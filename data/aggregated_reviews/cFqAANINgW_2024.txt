ID: cFqAANINgW
Title: Divide-and-Conquer Meets Consensus: Unleashing the Power of Functions in Code Generation
Conference: NeurIPS
Year: 2024
Number of Reviews: 12
Original Ratings: 5, 6, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1
Original Confidences: 4, 4, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1

Aggregated Review:
### Key Points
This paper presents FunCoder, a code generation framework that employs a divide-and-conquer strategy combined with functional consensus. FunCoder recursively breaks down programming tasks into smaller sub-functions, organized hierarchically, to achieve complex objectives. The framework mitigates error propagation by selecting functions with similar behaviors through consensus. Experimental results demonstrate that FunCoder outperforms state-of-the-art methods, achieving an average improvement of +9.8% across benchmarks like HumanEval, MBPP, xCodeEval, and MATH with models such as GPT-3.5 and GPT-4.

### Strengths and Weaknesses
Strengths:
- The method is conceptually clean and empirically effective, as evidenced by extensive experiments and ablation studies.
- FunCoder significantly enhances performance on both large proprietary models and smaller open models, contributing to reproducibility.
- The framework addresses the critical issue of code generation for complex tasks, which is a current bottleneck in the field.

Weaknesses:
- Important details regarding the divide-and-conquer approach are lacking, particularly in how the model determines function complexity and dependencies.
- The design of functionality similarity is flawed, as it oversimplifies the challenges of accurately inferring input domains and pre-conditions.
- The token length generated by the recursive decomposition can become a limiting factor, raising concerns about efficiency and computational costs.

### Suggestions for Improvement
We recommend that the authors improve the clarity of the divide-and-conquer strategy by providing more detailed explanations of how the model decides which functions to further divide and how it handles dependencies among sub-functions. Additionally, we suggest including a thorough analysis of the implementation costs associated with the recursive generation process. Addressing the limitations of functionality similarity and discussing the implications of token length in the context of complex problems would also enhance the paper's depth. Finally, we encourage the authors to conduct additional experiments that vary the depth of sub-problem generation to better understand its impact on overall performance.