ID: AN6WvJ24hw
Title: WBSan: Webassembly Bug Detection for Sanitization and Binary-Only Fuzzing
Conference: ACM
Year: 2024
Number of Reviews: 5
Original Ratings: -1, -1, -1, -1, -1
Original Confidences: -1, -1, -1, -1, -1

Aggregated Review:
### Key Points
This paper presents a WebAssembly (Wasm) binary sanitizer named “WBSan,” designed to detect memory bugs and undefined behaviors in Wasm binaries without requiring source code. The authors propose a combination of static analysis, binary instrumentation, and shadow memory techniques to address unique challenges in the Wasm ecosystem. The tool reportedly achieves superior bug detection rates, improved code coverage, and reduced false positives compared to existing sanitizers.

### Strengths and Weaknesses
Strengths:
- The paper is well-organized, clearly articulating the problem, methodology, experiments, and conclusions.
- The integration of shadow memory and custom instrumentation techniques represents a significant contribution to the field.
- The evaluation demonstrates WBSan's effectiveness in detecting bugs and improving code coverage.

Weaknesses:
- The comparison with the most recent methods is limited, as the latest reference is from 2022. More recent works should be included.
- The challenges in detection are not clearly articulated, particularly regarding the performance of existing methods listed in Table 1.
- The claim of limited access to source code needs concrete evidence to support the value of a binary-only detection mechanism.
- The paper lacks detailed explanations of how techniques like "dynamic memory boundary detection" and "red zone" insertion are specifically adapted for Wasm.
- The reported runtime overhead and binary size increase raise concerns about usability in resource-constrained environments.
- A high false positive rate of 49.2% for stack-buffer-overflows undermines the tool's reliability.

### Suggestions for Improvement
We recommend that the authors improve the clarity of the challenges in detection by providing detailed comparisons of existing methods in Table 1, including their performance in detecting various issues. Additionally, the authors should substantiate the claim regarding limited access to source code with concrete evidence. We suggest that the authors clarify how "dynamic memory boundary detection" and "Wasm shadow memory" have been adapted for Wasm, including a detailed explanation of the "red zone" mechanism. 

Furthermore, we recommend discussing the implications of the reported runtime overhead and binary size increase, particularly in low-bandwidth environments. To address the high false positive rate, the authors should propose enhancements to reduce this rate. Lastly, we encourage the authors to provide more technical details on the instrumentation process and how it can be replicated, as well as to clarify the evaluation methodology, including crash deduplication and coverage measurements.