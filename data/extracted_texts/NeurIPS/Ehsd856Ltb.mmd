# Revisiting K-mer Profile for Effective and Scalable Genome Representation Learning

Abdulkadir Celikkanat

Aalborg University

9000 Aalborg, Denmark

abce@cs.aau.dk

&Andres R. Masegosa

Aalborg University

9000 Aalborg, Denmark

arma@cs.aau.dk

&Thomas D. Nielsen

Aalborg University

9000 Aalborg, Denmark

tdn@cs.aau.dk

###### Abstract

Obtaining effective representations of DNA sequences is crucial for genome analysis. Metagenomic binning, for instance, relies on genome representations to cluster complex mixtures of DNA fragments from biological samples with the aim of determining their microbial compositions. In this paper, we revisit \(k\)-mer-based representations of genomes and provide a theoretical analysis of their use in representation learning. Based on the analysis, we propose a lightweight and scalable model for performing metagenomic binning at the genome read level, relying only on the \(k\)-mer compositions of the DNA fragments. We compare the model to recent genome foundation models and demonstrate that while the models are comparable in performance, the proposed model is significantly more effective in terms of scalability, a crucial aspect for performing metagenomic binning of real-world datasets.

## 1 Introduction

Microbes influence all aspects of our environment, including human health and the natural environment surrounding us. However, understanding the full impact of the microbes through the complex microbial communities in which they exist, requires insight into the composition and diversity of these communities .

Metagenomics involves the study of microbial communities at the DNA level. However, sequencing a complex microbial sample using current DNA sequencing technologies  rarely produces full DNA sequences, but rather a mixture of DNA fragments (called _reads_) of the microbes present in the sample. In order to recover the full microbial genomes, a subsequent binning/clustering step is performed, where individual DNA fragments are clustered together according to their genomic origins. This process is also referred to as _metagenomic binning_. The fragments being clustered during the binning process consist of contiguous DNA sequences (_contigs_) obtained from the reads through a so-called assembly process  (contigs are generally longer and less error-prone than the reads).

Metagenomic binning typically involves comparing and clustering DNA fragments using a distance metric in a suitable genome representation space. State-of-the-art methods for metagenomic binning typically rely on representations that include or build on top of the \(k\)-mer profiles of the contigs . These representations have mostly been studied from an empirical perspective , although general theoretical analyses into their representational properties have also been considered . With \(k=4\) (i.e., tetra-nucleotides) a \(256\)-dimensional vector is used to describe the genome, each entry in the vector encoding the frequency of a specific \(k\)-mer (e.g., ACTG, ATTT) in the genome sequence. The \(k\)-mer representation of a sequence thus has a fixed size and is independent of sequence length and downstream analysis tasks, providing a computationally efficient representation.

A more recent and popular line of research focuses on using approaches inspired by modern Large Language Models (LLMs) to derive more powerful representations of genome fragments. The goal is to replicate the success of LLMs used in natural language processing for genomic data. These models, known as genome foundation models, have seen numerous versions proposed recently [32; 16; 31].

Similarly to popular LLMs, existing genome foundation models utilize next-token prediction or masked-prediction approaches within transformer-based architectures, where the tokens to be predicted are the nucleotides composing the genome fragments. These models, akin to LLMs, enable trainable and contextualized representations that can be defined either in a task-dependent or task-independent manner . According to standardized benchmarks, the embeddings derived from these foundation models have the potential to offer substantial improvements over those based on \(k\)-mers . However, these embeddings are also computationally far more intensive, reducing their scalability in light of the massive amounts of data generated by modern sequencing technologies. For instance,  conducted \(k\)-mer-based metagenomic binning [28; 9] on samples from wastewater treatment plants, encompassing approximately \(1.9 10^{12}\) base pairs and resulting in the recovery of over 3700 high to medium quality clusters/metagenome-assembled genomes (MAGs).

In this paper, we demonstrate how \(k\)-mer-based embeddings of genome fragments provide a scalable and lightweight alternative to genome foundation models. We revisit the theoretical basis of \(k\)-mers and offer a theoretical characterization of the identifiability of DNA fragments based on their \(k\)-mer profiles. For non-identifiable fragments, we establish lower and upper bounds on their edit distance using the \(l_{1}\) distance between their respective \(k\)-mer profiles. These findings offer theoretical justifications for \(k\)-mer-based genome representations and hold potential significance beyond the scope of this study. Building on these theoretical insights, we propose a simple and lightweight model for learning embeddings of genome fragments using their \(k\)-mer representations.

We empirically assess the proposed embeddings on metagenomic binning tasks and compare their performance with large state-of-the-art genome foundation models. Our findings indicate that, while both sets of models produce comparable quality in terms of the MAGs recovered, the proposed models require significantly fewer computational resources. Figure 1 demonstrates this by showing the number of parameters in our \(k\)-mer embedding methods compared to those in the state-of-the-art genome foundation models. The \(k\)-mer-based embedding approaches involve models with several orders of magnitude fewer parameters.

The main contributions of the paper can be summarized as follows:

* We provide a theoretical analysis of the \(k\)-mer space, offering insights into why \(k\)-mers serve as powerful and informative features for genomic tasks.
* We demonstrate that models based on \(k\)-mers remain viable alternatives to large-scale genome foundation models.
* We show that scalable, lightweight models can provide competitive performance in the metagenomic binning task, highlighting their efficiency in handling complex datasets.

The datasets and implementation of the proposed architectures can be found at the following address: https://github.com/abdcelikkanat/revisitingkmers.

## 2 Background and Related Works

When analyzing the microbial content of biological samples (e.g., soil samples or samples from the intestine), we deal with genomic material originating from multiple different species. For such

Figure 1: Number of parameters of the different evaluated models (\(_{10}\)-scale).

analyses, the general workflow consists of sequencing the DNA fragments in the sample, producing electrical signals that are subsequently converted into sequences of letters corresponding to the four DNA bases (A, C, T, G). During the sequencing process, the full DNA sequences are fragmented into smaller subsequences (called _reads_), resulting in millions or even billions of reads for each sample. Depending on the sequencing technology being used, reads are typically either classified as short reads (\(100\)-\(150\) bases) or long reads (2k-30k bases), and while long reads are generally preferable, they are also more prone to translation errors.

Identifying the microbial composition of a sample involves clustering the DNA fragments according to their genomic origin (a process referred to as _metagenmoic binning_).1 Clustering the DNA fragments relies not only on a representation of the genome fragments, but typically also includes information about the read coverages in the sample, reflecting the relative abundances of the individual species that make up the sample.

For the current paper, the focus is on representations of DNA fragments. Existing works on metagenomic binning typically either rely on predefined features (e.g., ) or, more recently, on genome foundation models (e.g., ) for representing the DNA fragments. Predefined features for metagenomic binning include the \(k\)-mer frequencies of the genome (e.g., for \(k=4\), the genome is represented by a 256-dimensional vector), which have shown to exhibit a degree of robustness across different areas of the same genome . These \(k\)-mer vectors/profiles are either used as direct representations of the DNA fragments as in, e.g., METABAT2, VAMP , and SemiBin2  or is used for learning \(k\)-mer-based embeddings  in the spirit of word2vec.

More recently, genome foundation models have also been proposed, which include DNABERT , DNABERT-2 , HyenADNA , and DNABERT-S . These foundation models provide embedding of the raw DNA fragments as represented by the sequences of four nucleotide letters.

In this work, we show that although the contextualized embeddings produced by foundation models provide a strong basis for downstream genome analysis tasks, the complexity of the models also makes them less scalable to the vast amounts of data currently being generated by the state-of-the-art sequencing technologies. Consequently, we consider more lightweight models and explore the use and theoretical basis for models relying on \(k\)-mer representations of DNA fragments.

## 3 \(k\)-mer embeddings

As we discussed in the previous section, the metagenomic binning problem aims to cluster the sequences (i.e. reads) according to their respective genomes. For the sake of the argument, we denote with \(:[K]\) the function that maps each read to the (index) ground-truth genome from which the read originates. Here, we use \(\) to denote the set of reads where each read is supposed to originate from one of the \(K\) genomes.

Performing clustering directly on the reads has been shown to provide very poor performance , mainly because reads lie in a complex manifold in a very high dimensional space. A well-tested approach is to instead _embed_ each of the objects in a lower dimensional space, known as the _embedding or latent space_, whose structure is much closer to Euclidean space, where clustering is far simpler to perform. More formally, we characterize the problem as follows:

**Problem Definition.** Let \(^{+}\) be a finite set of reads with a genome mapping function \(\) where \(=\{A,C,T,G\}\). For a given threshold value \(^{+}\), the objective is to learn an embedding function \(:^{d}\) that embeds reads into a low-dimensional metric space \((,d_{})\), usually a Euclidean space, such that \(d_{}((),())\) if and only if \(()=()\) for all reads \(,\) where \(d||\).

Once we establish an embedding function like the one described earlier, it becomes, in principle, straightforward to employ a simple clustering algorithm to bin or group the reads. However, for this purpose, the embedding function \(\) must be capable of distinguishing the intrinsic features of the various genomes, producing similar latent representations for reads that originate from the same genomes. In the following subsection, we will discuss novel theoretical arguments that help to better understand why \(k\)-mer profiles are a powerful representation of reads.

### k-mers are a powerful representation of reads

The use of \(k\)-mer profiles to represent reads helps overcome several challenges encountered during the clustering or binning of reads. These challenges include (i) the variation in read lengths in practical scenarios, such as in genome sequencing where read lengths can differ significantly, (ii) ambiguity in read direction, which is a result of reads lacking inherent directionality, complicating the analysis, and (iii) the equivalence of a DNA sequence to its complementary sequence because DNA is composed of two complementary strands, meaning the information from one strand corresponds to that from its complementary strand.

An initial important question concerns the _identifiability_ of reads, which examines to what extent different reads share the same \(k\)-mer profiles. We will call the reads that can be uniquely reconstructed from their given \(k\)-mer profile as **identifiable** and this is crucial because if many reads possess the same \(k\)-mer profile, they will invariably be grouped into the same cluster, potentially leading to the loss of significant information. In this context, Ukkonen et al.  conjectured in their study on the string matching problem that two sequences sharing the same \(k\)-mer profile could be transformed into one another through two specific operations, and this claim was later proved by Pevzner . However, these specified operations fail to consider cases where sequences include repeated overlapping occurrences of the same \(k\)-mer.

In this regard, in Theorem 3.1, we demonstrate that a read can be perfectly reconstructed from its \(k\)-mer profile under certain conditions, which become less restrictive with larger \(k\) values. In the following theorem, we use \(r_{i} r_{j}\), with \(i<j\), to denote any subsequence of a read \(r\) that includes consecutive nucleotides from position \(i\) to position \(j\).

**Theorem 3.1**.: _Let \(\) be a read of length \(\). There exists no other distinct read having the same \(k\)-mer profile if and only if it does not satisfy any of the following conditions:_

1. \(r_{1} r_{k-1}=r_{-k-2} r_{}\) _and_ \(r_{i} r_{1}\) _for some_ \(1<i<-k-2\)_._
2. \(r_{i} r_{i+k-2}=r_{j} r_{j+k-2}\) _and_ \(r_{g} r_{g+k-2}=r_{h} r_{h+k-2}\) _for some indices_ \(1 i<g<j<h-k+2\) _where_ \(r_{i+k-1} r_{g-1} r_{j+k-1} r_{h-1}\)_._
3. \(r_{i} r_{i+k-2}=r_{j} r_{j+k-2}=r_{h} r_{h+k-2}\) _for some indices_ \(1 i<j<h-k+2\) _where_ \(r_{i+k-1} r_{j-1} r_{j+k-1} r_{h-1}\)_._

Proof.: The proof is omitted due to the limitation on the number of pages. Please see the appendix. 

It is important to note that it is always possible to find an optimal \(k^{*}\) value that ensures that each read does not meet any of the previously mentioned conditions and, in consequence, becomes identifiable. Clearly, when \(k\) is equal to the length of the reads, all reads become identifiable. However, as \(k\) increases, the \(k\)-mer profiles become more prone to errors, and it will be harder to identify the underlying patterns in the reads (in the extreme case scenario where \(k\) equals the length of the reads, each read will correspond to a unique \(k\)-mer). Thus, using large values of \(k\) is impractical. However, the results show that even with smaller \(k\) values, identifiability could still be potentially achieved if not by all but by some of the reads. We hypothesize that the effectiveness of \(k\)-mer representations stems, in part, from this fact.

Another perspective to consider is the extent to which two similar reads share a similar \(k\)-mer profile. The identifiability approach from the previous result addresses this issue by establishing that if two reads have identical profiles, then the reads themselves are identical. However, identifiability is limited by the conditions outlined in Theorem 3.1, which may not always be met. The observation given in Proposition 3.2 provides a broader and more applicable finding.

It demonstrates that if two \(k\)-mers are similar according to the \(l_{1}\) distance, then the corresponding reads are also similar according to the Hamming distance in the read space. It is important to note that both the \(l_{1}\) and Hamming distances are natural measures for evaluating similarity in this context. Technically speaking, we show that the \(l_{1}\) distance between \(k\)-mer profiles can be upper and lower bounded by the Hamming distance between the corresponding identifiable reads, so they are Lipschitz equivalent spaces. In the next result, \(c:^{k}\) denotes the function showing the number of occurrences of a given \(k\)-mer in a given read. For simplicity, we use the notation, \(c_{}\), to indicate the \(k\)-mer profile vector of a read \(r\) whose entries are ordered lexicographically. In other words, \(c_{}()\) is the number of appearances of \(^{k}\) in read \(\).

**Proposition 3.2**.: _Let \(M_{1}=(_{},d_{})\) and \(M_{2}=(|^{k}|,\|\|_{1})\) be the metric spaces denoting the set of identifiable reads and their corresponding \(k\)-mer profiles equipped with edit and \(_{1}\) distances, respectively. The \(k\)-mer profile function, \(c:M_{1} M_{2}\), mapping given any read, \(\), to its corresponding \(k\)-mer profile, \(c_{}:=c()\), is a Lipschitz equivalence, i.e. it satisfies_

\[,^{}\ _{l}d_{}( ,)\|c_{}-c_{}\|_{1}_{u} d_{}(,)\] (1)

_for \(_{l}=1/\) and \(_{u}=k||^{k}\), so \(M_{1}\) and \(M_{2}\) are Lipschitz equivalent._

Proof.: The proof is omitted due to the limitation on the number of pages. Please see the appendix. 

Unfortunately, when one runs a clustering algorithm directly on top of the _raw_\(k\)-mer profiles, the results are not competitive as demonstrated in numerous studies, see, e.g., . Instead, we will consider methods for learning embeddings of \(k\)-mer profiles and, more generally, genome sequences.

### Linear read embeddings

Below we consider two simple genome sequence models defining the embedding of a read as a linear combination of the \(k\)-mer representations. The first model (\(k\)-mer profile) does not involve any learning procedure and it is simply defined by the \(k\)-mer counts of the read, whereas the second model (Poisson model) expands on the \(k\)-mer profile model by explicitly representing the dependencies between \(k\)-mers. Both models will serve as baselines for more complex models.

\(k\)**-mer profile:** First, consider the definition of \(k\)-mer profiles:

\[_{}():=_{^{k}}c_{ }()_{}\] (2)

where \(_{}\) represents the canonical basis vector for the \(k\)-mer \(^{k}\), i.e. (\(_{}\{(u_{1},,u_{|^{k}|})\{0,1\}^{| ^{k}|}:_{i}u_{i}=1\}\) ).

As previously mentioned, our primary objective is to represent reads in a lower-dimensional space, where their relative positions in a latent space reflect their underlying similarities. By Equation 2, the \(k\)-mer profile of a read can also be considered as its embedding vector, but its entries are not independent. In other words, if we change one letter in a read, it can affect at most \(k\) different \(k\)-mer counts. In this regard, it might be possible to learn better representations than simple \(k\)-mer profiles.

**Poisson model:** For a given read \(:=(r_{1} r_{})\), it is easy to see that the consecutive \(k\)-mers in the read are not independent. For instance, the \(k\)-mers located at position indices \(i\) and \(i+1\), (i.e. \(:=r_{i} r_{i+k-1}\) and \(:=r_{i+1} r_{i+k}\)), share the same substring \(r_{i+1} r_{i+k-1}\), which highlights the inherent dependencies between \(k\)-mers. Hence, we will learn the representation, \(_{}\), of each \(k\)-mer, \(\), instead of using the canonical basis vectors. We propose to model the co-occurrence frequency of specific \(k\)-mer pairs within a fixed window size, \(\), using the Poisson distribution. In other words, \(o_{,} Pois(_{,})\), where \(o_{,}\) indicates the number of co-appearances of \(k\)-mers, \(:=r_{i} r_{i+k-1}\) and \(:=r_{j} r_{j+k-1}\) for \(|i-j|\).

In order to achieve close representations for highly correlated \(k\)-mers, and distant embeddings for the dissimilar ones, we define the rate of the Poisson distribution as follows:

\[_{,}:=(-\|_{}-_{}\|^{2}).\] (3)

The loss function used for training the embeddings with respect to the reads is simply defined in terms of the Poisson distribution model of the \(k\)-mer pairs:

\[_{}\{o_{,}\}_{, ^{k}}|\{_{}\}_{^{k} }\!:=\!\!_{^{k}}\!_{ ^{k}}o_{,}\|_{}- _{}\|^{2}+(-\|_{}-_ {}\|^{2})\] (4)

where \(o_{,}\) is the average number of co-occurrences of \(k\)-mers \(\) and \(\) per read within a window of size \(\) in the dataset. Once we have obtained the \(k\)-mer embeddings, we can obtain the read embeddings by combining the \(k\)-mer embeddings with their respective occurrence counts, as given in Equation 2. More specifically, the embedding of read, \(\), is given by

\[_{}()=^{k}}c _{}()}_{^{k}}c_{}( )_{}\] (5)

where \(\{_{}\}_{^{k}}\) corresponds to the learned \(k\)-mer embeddings of Eq. 4.

### Non-linear read embeddings

In the experimental section, we will show that the linear \(\)-mer embeddings described previously outperform raw \(\)-mer profiles in metagenomic binning tasks. However, the literature on machine learning frequently emphasizes that non-linear embeddings typically provide superior results when the data, such as genomic sequences in this context, exist in complex high-dimensional manifold spaces .

We design a simple and efficient neural network architecture utilizing self-supervised contrastive learning. Our model consists of two linear layers, and the first one takes \(k\)-mer profile features as input, projecting them into a \(512\)-dimensional space. A sigmoid activation function is applied, followed by a batch normalization operation and a dropout with a ratio of \(0.2\). The second layer maps them into the final \(256\)-dimensional embedding space.

Our approach is inspired by previous methods in the context of metagenomic binning at the contig level . The primary aim here is not to introduce a novel methodology for learning embeddings but to demonstrate that simple non-linear embeddings, built upon \(k\)-mer representations, can match the effectiveness of existing state-of-the-art genomic foundation models for metagenomic binning tasks while being significantly more scalable.

The methodology is graphically depicted in Figure 2. Initially, we create positive and negative pairs of read segments using the dataset provided. To create a positive pair, we split an existing read into two equal-sized segments. Conversely, a negative pair is formed by combining two segments originating from the splitting of two distinct reads chosen at random. Subsequently, for each pair, we calculate the \(k\)-mer profile for the two segments in the pair. These two \(k\)-mer profiles are then input into the same neural network, which maps them to two vectors within the embedding space. The loss function evaluates the quality of these two embeddings; it penalizes distant embeddings in positive pairs and close embeddings in negative pairs. The learning process involves optimizing the neural network's weights to minimize this loss function across numerous positive and negative samples.

Let \(=\{_{i}\}_{i=1}^{N}\) be the set of reads and \(_{i}^{l}\) and \(_{i}^{r}\) are the segments indicating the left and right halves of read \(_{i}\). As described above, we use these segments to construct the positive and negative pair samples required for the self-supervised contrastive learning procedure. Let \(\{(_{i}^{*},_{j}^{*},y_{ij})\}_{(i,j)}\) be the set of triplets where \([N][N]\) is the index set for the pairs, and the symbol, \(y_{ij}\{0,1\}\) is used to denote whether \((_{i}^{*},_{j}^{*})\) is a positive sample (i.e. \(+1\)), or negative (i.e. \(0\)). The positive label means that the pair corresponds to the left and right segments of the same read, while a negative label indicates they are segments from different reads. Then, we define the loss function as follows:

\[_{}\{y_{ij}\}_{(i,j)}| :=-|}_{(i,j)}y_{ij} p_{ij} +(1-y_{ij})(1-p_{ij})\] (6)

where \(\) indicates the all trainable weights of the neural network. Here, the success probability, \(p_{ij}\), corresponds to the case of a positive pair, occurring when \(y_{ij}=+1\), and computed as:

\[p_{ij}=(-\|_{}(_{i})-_{}(_{j})\|^{2})\]

where \(_{}(_{i}^{*})\) denotes the output embedding of the neural network for segment \(_{i}^{*}\).

Figure 2: Illustration of the non-linear \(k\)-mer embedding approach described in Section 3.3.

Given a large number of distinct genomes (i.e., clusters), it is highly likely that _negative_ pairs consist of segments from different genomes, as they originate from different reads. Conversely, _positive_ pairs are composed of segments from the same genome, as they originate from the same read. Consequently, the neural network's embedding function will learn to produce similar embeddings for \(k\)-mer profiles belonging to the same genome and different embeddings for \(k\)-mer profiles belonging to different genomes. As demonstrated in the next section, this straightforward approach built on \(k\)-mer profiles competes effectively with state-of-the-art genomic foundation models, which involve neural networks with several orders of magnitude more parameters.

## 4 Experiments

In this section, we will provide the details regarding the experiments, datasets, and baseline approaches that we consider to assess the performance of the proposed linear and non-linear models.

**Datasets**. We utilize the same publicly available datasets used to benchmark the genome foundation models . The training set consists of \(2\) million pairs of non-overlapping DNA sequences, each \(10,000\) bases in length, constructed by sampling from the dataset, including \(17,636\) viral, \(5,011\) fungal, and \(6,402\) distinct bacterial genomes from GenBank . For model evaluation, we use six datasets derived from the CAMI2 challenge data , representing marine and plant-associated environments and including fungal genomes. These datasets propose realistic and complex reads, making them one of the most utilized benchmarks for the metagenomics binning task. Additionally, the synthetic datasets consist of randomly sampled sequences from the fungi and viral reference genomes, excluding any samples from the training data .

**Baselines and proposed models.** For our experiments, we have employed the recent genome foundation models to assess the performance of our approach. (i) kmer is one of the most widely used baselines, and it also serves as a fundamental component of our model. The DNA sequences are represented as \(4\)-mer profiles _Tetranucleotide Frequencies_ given in Eq. 2 so each read is represented by a \(256\)-dimensional vector. (ii) HyenADNA  is a genome foundation model, HyenADNA, pre-trained on the Human Reference Genome  with context lengths up to \(10^{6}\) tokens at single

Figure 3: Evaluation of the models on multiple datasets for the metagenomic binning task. Each color represents the number of clusters within a specific \(F_{1}\) score range, and the number of clusters with the highest quality is highlighted in dark blue.

nucleotide resolution. (iii) DNABERT-2  is another foundation model pre-trained on multi-species genomes, and it proposes Byte Pair Encoding (BPE) for DNA language modeling to address the computational inefficiencies related to \(k\)-mer tokenization. It also incorporates various techniques, such as Attention with Linear Biases (ALiBi) and Low-Rank Adaptation (LoRA), to address the limitations of current DNA language models. (iv) DNEBERT-S  aims to generate effective species-aware DNA representations and relies on the proposed Manifold Instance Mixup (MI-Mix) and Curriculum Contrastive Learning approaches. It relies on the pre-trained DNABERT-2 model as the initial point of contrastive training. (v) Ours(kmer-\(l_{1}\)) is similar to the kmer approach presented in (i), but it uses \(l_{1}\) distance instead of the cosine-similarity distance so we will also name the first one as Ours(kmer-cosine) to distinguish both models. (vii) Ours(pois) refers to the Poisson approach described in Section 3.2. (vi) Ours(nl) refers to the non-linear \(k\)-mer embedding approach based on self-supervised constructive learning described in Section 3.3.

**Parameter Settings.** Our proposed models were trained on a cluster equipped with various NVIDIA GPU models. For the optimization of our models, we employed the Adam optimizer with a learning rate of \(10^{-3}\). We used smaller subsets of the dataset for training our models, and we sampled \(10^{4}\) reads for Ours(pois) and \(10^{6}\) sequences for Ours(nl). The Ours(nl) model was trained for \(300\) epochs with a mini-batch size of \(10^{4}\), while Ours(pois) was trained for \(1000\) epochs using full-batch updates and window size of \(4\). Since we incorporated the contrastive learning strategy for Ours(nl), we randomly sampled \(200\) read halves to form the negative instances for each positive sample (one half of a read). We have set \(k=4\) and the final embedding dimension to \(256\) for our all models. Following the experimental set-up of , we used the publicly available pre-trained versions of the baseline genome foundation models in the Hugging Face platform.

### Metagenomics Binning Task

We assess the performance of the models based on the number of detected species/clusters and these clusters are classified into five different quality levels in terms of their \(F_{1}\) scores. Our methods and each baseline approach generate embeddings for the reads, and we cluster these read representations by following the work  with the modified K-Medoid algorithm. We refer readers to the cited work for further details on this approach. In line with standard practices in the field, we use cosine similarity for the baseline methods to measure the similarity between read embeddings required for the K-Medoid algorithm. For Ours(kmer-\(l_{1}\)), we employed the \((-dist(,))\) function with \(l_{1}\) distance, while Euclidean distance was used for Ours(pois) and Ours(nl).

Figure 3 highlights the number of detected bins/clusters across different quality levels. For instance, the number of bins/species whose \(F_{1}\) scores above \(0.9\) is represented in dark blue while those with \(F_{1}\) scores between \(0.5\) and \(0.6\) are highlighted in red. Since we observe that the deviation in the number of detected species in most cases changes between at most \( 5\), the error bars were not included.

The results underscore the effectiveness of \(k\)-mer features, which are central to our paper's focus. More specifically, as it was observed in the study , \(k\)-mer feature vectors (i.e., kmer-cosine) surpass some genome foundation models like HyenaDNA and DNABERT-2. Furthermore, we highlight the importance of choosing an appropriate similarity measure by showcasing the performance of the Ours(kmer-\(l_{1}\)) variant. We note that Proposition 3.2 establishes a link between \(k\)-mer space equipped with \(l_{1}\) distance and read space with edit or Hamming distance. Thus, leveraging an appropriate metric in defining the similarities between reads in the binning stage also contributes to the performance improvement of Ours(kmer-\(l_{1}\)).

Despite the Ours(nl) model's lightweight design compared to recent genome foundation architectures, our non-linear embeddings effectively identify both high and low-quality bins. In the metagenomics binning task, for practical purposes, the high-quality bins are typically prioritized (depicted in dark blue), and our model demonstrates comparable performance to the DNABERT-S model on both Synthetic and Plant datasets, and it also outperforms DNABERT-S on the Marine dataset. Overall, our findings emphasize the efficacy of lightweight non-linear embeddings built on top of \(k\)-mer profiles.

### Ablation Study

We conduct a series of ablation studies in order to gain deeper insights into different components of the proposed architectures. We will start first by examining the impact of the parameter \(k\) which is used to define the \(k\)-mer profiles. It plays a fundamental role in the paper because all the model variants that we introduced rely on it. As also explained in Section 3, the selection of \(k\) also influences the identifiability of reads. In this regard, we evaluate the performance of the Ours(kmer-\(l_{1}\)) model across various \(k\) values. Figure 4 shows the number of high-quality bins (i.e., \(F_{1}>0.9\)) for different \(k\) settings and reveals that the optimal performance is generally achieved when \(k\) is set to \(4\) on different datasets. It also holds true across our different architectures, so we have set \(k=4\) in our models.

We also examine the influence of the output dimension size on the performance for the Ours(nl) model. We employed a very shallow architecture as described in Section 3.3, so the output dimension size plays a vital role in the computational cost and performance. As can be observed in Figure 5, the increase in dimension size also positively contributes to the number of detected high-quality bins, and the performance mostly saturates after \(2^{7}\). In order to have a fair comparison with the baselines, we also used \(2^{8}\) as an output dimension size in our architectures.

For the Ours(nl) architecture, it is very natural to use Bernoulli distribution to model whether a given pair of reads belongs to the same genome or not. However, different organisms might share similar regions in their genetic codes; therefore, assuming binary interactions might not suit well in every situation. In this regard, we rewrite Eq. 6 by Poisson distribution that we also employed for the Ours(poi) architecture as follows:

\[^{poisson}_{}:=|}_{(i,j) }-y_{ij}_{ij}+_{ij}\]

where \(_{ij}:=(-\|_{}(_{i})-_{ }(_{j})\|^{2})\) and \(y_{ij}\{0,1\}\) denotes if reads \(i\) and \(j\) belong to the same genome or not. We also test the loss function proposed by , which we refer as _hinge loss_:

\[^{hinge}_{}:=|}_{(i,j) }y_{ij}\|_{}(_{i})-_{ }(_{j})\|^{2}+(1-y_{ij})\{0,1-\|_{ {nl}}(_{i})-_{}(_{j})\|\}^{2}\]

Table 1 outlines the number of high-quality bins, and the Bernoulli and Poisson loss functions show comparable performances. On the other hand, we observe that it is possible to obtain even higher scores using the Hinge loss. However, it fails to have a probabilistic interpretation.

Figure 4: Influence of parameter \(k\) on the Ours(kmer-\(l_{1}\)) model across different datasets.

Figure 5: Influence of dimension size \((d)\) on the Ours(nl) model across different datasets.

## 5 Conclusion

In this study we have shown the efficacy of non-linear \(k\)-mer-based embeddings for metagenomic binning tasks, providing a compelling alternative to more recently proposed complex genome foundation models. Our work revisits and expands the theoretical framework surrounding \(k\)-mers, specifically addressing the identifiability of DNA fragments through their \(k\)-mer profiles and establishing new bounds on the distances defining relevant metric spaces. This theoretical insight not only reinforces the validity of using \(k\)-mer-based approaches for genome representation but also highlights their broader applicability in genomic research, such as taxonomic profiling/classification [22; 26] and phylogenetic analysis .

The lightweight model being proposed in the paper, grounded in these theoretical principles, shows considerable promise in the field of metagenomic binning. It achieves a performance comparable to that of state-of-the-art genome foundation models while requiring orders of magnitude fewer computational resources. This feature is especially important for large-scale genomic analyses that are currently driven by recent advances in sequencing technologies and where computational efficiency is paramount.

### Limitations and Societal Impact

The ability to scale up metagenomic binning holds the potential for broader societal impacts through an improved understanding of the diversity and function of the microbial communities that influence our health and environment. Insights into these communities can also play an essential role in achieving the sustainability goals [24; 1], in particular good health and well-being (SDG-3), life below water (SDG-14), and life on land (SDG-15), to name a few. The current study is partly limited by the experimental setup, which is only based on synthetically generated genomic data following the experimental setup of similar studies such as [31; 32]. While the discussions about computational resources are not expected to be significantly affected by the type of data being used, the evaluations and comparisons of the quality of the recovered genomes most likely will. For instance, samples containing genomes of closely related species or strains of the same species will generally be more difficult to separate into distinct clusters. As part of future work, we plan to pursue a more rigorous analysis of the binning quality using long-read sequences from real-world data.