# A Regularized Conditional GAN for Posterior Sampling in Image Recovery Problems

Matthew C. Bendel

Dept. ECE

The Ohio State University

Columbus, OH 43210

bendel.8@osu.edu

&Rizwan Ahmad

Dept. BME

The Ohio State University

Columbus, OH 43210

ahmad.46@osu.edu

&Philip Schniter

Dept. ECE

The Ohio State University

Columbus, OH 43201

schniter.1@osu.edu

###### Abstract

In image recovery problems, one seeks to infer an image from distorted, incomplete, and/or noise-corrupted measurements. Such problems arise in magnetic resonance imaging (MRI), computed tomography, deblurring, super-resolution, inpainting, phase retrieval, image-to-image translation, and other applications. Given a training set of signal/measurement pairs, we seek to do more than just produce one good image estimate. Rather, we aim to rapidly and accurately sample from the posterior distribution. To do this, we propose a regularized conditional Wasserstein GAN that generates dozens of high-quality posterior samples per second. Our regularization comprises an \(_{1}\) penalty and an adaptively weighted standard-deviation reward. Using quantitative evaluation metrics like conditional Frechet inception distance, we demonstrate that our method produces state-of-the-art posterior samples in both multicoil MRI and large-scale inpainting applications. The code for our model can be found here: https://github.com/matt-bendel/rcGAN.

## 1 Introduction

We consider image recovery, where one observes measurements \(=()\) of the true image \(\) that may be masked, distorted, and/or corrupted \(\) with noise, and the goal is to infer \(\) from \(\). This includes linear inverse problems arising in, e.g., deblurring, super-resolution, inpainting, colorization, computed tomography (CT), and magnetic resonance imaging (MRI), where \(=+\) with known linear operator \(\) and noise \(\). But it also includes non-linear inverse problems like those arising in phase-retrieval and dequantization, as well as image-to-image translation problems. In all cases, it is impossible to perfectly infer \(\) from \(\).

Image recovery is often posed as finding the single "best" recovery \(}\), which is known as a _point estimate_ of \(\). But point estimation is problematic due to the _perception-distortion tradeoff_, which establishes a fundamental tradeoff between distortion (defined as some distance between \(}\) and \(\)) and perceptual quality (defined as some distance between \(}\) and the set of clean images). For example, the minimum mean-squared error (MMSE) recovery \(}_{}\) is optimal in terms of \(_{2}\) distortion, but can be unrealistically smooth. Although one could instead compute an approximation of the maximum a posteriori (MAP) estimate  or minimize some combination of perceptual and distortion losses, it's unclear which combination would be most appropriate.

Another major limitation with point estimation is that it's unclear how certain one can be about the recovered \(}\). For example, with deep-learning-based recovery, it's possible to hallucinate a nice-looking \(}\), but is it correct? Quantifying the uncertainty in \(}\) is especially important in medical applications such as MRI, where a diagnosis must be made based on the measurements \(\). Rather than simply reporting our best guess of whether a pathology is present or absent based on \(}\), we might want to report the probability that the pathology is present (given all available data).

Yet another problem with point estimation is that the estimated \(}\) could pose issues with fairness . For example, say we are inpainting a face within an image. With a racially heterogeneous prior distribution, \(}_{}\) (being the posterior mean) will be biased towards the most predominant race. The same will be true of many other point estimates \(}\).

To address the aforementioned limitations of point estimation, we focus on _generating samples from the posterior distribution_\(p_{|}(|)\), which represents the complete state-of-knowledge about \(\) given the measurements \(\). The posterior correctly fuses prior knowledge with measurement knowledge, thereby alleviating any concerns about fairness (assuming the data used to represent the prior is fairly chosen ). Furthermore, the posterior directly facilitates uncertainty quantification via, e.g., pixel-wise standard deviations or pathology detection probabilities (see Appendix A). Also, if it was important to report a single "good" recovery, then posterior sampling leads to an easy navigation of the perception-distortion tradeoff. For example, averaging \(P 1\) posterior samples gives a close approximation to the less-distorted-but-oversmooth \(}_{}\) with large \(P\) and sharp-but-more-distorted \(}\) with small \(P\). Additionally, posterior sampling unlocks other important capabilities such as adaptive acquisition  and counterfactual diagnosis .

Concretely, given a training dataset of image/measurement pairs \(\{(_{t},_{t})\}_{t=1}^{T}\), our goal is to learn a generating function \(G_{}\) that, for a new \(\), maps random code vectors \((,)\) to posterior samples \(}=G_{}(,) p_{|}( |)\). There exist several well-known approaches to this task, with recent literature focusing on conditional generative adversarial networks (cGANs) [7; 8; 9; 10], conditional variational autoencoders (cVAEs) [11; 12; 13], conditional normalizing flows (cNFs) [14; 15; 16], and score/diffusion/Langevin-based generative models [17; 18; 19; 20; 21]. Despite it being a long-standing problem, posterior image sampling remains challenging. Although score/diffusion/Langevin approaches have dominated the recent literature due to advances in accuracy and diversity, their sample-generation speeds remain orders-of-magnitude behind those of cGANs, cVAEs, and cNFs.

We choose to focus on cGANs, which are typically regarded as generating samples of high quality but low diversity. Our proposed cGAN tackles the lack-of-diversity issue using a novel regularization that consists of supervised-\(_{1}\) loss plus an adaptively weighted standard-deviation (SD) reward. This is not a heuristic choice; we prove that our regularization enforces consistency with the true posterior mean and covariance under certain conditions.

Experimentally, we demonstrate our regularized cGAN on accelerated MRI and large-scale face completion/inpainting. We consider these applications for three main reasons. First, uncertainty quantification in MRI, and fairness in face-generation, are both of paramount importance. Second, posterior-sampling has been well studied for both applications, and fine-tuned cGANs  and score/Langevin-based approaches [19; 20] are readily available. Third, the linear operator "\(\)" manifests very differently in these two applications,1 which illustrates the versatility of our approach. To quantify performance, we focus on conditional Frechet inception distance (CFID) , which is a principled way to quantify the difference between two high-dimensional posterior distributions, although we also report other metrics. Our results show the proposed regularized cGAN (rcGAN) outperforming existing cGANs [8; 23; 9] and the score/diffusion/Langevin approaches from  and  in all tested metrics, while generating samples \( 10^{4}\) times faster than [19; 20].

## 2 Problem formulation and background

We build on the Wasserstein cGAN framework from . The goal is to design a generator network \(G_{}:\) such that, for fixed \(\), the random variable \(}=G_{}(,)\) induced by \( p_{}\) has a distribution that best matches the posterior \(p_{|}(|)\) in Wasserstein-1 distance. Here, \(\), \(\), and \(\) denote the sets of \(\), \(\), and \(\), respectively, and \(\) is drawn independently of \(\).

The Wasserstein-1 distance can be expressed as

\[W_{1}(p_{|}(,),p_{|}(,))= _{D L_{1}}_{|}\{D(,)\}- _{|}\{D(},)\},\] (1)

where \(L_{1}\) denotes functions that are 1-Lipschitz with respect to their first argument and \(D:\) is a "critic" or "discriminator" that tries to distinguish between true \(\) and generated \(}\) given \(\)Since we want the method to work for typical values of \(\), we define a loss by taking an expectation of (1) over \( p_{}\). Since the expectation commutes with the supremum in (1), we have 

\[}\{W_{1}(p_{}(,),p_{}(,))\} =_{D L_{1}}}}\{D(,) \}-}}\{D(},)\}\] (2) \[=_{D L_{1}}}}\{D(,)-D(G_{}(,),)\}.\] (3)

In practice, \(D\) is implemented by a neural network \(D_{}\) with parameters \(\), and \((,)\) are trained by alternately minimizing

\[_{}(,)}}\{D_{}(,)-D_{}(G_{}( ,),)\}\] (4)

with respect to \(\) and minimizing \(-_{}(,)+_{}( {})\) with respect to \(\), where \(_{}()\) is a gradient penalty that is used to encourage \(D_{} L_{1}\). Furthermore, the expectation over \(\) and \(\) in (4) is replaced in practice by a sample average over the training examples \(\{(_{t},_{t})\}_{t=1}^{T}\).

One of the main challenges with the cGAN framework in image recovery problems is that, for each measurement example \(_{t}\), there is only a single image example \(_{t}\). Thus, with the previously described training methodology, there is no incentive for the generator to produce diverse samples \(G(,)|_{ p_{z}}\) for a fixed \(\). This can lead to the generator learning to ignore the code vector \(\), which causes a form of "mode collapse."

Although issues with stability and mode collapse are also present in _unconditional_ GANs (uGANs) or discretely conditioned cGANs , the causes are fundamentally different than in continuously conditioned cGANs like ours. With continuously conditioned cGANs, there is only _one_ example of a valid \(_{t}\) for each given \(_{t}\), whereas with uGANs there are many \(_{t}\) and with discretely conditioned cGANs there are many \(_{t}\) for each conditioning class. As a result, most strategies that are used to combat mode-collapse in uGANs [26; 27; 28] are not well suited to cGANs. For example, mini-batch discrimination strategies like MBSD , where the discriminator aims to distinguish a mini-batch of true samples \(\{_{t}\}\) from a mini-batch of generated samples \(\{}_{t}\}\), don't work with cGANs because the posterior statistics are very different than the prior statistics.

To combat mode collapse in cGANs, Adler & Oktem  proposed to use a three-input discriminator \(D^{}_{}: \) and replace \(_{}\) from (4) with the loss

\[^{}_{}(,) }}D^{ }_{}(,G_{}(_{1},),)+ D^{}_{}(G_{}(_{2},), ,)\] \[-D^{}_{}(G_{}(_{1}, {y}),G_{}(_{2},),)},\] (5)

which rewards variation between the first and second inputs to \(D^{}_{}\). They then proved that minimizing \(^{}_{}\) in place of \(_{}\) does not compromise the Wasserstein cGAN objective, i.e., \(_{}^{}_{}( ,)=_{}_{}(,)\). As we show in Section 4, this approach does prevent complete mode collapse, but it leaves much room for improvement.

## 3 Proposed method

### Proposed regularization: supervised-\(_{1}\) plus SD reward

We now propose a novel cGAN regularization framework. To train the generator, we propose to solve

\[_{}\{_{}_{}(,)+_{1,,P_{}}(,_{})\}\] (6)

with appropriately chosen \(_{},_{}>0\) and \(P_{} 2\), where the regularizer

\[_{1,,P_{}}(,_{}) _{1,P_{}}()-_{} _{,P_{}}()\] (7)

is constructed from the \(P_{}\)-sample supervised-\(_{1}\) loss and standard-deviation (SD) reward terms

\[_{1,P_{}}() }}_{} \|-}_{(P_{})}\|_{1}}\] (8) \[_{,P_{}}() }(P_{}-1)} }_{i=1}^{P_{}}_{1},,_{p}, }}\|}_{i}-}_{(P_{})}\| _{1}},\] (9)

and where \(\{}_{i}\}\) denote the generated samples and \(}_{(P)}\) their \(P\)-sample average:

\[}_{i} G_{}(_{i},), }_{(P)}_{i=1}^{P}}_{i}.\] (10)

The use of supervised-\(_{1}\) loss and SD reward in (7) is not heuristic. As shown in Proposition 3.1, it encourages the samples \(\{}_{i}\}\) to match the true posterior in both mean and covariance.

**Proposition 3.1**.: _Suppose \(P_{} 2\) and \(\) has complete control over the \(\)-conditional mean and covariance of \(}_{i}\). Then the parameters \(_{*}=_{}_{1,,P_{ }}(,_{}^{})\) with_

\[_{}^{}}(P_{}+1)}}\] (11)

_yield generated statistics_

\[_{_{i}|\{}_{i}(_{* })|\}} =_{|\{\}}\{|\}=}_{ }\] (12a) \[_{_{i}|\{}_{i}(_ {*})|\}} =_{|\{\}}\{|\}\] (12b)

_when the elements of \(}_{i}\) and \(\) are independent Gaussian conditioned on \(\). Thus, minimizing \(_{1,,P_{}}\) encourages the \(\)-conditional mean and covariance of \(}_{i}\) to match those of the true \(\)._

See Appendix B for a proof. In imaging applications, \(}_{i}\) and \(\) may not be independent Gaussian conditioned on \(\), and so the value of \(_{}\) in (11) may not be appropriate. Thus we propose a method to automatically tune \(_{}\) in Section 3.2.

Figure 1 shows a toy example with parameters \(=[,]^{}\), generator \(G_{}(z,y)=+ z\), and \(z(0,1)\), giving generated posterior \(p_{}(x|y)=(x;,^{2})\). Assuming the true \(p_{}(x|y)=(x;_{0},_{0}^{2})\), Figs. 1(a)-(b) show that, by minimizing the proposed \(_{1,,P_{}}(,_{}^ {})\) regularization over \(=[,]^{}\) for any \(P_{} 2\), we recover the true \(_{0}=[_{0},_{0}]^{}\). They also show that the cost function steepens as \(P_{}\) decreases, with agrees with our empirical finding that \(P_{}=2\) tends to work best in practice.

We note that regularizing a cGAN with supervised-\(_{1}\) loss alone is not new; see, e.g., . In fact, the use of supervised-\(_{1}\) loss is often preferred over \(_{2}\) in image recovery because it results in sharper, more visually pleasing results . But regularizing a cGAN using supervised-\(_{1}\) loss _alone_ can push the generator towards mode collapse, for reasons described below. For example, in , \(_{1}\)-induced mode collapse led the authors to use dropout to induce generator variation, instead of random \(_{i}\).

Why not supervised-\(_{2}\) regularization?One may wonder: Why regularize using supervised-\(_{1}\) loss plus an SD reward in (7) and not a more conventional choice like supervised-\(_{2}\) loss plus a variance reward, or even supervised-\(_{2}\) loss alone? We start by discussing the latter.

The use of supervised-\(_{2}\) regularization in a cGAN can be found in . In this case, to train the generator, one would aim to solve \(_{}\{_{}(,)+ _{2}()\}\) with some \(>0\) and

\[_{2}()_{,} \|-_{}\{G_{}(,)\|_{2}^{2}\}. \] (13)

Ohayon et al.  revived this idea for the explicit purpose of fighting mode collapse. In practice, however, the \(_{}\) term in (13) must be implemented by a finite-sample average, giving

\[_{2,P_{}}()_{,_{1},,,}\|-}} _{i=1}^{P_{}}G_{}(_{i},)\|_{2}^{2}}\] (14)

for some \(P_{} 2\). For example, Ohayon's implementation  used \(P_{}=8\). As we show in Proposition 3.2, \(_{2,P_{}}\)_induces_ mode collapse rather than prevents it.

**Proposition 3.2**.: _Say \(P_{}\) is finite and \(\) has complete control over the \(\)-conditional mean and covariance of \(}_{i}\). Then the parameters \(_{*}=_{}_{2,P_{}}()\) yield generated statistics_

\[_{_{i}|\{}_{i}(_{* })|\}} =_{|\{\}}\{|\}=}_{ }\] (15a) \[_{_{i}|\{}_{i}(_{* })|\}} =.\] (15b)

_Thus, minimizing \(_{2,P_{}}\) encourages mode collapse._The proof (see Appendix C) follows from the bias-variance decomposition of (14), i.e.,

\[_{2,P_{}}()\] \[=_{}\{\|}_{}-_{}\{}_{i}()|\}\|_{2}^{2}+}}[_{}\{ }_{i}()|\}]+_{}\{\| _{}\|_{2}^{2}|\}\},\] (16)

where \(_{}-_{}\) is the MMSE error. Figure 1(c) shows that \(_{2,P_{}}\) regularization causes mode collapse in the toy example, and Section 4.2 shows that it causes mode collapse in MRI.

Why not supervised \(_{2}\) plus a variance reward?To mitigate \(_{2,P_{}}\)'s incentive for mode-collapse, the second term in (16) could be canceled using a variance reward, giving

\[_{2,,P_{}}() _{2,P_{}}()-}}_{,P_{}}()\] (17) \[_{,P_{}}() }-1}_{i=1}^{P_{}} _{_{1},,_{},}\{\|}_{i}( )-}_{{}_{(P)}}()\|_{2}^{2}\}.\] (18)

since Appendix D shows that \(_{,P_{}}()\) is an unbiased estimator of the posterior trace-covariance:

\[_{,P_{}}()=_{}\{ [_{}\{}_{i}( )|\}]\}\;P_{} 2.\] (19)

However, the resulting \(_{2,,P_{}}\) regularizer in (17) does not encourage the generated covariance to match the _true_ posterior covariance, unlike the proposed \(_{1,,P_{}}\) regularizer in (7) (recall Proposition 3.1). For the toy example, this behavior is visible in Fig. 1(d).

### Auto-tuning of SD reward weight \(_{}\)

We now propose a method to auto-tune \(_{}\) in (7) for a given training dataset. Our approach is based on the observation that larger values of \(_{}\) tend to yield samples \(}_{i}\) with more variation. But more variation is not necessarily better; we want samples with the correct amount of variation. To assess the correct amount of variation, we compare the expected \(_{2}\) error of the \(P\)-sample average \(}_{{}_{(P)}}\) to that of \(}_{{}_{(1)}}\). When \(\{}_{i}\}\) are true-posterior samples, these errors follow a particular relationship, as established by Proposition 3.3 below (see Appendix E for a proof).

**Proposition 3.3**.: _Say \(}_{i} p_{}(|)\) are independent samples of the true posterior and, for any \(P 1\), their \(P\)-sample average is \(}_{{}_{(P)}}_{i=1}^{P}}_{i}\). Then_

\[_{P}\{\|}_{{}_{(P)}}-\|_{ 2}^{2}|\}=_{},_{1}}{_{P}}=.\] (20)

Experimentally we find that \(_{1}/_{P}\) grows with the SD reward weight \(_{}\). (See Fig. 2.) Thus, we propose to adjust \(_{}\) so that the observed SNR-gain ratio \(_{1}/_{P_{}}\) matches the correct ratio \((2P_{})/(P_{}+1)\) from (20), for some \(P_{} 2\) that does not need to match \(P_{}\). (We use \(P_{}=8\) in Section 4.) In particular, at each training epoch \(\), we approximate \(_{P_{}}\) and \(_{1}\) as follows:

\[}_{P_{},} _{=1}^{V}\| }}_{i=1}^{P_{}}G_{_{}}(_{i,v},_{v})- _{v}\|_{2}^{2}\] (21) \[}_{1,} _{=1}^{V}\|G_{_{}}(_{1,v},_{v})-_{v}\|_{2}^{2},\] (22)

with validation set \(\{(_{v},_{v})\}_{v=1}^{V}\) and i.i.d. codes \(\{_{i,v}\}_{i=1}^{P_{}}\). We update \(_{}\) using gradient descent:

\[_{,+1} =_{,}-_{}([}_{1,}/}_{P_{},}]_{}-[2P_{}/(P_{ }+1)]_{})_{}^{}\;\;=0,1,2,\] (23)

with \(_{,0}=_{}^{}\), some \(_{}>0\), and \([x]_{} 10_{10}(x)\).

Figure 2: Example PSNR of \(}_{{}_{(P)}}\) versus \(P\), the number of averaged outputs, for several training \(_{}\) and MRI recovery at \(R=4\). Also shown is the theoretical behavior for true-posterior samples.

Numerical experiments

### Conditional Frechet inception distance

As previously stated, our goal is to train a generator \(G_{}\) so that, for typical fixed values of \(\), the generated distribution \(p_{}(|)\) matches the true posterior \(p_{}(|)\). It is essential to have a quantitative metric for evaluating performance with respect to this goal. For example, it is not enough that the generated samples are "accurate" in the sense of being close to the ground truth, nor is it enough that they are "diverse" according to some heuristically chosen metric.

We quantify posterior-approximation quality using the conditional Frechet inception distance (CFID) , a computationally efficient approximation to the conditional Wasserstein distance

\[_{}\{W_{2}(p_{}(, ),p_{}(,))\}.\] (24)

In (24), \(W_{2}(p_{},p_{})\) denotes the Wasserstein-2 distance between distributions \(p_{}\) and \(p_{}\), defined as

\[W_{2}(p_{},p_{})_{p_{,} (p_{},p_{})}_{,}\{\| -\|_{2}^{2}\},\] (25)

where \((p_{},p_{})\{p_{,} :p_{}= p_{,}\,p_{}= p_{,}\,\}\) denotes the set of joint distributions \(p_{,}\) with prescribed marginals \(p_{}\) and \(p_{}\). Similar to how FID --a popular uGAN metric--is computed, CFID approximates CWD (24) as follows: i) the random vectors \(\), \(}\), and \(\) are replaced by low-dimensional embeddings \(}\), \(}}\), and \(}\), generated by the convolutional layers of a deep network, and ii) the embedding distributions \(p_{}\) and \(p_{}\) are approximated by multivariate Gaussians. More details on CFID are given in Appendix F.

### MRI experiments

We consider parallel MRI recovery, where the goal is to recover a complex-valued multicoil image \(\) from zero-filled measurements \(\) (see Appendix G for details).

Data.For training data \(\{_{t}\}\), we used the first 8 slices of all fastMRI  T2 brain training volumes with at least 8 coils, cropping to \(384 384\) pixels and compressing to 8 virtual coils , yielding 12 200 training images. Using the same procedure, 2 376 testing and 784 validation images were obtained from the fastMRI T2 brain testing volumes. From the 2 376 testing images, 72 were randomly selected to evaluate the Langevin technique  in order to limit its sample generation to 6 days. To create the measurement \(_{t}\), we transformed \(_{t}\) to the Fourier domain, sampled using pseudo-random GRO patterns  at acceleration \(R=4\) and \(R=8\), and Fourier-transformed the zero-filled k-space measurements back to the (complex, multicoil) image domain.

Architecture.We use a UNet  for our generator and a standard CNN for our generator, along with data-consistency as in Appendix H. Architecture and training details are given in Appendix I.

Competitors.We compare our cGAN to the Adler and Oktem's cGAN , Ohayon et al.'s cGAN , Jalal et al.'s fastMRI Langevin approach , and Sriram et al.'s E2E-VarNet . The cGAN from  uses generator loss \(_{}_{}^{}(, )\) and discriminator loss \(-_{}^{}(,)+_{1} _{}()+_{2}_{}( )\), while the cGAN from  uses generator loss \(_{}_{}(,)+ _{2,P}()\) and discriminator loss \(-_{}(,)+_{1}_{ }()+_{2}_{}()\). Each used the value of \(_{}\) specified in the original paper. All cGANs used the same generator and discriminator architectures, except that  used extra discriminator input channels to facilitate the 3-input loss (5). For the fastMRI Langevin approach , we did not modify the authors' implementation in  except to use the GRO sampling mask. For the E2E-VarNet , we use the same training procedure and hyperparameters outlined in  except that we use the GRO sampling mask.

Testing.To evaluate performance, we converted the multicoil outputs \(}_{i}\) to complex-valued images using SENSE-based coil combining  with ESPIRiT-estimated  coil sensitivity maps, as described in Appendix G. Magnitude images were used to compute performance metrics.

Results.Table 1 shows CFID, FID \(}(_{i=1}^{P}\|}_{(p_{})}-}_{i}\|^{2})^{1/2}\), and 4-sample generation time at \(R\{4,8\}\). (C)FID was computed using VGG-16 (not Inception-v3) to better align with radiologists' perceptions . As previously described, the Langevin method was evaluated using only 72 test images. Because CFID is biased at small sample sizes , we re-evaluated the other methods using all \(2\,376\) test images, and again using all \(14\,576\) training and test images. Table 1 shows that our approach gave significantly better CFID and FID than the competitors. Also, the APSD of Ohayon et al.'s cGAN was an order-of-magnitude smaller than the others, indicating mode collapse. The cGANs generated samples \(3\,800\) times faster than the Langevin approach from .

Tables 2 and 3 show PSNR, SSIM, LPIPS , and DISTS  for the \(P\)-sample average \(}_{{}_{(P)}}\) at \(P\{1,2,4,8,16,32\}\) and \(R\{4,8\}\), respectively. While the E2E-VarNet achieves the best PSNR at \(R\{4,8\}\) and the best SSIM at \(R=4\), the proposed cGAN achieves the best LPIPS and DISTS performances at \(R\{4,8\}\) when \(P=2\) and the best SSIM at \(R=8\) when \(P=8\). The \(P\) dependence can be explained by the perception-distortion tradeoff : as \(P\) increases, \(}_{{}_{(P)}}\) transitions from better perceptual quality to lower \(_{2}\) distortion. PSNR favors \(P\) (e.g., \(_{2}\) optimality) while the other metrics favor particular combinations of perceptual quality and distortion. The plots in Appendices K.1 and K.2 show zoomed-in versions of \(}_{{}_{(P)}}\) that visually demonstrate the perception-distortion tradeoff at \(P\{1,2,4,32\}\): smaller \(P\) yield sharper images with more variability from the ground truth, while larger \(P\) yield smoother reconstructions.

Figure 3 shows zoomed versions of two posterior samples \(}_{i}\), as well as \(}_{{}_{(P)}}\), at \(P=32\) and \(R=8\). The posterior samples show meaningful variations for the proposed method, essentially no variation for Ohayon et al.'s cGAN, and vertical or horizontal reconstruction artifacts for Adler & Oktem's cGAN and the Langevin method, respectively. The \(}_{{}_{(P)}}\) plots show that these artifacts are mostly suppressed by sample averaging with large \(P\).

Figure 4 shows examples of \(}_{{}_{(P)}}\), along with the corresponding pixel-wise absolute errors \(|}_{{}_{(P)}}-|\) and pixel-wise SD images \((_{i=1}^{P}(}_{{}_{(P)}}-}_{i})^ {2})^{1/2}\), for \(P=32\) and \(R=8\). The absolute-error image for the Langevin technique looks more diffuse than those of the other methods in the brain region. The fact that it is brighter in the air region (i.e., near the edges) is a consequence of minor differences in sensitivity-map estimation. The pixel-wise SD images show a lack of variability for the E2E-VarNet, which does not generate posterior samples, as well as Ohayon et al.'s cGAN, due to mode collapse. The Langevin pixel-wise SD images show localized hot-spots that appear to be reconstruction artifacts.

Appendices K.1 and K.2 show other example MRI recoveries with zoomed pixel-wise SD images at \(R=4\) and \(R=8\), respectively. Notably, Figures K.10 and K.11 show strong hallucinations for Langevin recovery at \(R=8\), as highlighted by the red arrows.

    &  \\  Model & \(P\!=\!1\) & \(P\!=\!2\) & \(P\!=\!4\) & \(P\!=\!8\) & \(P\!=\!16\) & \(P\!=\!32\) & \(P\!=\!1\) & \(P\!=\!2\) & \(P\!=\!4\) & \(P\!=\!8\) & \(P\!=\!16\) & \(P\!=\!32\) \\  E2E-VarNet (Sriram et al. ) & **39.93** & - & - & - & - & - & **0.9641** & - & - & - & - & - \\ Langgina (Jalal et al. ) & 36.04 & 37.02 & 37.65 & 37.99 & 38.17 & 38.27 & 0.8989 & 0.913 & 0.9218 & 0.9260 & 0.9281 & 0.9292 \\ eGAN (Adler \& Oktem)  & 35.63 & 36.64 & 37.24 & 37.56 & 37.73 & 37.82 & 0.8936 & 0.945 & 0.9478 & 0.9480 & 0.9477 & 0.9473 \\ eGAN (Ohayon et al. ) & 39.44 & 39.46 & 39.46 & 39.47 & 39.47 & 39.47 & 0.9585 & 0.9546 & 0.9539 & 0.9535 & 0.9533 \\ cGAN (Ours) & 36.96 & 38.14 & 38.84 & 39.24 & 39.44 & 39.55 & 0.9440 & 0.9526 & 0.9544 & 0.9524 & 0.9537 & 0.9533 \\  & & LPIPS\(\) & & & & & & & & & & & \\  Model & \(P\!=\!1\) & \(P\!=\!2\) & \(P\!=\!4\) & \(P\!=\!8\) & \(P\!=\!16\) & \(P\!=\!32\) & \(P\!=\!1\) & \(P\!=\!2\) & \(P\!=\!4\) & \(P\!=\!8\) & \(P\!=\!16\) & \(P\!=\!32\) \\  E2E-VarNet (Sriram et al. ) & 0.0316 & - & - & - & - & - & - & 0.0859 & - & - & - & - & - \\ Langgina (Jalal et al. ) & 0.0545 & 0.0934 & 0.0336 & 0.0320 & 0.0317 & 0.0316 & 0.1116 & 0.0921 & 0.0828 & 0.0793 & 0.0781 & 0.0777 \\ eGAN (Adler \& Oktem)  & 0.0285 & 0.0255 & 0.0273 & 0.0298 & 0.0316 & 0.0237 & 0.0972 & 0.0857 & 0.0878 & 0.0930 & 0.0967 & 0.0990 \\ eGAN (Ohayon et al. ) & 0.0245 & 0.0247 & 0.0248 & 0.0249 & 0.0249 & 0.0249 & 0.0767 & 0.0790 & 0.0801 & 0.0807 & 0.0810 & 0.0811 \\ eGAN (Ours) & 0.0175 & **0.0164** & 0.0188 & 0.0216 & 0.0235 & 0.0245 & **0.0546** & 0.0563 & 0.0667 & 0.0755 & 0.0809 & 0.0837 \\   

Table 2: Average PSNR, SSIM, LPIPS, and DISTS of \(}_{{}_{(P)}}\) versus \(P\) for \(R=4\) MRI

    &  \\  Model & \(P\!=\!1\) & \(P\!=\!2\) & \(P\!=\!4\) & \(P\!=\!8\) & \(P\!=\!16\) & \(P\!=\!32\) & \(P\!=\!1\) & \(P\!=\!2\) & \(P\!=\!4\) & \(P\!=\!8\) & \(P\!=\!16\) & \(P\!=\!32\) \\  E2E-VarNet (Sriram et al. ) & **39.93** & - & - & - & - & - & **0.9641** & - & - & - & - & - \\ Langgina (Jalal et al. ) & 36.04 & 37.02 & 37.65 & 37.99 & 38.17 & 38.27 & 0.8989 & 0.9138 & 0.9218 & 0.9260 & 0.9281 & 0.9292 \\ eGAN (Adler \& Oktem)  & 35.63 & 36.64 & 37.24 & 37.56 & 37.73 & 37.37 & 37.82 & 0.8936 & 0.945 & 0.9478 & 0.9480 & 0.9477 & 0.9473 \\ eGAN (Ohayon et al. ) & 39.44 & 39.46 & 39.46 & 39.47 & 39.47 & 39.47 & 39.47 & 0.9585 & 0.9546 & 0.9539 & 0.9535 & 0.953 \\ eGAN (Ours) & 36.96 & 38.14 & 38.84 & 39.24

### Inpainting experiments

In this section, our goal is to complete a large missing square in a face image.

**Data.** We used \(256 256\) CelebA-HQ face images  and a centered \(128 128\) missing square. We randomly split the dataset, yielding \(27\,000\) training, \(2\,000\) validation, and \(1\,000\) testing images.

**Architecture.** For our cGAN, we use the CoModGAN generator and discriminator from  with our proposed \(_{1,,P_{}}\) regularization. Unlike , we do not use MBSD  at the discriminator.

**Training/validation/testing.** We use the same general training and testing procedure described in Section 4.2, but with \(_{}=\) 5e-3, \(n_{}=100\), and 110 epochs of cGAN training. Running PyTorch on a server with 4 Tesla A100 GPUs, each with 82 GB of memory, the cGAN training takes approximately 2 days. FID was evaluated on \(1\,000\) test images using \(P=32\) samples per measurement. To avoid the bias that would result from evaluating CFID on only \(1\,000\) images (see Appendix J.1), CFID was evaluated on all \(30\,000\) images with \(P=1\).

**Competitors.** We compare with the state-of-the-art CoModGAN  and Score-based SDE  approaches. For CoModGAN, we use the PyTorch implementation from . CoModGAN differs from our cGAN only in its use of MBSD and lack of \(_{1,,P_{}}\) regularization. For Song et al.'s SDE, we use the authors' implementation from  with their pretrained weights and the settings they suggested for the \(256 256\) CelebA-HQ dataset.

    &  &  \\  Model & \(P\)=\(1\) & \(P\)=\(2\) & \(P\)=\(4\) & \(P\)=\(8\) & \(P\)=\(16\) & \(P\)=\(32\) & \(P\)=\(1\) & \(P\)=\(2\) & \(P\)=\(4\) & \(P\)=\(8\) & \(P\)=\(16\) & \(P\)=\(32\) \\  E2E-VarNet (Sriram et al. ) & **36.49** & - & - & - & - & - & 0.9220 & - & - & - & - & - \\ Langgino (Malal et al. ) & 32.17 & 32.83 & 33.55 & 33.74 & 33.83 & 33.39 & 30.8725 & 0.8919 & 0.9031 & 0.9910 & 0.9120 & 0.9317 \\ cGAN (Adler \& Göken ) & 31.31 & 32.31 & 32.92 & 33.26 & 33.42 & 33.51 & 0.8865 & 0.9405 & 0.9103 & 0.9111 & 0.9102 & 0.9095 \\ cGAN (Oluyap et al. ) & 34.89 & 34.90 & 34.90 & 34.90 & 34.91 & 34.92 & 0.9222 & 0.9217 & 0.9213 & 0.9211 & 0.9211 & 0.9210 \\ cGAN (Ours) & 32.32 & 33.67 & 34.53 & 35.01 & 35.27 & 35.42 & 0.9030 & 0.9199 & 0.9252 & **0.9257** & 0.9251 & 0.9246 \\   &  &  \\  Model & \(P\)=\(1\) & \(P\)=\(2\) & \(P\)=\(4\) & \(P\)=\(8\) & \(P\)=\(16\) & \(P\)=\(32\) & \(P\)=\(1\) & \(P\)=\(2\) & \(P\)=\(4\) & \(P\)=\(8\) & \(P\)=\(16\) & \(P\)=\(32\) \\  E2E-VarNet (Sriram et al. ) & 0.0575 & - & - & - & - & - & 0.1253 & - & - & - & - & - \\ Langgino (Malal et al. ) & 0.0769 & 0.0619 & 0.0579 & 0.0589 & 0.0611 & 0.0611 & 0.1341 & 0.1136 & 0.1086 & 0.1119 & 0.1175 & 0.1212 \\ cGAN (Adler \& Göken ) & 0.0698 & 0.0614 & 0.0623 & 0.0667 & 0.074 & 0.0727 & 0.1407 & 0.1262 & 0.1252 & 0.1291 & 0.1334 & 0.1361 \\ cGAN (Oluyap et al. ) & 0.0532 & 0.0536 & 0.0539 & 0.0540 & 0.0534 & 0.0540 & 0.1128 & 0.1143 & 0.1151 & 0.1155 & 0.1157 & 0.1158 \\ cGAN (Ours) & 0.0418 & **0.0379** & 0.0421 & 0.0476 & 0.0516 & 0.0539 & 0.0906 & **0.0877** & 0.0965 & 0.1063 & 0.1135 & 0.1177 \\   

Table 3: Average PSNR, SSIM, LPIPS, and DISTS of \(}_{(P)}\) versus \(P\) for \(R=8\) MRI

Figure 3: Example \(R=8\) MRI reconstructions. Arrows show meaningful variations across samples.

**Results.** Table 4 shows test CFID, FID, and 128-sample generation time. The table shows that our approach gave the best CFID and FID, and that the cGANs generated samples 13 000 times faster than the score-based method. Figure 5 shows an example of five generated samples for the three methods under test. The samples are all quite good, although a few generated by CoModGAN and the score-based technique have minor artifacts. Some samples generated by our technique show almond-shaped eyes, demonstrating fairness. Additional examples are given in Appendix K.3.

## 5 Conclusion

We propose a novel regularization framework for image-recovery cGANs that consists of supervised-\(_{1}\) loss plus an appropriately weighted standard-deviation reward. For the case of an independent Gaussian posterior, we proved that our regularization yields generated samples that agree with the true-posterior samples in both mean and covariance. We also established limitations for alternatives based on supervised-\(_{2}\) regularization with or without a variance reward. For practical datasets, we proposed a method to auto-tune our standard-deviation reward weight.

Experiments on parallel MRI and large-scale face inpainting showed our proposed method outperforming all cGAN and score-based competitors in CFID, which measures posterior-approximation quality, as well as other metrics like FID, PSNR, SSIM, LPIPS, and DISTS. Furthermore, it generates samples thousands of times faster than Langevin/score-based approaches.

In ongoing work, we are extending our approach so that it can be trained to handle a wide range of recovery tasks, such as MRI with a generic acceleration and sampling mask , or inpainting with a generic mask. We are also extending our approach to other applications, such as super-resolution, deblurring, compressive sensing, denoising, and phase retrieval.

   Model & CFID\(\) & FID\(\) & Time (128)\(\) \\  Score-SDE (Song et al. ) & 5.11 & 7.92 & 48 min \\ CoModGAN (Zhao et al. ) & 5.29 & 8.50 & **217 ms** \\ cGAN (ours) & **4.69** & **7.45** & **217 ms** \\   

Table 4: Average results for inpainting: FID was computed from \(1\,000\) test images with \(P\!=\!32\), while CFID was computed from all 30 000 images with \(P\!=\!1\)

#### Limitations.

We acknowledge several limitations of our work. First, while our current work focuses on how to build a fast and accurate posterior sampler, it's not yet clear how to best exploit the resulting posterior samples in each given application. For example, in MRI, where the posterior distribution has the potential to help assess uncertainty in image recovery, it's still not quite clear how to best convey uncertainty information to radiologists (e.g., they may not gain much from pixel-wise SD images). More work is needed on this front. Second, we acknowledge that, because radiologists are risk-averse, more studies are needed before they will feel comfortable incorporating generative deep-learning-based methods into the clinical workflow. Third, we acknowledge that the visual quality of our \(R=8\) MRI reconstructions falls below clinical standards. Fourth, some caution is needed when interpreting our CFID, FID, and DISTS perceptual metrics because the VGG-16 backbone used to compute them was trained on ImageNet data. Although there is some evidence that the resulting DISTS metric correlates well with radiologists' perceptions , there is also evidence that ImageNet-trained features may discard information that is diagnostically relevant in medical imaging . Thus our results need to be validated with a pathology-centric radiologist study before they can be considered relevant to clinical practice.