# Minimax Forward and Backward Learning of Evolving Tasks with Performance Guarantees

Veronica Alvarez\({}^{1}\) Santiago Mazuelas\({}^{1,2}\) Jose A. Lozano\({}^{1,3}\)

\({}^{1}\)Basque Center of Applied Mathematics (BCAM)

\({}^{2}\)IKERBASQUE-Basque Foundation for Science \({}^{3}\)University of the Basque Country UPV/EHU

{valvarez, smazuelas, jlozano}@bcamath.org

###### Abstract

For a sequence of classification tasks that arrive over time, it is common that tasks are evolving in the sense that consecutive tasks often have a higher similarity. The incremental learning of a growing sequence of tasks holds promise to enable accurate classification even with few samples per task by leveraging information from all the tasks in the sequence (forward and backward learning). However, existing techniques developed for continual learning and concept drift adaptation are either designed for tasks with time-independent similarities or only aim to learn the last task in the sequence. This paper presents incremental minimax risk classifiers (IMRCs) that effectively exploit forward and backward learning and account for evolving tasks. In addition, we analytically characterize the performance improvement provided by forward and backward learning in terms of the tasks' expected quadratic change and the number of tasks. The experimental evaluation shows that IMRCs can result in a significant performance improvement, especially for reduced sample sizes.

## 1 Introduction

In practical scenarios, it is often of interest to incrementally learn a growing sequence of classification problems (tasks) that arrive over time. In such a sequence, it is common that tasks are evolving in the sense that consecutive tasks often have a higher similarity. Examples of evolving tasks are the classification of portraits from different time periods  and the classification of spam emails over time ; in these problems, the similarity between consecutive tasks (portraits of consecutive time periods and emails from consecutive years) is significantly higher (see Figure 1). The incremental learning of a growing sequence of tasks holds promise to significantly improve performance by leveraging information from different tasks. Specifically, at each time step, information from preceding tasks can be used to improve the performance of the last task (forward learning) and, reciprocally, the information from the last task can be used to improve the performance of the preceding tasks (backward learning) . Such transfer of information can enable accurate classification even in cases with reduced sample sizes, thus significantly increasing the effective sample size (ESS) of each task. However, exploiting the benefits of forward and backward learning is challenging due to the continuous arrival of samples from tasks characterized by different underlying distributions .

Techniques developed for concept drift adaptation (aka learning in a dynamic scenario)  are designed for evolving tasks but only aim to learn the last task in the sequence. In particular, methods based on learning rates learn the last task by slightly updating the classification rule for the preceding task ; and methods based on sliding windows learn the last task by using a set of stored samples from the most recent preceding tasks . In concept drift adaptation, at each timestep only the last task is considered of interest, and is learned leveraging information from the most recent preceding tasks since they are the most similar to the last task.

Techniques developed for continual learning (aka lifelong learning) [4; 5; 6; 7; 17; 18; 19; 20] aim to learn the whole sequence of tasks but existing methods are designed for situations where tasks' similarities do not depend on the time steps when tasks are observed. In particular, methods based on dynamic architectures learn shared parameters using samples from all the tasks together with task-specific parameters using samples from the corresponding task [6; 20]; and methods based on replay learn parameters using a pool of stored samples from all the preceding tasks together with the samples from the last task [5; 7]. Existing methods for continual learning are not designed for evolving tasks and consider scenarios in which the order of the tasks in the sequence is not relevant. In the current literature of continual learning, only  considers scenarios with evolving tasks but focus on the theoretical analysis of transferring information from the preceding tasks.

This paper presents incremental minimax risk classifiers (IMRCs) that determine classification rules minimizing worst-case error probabilities over uncertainty sets that can contain the sequence of evolving underlying distributions. The proposed techniques can effectively exploit forward and backward learning by obtaining uncertainty sets that get smaller using information from all the tasks (see Figure 1). Specifically, the main contributions presented in the paper are as follows.

* We propose forward learning techniques that recursively use the information from preceding tasks to reduce the uncertainty set of the last task.
* We propose forward and backward learning techniques that use the information from the last task to further reduce the sequence of uncertainty sets obtained with forward learning.
* We analytically characterize the increase in ESS provided by the presented methods in terms of the expected quadratic change between consecutive tasks and the number of tasks.
* We numerically quantify the performance improvement provided by IMRCs in comparison with existing techniques using multiple datasets, sample sizes, and number of tasks.

NotationsCalligraphic letters represent sets; \(\|\|_{1}\) and \(\|\|_{}\) denote the \(1\)-norm and the infinity norm of its argument, respectively; \(\) and \(\) denote vector inequalities; \(\{\}\) denotes the indicator function; and \(_{}\{\,\,\}\) and \(_{}\{\}\) denote the expectation and the variance of its argument with respect to distribution \(\). For a vector \(\), \(v^{(i)}\) and \(^{}\) denote its i-th component and transpose. Non-linear operators acting on vectors denote component-wise operations. For instance, \(||\) and \(^{2}\) denote the vector formed by the absolute value and the square of each component, respectively. For the reader's convenience, we also provide in Table 2 in Appendix A a list with the main notions used in the paper and their corresponding notations.

Figure 1: Tasks that arrive over time are characterized by different underlying distributions and consecutive tasks often have a higher similarity. The black line represents the evolution of the underlying distributions that characterize different tasks. IMRCs minimize the worst-case error probability over uncertainty sets \(_{i}\) that can include the underlying distribution \(_{i}\). A single task uncertainty set (blue hexagons) can be obtained leveraging information only from the corresponding task, while a forward uncertainty set (green hexagons) can be obtained leveraging information from preceding tasks. Then, the proposed methodology obtains forward and backward uncertainty sets (red hexagons) leveraging information from all the tasks in the sequence.

Preliminaries

This section first formulates the problem of incrementally learning a growing sequence of tasks, and describes evolving tasks in comparison with the time-independent assumption common in continual learning. Then, we briefly describe MRCs that determine classification rules by minimizing the worst-case error probability over an uncertainty set.

### Problem formulation

In the following, we denote by \(\) the set of instances or attributes, \(\) the set of labels or classes, \(()\) the set of probability distributions over \(\), and \((,)\) the set of classification rules. A classification task is characterized by an underlying distribution \(^{*}()\), and standard supervised classification methods use a sample set \(D=\{(x_{i},y_{i})\}_{i=1}^{n}\) formed by \(n\) i.i.d samples from distribution \(^{*}\) to find a classification rule \((,)\) with small expected loss \((,^{*})\).

In the addressed settings, sample sets \(D_{1},D_{2},\) arrive over time steps \(1,2,\) corresponding with different classification tasks characterized by underlying distributions \(_{1},_{2},\). Incremental learning aims to continually learn over time the growing sequence of tasks exploiting information acquired from all the tasks. At each time step \(k\), learning methods obtain classification rules \(_{1},_{2},,_{k}\) for the current sequence of \(k\) tasks using the new sample set \(D_{k}\) and certain information retained from step \(k-1\). The performance of learning methods is assessed at each time step \(k\) by quantifying the performance in the current \(k\) tasks. For instance, overall performance can be assessed by the averaged error \(_{j=1}^{k}(_{j},_{j})\) with \((_{j},_{j})\) the expected loss of the classification rule \(_{j}\) for distribution \(_{j}\).

Evolving tasks are considered by methods for concept drift adaptation, but existing continual learning methods are designed for scenarios where tasks' similarities do not depend on the time steps when tasks are observed. These scenarios are usually mathematically modeled assuming that the tasks' distributions \(_{1},_{2},\) are independent and identically distributed (i.i.d.) [18; 19]. In this paper, we develop techniques designed for evolving tasks that can be mathematically modeled assuming that the changes between consecutive distributions \(_{2}-_{1},_{3}-_{2},\) are independent and zero-mean (evolving task assumption). The assumption in this paper is not stronger than the usual i.i.d. assumption and can better describe evolving tasks; their main difference is considering independent changes between consecutive distributions instead of independent distributions. Note that with independent distributions the difference between the distributions of the \(i\)-th and the \((i+t)\)-th tasks has zero mean and variance \(\{_{i+t}-_{i}\}=\{ _{i+1}-_{i}\}=2\{_{1}\}\) that does not depend on \(t\). On the other hand, with independent changes between consecutive distributions, the difference between the distributions of the \(i\)-th and the \((i+t)\)-th tasks has zero mean and variance \(\{_{i+t}-_{i}\}=_{j=1}^{t} {ar}\{_{i+j}-_{i+j-1}\}\) that increases with \(t\). Appendix H further describes how the assumption used in the paper is more appropriate for evolving tasks than the conventional i.i.d. assumption using real datasets.

### Minimax risk classifiers

The methods presented in the paper are based on robust risk minimization [22; 23] instead of empirical risk minimization since training samples corresponding to different tasks follow different distributions. In particular, we utilize MRCs [24; 25] that learn classification rules by minimizing the worst-case expected loss against an uncertainty set given by constraints on the expectation of a feature mapping \(:^{m}\) as

\[=\{()\::\:|_{}\{(x,y)\}-|\}\] (1)

where \(\) denotes a mean vector of expectation estimates and \(\) denotes a confidence vector. Feature mappings are vector-valued functions over \(\), e.g., one-hot encodings of labels  with instances represented by values from the last layers in a neural network [8; 27] or by random Fourier features (RFF) [28; 29].

Given the uncertainty set \(\), MRC rules are solutions of the optimization problem

\[R()=_{(,)}\:_{ }\:(,)\] (2)where \(R()\) denotes the minimax risk and \((,)\) denotes the expected loss of classification rule \(\) for distribution \(\). In the following, we utilize the 0-1-loss so that \((,)=_{}\{\{(x)  y\}\}\) and the expected loss with respect to the underlying distribution becomes the error probability of the classification rule. Deterministic MRCs assign each instance \(x\) with the label \((x)_{y}(x,y)^{}^{}\) where the parameter \(^{}\) is the solution of the convex optimization problem

\[_{}\,1-^{}+_ {x,} }(x,y)^{}-1}{||}+^{}||\] (3)

given by the Lagrange dual of (2) [24; 25].

The baseline approach of single-task learning obtains a classification rule \(_{j}\) for each \(j\)-th task leveraging information only from the sample set \(D_{j}=\{(x_{j,i},y_{j,i})\}_{i=1}^{n_{j}}\) given by \(n_{j}\) samples from distribution \(_{j}\). In that case, IMRCs coincide with MRCs for standard supervised classification that obtain the mean and confidence vectors as

\[_{j}=}_{i=1}^{n_{j}}(x_{j,i},y_{j, i}),_{j}=_{j}}, _{j}=_{j}^{2}}{n_{j}}\] (4)

with \(_{j}^{2}\) an estimate of \(_{_{j}}\{(x,y)\}\), e.g., the sample variance of the \(n_{j}\) samples. The vector \(_{j}\) describes the mean squared errors (MSEs) of the mean vector components and directly gives the confidence vector \(_{j}\) as shown in (4).

MRCs provide bounds for the minimax risk \(R(_{j})\) in terms of the smallest minimax risk as described in [24; 25; 30]. The smallest minimax risk is that corresponding to the ideal case of knowing mean vectors exactly, that is, the minimax risk corresponding with the uncertainty set \(_{j}^{}=\{(\;\;):_{}\{(x,y)\}=_{j}^{}\}\) given by the expectation \(_{j}^{}=_{_{j}}\{(x,y)\}\). In the baseline approach of single-task learning, if \(R_{j}^{}\) and \(_{j}^{}\) denote the smallest minimax risk and the MRC parameter corresponding with \(_{j}^{}\), with probability at least \(1-\) we have that

\[R(_{j}) R_{j}^{}+ }{}}\|_{j}^{}\|_{1}\] (5)

where \(M\) and \(\) are such that \(\|(x,y)\|_{} M\) for any \((x,y)\) and \(subG(_{j})_{j}\), \(subG()\) denotes the sub-Gaussian parameter of the argument components, and \(_{j}\) denotes the random variable given by the feature mapping of samples from the \(j\)-th task. Inequality (5) is obtained using the bounds in  together with the Chernoff bound  for sub-Gaussian variables.

In the following sections, we describe techniques that obtain the mean and MSE vectors using forward and backward learning. Once such vectors are obtained, IMRC methods obtain the classifier parameter \(_{j}\) for each \(j\)-th task solving the convex optimization problem in (3) that can be efficiently addressed using conventional methods [32; 33].

## 3 Forward learning with performance guarantees

This section presents the recursions that allow to obtain mean and MSE vectors for each task retaining information from preceding tasks. In addition, it characterizes the increase in ESS provided by forward learning in terms of the tasks' expected quadratic change and the number of tasks.

### Forward learning

Let \(_{j}^{}\) and \(_{j}^{}\) denote the mean and MSE vectors for forward learning corresponding to the \(j\)-th task. The following recursions allow to obtain \(_{j}^{}\) and \(_{j}^{}\) for each \(j\)-th task using the vectors for the preceding task \(_{j-1}^{},_{j-1}^{}\) as

\[_{j}^{}=_{j}+ _{j}}{_{j-1}^{}+_{j}+ _{j}^{2}}(_{j-1}^{}-_{j} ),_{j}^{}=(_{j }}+_{j-1}^{}+_{j}^{2}})^ {-1}\] (6)

with \(_{j}\) and \(_{j}\) given by (4) and \(_{1}^{}=_{1}\) and \(_{1}^{}=_{1}\).

The vector \(_{i}^{2}\) assesses the expected quadratic change between consecutive tasks described by \(_{i}~{}=~{}_{i}^{}-_{i-1}^{}\). Taking \(_{i}^{2}=\{_{i}^{2}\}\) and \(_{i}^{2}=_{}_{i}}\{(x,y )\}\) for any \(i\), the first recursion in (6) provides the unbiased linear estimator of the mean vector \(_{j}^{}\) based on \(D_{1},D_{2},,D_{j}\) that has the minimum MSE, while the second recursion in (6) provides its MSE (see Appendix B for a detailed derivation). Vectors \(_{i}^{2}\) and \(_{i}^{2}\) can be estimated online using the sample sets. In particular, \(_{i}^{2}\) can be estimated as the sample variance, while \(_{i}^{2}\) can be estimated using sample averages as

\[_{i}^{2}=_{l=1}^{W}_{i_{l}}-_{i_{l-1} })^{2}}{W}i_{0},i_{1},,i_{W}i\{1,2,,k\}.\] (7)

Recursions in (6) obtain mean and MSE vectors for the \(j\)-th task by using information from preceding tasks and the \(j\)-th sample set \(D_{j}\). Specifically, the first recursion in (6) obtains the mean vector \(_{j}^{}\) by adding a correction to the sample average \(_{j}\). This correction is proportional to the difference between \(_{j}\) and \(_{j-1}^{}\) with a proportionality constant that depends on the MSE vectors \(_{j},_{j-1}^{}\) and the expected quadratic change \(_{j}^{2}\). In particular, if \(_{j}_{j-1}^{}+_{j}^{2}\), the mean vector is given by the sample average as in single-task learning, and if \(_{j}_{j-1}^{}+_{j}^{2}\), the mean vector is given by that of the preceding task. Note that for forward learning, at each step \(k\), only the vectors for the last task \(_{k}^{}\) and \(_{k}^{}\) need to be obtained from those of the \((k-1)\)-th task, the vectors for the remaining tasks stay the same as at step \(k-1\) (see also Fig. 2 and Alg. 1 below).

### Performance guarantees and effective sample sizes with forward learning

The following result provides bounds for the minimax risk for each task using forward learning.

**Theorem 1**.: Let \(_{j}^{}\) be the uncertainty set given by (1) using the mean and confidence vectors \(_{j}^{}\) and \(_{j}^{}=_{j}^{}}\) provided by (6), and let \(\) be such that \(subG(_{j})_{j}\) and \(subG(_{j})_{j}\) for \(j=1,2,,k\). Then, under the evolving task assumption of Section 2, we have with probability at least \(1-\) that

\[R(_{j}^{}) R_{j}^{}+}{^{}}}\|_{j}^{ }\|_{1}j\{1,2,,k\}\] (8)

with \(n_{1}^{}=n_{1}\) and \(n_{j}^{} n_{j}+n_{j-1}^{}_{j}^{ }\|_{}}{\|_{j}^{}\|_{}+n_{j-1}^ {}\|_{j}^{2}\|_{}}\) for \(j 2\).

Proof.: See Appendix C. 

The value \(n_{j}^{}\) in (8) is the ESS of the proposed IMRC method with forward learning since the bound in (8) coincides with that of single-task learning in (5) if the sample size for the \(j\)-th task is \(n_{j}^{}\). The ESS of each task is obtained by adding a fraction of the ESS for the preceding task to the sample size. In particular, if \(_{j}^{2}\) is large, the ESS is given by the sample size, while if \(_{j}^{2}\) is small, the ESS is given by the sum of the sample size and the ESS of the preceding task.

The bound in (8) shows that recursions in (6) do not need to use very accurate values for \(_{j}\) and \(_{j}\). Specifically, the coefficient \(\) in (8) can be taken to be small as long as the values used for \(_{j}\) and \(_{j}\) are not much lower than the sub-Gaussian parameters of \(_{j}\) and \(_{j}\), respectively. In particular, \(\) is smaller than the maximum of \(M/_{j,i}\{_{j}^{(i)}\}\) and \(2M/_{j,i}\{d_{j}^{(i)}\}\) due to the bound for the sub-Gaussian parameter of bounded random variables (see e.g., Section 2.1.2 in ).

Theorem 1 shows the increase in ESS in terms of the ESS of the preceding task. The following result allows to directly quantify the ESS in terms of the tasks' expected quadratic change and the number of tasks.

**Theorem 2**.: If \(\|_{j}^{2}\|_{} d^{2}\), \(M 1\), and \(n_{j} n\) for \(j=1,2,,k\), then for any \(j\{1,2,,k\}\), we have that the ESS in (8) can be taken so that it satisfies

\[n_{j}^{} n(1+-1-}{(1+ )^{2j-1}+})=}}-1}.\] (9)

In particular, if \(nd^{2}<1/j^{2}\), we have that \(n_{j}^{} n(1+)\).

Proof.: See Appendix D.

The above theorem characterizes the increase in ESS provided by forward learning in terms of the tasks' expected quadratic change. Such increase grows monotonically with the number of preceding tasks \(j\) as shown in (9) and becomes proportional to \(j\) when the expected quadratic change is smaller than \(1/(j^{2}n)\). Figure 3 below further illustrates the increase in ESS with respect to the sample size \((n_{j}^{}/n)\) due forward learning in comparison with forward and backward learning.

## 4 Forward and backward learning with performance guarantees

This section presents the recursions that allow to obtain mean and MSE vectors for each task leveraging information from all the tasks. In addition, it characterizes the increase in ESS provided by forward and backward learning in terms of the tasks' expected quadratic change and the number of tasks.

Backward learning is more challenging than forward learning since the new task provides additional information for preceding tasks at each time step, while the information from preceding tasks is always the same. The techniques proposed below for backward learning effectively increase the ESS over time by carefully accounting for the new information at each step.

### Forward and backward learning

At each step \(k\), the proposed techniques learn to classify each \(j\)-th task leveraging information obtained from the \(j\) preceding tasks (tasks \(\{1,2,,j\}\)) and from the \(k-j\) succeeding tasks (tasks \(\{j+1,j+2,,k\}\)). From preceding tasks, we obtain the forward mean and MSE vectors \(_{j}^{},_{j}^{}\) using recursions in (6), while from succeeding tasks, we obtain the backward mean and MSE vectors \(_{j}^{},_{j}^{}\) using recursions in (6) in retrodiction. Specifically, vectors \(_{j}^{}\) and \(_{j}^{}\) are obtained using the same recursion as for \(_{j}^{}\) and \(_{j}^{}\) in (6) with \(_{j+1}^{ k},_{j+1}^{2}\), and \(_{j+1}^{ k}\) instead of \(_{j-1}^{},_{j}^{2}\), and \(_{j-1}^{}\).

Let \(_{j}^{ k}\) and \(_{j}^{ k}\) denote the mean and MSE vectors for forward and backward learning corresponding to the \(j\)-th task for \(j\{1,2,,k\}\). The following recursions allow to obtain the mean and MSE vectors \(_{j}^{}\) and \(_{j}^{ k}\) for each \(j\)-th task using those vectors for forward learning \(_{j}^{},_{j}^{}\) and backward learning \(_{j+1}^{ k},_{j+1}^{ k}\) as

\[_{j}^{ k}=_{j}^{}+_{j}^ {}}{_{j}^{}+_{j+1}^{ k}+ _{j+1}^{2}}(_{j+1}^{ k}-_{j}^{} ),_{j}^{ k}=(_{j}^{ }}+_{j+1}^{ k}+_{j+1}^{2}})^ {-1}\] (10)

with \(_{k}^{}=_{k},_{k}^{ k}=_ {k}\) and \(_{k}^{ k}=_{k}^{},_{k}^{  k}=_{k}^{}\). Analogously to the case of forward learning in Section 3.1, taking \(_{i}^{2}=\{_{i}^{2}\}\) and \(_{i}^{2}=_{_{i}}\{(x,y)\}\) for any \(i\), the first recursion in (10) provides the unbiased linear estimator of the mean vector \(_{j}^{}\) based on \(D_{1},D_{2},,D_{j}\) and \(D_{j+1},D_{j+2},,D_{k}\) that has the minimum MSE, while the second recursion in (10) provides its MSE (see Appendix B for a detailed derivation).

Recursions in (10) obtain at step \(k\) the mean and MSE vectors for the \(j\)-th task by retaining information from preceding tasks and acquiring information from the new task. Specifically, the first recursion in (10) obtains the mean vector \(_{j}^{ k}\) by adding a correction to the mean vector of the corresponding task \(_{j}^{}\) obtained for forward learning. This correction is proportional to the difference between \(_{j}^{}\) and \(_{j+1}^{ k}\) with a proportionality constant that depends on the MSE vectors \(_{j}^{},_{j+1}^{ k}\) and the expected quadratic change \(_{j+1}^{2}\). In particular, if \(_{j}^{}_{j+1}^{ k}+_{j+1}^{2}\), the mean vector is given by that of the corresponding task for forward learning, and if \(_{j}^{}_{j+1}^{ k}+_{j+1}^{2}\), the mean vector is given by that of the next task for backward learning.

### Implementation

This section describes the implementation of the proposed IMRCs with forward and backward learning and its computational and memory complexities.

Figure 2 depicts the flow diagram for the proposed IMRC methodology. The presented techniques carefully avoid the repeated usage of the same information from the sequence

of tasks. At each step \(k\), the IMRC method obtains forward mean vector \(_{k}^{}\) for the \(k\)-th task leveraging information from preceding tasks using the forward mean vector \(_{k-1}^{}\) and the sample average \(_{k}\). Reciprocally, backward mean vectors \(_{j+1}^{ k}\) for each \(j\)-th task are obtained leveraging information from the \(k\)-th task through the sample average \(_{k}\). Then, the forward and backward mean vectors \(_{j}^{=k}\) are obtained from the forward mean vectors \(_{j}^{}\) and the backward mean vectors \(_{j+1}^{ k}\). In particular, \(_{j}^{}\) provides the information from the preceding tasks \(1,2,,j\), while \(_{j+1}^{ k}\) provides the information from the succeeding tasks \(j+1,j+2,,k\). At each step \(k\), the IMRC method obtains forward and backward mean vectors \(_{j}^{=k}\) for \(j=k-b,k-b+1,,k\) with \(b\) the number of backward steps. In particular, if \(b=0\), IMRC carries out only forward learning. Note that, at each step \(k\), the proposed IMRC methods only need to retain the forward mean vectors \(_{j}^{}\) and sample averages \(_{j}\) for \(j=k-b,k-b+1,,k\).

``` Input:\(D_{k}\) from new task, and \(_{j},_{j},_{j}^{}\), \(_{j}^{}\) for \(k-b j k-1\) from previous \(b-1\) steps Output:\(_{j}\) for \(k-b j k\), \(_{k},_{k},_{j}^{}\), \(_{k}^{}\)  Obtain sample average and MSE vectors \(_{k}^{}=_{k},_{k} ^{}=_{k}\) using the sample set \(D_{k}\) \(\) Single-task Estimate the tasks' expected quadratic change \(_{k}^{2}\) using (7)  Obtain the forward mean and MSE vectors \(_{k}^{},_{k}^{}\) using (6) \(\) Forward Take \(_{k}^{}=_{k}^{ }}\) and obtain classifier parameter \(_{k}\) solving the optimization problem (3) for\(j=k-1,k-2,,k-b\)do  Estimate the tasks' expected quadratic change \(_{j}^{2}\) using (7)  Obtain backward mean and MSE vectors \(_{j+1}^{ k},_{j+1}^{  k}\) using (6) in retrodiction \(\) Backward Obtain mean and MSE vectors \(_{j}^{ k},_{j}^{}\) using (10) \(\) Forward and backward Take \(_{j}^{ k}=_{j}^{  k}}\) and obtain classifier parameters \(_{j}\) solving the optimization problem (3) ```

**Algorithm 1** IMRC at step \(k\)

Algorithm 1 details the implementation of the proposed IMRCs at each step. For \(k\) steps, IMRCs have computational complexity \(((b+1)Kmk)\) and memory complexity \(((b+k)m)\) where \(K\) is the number of iterations used for the convex optimization problem (3), \(m\) is the length of the feature vector, and \(b\) is the number of backward steps. The complexity of forward and backward learning increases proportionally to the number of backward steps that can be taken to be rather small, as shown in the following. Even more efficient implementations can be obtained using Rauch-Tung-Striebel recursions (see e.g., Section 7.2 in ) that can be used to obtain \(_{j}^{ k}\) from \(_{j+1}^{ k}\), as shown in Appendix E.

### Performance guarantees and effective sample sizes with forward and backward learning

The following result provides bounds for the minimax risk for each task using forward and backward learning

**Theorem 3**.: Let \(_{j}^{=k}\) be the uncertainty set given by (1) using the mean and confidence vector \(_{j}^{=k}\) and \(_{j}^{=k}=_{j}^{=k}}\) provided by (10), and let \(\) and \(n_{j}^{}\) be as in Theorem 1. Then, under the evolving task assumption of Section 2, we have with probability at least \(1-\) that

\[R(_{j}^{=k}) R_{j}^{}+}}{^{=k}}}\|_{j}^{}\|_{1} j\{1,2,,k\}\] (11)

Figure 2: Diagram for IMRC methodology.

[MISSING_PAGE_FAIL:8]

## 5 Numerical results

This section first compares the classification performance of IMRCs with existing techniques using multiple datasets, then we show the performance improvement of the presented IMRCs due to forward and backward learning. In Appendix H, we provide additional implementation details and numerical results. The implementation of the proposed IMRCs is available on the web https://github.com/MachineLearningBCAM/IMRCs-for-incremental-learning-NeurIPS-2023.

The proposed method is evaluated using \(12\) public datasets composed by evolving tasks [10; 1; 35; 36; 37; 38; 39; 40; 2]. Six datasets are formed by images with characteristics/quality/realism that change over time; while the rest are formed by tabular data that are segmented by time (see further details in Appendix H). For instance, each task in the "Yearbook" dataset corresponds to portrait's photographs from one year from 1905 to 2013 and the goal is to predict males and females; and each task in the "CLEAR" dataset corresponds to images with a natural temporal evolution of visual concepts per year from 2004 to 2014 and the goal is to predict if an image is soccer, hockey, or racing. For the image datasets, instances are represented by pixel values in "Rotated MNIST" dataset, and by the last layer of the ResNet18 pre-trained network  in the remaining datasets; while for the tabular datasets, instances are represented by \(200\) RFFs [28; 29] with scaling parameter \(^{2}=10\).

The proposed IMRC method is compared with \(7\) state-of-the-art-techniques: \(2\) techniques of continual learning based on experience replay [5; 17], a technique of continual learning based on regularization , a technique of continual learning based on dynamic architectures , \(2\) techniques of concept drift adaptation based on weight factors [9; 16], and a technique of concept drift adaptation based on sliding windows . The hyper-parameters in all methods are set to the default values provided by the authors. IMRCs are implemented using \(b=3\) backward steps and the expected quadratic change \(_{j}^{2}\) is estimated using \(W=2\) in (7). In Appendix H, among other additional results, we study the change in classification error and processing time achieved by varying the number \(b\) of backward steps.

In the first set of numerical results, we compare the performance of the proposed IMRCs with existing techniques using \(n=10\) samples per task. These numerical results are obtained computing the average classification error over all the time steps and tasks in 50 random instantiations of data samples. As can be observed in Table 1, IMRCs can significantly improve performance in evolving tasks with respect to existing methods. Certain techniques of continual learning or concept drift adaptation achieve top performance in specific datasets, but the performance improvement of the methods presented are realized over general datasets with evolving tasks. The results for \(n=10\) samples per task in Table 1 are complemented with results for \(n=50,100\), and \(150\) samples per task in Tables 4, 5, and 6 in Appendix H. These results show that the improved performance of IMRCs compared to the state-of-the-art techniques is similar for different sample sizes. In addition, Table 1 shows that the average running time per task of IMRC methods is similar to other state-of-the-art methods.

  Method & GEM  & MER  & EELLA  & EWC  & Condor  & DriftSurf  & AUE  & IMRC \\  Yearbook  &.18 \(\).03 &.16 \(\).03 &.45 \(\).01 &.47 \(\).05 &.14 \(\).01 &.33 \(\).02 &.33 \(\).02 & **.13**\(\).04 \\ I. noise  &.39 \(\).08 &.17 \(\).03 &.48 \(\).05 &.47 \(\).04 &.16 \(\).02 &.48 \(\).02 &.48 \(\).02 & **.15**\(\).03 \\ DomainNet  &.69 \(\).05 &.38 \(\).04 &.67 \(\).05 &.75 \(\).04 &.45 \(\).04 & **.32**\(\).02 &.33 \(\).02 &.34 \(\).06 \\ UTFKaes  &.12 \(\).00 &.17 \(\).09 &.19 \(\).12 &.12 \(\).00 &.23 \(\).00 &.12 \(\).00 &.12 \(\).00 & **.10**\(\).01 \\ R. MNIST  & **.36**\(\).06 &.37 \(\).09 &.48 \(\).05 &.48 \(\).01 &.45 \(\).02 &.48 \(\).02 &.48 \(\).02 & **.36**\(\).01 \\ CLEAR  &.57 \(\).10 &.10 \(\).03 &.61 \(\).06 &.65 \(\).03 &.35 \(\).00 &.33 \(\).00 &.33 \(\).01 & **.09**\(\).03 \\ P. Supply  &.46 \(\).01 &.47 \(\).01 &.41 \(\).07 &.47 \(\).00 &.36 \(\).01 &.45 \(\).02 &.45 \(\).02 & **.30**\(\).01 \\ Usenet1  &.48 \(\).02 &.48 \(\).02 &.39 \(\).05 &.48 \(\).02 &.48 \(\).02 &.40 \(\).01 &.40 \(\).01 & **.32**\(\).03 \\ Usenet2  &.36 \(\).01 & **.33**\(\).01 &.39 \(\).03 &.48 \(\).02 &.42 \(\).01 &.35 \(\).03 &.39 \(\).03 & **.33**\(\).02 \\ German  &.38 \(\).16 &.38 \(\).10 & **.33**\(\).04 &.35 \(\).11 &.41 \(\).02 &.36 \(\).00 &.35 \(\).02 & **.34**\(\).01 \\ Spam  &.25 \(\).05 & **.13**\(\).02 &.28 \(\).07 &.33 \(\).11 &.22 \(\).02 &.24 \(\).03 &.25 \(\).03 & **.13**\(\).01 \\ Covert.  &.09 \(\).01 & **.08**\(\).00 &.13 \(\).01 &.09 \(\).00 &.09 \(\).00 &.10 \(\).00 &.11 \(\).00 & **.08**\(\).00 \\  Ave. running time & 0.238 & 0.250 & 0.055 & 0.313 & 0.184 & 0.128 & 0.044 & 0.275 \\  

Table 1: Classification error, standard deviation, and running time of the proposed IMRCs method in comparison with existing techniques using \(n=10\) samples per task.

In the second set of numerical results, we analyze the contribution of forward and backward learning to the final performance of IMRCs. In particular, we show the relationship among classification error, number of tasks, and sample size for single-task, forward, and forward and backward learning. These numerical results are obtained averaging, for each number of tasks and sample size, the classification errors achieved with \(10\) random instantiations of data samples in "Yearbook" dataset (see Appendix H for further details). Figure 3(a) shows the classification error of IMRC method divided by the classification error of single-task learning for different number of tasks with \(n=10\) and \(n=100\) sample sizes. Such figure shows that forward and backward learning can significantly improve the performance of IMRCs as tasks arrive. In addition, Figure 3(b) shows the classification error of IMRC method for different sample sizes with \(k=10\) and \(k=100\) tasks. Such figure shows that IMRCs with forward and backward learning for \(k=100\) tasks and \(n=10\) samples achieve significantly better results than single-task learning using \(n=100\) samples. In particular, the experiments show that the methods proposed can effectively exploit backward learning that results in enhanced classification error in all the experimental results.

## 6 Conclusion

The paper proposes IMRCs that effectively exploit forward and backward learning and account for evolving tasks by using a sequence of uncertainty sets that can contain the true underlying distributions. In addition, the paper analytically characterizes the increase in ESS achieved by the proposed techniques in terms of the tasks' expected quadratic change and number of tasks. The numerical results assess the performance improvement of IMRCs with respect to existing methods using multiple datasets, sample sizes, and number of tasks. The proposed methodology for incremental learning with evolving tasks can lead to techniques that further approach the humans' ability to learn from few examples and to continuously improve on tasks that arrive over time.

## Appendix C Proof of Theorem 1

Proof.: To obtain bound in (8) we first prove that the mean vector estimate and the MSE vector given by (6) satisfy

\[\{|_{j}^{(i)}-_{j}^{(i)}| ^{(i)}()} \}(1-)\] (15)

for any component \(i=1,2,,m\). Then, we prove that \(\|_{j}^{}}\|_{} M/^ {(i)}}\) for \(j\{1,2,,k\}\), where the ESSs satisfy \(n_{1}^{}=n_{1}\) and \(n_{j}^{} n_{j}+n_{j-1}^{(i)}_{j}^{2}\|_{}}{\|_{j}^{2}\|_{ }+n_{j-1}^{(i)}\|_{j}^{2}\|_{}}\) for \(j 2\).

To obtain inequality (15), we prove by induction that each component \(i=1,2,,m\) of the error in the mean vector estimate \(z_{j}^{(i)}=_{j}^{(i)}-_{j}^{(i)}\) is sub-Gaussian with parameter \(_{j}^{(i)}^{(i)}}\). Firstly, for \(j=1\), we have that

\[z_{1}^{(i)}=_{1}^{(i)}-_{1}^{(i) }=_{1}^{(i)}-_{1}^{(i)}.\]

    & Single task & Forward & Backward & Forward and Backward \\  Mean vector & \(_{j}\) & \(_{j}^{}\) & \(_{j}^{ k}\) & \(_{j}^{ k}\) \\ Confidence vector & \(_{j}\) & \(_{j}^{}\) & \(_{j}^{ k}\) & \(_{j}^{ k}\) \\ MSE vector & \(_{j}\) & \(_{j}^{}\) & \(_{j}^{ k}\) & \(_{j}^{ k}\) \\ ESS & \(_{j}\) & \(_{j}^{}\) & \(_{j}^{ k}\) & \(_{j}^{ k}\) \\ Uncertainty set & \(_{j}\) & \(_{j}^{}\) & \(_{j}^{ k}\) & \(_{j}^{ k}\) \\ Minimax risk & \(R(_{j})\) & \(R(_{j}^{})\) & \(R(_{j}^{ k})\) & \(R(_{j}^{ k})\) \\   

Table 2: Main notations used in the paper Since the bounded random variable \(_{1}^{(i)}\) is sub-Gaussian with parameter \((_{1}^{(i)})\), then the error in the mean vector estimate \(z_{1}^{(i)}\) is sub-Gaussian with parameter that satisfies

\[(_{1}^{(i)})^{2}=^{(i)} )^{2}}{n_{1}}_{1}^{2(i)}}{n_{1}}=^{2}s_{ 1}^{(i)}.\]

If \(z_{j-1}^{}{}^{(i)}=_{j-1}^{}{}^{(i)}-_{j-1}^{ }{}^{(i)}\) is sub-Gaussian with parameter \(_{j-1}^{}{}^{(i)}^{}{}^{(i)}}\) for any \(i\;=\;1,2,,m\), then using the recursions in (6) we have that

\[z_{j}^{(i)} =_{j}^{}{}^{(i)}-_{j}^{(i)}=_{j-1} ^{}{}^{(i)}+w_{j}^{(i)}-_{j}^{(i)}-^{(i)}}{s_{j-1}^{ }{}^{(i)}+s_{j}^{(i)}+d_{j}^{2(i)}}(_{j-1}^{-}{}^{(i)}- _{j}^{(i)})\] \[=_{j-1}^{}{}^{(i)}+w_{j}^{(i)}-_{j-1}^{ }{}^{(i)}+(1-^{(i)}}{s_{j-1}^{}{}^{(i)}+s_{j}^{(i) }+d_{j}^{2(i)}})(_{j-1}^{}{}^{(i)}-_{j}^{(i)})\] \[=_{j-1}^{}{}^{(i)}+w_{j}^{(i)}-_{j-1}^{ }{}^{(i)}-^{-(i)}}{s_{j}^{(i)}}(_{j}^{(i)}-_{j-1}^{ }{}^{(i)})\]

since \(_{j}=_{j}^{}-_{j-1}^{}\). If \(_{j}=_{j}-_{j}^{}\), the error in the mean vector estimate is given by

\[z_{j}^{(i)} =_{j-1}^{}{}^{(i)}+w_{j}^{(i)}-_{j-1}^{ }{}^{(i)}-^{(i)}}{s_{j}^{(i)}}(_{j}^{} {}^{(i)}+v_{j}^{(i)}-_{j-1}^{}{}^{(i)})\] \[=_{j-1}^{}{}^{(i)}+w_{j}^{(i)}-_{j-1}^{ }{}^{(i)}-^{-(i)}}{s_{j}^{(i)}}(_{j-1}^{}{}^{(i)}+w _{j}^{(i)}+v_{j}^{(i)}-_{j-1}^{}{}^{(i)})\] \[=(1-^{(i)}}{s_{j}^{(i)}})z_{j-1 }^{}{}^{(i)}+(1-^{(i)}}{s_{j}^{(i)}} )(w_{j}^{(i)})-^{(i)}}{s_{j}^{(i)}}v _{j}^{(i)}\]

where \(w_{j}^{(i)}\) and \(v_{j}^{(i)}\) are sub-Gaussian with parameter \((w_{j}^{(i)})\) and \((_{j}^{(i)})/}\), respectively. Therefore, we have that \(z_{j}^{(i)}\) is sub-Gaussian with parameter \(_{j}^{(i)}\) that satisfies

\[(_{j}^{(i)})^{2}= (1-^{(i)}}{s_{j}^{(i)}})^{2} (_{j-1}^{}{}^{(i)})^{2}+(1-^{ (i)}}{s_{j}^{(i)}})^{2}(w_{j}^{(i)})^{2}+ (^{(i)}}{s_{j}^{(i)}})^{2}^{(i)})^{2}}{n_{j}}\]

since \(_{j-1}^{}\), \(_{j}\), and \(_{j}\) are independent. Using that \(_{j-1}^{}{}^{(i)}^{}{}^{(i)}}\) and the definition of \(\), we have that

\[(_{j}^{(i)})^{2} (1-^{(i)}}{s_{j}^{(i)}})^{2 }^{2}s_{j-1}^{(i)}+(1-^{(i)}}{s_ {j}^{(i)}})^{2}^{2}d_{j}^{2(i)}+(^{(i)} }{s_{j}^{(i)}})^{2}^{2}^{2(i)}}{n_{j}}\] \[(1-^{(i)}}{s_{j}^{(i)}})^{2 }^{2}((^{(i)}}-^{(i)}} )^{-1}+d_{j}^{(i)})+^{(i)})^{2}}{ s_{j}^{(i)}}^{2}\] (16) \[=(1-^{(i)}}{s_{j}^{(i)}})^ {2}s_{j}^{(i)}+^{2}^{(i)} )^{2}}{s_{j}^{(i)}}\]

where (16) is obtained using the second recursion in (6).

The inequality in (15) is obtained using the union bound together with the Chernoff bound (concentration inequality)  for the random variables \(z_{j}^{(i)}\) that are sub-Gaussian with parameter \(_{j}^{(i)}\).

Now, we prove by induction that, for any \(j\), \(\|^{}}\|_{} M/^{}}\) where the ESSs satisfy \(n_{1}^{}=n_{1}\) and \(n_{j}^{} n_{j}+n_{j-1}^{}_{j}^{ }\|_{}}{\|_{j}^{}\|_{}+n_{j-1}^{ }\|_{j}^{2}\|_{}}\) for \(j 2\). For \(j=1\), using the definition of \(_{j}^{}\) in the second recursion in (6), we have that for any component \(i\)

\[(s_{1}^{(i)})^{-1}=(s_{1}^{(i)})^{-1}= }{_{1}^{2(i)}}}{M^{2}}.\]

Then, vector \(_{1}^{}\) satisfies

\[\|_{1}^{}}\|_{}}}= ^{}}}.\]

If \(\|_{j-1}^{}}\|_{} M/^{ }}\), then we have that for any component \(i\)

\[(s_{j}^{(i)})^{-1} =^{(i)}}+^{(i)}+d_{ j}^{2(i)}}^{(i)}}+}{n_{j-1}^{}}+d_{ j}^{2(i)}}}(n_{j}+^{}}+ ^{2(i)}}{M^{2}}})\] \[}(n_{j}+^{ }}+^{2}\|_{}}{\|_{j}^{2}\|_{ }}})\]

by using the second recursion in (6) and the induction hypothesis. Then, vector \(_{j}^{}\) satisfies

\[\|_{j}^{}}\|_{}+n_{j-1}^{}_{j}^{2}\|_{}}{\|_{j}^{2}\|_{}+n_{j-1}^{}\|_{j}^{2}\|_{ }}}}.\] (17)

The inequality in (8) is obtained because the minimax risk is bounded by the smallest minimax risk as shown in  so that

\[R(_{j}^{}) R_{j}^{}+(\|_{j}^{}-_{j}^{}\|_{}+\|_{j}^{}\|_{})\|_{j}^{} \|_{1}\]

that leads to (8) using (15), (17), and the fact that \(1)}\). 

## Appendix D Proof of Theorem 2

Proof.: To obtain bound in (9), we proceed by induction. For \(j=1\), using the expression for the ESS in (8), we have that

\[n_{1}^{}=n_{1} n.\]

If (9) holds for the \((j-1)\)-task, then for the \(j\)-th task, we have that

\[n_{j}^{} n_{j}+n_{j-1}^{} _{j}^{2}\|_{}}{\|_{j}^{2}\|_{}+n_{j-1}^{} \|_{j}^{2}\|_{}} n+n_{j-1}^{}^{}d^{2}}=n(1+^{} }+nd^{2}})\]

where the second inequality is obtained because \(n_{j} n\), \(\|_{j}^{2}\|_{} 1\), and \(\|_{j}^{2}\|_{} d^{2}\). Using that \(n_{j-1}^{} n(1+-1-}{ (1+)^{2j-3}+})\), the ESS of the \(j\)-th task satisfies

\[n_{j}^{}  n(1+-1- }{n(1+)^{2j-3}+}}+nd^{2})=n(1++}{(1+)^{2j-2}-1}+nd^{2}})\] \[=n(1++}{(1+ )^{2j-2}-1}+}{+1}})\] (18) \[=n(1+-1-}{(1+)^{2j -2}+(+1)+^{2}(1+)^{2j-2}-^{2}})\]

where (18) is obtained because \(nd^{2}=}{+1}\) since \(=}{2}(}}+1)\).

Now, we obtain bounds for the ESS if \(nd^{2}<}\). In the following, the constant \(\) represents the golden ratio \(=1.618\).

If \(nd^{2}<}}}  1\) because \(=}{2}(}+1})=} ++}}\), then we have that \(n_{j}^{-}\) satisfies

\[n_{j}^{} n(1+)=n(1+)\]

where the first inequality follows because \((1+)^{2j-2} 1+(2j-2)\). Using \(\), we have that

\[n_{j}^{} n(1+(2j-1)})  n(1+}) n(1+).\]

## Appendix E More efficient recursions for forward and backward learning

The Rauch-Tung-Striebel smoother recursions  allow to obtain forward and backward mean and MSE vectors directly from those vectors for the succeeding task. Specifically, for each \(j\)-th task, the mean vector \(_{j}^{=k}\) together with the MSE vector \(_{j}^{=k}\) can be obtained using those vectors for the succeeding task \(_{j+1}^{=k},_{j+1}^{=k}\) as

\[_{j}^{=k} =_{j}^{}+_{j}^{}}{ _{j}^{}+_{j+1}^{2}}(_{j+1}^{=k}- _{j}^{})\] \[_{j}^{=k} =(_{j}^{}}+(_{j+1}^{ 2}+(}{_{j+1}^{=k}}-_{j}^{}+ _{j+1}^{2}})^{-1})^{-1})^{-1}.\]

The above recursions provide the same mean vector estimate as the recursions in (10) in the paper since they are obtained using the Rauch-Tung-Striebel smoother recursions instead of fixed-lag smoother recursions .

## Appendix F Proof of Theorem 3

Proof.: To obtain bound in (11) we first prove that the mean vector estimate and the MSE vector given by (10) satisfy

\[\{|_{k}^{\,(i)}-_{j}^{=k\,(i)}|^{=k\,(i)}()}\}(1-)\] (19)

for any component \(i=1,2,,m\). Then, we prove that \(\|_{j}^{=k}\|_{} M/^{=k}}\) for \(j\{1,2,,k\}\), where the ESSs satisfy \(n_{k}^{=k}=n_{k}^{}\) and \(n_{j}^{=k} n_{j}^{}+n_{j+1}^{-k}_{j}^{2}\|_ {}}{\|_{j}^{2}\|_{}+\|_{j+1}^{2}\|_ {}}\) for \(j 2\).

To obtain inequality (19), we prove that each component \(i=1,2,,m\) of the error in the mean vector estimate \(z_{j}^{=k\,(i)}=_{j}^{\,(i)}-_{j}^{=k\,(i)}\) is sub-Gaussian with parameter \(_{j}^{=k\,(i)}^{=k\,(i)}}\). Analogously to the proof of Theorem 1, it is proven that each component in the error of the backward mean vector \(_{j+1}^{-k}\) is sub-Gaussian with parameters satisfying \(_{j+1}^{}_{j+1}^{=k}}\). The error in the forward and backward mean vector estimate is given by

\[z_{j}^{=k\,(i)}=_{j}^{\,(i)}-_{j}^{=k\,(i)}=_{j}^{\,( i)}-_{j}^{\,(i)}-^{\,(i)}}{s_{j}^{ \,(i)}+s_{j+1}^{-k\,(i)}+d_{j+1}^{2\,(i)}}(_{j+1}^{-k\,(i) }-_{j}^{\,(i)})\]where the second equality is obtained using the recursion for \(_{j}^{=k\,(i)}\) in (10). Adding and subtracting \(^{\,(i)}}{s_{j}^{\,(i)}+s_{j+1}^{\, (i)}+d_{j+1}^{2\,\,(i)}}_{j+1}^{\,\,(i)}\), we have that

\[z_{j}^{=k\,(i)} =z_{j}^{-(i)}-^{\,(i)}}{s_{j}^{ \,(i)}+s_{j+1}^{\,(i)}+d_{j+1}^{2\,\,(i)}}(_{j+1}^{ \,\,(i)}-_{j+1}^{\,\,(i)}+_{j+1}^{\,(i)}-_{ j}^{\,(i)})\] \[=z_{j}^{-(i)}-^{\,(i)}}{s_{j}^{ \,(i)}+s_{j+1}^{\,(i)}+d_{j+1}^{2\,\,(i)}}(_{j}^{ \,(i)}+w_{j+1}^{(i)}-z_{j+1}^{\,(i)}-_{j}^{\,(i)})\]

since \(_{j}=_{j}^{}-_{j-1}^{}\) and \(z_{j}^{\,(i)}=_{j}^{\,(i)}-_{j}^{\,(i)}\). Then, we have that

\[z_{j}^{=k\,(i)}=z_{j}^{\,(i)}-^{ \,(i)}}{s_{j}^{\,(i)}+s_{j+1}^{\,(i)}+d_{j +1}^{2\,\,(i)}}(z_{j}^{\,(i)}+w_{j+1}^{(i)}-z_{j+1}^{ \,(i)})\] (20) \[=(1-^{\,(i)}}{s_{j}^{\,(i) }+s_{j+1}^{\,(i)}+d_{j+1}^{2\,\,(i)}})z_{j}^{\,(i) }-^{\,(i)}}{s_{j}^{\,(i)}+s_{j+1}^{ \,(i)}+d_{j+1}^{2\,\,(i)}}(w_{j+1}^{(i)}-z_{j+1}^{\, (i)})\]

where \(z_{j}^{\,(i)}\), \(z_{j+1}^{\,(i)}\), and \(w_{j+1}^{(i)}\) are sub-Gaussian with parameters \(_{j}^{\,(i)}^{\,(i)}}\), \(_{j+1}^{\,(i)}^{\,(i)}}\), and \((w_{j}^{(i)})\), respectively. Since \(_{j}^{}\), \(_{j+1}^{}\), and \(_{j+1}\) are independent, we have that \(z_{j}^{=k\,(i)}\) given by (20) is sub-Gaussian with parameter that satisfies

\[(_{j}^{=k\,(i)})^{2}= (1-^{\,(i)}}{s_{j}^{\,(i) }+s_{j+1}^{\,(i)}+d_{j+1}^{2\,\,(i)}})^{2}(_{j}^{ \,(i)})^{2}\] \[+(^{\,(i)}}{s_{j}^{\,(i) }+s_{j+1}^{\,(i)}+d_{j+1}^{2\,\,(i)}})^{2}(( w_{j}^{(i)})^{2}+(_{j+1}^{\,(i)})^{2})\] \[ (1-^{\,(i)}}{s_{j}^{\,(i) }+s_{j+1}^{\,(i)}+d_{j+1}^{2\,\,(i)}})^{2}^{2}s_{j}^{ \,(i)}\] \[+(^{\,(i)}}{s_{j}^{\,(i) }+s_{j+1}^{\,(i)}+d_{j+1}^{2\,\,(i)}})^{2}^{2}(d _{j+1}^{\,\,(i)}+s_{j+1}^{\,(i)})\]

Using the second recursion in (10) we have that the sub-Gaussian parameter satisfies

\[(_{j}^{=k\,(i)})^{2} (1-^{=k\,(i)}}{s_{j+1}^{\,(i)}+d_{j+1 }^{2\,\,(i)}})^{2}^{2}(^{=k\,(i)}}-^{-k\,\,(i)}+d_{j+1}^{2\,\,(i)}})^{-1}\] \[+^{=k\,(i)})^{2}}{s_{j+1}^{-k\,\,(i)}+d_{j +1}^{2\,\,(i)}}^{2}\] \[=(^{\,(i)}+d_{j+1}^{2\,\,(i)}-s_{j} ^{=k\,(i)}}{s_{j+1}^{\,(i)}+d_{j+1}^{2\,\,(i)}})^{2}s_{ j}^{=k\,(i)}\] \[+^{=k\,(i)})^{2}}{s_{j+1}^{-k\,\,(i)}+d_{j +1}^{2\,\,(i)}}^{2}=^{2}s_{j}^{=k\,(i)}.\]

The inequality in (19) is obtained using the union bound together with the Chernoff bound (concentration inequality)  for the random variables \(z_{j}^{=k\,(i)}\) that are sub-Gaussian with parameter \(_{j}^{=k\,(i)}\).

Now, we prove that, for any \(j\), \(\|_{j}^{=k}}\| M/^{=k}}\) where the ESSs satisfy \(n_{k}^{=k}=n_{k}^{}\) and \(n_{j}^{=k} n_{j}^{}+n_{j+1}^{-k}_{j}^{2} \|_{}}{\|_{j}^{2}\|_{}+n_{j+1}^{-k}\|_{j+1}^{2}\|_ {}}\) for \(j 2\). Analogously to the proof of Theorem 1, we prove that the backward MSE vector \(_{j+1}^{-k}\) satisfies \(\|_{j+1}^{-k}}\|_{} M/^{-k}}\). Then, using that \(\|_{j+1}^{=k}}\|_{} M/^{-k}}\), we have that for every component \(i\)

\[(s_{j}^{=k(i)})^{-1} =^{}(i)}+^{-k (i)}+d_{j+1}^{2(i)}}^{}}{ _{j}^{2(i)}}+}{n_{j+1}^{2}}+d_{j+1}^{2 (i)}}\] \[}(n_{j}^{}+^{-k}}+^{2}}{M^{2}}})}(n_ {j}^{}+^{-k}}+^{2}\|_{ }}{\|_{j}^{2}\|_{}}}).\]

Then, we obtain

\[\|_{j}^{=k}}\|_{}^{} +^{-k}}+_{j+1}^{2}\|_{}}}}}.\] (21)

The inequality in (11) is obtained because the minimax risk is bounded by the smallest minimax risk as shown in  so that

\[R(_{j}^{=k}) R_{j}^{}+(\|_{j}^{}- {}_{j}^{=k}\|_{}+\|_{j}^{=k}\|_{})\| {}_{j}^{}\|_{1}\]

that leads to (11) using (19), (21), and the fact that \(1)}\). 

## Appendix G Proof of Theorem 4

Proof.: To obtain bound in (12), we use the ESS obtained with forward learning in Theorem 2 and obtained with backward learning. Analogously to the proof of Theorem 2, we prove that the ESS obtained at backward learning satisfies

\[n_{j+1}^{ k} n_{j+1}+n_{j+2}^{-k}_{j+1}^{ 2}\|_{}}{\|_{j+1}^{2}\|_{}+n_{j+2}^{-k}\|_{j+2}^{ 2}\|_{}} n(1+-1-}{(1+ )^{2(k-j)-1}+}).\]

Therefore, the ESS obtained with forward an backward learning satisfies

\[n_{j}^{=k}  n_{j}^{}+n(1+-1-}{(1+)^{2(k-j)-1}+})(1+\ -1-}{(1+)^{2(k-j )-1}+})}{nd^{2}})^{-1}\] \[= n_{j}^{}+n-1}{(1+ )^{2(k-j)-1}+}(1+\ }{+1}(1+-1-}{ (1+)^{2(k-j)-1}+}))^{-1}\]

where the second equality follows because \(nd^{2}=}{+1}\) since \(=}{2}(}}+1)\). Then, we have that

\[n_{j}^{=k} n_{j}^{}+n-1}{(1+ )^{2(k-j)-1}+}\] \[(+1)(+1+^{2})+ ((1+)^{2(k-j)-1}-1-)}{(+1)((1+)^{2(k-j)-1}+1)} )^{-1}\] \[ n_{j}^{}+n-1}{(1+ )^{2(k-j)-1}+}+1)}{(1+ )^{2(k-j)+1}+1}.\]

Now, we obtain bounds for the ESS depending on the value value of \(nd^{2}\). Such bounds are obtained similarly as in Theorem 2 and we also denote by \(\) the golden ratio \(=1.618\).

1. If \(nd^{2}<}}}  1\) because \[=nd^{2}}}+1}{2}=}+4}+}}{2}\] then we have that \(n_{j}^{ k}\) satisfies \[n_{j}^{=k} n_{j}^{}+n=n_{j}^{}+n n_{j}^{ }+n(k-j)}\] where the first inequality follows because \((1+)^{2(k-j)-1} 1+(2(k-j)-1)\) and the second inequality is obtained using \(\).
2. If \(} nd^{2}<1} }\) because \[=nd^{2}}}+1}{2}=}+4}+}}{2}\] then we have that \(n_{j}^{ k}\) satisfies \[n_{j}^{=k} n_{j}^{}-1}{(1+)^{2(k-j)}+1} n_{j}^{} })^{2(k-j)}-1}{(1+})^{2(k-j)}+1}\] where the second inequality follows because the ESS is monotonically increasing for \(\) and \( nd^{2}\). Since \((1+})^{2(k-j)} 1+2}(k-j)\) and \(k-j 1\), we have that \[n_{j}^{=k} n_{j}^{}+}}{1+ }} n_{j}^{}+n}}\] because \(}\).
3. If \(nd^{2} 1\, 1 nd^{2} nd^{2}\) because \(=nd^{2}}}+1}{2}\), then we have that \(n_{j}^{}}{{=}}k}\) satisfies \[n_{j}^{=k} n_{j}^{}+n-1}{2 ^{2(k-j)}+1} n_{j}^{}+n}\] where the first inequality follows because the ESS is monotonically increasing for \(\) and \( 1\) and the second inequality is obtained using \(k-j 1\) and \( nd^{2}\).

## Appendix H Additional numerical results and implementation details

In this section we describe the datasets used for the numerical results in Section 5, we provide further details for the numerical experimentations carried out, and include several additional results. Specifically, in the first set of additional results, we evaluate the classification performance of the proposed method in comparison with state-of-the-art techniques for different sample sizes; in the second set of additional results, we further show the performance improvement leveraging information from all the tasks in the sequence with additional datasets; in the third set of additional results, we show the classification error and the running time of IMRCs for different hyper-parameter values; and in the fourth set of additional results, we evaluate the assumption of change between tasks being independent and zero-mean. In addition, in the folder Implementation_IMRC in the supplementary materials we provide the code of the proposed IMRCs with the setting used in the numerical results.

In Section 5, we use \(12\) publicly available datasets , and http://yann.lecun.com/exdb/mnist/. The summary of these datasets is provided in Table 3 that shows the number of classes, the number of samples, and the number of tasks. In the following, we further describe the tasks and the time-dependency of each dataset used.

* The "Yearbook" dataset contains portraits' photographs over time and the goal is to predict males and females. Each task corresponds to portraits from one year from 1905 to 2013.
* The "ImageNet noise" dataset contains images with increasing noise over tasks and the goal is to predict if an image is a bird or a snake. The sequence of tasks corresponds to the noise factors \([0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6]\).
* The "DomainNet" dataset contains six different domains with decreasing realism and the goal is to predict if an image is an airplane, bus, ambulance, or police car. The sequence of tasks corresponds to the six domains: real, painting, infograph, clipart, sketch, and quickdraw.
* The "UTKFaces" dataset contains face images in the wild with increasing age and the goal is to predict males and females. The sequence of tasks corresponds to face images with different ages from 0 to 116 years.
* The "Rotated MNIST" dataset contains rotated images with increasing angles over tasks and the goal is to predict if the number in an image is greater than \(5\) or not. Each \(j\)-th task corresponds to a rotation angle randomly selected from \([,]\) degrees where \(j\{1,2,,k\}\) and \(k\) is the number of tasks.
* The "CLEAR" dataset contains images with a natural temporal evolution of visual concepts and the goal is to predict if an image is soccer, hockey, or racing. Each task corresponds to one year from 2004 to 2014.
* The "Power Supply" dataset contains three year power supply records from 1995 to 1998 and the goal is to predict which hour the current power supply belongs to. We relabel into binary classification according to pm. or am. as in .
* The "Usenet" dataset is splitted into Usenet1 and Usenet2 which both contains a stream of messages from different \(20\) newsgroups that are sequentially presented to a user and the goal is to predict the personal interests.
* The "German" dataset contains information about people who take a credit by a bank and the goal is to classify each person as good or bad credit risks.
* The "Spam" dataset contains emails and the task is to predict if an email is malicious spam email or legitimate email.
* The "Covertype" dataset contains cartographic variables of a forest area obtained from US Forest Service (USFS) and the goal is to predict the forest cover type.

The samples in each task are randomly splitted in 100 samples for test and the rest of the samples for training. The samples used for training in the numerical results are randomly sampled from each group of training samples in each repetition.

In Section 5, we compare the results of IMRC methods with \(7\) state-of-the-art-techniques . In the following, we briefly describe each method used.

* GEM method  is a technique developed for continual learning. The method provided by Lopez-Paz & Ranzato learns each new task using a stochastic gradient descent with inequality constraints given by the losses of preceding tasks. Such constraints avoid the increase of the loss of each preceding tasks.
* MER method  is a technique developed for continual learning. The method provided by Riemer et al. learns each new task using sample sample sets that include random samples of preceding tasks. Such samples of preceding tasks are stored in a memory buffer.
* ELLA method  is a techniques developed for continual learning. The method provided by Ruvolo & Eaton learns each new task transferring knowledge from a shared basis of task models.
* EWC method  is a technique developed for continual learning. The method provided by Kirkpatrick et al. learns each new task regularizing the loss with regularization parameters given by the Fisher information.
* Condor method  is a technique developed for concept drift adaptation. The method provided by Zhao et al. is an ensemble method that adapts to evolving tasks by learning weighting the models in the ensemble at each time step.

* DriftSurf method  is a technique developed for concept drift adaptation. The method provided by Tahmasbi et al. adapts to evolving tasks by using a drift detection method. Such method allows to restart a new model when a change in the distribution is detected.
* AUE method  is a technique developed for concept drift adaptation. The method provided by Brzezinski & Stefanowski is an ensemble method that adapts to evolving tasks by incrementally updating all classifiers in the ensemble and weighting them with non-linear error functions.

The classifier parameters in the numerical results are obtained using an accelerated subgradient method based on Nesterov approach [32; 33]. Such subgradient method applied to optimization (3) obtains at each step classifier parameters \(\) from the mean and confidence vectors \(,\) using the iterations for \(l~{}=~{}1,2,,K\)

\[}(l+1) =(l)+a_{l}- ((l))-((l)) \] (22) \[(l+1) =}(l+1)+_{l+1}(_{l}^{-1}-1)( (l)-}(l))\]

where \(()\) denotes the sign function, \((l)\) is the \(l\)-th iterate for \(\), \(_{l}=2/(l+1)\) and \(a_{l}~{}=~{}1/(l~{}+~{}1)^{3/2}\) are the step sizes and \(((l))\) denotes a subgradient of \(()\) at \((l)\) with

\[()=_{x,}}(x,y)^{}-1}{| |}.\]

In addition, the above subgradient method is implemented using \(K=2000\) iterations and a warm-start that initializes the classifier parameters in (22) with the solution obtained for the closest task.

   Dataset & Classes & Samples & Tasks \\  Yearbook  & 2 & 37,921 & 126 \\ ImageNet Noise  & 2 & 12,000 & 10 \\ DomainNet  & 4 & 6,256 & 6 \\ UTKFace  & 2 & 23,500 & 94 \\ Rotated MNIST  & 2 & 70,000 & 60 \\ CLEAR  & 3 & 10,490 & 10 \\ Power Supply  & 2 & 29,928 & 99 \\ Usenet1  & 2 & 1,500 & 5 \\ Usenet2  & 2 & 1,500 & 5 \\ German  & 2 & 1,000 & 3 \\ Spam  & 2 & 6,213 & 20 \\ Covertype  & 2 & 581,012 & 1,936 \\   

Table 3: Datasets characteristics.

Figure 5: Forward and backward learning can sharply boost performance and ESS as tasks arrive.

  Method & GEM & MER & ELLA & EWC & Condor & DriftSur & AUE & IMRC \\  Yearbook &.16 \(\).03 &.10 \(\).01 &.43 \(\).08 &.22 \(\).02 &.09 \(\).01 &.23 \(\).01 & **.08**\(\).01 \\ I. noise &.12 \(\).03 & **.07**\(\).01 &.47 \(\).04 &.45 \(\).07 &.09 \(\).01 &.48 \(\).02 &.48 \(\).02 &.08 \(\).01 \\ DomainNet &.49 \(\).10 &.28 \(\).02 &.67 \(\).05 &.74 \(\).05 &.43 \(\).01 &.32 \(\).00 &.32 \(\).00 & **.27**\(\).02 \\ UTKFaces &.12 \(\).00 &.11 \(\).01 &.17 \(\).11 &.12 \(\).00 & **.10**\(\).01 &.12 \(\).00 &.12 \(\).00 & **.10**\(\).00 \\ R. MNIST &.27 \(\).01 &.47 \(\).05 &.47 \(\).05 &.38 \(\).01 &.41 \(\).02 &.48 \(\).02 & **.20**\(\).01 \\ CLEAR &.08 \(\).01 &.05 \(\).02 &.60 \(\).04 &.60 \(\).04 &.36 \(\).01 &.33 \(\).00 &.33 \(\).00 & **.04**\(\).01 \\ P. Supply &.47 \(\).01 &.48 \(\).02 &.30 \(\).01 &.47 \(\).01 &.36 \(\).01 &.36 \(\).00 &.36 \(\).01 & **.24**\(\).00 \\ Usenet1 &.47 \(\).02 &.41 \(\).03 & **.29**\(\).01 &.48 \(\).01 &.43 \(\).02 &.39 \(\).00 &.39 \(\).01 & **.29**\(\).01 \\ Usenet2 &.34 \(\).00 &.29 \(\).00 & **.26**\(\).01 &.32 \(\).01 &.32 \(\).02 & **.26**\(\).00 &.28 \(\).00 &.31 \(\).00 \\ German &.34 \(\).01 &.30 \(\).00 & **.25**\(\).01 &.30 \(\).02 &.31 \(\).01 &.29 \(\).01 &.29 \(\).01 &.28 \(\).01 \\ Spam & **.07**\(\).01 & **.07**\(\).01 &.23 \(\).03 &.13 \(\).02 &.11 \(\).02 &.32 \(\).01 &.33 \(\).01 & **.07**\(\).00 \\ Covert. &.08 \(\).00 &.08 \(\).00 &.10 \(\).01 &.08 \(\).00 & **.07**\(\).02 &.09 \(\).00 &.09 \(\).00 &.08 \(\).00 \\  

Table 6: Classification error and standard deviation of the proposed IMRC method in comparison with the existing techniques for \(n=150\) samples per task.

  Method & GEM & MER & ELLA & EWC & Condor & DriftSur & AUE & IMRC \\  Yearbook &.16 \(\).02 &.11 \(\).01 &.43 \(\).10 &.38 \(\).02 &.11 \(\).02 &.29 \(\).02 &.29 \(\).02 & **.10**\(\).02 \\ I. noise &.16 \(\).06 & **.10**\(\).01 &.47 \(\).05 &.47 \(\).05 & **.10**\(\).02 &.48 \(\).02 & **.48**\(\).02 & **.10**\(\).02 \\ DomainNet &.65 \(\).05 &.29 \(\).02 &.67 \(\).05 &.75 \(\).05 &.45 \(\).01 &.32 \(\).00 &.32 \(\).00 & **.28**\(\).03 \\ UTFKaces &.12 \(\).00 &.11 \(\).09 &.18 \(\).11 &.12 \(\).00 &.14 \(\).02 &.12 \(\).00 &.12 \(\).00 & **.10**\(\).00 \\ R. MNIST &.29 \(\).04 &.41 \(\).13 &.48 \(\).05 &.44 \(\).01 &.43 \(\).01 &.48 \(\).02 & 48 \(\).02 & **.25**\(\).02 \\ CLEAR &.

In the **first set of additional results**, we further compare the classification error of IMRCs with the state-of-the-art techniques. The results in Table 1 in the paper as well as Tables 4, 5, and 6 are obtained computing the classification error \(50\) times for each sample size. Table 1 in the paper shows classification errors for \(n=10\) samples, while Tables 4, 5, and 6 show the classification error for \(n~{}=~{}50\), \(n=100\), and \(n=150\) samples, respectively. As can be observed in Table 4, the performance improvement of IMRCs in comparison with the state-of-the-art techniques for \(n~{}=~{}50,n=100\), and \(n=150\) is similar to that shown in the paper for \(n=10\).

In the **second set of additional results**, we further illustrate the relationship among classification error, number of tasks, and sample size. Figure 4 in the paper as well as Figure 5 are obtained computing the classification error over all the sequences of consecutive tasks of length \(k\) in the dataset. Then, we repeat such experiment \(10\) times with randomly chosen training sets of size \(n\). Figure 5 extends the results for IMRCs using "DomainNet" dataset completing those in the main paper that show the results using "Yearbook" dataset. Figure 4(a) shows the classification error of IMRC method divided by the classification error of single-task learning for different number of tasks with \(n=10\) and \(n=100\) sample sizes. In addition, Figure 4(b) shows the classification error of IMRC method for different sample sizes with \(k=10\) tasks. Figures 4(a) and 4(b) show similar behavior to Figures 5(a) and 5(b) in the paper, respectively. In addition, Figure 6 shows the classification error of IMRCs per step and task with single-task learning, forward learning, and forward and backward learning using the "Yearbook" dataset. Such figure shows that forward and backward learning can improve performance of preceding tasks, while forward learning and single task learning maintain the same performance over time.

In the **third set of additional results**, we further assess the change in classification error and the running time of IMRCs varying the hyper-parameters. Table 7 shows the classification error of IMRCs varying the values of hyper-parameter for the window size \(W\) and the number of backward steps \(b\), completing those in the paper that show the results for \(W=2\) and \(b=3\). As shown in the table, the proposed IMRCs do not require a careful fine-tuning of hyper-parameters and similar performances are obtained by using different values. In addition, Table 8 shows the mean running

   Hyper-parameter & \(W=2\) & \(W=4\) & \(W=6\) & \(b=1\) & \(b=2\) & \(b=3\) & \(b=4\) & \(b=5\) \\  Sample size \(n\) & 10 & 100 & 10 & 100 & 10 & 100 & 100 & 100 & 100 & 100 & 100 & 100 & 100 & 100 \\  Yearbook &.13 &.08 &.13 &.09 &.13 &.09 &.14 &.10 &.09 &.14 &.13 &.08 &.13 &.08 \\ ImageNet noise &.15 &.09 &.15 &.09 &.15 &.09 &.15 &.09 &.15 &.09 &.15 &.09 &.15 &.08 &.15 &.08 \\ DomainNet &.34 &.28 &.32 &.27 &.33 &.28 &.36 &.29 &.35 &.28 &.34 &.28 &.34 &.28 &.34 &.28 \\ UTKFaces &.10 &.10 &.10 &.10 &.10 &.10 &.10 &.10 &.10 &.10 &.10 &.10 &.10 &.10 &.10 &.10 \\ Rotated MNIST &.36 &.21 &.35 &.21 &.36 &.21 &.36 &.22 &.36 &.22 &.36 &.21 &.36 &.21 \\ CLEAR &.09 &.05 &.09 &.05 &.09 &.06 &.10 &.05 &.09 &.05 &.09 &.05 &.09 &.05 &.08 &.05 \\ Weather &.31 &.31 &.31 &.31 &.31 &.31 &.31 &.31 &.31 &.31 &.31 &.31 &.31 &.31 &.31 \\ Power Supply &.30 &.25 &.30 &.25 &.30 &.25 &.32 &.27 &.31 &.26 &.30 &.25 &.30 &.25 &.30 &.25 \\ Usenet1 &.32 &.30 &.33 &.31 &.33 &.31 &.32 &.30 &.32 &.30 &.32 &.30 &.32 &.30 \\ Usenet2 &.33 &.30 &.34 &.31 &.34 &.31 &.34 &.30 &.33 &.30 &.33 &.30 &.32 &.30 \\ German &.34 &.29 &.34 &.29 &.34 &.29 &.34 &.29 &.34 &.29 &.34 &.29 &.34 &.29 \\ Spam &.13 &.08 &.14 &.08 &.13 &.08 &.14 &.09 &.13 &.08 &.13 &.08 &.12 &.07 &.12 &.07 \\ Covertype &.08 &.08 &.08 &.08 &.08 &.08 &.08 &.08 &.08 &.08 &.08 &.08 &.08 &.08 &.08 \\   

Table 7: Classification error of the proposed IMRC method varying \(W\) and \(b\).

Figure 6: Forward and backward learning can improve performance of preceding tasks.

[MISSING_PAGE_FAIL:25]