# Three Iterations of \((d-1)\)-WL Test Distinguish Non Isometric Clouds of \(d\)-dimensional Points

Valentino Delle Rose\({}^{1,2}\), Alexander Kozachinskiy\({}^{1,3}\), Cristobal Rojas\({}^{1,2}\)

Mircea Petrache\({}^{1,2,4}\), Pablo Barcelo\({}^{1,2,3}\)

\({}^{1}\) Centro Nacional de Inteligencia Artificial, Chile

\({}^{2}\) Instituto de Ingenieria Matematica y Computacional, Universidad Catolica de Chile

\({}^{3}\) Instituto Milenio Fundamentos de los Datos, Chile

\({}^{4}\) Departamento de Matematica, Universidad Catolica de Chile

valentino.dellerose@cenia.cl, alexander.kozachinskiyi@cenia.cl

cristobal.rojas@mat.uc.cl, mpetrache@mat.uc.cl, pbarcelo@uc.cl

###### Abstract

The Weisfeiler-Lehman (WL) test is a fundamental iterative algorithm for checking the isomorphism of graphs. It has also been observed that it underlies the design of several graph neural network architectures, whose capabilities and performance can be understood in terms of the expressive power of this test. Motivated by recent developments in machine learning applications to datasets involving three-dimensional objects, we study when the WL test is _complete_ for clouds of Euclidean points represented by complete distance graphs, i.e., when it can distinguish, up to isometry, any arbitrary such cloud. Our main result states that the \((d-1)\)-dimensional WL test is complete for point clouds in \(d\)-dimensional Euclidean space, for any \(d 2\), and only three iterations of the test suffice. Our result is tight for \(d=2,3\). We also observe that the \(d\)-dimensional WL test only requires one iteration to achieve completeness.

## 1 Introduction

**Context.** Recent work in machine learning has raised the need to develop effective and efficient tests for checking if two three-dimensional point clouds, i.e., finite sets of points in \(^{3}\), are _isometric_. Recall that, given two such point clouds \(P\) and \(Q\), an isometry is a distance-preserving bijection between the points in \(P\) and \(Q\). The importance of these tests is that they provide the foundations for designing neural network architectures on point clouds that are capable of fully exploiting the structure of the data . It has been observed that the _incompleteness_ of any such an architecture, i.e., the inability to recognize a point cloud up to isometry, can affect its learning performance . Understanding which is the simplest test that allows detecting isometries in this scenario is thus essential not only for developing "complete" architectures but also to make them as efficient as possible in terms of the computational resources they need to use.

Point clouds can be represented as complete graphs in which each edge is labeled with the distance between the corresponding points. Under this representation, detecting the isometry of two point clouds is reduced to detecting an isomorphism between their graph representation. Not surprisingly, then, much of the work on developing so-called _geometric_ tests for detecting isometries over point clouds is inspired by the literature on isomorphism tests from graph theory. Of particular importancein this context has been the use of geometric versions of the well-known _Weisfeiler-Lehman test_ (WL test) for graph isomorphism .

Intuitively, the \(\)-dimensional geometric WL test (\(\)-WL test), for \( 1\), iteratively colors each tuple \(\) of \(\) points in a point cloud. The color of \(\) in round 0 is a complete description of the mutual distances between the points that belong to the tuple. In round \(t+1\), for \(t 0\), the color of \(\) is updated by combining in a suitable manner its color in iteration \(t\) with the color of each one of its _neighbors_, i.e., the tuples \(^{}\) that are obtained from \(\) by exchanging exactly one component of \(\) with another point in the cloud. The dimensionality of the WL test is therefore a measure of its computational cost: the higher the \(\), the more costly it is to implement the \(\)-dimensional WL test.

For checking if two point clouds are isometric, the geometric WL test compares the resulting color patterns. If they differ, then we can be sure the point clouds are not isometric (that is, the test is _sound_). An important question, therefore, is what is the minimal \( 1\) for which the geometric \(\)-WL test is _complete_, i.e., the fact that the color patterns obtained in two point clouds are the same implies that they are isometric.

There has been important progress on this problem recently: (a) Pozdnyakov and Ceriotti have shown that the geometric 1-WL test is incomplete for point clouds in 3D; that is, there exist isometric point clouds in three dimensions that cannot be distinguished by the geometric 1-WL test ; (b) Hordan et al. have proved that 3-WL test is complete in 3D after 1 iteration when initialized with Gram matrices of the triples of points instead of the mutual distances in these triples. A similar result has recently been obtained in . Hordan et al. also gave a complete "2-WL-like" test, but this test explicitly uses coordinates of the points.

As further related results, in , geometric WL tests have been compared to the expressivity of invariant and equivariant graph neural networks. Non-geometric related results include e.g. , where for explicit graphs on \(n\) vertices it is shown that \(\)-WL requires \(O(n)\) iterations for distinguishing them, whereas \(2\)-WL requires \(O()\) and \((3-1)\)-WL requires \(O( n)\) iterations, and , which has a promising proposal for generalized distances on non-geometric graphs, based on biconnectivity.

**Main theoretical results.** Our previous observation show an evident gap in our understanding of the problem: What is the minimum \(\), where \(=2,3\), for which the geometric \(\)-dimensional WL test is complete over three-dimensional point clouds? Our main contributions are the following:

* We show that for any \(d>1\) the geometric \((d-1)\)-WL test is complete for detecting isometries over point clouds in \(^{d}\). This is the positive counterpart of the result in  (namely, that geometric 1-WL test is incomplete in dimension \(d=3\)), by showing that geometric 1-WL is complete for \(d=2\) and that geometric 2-WL test is complete for \(d=3\). Further, only three rounds of the geometric \((d-1)\)-WL test suffice to obtain this completeness result.
* We provide a simple proof that a single round of the geometric \(d\)-WL test is sufficient for identifying point clouds in \(^{d}\) up to isometry, for each \(d 1\). This can be seen as a refinement of the result in , with the difference that our test is initialized with the mutual distances inside \(d\)-tuples of points (as in the classical setting) while theirs is initialized with Gram matrices of \(d\)-tuples of points. In other words, the initial coloring of , for each \(d\)-tuple of points, in addition to their pairwise distances, includes their distances to the _origin_, while in our result we do not require this additional information.

These results, as well as previously mentioned results obtained in the literature, are all based on the standard _folklore_ version of the \(\)-WL test (as defined, e.g., in ). This is important because another version of the test, known as the _oblivious_\(\)-WL test, has also been studied in the machine learning literature . It is known that, for each \( 1\), the folklore \(\)-WL test has the same discriminating power as the oblivious \((+1)\)-WL test .

Table 1 summarizes the state of the art concerning the distinguishing power of the geometric \(\)-WL test; note that it is not known whether the \((d-2)\)-WL test is incomplete for \(d 4\).

Relationship with graph neural networks.Graph Neural Networks (GNNs) are specialized neural networks designed to process data structured as graphs . Among GNNs, _Message Passing_ GNNs (MPGNNs) use a message-passing algorithm to disseminate information between nodes in a graph . The relationship between the 1-WL test and MPGNNs is now a fundamental subject in this field. Seminal research has shown that these two approaches are essentially equivalent in their ability to distinguish non-isomorphic graph pairs [14; 18]. Additionally, Morris et al.  proposed _higher-dimensional_\(\)-MPGNNs that have the same discriminating power as the oblivious \(\)-WL test, and hence as the folklore \((-1)\)-WL test, for \(>1\).

The geometric WL test studied here corresponds to a particular case of the _relational_ WL test, i.e., a suitable version of the WL test that is tailored for edge-labeled graphs. Connections between the relational WL test and so-called _relational_ MPGNNs have recently been established by . In particular, relational \(\)-MPGNNs have the same discriminating power as the (folklore) geometric \((-1)\)-WL test, for \(>1\). Our main result implies then that there is no need to create specialized GNN architectures for distinguishing non-isometric point clouds in \(^{d}\). Instead, relational \(d\)-MPGNNs are sufficient for this task.

Experimental evaluation of MPGNNs, based on the folklore 2-WL test, on data sets from molecular physics, and their comparison with state-of-art models, was recently performed in .

## 2 Formal Statement of the Main Result

Consider a cloud of \(n\) points \(S=\{p_{1},,p_{n}\}\) in \(^{d}\). We are interested in the problem of finding representations of such clouds that completely characterize them up to isometries, while at the same time being efficient from an algorithmic point of view. Our main motivation is to understand the expressiveness of the WL algorithm when applied to point clouds in euclidean space seen as complete distance graphs. Let us briefly recall how this algorithm works.

A function whose domain is \(S^{}\) will be called an _\(\)-coloring_ of \(S\). The \(\)-WL algorithm is an iterative procedure which acts on \(S\) by assigning, at iteration \(i\), an \(\)-coloring \(^{(i)}_{,S}\) of \(S\).

**Initial coloring.** The initial coloring, \(^{(0)}_{,S}\), assigns to each \(\)-tuple \(=(x_{1},,x_{}) S^{}\) the color \(^{(0)}_{,S}()\) given by the \(\) matrix

\[^{(0)}_{,S}()_{ij}=d(x_{i},x_{j}) i,j=1,,\]

of the relative distances inside the \(\)-tuple (for \(=1\) we have a trivial coloring by the \(0\) matrix).

**Iterative coloring.** At each iteration, the _\(\)-WL algorithm_ updates the current coloring \(^{(i)}_{,S}\) to obtain a refined coloring \(^{(i+1)}_{,S}\). The update operation is defined slightly differently depending on whether \(=1\) or \( 2\).

* For \(=1\), we have: \[^{(i+1)}_{1,S}(x)=^{(i)}_{1,S}(x),\{-2.845276pt\{(d(x,y),^{(i)}_{1,S}(y)) y S\}-2.845276pt\}.\] That is, first, \(_{i+1}(x)\) remembers the coloring of \(x\) from the previous step. Then it goes through all points \(y S\). For each \(y\), it stores the distance from \(x\) to \(y\) and also the coloring

 ^{d}\)?_} \\   & 1-WL & 2-WL & 3-WL \\  ^{2}\)} & **Complete** & **Complete** & \\  & in 3 iterations & in 1 iteration & \\  & Theorem 2.1 & Theorem 5.1 & \\  & **Incomplete** & **Complete** & **Complete** \\ \(^{3}\) & & **in 3 iterations** & in 1 iteration \\  &  & Theorem 2.1 & Theorem 5.1 \\  & & **Incomplete** & **Complete** \\ \(^{4}\) & & **Open** & **in 3 iterations** \\  & & & Theorem 2.1 \\   & \((d-2)\)-WL & \((d-1)\)-WL & \(d\)-WL \\  ^{d}\)} & **Open** & **Complete** & **Complete** \\  & **in 3 iterations** & in 1 iteration \\  & & **Theorem 2.1** & Theorem 5.1 \\  

Table 1: What is known about the distinguish power of geometric \(\)-WL.

[MISSING_PAGE_EMPTY:4]

* if \(0,u,v\) lie on the same line, then all points of \(S\) lie on this line;
* if \(0,u,v\) do not lie on the same line, then the interior of \((u,v)=\{ u+ v:,[0,+)\}\) does not contain points from \(S\) (see the first picture on Figure 1, the red area between \((0,u)\) and \((0,v)\) is disjoint from \(S\)).

In order to initialize our reconstruction algorithm, we need the following information about \(S\). We assume that \(S\) has more than 1 point (otherwise there is nothing to do).

_Initialization Data_: the initialization data consists of a real number \(d_{0} 0\) and two multisets \(M,M^{}\) such that for some \(u,v S\), satisfying the cone condition, it holds that \(d_{0}=d(u,v)\) and

\[M=M_{u}=\{\!\!\{\!(d(u,y),\|y\|):y S\!\! \}\!\}; M^{}=M_{v}=\{\!\!\{\!(d(v,y), \|y\|):y S\!\!\}\!\}\!.\]

We will start by describing the Reconstruction Algorithm, assuming that the initialization data is given. We will then show how to extract this data from \(^{(3)}_{1,S}\) in the Initialization Step bellow.

_Reconstruction algorithm._ Assume that initialization data \((d_{0},M,M^{})\) is given. Our task is to determine \(S\) up to isometry. Note that from \(M\) we can determine \(\|u\|\). Indeed, in \(M\) there exists exactly one element whose first coordinate is \(0\), and this element is \((0,\|u\|)\). Likewise, from \(M^{}\) we can determine \(\|v\|\). We are also given \(d_{0}=d(u,v)\). Overall, we have all the distances between 0, \(u\), and \(v\). Up to a rotation of \(S\), there is only one way to put \(u\), it has to be somewhere on the circle of radius \(\|u\|\), centered at the origin. We fix any point of this circle as \(u\). After that, there are at most two points where we can have \(v\). More specifically, \(v\) belongs to the intersection of two circles: one of radius \(\|v\|\) centered at the origin, and the other of radius \(d(u,v)\) centered at \(u\). These two circles are different (remember that the cone condition includes a requirement that \(u 0\)). Hence, they intersect by at most two points. These points are symmetric w.r.t. the line that connects the centers of the two circles, i.e., \(0\) and \(u\). Thus, up to a reflection through this line (which preserves the origin and \(u\)), we know where to put \(v\).

Henceforth, we can assume the coordinates of \(u\) and \(v\) are known to us. Note that so far, we have applied to \(S\) a translation (to put the barycenter at the origin), a rotation (to fix \(u\)), and a reflection (to fix \(v\)). We claim that, up to this isometry, \(S\) can be determined uniquely.

Let \(_{u}\) and \(_{v}\) denote the reflections through the lines \((0,u)\) and \((0,v)\), respectively. We first observe that from \(M\) we can restore each point of \(S\) up to a reflection through the line \((0,u)\). Likewise, from \(M^{}\) we can do the same with respect to the line \((0,v)\). More precisely, we can compute the following multisets:

\[L_{u}=\{\!\!\{y,_{u}y\} y S\!\!\}\!, L_{v}=\{\!\!\{y,_{v}y\} y S\!\! \}\!.\]

Indeed, consider any \((d(u,y),\|y\|) M\). What can we learn about \(y S\) from this pair of numbers? These numbers are distances from \(y\) to \(u\) and to \(0\). Thus, \(y\) must belong to the intersection of two circles: one with the center at \(u\) and radius \(d(u,y)\) and the other with the center at \(0\) and radius \(\|y\|\). Again, since \(u 0\), these two circles are different. Thus, we obtain at most two points \(z_{1},z_{2}\) where one can put \(y\). We will refer to these points as _candidate locations_ for \(y\) w.r.t. \(u\). They can be obtained one from the other by the reflection \(_{u}\) through the line connecting \(0\) and \(u\). Hence, \(\{z_{1},z_{2}\}=\{y,_{u}y\}\). To compute \(L_{u}\), we go through \((d(u,y),\|y\|) M\), compute candidate locations \(z_{1},z_{2}\) for \(y\), and put \(\{z_{1},z_{2}\}\) into \(L_{u}\). In a similar fashion, one can compute \(L_{v}\) from \(M^{}\).

Let us remark that elements of \(L_{u}\) and \(L_{v}\) are sets of size 2 or 1. A set of size 2 appears as an element of \(L_{u}\) when some \(y\) has two distinct candidate locations w.r.t. \(u\), that is when \(y\) does not lie on the line \((0,u)\). In turn, when \(y\) does lie on this line, we have \(z_{1}=z_{2}=y\) for two of its candidate locations, giving us an element \(\{y\} L_{u}\), determining \(y\) uniquely. The same thing happens with respect to \(L_{v}\) for points that lie on the line \((0,v)\),

The idea of our reconstruction algorithm is to gradually exclude some candidate locations so that more and more points get a unique possible location. What allows us to start is that \(u\) and \(v\) satisfy the cone condition; this condition gives us some area that is free of points from \(S\) (thus, one can exclude candidates belonging to this area).

The easy case is when \(0,u\), and \(v\) belong to the same line. Then, by the cone condition, all points of \(S\) belong to this line. In this case, every point of \(S\) has just one candidate location. Hence, both multisets \(L_{u}\) and \(L_{v}\) uniquely determine \(S\).

Assume now that \(0,u\), and \(v\) do not belong to the same line. As in the previous case, we can uniquely restore all points that belong to the line connecting \(0\) and \(u\), or to the line connecting \(0\) and \(v\) (although now these are two different lines). Indeed, these are points that have exactly one candidate location w.r.t. \(u\) or w.r.t. \(v\). They can be identified by going through \(L_{u}\) and \(L_{v}\) (we are interested in points \(z\) with \(\{z\} L_{u} L_{v}\)).

The pseudocode for our reconstruction algorithm is given in Algorithm 1. We now give its verbal description. Let us make a general remark about our algorithm. Once we find a unique location for some \(y S\), we remove it from our set in order to reduce everything to the smaller set \(S\{y\}\). This is implemented by updating the multisets \(L_{u}\) and \(L_{v}\) so that \(y\) is not taken into account in them. For that, we just remove \(\{y,_{u}y\}\) from \(L_{u}\) and \(\{y,_{v}y\}\) from \(L_{v}\) (more precisely, decrease their multiplicities by 1).

From now on, we assume that these two lines (connecting \(0\) and \(u\), and \(0\) and \(v\), respectively) are free of the points of \(S\). These lines contain the border of the cone \((u,v)\). At the same time, the interior of this cone is disjoint from \(S\) due to the cone condition. Thus, in fact, the whole \((u,v)\) is disjoint from \(S\).

We now go through \(L_{u}\) and \(L_{v}\) in search of points for which one of the candidate locations (either w.r.t. \(u\) or w.r.t. \(v\)) falls into the "forbidden area", that is, into \((u,v)\). After restoring these points and deleting them, we notice that the "forbidden area" becomes larger. Indeed, now in \(S\) there are no points that fall into \((u,v)\) under one of the reflections \(_{u}\) or \(_{v}\). In other words, the updated "forbidden area" is \(F=(u,v)_{u}(u,v)_{v }(u,v)\). If the absolute angle between \(u\) and \(v\) is \(_{uv}\), then, \(F\) has total amplitude \(3_{uv}\). We now iterate this process, updating \(F\) successively. At each step, we know that after all removals made so far, \(S\) does not have points in \(F\). Thus, points of \(S\) that fall into \(F\) under \(_{u}\) or under \(_{v}\) can be restored uniquely. After deleting them, we repeat the same operation with \(F_{u}F_{v}F\) in place of \(F\).

```
1\(S:=\);
2for\(\{z\} L_{u} L_{v}\)do//Restoringpointsfromthelines\((0,u)\)and\((0,v)\)
3 Put\(z\) into \(S\);
4 Remove \(\{z\}\) from \(L_{u} L_{v}\);
5 endfor
6\(F:=(u,v)\);
7while\(F^{2}\)do
8for\(\{z_{1},z_{2}\} L_{u} L_{v}\)do//Restoringpointsthathaveonecandidatelocationintheforbiddenarea
9if\(z_{1} F\)or\(z_{2} F\)then
10 Set\(y=z_{1}\) if\(z_{2} F\) and \(y=z_{2}\) if\(z_{1} F\);
11 Put\(y\) into \(S\);
12 Remove\(\{y,_{u}y\}\) from \(L_{u}\) and \(\{y,_{v}y\}\) from \(L_{v}\);
13 endfor
14 //Updatingforbiddenarea
15\(F=F_{u}F_{v}F\);
16 endwhile
17 Output\(S\);
```

**Algorithm 1**Reconstruction algorithm

After \(k\) such "updates", \(F\) will consist of \(2k+1\) adjacent angles, each of size \(_{uv}\), with \((u,v)\) being in the center. In each update, we replace \(F\) with \(F_{u}F_{v}F\). This results in adding two angles of size \(_{uv}\) to both sides of \(F\). Indeed, if we look at the ray \((0,u)\), it splits our current \(F\) into two angles, one of size \((k+1)_{uv}\) and the other of size \(k_{uv}\). Under \(_{u}\), the part whose size \(_{uv}\) from the opposite side of \(F\). See Figure 1 for the illustration of this process.

Within at most \(1+}\) such steps, \(F\) covers all angular directions, thus completing the reconstruction of \(S\).

_Initialization step._ We explain how to obtain the Initialization Data about \(S\) from \(_{1}^{(3)}(S)\).

We start by observing that from the first iteration of 1-WL, we can compute \(\|x\|\) for all \(x S\). As the following lemma shows, this holds in any dimension, with the same proof. We temporarily omit the current hypothesis \(b=0\), in order to use the lemma later without this hypothesis.

**Lemma 3.1** (The Barycenter Lemma).: _Take any \(n\)-point cloud \(S^{d}\) and let_

\[D_{x}=\{\!\!\{d(x,y) y S\}\!\!\}.\]

_Then for every \(x S\), knowing \(D_{x}\) and the multiset \(\{\!\!\{D_{y} y S\}\!\!\}\), one can determine the distance from \(x\) to the barycenter of \(S\)._

Proof.: Consider the function \(f^{d}[0,+)\) defined as \(f(x)=_{y S}\|x-y\|^{2}\), namely \(f(x)\) is the sum of the squares of all elements of \(D_{x}\) (with multiplicities). It follows that \(_{y S}f(y)\) is determined by \(\{\!\!\{D_{y} y S\}\!\!\}\). The lemma is thus proved if we prove the following equality

\[\|x-b\|^{2}=(f(x)-_{y S}f(y)). \]

To prove the above, we first write:

\[f(x)= _{y S}\|x-y\|^{2}=_{y S}\|(x-b)+(b-y)\|^{2}\] \[=_{y S}(\|x-b\|^{2}+2 x-b,b-y+\|b-y\|^{ 2})\] \[=n\|x-b\|^{2}+2 x-b,n b-_{y S}y+ _{y S}\|b-y\|^{2}\] \[=n\|x-b\|^{2}+_{y S}\|b-y\|^{2}\]

Figure 1: Growth of the “forbidden” area.

Denote \(=_{y S}\|b-y\|^{2}\). Substituting the expression for \(f(x)\) and \(f(y)\) from above into the right-hand side of (2), we get:

\[(f(x)-_{y S}f(y)) =(n\|x-b\|^{2}+-_{y S }n\|y-b\|^{2}+)\] \[=(n\|x-b\|^{2}+-(n+n ))=\|x-b\|^{2},\]

as required. 

By definition, \(^{(1)}_{1,S}(x)\) determines the multiset \(D_{x}=\{\!\!\{d(x,y) y S\}\!\!\}\) of distances from \(x\) to points of \(S\). Since we are given the multiset \(^{(3)}_{1}(S)\), we also know the multiset \(^{(1)}_{1}(S)=\{\!\!\{^{(1)}_{1,S}(x) x S\}\!\!\}\) (labels after the third iterations determine labels from previous iterations). In particular, this gives us the multiset \(\{\!\!\{d_{x} x S\}\!\!\}\). Overall, due to the Barycenter lemma, we conclude that \(^{(1)}_{1,S}(x)\) can be converted into \(\|x\|\).

Now, remember that

\[^{(2)}_{1,S}(x)=^{(1)}_{1,S}(x),\{\!\!\{(d(x,y),^{(1)}_{1,S} (y)) y S\}\!\!\}.\]

By converting \(^{(1)}_{1,S}(y)\) into \(\|y\|\) for all \(y S\) here, one can convert \(^{(2)}_{1,S}(x)\) into the multiset

\[M_{x}=\{\!\!\{(d(x,y),\|y\|) y S\}\!\!\}.\]

We need one more iteration to find \(d(u,v),M_{u},M_{v}\) for some \(u,v S\) satisfying the cone condition. In fact, we only need

\[^{(3)}_{1,S}(u)=^{(2)}_{1,S}(u),\{\!\!\{d(u,y),^{(2) }_{1,S}(y)\!:y S\}\!\!\}\]

for arbitrary \(u S\) with \(u 0\). Since \(^{(3)}_{1,S}(u)\) determines \(\|u\|\), such \(^{(3)}_{1,S}(u)\) can indeed be selected from \(^{(3)}_{1}(S)\) (and since we assume that \(S\) has more than one point, we know that there are points in \(S\) that are different from \(0\)).

Due to the fact that \(^{(2)}_{1,S}(y)\) can be converted to \(M_{y}\), we can in turn convert \(^{(3)}_{1,S}(u)\) into the multiset \(=\{\!\!\{\!\{d((u,y),M_{y})\!:y S\}\!\!\}\!\}\). In particular, since \(y=u\) is the only point for which \(d(u,y)=0\), we can compute \(M_{u}\) from \(\). Once we have \(M_{u}\), the rest of the initialization goes as follows. First note that for a given element \((d(u,y),M_{y})\) in \(\) with \(d(u,y)>0\) (so that \(y u\)), we can look in \(M_{y}\) for the only element with \(0\) as the first entry, whose second entry is then \(\|y\|\). So we can obtain \((d(u,y),\|y\|)\). As in the Reconstruction Algorithm, we then have only two possibilities for the location of \(y\) relative to \(u\), say \(y_{1}\) and \(y_{2}=_{u}(y_{1})\). It follows that the absolute value of the angle \(_{uy}\) between \(u\) and \(y\) is uniquely determined (if \(\|y\|=0\), we set \(_{uy}=0\)), and we can compute it from \(\). In order to select \(v\), we go though \(\) and look for \(v\) such that \(_{uv}\) is the smallest angle among \(\{_{uy} y S,0<_{uy}<\}\). If such a \(v\) does not exist, all points of \(S\) must lie on the line connecting \(0\) and \(u\). In this case, the cone condition is satisfied, for example, for \(u\) and \(v=u\). Thus, we can initialize with \(d_{0}=0,M=M^{}=M_{u}\). If \(v\) as above exists, there can be no point in the interior of \((u,v)\), since otherwise there would be \(y\) with \(0<_{uy}<_{uv}<\), contradicting the minimality of \(_{uv}\). Thus, the cone condition is satisfied for \(u,v\). We can then set \(d_{0}=d(u,v)\), \(M=M_{u}\) and \(M^{}=M_{v}\).

## 4 Proof of Main Theorem for \(d>2\)

We now present the proof for the case \(d>2\). The strategy of the proof has the same structure as for \(d=2\). Since the objects involved now are more general, it will be convenient to introduce some terminology. Let \(=(x_{1},,x_{k})(^{d})^{k}\) be a \(k\)-tuple of points in \(^{d}\). The _distance matrix_ of \(\) is the \(k k\) matrix \(A\) given by \(A_{ij}=d(x_{i},x_{j}),i,j=1,,k\).

Now, let \(S^{d}\) be a finite set. Then the _distance profile_ of \(\) w.r.t. \(S\) is the multiset

\[D_{}=\{\!\!\{\,(d(x_{1},y),,d(x_{k},y)) y S\}\!\!\}.\]

As before, we let \(b=_{y S}y\) denote the barycenter of \(S\). For a finite set \(G^{d}\), we denote by \((G)\) the linear space spanned by \(G\), and by \((G)\) the corresponding affine one. Their respective dimensions will be denoted by \((G)\) and \((G)\).

As for the case \(d=2\), we start by distilling the Initialization Data required for the reconstruction, which is described relative to the barycenter \(b\) of \(S\). For convenience, we have decided not to assume at this stage that \(S\) has been translated first to put \(b\) at the origin, as we did for the sake of the exposition in the case \(d=2\). This is now the task of the isometry we apply to \(S\) when choosing locations for its points, which we now completely relegate to the reconstruction phase.

**Definition 1**.: Let \(S^{d}\) be a finite set and let \(b\) be its barycenter. A \(d\)-tuple \(=(x_{1},,x_{d}) S^{d}\) satisfies the _cone condition_ if

* \((b,x_{1},,x_{d})=(S)\);
* if \((S)=d\), then there is no \(x S\) such that \(x-b\) belongs to the interior of \((x_{1}-b,,x_{d}-b)\).

**Definition 2**.: For a tuple \(=(x_{1},,x_{d}) S^{d}\), we define its _enhanced profile_ as

\[EP(x_{1},,x_{d})=(A,M_{1},,M_{d}),\]

where \(A\) is the distance matrix of the tuple \((b,x_{1},,x_{d})\) and \(M_{i}=D_{[b/i]}\) is the distance profile of the tuple \((x_{1},,x_{i-1},b,x_{i+1},,x_{d})\) with respect to \(S\).

**Definition 3**.: Let \(S^{d}\) be a finite set and let \(b\) be its barycenter. An _initialization data_ for \(S\) is a tuple \((A,M_{1},,M_{d})\) such that \((A,M_{1},,M_{d})=EP(x_{1},,x_{d})\) for some \(d\)-tuple \(=(x_{1},,x_{d}) S^{d}\) satisfying the cone condition.

_Remark 4.1_.: The interested reader can verify that the Initialization Data condition extends the definition for \(d=2\). Note that the first bullet of the Cone Condition is automatically verified for \(d=2\), but is nontrivial for \(d>2\).

The fact that an initialization data \((A,M_{1},,M_{d})\) can be recovered from \(_{d-1}(S)\) is ensured by the following proposition.

**Proposition 4.2** (Initialization Lemma).: _Take any \(S^{d}\). Then, knowing the multiset \(\{\!\!\{\,^{(3)}_{d-1,S}() S^{d-1}\}\!\!\}\), one can determine an initialization data for \(S\)._

We now proceed with the reconstruction phase.

### Reconstruction Algorithm

Assume an Initialization Data \((A,M_{1},,M_{d})\) for a finite \(S^{d}\) is given. Our first task is to choose, up to isometry, positions for the points in the \((d+1)\)-tuple \((b,x_{1},,x_{d})\) corresponding to the matrix \(A\). We use the following classical lemma, whose proof is given e.g. in [4, Sec. 2.2.1].

**Lemma 4.3** (Anchor Lemma).: _If \((u_{1},,u_{k})^{d}\) and \((v_{1},,v_{k})^{d}\) have the same distance matrix, then there exists an isometry \(f^{d}^{d}\) such that \(f(u_{i})=v_{i}\) for all \(i=1,,k\)._

As for \(d=2\), we put the barycenter of the cloud at the origin. Then, we simply apply the Anchor Lemma to any collection of points \(z_{1},,z_{d}^{d}\) such that our given \(A\) is also the distance matrix of the tuple \((0,z_{1},,z_{d})\). The Lemma then gives us an isometry \(f^{d}^{d}\) such that \(f(b)=0,f(x_{1})=z_{1},,f(x_{d})=z_{d}\). As distance profiles are invariant under isometries, our given \(M_{i}\) is also the distance profile of the tuple \((z_{1},,z_{i-1},0,z_{i+1},,z_{d})\) w.r.t. \(f(S)\). Our task now is, from \(M_{1},,M_{d}\), to uniquely determine the locations of all points in \(f(S)\). This would give us \(S\) up to an isometry. Since now we have locations for \((z_{1},,z_{d})\), we can in fact compute:

\[(S)=(b,x_{1},,x_{d})=(0,z_{1},,z_{d})=(z_{1},,z_{d}),\]

where the first equality is guaranteed by the cone condition. The reconstruction algorithm depends on whether \((S)=d\) or not.

Consider first the case when \((S)=(z_{1},,z_{d})<d\). Then there exists \(i\{1,,d\}\) such that \((z_{1},,z_{d})=(z_{1},,z_{i-1},z _{i+1},,z_{d})\). This means that \(f(S)(z_{1},,z_{i-1},0,z_{i+1},,z_{d})\), since otherwise \(f(S)\) would have larger affine dimension. We claim that, in this case, from \(M_{i}\) we can restore the location of all points in \(f(S)\). Indeed, from \(M_{i}\) we know, for each \(z f(S)\), a tuple with the distances from \(z\) to \(z_{1},,z_{i-1},0,z_{i+1},,z_{d}\). As the next lemma shows, this information is enough to uniquely determine the location of \(z\).

**Lemma 4.4**.: _Take any \(x_{1},,x_{m}^{d}\). Assume that \(a,b(x_{1},,x_{m})\) are such that \(d(a,x_{i})=d(b,x_{i})\) for all \(i=1,,m\). Then \(a=b\)._

It remains to reconstruct \(f(S)\) when \((S)=d\), in which case our pivot points \(z_{1},,z_{d}\) are linearly independent. Recall that \(M_{i}\) is the distance profile of the tuple \((z_{1},,z_{i-1},0,z_{i+1},,z_{d})\) w.r.t. \(f(S)\). Moreover, since no \(x\) in \(S\) is such that \(x-b\) lies in the interior of \((x_{1}-b,,x_{d}-b)\), we know that \(f(S)\) must be disjoint from the interior of \((z_{1},,z_{d})\). As the next proposition shows, this information is enough to reconstruct \(f(S)\) in this case as well, which finishes the proof of Theorem 2.1 for \(d>2\).

**Proposition 4.5** (The Reconstruction Lemma).: _Assume that \(z_{1},,z_{d}^{d}\) are linearly independent. Let \(T^{d}\) be finite and disjoint from the interior of \((z_{1},,z_{d})\). If, for every \(i=1,,d\), we are given \(z_{i}\) and also the distance profile of the tuple \((z_{1},,z_{i-1},0,z_{i+1},,z_{d})\) w.r.t. \(T\), then we can uniquely determine \(T\)._

## 5 On the distinguishing power of one iteration of \(d\)-WL

In this section, we discuss a somewhat different strategy to reconstruct \(S\). It is clear that if for a point \(z^{d}\) we are given the distances from it to \(d+1\) points in general position with known coordinates, then the position of \(z\) is uniquely determined (see e.g. Lemma 4.4). Since \(d\)-WL colors \(d\)-tuples of points in \(S\), a natural strategy to recover \(S\) is to use the barycenter as an additional point. By Lemma 3.1, we know that distances to the barycenter from points of \(S\) can be obtained after one iteration of \(d\)-WL. However, the information that allows us to match \(d(z,b)\) to the distances from this \(z\) to a \(d\)-tuple, is readily available only after two iterations of \(d\)-WL. It follows that this simple strategy can be used to directly reconstruct \(S\) from the second iteration of \(d\)-WL. We remark that this strategy is similar to the one used in  to uniquely determine \(S\) up to isometries when the coloring we are initially given corresponds to certain Gram Matrices for \(d\)-tuples of points. Essentially, after one interaction of \(d\)-WL over this initial data, we obtain enough information to directly determine the location of each \(z\) relative to a collection of \(d+1\) points. In fact, it is not hard to show that from the first iteration of \(d\)-WL, applied to the distance graph of \(S\), one can compute these Gram Matrices, thus providing an alternative proof that two iterations suffice for distinguishing geometric graphs.

We show instead that only one iteration suffices. Our approach differs and depends on certain geometric principles that allow us to simplify the problem by conducting an exhaustive search across an exponentially large range of possibilities.

**Theorem 5.1**.: _For any \(d 1\) and for any finite set \(S^{d}\), knowing the multiset \(\{\!\{^{(1)}_{d,S}()| S^{d}\}\!\}\), one can determine \(S\) up to an isometry._

## 6 Final remarks

Open problems.An interesting open question about our work is what is the minimum number of rounds needed for the \((d-1)\)-WL test to be complete with respect to point clouds in \(^{d}\). Our result shows that three rounds suffice, but we do not know the completeness status of the test when only one or two rounds are allowed. Another open problem is the completeness status of the \((d-2)\)-WL test for \(d\)-dimensional point clouds when \(d>3\).

Limitations.A consequence of our main result and is that distance-based \(d\)-MPGNNs possess sufficient expressive capability to learn \(d\)-dimensional point clouds up to isometry. However, the computational complexity of implementing \(d\)-MPGNNs is a major concern, as it involves \(O(n^{d})\) operations per iteration, where \(n\) denotes the number of nodes in the graph. This computational cost can quickly become unmanageable, even for relatively small values of \(d\), such as \(d=3\). It remains to be studied which kind of optimizations on higher-order GNNs can be implemented for improved performance without much sacrifice on their expressive power.

Acknowledgements

Barcelo and Kozachinskiy are funded by ANID-Millennium Science Initiative Program - ICN17002. All authors are funded by the National Center for Artificial Intelligence CENIA FB210017, Basal ANID. Delle Rose is funded by ANID Fondecyt Postdoctorado 3230263. Petrache is funded by ANID Fondecyt Regular 1210462.