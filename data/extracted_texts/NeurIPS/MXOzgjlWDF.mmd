# Structured Unrestricted-Rank Matrices for

Parameter Efficient Fine-tuning

 Arijit Sehanobish\({}^{1}\)1 &Avinava Dubey\({}^{2}\)1 &Krzysztof Choromanski\({}^{3,4}\)1

**Somnath Basu Roy Chowdhury\({}^{5}\)1 &Deepali Jain\({}^{3}\) &Vikas Sindhwani\({}^{3}\) &Snigdha Chaturvedi\({}^{5}\)**

\({}^{1}\)Independent \({}^{2}\) Google Research \({}^{3}\)Google DeepMind

\({}^{4}\)Columbia University \({}^{5}\)UNC Chapel Hill

Equal Contribution

###### Abstract

Recent efforts to scale Transformer models have been successful across a wide range of tasks . However, fine-tuning these models for downstream tasks can be expensive, as it requires updating a large number of parameters in the Transformer model. Parameter-efficient fine-tuning (PEFT) approaches have emerged as a viable alternative that allow us to fine-tune models by updating only a small number of parameters. In this work, we propose a general framework for parameter efficient fine-tuning using _structured unrestricted-rank matrices_ (SURM), which can serve as a drop-in replacement for popular approaches such as Adapters and LoRA. Unlike other methods like LoRA, SURMs provides more flexibility in finding the right balance between compactness and expressiveness. This is achieved by using _low displacement rank matrices_ (LDRMs), which has not been used in this context before. SURMs remain competitive with baselines, often providing significant quality improvements while using a smaller parameter budget. SURMs achieve **5**-**7**% accuracy gains on various image classification tasks while replacing low-rank matrices in LoRA. It also results in up to **12x** reduction of the number of parameters in adapters (with virtually no loss in quality) on the GLUE benchmark.

## 1 Introduction

In recent years, large-scale Transformer models have demonstrated impressive performance across a wide range of domains, including natural language processing (NLP) , vision , robotics , and even multi-modal settings . For many applications, a single large pre-trained model is _adapted_ for several downstream problems. _Fine-tuning_, where all the model parameters are updated, is a popular way to adapt a pre-trained model to a new task or domain. However, fine-tuning large models on specific downstream tasks requires significant computational resources and involves a massive memory footprint, as each task necessitates storing its own set of parameters.

Parameter-efficient fine-tuning (PEFT) methods have emerged as the preferred methodology to adapt pre-trained Transformers to different downstream tasks. PEFT methods often achieve performance on par with full fine-tuning while training only a small number of parameters . PEFT techniques involve either training a small subset of the model's parameters  or integrating small modular layers while freezing the base model's weights . There are two popular classes of methods to inject additional parameters: **(a)** using small modular layers inside Transformers called _adapter_ layers , and **(b)** constraining the updates as _low-rank matrices_ (**LoRA**) .

Although adapters and LoRA (including their variants) differ architecturally and conceptually, they share a common reliance on low-rank matrices. The success of these methods has been attributed to the low intrinsic dimensionality of the hidden representations in the pre-trained Transformermodels [1; 70]. These low-rank methods primarily aim to approximate updates, which, in general, are not low rank. Hence, there's no justification for imposing low-rank constraints on them. Motivated by this insight, we explore alternative classes of matrices--ones that aren't necessarily low rank but are characterized by a linear number of parameters while exhibiting impressive approximations across various matrix classes. We present Fig. 1 as a preview of the motivating results. In Fig. 1 (left), we show that structured matrices (SURM) can approximate any random matrix better than low rank matrices. In Fig. 1 (right), we show that when SURMs are used for parameter efficient fine-tuning it outperforms existing PEFT methods (see more details in Sec. 4).

We propose a novel paradigm of parameter efficient fine-tuning that leverages _Structured Unrestricted-Rank_ matrices (or SURMs). SURMs provide similar efficiency gains as previous works in efficient fine-tuning, but their more expressive structure paves the way for quality improvements. In this work, we propose to perform parameter-efficient fine-tuning by parameterizing learnable weights as structured matrices. We focus on the two sub-classes of SURMs: **(1)** Kronecker product of matrices  and **(2)** low displacement rank matrices (LDRMs) [66; 6; 58; 54; 73]. To summarize, our primary contributions are:

* We propose the class of Structured Unrestricted-Rank matrices (SURMs) (Section 3), for parameter efficient fine-tuning of Transformers. SURMs include low-rank matrices used in LoRA, as special cases. To the best of our knowledge, we are the first to apply LDRMs in this context.
* We demonstrate strong matrix approximation capabilities inherent in Low Displacement Rank Matrices, with a specific focus on circulant and Toeplitz matrices (Section 4).
* We introduce a new class of adapter-layers using SURMs, achieving a **12x** reduction in parameters compared to adapters, with virtually no loss in quality on the GLUE benchmark (Section 6).
* We achieve 5-7% accuracy gains over LoRA on a wide variety of image datasets as well as in low resource setting (VTAB-1k benchmark). In some cases SURMs outperform full fine-tuning, while using only **55k** training parameters (as shown in Fig. 1 (right)).

## 2 Related Work

With the introduction of BERT  and GPT-2 , Transformer models trained on general text corpora have revolutionized the field of machine learning (ML). Since then, these models have continued to increase in size, with open-source variants adopting various architectures. Examples include encoder-decoder models such as T5  with up to 20B parameters , and a range of auto-regressive decoder models like Llama , Pythia , Mistral , among others, varying in size from a few million to 180B parameters . These models can be easily adapted to downstream tasks by fine-tuning on task-specific data, resulting in state-of-the-art performance across a broad

Figure 1: **Left:** Approximating a PSD matrix using a low rank matrix, Kronecker product of matrices, circulant matrix, and Toeplitz matrix. We repeat our experiment **10** times and for each trial, we observe that low rank matrix is the worst approximator followed by Kronecker product, circulant, and Toeplitz. **Right:** The tradeoff between accuracy and parameter numbers of various PEFT methods. Results are measured across 5 image datasets using CLIP-ViT. Our methods appear in the top right corner (in blue) and achieve the best performance among various strong baseline methods.

spectrum of downstream tasks. Due to the computational infeasibility of fine-tuning all the parameters of these models, in-context learning  and prompt engineering [11; 22] have emerged as attractive alternatives to adapt models to downstream tasks. However, such adaptation results depend heavily on the design of the input prompt and tend to vary greatly with small perturbations of the prompts .

Consequently, many works have proposed various PEFT techniques. One of the earliest methods involves inserting the so-called _adapter_ layers between existing layers in a neural network [25; 59]. An adapter is typically an MLP with input, output, and a smaller middle layer, encoded by two low-rank matrices, making it compact in terms of parameters. An extension of the adapter is Compactor , which uses Tucker decomposition to parameterize the adapter layers and weight-sharing to reduce the number of trainable parameters. Various modifications and extensions of the above methods have been proposed [53; 24; 32; 52; 65]. Another popular PEFT technique is differentiable prompt-tuning (DPT), which can be thought of as optimizing special tokens in the prompt . However, these methods are limited by the sequence length of the underlying models. Even though DPT was originally developed for NLP, several works have extended it for computer vision tasks as well [83; 12; 27; 24].

One of the most popular PEFT methods is Low-Rank Adaptation (LoRA) , which imposes a low-rank constraint on the weight updates. The main difference between adapters and LoRA is that the learned LoRA weights can be merged with the frozen model weights during inference without adding any latency. Given the popularity of LoRA, there have been many works on extending it to different contexts like long-range modeling , multi-tasking  or improving its efficiency [19; 71; 46; 37; 31] among many others.

In general, low-rank matrices are studied extensively in various ML applications [57; 87; 44; 61]. The research on low displacement rank matrices (LDRMs) for ML is more narrow [89; 68; 41; 66; 15; 35; 62]. Although Kronecker matrices (a class of LDRMs) have been explored in the context of LDRMs [21; 24; 51], the constituent matrices in the Kronecker product have low rank even in these work. In this work, we use a fixed parameter budget but do not impose any rank-based condition. To the best of our knowledge, we are the first to systematically explore the effectiveness of different structured matrices and introduce LDRMs for parameter-efficient fine-tuning.

The rest of the paper is organized as follows: **(a)** We introduce the notion of Structured Unrestricted-Rank Matrices (SURM) that are used in this work (Section 3), **(b)** We motivate the usage of SURM by empirically showing the approximation qualities of these matrices (Section 4), **(c)** We use SURM as drop-in replacement for popular approaches such as Adapters and LoRA (Section 5), **(d)** We validate our approach across a wide range of vision and NLP tasks (Section 6).

## 3 Structured Unrestricted-Rank Matrices (SURM)

In this section, we will define the matrices that are used for parameter efficient fine-tuning. First, we define the concept of a _structured matrix_, which is a generic term for a matrix \(^{m n}\) that can be represented by fewer than \(mn\) parameters. These matrices are useful because they reduce both space and time complexity when performing matrix multiplications.

A simple example of a structured matrix is a low rank matrix of the form \(=^{}^{m n}\), where \(^{m r}\), \(^{n r}\) with \(r(m,n)\). In this work, our main focus is on those classes of structured matrices that are not restricted to be low-rank, which we refer to as _Structured Unrestricted-Rank Matrices_ (SURM). Next, we present two classes of SURM matrices that we use for parameter efficient fine-tuning.

**Low Displacement Rank Matrices**. Our first class of SURMs is low displacement rank matrices (LDRMs). A matrix \(^{m n}\) is said to have \((,)\)-displacement structure if:

\[_{,}() }}{{=}}-=,\] (1)

where \(^{m m},^{n n}, ^{m n}\) and \(\) has low rank \(r\) (as compared to \((m,n)\)). We call \(_{,}\) the _displacement rank operator_, parameterized by \(\) and \(\).

For a given \(\), there can exist several pairs of \((,)\) matrices satisfying Eq. 1 that produce a low-rank matrix, \(\). Some examples of such \((,)\) pairs include: \((,),(,^{}),(_{x}, ^{}),(_{x},_{y})\) (for \(x y\)). Here \(\) is a circulant-shift matrix and \(_{z}\) is a diagonal matrix with nonzero entries equal to \(z\). Low displacement rank matrices (\(\) in Eq. 1) enable fast (sub-quadratic) matrix-vector multiplication and enhance the efficiency of other matrix operations, such as inversion. By selectingmore complex \((,)\) pairs, such as those involving _general Jordan form matrices_, it is possible to consider more unstructured \(\) that still have compact representations and support efficient matrix operations [56; 66]. In this paper, we focus on classic low displacement rank matrices: circulant and toeplitz matrices, which are described below.

1. **Circulant Matrices**: A circulant matrix \(^{m n}\) can be parameterized by its first row. The following rows are obtained from the previous one by applying a right circulant shift. A schematic visualization of a circulant matrix is shown in Fig 2**(a)**. Since we only need to store the first row, circulant matrices can be trivially encoded in \(O(n)\) space. They also support fast matrix-vector multiplication in \(O((n+m)(n+m))\) time using Fast Fourier Transform (FFT) .
2. **Toeplitz Matrices**: A toeplitz matrix \(^{m n}\) is a matrix whose entries are constant along each diagonal. A schematic visualization of a toeplitz matrix is shown in Fig 2**(b)**). They can be parameterized using only their first row and column, allowing them to be encoded in \(O(n+m)\) space. Similar to circulant matrices, they support fast \(O((n+m)(n+m))\) matrix-vector multiplication via FFT.

**Kronecker Product of Matrices**. Kronecker products are another class of structured unrestricted rank matrices that have low storage complexity and admit efficient matrix-vector multiplication. These matrices are obtained using a Kronecker product \(\) of two matrices \(\) and \(\), as shown in Fig 2**(c)**. We provide more details about these matrices in Appendix A.3.

## 4 Ldr-SURMs as General Approximators

In this section, we motivate the usage of structured unrestricted-rank matrices (SURMs) for parameter-efficient fine-tuning. In general, the parameter updates \(\) can be arbitrary matrices, and an effective parameterization of \(\) should be sufficiently expressive to approximate them. Since we use structured update rank matrices (SURMs) to parameterize \(\), we demonstrate that SURMs can approximate various classes of matrices. Without loss of generality, in this section, we assume that all our matrices have real entries and that weight matrices are square (\(n=m\)).

First, we recall the result from , which states that a broad class of low displacement rank matrices, as well as linear combinations of Toeplitz (or their inverses) products2, can be parameterized as:

\[(,)=_{i=1}^{r}_{1}(_{i })_{-1}(_{i}),\] (2)

where \(=[_{1},...,_{r}],=[_{1},..., _{r}]^{n r}\), and \(_{f}()\) (for any \(f\), \(v^{n}\)) is defined as:

\[_{f}()=v_{0}&fv_{n-1}&&f_{1 }\\ _{1}&v_{0}&&f_{2}\\ &&&fv_{n-1}\\ _{n-1}&&_{1}&v_{0}.\] (3)

When \(f=1\), \(_{f}(v)\) is a circulant matrix and when \(f=-1\), we refer to \(_{f}(v)\) as a skew-circulant matrix. Moreover, \(\) can be decomposed as follows: \(=^{}\) for \(=[_{1},...,_{r}],=[_{1},...,_{r}]^{n r}\). One can think about rank \(r\) of \(\) of controlling how "structured" \(\) is.

Figure 2: A schematic diagram to illustrate the structure (a) Circulant, (b) Toeplitz, and (c) Kronecker product of two matrices \(\) and \(\).

From the above result, we see that \((,)\) is the most expressive parameterization among the ones discussed so far. To understand how they fare with SURMs in practice, we evaluate their approximation qualities in two settings: **(a)** comparing \((,)\) with circulant and Toeplitz matrices, and **(b)** comparing circulant and Toeplitz matrices with low-rank matrices.

### Comparing \((,)\) with Circulant and Toeplitz Matrices

We test the approximation capabilities of matrices \((,)\) (Eq. 2) and compare it with popular classes of SURMs: circulant and Toeplitz matrices (Section 3). Specifically, we use these structured matrices to approximate three broad classes of matrices: **(a)** random, **(b)** near-low-rank, and **(c)** near-low-intrinsic-rank. We denote the ground-truth matrix that we try to approximate as \(^{100 100}\) and parameterized structured matrix as \(\) (see more details about the setup in Appendix A.7). For all matrices, we obtain the parameters of \(\) using gradient descent on the loss function: \(\|-\|_{}^{2}\). 3

In Figure 5, we report the relative Frobenius norm error during training for different settings. In Fig 5 (top left), we use \((,)\) with different \(r\) (rank of \(\) in Eq. 1) is used to approximate random matrices. While the best approximations are achieved for larger values of \(r\) (specifically, \(r=20\)), it is interesting to note that the final error does not decrease monotonically with increasing \(r\). For the remaining class of matrices \(\), which are close to low-rank and therefore easier to approximate, we experiment with smaller values of \(r\) and report the results in Figure 5 (left column, middle and bottom). In this case, we observe that the three top-performing approximators \((,)\) were trained with \(r=1,2,4\). These results indicate that for more structured ground truth matrices (even if they are not necessarily low-rank), LDRMs with a very low rank for the corresponding \(\) are sufficient.

Motivated by the results showing that LDRMs with low \(r\) can serve as effective approximators, we use circulant and Toeplitz matrices to approximate near-to-low-rank and low-intrinsic-rank matrices. In the three plots shown in Fig. 5 (right column), we observe that approximations using Toeplitz matrices (using twice as many parameters as circulant matrices) offer negligible gains and are only beneficial in the near-low-rank case. For the low-intrinsic case, circulant matrices outperform Toeplitz ones. Overall, circulant matrices with few parameters achieve strong performance in this setting.

### Comparing Low Rank with Circulant and Toeplitz Matrices

In this section, we focus on the difference in approximation qualities between low rank matrices and the circulant and Toeplitz matrices under a _fixed_ parameter budget. We use the following settings:

Figure 4: Fitting the pinwheel dataset with a frozen embedding layer using various SURM-based PEFT methods and LoRA.

Figure 3: A circulant matrix with the first column given by a vector \((c_{0},c_{1},c_{2},c_{3},c_{4})\) can be re-written as a linear combination of the orthogonal base circulant matrices (5 matrices with orange-entries corresponding to one and other to zero). Such a closed-form decomposition is in general not possible for matrices \((,)\) and thus optimal approximators are found by gradient-descent.

**Approximating Symmetric Positive Definite Matrices**. We use a PSD matrix \(^{50 50}\) with \(L^{2}\)-normalized rows in this experiment. We compare the errors to approximate \(\) using circulant, (symmetric) Toeplitz, low-rank matrices, and Kronecker product of two matrices. We use a fixed parameter budget and repeat this experiment \(10\) times. We report the results in Figure 1 (left). For _each_ of these \(10\) trials, we observe that the circulant and Toeplitz achieve the lowest error, therefore the best approximation quality (see more details in Appendix A.7).

**Fitting a Toy Dataset**. We create a synthetic pinwheel dataset with 5 spokes as shown in Figure 9 (left). We fit this dataset using a simple neural network with one hidden layer with a matrix \(^{64 64}\). In this experiment, we replace \(\) with a rank \(1\) LoRA, a circulant, a symmetric Toeplitz, and a Toeplitz matrix ( with all parameterizations having the same number of training parameters). In Fig 4), we report the training loss curves of this experiment. We observe that the LoRA layer struggles to fit the data whereas the LDRMs show similar performance to full fine-tuning (Fig 4). These results show the impressive expressive power of these matrices. Therefore, we conclude that LDRMs with particularly low displacement rank serve as good approximators for various matrices. We perform additional experiments and provide more details in Appendix B.

Figure 5: Illustration of the approximation capabilities of different LDRMs. The \(y\)-axis depicts the relative Frobenius norm error \(\|-\|_{}/\|\|_{}\) between the groundtruth \(\) and the approximator \(\). (_Left Column Top_): We approximate a random Gaussian matrix \(\) with matrices \((,)\) using different \(r\) (LDR: \(r\)). (_Left Column Middle_) We approximate near-low-rank matrices \(\) using smaller values of \(r\). (_Left Column Bottom_): Similar setup to approximate near-low-intrinsic-rank matrices \(\). (_Right Column_): We perform analogous studies with circulant and Toeplitz matrices, where the ground truth has low rank or low-intrinsic rank.

## 5 Integration of SURMs with PEFT

Motivated by the results from the previous section, we use SURMs as drop-in replacements for various PEFT methods. In this section, we present the integration of SURMs in two popular classes of PEFT methods: LoRA and Adapters.

### Integration of SURMs in LoRA

LoRA  uses a low rank matrix to parameterize the weight matrix updates. Formally, given a pre-trained weight matrix \(\), then the updated matrix is \(}=+\), where \(=^{}\) and \(^{m r},^{n r}\) for \(r(m,n)\) and \(\) is a fixed scaling parameter. For efficient training, \(\) needs to be initialized as a zero-matrix. LoRA performs this by choosing initializing \(\) to be the zero matrix and \(\) to be a random matrix. In this work, we propose to parameterize \(\) using structured unrestricted rank matrices. Next, we provide the details of parameterizing \(\) using different SURM matrices (assuming \(m=n\) for simplicity).

**Circulant Matrices**. In this setting, we parameterize the updates as: \(=_{1}_{2}\), where \(_{i}^{n n}\) are circulant matrices encoded using a \(n\)-dimensional vector, \(_{i}^{n}\). We use Hadamard products (\(_{1}_{2}\)) instead of conventional matrix products as it can be computed efficiently. The construction of Hadamard products which is O(\(n\)) is quicker than the process involved in efficient multiplication (which is O(\(n\)log\((n)\)). To enable zero-initialization, we initialize \(_{1}\) as a zero-vector and \(_{2}\) as a random-vector. Additionally, this approach does not compromise the expressiveness of the network, as the result of the Hadamard product is also a circulant matrix.

**Toeplitz Matrices**. Similar to the previous setting, we use two Toeplitz matrices to parameterize: \(=g(_{},g(_{},))\), where \(_{},_{}\) are Toeplitz matrices, and \(g\) is the operator that allows efficient matrix-vector multiplication with Toeplitz matrices (see Appendix A.3 ). Each Toeplitz matrix \(^{n n}\) is parameterized using an \(n\)-dimensional vector \(\) encoding its first row and an \(n\)-dimensional vector \(\) encoding its first column (\(2n-1\) total parameters). This formulation leads to the \(4n-2\) trainable parameters. To further reduce this number, we constrain the \(_{},_{}\) to be symmetric, reducing the total number of trainable parameters to \(2n\). To enable zero-initialization, we initialize \(_{1}\) as a zero matrix and \(_{2}\) is randomly initialized.

**Kronecker Product of Matrices**. In this setting, we parameterize: \(=\), where \(^{r_{1} r_{2}},^{}}}\). The hyperparameters \(r_{1},r_{2}\) allow us to control the trainable parameter count and the rank of \(\). In contrast to low-rank matrix updates, we can create matrices \(\) of fairly large ranks while keeping the number of trainable parameters small (see Appendix A.2). To enable zero-initialization, we set \(\) as a zero matrix and \(\) as a random matrix.

    &  &  &  \\  & \(( 10^{6})\) & &  &  &  &  &  &  &  &  &  &  \\  Fine-tuning & \(86.6\) & \(99.0\) & \(92.4\) & \(75.0\) & \(72.4\) & \(99.6\) & \(97.7\) & \(85.4\) & \(73.8\) & \(79.0\) & \(99.7\) \\  Attn. Tuning & 28.4 & 93.9 & 85.7 & 73.8 & 69.2 & 99.2 & 96.8 & 81.8 & 73.1 & 75.0 & 97.6 \\ Trans. Probing & 3.2 & 86.9 & 86.9 & 76.7 & 72.0 & 99.0 & 95.6 & 80.1 & 74.3 & 75.9 & 98.5 \\ Linear Probing & **0.049** & 96.3 & 87.7 & 70.1 & 72.7 & 98.7 & 94.8 & 80.1 & 72.4 & 75.4 & 98.4 \\ BitFit & 0.358 & 92.3 & 81.0 & 71.8 & 72.6 & 99.0 & 92.1 & 76.0 & 70.8 & 75.9 & 98.8 \\ Adapter & 1.505 & 98.4 & 90.6 & 74.2 & 71.0 & 99.3 & 94.7 & 81.4 & 77.1 & 78.0 & 99.0 \\ AdapterDrop & 0.174 & 96.8 & 88.4 & 72.3 & 70.2 & 99.6 & 93.3 & 78.3 & 71.4 & 77.1 & 98.0 \\ LoRA & 0.219 & **98.7** & 90.6 & 73.6 & 70.4 & 99.4 & 95.1 & 78.1 & 80.8 & 78.1 & 99.2 \\ LoRA-Fix & 0.148 & 96.2 & 88.3 & 72.0 & 65.5 & 99.0 & 92.5 & 77.1 & 60.0 & 77.7 & 88.6 \\ LN Tuning & 0.075 & 92.2 & 71.7 & 72.0 & 69.0 & 98.8 & 82.5 & 76.6 & 66.7 & 72.4 & 99.1 \\ LePE & 0.167 & 93.7 & 90.8 & 73.2 & 69.8 & 99.1 & 95.1 & 78.9 & 68.0 & 75.4 & 98.0 \\ RPB & 0.145 & 96.7 & 87.0 & 72.4 & 70.4 & 98.9 & 94.7 & 77.1 & 68.4 & 75.2 & 97.9 \\ KAdaptation & 0.114 & 97.9 & **91.2** & 75.1 & 71.4 & 99.4 & 95.9 & 84.8 & 74.0 & 78.1 & 99.2 \\  SURM _(Kronecker)_ & 0.055 & 98.3 & 89.9 & 78.6 & 75.4 & 99.6 & **97.1** & **85.0** & 80.7 & **79.0** & 99.2 \\ SURM _(Toeplitz)_ & 0.055 & 98.5 & 90.2 & 79.1 & 75.6 & 99.7 & 97.1 & 84.5 & 80.9 & 77.9 & 99.0 \\ SURM _(Circulant)_ & 0.055 & 98.0 & 90.7 & **80.5** & **75.7** & **99.8** & 97.0 & 84.6 & **81.1** & 78.6 & **99.3** \\   

Table 1: ViT-experiments : Baseline numbers are taken from . The best numbers are highlighted in **bold** and the second-best numbers are underlined. Hyperparameter settings are followed from . We find that SURM consistently outperform very strong baselines with **2-3x** reduction in parameters.

In all the above settings, it is possible to increase the number of training parameters by relaxing the structure of the matrix, \(\). This can be performed by introducing more matrices in the product chains, utilizing asymmetric Toeplitz matrices, adjusting the sizes of factors in the Kronecker product, or employing sums of such matrices. Another way to enhance layer expressiveness is by experimenting with combinations of different LDRMs, such as mixing circulant and skew-circulant matrices. A broad class of matrices, including low-rank ones, can be represented as sums of these matrices (see Theorem A.2 and the subsequent discussion).

### Integration of SURMs in Adapters

Adapters  are small bottleneck networks into Transformer layers as shown below:

\[=+(),\] (4)

where \(()\) is a non-linear activation function, \(^{b s n}\) represents input to the layer (\(b\): batch size, \(s\): sequence length), \(^{r n},^{n r}\) are low-rank matrices (\(r n\)) and \(\) is the output of the layer. For simplicity, layer norms and bias terms are not included in the equation. We use SURMs as a drop-in replacement for matrices \(\) and \(\). Next, we will provide details of integrating SURMs within the adapter setting. Additional details are provided in Appendix A.5.

**Circulant Matrices**. In this setting, we apply two circulant matrices \(_{1},_{2}\) (encoded by \(_{1},_{2}\)), resulting in the adapter block: \(=+(f(_{1}_{2},) )+\), where \(f\) is an operator that efficiently computes the matrix multiplication between input \(\) and the circulant matrix encoded by the vector \(_{1}_{2}\) (Appendix A.3). To enable zero-initialization, the vector \(_{1}\) is initialized randomly while \(_{2}\) and \(\) are initialized as zero vectors.

**Toeplitz Matrices**. In this setting, we use two symmetric Toeplitz matrices \(_{1},_{2}\), where \(_{1}\) and \(\) is initialized as a zero vector and \(_{2}\) is initialized randomly. We then define the adapter layer as: \(=+(g(_{1},g(_{2},)))+ \), where \(g\) is an operator that efficiently computes the matrix multiplication between an input \(\) and a Toeplitz matrix.

    &  &  &  &  &  &  \\  & \(( 10^{6})\) & CIFAR-100 & **Cal**-101 & **DTD** & F-102 & **Pets** & **SVHN** & **Sun397** & **Cam.** & **EuroSAT** & **Res**-45 & **Retino** \\  Fine-tuning & \(86.6\) & \(68.9\) & \(87.7\) & \(64.3\) & \(97.2\) & \(86.9\) & \(87.4\) & \(38.8\) & \(79.7\) & \(95.7\) & \(84.2\) & \(73.9\) \\  Linear & **0.049** & 64.4 & 85.0 & 63.2 & 97.0 & 86.3 & 36.6 & 51.0 & 78.5 & 87.5 & 68.5 & 74.0 \\ BiFit & 0.013 & 72.8 & 87.0 & 59.2 & 97.5 & 85.3 & 59.9 & 51.4 & 78.7 & 91.6 & 72.9 & 69.8 \\ VPT-Shallow & 0.063 & 77.7 & 86.9 & 62.6 & 97.5 & 87.3 & 74.5 & 51.2 & 78.2 & 92.0 & 75.6 & 72.9 \\ VPT-Deep & 0.531 & 78.8 & 90.8 & 65.8 & 98.0 & 88.3 & 78.1 & 49.6 & 81.8 & 96.1 & 83.4 & 68.4 \\ Adapter & 0.157 & 69.2 & 90.1 & 68.0 & 98.8 & 89.8 & 82.8 & 54.3 & 84.0 & 94.9 & 81.9 & 75.5 \\ AdaptFormer & 0.157 & 70.8 & 91.2 & 70.5 & 99.1 & 90.9 & 86.6 & 54.8 & 83.0 & 95.8 & 84.4 & **76.3** \\ LoRA & 0.295 & 67.1 & 91.4 & 69.4 & 98.8 & 90.4 & 85.3 & 54.0 & 84.9 & 95.3 & 84.4 & 73.6 \\ NOAH & 0.361 & 69.6 & **92.7** & 70.2 & 99.1 & 90.4 & 86.1 & 53.7 & 84.4 & 95.4 & 83.9 & 75.8 \\ Fact-TK\({}_{ 32}\) & 0.069 & 70.6 & 90.6 & 70.8 & 99.1 & 90.7 & 88.6 & 54.1 & 84.8 & **96.2** & 84.5 & 75.7 \\ SSF & 0.240 & 69.0 & 92.6 & **75.1** & 99.4 & 91.8 & 90.2 & 52.9 & **87.4** & 95.9 & **87.4** & 75.5 \\ RepAdapter & 0.110 & 70.7 & 91.6 & 72.5 & 99.1 & 91.3 & 88.5 & 54.2 & 84.1 & 95.7 & 85.1 & 74.6 \\  SURM (_Kronecker_) & 0.055 & 79.6 & 88.7 & 73.1 & 99.1 & 92.5 & 74.8 & 54.7 & 82.2 & 94.3 & 81.9 & 75.4 \\ SURM (_Toeplitz_) & 0.055 & 79.5 & 88.9 & 72.7 & 99.1 & 91.5 & 74.7 & 55.8 & 83.6 & **96.2** & 82.2 & 76.0 \\ SURM (_Circulant_) & 0.055 & **80.6** & 87.5 & 74.7 & **99.5** & **93.3** & 74.9 & **57.1** & 85.3 & 96.0 & 83.7 & 75.4 \\   

Table 2: Results on the VTAB-1k benchmark. Baseline numbers are taken from  and . Best numbers are highlighted in **bold** and the second-best numbers are underlined. We observe that SURM is one of the top-performing PEFT methods on almost all datasets.

Figure 6: **Low Resource Training**. Accuracy of SURM CLIP-ViT models as a function of the training data fraction. The results show that SURM can achieve comparable accuracy with as low as \( 2\%\) of the training data for easier tasks like CIFAR10 and \( 20\%\) for harder tasks like SUN397.

**Kronecker Product of Matrices**. In this case, we rewrite Equation 4 as: \(=+(())+\), where \(\) is the Kronecker product. In this case, \(\) is initialized randomly and \(\) and \(\) are initialized by zeros. In all experiments using SURM-adapters, \(()\) is the GeLU non-linearity.

## 6 Experiments

In this section, we show the effectiveness of our proposed methods in a wide range of vision and NLP tasks through extensive empirical studies.

**Image Classification Experiments**. We evaluate SURM on several vision datasets: CIFAR10, CIFAR100 , SUN397 , DTD  and STL10 . We experiment using ViT-B/16  & Clip-ViT-B/16  as base models and inject trainable parameters \(,,\) matrices in the LoRA setting. We report the results using ViT\({}_{}\) are presented in Table 1 (left). We observe that SURM consistently outperforms **12** baseline methods (that use up to **10x** parameters). On three out of the five tasks, SURMs emerge as the top performers, surpassing LoRA by a margin of up to **5**-**7\(\%\)** while achieving competitive performance on the remaining tasks. We report the results using Clip-ViT in Table 1 (right). In this setting, SURM is among the top two methods across all 5 tasks. SURM also uses fewer trainable parameters, reducing them by **3.65x** compared to LoRA and **2.4x** compared to LoRA-Fix.

_Low Data Regime_. We evaluate SURM in low data regime using VTAB-1k datasets  and the ViT model. VTAB-1k is a diverse collection of vision datasets with only \(1000\) training examples. We focus on the Natural and Specialized subsets of VTAB. In Table 2, we observe that SURMs are among the top 2 methods on **10** datasets while being competitive on the remaining tasks.

We evaluate different variants of SURM and train it on a varying fraction of data on 5 datasets using Clip-ViT model. We report the results in Figure 6. We observe that the circulant SURM works best in low data regime. Furthermore, SURM achieves the performance of full fine-tuning trained on the entire dataset with only a small fraction of the data. For more challenging datasets like Sun397, we achieve comparable accuracy using approximately 20% of the training data, while for datasets such as CIFAR10 and STL10, only about 2% is needed.

_Large Data Regime_. We perform experiments to show that SURM generalizes well in large data regimes. On ImageNet  and iNat2021 , SURM achieves performance comparable to full fine-tuning while using only \(\) of the training parameters (see detailed results in Appendix B.2).

**NLP Experiments**. We extensively evaluate SURM models on the GLUE benchmark  using BERT\({}_{}\). We compare with different adapter baselines and 11 other PEFT techniques. These include full-finetuning, _Adapter (Houlby)_ and _Adapter (Pfeiffer)_, among others (we report the corresponding results from ). BiTFit results are taken from  (except QQP numbers which are obtained from ) and the numbers for \(AA\)-adapters from . Prefix, Serial, AdaMix, UniPELT,

Figure 7: **Left: Tradeoff between performance and parameter count for various PEFT methods. We report the average results across 5 image datasets using ViT-B (complete results in Table 1). Right: Average performance across GLUE benchmark (see complete results in Table 5). SURMs appear in the top right corner and perform best among various strong baseline methods in both settings.**Parallel, MAM, and AutoPEFT numbers are taken from . The results for the remaining baselines are replicated by us. More experimental details can be found in Appendix B.

For brevity, we summarize the average performance across 8 tasks for SURM-adapters and compare it to 11 baselines, in Fig 7 (right). We observe that SURM achieve much better performance while using a fraction of the parameters (the complete results are reported in Appendix Table 5). We also observe that SURM (integrated into LoRA) outperforms the baseline LoRA, under the same parameter budget. This shows the effectiveness of using structured matrices as a drop-in replacement for low rank matrices used in LoRA. We further analyze the representations learnt by SURMs and LoRAs (Appendix B.4). We find that LoRA learns weights that are very similar to the pre-trained weights whereas SURM is able to explore a larger parameter space (an observation similar to ).

**Large-scale Experiments**. In this setting, we integrate SURMs in LLMs. Specifically, we use matrices of the form \((,)\) (as described in Eqn 2) to increase the number of training parameters. We use the experimental setup introduced in , where the LLM tries to fit a dataset of UUID pairs using the Llama-2-7B model . This was shown to be a challenging task (UUID prediction is significantly different from the pre-training tasks) that requires higher rank values in LoRA. We report the results in Fig. 8, demonstrating that SURMs is able to fit the data, whereas other methods struggle to do so (see more details in Appendix B.1).

**Image Segmentation**. Next, we focus on the extremely challenging task of medical image segmentation using Synapse multi-organ segmentation dataset . Segment-Anything-Model (SAM)  is used as the foundation model for this task. We follow  and adapt the \(,\) in ViTbase image encoder in SAM. Finally, in this low data regime, we use Circulant variant of SURM as it is the best performing variant (Fig. 6). We report the Dice similarity coefficient (DSC) metric for each of the \(8\) organ segmentations and their average (higher is better). For a fair comparison, we include LoRA with rank \(\), matching the _exact_ parameter count of Circulant. The results are presented in Table 3. We report the baseline performance from . SURMs compare favorably with specialized architectures developed for medical imaging like U-Net, Attention U-Net, Transformer-based U-Net, and the Swin U-Net even though they have significantly higher number of training parameters than our method (see details in Appendix B.1).

## 7 Conclusion

We introduce structured unrestricted-rank matrices (SURMs) as an alternative to low-rank matrices for the parameter-efficient fine-tuning of large Transformer models. In this setting, structured matrices form the cornerstone of a comprehensive framework, offering a solid base for various parameter efficient fine-tuning methods, such as adapters and LoRA, with enhanced efficiency. SURMs improve the overall effectiveness of PEFT, contributing to its efficient integration into diverse models and domains. Based on extensive numerical experiments and theoretical insights, we conclude that the Circulant variant is our most performing variant (in terms of speed and accuracy).

  
**Methods** & DSC & Aorta & Gallblad. & Kid. (L) & Kid. (R) & Liver & Pancreas & Spleen & Stomach \\  U-Net & 76.85 & 89.07 & **69.72** & 77.77 & 68.60 & 93.43 & 53.98 & 86.67 & 75.58 \\ Att-UNet & 77.77 & **89.55** & 68.88 & 77.98 & 71.11 & 93.57 & 58.04 & 87.30 & 75.75 \\ TransUnet & 77.48 & 87.23 & 63.13 & 81.87 & 77.02 & 94.08 & 55.86 & 85.08 & 75.62 \\ SwinUnet & 79.13 & 85.47 & 66.53 & **83.28** & 79.61 & 94.29 & 56.58 & **90.66** & 76.60 \\ SAMed & **81.88** & 87.77 & 69.11 & 80.45 & 79.95 & **94.80** & **72.17** & 88.72 & **82.06** \\  LORA (rank=1) & 78.26 & 81.86 & 64.54 & 81.97 & **81.18** & 93.79 & 60.80 & 88.33 & 73.64 \\ SURM (_Circulant_) & 80.11 & 83.04 & 64.92 & 81.37 & 80.96 & 94.21 & 69.11 & 88.15 & 79.06 \\   

Table 3: Image Segmentation results on the Synapse multi-organ segmentation dataset. SURMs achieve comparable performance with specialized architectures developed for medical imaging while being more parameter efficient.

Figure 8: Fitting the UUID dataset using Llama-2-7b. We fit the data using various SURM-based PEFT methods and LoRA.

## 8 Author Contributions

AS designed the integration of SURM in Adapters and LoRA and ran the GLUE experiments. AD helped in developing the integration and ran all image experiments. KC came up with the idea of using LDRMs in the context of PEFT. SBRC helped in running various large-scale experiments and writing the manuscript. All authors contributed to the writing of this manuscript.