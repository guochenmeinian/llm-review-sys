# Fine-Tuning Personalization in Federated Learning

to Mitigate Adversarial Clients

 Youssef Allouah

EPFL

Lausanne, Switzerland

&Abdellah El Mrini

EPFL

Lausanne, Switzerland

&Rachid Guerraoui

EPFL

Lausanne, Switzerland

&Nirupam Gupta

University of Copenhagen

Copenhagen, Denmark

&Rafael Pinot

Sorbonne Universite and Universite Paris Cite,

CNRS, F-75005 Paris, France

Authors are listed in alphabetical order.Correspondence to : Abdellah El Mrini <abdellah.elmrini@epfl.ch>.

###### Abstract

Federated learning (FL) is an appealing paradigm that allows a group of machines (a.k.a. clients) to learn collectively while keeping their data local. However, due to the heterogeneity between the clients' data distributions, the model obtained through the use of FL algorithms may perform poorly on some client's data. Personalization addresses this issue by enabling each client to have a different model tailored to their own data while simultaneously benefiting from the other clients' data. We consider an FL setting where some clients can be adversarial, and we derive conditions under which full collaboration fails. Specifically, we analyze the generalization performance of an interpolated personalized FL framework in the presence of adversarial clients, and we precisely characterize situations when full collaboration performs strictly worse than _fine-tuned_ personalization. Our analysis determines how much we should scale down the level of collaboration, according to data heterogeneity and the tolerable fraction of adversarial clients. We support our findings with empirical results on mean estimation and binary classification problems, considering synthetic and benchmark image classification datasets.

## 1 Introduction

Federated learning (FL) is the de facto standard for a group of machines (also referred to as _clients_) to learn a common model on their collective data (Kairouz et al., 2021). The benefit of this method is twofold: the clients (1) retain control over their local data (as they do not communicate them to a central server) and (2) share the computational workload during the learning procedure. Although FL is a promising learning paradigm, it also comes with its own technical challenges, the first of which is data heterogeneity. Indeed, each client holds only a portion of the common dataset, which is not necessarily a faithful representation of the entire population. This could lead to disagreements amongst clients on model updates, rendering the task of learning an accurate model in this context cumbersome. Nevertheless, when all machines correctly follow a prescribed algorithm, this problem can be solved using either a distributed implementation of the stochastic gradient descent (SGD) algorithm or variants of the federated averaging scheme (McMahan et al., 2017; Khaled et al., 2020; Karimireddy et al., 2020). Another negative impact of data heterogeneity is the non-uniformity of model accuracy. Specifically, while an FL algorithm outputs a model that is accurate on average, the accuracy of this model on different clients' local data could vary significantly.

**Personalization.** Personalized FL attempts to address the aforementioned shortcoming on non-uniform model accuracy by having clients collaborate to design individual models that generalize well over their local data distributions (Vanhaesebrouck et al., 2017; Sattler et al., 2020; Fallah et al., 2020; Hanzely et al., 2020). This approach is highly relevant to many modern machine learning applications, as it tailors the training of each model to the needs of the respective client. To get a more precise view of this approach, consider a general supervised learning task with \(\) denoting the input space and \(\) the output space. Personalized FL involves \(n\) clients which can communicate, through a central trusted machine (a.k.a. the _server_). The clients hold local datasets \(S_{1},,S_{n}\), comprising \(m\) data points, drawn i.i.d. from their respective local data distributions \(_{1},,_{n}\) with support in \(:=\). Given a parameter set \(^{d}\), we consider hypothesis functions of the form \(h_{}^{}\), parameterized by \(\), and we denote by \(\) the corresponding hypothesis class. We allow \(^{}\) to encompass cases in which the model outputs logits/probits instead of classes. The objective of each client \(i\) is to find a model \(_{i}^{*}\) minimizing its local risk function

\[_{i}()_{(x,y)_{i}}[ (h_{}(x),y)],,\] (1)

where \(^{}_{+}\) is a non-negative point-wise loss function measuring how well a hypothesis \(h_{}\) fits the output \(y\) on an input \(x\). The mapping \((,x,y)(h_{}(x),y)\) is assumed to be differentiable, with respect to \(\). To minimize the local risk above, each client \(i\) only has access to its local dataset \(S_{i}\) yielding a local empirical loss \(_{i}()_{(x,y) S_{i}}(h_{ }(x),y)\), and to the information sent by other clients on their respective datasets. This optimization problem can be solved in several ways, and we have at out disposal a rich literature on personalized FL schemes (Mansour et al., 2020; Fallah et al., 2020; Marfoq et al., 2021). We focus on a specific personalization scheme wherein each client aims to solve for the \(\)_-interpolated empirical loss_ minimization problem:

\[_{_{i}}_{i}^{}(_{i})(1- )_{i}(_{i})+(_{i}),\] (2)

where \(()_{i=1}^{n}_{i}(), \ \), and \(\). When \(=1\), the problem reduces to the standard FL objective and corresponds to a full collaboration amongst the clients. The case of \(=0\) represents the absence of collaboration, i.e., each client minimizes its local empirical loss. We use the terminology _fine-tuned_ personalization to refer to the objective of solving for (2) when \((0,1)\) is determined by optimizing the learning performance in retrospect.

**Robustness.** Standard personalized FL approaches usually assume that all clients correctly follow a prescribed protocol, and hence do not consider the possibility of _adversarial_ clients. Robustness to such clients, a.k.a "Byzantine robustness", refers to the design of FL schemes that yield accurate models even when some clients arbitrarily deviate from the algorithm and can send potentially corrupted information to other clients: This could result from poisonous data or code, or attacks from malicious players. Although Byzantine robustness has received significant attention in the FL community (Guerraoui et al., 2024), it remains largely understudied in the context of personalized FL. In fact, prior work has shown that the presence of adversarial clients induces a fundamental optimization error that grows with the heterogeneity across clients' local data (Karimireddy et al., 2022; Allouah et al., 2024). This optimization error is at odds with the improvement in generalization, which is offered by collaborating with other correct clients, to a point where collaboration is rendered vacuous. The main motivation for our work is to quantify the impact of adversarial clients on the relevance of collaboration for any correct client.

### Problem Setting

Given the set of \(n\) clients, we aim to tolerate the presence of at most \(f<n/2\) adversarial clients. Such clients can respond arbitrarily to the queries made by the server, e.g., a gradient computation on their local dataset. We also call these clients Byzantine adversaries. The identity of Byzantine adversaries is a priori unknown to the correct (i.e., non-adversarial) clients, otherwise, the problem is rendered trivial. As we explain above, when no client is adversarial, the objective of each client \(i\) is to minimize its own risk, defined in (1), by solving for the interpolated empirical loss minimization problem (2). However, in the presence of adversarial clients, a correct client cannot simply seek a solution to (2), as they can never have truthful access to the information about Byzantine adversaries' datasets. A more reasonable goal is to minimize an interpolation between their local and the _correct_ clients' average loss functions. We formally define the _robust-interpolated_ objective for client \(i\) as follows:

\[_{_{i}}_{i}^{}(_{i})(1- )_{i}(_{i})+_{}(_{i}),\] (3)where \(\) represents the set of correct clients, \(_{}() }_{i}_{i}(),\;\), and \(\) is called the _collaboration level_. Similar to (2), \(=0\) and \(=1\), respectively, reduce to local learning which can be solved with local SGD (Stich, 2018), and Byzantine-robust FL which can be tackled using a robust variant of distributed gradient descent (Allouah et al., 2023). Recall that \(\) is a priori unknown to the correct clients, hence they can neither have access to \(_{}\) nor to its gradients. A correct client can only approximate any information on \(_{}\), where the approximation error grows with both \(f/n\) and data heterogeneity, shown in (Karimireddy et al., 2022; Allouah et al., 2024).

### Contributions

We establish optimization and generalization guarantees on the interpolated personalized objective (3) in the presence of adversarial clients, and show how the degree of collaboration \(\), asymptotically navigates the trade-off between the fundamental optimization error due to adversarial clients and the improved generalization performance thanks to the collaboration with correct ones.

This sheds light on specific situations in which full collaboration performs strictly worse than _fine-tuned_ personalization, and even sometimes worse than local learning. Precisely, we extend an important result from domain adaptation (Ben-David et al., 2010), showing that data from a distinct distribution cannot be beneficial for the local learning task when the heterogeneity is above a certain threshold, which depends on the local sample size and the hypothesis class complexity. In the context of Byzantine robust distributed learning, we show that even if data heterogeneity is low enough, the level of collaboration should be rescaled by a parameter that both depends on the fraction of adversaries and the gradient dissimilarity between correct clients. Essentially, while the effect of collaboration could be captured by substraction between the local task complexity and the heterogeneity of local distributions in a Byzantine-free context, we show that it is further captured by a multiplicative factor in the presence of adversaries. The higher the dissimilarity between correct gradients (and the number of adversarial clients in the system), the smaller \(\) should be taken.

Our results show that for personalized FL, in most realistic contexts where heterogeneity between clients is not negligible, full collaboration is not optimal in the presence of adversarial clients. Moreover, the presence of these adversarial clients considerably limits the level of collaboration that could be useful for the correct clients, to the point where it is often more efficient to learn locally if the local task is sufficiently simple.

### Paper Outline

The remainder of the paper is organized as follows. Section 2presents the mean estimation setting as a warm-up and special case of the framework presented in Section 1.1. The goal is to give an intuition on settings in which personalization can or cannot help reduce the estimation error in the presence of adversarial clients. Section 3 presents our analysis in the general binary classification setting, where we quantify the tension between the optimization error and the generalization gap in the presence of Byzantine adversaries. We also empirically validate our theory on the MNIST dataset. We defer full proofs to Appendix C and our full experimental setup to Appendix D. We also include further information on related work in Appendix A.

## 2 Warm-up: Mean Estimation with Adversaries

Before diving into the details of our results in a general supervised learning setting, let us first focus on the simple task of Byzantine-robust federated mean estimation in which the concepts of heterogeneity and task complexity are easier to grasp. We consider \(n-f\) correct clients denoted \(\). Each client \(i\) has access to \(m\) data point \(y_{i}^{(1)},...,y_{i}^{(m)}\) sampled i.i.d. from their a local distribution \(_{i}\) and independently from the other correct clients. We assume that each local distribution \(_{i}\) has a support in \(^{d}\), an unknown finite mean \(_{i}\). Furthermore, we assume that all the distributions have the same finite variance \(^{2}_{y_{i}}( y-_{ i}^{2})\). In this context, the objective of each client \(i\) is to find their true mean \(_{i}\). To do so, we assume that each client attempts solve a problem of the form

\[_{y_{i}^{}^{d}}_{k[m]}  y_{i}^{}-y_{i}^{(k)}^{2}+_{k[m]}_{j} y_{i}^{}-y_{j}^{(k)} ^{2}.\] (4)In fact, the optimal solution to this problem is \(y_{i}^{*}:=(1-)}+}}\) where \(}:=_{j=1}^{m}y_{i}^{(j)}\) and \(}}:=_{i}}\). Recall that due to the presence of Byzantine adversaries, correctness cannot compute \(}}\) directly, but should instead use a robust aggregation rule \(F\) to estimate \(}}\). Specifically, we consider the natural robust estimator of \(}^{*}\)3, where \(}}\) is replaced by a robust approximation

\[y_{i}^{}=(1-)}+ F(},, }).\] (5)

To formalize how good a robust aggregation rule is, we use the notion of \((f,)\)-robustness (Allouah et al., 2023), which we state below.

**Definition 1** (\((f,)\)-robustness).: Let \(f<}{{2}}\) and \( 0\). An aggregation rule \(F\) is said to be \((f,)\)_-robust_ if for any vectors \(v_{1},,v_{n}^{d}\), and any set \([n]\) of size \(n-f\),

\[\|F(v_{1},,v_{n})-_{}\|^{2}_{i}\|v_{i}-_{} \|^{2},_{}_{i }v_{i}.\]

### On the Effect of Collaboration

We evaluate the performance of the estimator \(}\) by the mean squared error defined as \([\|y_{i}^{}-_{i}\|^{2}],\)where the expectation is taken over the random samples \(y_{i}^{(1)},...,y_{i}^{(m)}\) drawn i.i.d. from \(_{i}\) and independently for every \(i\). Then the following holds.

**Proposition 1**.: _Consider the mean estimation setting described. For any \(i\), let \(y_{i}^{}\) be as defined in (5) with an aggregation rule \(F\) that satisfies \((f,)\)-robustness. Then the following holds true:_

\[[\|y_{i}^{}-_{i}\|^{2}] 3(1- )(,)}{m}+3^{2}( \|_{i}-_{}\|^{2}+^{2}).\]

_with \(_{}:=_{i}_{i}\), \(^{2}:=_{j}\|_{j}-_ {}\|^{2},\)and \((,):=^{2}(+1)-2+.\)_

**Tightness of the bound.** While the right-hand side of Proposition 1 may not be tight in general, we note that it is tight for \(=0\) and \(=1\), in the homogeneous setting (\(=0\)), provided that we use robust averaging with \((f/n)\). Indeed, when \(=0\) the squared error in estimating the mean of a distribution with variance \(^{2}\) from \(m\) i.i.d. samples is in \((^{2}/m)\), refer (Wu, 2017). Furthermore, when \(=1\), the squared error in estimating the mean of a distribution with variance \(^{2}\) is in \((}{m})\), refer (Zhu et al., 2023).

**Interpretation.** Note that, in the above, the terms that represent the hardness of the local mean estimation task and the heterogeneity among correct clients are \(}{m}\), and \(\|_{i}-_{}\|^{2}+^{2}\) respectively. Indeed \(^{2}\) is the variance of each distribution, hence the local mean estimation task is essentially as hard as \(^{2}\) is large with respect to the number of points \(m\) each client has access to. Similarly, \(^{2}\) essentially computes how far apart the true means of the correct clients are on average, and \(\|_{i}-_{}\|^{2}\) penalizes especially the distance to the average of the correct clients for the one we observe (i.e., \(i\)). By minimizing the right-hand side of Proposition 1, we get

\[^{*}=)}{m}}{(+1) (1-)}{m}+\|_{i}-_{ }\|^{2}+^{2}},\] (6)

which approaches \(0\) as \(\|_{i}-_{}\|^{2}+^{2}\) grows and \(1/(1+)\) when \(\|_{i}-_{}\|^{2}+^{2}}}{{m}}\). Note that \(\) can be as small as \((}{{n}})\), hence the above means that, when heterogeneity is limited and with a small enough fraction of adversarial clients, high level of collaborations can be used by each correct client. On the other hand, correct clients need not gain much by collaborating with other clients in highly heterogeneous regimes.

### Experimental Validation

To validate our theoretical observations on Byzantine-robust federated mean estimation, we run a series of experiments using simulated datasets sampled from 1-dimensional Gaussian distributions.

Specifically, for each of the \(n-f\) correct clients, we consider that their distribution is such that \(_{i}=(_{i},^{2})\), where the unknown local means \((_{i})_{i}\) have been sampled i.i.d. from a Gaussian distribution \((10,_{h}^{2})\)4, where \(_{h}\) determines the expected squared distance between the local means of each correct client. Each honest client \(i\) samples \(m\) datapoints from \(_{i}\) and the error is computed with respect to \(_{i}\). To evaluate the theoretical expression of \(^{*}\), defined in (6), in this scenario, we replace the distances of the form \((_{i}-_{})^{2}\) by the variance \((1-}{{n-f}})_{h}^{2}\). We present in Figure 1 the average error (squared distance to the true mean) of the estimator defined as per (5) on \(20\) runs, for different values of \(\). The robust aggregation being used here is an NNM pre-aggregation rule (Allouah et al., 2023) followed by trimmed mean (Yin et al., 2018) and adversarial clients implement the sign-flipping attack. Below we analyze our result presented in the first row of Figure 1.

Heterogeneity.First, we study the impact of the heterogeneity level in Figure 1. Doing so, we fix \(n=600,f=100,m=20,=15\) and vary the level of heterogeneity \(_{h}\{0,1,2,3,4\}\). We observe that for low levels of heterogeneity, the optimal choice for \(\) is close to \(1\). In this case, personalization does not really help.

Byzantine fraction.Second, we analyze the impact of the fraction of Byzantine adversaries. For Figure 1, we fix \(n=600,m=20,=15,_{h}=2\) and vary \(f\{0,50,100,150\}\). As per our theoretical analysis, as the Byzantine fraction increases \(\) should increase; hence the correct clients need to rely less and less on the global aggregate. However, simply using a local estimator can be detrimental as showcased by the red curve, which shows the case \(f=150\). Then, by choosing the right collaboration, one reduces the error by \(50\%\) compared to the local estimator.

Task complexity.Finally, we study the impact of the task complexity, characterized by the quantity \(^{2}/m\). We fix \(n=600,f=100,m=20,_{h}=2\) and vary \(\{1,7,13,19,25,31\}\). We observe, as expected, that the optimal level of collaboration level of collaboration moves away from \(0\) as the task gets harder. However, we also observe that, since the fraction of Byzantine clients is non-negligible, the optimal choice of collaboration \(\), even for very large values of \(\), never goes to \(1\).

Correspondence between the upper-bound and empirical observations.The second line of Figure 1 shows a comparison between the optimal theoretical value predicted by our analysis and

Figure 1: Impact of the heterogeneity (\(_{h}\)), number of Byzantine adversaries \(f\) and the task complexity (\(\)). (Top) The average error for different values of \(\), computed using \(20\) random experiments. (Bottom) Comparison of theoretical \(^{*}\) and empirical minimizer of the error. We fixed the following default values: \(n=600,f=100,m=20,=15,_{h}=2\)

the empirical minimizer of the error on average.5 We see that the value we predicted for \(^{*}\) and the actual empirical best choice for \(\) has very similar trends in all the settings we consider.

## 3 Binary Classification with Adversaries

In this section, we consider the more general problem of binary classification. We study the learning-theoretic setup given in Section 1 with binary output space \(:=\{0,1\}\) and \(^{}=\). Throughout, we place ourselves in a hypothesis space \(\) of finite pseudo-dimension (Vidyasagar, 2003; Mohri et al., 2018), denoted \(()\), which we recall reduces to the VC dimension for the \(0-1\) loss. We further make the following assumptions on the loss functions. These assumptions are standard in the Byzantine robustness literature see, e.g., (Karimireddy et al., 2022; Allouah et al., 2023).

**Assumption 1** (\(L\)-smoothness, \(\)-strong convexity).: Each loss function \(_{i},i\), is \(L\)-smooth and \(\)-strongly convex. That is, for all \(,^{}\), we have

\[\|-^{}\|^{2}_{i}()- _{i}(^{})-_{i}(^{} ),\,-^{}\|-^{}\|^{2}.\]

**Assumption 2** (Bounded heterogeneity).: There exists a real value \(G\) such that for all \(\), we have

\[|}_{i}\|_{i}()- _{}()\|^{2} G^{2}.\]

We additionally make the following assumption on the parameter set \(\) to ensure that the Euclidean projection on \(\) (denoted \(_{}\)) is well-defined, unique and that the minimizer of the interpolated loss is not pathological, i.e., is not in the border of \(\).

**Assumption 3**.: The parameter set \(\) is compact and convex. Moreover, for every \(i,\), the minimizer of \(_{i}^{}\) is in the interior of \(\).

Additionally, for our generalization analysis, we make the following assumption on the loss function:

**Assumption 4**.: The loss function is bounded in \(\).

To conduct an analysis of the effect of collaboration on the generalization performance of correct clients when trying to solve (1), we proceed in two steps. We first evaluate the optimization error that a standard gradient descent algorithm incurs in our setting. Then we bound the generalization gap induced when minimizing (1) and combine the two bounds into our main result in Theorem 1.

### Algorithm & Optimization Error

We focus our analysis on a simple personalized variant of the robust distributed gradient descent algorithm, which is the standard algorithm in the Byzantine-robust FL literature and is shown to achieve tight optimization bounds (Allouah et al., 2023). Our variant, presented in Algorithm 1, essentially corresponds to gradient descent on the function \(_{i}^{}\), but using a robust estimate \(R_{i}^{t}\) (iteration 7) of the gradient of \(_{}\), which cannot be computed exactly due to Byzantine adversaries. This robust estimate is computed using a robust aggregation \(F\), e.g., trimmed mean or median.

**On the execution of the algorithm.** Executing Algorithm 1 in practice implies that each client acts as a local server, and runs an independent federated learning procedure. We further assume that the clients have access to a communication protocol that allows them to broadcast their model to the other clients. This can either be done through the use of the central server or directly through a decentralized communication (i.e., without a server). This algorithm is not communication efficient and we believe that it could be improved in that direction. Nevertheless, it allows us to discuss the information-theoretic aspects of the problem in a simple manner. We first present the optimization error of Algorithm 1 in Lemma 1 below.

**Lemma 1**.: _Let assumptions 1, 2, and 3 hold. Consider Algorithm 1 with learning rate \(=\), \(\), and assume the aggregation function \(F\) to be \((f,)\)-robust. For any \(T 1\), we have:_

\[_{i}^{}(_{i}^{T})-_{i,*}^{}  G^{2}}{^{2}}+(1-)^{T} _{0},\]

_where \(_{0}:=_{i}^{}(_{i}^{0})-_{i,*}^ {}\) and \(_{i,*}^{}:=_{}_{i}^{}()\)._Our optimization error bound recovers the classical GD linear rate when \(=0\) (local learning), and achieves an asymptotic error in \(( G^{2})\) when \(=1\) (full collaboration), which is provably tight under Assumption 2 (Karimireddy et al., 2022). Interestingly, for \((0,1)\), the asymptotic error smoothly interpolates in \((^{2} G^{2})\), which is expected as lesser collaboration limits the influence of the adversary on the optimization error.

### Generalization Gap & Effect of Collaboration

Although the presence of adversarial clients impairs the optimization process, one expects a generalization benefit from collaboration if data distributions are similar enough. We formalize this intuition by bounding the generalization gap, of the personalized learning problem (2). We first bound the generalization gap on the interpolated loss \(_{i}^{}\) using a result adapted from (Blitzer et al., 2007).

**Lemma 2**.: _Let Assumption 4 hold. For any \(>0\), \(\) and \(\), we have with probability at least \(1-\) (over the choice of samples) that_

\[|_{i}^{}()-_{i}^{}()| 2 )^{2}}{m}+ }{m(n-f)})},\]

_where \(_{i}^{}()[_{i}^{ }()],\), and \(()(()})}+\)._

When specializing the result of Lemma 2 to \(=0\) and \(=1\), we recover the standard generalization gaps \(()/m}\) and \(()/m(n-f)}\) for local learning and federated learning (with correct clients only), respectively. However, in addition to the generalization gap bounded in Lemma 2, we need to bound the gap between the interpolated risk (3) and the original local risk (1). In fact, these two objectives are statistically different when there is data heterogeneity among clients since the interpolated risk (3) involves the average of local loss functions. To quantify this difference, we leverage tools from domain adaptation theory (Ben-David et al., 2010) and consider a function \(\) measuring the discrepancy between two statistical distributions. Formally, we require for every \(i\),

\[|_{i}()-_{}()|(_{i},_{}),.\] (7)

For example, for the case of 0-1 loss in binary classification, for any two distributions \(_{1}\) and \(_{2}\), (Blitzer et al., 2007) propose the discrepancy measure to be \((_{1},_{2})=d_{}( _{1},_{2}) 2_{h}|_{_{1}}(I(h))- _{_{2}}(I(h))|\), where \(I(h)\{x:h(x)=1\}\). For more general losses, we can use hypothesis space-dependent Integral Probability Metrics (Sriperumbudur et al., 2009; Bao et al., 2023), which we include in Appendix B.2. We now combine our bounds on the optimization error and generalization gap into Theorem 1 below.

**Theorem 1**.: _Let assumptions 1, 2, 3, and 4 hold, and let \(\) be a function such that (7) holds. Consider Algorithm 1 with learning rate \(=\), \(\), and assume the aggregation function \(F\) to be \((f,)\)-robust. Then, for any \(>0,T 1\), we have with probability at least \(1-\) (over the choice of samples) that_

\[_{i}(_{i}^{T})-&_{i}(_{i}^{*})(1-)^{T} _{0}+ G^{2}}{^{2}}+2( _{i},_{})\\ &+4)^{2 }}{m}+}{m(n-f)}},\] (8)

_where \(()(()})}+\) and \(_{i,*}^{}_{}_{i}^{ }()\)._

**Interpretation.** The bound in Theorem 1 features a trade-off between _data heterogeneity_, _sample size_, and _model complexity_. Indeed, we minimize the bound in Theorem 1 and obtain the following closed-form approximation by ignoring constant and logarithmic terms, and assuming that \(n,T 1\) (see Appendix C for details)

\[^{*}_{}(()}{m}}-(_{i},_{})}{G^{2}} ),\] (9)

where \(_{}\) denotes the projection over \(\). This expression suggests that the optimal collaboration parameter decreases with data heterogeneity. Indeed, if \((_{i},_{})>()}}{{m}}}\), then \(^{*}=0\) and local learning, as expected, is optimal. Otherwise, the optimal collaboration parameter can be non-zero. This validates the fact that correct clients cannot improve their local generalization when their local distributions are too dissimilar compared to the complexity of the hypothesis class and the number of data points each of them has. Furthermore, even if the heterogeneity \((_{i},_{})\) sufficiently small compared to \(()}}{{m}}}\), the level of collaboration must be re-evaluated according to \(G^{2}\); hence depending on both the fraction of adversaries and the dissimilarity of the gradient between correct clients.

### Experimental Validation

Setup.We empirically investigate the impact of Byzantine adversaries on the generalization performance, in our personalization framework, using the Phishing dataset (Chiew et al., 2019) and

Figure 2: Effect of adversarial fraction and heterogeneity and local sample size. (Top) Phishing dataset with logistic regression with \(n=20\), \(=3\). (Bottom) MNIST with a Convolutional Neural Network (details in Appendix D) \(n=20\). \(=\) refers to the homogeneous setting.

the MNIST dataset (LeCun and Cortes, 2010). Other experiments are included in Appendix D. For the different experiments, we use the state-of-the-art defense under data heterogeneity: NNM pre-aggregation (Allouah et al., 2023) rule followed by trimmed mean as robust aggregation (Yin et al., 2018). We simulate the Byzantine attack with the Sign Flipping attack (Li et al., 2020). Throughout the experiments, we fix \(n=20\), and only vary the local dataset size \(m\), the fraction of Byzantine adversaries \(f\), and the heterogeneity level \(\) which we will explain in the next paragraph. The clients execute Algorithm 1 for \(T\) iterations which depends on the dataset being used. Figure 2, as well as the figures in Appendix D, show the average results and error bars for \(5\) random runs.

To simulate heterogeneity, we use a Dirichlet distribution (Hsu et al., 2019) to generate datasets with unbalanced class fractions for each client. The parameter \(\) determines the heterogeneity degree (the smaller the bigger the heterogeneity). We subsequently sample the test datasets using the same class distribution as the train datasets for each client, and we evaluate the trained models on these local datasets. We defer the implementation details to Appendix D.

Figure 2, as well as Figure 6 from Appendix D, show the final local test accuracy performance as a function of the degree of collaboration (\(\)) for different values of \(f,m\) and \(\). These experimental results shed light on the impact of these different factors and allow us to confirm the main insights of our theory.

Full collaboration can be suboptimal.This can be gleaned from settings where the adversarial fraction is substantial (over \(6\) adversarial clients, e.g. green and red curves in Figure 2), when the heterogeneity is large (small values of \(\), e.g. blue and orange curves in Figure 6 in Appendix D) and when the local dataset is large enough (e.g. Figure 2b and Figure 2c). In situations where the adversarial fraction is critical (\(f=9\), corresponding to red curves in Figure 2 ), robust federated learning completely fails, achieving accuracy scores under \(50\%\) on the local test datasets. Figure 5 in Appendix D further illustrates this point, showing that even local learning can be better than state-of-the-art robust Federated Learning in these circumstances.

Fine-tuning the collaboration helps get the best of both worlds.Figure 2(Bottom) shows that in data scarcity scenarios, for moderate values of the number of adversarial clients (\(f=3\) or \(f=6\)), using a collaboration degree strictly between \(0\) and \(1\) yields better accuracy on the local test dataset. The same effect also appears in Figure 2(Top) for \(f=3\) and Figure 4 in Appendix D. Additionally, even for extreme adversarial fractions (\(f=9\) in our experiments), the gain from decreasing the collaboration degree can be substantial compared to simply using Robust Federated Learning methods. This suggests that fine-tuning the collaboration degree can help dampen the detrimental effects of adversarial clients.

## 4 Conclusion & Future Work

In this paper, we have taken a first step towards understanding how fine-tuning personalization in FL can mitigate the impact of adversarial clients. The results we obtain suggest that the use of personalization can improve the performance of FL algorithms in the presence of adversarial clients, but also that the level of collaboration needs to be chosen carefully. Our theoretical analysis accounts for the necessity to strike a balance between the optimization error, which is impacted by adversarial clients, and the generalization gap, which is likely to benefit from a larger pool of data. We identify the main factors that impact the local performance, namely data heterogeneity, the fraction of adversarial clients, and data scarcity. This work could be extended in several directions. Firstly, as explained in Section 3, the study of Algorithm 1 primarily serves our understanding of the robust interpolated optimization problem in (3) from an information-theoretic perspective. However, it may not be efficient enough to cope with high-dimensional learning tasks involving a number of clients. An interesting future direction could be to investigate alternative algorithms with lower communication and computational costs, which would be able to handle these high-dimensional problems. Second, our study focuses on a personalization strategy that interpolates between client loss functions. Although this strategy is simple to interpret and allows us to derive optimization and generalization bounds, it is only one of many possible personalized FL schemes. Another interesting avenue would be to investigate whether the insights we drew from our interpolated problem could be derived in a similar fashion from other personalization frameworks such as regularization, layer specialization, or clustering.