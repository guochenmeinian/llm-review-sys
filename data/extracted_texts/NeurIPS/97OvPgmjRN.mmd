# Enhancing Chess Reinforcement Learning with Graph Representation

Tomas Rigaux

_Kyoto University_

Kyoto, Japan

tomas@rigaux.com &Hisashi Kashima

_Kyoto University_

Kyoto, Japan

kashima@i.kyoto-u.ac.jp

 tomas.rigaux.com

###### Abstract

Mastering games is a hard task, as games can be extremely complex, and still fundamentally different in structure from one another. While the AlphaZero algorithm has demonstrated an impressive ability to learn the rules and strategy of a large variety of games, ranging from Go and Chess, to Atari games, its reliance on extensive computational resources and rigid Convolutional Neural Network (CNN) architecture limits its adaptability and scalability. A model trained to play on a \(19 19\) Go board cannot be used to play on a smaller \(13 13\) board, despite the similarity between the two Go variants. In this paper, we focus on Chess, and explore using a more generic Graph-based Representation of a game state, rather than a grid-based one, to introduce a more general architecture based on Graph Neural Networks (GNN). We also expand the classical Graph Attention Network (GAT) layer to incorporate edge-features, to naturally provide a generic policy output format. Our experiments, performed on smaller networks than the initial AlphaZero paper, show that this new architecture outperforms previous architectures with a similar number of parameters, being able to increase playing strength an order of magnitude faster. We also show that the model, when trained on a smaller \(5 5\) variant of chess, is able to be quickly fine-tuned to play on regular \(8 8\) chess, suggesting that this approach yields promising generalization abilities. Our code is available at https://github.com/akulen/AlphaGateau.

## 1 Introduction

In the past decade, combining Reinforcement Learning (RL) with Deep Neural Networks (DNNs) has proven to be a powerful way to design game agents for a wide range of games. Notable achievements include AlphaGo's dominance in Go , AlphaZero's human-like style of play in Chess and Shogi , and MuZero's proficiency across various Atari games . They use self-play and Monte Carlo Tree Search (MCTS)  to iteratively improve their performance, mirroring the way humans learn through experience, or intuition, and game-tree exploration.

Previous attempts to make RL-based chess engines were unsuccessful as the MCTS exploration requires a precise position heuristic to guide its exploration. Handcrafted heuristics such as the ones used in traditional minimax exhaustive tree searches were too simplistic, and lacked the degree of sophistication that the random tree explorations of MCTS expects to be able to more accurately evaluate a complex chess position. By combining the advances in computing powers with the progress of the field of Deep Learning, AlphaZero was able to provide an adequate heuristic in the form of a Deep Neural Network that was able to learn in symbiosis with the MCTS algorithm to iteratively improve itself.

However, these approaches rely on rigid, game-specific neural network architectures, often representing games states using grid-based data structures, and process them with Convolutional Neural Networks (CNNs), which limits their flexibility and generalization capabilities. For example, a model trained on a standard \(19 19\) Go board cannot easily adapt to play on a smaller \(13 13\) board without significant changes to its internal structure, manual parameter transfer, and retraining, despite the underlying similarity of the game dynamics. This inflexibility is further compounded by the extensive computational resources required for training these large-scale models from scratch for each specific game or board configuration. If it was possible to make a single model train of various variants of a game, and on various games at the same time, it would be possible to speed up the training by starting to learn the fundamental rules on a simplified and smaller variant of a game, before presenting the model with the more complex version. Similarly, if a model learned all the rules of chess, it could serve as a strong starting point to learn the rules of Shogi, for example.

It could be possible to design a more general architecture for games such as Go, where moves can be mapped one-to-one with the board grid, so that a model could still use CNN layers and handle differently sized boards simultaneously, but this solution is no longer feasible when the moves become more complex, including having to move pieces between squares, or even dropping captured pieces back onto the board in Shogi.

Those moves evoke a graph-like structure, where pieces, initially positioned on squares, are moved to different new squares, following an edge between those two squares, or nodes. As such, it is natural to consider basing an improved model on a graph representation, instead of a grid representation. We explore replacing CNN layers with GNN layers to implement that idea, and more specifically consider in this paper attention-based GNN layers, reflecting how chess players usually remember the structures that the pieces form, and how they interact with each other, instead of remembering where each individual piece is placed, when thinking about a position.

Representing moves as edges in a graph also introduces the possibility to link the output policy size with the number of edges, to make the model able to handle different game variants with different move structures simultaneously. To do so, it becomes important to have edge features as well as node features, as they will be used to compute for each edge the equivalent move logit. As the classical attention GNN layer, the Graph Attention Network  (GAT) only defines and updates node-features, we propose a novel modification of the GAT layer, that we call Graph Attention neTwork with Edge features from Attention weight Updates (GATEAU), to introduce edge-features. We also describe the full model architecture integrating the GATEAU layer that can handle differently sized input graphs as AlphaGateau.

Our experimental results demonstrate that this new architecture, when implemented with smaller networks compared to the original AlphaZero, outperforms previous architectures with a similar number of parameters. AlphaGateau exhibits significantly faster learning, achieving a substantial increase in playing strength in a fraction of the training time. Additionally, our approach shows promising generalization capabilities: a model trained on a smaller \(5 5\) variant of chess can be quickly fine-tuned to play on the standard \(8 8\) chessboard, achieving competitive performance with much less computational effort.

## 2 Related Work

**Reinforcement Learning.** AlphaGo , AlphaZero , MuZero , and others have introduced a powerful framework to exploit Reinforcement Learning techniques in order to generate self-play data used to train from scratch a neural network to play a game.

However, those frameworks use rigid neural networks, that have to be specialized for one specific game. As such, the training process requires a lot of computation resources. It is also not possible to reuse the training on one type of game to train for another one, or to start the training on a smaller and simpler variant of the game, before introducing more complexity.

**Scalable AlphaZero.** In the research of Ben-Assayag and El-Yaniv , using Graph Neural Networks has been investigated as a way to solve those issues. Using a GNN based model, it becomes possible to feed as input differently-sized samples, such as Othello boards of size between 5 and 16, enabling the model to learn how to play in a simpler version of the game.

This approach had promising results, with 10 times faster training time than the AlphaZero baseline. It was however limited to Othello and Gomoku, and using the GNN layers (GIN layers ) only as a scalable variant of CNN layers, keeping a rigid grid structure.

**Edge-featured GNNs.** There exists a large variety of GNN variants, specialized for different use case s and data properties. For this work, a simple layer was enough to experiment with the merits of the proposed approach, except it was critical that the chosen layer handled both node-features and edge-features. We chose to use an attention-based layer.

Gong and Cheng  introduce the EGNN(a) layer, where each dimension of an edge-feature is used for a different attention head. We wanted edge features to be treated as a closer equivalent to node-features, so we did not use this layer.

The EGAT layer introduced by Chen and Chen  is better for our case, as they construct a dual graph where edges and nodes have reversed roles, so the node features in the dual graph are edge features for the initial graph. However, this method requires building the dual graph, and is quadratic in the maximal node degree. As this was quite complex, we decided to introduce GATEAU, which solves the problem in a simpler and more natural way.

## 3 Setting

Our architecture is based on the AlphaZero framework, which employs a neural network \(f_{}\) with parameters \(\) that is used as an oracle for a Monte-Carlo Tree Search (MCTS) algorithm to generate self-play games. When given a board state \(s\), the neural network predicts a (value, policy) pair \((v(s),(s,))=f_{}(s)\), where the value \(v[-1,1]\) is the expected outcome of the game, and the policy \(\) is a probability distribution over the moves.

We utilize Algorithm 1 to train the models in this paper, with modifications to incorporate Gumbel MuZero  with a gumbel scale of 1.0 as our MCTS variant.

``` Parameters:\(N_{iter}=100,N_{gances}=256,N_{sim}=128,ws=10^{6},N_{train}=1,bs=2048\) \(()\); for\(i 1\)to\(N_{iter}\)do  data \(\)selfplay(\(,N_{gances},N_{sim}\)); /* We generate self-play data */  frame_window \(\) (data\(|\)frame_window\(|1:ws\)); /* The new frame window consists of  the newly generated data and a uniform sample of the previous window */ for\(j 1\)to\(N_{train}\)do  frame_window \(\) frame_window.shuffle(); forbatch inframe_window.batches(\(bs\))do \(\)apply(\(\).gradient(\(\),batch));  end for  end for  end for ```

**Algorithm 1**Self-Play Training

## 4 Proposed Models

### Motivation: Representing the Game State as a Graph

Many games, including chess, are not best represented as a grid. For example, chess moves are analogous to edges in a grid graph, and games like Risk naturally form planar graphs based on the map. As such, it makes natural sense to encode more information through graphs in the neural network layers that are part of the model.

This research focuses on implementing this idea in the context of chess. This requires to answer two questions: how to represent a chess position as a graph, and how to output a policy vector that is edge-based, and not node-based.

The architecture presented in this paper is based on GNNs, but using node features to evaluate the value head, and edge features to evaluate the policy head. As such, a GNN layer that is able to handle both node and edge features is required. This paper will introduce the GATEAU layer, that is a natural extension of the GAT layer  to edge features.

### Graph Design

In AlphaZero, a chess position is encoded as an \(n n 119\) matrix, where each square on the \(n n\) chess board is associated to a feature vector of size 119, containing information about the corresponding square for the current position, as well as the last 7 positions, as described in Table 1.

We will instead represent the board state as a graph \(G(V,E)\), with the \(n n\) squares being nodes \(V\), and the edges \(E\) being moves, based on the action design of AlphaZero. Each AlphaZero action is a pair (source square, move), with \(n n\) possible source squares. In \(8 8\) chess, the 73 moves (resp. 49 in \(5 5\) chess) are divided into 56 queen moves (resp. 32), 8 knight moves (resp. 8), and 9 underpromontions (resp. 9) for a total of 4672 actions (resp. 1225). The edge associated with an action is oriented from the node corresponding to the source square, to the destination square of the associated move. In \(8 8\) chess, castling is represented with the action going from the king's starting square going laterally 2 squares. As this action encoding is a little too large, containing moves ending outside of the board that do not correspond to real edges, the constructed graph only contains 1858 edges (resp. 455), corresponding only to valid moves.

The node and edge features, of initial size 119 and 15, are detailed in Tables 1 and 2, respectively. Node features are based on AlphaZero's features, including piece type, game state information, and historical move data. Edge features encode move legality, direction, potential promotions, and piece-specific move capabilities. In the case of \(5 5\) chess, we include the unused castling information, in order to have the same vector size of the \(8 8\) models. It would be possible to preprocess the node and edge features differently for different games or variants, but for simplicity we didn't do it.

The starting positions for all games played in our experiments were either the classical board setup in \(8 8\) chess, or the Gardner setup for \(5 5\) chess, illustrated in Figure 1.

### GATEAU: A New GNN Layer, with Edge Features

The Graph Attention Network layer introduced by Velickovic et al.  updates the node features by averaging the features of the neighbouring nodes, weighted by some attention coefficient. To be more precise, given the node features \(h^{N K}\), attention coefficients are defined as

\[e_{ij}=W_{u}h_{i}+W_{v}h_{j}\] (1)

with parameters \(W_{u},W_{v}^{K K^{}}\). In the original paper, \(W_{u}=W_{v}\), but as we are working with a directed graph, we differentiate them to treat the source and destination node asymmetrically. Then

   Dimensions & Description \\ 
12 & The piece on the square, as a 12-dimensional soft one-hot \\
2 & Whether the position was repeated before \\
98 & For each of the previous 7 moves, we repeat the last 14 dimensions \\  1 & The current player \\
1 & The total move count \\
4 & Castling rights for each player \\
1 & The number of moves with no progress \\   

Table 1: Node features

   Dimensions & Description \\ 
1 & Is this move legal in the current position? \\
2 & How many squares [to the left/up] does this edge move? \\
4 & Would a pawn promote to a \{knight/bishop/rook/queen\} if it did this move? \\
2 & Could a \{white/black\} pawn do this move? \\
4 & Could a \{knight/bishop/rook/queen\} do this move? \\
2 & Could a \{white/black\} king do this move? \\   

Table 2: Edge featureswe can compute attention weights \(\), and use them to update the node features:

\[^{0}_{ij} =_{j}a^{T}e_{i_{ }}=(a^{T}e_{ij})}}{ _{k}^{(a^{T}e_{ik})}},\] (2) \[h^{}_{i} =_{j_{i}}^{0}_{ij}Wh_{j}\] (3)

with parameters \(W^{K K^{}}\) and \(a^{K^{}}\).

The main observation motivating GATEAU is that in this process, the attention coefficients \(e_{ij}\) serve a role similar to node features, being a vector encoding some information between nodes \(i\) and \(j\). As such, we propose to introduce edge features in place of those attention coefficients.

Our proposed layer, called Graph Attention neTwork with Edge features from Attention weight Updates (GATEAU) takes the node features \(h^{N K}\) and edge features \(g_{i,j}^{N N K^{}}\) as inputs. We start by simply updating the edge features similarly to Eq. 1:

\[g^{}_{ij}=W_{u}h_{i}+W_{e}g_{ij}+W_{v}h_{j}\] (4)

with parameters \(W_{u},W_{v}^{K K^{}}\) and \(W_{e}^{K^{} K^{}}\). Then the attention weights are obtained as in Eq. 2, by substituting the attention coefficients with our new edge features:

\[_{ij}=_{j}(a^{T}g^{ }_{i})\] (5)

with parameter \(a^{K^{}}\). Finally, we update the node features as in Eq. 3:

\[h^{}_{i}=W_{0}h_{i}+_{j_{i}}_{ij}(W_{h}h_{j}+W_{ g}g_{ij})\] (6)

with parameters \(W_{0},W_{h}^{K K^{}}\) and \(W_{g}^{K^{} K^{}}\). We add the self-edges manually as it is inconvenient for the policy head if they are included in the graph, and we mix back the values of the edge features back in the node features.

### AlphaGateau: A Full Model Architecture Based on AlphaZero and GATEAU

Following the structure of the AlphaZero neural network, we introduce AlphaGateau, combining AlphaZero with GATEAU instead of CNN layers, and redesign the value and policy head to be able to exploit node and edge features respectively to handle arbitrarily sized inputs with the same number of parameters.

We define the following layers, which are used to describe AlphaGateau in Figure 2.

**Attention Pooling.** In order to compute a value for a given graph, we need to pool the features together. Node features seem to be the more closely related to positional information, so we pool them instead of edge features. For this, we use an attention-based pooling layer, similar to the one described in Eq. 7 by Li et al. , which, for node features \(h^{N K}\) and a parameter vector \(a^{K}\), outputs

\[^{p}_{i}=_{i} (a^{T}h_{}),\] \[H=_{i}^{p}_{i}h_{i},\] (7)

Figure 1: The starting positions of \(8 8\) and \(5 5\) chess games

where \(H^{K}\) is a global feature vector.

**Batch Normalization and Non-linearity (BNR).** As they are a pair of operations that often occur, we group Batch Normalization and a ReLU layer together under the notation BNR:

\[(x)=((x)).\] (8)

**Residual GATEAU (ResGATEAU).** Mirroring the AlphaZero residual block architecture, we introduce ResGATEAU, which similarly sums a normalized output from two stacked GATEAU layers to the input:

\[(h,g)=(h,g)+((( (h,g)))).\] (9)

## 5 Experiments

We evaluate AlphaGateau's performance in learning regular \(8 8\) chess from scratch and generalizing from a \(5 5\) variant to the standard \(8 8\) chessboard. The metric used to evaluate the models is the Elo rating, calculated through games played against other models (or players) with similar ratings. Due to computational constraints, we couldn't replicate the full 40 residual layers used in the initial AlphaZero paper, and experimented with 5 and 6 layer models. We also started exploring 8 layers, but these models required to generate a lot more data, which would make the experiment run an order of magnitude longer. Our results indicate that AlphaGateau learns significantly faster than a traditional CNN-based model with similar structure and depth, and can be efficiently fine-tuned from \(5 5\) to \(8 8\) chess, achieving competitive performance with fewer training iterations. 2 All models used in these experiments are trained with the Adam optimizer  with a learning rate of 0.001. All feature vectors have an embedding dimension of 128. The loss function is the same as for the original AlphaZero, which is, for \(f_{}(s)=,\),

\[L(,v,,)=-^{T}()+(v-)^{2}.\] (10)

Figure 4: Policy head

Figure 3: Value head

### Implementation

**Jax and PGX.** As the MCTS algorithm requires a lot of model calls weaved throughout the tree exploration, it is essential to have optimized GPU code running both the model calls, and the MCTS search. In order to leverage the MCTX  implementations of Gumbel MuZero, all our models and experiments were implemented in Jax  and its ecosystem . PGX  was used for the chess implementation, and we based our AlphaZero implementation on the PGX implementation of AZNet. We used Aim  to log all our experiments.

To estimate the Elo ratings, we use the statsmodels package  implementation of Weighted Least Squares (WLS).

**Hardware.** All our models were trained using multiple Nvidia RTX A5000 GPUs (_Learning speed_ used 8 and _Fine-tuning_ used 6), and their Elo ratings were estimated using 6 of those GPUs.

### Evaluation

As each training and evaluation lasted a little under a week, we were not able to train each model configuration several times so far. As such, each model presented in the results was trained only once, and the confidence intervals that we include are on the Elo rating that we estimated for each of them, as described in the following.

During training, at regular intervals (each 2, 5, or 10 iterations), the model parameters were saved, and we used this dataset of parameters to evaluate Elo ratings. In this section, we will call a pair (model, parameters) a player, and compute a rating for every player.

We initially chose 10 players, and simulated 60 games between each pair of players, to get initial match data \(M\). For each pair of players that played a match, we store the number of wins \(w_{ij}\), draws \(d_{ij}\), and losses \(l_{ij}\): \(M_{ij}=(w_{ij},d_{ij},l_{ij})\). Using this data, we can roughly estimate the ratings \(r^{N_{players}}\) of the players present in \(M\) using a linear regression on the following set of equations:

\[r_{j}-r_{i}&=(+d_{ij}+l_{ij}+1}{w_{ij}++1}{2}}-1)&i M,j M_{i},\\ _{i M}r_{i}&=|M| 1000.\] (11)

We artificially add one draw to avoid extreme cases where there are only wins for one player and no losses, in which case the rating difference would theoretically be infinite. This is equivalent to a Jeffreys prior. The last equation fixes the average rating to 1000, as the Elo ratings are collectively invariant by translation.

We then ran Algorithm 2 to generate a densely connected match data graph, where each player played against at least 5 other players of similar playing strength. Finally, we used this dataset to fit a linear regression model (Weighted Least Squares) to get Elo ratings that we used in the results figures for the experiments. The confidence intervals were estimated by assuming that the normalized match outcomes followed a Gaussian distribution. If \(_{ij}=+d_{ij}+1}{w_{ij}+d_{ij}+l_{ij}+1}\) is the estimated probability that player \(i\) beats player \(j\), we approximate the distribution that \(p_{ij}\) follows as a Gaussian, and using the delta method, we derive that \(r_{j}-r_{j}\) asymptotically follows a Gaussian distribution of mean \((}-1)\) and variance \(()^{2}+d_{ij}+l_{ij})p_{ij}(1- p_{ij})}\). The proof is detailed in Appendix A.2. Using the WLS linear model of statsmodels , we get Elo ratings for every player, as well as their standard deviations, which we use in the following to derive 2-sigma confidence intervals.

### Experiments

**Learning Speed.** Our first experiment compares the baseline ability of AlphaGateau to learn how to play \(8 8\) chess from scratch, and compares it with a scaled down AlphaZero model. The AlphaZero model has 5 residual layers (containing 10 CNN layers) and a total of 2.2M parameters, and the AlphaGateau model also has 5 ResGATEAU layers (containing 10 GATEAU layers) and a total of 1.0M parameters, as it doesn't need an \(N_{nodes} hs N_{actions}\) fully connected layer in the policy head, and the GATEAU layers use 2/3 of the parameters a \(3 3\) CNN does.

For this experiment, we generated 256 games of length 512 at each iteration, totalling \(131\,072\) frames, and kept a frame window of 1M frames (all the newly generated frames, and uniform sampling over the frame window of the previous iteration), over 500 iterations. During the neural network training, we used a batch size of 256. The training for AlphaGateau lasted 13 days and 16 hours, while AlphaZero took 10 days and 3 hours.

We report the estimated Elo ratings with a 2-sigma confidence interval in Figure 5. AlphaZero was only able to reach an Elo of \(667 38\) in 500 iterations, and would likely continue to improve with more time, while AlphaGateau reached an Elo of \(2105 42\), with an explosive first 50 iterations, and achieving results comparable to the final Elo of AlphaZero after only 10 iterations.

Although those results are promising, it is important to note that we only compared to a simplified version of AlphaZero, using only 5 layers instead of the original 40, and without spending large efforts to optimize the hyperparameters of the model. As such, it is possible that the performance of AlphaZero could be greatly improved in this context with more parameter engineering. Both AlphaGateau and AlphaZero have not reached a performance plateau after 500 iterations, showing slow but consistent growth.

**Fine-tuning.** In our second experiment, we trained a AlphaGateau model with 10 residual layers on \(5 5\) chess for 100 iterations, then fine-tuned this model on \(8 8\) chess for 100 iterations. This model has a total of 1.7M parameters.

For this experiment, we generated 1024 games of length 256 at each iteration on \(5 5\) chess, and 256 games of length 512 while fine-tuning on \(8 8\) chess, and kept a frame window of 1M frames. The initial training lasted 2 days and 7 hours, and the fine-tuning 5 days and 15 hours.

We report the estimated Elo ratings with a 2-sigma confidence interval in Figure 6. The initial training ended with an Elo rating of \(807 46\) when evaluated on \(8 8\) chess games, which suggests that it was able to learn general rules of chess on \(5 5\), and apply them with some success on \(8 8\) chess without having seen any \(8 8\) chess position during its training. Once the fine-tuning starts, the model jumps to an Elo of \(1181 50\) after a couple iterations, suggesting the baseline learned on \(5 5\) was of high quality. After fine-tuning, the model had an Elo of \(1876 47\), reaching comparable performances to the smaller model using roughly the same amount of iterations and GPU-time, despite being twice as big. Preliminary testing suggests that this model would become stronger if more data was generated at each iteration, but that would linearly increase the training time, as generating self-play games took half of the 5 days of training.

### Impact of the Frame Window and the Number of Self-play Games

In order to train deeper networks, we experimented with the number of self-play games generated at each generation, and with the size of the frame window. It seems from our results in Figure 7 that having more newly generated data helps the model learn faster. However, the time taken for each iteration scales linearly with the number of generated games, and the model is still able to improve using older data. As such, keeping a portion of the frame window from previous iterations makes for a good compromise. There are however options to improve our frame window selection:* Which previous samples should be selected? We selected uniformly at random from the previous frame window to complement the newly generated samples, but it might be preferable to select fewer samples, but chosen as to represent a wide range of different positions.
* Past samples are by design of dubious quality. As they come from self-play games with previous model parameters, they correspond to games played with a lower playing strength, and the policy output by the MCTS is also worse. Keeping a sample that is too old might cause a drop of performance rather than help the model learn. We experimented a little with keeping the 1M most recent samples, but with little success.

We also initially tried to increase the number of epochs in one iteration, but only saw marginal gains, suggesting that mixing new data among the previous frame window helps the model extract more training information from previous samples.

Figure 5: The Elo ratings of AlphaZero and AlphaGateau with 5 residual layers trained over 500 iterations. The AlphaGateau model initially learns \(\)10 times faster than the AlphaZero model, and settles after 100 iterations to a comparable speed of growth to that of AlphaZero.

Figure 6: The Elo ratings of the first 100 iterations of the AlphaGateau model from Figure 5 was included for comparison. The initial training on \(5 5\) chess is able to increase its rating while evaluated on \(8 8\) chess during training, even without seeing any \(8 8\) chess position. The fine-tuned model starts with a good baseline, and reaches comparable performances to the 5-layer model despite being undertrained for its size.

Figure 7: The two models with a frame window of size \(131\,072\) only kept the latest generated games in the frame window. The model keeping no frame window and generating 256 games was trained in only 39 hours, but had the worst performance. Adding a 1M frame window improved the performance a little and lasted 60 hours, while increasing the number of self-play games to 1024 performed the best, but took 198 hours.

Conclusion

In this paper, we introduce AlphaGateau, a variant on the AlphaZero model design that represents a chess game state as a graph, in order to improve performance and enable it to better generalize to variants of a game. This change from grid-based CNN to graph-based GNN yields impressive increase in performance, and seems promising to enable more research on reinforcement-learning based game-playing agent research, as it reduces the resources required to train one.

We also introduce a variant of GAT, GATEAU, that we designed in order to handle edge features in a simple manner performed well, and efficiently.

**Future Work.** As our models were relatively shallow when compared to the initial AlphaZero, it would be important to confirm that AlphaGateau still outperforms AlphaZero when both are trained with a full 40-deep architecture. This will require a lot more computing time and resources.

As discussed in Section 5.4, our design of the frame window is a little unsatisfactory, and a future improvement would be to define an efficiently computable similarity metric between chess positions, that helps the neural network generalize.

We focused on chess for this paper, but there are other games that could benefit from this new approach. The first one would be shogi, as it has similar rules to chess, and the promising generalization results from AlphaGateau could be used to either train a model on one game, and fine-tune it on the other, or to jointly train it on both games, to have a more generalized game-playing agent. As alluded to in the Graph Design 4.2, more features engineering would be required to have node and edge features compatibility between chess graphs, and shogi graphs. It could also be possible to change the model architecture to handle games with more challenging properties, such as the game Risk, which has more than 2 players, randomness, hidden information, and varying maps, but is even more suited to being represented as a graph.