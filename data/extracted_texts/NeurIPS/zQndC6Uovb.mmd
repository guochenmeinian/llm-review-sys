# Annealing Machine-assisted Learning of Graph Neural Network for Combinatorial Optimization

Pablo Loyola\({}^{1}\)  Kento Hasegawa\({}^{3}\)  Andres Hoyos-Idobro\({}^{2}\)  Kazuo Ono\({}^{3}\)

**Toyotaro Suzumura\({}^{1,4}\)  Yu Hirate\({}^{1}\)  Masanao Yamaoka\({}^{3}\) \({}^{1}\)**Rakuten Institute of Technology, Rakuten Group, Inc., Tokyo, Japan

\({}^{2}\)Rakuten Institute of Technology, Rakuten Group, Inc., Paris, France

\({}^{3}\)Hitachi, Ltd., Tokyo, Japan

\({}^{4}\)The University of Tokyo, Japan

{pablo.a.loyola, andres.hoyosidrobo, yu.hirate}@rakuten.com

{kento.hasegawa.bc, kazuo.ono.ap, masanao.yamaoka.ns}@hitachi.com

suzumura@acm.org

###### Abstract

While Annealing Machines (AM) have shown increasing capabilities in solving complex combinatorial problems, positioning themselves as a more immediate alternative to the expected advances of future fully quantum solutions, there are still scaling limitations. In parallel, Graph Neural Networks (GNN) have been recently adapted to solve combinatorial problems, showing competitive results and potentially high scalability due to their distributed nature. We propose a merging approach that aims at retaining both the accuracy exhibited by AMs and the representational flexibility and scalability of GNNs. Our model considers a compression step, followed by a supervised interaction where partial solutions obtained from the AM are used to guide local GNNs from where node feature representations are obtained and combined to initialize an additional GNN-based solver that handles the original graph's target problem. Intuitively, the AM can solve the combinatorial problem indirectly by _infusing_ its knowledge into the GNN. Experiments on canonical optimization problems show that the idea is feasible, effectively allowing the AM to solve size problems beyond its original limits.

## 1 Introduction

Graph-based approaches are one of the most predominant techniques for learning combinatorial optimization solvers. Their distributed nature allows them to scale up to millions of nodes . Nevertheless, their probabilistic nature, which provides soft assignments to decision variables, may produce solutions at a different level than their classic counterparts . Annealing Machines (AM), a concurrent line of research, is seen as a more immediate alternative to the expected advances of future fully quantum solutions, which are currently in use in several industries . Their major drawback, similarly suffered by the fully quantum versions, is their scalability, handling a limited number of variables, sometimes forcing problem reformulations to fit hardware limitations .

We see these two approaches working towards the same goal: _i)_ GNN-based methods enable scalability, but their solutions could be noisy; _ii)_ AM-based methods provide high precision, yet they are limited in the number of variables they can handle. This apparent trade-off motivates us to design a framework to capture the best of each technology: high scalability and high precision. This work proposes a way to _combine_ the solving capabilities of both graph and annealing-based methods into a single workflow that handles combinatorial optimization problems at scale.

Given a combinatorial problem \(P\) and its associated graph \(_{P}=(_{P},_{P})\), with node set \(_{P}\) and edge set \(_{P}\), our framework considers a sequential compression step, that generates a list \(\{_{i}\}_{i=1}^{s}\) of compressed versions of \(_{P}\) with \(|_{P}||_{1}||_{s}|\). Then, we perform a supervised interaction step where the AM solution for each graph \(_{i}\) acts like target labels of a \(i\)-th local GNN, \( i[s]\). Finally, we pool all these node feature representations and use them to initialize an extra GNN-based solver that handles \(P\) on the original graph \(\). In that sense, the AM solves the combinatorial problem indirectly by infusing its knowledge into the GNN. We conducted an empirical study on three canonical optimization problems over various families of graphs. Our results show that the proposed solution is feasible, allowing the AM to solve problems of size beyond its initial scope, reduce the overall converge time, and, in some cases, even increase the solution quality.

## 2 Background and Related Work

**Annealing Machines for Combinatorial Optimization** AM can operate based on various mechanisms, including both quantum and classical: superconducting flux qubits, degenerating optical parametric oscillators, and semiconductor CMOS integrated circuits. However, there are various types of AM since D-Wave released the first commercial quantum AM [18; 31; 23; 30; 12; 11; 14; 17; 1; 20]. AM requires casting the target problem as a Quadratic Unconstrained Binary Optimization (QUBO) problem [10; 8]. The QUBO formulation models the problem as a graph, with nodes as decision variables and edges as (energy) couplings that encode their relationships. This formulation has proven versatile, with AM covering a wide range of applications [7; 26; 6; 22; 24; 21; 16; 32]. We refer the reader to  for a comprehensive QUBO formulation tutorial. We consider the following problem:

\[&\ ^{} =:H_{}()\\ &\ \{0,1\}^{n},\] (1)

where \(H_{}\) is the Hamiltonian associated with the QUBO matrix \(^{n n}\), which is the symmetric matrix that encodes the target problem, and \(\) is the vector of binary assignments. In this work, we explore to what extent the GNNs can enable AMs to handle larger problems, hopefully without sacrificing accuracy.

**QUBO-based Graph Learning for Combinatorial Optimization** Recently  exploited the relationship between GNNs and QUBO for solving combinatorial problems. This method relies on the QUBO formulation of a target problem, where a GNN takes the Hamiltonian as the cost function and minimizes it in an unsupervised way. Thus, for the \(k\)-th GNN layer and a given node \(\), we obtain a node feature representation that depends on both of its previous representation at the \((k-1)\)-th layer and the aggregated representations of the direct neighbors,

\[_{v}^{k}=_{}(_{v}^{k-1},\{_ {u}^{k-1}\  u_{v}\}), k[K],\] (2)

where \(_{v}^{k}^{d_{k}}\), \(d_{k}\) is the dimension of the \(k\)-th representation, \(_{v}\) is the set of neighbors of \(v\), and \(_{}\) a learnable function . The resulting representation passes through a linear layer and an activation function to obtain a single positive real value, and is then projected to integer values to obtain a final binary node assignment.

We write it in compact form as:

\[^{}=_{}(_{}( ,\ )}_{=}^{|| d_{K}}}),\] (3)

where \(^{|| d_{0}}\) is the matrix of initial node features1, \(_{}\) maps the graph \(\) and \(\) to \(}\), and \(_{}:\{0,1\}\) is the composition of a linear layer and an activation function. Let \(_{v}^{d_{0}}\) be the \(v\)-row of \(\), the feature vector of the node \(v\). Thus, the initial embedding in Eq. 2 corresponds to \(_{v}^{0}=_{v},\  v\). Therefore, finding a solution \(^{}\) amounts to minimizing \(H_{}(^{})\) in an unsupervised manner.

Methodology

**Problem Statement** Our main goal is to assess AM and GNN complementarity. We assume a scenario where the target problem is large enough that it cannot be solved solely by the AM. Therefore, we propose a framework that divides the problem into smaller pieces so the AM can consume and solve, and the GNN can act as a bridge, aggregating information to achieve a global solution.

**Graph Compression** We reduce the size of the original graph \(_{P}\) using Louvain decomposition for network community detection . The output of this decomposition is a list of size-decreasing graphs \(\{_{i}\}_{i=1}^{s}\). For each \(_{i}=(_{i},\,_{i})\), the algorithm admits a mapping back to the original graph. Thus, we can relate a single artificial node \(n_{i}\) with the corresponding set of actual nodes in the original graph \(_{P}\). We ensure the size of all resulting graphs is smaller than the aforesaid feasibility limit exhibited by the AM. We chose Louvain decomposition because _i)_ it is one of the most cited and well-understood methods for community detection _ii)_ it is hierarchical, allowing reconstruction from a given granularity to the original graph, _iii)_ among hierarchical models, Louvain provides the most homogeneous results, as literature shows . Given the expected diversity of graphs our method should handle, we consider homogeneity to be a desirable factor.

**Multiresolution Guidance I : Locally-assisted Solvers Interaction** We get a QUBO matrix \(_{i}\) for each \(_{i}\). We assume that while these derived matrices are not equivalent to \(_{P}\), there should be certain alignment as they are working on different granularities of the original graph \(_{P}\). As each \(_{i}\) is smaller than the AM's limit, we can apply it to solve them. This step outputs, for each \(_{i}\), the solution found by the AM, in the form of a binary solution vector \(_{i}^{}^{|_{i}|}\).

**Multiresolution Guidance II : Guiding block (GB)** We consider AM solutions a good source of supervision and use them to drive local GNNs that solve upon the same set of \(_{i}\) graphs. Instead of just minimizing the Hamiltonian in an unsupervised way, as described in Sec. 2, we propose to combine the Hamiltonian cost with a measure of alignment between the AM's solution and GNN's partial solutions at each training time/epoch \(t\). For a graph \(_{i}\), let \(_{i,t}^{}\) be the GNN's partial solution. \(_{i,t}^{}\) denotes assignment scores. Thus, we have \(^{i}=_{}(_{i,t}^{ },\,_{i}^{})\  i[s]\), where \(_{i,t}^{}=_{}(_{}(_{i},))\). We set \((,)=\|-\|^{2}\). _Local_ GNNs can quickly converge for each compressed graph due to this guidance. While we check these local results' specific behavior and quality, we focus more on the final node representations. For each \(_{i}\), this step gets a matrix \(}^{i}^{|_{i}| d_{K}}\) (with \(d_{K}\) a predefined vector dimensionality) with the node vectors after the GNN converged. Fig. 0(b) depicts this process for one compressed graph.

**Aggregating Partial Solutions** The output of the previous step gives a node feature vector for each compressed graph \(_{i}\). We reuse these feature vectors to initialize a larger GNN to solve \(P\) on the original graph \(_{P}\), called _Main GNN solver_ in Fig. 0(a). We hypothesize that these feature representations associated with AM-guided solutions on compressed versions of \(_{P}\) may encode valuable information that, if passed as initial node vectors for the main solver, could benefit the solution-finding process, in contrast, to initialize those node vectors randomly (\(_{v}^{0}\) is random).

**Mapping Module** Let \(_{n^{i}}\) denote the set of real nodes in the original graph \(_{P}\) associated with a given node \(n^{i}_{i}\), the \(i\)-th compressed version of \(_{P}\). Thus, \(_{n^{i}}=\{v_{P} v_{ }(n^{i})\}\),

Figure 1: (a) Proposed approach: Original graph \(_{P}\) is compressed into a sequence of decreasing size problem graphs, which are solved by AM. A local GNN solver uses those solutions as guidance, and their resulting learned node representations are aggregated through a _Mapping module_ to initialize a Main GNN solver that attaches to the original graph \(_{P}\). (b) Guiding block (GB) diagram.

[MISSING_PAGE_FAIL:4]

_Main_ GNN solver, the loss function is solely the Hamiltonian using the original QUBO matrix (per problem). Both solvers run until convergence, defined using a tolerance parameter or a maximum number of epochs. We set the maximum epochs to 10k and 1k for the _Main_ and _Local_, respectively.

**Annealing Machine** We used a CMOS-based AM that implements momentum annealing . Unlike the standard simulated annealing that updates variables individually, momentum annealing updates all connected variables simultaneously. Momentum annealing executed on a GPU is much faster than the simulated annealing performed on a CPU. We used an NVIDIA Tesla V100 GPU to perform the momentum annealing. Our AM can handle up to 100k decision variables. Variables were updated 1k times during each run of the annealing process. The momentum annealing was performed 1k times, and the best solution was retrieved.

**Graph Solver Variants** We compared three solver variants: _i) Raw GNN_ (rGNN), a single GNN that takes as input the original graph, i.e., _Main_ (global) solver; _ii) Multiresolution GNN_ (rrrGNN), a GNN-based local solver that receives the compressed versions of the original graph and solves the local QUBO problem. After convergence, the resulting node vectors are pooled following the Louvain schema to initialize the node vectors of the main GNN solver; _iii)_rrGNN+AM, a rrGNN with local guidance from the AM.

## 5 Results and Discussion

**Solution Quality and Convergence** We sampled solutions 50 times per target graph and obtained the final solution. We experimented on large graphs; therefore, no ground truth is available. Given this limitation, we used the final loss value as a measure of the quality of the solution, assuming that, in the absence of violations, a lower value means a better solution. Let _loss_ be the evaluation of the Hamiltonian on a binarized solution; see Sec. 2. Unlike the relaxed version we used during training, this loss is our original optimization objective. We also checked violations based on the problem definition. In this scenario, a good solver achieves the lowest loss and, simultaneously, the minimum number of violations. For MIS, rGNN is faster than the other alternatives, reaching loss values 48% larger with 15% more violations on average. This pattern persists across problems, providing evidence that a single GNN block trained in a purely unsupervised way, while fast, seems unable to provide high-quality results. Between rrGNN and rrGNN +AM, while rrrGNN is consistently faster, it also produces more violations across graphs, mainly for the largest graph. This behavior indicates that the information from the local GNN-based solver is indeed useful, compared to rGNN, but not enough to beat the contribution of an AM-based solver. We omit rGNN from the following analyses and focus on the trade-off between quality and speed of rrGNN and rrGNN +AM. Our comparison deals with _i)_ a main GNN solver that received AM's information against and _ii)_ a main GNN solver that received information only from the GNN-based solvers. Given the lack of ground truth (global minimum), we employed the _Relative loss difference_. It computes the difference between absolute values of the minimum loss achieved by rrGNN and rrGNN +AM models: \(_{}=_{}|-|_{}|}{|_{}|} 100\). \(_{}>0\) means rrrGNN+AM has a lower loss than rrGNN. Table 4 presents the values of \(_{}\) across all target graphs for the three selected problems. In addition, Table 2 provides insights into how well models handle constraints. For MIS, we present the number of violations and how balanced the resulting sets are in the case of GP (ratio of their number of nodes).

Our approach is particularly effective for larger graphs. For smaller graphs (up to 100k nodes), rrrGNN performs comparatively well. This performance reinforces our initial goal of using the GNN as a bridge to bring the accurate problem-solving capabilities of the AM to large-scale graphs. The quality of rrGNN degrades as we expand to more complex graphs (in terms of \(n\) and \(d\)), where violations increase compared to rrrGNN+AM. Table 4 shows the relative differences in terms of total execution time, \(_{T}=_{}-_{}}{_{}} 100\). \( T>0\) means rrrGNN is faster than rrGNN+AM. Interestingly, if we look at the execution time comparison, there is a considerable difference depending on the combinatorial problem. This difference is evident when comparing MIS, where rrrGNN is much faster. We hypothesize that the primary input discrepancy resides in the QUBO matrix's shape, as the underlying graph structures remain the same. Therefore, differences may be due to solver technicalities, such as the sparsity2. Note that, for a given graph, a local GNN-based solver is, on average, \(9\) faster than the local AM-based solver, ignoring solution quality aspects. This speed advantage of the GNN solver underscores its practicality in real-world scenarios. We report the total time: the sum of local AM and GNN global solver times; the price to pay for a better solution is the extra time the AM takes. It is worth noting that such time comparison assumes the Louvain compression has been performed in advance, a realistic scenario in the real world.

**Impact of GNN module selection** We compared GCN against a Graph Attention Network (GAT) , as the latter automatically learns to weight incoming node vectors from the set of neighbors during the aggregation step. For MIS, we could see a slight decrease in the achieved loss by up to 100k nodes, but at the expense of \(8\) total time (average for all target graphs). Unfortunately for the other problems, no conclusive evidence was found across graphs, which may suggest the GNN layer could be problem-specific.

**Node Decision Assignment Uncertainty** Fig. 2 shows the decision assignments to nodes during training. While, in general, there is progressive accumulation at the extremes, in red, we can see some cases that exhibit shifts. This phenomenon is undesirable as it could hinder early stopping. We focus on characterizing _late_ shifts, i.e., changes at the late state of training. To do that, we uniformly divided the total number of epochs into three segments: _early_, _mid_, and _late_ and counted how many shifts occur in each segment for both mrGNN and mrGNN+AM. Table 3 shows the proportion of shifts per segment for all target problems. This example shows a clear difference in the proportion of late-stage shifts, with mrGNN+AM reducing them in most cases. This behavior is consistent across graphs, which are omitted due to space limitations.

**Comparison Against other Baselines** For ML-based solvers, most works operate only on small to medium-size graph benchmarks, such as , which represents the state-of-the-art for MIS, considers benchmarks less than a hundred nodes (in average). The assumption is the same for classical (heuristic) solvers. While they can be very efficient on small to medium-sized graphs, they cannot provide comparable solutions as size increases. We conducted the same experimental setting for graphs with sizes 50K, 100K, and 150K varying degrees in \(\) for the MIS problem to assess such an assumption. We selected two representative classical algorithms: Greedy Search (GS) and the HB algorithm . Results confirm our central hypothesis on the difficulty of scaling up classical heuristics: GS finished within 2h only for the family of graphs with \(n\)=50K, with an MIS of size 17% lower than the one obtained by the proposed model. For larger graphs, we stopped the execution after 2h, considering that the total time for the proposed approach was, on average, 12 min. HB algorithm did not finish for \(n=\)50K. In light of this evidence, we consider our approach to be able to scale and

   Last Louvain & \(n\) & \(\) & \(\) \\ used & & MIS & MaxCut \\ 
1st & 67 146 & 5.94\% & 3.10\% \\
2nd & 30935 & 3.84\% & 1.74\% \\
3rd & 14 641 & 0.11\% & 1.02\% \\
4th & 7 013 & 0.01\% & 0.21\% \\   

Table 1: Difference in terms of final loss value using the \(k\)-th Louvain compressed graphs against using all of them for MIS and MaxCut on (\(n\)=150k, \(d\)=5) graph.

   Problem & Solver & early & mid & late \\   & mrGNN & 0.46 & 0.19 & 0.35 \\  & mrGNN+AM & 0.53 & 0.25 & **0.22** \\   & mrGNN & 0.68 & 0.21 & 0.1 \\  & mrGNN+AM & 0.77 & 0.21 & **0.03** \\   & mrGNN & 0.44 & 0.31 & 0.25 \\  & mrGNN+AM & 0.54 & 0.27 & **0.19** \\   

Table 3: Proportion of assignment shifts per training stage for various problems on the \(n=150\)k, \(d=5\) graph. mrGNN+AM solver consistently produces less late stage shifts.

    & n & \(d=3\) & \(d=4\) & \(d=5\) \\   & 50k & 0 / 0 & 0 / 1 & 0 / 3 \\  & 100k & 0 / 1 & 0 / 1 & 0 / 2 \\  & 150k & 1 / 1 & 2 / 2 & 1 / 2 \\   & 50k & 0.48 / 0.46 & 0.46 / 0.46 & 0.44 / 0.44 \\  & 100k & 0.46 / 0.43 & 0.44 / 0.44 & 0.46 / 0.43 \\  & 150k & 0.42 / 0.39 & 0.41 / 0.40 & 0.39 / 0.39 \\   

Table 2: Performance of AM-based and GNN-based methods. Ratio denotes AM /GNN.

provide suitable solutions where classical methods cannot. Finally, we considered a _neural_ model (NM), as presented in . In this case, we compare at MIS size obtained by MN and our proposed method. Out of the nine target graphs, NM only obtains higher MIS size for three: 50K, d=  and 100K, d=3. For the rest, our approach obtains on average of 4.9% higher MIS values, at equal or less number of violations.

## 6 Conclusion and Future Work

We explore how to combine the accuracy of AM and the flexibility of GNN to solve combinatorial optimization problems. Our approach was tested on canonical combinatorial problems, showing that the flexibility of GNNs can allow the transfer of the accurate capabilities of the AM to graphs that are initially out of its reach. For future work, we are interested in _i)_ the reuse of partial solutions across similar problems and _ii)_ an end-to-end differentiable framework.