# UniSDF: Unifying Neural Representations for

High-Fidelity 3D Reconstruction of Complex Scenes

with Reflections

 Fangjinhua Wang1

&Marie-Julie Rakotosaona

ETH Zurich

&Michael Niemeyer

Google

&Richard Szeliski

Google

&Marc Pollefeys

ETH Zurich

&Federico Tombari

Google

###### Abstract

Neural 3D scene representations have shown great potential for 3D reconstruction from 2D images. However, reconstructing real-world captures of complex scenes still remains a challenge. Existing generic 3D reconstruction methods often struggle to represent fine geometric details and do not adequately model reflective surfaces of large-scale scenes. Techniques that explicitly focus on reflective surfaces can model complex and detailed reflections by exploiting better reflection parameterizations. However, we observe that these methods are often not robust in real scenarios where non-reflective as well as reflective components are present. In this work, we propose UniSDF, a general purpose 3D reconstruction method that can reconstruct large complex scenes with reflections. We investigate both camera view as well as reflected view-based color parameterization techniques and find that explicitly blending these representations in 3D space enables reconstruction of surfaces that are more geometrically accurate, especially for reflective surfaces. We further combine this representation with a multi-resolution grid backbone that is trained in a coarse-to-fine manner, enabling faster reconstructions than prior methods. Extensive experiments on object-level datasets DTU, Shiny Blender as well as unbounded datasets Mip-NeRF 360 and Ref-NeRF real demonstrate that our method is able to robustly reconstruct complex large-scale scenes with fine details and reflective surfaces, leading to the best overall performance. Project page: https://fangjinhuawang.github.io/UniSDF.

## 1 Introduction

Given multiple images of a scene, accurately reconstructing a 3D scene is an open problem in 3D computer vision. 3D meshes from reconstruction methods can be used in many downstream applications, _e.g._, scene understanding, robotics, and creating 3D experiences for augmented/virtual reality . Typical aspects of real-world scenes such as uniformly colored areas or non-Lambertian surfaces remain challenging.

As a traditional line of research, multi-view stereo methods  usually estimate depth maps with photometric consistency and then reconstruct the surface as a post-processing step, _e.g._, point cloud fusion with screened Poisson surface reconstruction  or TSDF fusion . However, they cannot reconstruct reflective surfaces since their appearances are not multi-view consistent.

Recently, Neural Radiance Fields (NeRF)  render compelling photo-realistic images by parameterizing a scene as a continuous function of radiance and volume density using a multi-layer perceptron (MLP). More recent works [30; 8; 42; 4] replace or augment MLPs with grid based data structures to accelerate training. For example, Instant-NGP (iNGP)  uses a pyramid of grids and hashes to encode features and a tiny MLP to process them. Motivated by NeRF, neural implicit reconstruction methods [50; 47] combine signed distance functions (SDF) with volume rendering, and produce smooth and complete surfaces. For acceleration, recent works [21; 37] rely on hash grid representations and reconstruct surfaces with finer details. However, these NeRF-based methods cannot accurately reconstruct reflective surfaces [44; 14].

To better represent the reflective appearance, Ref-NeRF  parameterizes the appearance using _reflected_ view direction that exploits the surface normals, while NeRF uses the camera view direction. Recently, some works [51; 22; 25; 14] adopt this reflected view parameterization and successfully reconstruct reflective surfaces. We observe that while reflected view radiance fields can effectively reconstruct highly specular reflections, they struggle to represent more diffuse or ambiguous reflection types and fine details that can be found in real scenes. In contrast, we find that direct camera view radiance fields are more robust to difficult surfaces in real settings, although the reconstructions still present artifacts for reflective scenes. In this paper, we seamlessly bring together reflected view and camera view radiance fields into a novel unified radiance field for representing 3D real scenes accurately in the presence of reflections. Our method is robust for reconstructing both real challenging scenes and highly reflective surfaces.

The proposed method, named UniSDF, performs superior to or on par with respective state-of-the-art methods which are tailored for a specific scene type. UniSDF can be applied to any type of dataset, ranging from DTU , Shiny Blender , Mip-NeRF 360 dataset , to Ref-NeRF real dataset , leading to the overall best performance. It demonstrates the capability to accurately reconstruct complex scenes with large scale, fine details and reflective surfaces as we see in Fig. 1.

In summary, we propose a novel algorithm that learns to seamlessly combine two radiance fields with a learnable weight field while exploiting the advantages of each representation. Our method produces high quality surfaces in both reflective and non-reflective regions.

## 2 Related Works

Multi-view stereo (MVS).Many traditional [39; 48] and learning-based [49; 16; 46; 45] MVS methods first estimate multi-view depth maps and then reconstruct the surface by fusing depth maps in a post-processing step. As the core step, depth estimation is mainly based on the photometric consistency assumption across multiple views. However, this assumption fails for glossy surfaces with reflections, and thus MVS methods cannot reconstruct them accurately.

Figure 1: Comparison of surface normals (top) and RGB renderings (bottom) on “garden spheres” . While the state-of-the-art methods Ref-NeRF , ENVIDR , and Neuralangelo  struggle to reconstruct reflective elements or fine geometric details, our method accurately models both, leading to high-quality mesh reconstructions of all parts of the scene. Best viewed when zoomed in.

NeRF.As a seminal method in view synthesis, NeRF  represents a scene as a continuous volumetric field with an MLP, with position and camera view direction as inputs, and renders an image using volumetric ray-tracing. Since NeRF is slow to train, some methods [30; 42; 8] use voxel-grid-like data structures to accelerate training. Many follow-up works apply NeRFs to different tasks, _e.g._, sparse-view synthesis [54; 31; 43], real-time rendering [9; 34; 18; 53], 3D generation [33; 23; 7] and pose estimation [24; 41; 59]. For the 3D reconstruction task, there are many methods [32; 50; 47; 55; 13; 21; 37; 26; 35] integrating NeRF with signed distance functions, a common implicit function for geometry. Specifically, they transform SDFs back to volume density for volume rendering. However, we observe that they are unable to reconstruct shiny / reflective surfaces since NeRF's camera view direction parameterization for the color prediction does not accurately model reflective parts of the scene.

NeRFs for reflections.To render reflective appearance, [40; 5; 57; 58] extend NeRF and decompose a scene into physical components with strong simplifying assumptions, _e.g._, known lighting  or no self-occlusion [5; 57]. Recently, Ref-NeRF  reparameterizes the appearance prediction with separate diffuse and reflective components by using the reflected view direction, which improves the rendering of specular surfaces. As a result, recent works [51; 22; 25; 14; 27] adopt this representation to reconstruct glossy surfaces. While leading to strong view-synthesis for reflections, we find that reflected view radiance field approaches often lead to overly smooth reconstructions with missing details and that their optimization is not stable on real-world scenes. In contrast to existing methods with a single radiance field, we propose to seamlessly combine reflected view and camera view radiance fields into a novel unified radiance field with learnable weight, which is robust for reconstruction in challenging scenes with reflective surfaces. The recent preprint Factored-NeuS  also uses camera view and reflected view radiance fields. It separately supervises the rendered colors of two radiance fields with ground-truth color, instead of learning a weight field to combine them like ours. We find that our approach to combine two radiance fields with learnable weight is simpler to train and leads to better reconstruction. Other recent methods [17; 56; 52] use weight to compose the colors from camera view radiance field(s) to render reflections, similarly to us. [17; 56] can only handle planar reflections, _e.g._, mirrors, and require ground-truth masks of reflective objects to supervise the weight. In contrast, our method can handle non-planar reflective objects, _e.g._, spheres. As we learn the weight to compose camera view and reflected view radiance fields _without supervision_, our method does not require additional input and can be trained from only RGB images. MS-NeRF  uses multiple volume density fields and how to reconstruct the underlying surface is undefined. In contrast, we use a single SDF field to represent geometry and can hence directly extract the iso-surface from it.

## 3 Method

In this section, we first review the basic elements of NeRF . We then describe the architecture and training strategy of our method.

### NeRF Preliminaries

In NeRF , a 3D scene is represented by mapping a position \(\) and ray direction \(\) to a volumetric density \(\) and color \(\) using MLP. For a pixel in the target viewpoint and its corresponding ray \(=+t\), distance values \(t_{i}\) are sampled along the ray. The density \(_{i}\) is predicted by a spatial MLP that receives the position \(\) as input, while the directional MLP that predicts the color \(_{i}\) uses the bottleneck vector \(()\) from the density MLP and the view direction \(\) as input. The final color \(\) is rendered as:

\[=_{i}w_{i}_{i},w_{i}=T_{i}_{i},\] (1)

where \(_{i}=1-(-_{i}_{i})\) is opacity, \(_{i}=t_{i}-t_{i-1}\) is the distance between adjacent samples, and \(T_{i}=_{j=1}^{i-1}(1-_{j})\) is the accumulated transmittance. The model is trained by minimizing the loss between the predicted and ground truth color:

\[_{}=[(||-_{gt}||^{2}].\] (2)

Note that Mildenhall _et al._ use a single-layer directional MLP and thus often describe the combination of NeRF's spatial and view dependence MLPs as a single MLP.

### UniSDF

Given a set of known images of a scene that potentially contains reflective surfaces, our goal is to optimize a neural implicit field and reconstruct the scene with high fidelity and geometric accuracy. We propose UniSDF, a method that enables us to seamlessly combine camera view radiance fields and reflected view radiance fields to reconstruct both (a) non-reflective surfaces, diffuse reflective surfaces and complex surfaces with both reflective and non-reflective areas as well as (b) highly specular surfaces with a well defined and detailed reflected environment. Our pipeline is shown in Fig. 2. We generate two radiance fields that are parameterized by camera view directions or reflected view directions and combine them at the pixel level using a learned rendered weight.

Volume rendering the SDF.We represent the scene geometry using a signed distance field (SDF), which defines the surface \(\) as the zero level set of SDF \(d\):

\[=\{:d()=0\}.\] (3)

To better reconstruct large-scale scenes, we follow Mip-NeRF 360  and transform \(\) into a _contracted space_ with the following contraction:

\[()=&|||| 1\\ (2-||})(}{|||| })&||||>1\] (4)

For volume rendering, we compute the volume density \(()\) from the signed distance \(d()\) as: \(()=_{}(d())\), where \(_{}\) is the cumulative distribution function of a zero-mean Laplace distribution with learnable scale parameter \(>0\). The surface normal at \(\) can be computed as the gradient of the signed distance field: \(= d()/|| d()||\).

Hash Encoding with iNGP.To accelerate training and improve reconstruction of high-frequency details, we use iNGP  to map each position \(\) to a higher-dimensional feature space. Specifically, the features \(\{_{l}()\}\) from the pyramid levels of iNGP are extracted with trilinear interpolation and then concatenated to form one single feature vector \(()\), which is passed to the SDF MLP.

Camera View & Reflected View Radiance Fields.In contrast to most existing methods [28; 2; 44] that use a single radiance field, we propose to combine a camera view radiance field and a reflected view radiance field to better represent reflective and non reflective surfaces.

We follow NeRF  for representing our camera view radiance field \(_{cam}\), which is computed from features defined at each position and the camera view direction:

\[_{cam}=f_{cam}(,,,),\] (5)

Figure 2: Pipeline of UniSDF. We combine the camera view radiance field and reflected view radiance field in 3D. Given a position \(\), we extract iNGP features \(\) and input them to an MLP \(f\) that estimates a signed distance value \(d\) used to compute the NeRF density. We parametrize the camera view and reflected view radiance fields with two different MLPs \(f_{cam}\) and \(f_{ref}\) respectively. Finally, we learn a continuous weight field that is used to compute the final color as a weighted composite \(\) of the radiance fields colors \(_{cam}\) and \(_{ref}\) after volume rendering, Eq. 8.

where \(\) is the bottleneck feature vector from SDF MLP, \(\) is the normal at \(\) and \(\) is the camera view direction. Similarly to recent works [50; 47], we notice that using surface normals as input leads to better quality.

We represent the reflected radiance field \(_{ref}\) with an MLP \(f_{ref}\) as:

\[_{ref}=f_{ref}(,_{r},,),\] (6)

where \(_{r}\) is the reflected view direction around the normal \(\). In Ref-NeRF , it is shown that for BRDFs under a limited set of conditions, view-dependent radiance is a function of \(_{r}\) only. Unlike Ref-NeRF, which uses separate diffuse and specular components, we only use the specular component, leading to a simpler architecture. Additionally, we observe that using separate diffuse and specular components can lead to optimization instabilities resulting in geometry artifacts (see supp. mat. for details).

The main difference between two radiance fields is the view directional input of the MLP. As shown in Fig. 3, our method mainly uses the reflected view radiance field to represent highly specular reflections such as the tree reflections in the garden spheres or the environment reflection on the sedan car. The camera view radiance field is used to represent more diffuse reflections.

Learned composition.We compose two radiance fields using a learnable weight field in 3D. Specifically, we use an MLP \(f_{w}\) to learn the weight values \(\):

\[=(f_{w}(,,) ).\] (7)

We compose the signals at the pixel level. We first volume render \(\), \(_{ref}\), \(_{cam}\) following Eq. 1. We then compose the colors for each pixel as follows:

\[=_{ref}+(1-)_{cam}.\] (8)

In Fig. 3, the weight \(\) detects reflections well and assigns high weight to reflected view radiance field in reflective regions. The surface normals show that our model accurately reconstructs both reflective and non-reflective surface geometry.

Motivation of composing radiance fields.Disambiguating the influence of geometry, color and reflection is an ill-posed problem in 3D reconstruction from images. NeRF-based methods [47; 50; 21] with camera view radiance field show their robustness in real-world scenes , while having difficulty with reflections [44; 14]. Ref-NeRF based methods [25; 14; 51] with reflected view radiance field usually perform well under restricted conditions, \(e\)._g_., highly specular objects , while we experimentally find their performance degrades in real-world scenes, \(e\)._g_., NeRO  and Ref-NeuS  on DTU  (Tab. 1), BakedSDF  on Mip-NeRF 360 dataset  (Fig. 4). Therefore, to extend theoretically justified Ref-NeRF representation with robust scene representations,

Figure 3: Visualization of the color of reflected view radiance field, color of camera view radiance field, learned weight \(\), composed color and surface normal on “sedan” and “garden spheres” scenes . Our method assigns high weight (red color) for reflective surfaces, \(e\)._g_., window and hood of sedan, spheres, without any supervision.

we propose to exploit the advantages of two radiance fields by combining them with learnable weight. Moreover, since each type of radiance field is specialized for different levels of reflection strength and complexity, we observe that the reconstructed geometries while using the two types of radiance are often complementary (Fig. 5). In our method, we explicitly intertwine the radiance fields in 3D to continuously determine and use the most adapted parametrization for each surface area.

### Training and Regularization

Coarse-to-fine training.We observe that directly optimizing all the features in our multi-resolution hash grid leads to overfitting of training images, in particular to specular appearance details, which in turn results in incorrect geometry as we show in Fig. 7 (a). We observe that this model tends to fake specular effects by embedding emitters inside the surface exploiting the numerous learnable features in the hash grid. Therefore, we propose to instead optimize the hash grid features in a coarse-to-fine fashion, similarly to [21; 37], to avoid overfitting and promote smoother and more realistic surfaces. Specifically, we start with \(L_{}\) coarse pyramid levels in the beginning of training, and introduce a new level with higher resolution every \(T_{0}\) training fraction (see implementation details in Sec. 4.1).

Regularization.Following prior works [50; 47], we use an eikonal loss  to encourage \(d()\) to approximate a valid SDF:

\[_{}=_{}[(|| d()||-1) ^{2}].\] (9)

To promote normal smoothness, we constrain the computed surface normal \(\) to be close to a predicted normal vector \(^{}\). \(^{}\) is predicted by the SDF MLP and normalized. We use the normal smoothness loss \(_{}\) as:

\[_{}=_{i}w_{i}||-^{}||^{2}.\] (10)

We also use the orientation loss \(_{}\) from Ref-NeRF  to penalize normals that are "back-facing", using:

\[_{}=_{i}w_{i}(0,)^{2}.\] (11)

Full loss function.The full loss function \(\) includes the color loss \(_{}\) of composed color \(\) and the regularizations, which is written as follows:

\[=_{}+_{1}_{}+ _{2}_{}+_{3}_{}.\] (12)

## 4 Experiments

### Experimental Settings

Datasets.We extensively evaluate our method on four different types of datasets. The DTU dataset  is an indoor object-centric dataset with ground truth point clouds. Following prior works [50; 47], we use the same 15 scenes for evaluation. The Shiny Blender dataset  contains six different shiny objects that are rendered in Blender under conditions similar to the NeRF dataset. The Mip-NeRF 360 dataset is proposed in  and contains complex unbounded indoor and outdoor scenes captured from many viewing angles. We further evaluate on the three large-scale scenes with reflections that are introduced in Ref-NeRF , which consists of the scenes "sedan", "garden spheres" and "toycar". For simplicity, we name these 3 scenes the "Ref-NeRF real dataset".

Implementation details.Based on the Mip-NeRF 360 codebase , we implement our method in Jax  with the re-implementation of VolSDF  and iNGP . In our iNGP hierarchy of grids and hashes, we use 15 levels from 32 to 4096, where each level has 4 channels. For coarse to fine training, we set \(L_{}=4\) and \(T_{0}=2\%\). Similar to mip-NeRF 360 , we use two rounds of proposal sampling and then a final NeRF sampling round. Following Zip-NeRF, we penalize the sum of the mean of squared grid/hash values at each pyramid level with a loss multiplier as 0.1. Our models are all trained on 8 NVIDIA Tesla V100-SXM2-16GB GPUs with a batch size of \(2^{14}\). We train 25k steps on DTU / Shiny Blender and 100k steps on Mip-NeRF 360 / Ref-NeRF real datasets, which takes 0.75h and 3.50h respectively. See the supplement for more details.

Baselines.We compare our method to state-of-the-art volumetric implicit methods in surface reconstruction  and view synthesis . Neuralangelo  and Zip-NeRF  are hash grid-based state-of-the-art methods for reconstruction and view synthesis, respectively. Tailored for handling reflections,  are top performing methods for reconstructing and rendering objects with reflective surfaces. BakedSDF  is a top performing method for reconstructing high quality mesh of unbounded scenes with reflective surfaces.

To further evaluate the effectiveness of our method, we propose two custom baselines, named "CamV" and "RefV". Using the same backbone as our method, "CamV" uses only the camera view radiance field, while "RefV" uses only the reflected view radiance field following Ref-NeRF . Note that for both baselines, we also use our coarse-to-fine training strategy to improve performance.

### Evaluation Results

Dttu.We evaluate the reconstruction quality on DTU dataset . Following prior works, we extract the mesh at 512 resolution. For Neuralangelo , we report the reproduced results from the official implementation. As shown in Tab. 1, Geo-NeuS  performs best on DTU and our method outperforms the remaining methods. Geo-NeuS heavily relies on supervision from accurate SfM point cloud and photometric consistency constraint to achieve top performance, while our method uses rendering loss only like Neuralangelo . For reflective regions, the SfM reconstruction is inaccurate for supervision  and the multi-view photometric consistency is not guaranteed. We show that Geo-NeuS performs worse on Shiny Blender  in Tab. 2. Besides, we observe that NERO  and Ref-NeuS  perform worse than their baseline NeuS . Though these methods perform well on objects with strong reflections, _e.g._, Shiny Blender , they are not robust in general real-world scenes without strong reflections.

Shiny Blender.We summarize the rendering metrics, mean angular error (MAE) of normals and _accuracy_ (Acc) of mesh in Tab. 2. Our method performs best in PSNR and on par with ENVIDR  in SSIM, LPIPS and MAE. Note that ENVIDR additionally uses an environment MLP, which we do not require, to improve rendering and reconstruction. Besides, we find ENVIDR unrobust in real-world scenes with geometry artifacts on both reflective and non-reflective surfaces, shown in Fig. 1. For mesh quality, our method performs on par with Ref-NeuS  in Acc, while performing much better than it on DTU  (Tab. 1). This demonstrates the roubustness of our method in various types of scenes. Moreover, our method explicitly outperforms Geo-NeuS , Neuralangelo  and Zip-NeRF  in all metrics.

   Methods & NeuS  & NeuralWarp  & Geo-NeuS  & Neuralangelo  \\  C.D. (mm) \(\) & 0.87 & 0.68 & 0.51 & 1.07 \\   Methods & NERO  & Ref-NeuS  & Factored-NeuS\(\) & Ours \\  C.D. (mm) \(\) & 1.04 & 1.93 & 0.77 & 0.64 \\   

Table 1: Quantitative results of Chamfer Distance (C.D.) on DTU . Red, orange and yellow indicate the first, second and third best methods. \(\): Factored-NeuS  does not provide result for scan 69. Its result is the average error of the other 14 scenes.

    &  &  &  &  \\   & PSNR \(\) & SSIM \(\) & LPIPS \(\) & MAE\({}^{*}\) & Acc\({}^{+}\) & PSNR \(\) & SSIM \(\) & LPIPS \(\) & PSNR \(\) & SSIM \(\) & LPIPS \(\) \\  Zip-NeRF  & 25.93 & 0.939 & 0.122 & - & - & 27.69 & 0.791 & 0.237 & 24.27 & 0.600 & 0.276 & 25.82 & 0.793 & 0.212 \\ Zip-NeRF  & 29.24 & 0.942 & 0.112 & - & - & **28.53** & 0.828 & 0.930 & 23.68 & 0.635 & 0.247 & 27.15 & 0.820 & 0.183 \\ Geo-NeuS  & 28.78 & 0.945 & 0.085 & 10.52 & - & 1.63 & - & - & - & - & - & - & - & - \\ Neuralangelo  & 30.68 & 0.949 & 0.095 & 14.16 & 1.81 & 25.08 & 0.699 & 0.332 & 23.70 & 0.608 & 0.330 & 26.49 & 0.752 & 0.252 \\  Ref-NeRF  & 35.96 & 0.967 & 0.058 & 18.38 & - & - & - & - & - & 24.06 & 0.589 & 0.355 & - & - & - \\ ENVIDR  & 35.85 & 0.938 & 0.008 & 46.1 & - & - & - & - & - & - & - & - & - & - \\ NeRD  & 29.84 & 0.962 & 0.072 & - & - & - & - & - & - & - & - & - & - \\ Ref-NeuS  & 27.40 & 0.951 & 0.073 & 5.34 & 0.98 & - & - & - & - & - & - & - & - \\ Factored-NeuS  & 30.89 & 0.954 & 0.076 & 5.31 & 1.90 & - & - & - & - & - & - & - & - \\ BakedSDF  & 25.60 & 0.943 & 0.090 & - & - & 26.42 & 0.738 & 0.314 & 0.836 & 0.325 & 25.48 & 0.772 & 0.243 \\ Ours & **96.82** & 0.976 & 0.043 & 4.76 & 1.06 & 27.67 & 0.808 & 0.128 & 23.70 & 0.856 & 0.265 & **29.40** & **0.807** & **0.174** \\   

Table 2: Quantitative results on Shiny Blender , Mip-NeRF 360 dataset  and Ref-NeRF real dataset . ‘Mean’ represents the _average_ rendering metrics on all datasets. Red, orange, and yellow indicate the first, second, and third best methods for each metric. *: We follow Ref-NeuS  and evaluate _accuracy_ of mesh on four scenes (car, helmet, toaster, coffee). See supp. mat. for details.

Mip-NeRF 360 dataset.As shown in Tab. 2, our method performs on par with Zip-NeRF  in rendering. Note that Zip-NeRF focuses on view synthesis, while we focus on surface reconstruction. Compared with BakedSDF  and Neuralangelo , our performance is much better in all metrics. As shown in Fig. 4, our method reconstructs more complete surfaces and better details, while BakedSDF shows hole artifacts and struggles to reconstruct fine geometric details.

Ref-NeRF real dataset.As shown in Tab. 2, evaluation on this dataset is challenging for all methods. Our method outperforms Ref-NeRF  and Neuralangelo  in SSIM and LPIPS, Zip-NeRF  in PSNR and SSIM, and BakedSDF  in LPIPS. For surface reconstruction, Neuralangelo  cannot reconstruct reflective spheres well as shown in Fig. 1, while our method accurately reconstructs the smooth surface of the reflective spheres and the fine details on the statue.

Summary of evaluation.The four datasets that we evaluate on include various scene types, ranging from object-level to unbounded scenes, with and without reflections. While some methods perform best on specific datasets, _e.g_., Geo-NeuS  on DTU and Zip-NeRF  on Dip-NeRF 360 dataset , we show their performance degrades on other types of datasets, _e.g_., Shiny Blender . In contrast, our method shows competitive performance on all datasets and performs best overall (see averaged metrics in Tab. 2). This demonstrates the robustness of our method to various scene types.

Custom baselines comparison.We compare our method with our two custom baselines, CamV and RefV, on the DTU , Mip-NeRF 360 , and Ref-NeRF real  datasets. As shown in Tab. 3, our method outperforms the two baselines in all metrics on all three datasets. Besides, CamV mostly outperforms RefV, while RefV fails on one scene in DTU. This shows that the camera view radiance field is usually more robust than the reflected view radiance field, although this method does not reconstruct the geometry of reflective regions well.

Fig. 5 shows a qualitative comparison, where RefV reconstructs smooth surface for the reflective back window but has artifacts on the side for "sedan", while CamV fails to reconstruct accurate surfaces because of the reflections. On the "toycar" scene, RefV fails to reconstruct the correct geometry, while CamV reconstructs shiny surfaces better while showing artifacts on the hood. For RefV, we sometimes observe optimization issues with separate diffuse and specular components, where the specular component may be blank throughout training and the diffuse component (w./o. directional input) wrongly represents the view-dependent appearance with incorrect geometry (see supp. mat. for details). By coupling two difference radiance fields continuously in 3D, our method represents the appearance and geometry better than the baselines that only use a single radiance field, leading to higher-quality reconstructed surfaces.

    &  &  &  \\   & C.D. (mm) \(\) & PSNR \(\) & SSIM \(\) & LPIPS \(\) & PSNR \(\) & SSIM \(\) & LPIPS \(\) \\  CamV & 0.85 & 27.26 & 0.800 & 0.225 & 23.30 & 0.622 & 0.283 \\ RefV & 0.89* & 26.74 & 0.794 & 0.223 & 23.02 & 0.615 & 0.301 \\ Ours & **0.64** & **27.67** & **0.808** & **0.213** & **23.70** & **0.636** & **0.265** \\   

Table 3: Quantitative comparison with two custom baselines. Best results are in bold. *: RefV fails on scan 110 of DTU , the reported chamfer distance (C.D.) is the average of other 14 scenes.

Figure 4: Qualitative comparison with BakedSDF  on “bicycle” and “officebonsai” scenes of Mip-NeRF 360 dataset . BakedSDF produces hole structures in many regions (highlighted with dotted orange boxes) and less details of fine structures (highlighted with red boxes), while our method reconstructs more complete surfaces and better details. Best viewed when zoomed in.

Mesh visualization.In Fig. 6, we visualize our meshes on Shiny Blender  and Mip-NeRF 360 dataset . Our method can accurately reconstruct the surfaces of reflective objects as well as large-scale scenes with fine geometric details.

### Ablation Study

Coarse-to-fine training.As shown in Fig. 7 (a), the reconstructions of "sedan"  contain artifacts on the specular window and hood without training in a coarse-to-fine manner. With all feature pyramid grids activated in the beginning, the hash grid backbone can easily overfit to the specular effects with wrong geometry.

Unification of radiance fields.In Tab. 3, we show that composing two radiance fields can consistently improve performance. In this ablation, we justify the effectiveness of unification with learnable weights. Since the main difference of two radiance fields is the view directional input, we design a baseline with a single radiance field that takes both camera view \(\) and reflected view \(_{r}\) as inputs. Structurally, this baseline has the same input information as our radiance fields and weight field. As shown in Fig. 7 (b), our method performs better in reconstruction, while the baseline cannot reconstruct reflective surfaces well on both scenes.

## 5 Conclusion

In this paper, we have presented UniSDF, a novel algorithm that learns to seamlessly combine radiance fields for robust and accurate reconstruction of complex scenes with reflections. We find that camera

Figure 5: Qualitative comparison of surface normals with two baselines, RefV and CamV on “sedan” and “toycar” scenes . Best viewed when zoomed in.

Figure 6: Visualization of our meshes. Best viewed when zoomed in.

Figure 7: Ablation study of our method. Best viewed when zoomed in.

view radiance fields, \(e\)._g_., NeRF, are robust to complex real settings but cannot reconstruct reflective surfaces well, while reflected view radiance fields, \(e\)._g_., Ref-NeRF, can effectively reconstruct highly specular surfaces but struggle in real-world settings and to represent other types of surfaces. By adaptively combining camera view and reflected view radiance fields with a learnable weight field, our method significantly outperforms the baselines with either single radiance field. Together with a hash grid backbone to accelerate training and improve reconstruction details, our method performs superior to or on par with state-of-the-art methods, tailored for handling reflections or not, in reconstruction and rendering on different types of scenes, ranging from object-level to unbounded scenes, with and without reflections.

Acknowledgement.We would like to thank Dor Verbin, Peter Hedman, Ben Mildenhall and Pratul P. Srinivasan for feedback and comments.