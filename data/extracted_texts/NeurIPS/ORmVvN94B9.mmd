# Rigorous Runtime Analysis of MOEA/D for Solving Multi-Objective Minimum Weight Base Problems

Anh Viet Do

Optimisation and Logistics

The University of Adelaide, Australia

&Aneta Neumann

Optimisation and Logistics

The University of Adelaide, Australia

&Frank Neumann

Optimisation and Logistics

The University of Adelaide, Australia

&Andrew M. Sutton

Department of Computer Science

University of Minnesota Duluth, USA

###### Abstract

We study the multi-objective minimum weight base problem, an abstraction of classical NP-hard combinatorial problems such as the multi-objective minimum spanning tree problem. We prove some important properties of the convex hull of the non-dominated front, such as its approximation quality and an upper bound on the number of extreme points. Using these properties, we give the first run-time analysis of the MOEA/D algorithm for this problem, an evolutionary algorithm that effectively optimizes by decomposing the objectives into single-objective components. We show that the MOEA/D, given an appropriate decomposition setting, finds all extreme points within expected fixed-parameter polynomial time, in the oracle model. Experiments are conducted on random bi-objective minimum spanning tree instances, and the results agree with our theoretical findings. Furthermore, compared with a previously studied evolutionary algorithm for the problem GSEMO, MOEA/D finds all extreme points much faster across all instances.

## 1 Introduction

Evolutionary algorithms have been widely used to tackle multi-objective optimization problems in many areas such as robotics, pattern recognition, data mining, bioinformatics, scheduling and planning, and neural network training . Their population-based search operators make them a natural choice for simultaneously handling several possibly conflicting objectives. Many generic evolutionary multi-objective frameworks have been developed to supply basic implementations for any problem, and to provide templates that can be fine-tuned for specific applications (we refer to  for an overview of common approaches). Such features, along with their strong empirical performances in challenging applications, have led them to becoming one of the most attractive topics to researchers and practitioners alike.

Among evolutionary multi-objective algorithms (EMOs), arguably the most exemplary are dominance-based approaches such as GSEMO and NSGA variants, with the former often being considered a baseline. Another popular technique for multi-objective optimization is to decompose the multiple objectives into a single-objective subproblem. The MOEA/D algorithm is a state-of-the-art application of this technique in evolutionary computation .

Despite the prevalence of EMOs on practical applications, rigorous analyses of their runtime behavior on meaningful problems are scarce. Nevertheless, these kinds of analyses are critical for (1) providing performance guarantees and guidelines to practitioners who use and develop these techniques in the field, and (2) promoting the explainability of heuristic search and optimization techniques byclarifying their working principles through a careful mathematical analysis. Run-time analyses on the performance of evolutionary algorithms have been provided for simple algorithms such as GSEMO in both artificial benchmark problems [2; 7] and others such as bi-objective minimum spanning tree [18; 28] and constrained submodular optimization [21; 22; 5; 23]. In recent years, theoretical analyses of state of the art approaches such as NSGA-II and MOEA/D have been conducted [12; 14; 13; 34; 6]. However, these run-time results have only been given for artificial benchmark problems.

In this paper, we present for the first time rigorous results on MOEA/D for a classical multi-objective optimization problem, namely the multi-objective minimum weight base problem. This problem, falling under the matroid optimization category, significantly generalizes the previously studied bi-objective minimum spanning tree problem. In this work, we focus on approximating the non-dominated front, as its size can be exponential in the problem size. In particular, we show that MOEA/D obtains a factor 2-approximation for two objectives in expected polynomial time. Previous analyses for the special case of graphic matroid (i.e. spanning forests) were only able to show a pseudo-polynomial run-time for GSEMO and NSGA-II to obtain this approximation [18; 4]. We further extend the analyses by deriving a fixed-parameter polynomial expected run-time in instances with \(k 2\) objectives to reach a \(k\)-approximation. That is, unlike the previous runtime bounds, ours is both polynomial and weight-free under fixed \(k\) in light of the findings by Rechel et. al. .

Instrumental to our analyses is a deeper understanding of the problem, and as such, we formally examine certain properties of the multi-objective minimum weight base problem. We first prove a tight approximation guarantee from computing the convex hull of the non-dominated front, extending the known guarantee for two objectives . With this in mind, we explore insight regarding this convex hull, including its vertex complexity and the structural relation among solutions whose weights constitute said convex hull. In addition, we briefly formulate an efficient deterministic approach to enumerate extreme points, which achieves a smaller approximation factor in lower (and weight-free) runtime than a recently proposed framework for general multi-objective minimization instances . These findings may be of interest in areas beyond runtime analysis.

## 2 Preliminaries & Problem

First, we give an overview of relevant matroid theory concepts, with terminologies adopted from the well-known text book  on the subject.

**Definition 1**.: _A tuple \(M=(E, 2^{E})\) is a matroid if \(a)\), \(b) x y E,y x\), \(c)\)\( x,y,|x|<|y| e y x,x\{e\} \). The set \(E\) is the ground set, and \(\) is the independence collection. \(A\) base of \(M\) is a maximal set in \(\)._

**Definition 2**.: _Given a matroid \(M=(E,)\), its rank function, \(r:2^{E}\), is defined as \(r(x)=\{|y|:y 2^{x}\}\), and the rank of \(M\) is \(r(E)\). A matroid is completely characterized by its rank function._

To give examples, a \(K\)-rank uniform matroid over \(E\) admits the independence collection \(=\{x E:|x| K\}\), characterizing a cardinality constraint. In linear algebra, a representable matroid describes linear independence among a vector set. In graph theory, given an undirected graph \(G=(V,E)\), a graphic matroid \(M=(E,)\) defined by \(G\) is such that \(\) contains all edge sets \(x\) forming a forest subgraph in \(G\). A base of a graphic matroid is a spanning forest, which itself is an object of much interest. Dual to the graphic matroid, the bond matroid \(M^{*}=(E,^{*})\) is such that \(^{*}\) contains all edge sets \(x\) whose removal from \(E\) preserves every pairwise connectivity in \(G\). The matroid properties emerge in many combinatorial structures of various optimization problems .

A classical application of matroids in optimization is in the minimum weight base (MWB) problem. Given a weighted matroid \((E,r,w)\), this problem asks to find a base in this matroid minimizing \(w\). The most arguably well-known special case of MWB problem is the minimum spanning tree (MST) problem. It is known that the classical Greedy algorithm minimizes (and maximizes) arbitrary weight over a base collection of any matroid [24; 9; 8]. From the exchange property between independent sets (specifically the symmetric-exchange property proven in ), we see that Greedy can also enumerate all minimum weight bases, thus characterizes the optimality of any MWB instance. A proof of this quality is also included in .

The multi-objective minimum weight base (MOMWB) is a natural multi-objective extension to MWB. Given a \(k\)-weighted1 matroid \((E,r,w(^{*})^{k|E|})\) where \(E\) is the ground set, \(r\) is the rank function of the matroid, and the weight vector of a solution \(x\{0,1\}^{|E|}\) is \(wx\) (also called the image of \(x\) under \(w\)), the multi-objective problem asks to find a non-dominated set of bases in \((E,r)\) minimizing \(w\). Here, \(k\) is the number of objectives.

We denote \(m:=|E|\), \(n:=r(E)\), and observe that \(x\) is a base in \((E,r)\) implies \(|x|=n\). Given an objective vector function \(f\) and solutions \(x\) and \(y\), \(x\) dominates \(y\), denoted with \(x_{f}y\), iff \(f(y)-f(x)^{k}_{ 0}\). We see that \(x_{f}y\) iff \(_{^{k}}^{}(f(y)-f(x)) 0\), i.e. \(y\) has greater scalarized objective value than \(x\) across all linear trade-offs. We denote the set of images of non-dominated solutions with \(F\), and vertices of its convex hull \((F)\) are called _extreme points_. For convenience, let \((F)\) contain only points in \(F\) and that its faces be conventionally defined, i.e. as continuous Euclidean subspaces.

Since \(F\) can be exponentially large, we consider instead approximating it by finding solutions mapped to \((F)\). Such a set is known to guarantee a 2-approximation of the non-dominated set for \(k=2\) under the following definition.

**Definition 3** (Minimization).: _Given \(k\) non-negative objective functions \(f:=(f_{i})_{i=1}^{k}\), a solution \(x\)\(c\)-approximates a solution \(y\) for some \(c 0\) if \(cf(y)-f(x)^{k}_{ 0}\). A solution set \(X\)\(c\)-approximates (or is a \(c\)-approximation of) a solution set \(Y\) if every \(y Y\) is \(c\)-approximated by at least a \(x X\)._

We formally describe categories of solutions of interest. Here, we only consider feasible solutions, e.g. bases in a MWB or MOMWB instance. Furthermore, a subset of \(E\) is characterized by a bit-string in \(\{0,1\}^{|E|}\), so both set and bit operations on solutions are well-defined, and we use both representations throughout the paper.

**Definition 4**.: _A solution \(x\) is a supported solution to an instance with objective functions \(f=(f_{i})_{i=1}^{k}\) and a solution set \(S\) if there is a linear trade-off \(^{k}\{0\}\) where \(x*{argmin}_{y S}^{}f(y)\). A trade-off set \(\) is complete if \(_{x}*{argmin}_{y S}^{}f(y)\) contains all supported solutions. A supported solution \(z\) is extreme if there is \(^{}^{k}\) where for all \(x*{argmin}_{y S}^{}f(y)\), \(f(z)=f(x)\). A set containing a trade-off for each extreme solution is called sufficient._

Note we assume that every instance admits a solution minimizing \(^{}f\) for every \(^{k}\). Of course, this holds for MOMWB due to the solution set being finite. We see that supported solutions are precisely the solutions whose images lie on \((F)\). Intuitively, a complete trade-off set decomposes the multi-objective instance in such a way to allow enumerating all supported solutions via exactly solving scalarized instances. Since supported solutions that are not extreme are mapped to points on the faces of \((F)\), we have the following observation.

**Observation 1**.: _For each supported solution minimizing \(^{}f\), there is an extreme solution minimizing \(^{}f\). For every \(^{k}\), there is an extreme solution minimizing \(^{}f\)._

However, for linear functions, the number of supported solutions can be very large, so we also consider finding a representative subset which, as we will see, is sufficient to give an approximation guarantee.

**Definition 5**.: _A solution set \(X\) is sufficient to an instance with objective functions \(f\) if for every extreme solution \(y\), there is \(x X\) where \(f(x)=f(y)\). The analogy for supported solutions is called a complete solution set._

With this definition, the set of solutions that are mapped to the extreme points is sufficient. In fact, the size of a minimal sufficient set is exactly the number of extreme points. Note that while the set of all supported solutions is unique, there can be multiple distinct minimal sufficient sets due to duplicate images. We briefly prove an approximation factor by any sufficient set, which is not restricted to MOMWB.

**Theorem 1** (Minimization).: _Given \(k 1\) and a non-negative \(k\)-objective instance where for each objective \(i\) there is \(_{i}>0\) so that \(f_{i}(x)(0,_{i}]\) for all solutions \(x\), every sufficient solution set \(P\)\(k\)-approximates all solutions. This factor is tight for all \(k\), even if \(P\) is a complete solution set._We denote the weight scalarization with trade-off \(\) with \(^{()}:=^{}\), so \((E,r,^{()})\) is a scalarized instance at \(\). All proofs, including the one for the above result, are included in the Appendix.

## 3 Properties of Conv(\(F\)) in Multi-Objective Minimum Weight Base Problem

Here, we derive various properties of Conv(\(F\)) with implications on the complexity of approximating \(F\). Since these solutions are optima of linearly scalarized instances, we use the properties of the Greedy algorithm, known to guarantee and characterize optimality in linear optimization over a matroid.

The Greedy algorithm starts from an empty set and adds elements to it in increasing weight order while maintaining its independence, until a base is reached. In essence, Greedy operates on a permutation over \(E\) and produces a unique solution so we can characterize its outputs via permutations. We say a permutation \(\) over \(E\), \(:E\{1,,m\}\), _sorts_ the weight \(w\) if, for all \(i=1,,m-1\), \(w_{r^{-1}(i)} w_{r^{-1}(i+1)}\). As mentioned, Greedy run on a permutation that sorts the weight to be minimized returns a minimum weight base. More importantly, all minimum weight bases can be obtained by running Greedy on all sorting permutations. This allows us to derive properties of any solution mapped onto Conv(\(F\)) using Greedy's behaviors. In particular, we can circumvent the difficulty of examining weights by examining permutations instead, essentially looking at the weight-induced rankings rather than the weights themselves. As such, all results in this section are weight-free and hold for arbitrary real weights. We refer to  for a weight-dependent algorithmic treatment of Conv(\(F\)) under general settings.

**Observation 2**.: _A MOMWB instance defined over a ground set \(E\) satisfies the following: (1) its objective functions are linear, and (2) there is a surjective mapping from the set of permutations over \(E\) to the set of supported solutions._

To simplify analysis, we restrict the trade-off space to non-negative 1-norm unit vectors \(U=\{a^{k}:_{i=1}^{k}a_{i}=1\}\), let \(_{}\) be a permutation sorting \(^{()}\) for \( U\). For each \(i E\), let \(_{i}=(_{j,i})_{j=1}^{k}\), and for each pair \(i,j E\), let \(_{i,j}=_{i}-_{j}\) and \(_{i,j}=\{a U:_{i,j}^{}a=0\}\) be the \((k-2)\)-dimensional set characterized by the fact that for all \( U\), \(_{i}^{()}=_{j}^{()}\) iff \(_{i,j}\). Finally, let \(A\) be the multiset of non-empty \(_{i,j}\) where \(_{i,j} 0,H_{A}\) be the multiset of convex \((k-1)\)-polytopes in \(U\) defined by intersections of half-spaces bounded by hyperplanes in \(A\) and the boundary of \(U\), and \(A^{}\) be the set of points in \(U\) where each point lies in the interior of a polytope in \(H_{A}\), we show that \(A\) and \(A^{}\) encompass complete solution set and sufficient solution set, respectively. Note that if \(_{i,j}=_{i}-_{j}=0\), the inclusion of either \(i\) or \(j\) in a solution does not change its image under \(\).2

**Lemma 1**.: _For any \(Q H_{A}\), the set of all bases minimizing \(^{()}\) remains constant for all \((Q)^{3}\), and these bases share an image under \(\). Furthermore, they also minimize \(^{()}\) for all \( Q\)._

This immediately gives the upper bound on the number of extreme points, which is the maximum number of space partitions by hyperplanes; the formula for this is given in . Note that Lemma 1 only requires properties in Observation 2, which hold for the broader class of set systems that is matroid embeddings since all minimum weight bases in such a system are exactly Greedy bases .

**Corollary 1**.: _The size of a minimal sufficient solution set to a \(k\)-objective instance satisfying properties in Observation 2 is at most \(_{i=1}^{k}\), and \(A^{}\) is a sufficient trade-off set._

We remark that we deliberately choose each trade-off in \(A^{}\) from the interior of each polytope. This is because if a zero trade-off coefficient is assigned to an objective, then bases minimizing the weight scalarized by such a trade-off may not be non-dominated. Furthermore, such scalarized weights admit optima whose images under \(\) are identical, which is necessary to ensure that the first optimum an optimization algorithm finds using these trade-offs is an extreme solution. Moreover, this trade-offselection scheme also guarantees that said algorithm does not discard vertices of \((F)\) over time, unless it stores all found optima.

Given a solution set \(S\), the \(l\)-Hamming neighborhood graph of \(S\) is an undirected graph \(G_{l}=(S,\{\{a,b\}:|a b| l\})\), and \(S\) is \(l\)-Hamming connected if \(G_{l}\) is connected. Neumann  proved for spanning trees that given the non-dominated front being strongly convex, the set of supported solutions is \(2\)-Hamming connected. We show that this even holds for matroid bases without the convexity assumption. For simplicity, we assume, for the rest of the analysis, fixed orderings among each class of elements \(i E\) sharing \(w_{i}\). We will see that the existence of such elements does not affect the \(2\)-Hamming connectivity among supported solutions.

We first show that as the trade-off moves continuously within \(U\), the permutation sorting the scalarized weight is transformed incrementally by exchanging two adjacent positions, which we call an adjacent swap.

**Lemma 2**.: _For any \(a,a^{} U\), let \(A^{*}=\{a_{i}\}_{i=1}^{h}\) be the multiset of intersections between the line segment connecting \(a\) and \(a^{}\) and hyperplanes in \(A\), indexed in the order from \(a\) to \(a^{}\), there is a shortest sequence of adjacent swaps from \(_{a}\) to \(_{a^{}}\), \((_{a},_{1},,_{h},_{a^{}})\), where for all \(i=1,,h\), \(_{i}\) sorts \(w^{(a_{i})}\). If \(w^{(a)}\) or \(w^{(a^{})}\) can be sorted by multiple permutations, the claim holds assuming that \(_{a}\) and \(_{a^{}}\) have maximum Kendall distance4._

Next, we show that an adjacent swap on the sorting permutation incurs an at most \(2\)-bit change in the minimum weight base.

**Lemma 3**.: _Let \(\) and \(^{}\) be permutations over \(E\) that are one adjacent swap apart, and \(x\) and \(x^{}\) are Greedy solutions on them, respectively, then \(|x x^{}| 2\). Furthermore, let \(u,v E\) where \((v)=(u)+1\) and \(^{}(v)=^{}(u)-1\), \(|x x^{}|=2\) iff \(x^{}=x\{u\}\{v\}\)._

Lemma 2 and 3 indicate that there is a sequence of \(2\)-bit flips between any pair of supported solutions such that every step also gives a supported solution. Therefore, starting from a supported solution, we can compute the rest of \((F)\) with \(2\)-bit variations.

Regarding weight-sharing elements, for a supported solution \(x\) minimizing \(w^{()}\), if there is a class of equal-weight elements \(Z\) partially intersecting \(x\), then all supported solutions minimizing \(w^{()}\) containing different elements in \(Z\) can be reached from \(x\) by a sequence of \(2\)-bit flips, each step in which produces a supported solution also minimizing \(w^{()}\). This is because \(Z\) is located consecutively in \(_{}\) and can be arranged arbitrarily (leading to the Greedy solution minimizing \(w^{()}\)), and there is a sequence of adjacent swaps between any two such permutations touching only elements in \(Z\). Furthermore, if there are multiple such classes whose elements share a scalarized weight at some trade-off \(\), the relative inter-class orderings in any valid \(_{}\) can be shuffled arbitrarily with an adjacent swap sequence that neither, at any step, changes any pairwise intra-class ordering, nor breaks the sorting property. For these two reasons, the set of permutations sorting all scalarized weights is \(1\)-Kendall connected (Kendall-distance equivalence to Hamming connectivity), thus the relative intra-class orderings, and consequentially the presence of multiple elements within each such class, does not affect \(2\)-Hamming connectivity.

**Corollary 2**.: _Given solutions \(x\) and \(y\) where \(\{wx,wy\}(F)\), there is a non-empty set of solutions \(\{z_{i}\}_{i=1}^{h}\) where \(x=z_{1}\), \(y=z_{h}\), \(|z_{i} z_{i+1}|=2\) for all \(i=1,,h-1\) and \(\{wz_{i}\}_{i=1}^{h}(F)\)._

Lemma 3 also lets us derive a stronger bound on the number of distinct Greedy solutions as the trade-off moves in a straight line, giving an upper bound on the number of extreme points in case \(k=2\).

**Theorem 2**.: _Given \(n(0,m)\), \(a,b U\) and \(X\) is a minimal set of extreme solutions such that for each \(\), \(X\) contains a solution minimizing \(w^{((1-)a+ b)}\), \(|X| hm-h(h+1)/2+1\) where \(h:=-1}\)._

**Corollary 3**.: _A bi-objective MWB instance (i.e. \(k=2\)) admits at most \(O(m})\) extreme points._

We remark that aside from the trivial cases \(n\{1,m-1\}\), we did not find an instance where this bound is tight. As far as we are aware, it is an open question whether this bound is optimal.

``` Input: Multi-weighted matroid \((E,r,w)\) Output:\(S\), \(\)
1\(S,^{}\);
2\(\{e_{i}\}_{i=1}^{k}\);
3\(P\) all permutations over \(\{1,,k\}\);
4while\(^{}\)do
5for\(^{}\)do
6\( p P,a_{p}\) base minimizing \(w^{()}\) prioritizing weights ranked by \(p\);
7\(S S\{a_{p}\}_{p P}\);
8\(^{}^{}\);
9\(\) non-negative normal vectors to facets of \((\{wx:x S\})\); ```

**Algorithm 1**Finding extreme points and a complete trade-off set (adapted from )

``` Input: Bi-weighted matroid \((E,r,w_{1},w_{2})\) Output:\(S\), \(\)
1\(S,^{}\);
2\(\{0,1\}\);
3while\(^{}\)do
4for\(^{}\)do
5\(a,b\) bases minimizing \((1-)w_{1}+ w_{2}\) prioritizing \(w_{1}\) and \(w_{2}\), respectively;
6\(S S\{a,b\}\);
7\(^{}^{}\);
8\(\);
9\(\) element indexes of \(S\) in increasing \(w_{1}()\) order;
10for\(i\{1,,|S|-1\}\)do
11\(_{1},_{2} w_{1}S_{(i+1)}-w_{1}S_{(i)},w_{2}S_{(i) }-w_{2}S_{(i+1)}\);
12\(\{_{1}/(_{1}+_{2})\}\); ```

**Algorithm 2**Special case of Algorithm 1 for \(k=2\)

## 4 Exact Computation of Extreme Points

In this section, we describe a deterministic framework that finds a solution for each extreme point, as well as a complete trade-off set. This framework, modified from the algorithm proposed in  for bi-objective MST, is outlined in Algorithm 1. It calls another algorithm (e.g. Greedy) to find MWB to scalarized weights, and iteratively computes new extreme points based on information from previous ones. Intuitively, each subset of extreme points \(Z\) is such that its convex hull is "inside" \((F)\) and contains, for each extreme point \(y Z\), a facet separating \(Z\) from \(y\). This means \(y\) can be discovered by minimizing the weight scalarized along the normal direction of this facet, essentially expanding \((Z)\) to "touch" \(y\). This iterative process begins with an optimum in each objective, and ends when all new normal vectors are duplicates of ones found previously, indicating that the current convex hull cannot be expanded further and equals \((F)\). The special case of this algorithm for \(k=2\) is given in Algorithm 2 which treats trade-offs as scalars.

``` Input: Bi-weighted matroid \((E,r,w_{1},w_{2})\) Output:\(S\), \(\)
1\(S,^{}\);
2\(\{e_{i}\}_{i=1}^{k}\);
3\(P\) all permutations over \(\{1,,k\}\);
4while\(^{}\)do
5for\(^{}\)do
6\( p P,a_{p}\) base minimizing \(w^{()}\) prioritizing weights ranked by \(p\);
7\(S S\{a_{p}\}_{p P}\);
8\(^{}^{}\);
9\(\) non-negative normal vectors to facets of \((\{wx:x S\})\); ```

**Algorithm 3**Finding extreme points and a complete trade-off set (adapted from )

Algorithm 1, naively implemented, requires \(O(\#((k)+k!m m))\) operations and \(O(k!\#m)\) calls to the matroid rank oracle where \(\#\) is the number of extreme points. Each iteration in the main loop adds at least one extreme point, and redundant points are excluded from future iterations via \(^{}\). Here, we assume updating trade-off for each new vertex takes \((k)\) operations.

We remark that exhaustive tie-breaking over all objectives is done at line 6 to ensure that the computed points are the vertices of \((F)\) instead of interior points of its faces, and that all extreme points are accounted for when the termination criterion is met. Furthermore, if the trade-off assigns zero value to some objectives, this also guarantees that the resulted solutions are non-dominated. This subroutine can be improved by grouping together objectives whose sorting permutations agree (in relative orderings) among elements tied by \(w^{()}\).

## 5 MOEA/D With Weight Scalarization

Multi-Objective Evolutionary Algorithm based on Decomposition (MOEA/D), introduced in , is a co-evolutionary framework characterized by simultaneous optimization of single-objective subproblems in a multi-objective problem. While there are many approaches to decompose the multi-objective into single-objectives, we consider the classical approach that is weight scalarization , as hinted in preceding sections. This simple scheme is sufficient in approximating \(F\) and even enumerating \((F)\).

### Description

MOEA/D uses two fitness functions, a scalar function formulated by the decomposition scheme and a vector function for dominance checking . To account for the matroid base constraint, we use the penalty term formulated in , which was adapted from prior work on MST . Letting \(w_{max}:=_{(i,)\{1,,k\} E}w_{i,}\), we have the fitness \(f_{}\) of \(x\{0,1\}^{m}\) at trade-off \(\), and the fitness vector \(g\) for dominance checking where \(\) is the one vector.

\[f_{}(x):=m(n-r(x))w_{max}+w^{()}x, g(x):=m(n-r(x))w_{max} +wx\] (1)

The MOEA/D for the MOMWB problem is outlined in Algorithm 3. The fitness functions defined in Eq. (1) and the input trade-off set realize the decomposition, and the algorithm evolves a population for each scalarized subproblem with potential neighborhood-based collaboration. During the search, it maintains a non-dominated solution set \(S\), which does not influence the search and is returned as output. An optimum to each scalarized subproblem is a supported solution. Note in this formulation, MOEA/D keeps ties in each subproblem, allowing all found optima to participate in mutation operations. This is to avoid having to flip more than two bits to jump from a supported solution to an uncollected point in \((F)\). We will see that while this may increase the population size, it does not affect the run-time to reach optimality in each subproblem.

``` Input: A MOMWB instance, trade-off set \(\), neighborhood size \(N 1\) Output:\(S\)
1\(,B_{} N\) nearest neighbors of \(\) in \(\) (Euclidean distance);
2\(,P_{}\) a random sample from \(\{0,1\}^{m}\);
3\(S\);
4whilestopping conditions not metdo
5for\(\)do
6\(x\) uniformly sampled from \(P_{}\);
7\(y\) independent bit flips on \(x\) with probability \(1/m\);
8\(D\{l B_{}: z P_{l},f_{l}(y)<f_{l}(z)\}\);
9\(T\{l B_{}: z P_{l},f_{l}(y)=f_{l}(z)\}\);
10\( l D,P_{l}\{y\}\);
11\( l T,P_{l} P_{l}\{y\}\) removing solutions with duplicate images;
12\(S\) non-dominated individuals in \(S\{y\}\) under relation \(_{g}\); ```

**Algorithm 3**MOEA/D for MOMWB

### Expected Time To Minimize Scalarized Weights

In the following, we do not assume a particular value of \(N\), and the results hold for any \(N 1\). Furthermore, we exclude the trivial instances with \(n=m\) and \(n=0\), which admit exactly one base each.

**Lemma 4**.: _MOEA/D working on trade-off set \(\) finds a base's superset for each \(\) within \(O(||m n)\) expected search points._

Let \(OPT_{}\) be the optimal value to \((E,r,w^{()})\), we have the following drift argument proven in  for the standard bit mutation in the MWB problem.

**Lemma 5** (, Proposition 9).: _Given a trade-off \(\) and \(x\{0,1\}^{m}\), if \(x\) supersets a base, then there are \(n\) 2-bit flips and \(m-n\) 1-bit flips on \(x\) reducing \(f_{}(x)\) on average by \((f_{}(x)-OPT_{})/m\)We use the same ideas as the proof of Theorem 2 in , while sharpening an argument to derive a slightly tighter bound.

**Theorem 3**.: _MOEA/D working on trade-off set \(\) finds MWBs to instances scalarized by trade-offs in \(\) in \(O(||m n+_{}m^{2}((m-n)+ w_{max}+  d_{}))\) expected search points where \(d_{}:=\{a>0:a,a(1-)\}\)._

In order for MOEA/D to reach a \(k\)-approximation and not lose it afterwards, it suffices that \(\) is sufficient and each scalarized subproblem admits optima with a unique image. As mentioned and from Lemma 1, this can be obtained by sampling from the interiors of convex polytopes in \(H_{A}\). For \(k=2\), this can be done by taking a complete scalar trade-off set \(A\) (e.g. as returned by Algorithm 2) and include \((a+b)/2\) (which is an interior point) for each non-empty interval \((a,b)\) bounded by consecutive elements in \(A\{0,1\}\). Under the integer weights assumption, this method gives rational trade-offs whose integral denominators are \(O(w_{max}^{2})\), so we have the following bound from Corollary 3.

**Corollary 4**.: _For a bi-objective instance, MOEA/D working on a minimal sufficient trade-off set finds a sufficient solution set within \(O(m^{2}}(m((m-n)+3 w_{max})+ n))\) expected number of search points._

This method can be generalized to higher dimensions. Instead of taking an average of two consecutive elements, we can take the average of the vectors normal to \(k\) facets of \((F)\) that meet at an extreme point, as this ensures the resulted trade-off \(\) is not normal5 to any \(h\)-faces of \((F)\) for all \(h[1,k]\), and that said extreme point minimizes \(w^{()}\). Since each facet is determinable by \(k\) points with integral coordinates, each such (1-norm unit) vector admits rational coordinates with denominator at most \(k_{max}\). Therefore, the trade-offs derived by this method admit rational representations whose denominators are \(O(k^{k+1}w_{max}^{k})\), giving the run-time upper bound from Corollary 1 under the assumption that \(k\) is sufficiently small.

**Corollary 5**.: _Given a \(k\)-objective instance where \(k o(m)\) and \(k o(w_{max})\), MOEA/D working on a minimal sufficient trade-off set guarantees \(k\)-approximation within \(O(m^{2k-1}(m((m-n)+(k+1) w_{max})+ n))\) expected number of search points._

As a side note, since MOEA/D uses standard bit mutation, we can replace \(w_{max}\) with \(m^{m}\) and remove \( d_{}\) from the bound in Theorem 3 to arrive at weight-free asymptotic bounds .

### Expected Time To Enumerate \((F)\)

We see from Corollary 2 that MOEA/D with a complete trade-off set can collect all points in \((F)\) with 2-bit flips starting from an optimum to each subproblem. As mentioned, this is afforded by allowing all found optima to undergo mutation.

**Theorem 4**.: _Assuming distinct supported solutions have distinct images under \(w\), MOEA/D working on a minimal complete trade-off set \(\), and starting from an optimum for each \(\) enumerates \(C:=(F)\) in \(O(|||C|^{2}m^{2})\) expected number of search points._

With this, Theorem 3 and Corollary 3 and 1, we have the following expected run-time bounds under the distinct image assumption. Note this assumption can be removed by having MOEA/D keep duplicate images at line 11.

**Corollary 6**.: _For a bi-objective instance, MOEA/D working on a minimal complete trade-off set enumerates \(C:=(F)\) in expected time \(O(m^{2}}(m((m-n)+3 w_{max}+|C|^{2})+ n))\)._

**Corollary 7**.: _Given a \(k\)-objective instance where \(k o(m)\) and \(k o(w_{max})\), MOEA/D working on a minimal complete trade-off set enumerates \(C:=(F)\) in expected time \(O(m^{2k-1}(m((m-n)+(k+1) w_{max}+|C|^{2})+ n))\)._Experimental Investigation

In this section, we perform computational runs of MOEA/D on various bi-objective minimum spanning tree instances. Spanning trees in a connected graph \(G=(V,E)\) are bases of the graphic matroid defined by \(G\) admitting the ground set \(E\). The rank of such a matroid (i.e. the size of the spanning tree) equals \(|V|-1\) and its rank function is defined with \(r(x)=|V|-cc(x)\) where \(cc(x)\) is the number of connected components in \((V,x)\). In notations, we have \(n=|V|-1\) and \(m=|E|\). We use simple undirected graphs in our experiments, and the edge-set representation of solutions in the implementations of the algorithms .

### Setting and Performance Metrics

We uniformly sample graphs with \(|V|\{26,51,101\}\) and \(|E|\{150,300\}\). In this procedure, edges are added randomly into an empty graph up to the desired edge count, and this is repeated until a connected graph is obtained. Each edge weight is an integer sampled independently from \((1,100)\). We generate two weighted graphs with each setting, making 12 instances in total.

With this experiment, we aim to measure the algorithms' performances in finding solutions mapped to all extreme points, we denote this set of target points with \(R\). We compare MOEA/D against GSEMO, previously studied for its performance in bi-objective MST . For GSEMO, we use the fitness function \(g\) defined in Eq. (1). Since GSEMO checks for dominance in each iteration across its entire population, we set \(N:=||\) for MOEA/D to match. Here, the input \(\) to MOEA/D is derived from a complete trade-off set output by Algorithm 2 in the manner described in Section 5.2. The points given by Algorithm 1 are the target points \(R\), and each run is terminated if all target points are hit. Additionally, each run is terminated after at most \( 3|R|m^{2}(m-n)\) evaluations (each evaluation is a call to function \(g\)). Each algorithm is run on each instance 10 times. Their performances are measured with the followings (\(S\) is the final population returned by the algorithm):

* **Success rate:** The number of runs where all target points are hit within the evaluation budget.
* **Cover rate:** The proportion of hit target points after termination, \(|R\{wx:x S\}|/|R|\). A run is successful if this reaches 100%.
* **Modified inverted generational distance (IGD+):** The distance between the output and the target points , \(_{y R}_{x S}^{k}(\{(wx)_{i}-y_{i},0\})^{2}} /|R|\). A run is successful if this reaches 0.
* **T:** The number of evaluations until all target points are hit.

We remark that the fitnesses \(f_{k}\) can be quickly computed alongside \(g\), incurring minimal overheads. In fact, the run-time bottleneck is in checking the number of connected components.

### Experimental Results

The results are shown in Table 1, with IGD+ and cover rate from MOEA/D omitted due to them being 0 and 100% across all instances, respectively. These are contextualized by the listed instance-specific parameters. Of note is the number of target points \(|R|\) which is smaller than the upper bound in Theorem 2 in all instances.

Immediately, we see the GSEMO failed to hit all target points within the evaluation budget in most runs, while MOEA/D succeeded in every run. In most cases, GSEMO hit at most one target point. Inspecting the output points and IGD+ reveals that its population converged well to the non-dominated front, yet somehow misses most extreme points. In contrast, MOEA/D hit all target points within up to 92% of the evaluation budget, though there are significant relative variances in the run-times.

Inspecting the run-times of MOEA/D in relation to the evaluation budgets, we see that the means of ratios remain fairly stable across instances. This suggests the asymptotic bound in Theorem 3 is not overly pessimistic. Instances 5 and 6 are particularly interesting as they are ostensibly the easiest due to the small number of extreme points, yet MOEA/D seems to require the most fractions of the budget. Given that these instances exhibit the smallest \(m-n\), this can be explained by the interference of lower-order terms in the asymptotic bound, which are not counted in the budgets.

## 7 Conclusion

In this study, we contribute to the theoretical analyses of evolutionary multi-objective optimization in the context of non-trivial combinatorial problems. We give the first run-time analysis of the MOEA/D algorithm for a broad problem class that is multi-objective minimum weight base problem. In particular, we show a fixed-parameter polynomial expected run-time for approximating the non-dominated front, simultaneously extending existing pseudo-polynomial bounds for GSEMO to arbitrary number of objectives and broader combinatorial structures. Our experiments in random bi-objective minimum spanning tree instances indicate that MOEA/D significantly outperforms GSEMO in the computing extreme points under an appropriate decomposition. Along the way, we prove properties that give further insight into the problem of interest.