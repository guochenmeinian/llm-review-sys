# _Read-Me_: Refactorizing LLMs as Router-Decoupled Mixture of Experts with System Co-Design

Ruisi Cai\({}^{1}\), Yeonju Ro\({}^{*1}\), Geon-Woo Kim\({}^{1}\), Peihao Wang\({}^{1}\),

**Babak Ehteshami Bejnordi\({}^{2}\), Aditya Akella\({}^{1}\), Zhangyang Wang\({}^{1}\)**

\({}^{1}\)The University of Texas at Austin, \({}^{2}\)Qualcomm AI Research

{ruisi.cai, gwkim, peihaowang, atlaswang}@utexas.edu,

{yro, akella}@cs.utexas.edu, behtesha@qti.qualcomm.com

Equal contribution: authors are listed alphabetically. A. Akella and Z. Wang also advised this work equally.

###### Abstract

The proliferation of large language models (LLMs) has led to the adoption of Mixture-of-Experts (MoE) architectures that dynamically leverage specialized subnetworks for improved efficiency and performance. Despite their benefits, MoE models face significant challenges during inference, including inefficient memory management and suboptimal batching, due to misaligned design choices between the model architecture and the system policies. Furthermore, the conventional approach of training MoEs from scratch is increasingly prohibitive in terms of cost. In this paper, we propose a novel framework _Read-ME_ that transforms pre-trained dense LLMs into smaller MoE models (in contrast to "upcycling" generalist MoEs), avoiding the high costs of ground-up training. Our approach employs activation sparsity to extract experts. To compose experts, we examine the widely-adopted layer-wise router design and show its redundancy, and thus we introduce the pre-gating router decoupled from the MoE backbone that facilitates system-friendly pre-computing and lookahead scheduling, enhancing expert-aware batching and caching. Our codesign therefore addresses critical gaps on both the algorithmic and system fronts, establishing a scalable and efficient alternative for LLM inference in resource-constrained settings. _Read-ME_ outperforms other popular open-source dense models of similar scales, achieving improvements of up to \(10.1\%\) on MMLU, and improving mean end-to-end latency up to \(6.1\%\). Codes are available at: https://github.com/VITA-Group/READ-ME.

## 1 Introduction

The success of Mixture-of-Experts (MoE)  - such as recently exemplified by the Mixtral model  in the era of large language models (LLMs) - lies in its remarkable ability to leverage the collective expertise of specialized sub-networks, or "experts," each proficient in handling specific subsets or aspects of the data. By dynamically routing data through these experts, MoE models effectively capture complex patterns, adapt to diverse data distributions, and offer superior predictive accuracy compared to traditional single-model approaches. In addition to performance promise, MoEs also have a natural appeal for resource-limited devices due to their high sparsity, and therefore reduced activated parameters per token, which can potentially save inference costs .

However, MoE inference presents significant challenges for key system-level objectives:

* **Memory Management:** Although MoEs activate only a subnetwork during inference, expert selection is determined on the fly by a layerwise router, complicating efficient prefetching. This often forces reliance on naive prefetching algorithms. For example, prior work haspredicted the next expert using hidden states from the previous layer and applied an LRU cache replacement for recently used experts . While effective under certain conditions, such strategies depend on assumptions about expert locality and token predictability, which can become sub-optimal if those assumptions are violated (as shown in Table 4).
* **Token Batching:** Token batching techniques critical for efficient inference (e.g., ) are poorly suited to MoE architectures, where each batch contains tokens invoking different experts across layers, rendering batching strategies ineffective (SS 4.2).

Moreover, traditional MoEs are typically trained from scratch, which becomes prohibitively expensive as model scales increase. To mitigate this, some approaches, such as "upcycling" , reuse pre-trained dense LLMs to initialize experts in an MoE. While that efficiently scales MoEs by leveraging smaller, pre-trained models, it does not address the inference-related challenges mentioned earlier.

In this work, we tackle the opposite challenge: _how to create a smaller MoE model from larger pre-trained models that enables resource-efficient inference while minimizing training costs?_ Despite existing efforts [11; 12; 13; 14], this problem remains underexplored. Approaches like [11; 12; 13] attempt MoE refactorization but still adopt systems-unfriendly layer-wise structures for inference. Similarly,  focuses on dynamically selecting "important" neurons during pre-filling and pruning others during generation, but this is limited to long-content generation and requires neuron importance identification for each sequence.

To address both training and inference challenges, we introduce a holistic MoE framework dubbed _Read-ME_. To minimize training costs, we "refactorize" a pre-trained dense LLM into specialized experts through activation sparsity and optimize the routing policy (SS 3). For efficient inference, we examine the redundancy of layer-wise routers (SS 2.1, SS 2.2) and propose decoupling the router from the MoE backbone (SS 2.3). This allows us to _pre-gate all requests (token sequences) before inference_ and apply lookahead scheduling based on the experts to which tokens will be dispatched. Consequently, we propose an expert-aware batching algorithm (SS 4.2) and an optimal expert caching strategy inspired by Belady's offline caching algorithm  (SS 4.1).

Figure 1 illustrates our framework. Our key contributions are:

* We transform large pre-trained LLMs into Mixture-of-Experts (MoE) models with fewer activated parameters and small additional training cost (1 billion tokens). Our approach outperforms popular open-source models and compression techniques of similar scale on downstream tasks like MMLU .
* We analyze the widely adopted layer-wise routers in existing MoEs and reveal design redundancies. Current caching policies and batching algorithms are poorly suited to layer-wise MoEs. We propose a novel pre-gating router, decoupled from the MoE backbone, enabling better system-level optimization.

Figure 1: Overview of _Read-ME_. This figure shows the refactoring of a pre-trained dense model (in yellow) into two experts (in **red** and **green**). After refactoring, the model is deployed, and the serving timeline is depicted. At time \(t=0\), multiple inference requests (each a sequence of tokens) are queued, with expert assignment for each token undecided (”?") until processed by the router. Our router pre-gates tokens before inference, enabling expert-aware batching. Tokens are routed to their respective experts and batched accordingly: at \(t=0\) for Expert 1 (**red**) and at \(t=1\) for Expert 2 (**green**). New tokens enter the queue at each time step, with routing computed only for incoming tokens marked “?”.

* Our system achieves a 6.1% reduction in mean latency and a 10% improvement in tail latency compared to state-of-the-art systems. Our caching algorithm is both provably and empirically optimal, thanks to our algorithm-system co-design.

## 2 Pre-gating Sparse Mixture of Experts

In this section, we introduce our motivation and design of pre-gating MoE which enables system-level acceleration by sharing and precomputing expert selection for each layer.

### System Drawbacks of Conventional Sparse MoE Design

An Mixture-of-Expert (MoE) [1; 2; 17; 3] layer consists of a routing network \(G\) and a set of \(N\) expert networks \(\{F_{1},...,F_{N}\}\). In the forward pass, the routing network will first process input sequences and generate the gating weights. Then a size-\(K\) subset of experts will be dynamically activated and their outputs will be combined as final outputs according to the gating weights. In LLMs, MoE is typically adopted in the Feed-Forward Networks (FFN) within each transformer block [1; 2; 3]. Suppose an LLM has \(L\) layers, the output of the \(l\)-th layer can be formulated as:

\[=_{i=1}^{N}(|\{j[N]:G^{(l)}()_{j} G^{(l)}( {x})_{i}\}| K)G^{(l)}()_{i}F_{i}^{(l)}(),\] (1)

where the superscripts indicate the layer indices, \(G^{(l)},F^{(l)}\) are point-wise functions operating on tokens individually, and \(()\) is the indicator function which filters experts with top-\(K\) gating weights. For shorthand, we denote \(_{i}^{(l)}=(|\{j[N]:G^{(l)}()_{j} G^{(l)}( )_{i}\}| K)\).

As shown in Eq. 1, conventional MoEs assign a separate router to each layer. While this is commonly used by open-source MoEs like Mixtral  and OpenMoE , we highlight its system inefficiency. Layer-wise gating makes it difficult to predict which expert to load until runtime (SS 4.1), and complicating request batching (SS 4.2). Specifically, layer-wise routers select the \(l\)-th layer expert \(i:_{i}^{(l)}=1\) based on the \((l-1)\)-th layer outputs, which prevents pre-scheduling and pre-loading of data or model weights. This issue is especially problematic for billion-level parameter MoEs, where experts are usually distributed across devices (GPUs and CPUs in a machine) or even machines; in such situations, layer-wise selection accentuates high overheads of data I/O and communication among servers in the critical path of inference.

### Redundancy of Layer-wise Router

In this section, we demonstrate that layer-wise gating patterns are redundant in an MoE. In particular, we empirically find that expert selections between two adjacent layers are highly correlated.

We use Mixtral-8\(\)7B (\(N=8,K=2\))  as a study case and analyze router decisions among its layers. Define the random variable \(^{(l)}=\{i[N]:_{i}^{(l)}=1\}\) as the pair of experts selected

Figure 2: (a) Visualization of transition matrix between the (\(l\)-1)-th layer and the \(l\)-th layer, where each coordinate \([\{s,t\},\{i,j\}]\) represents \(P(^{(l)}=\{i,j\}|^{(l-1)}=\{s,t\})\). The row-wise sparse pattern suggests that the router decision becomes almost deterministic given the previous layer’s decision. (b) Mutual information \(I(^{(l)};^{(l-1)})\), which indicates the learned knowledge shared by two neighboring layers is high. (c) Overview figure of router tuning and router distillation loss.

for each layer (\(|^{(l)}|=2\)). We are interested in the conditional probability of \(^{(l)}\) between two consecutive layers: \(P(^{(l)}=\{i,j\}|^{(l-1)}=\{s,t\})\). The transition matrix of the last two layers from Mitral-8\(\)7B is depicted in Figure 2 (a). The row-wise sparse pattern implies that the expert selection is almost deterministic given the previous layer' choices. For example, for tokens choosing expert-3 and expert-5 in the 30th layer, over \(70\%\) will select expert-1 and expert-5 at the 31st layer.

To further validate this observation, we plot the mutual information between expert choices of every two neighboring layers: \(I(^{(l)};^{(l-1)})\). As reflected in the right sub-figure of Figure 2, knowing expert pairs used in the last layer significantly reduces the uncertainty of the next layer. Thus, the implicit knowledge learned by each router is extensively shared across layers.

### Pre-Computed Routing Policy

The above observations suggest that among the many \(^{L}\) routing paths, only a few are used during the inference. Therefore, layer-wise routing decisions are unnecessary for MoEs. Instead, we can separate the routerfrom the MoE backbone and pre-compute the routing path all at once.

First of all, we assume the indices of experts handling one domain of tokens are aligned, i.e. \(\{F_{i}^{(1)},,F_{i}^{(l)}\}\) always forms a routing path. We defer our approach to the construction of aligned experts to SS3. Next, we let a singleton network \(G\) generate gating weights for all layers. In particular, we adopt one transformer block with causal attention as the model architecture of \(G\). Gating weights computed in this way not only leverage the states of the current token but also take the information from the past tokens into consideration. Thus, tokens will have expert selections similar to the recent tokens, which ensures cache-friendly inference (see more details in SS 5.3).

Suppose the input sequence is \((_{t})_{t=1,,T}\), the output for the \(t\)-th token at the \(l\)-th layer is:

\[_{t}=_{i=1}^{N}(|\{j[N]:G(_{ t})_{j} G( _{ t})_{i}\}| K)G(_{ t})_{i}F_{i}^{(l)}(_{t}),\] (2)

where \(_{ t}=(_{1},,_{t})\) represents all the tokens before the \(t\)-th token. We note that \(G\) is independent of layer index \(l\). Despite a subtle change, it brings profound benefits to enable system-level optimization. In brief, by separating the gating network from the transformer layers, expert selection can be determined at the outset and used to schedule the data-loading procedure for each layer. We defer more details on system co-design to SS4.

## 3 Re-factoring Language Model with Pre-Gating MoE

In this section, we introduce the main technique to re-use a dense pre-trained model to construct our pre-gating MoE proposed in SS2. In short, our approach first initializes each expert by structured pruning of a dense model on the corresponding data domains. Afterward, we instantiate a gating network shared across layers and continue joint training of the router and experts.

**Domain-Aware Expert Construction.** We construct a set of small experts by pruning the dense model with different data domains. To begin with, we point out that public language corpora often contain metadata indicating the domain of each subset. For example, the training dataset of LLaMA family  can be split into scientific articles , novels , and QAs , etc. We utilize this metadata to group data entries in the training corpus into \(N\) sub-domains \(\{_{1},,_{N}\}\). Observing that feature channels on each subset are sparsely activated , we compute the average magnitude of a channel on each subset and keep top activated neurons to form the domain expert. Formally, let the number of experts equal to the number of sub-domains, and assume the dense model is a two-layer FFN with hidden size \(D\): \(F_{0}()=_{2}(_{1})\), then the \(i\)-th experts with hidden size \(d\) are initialized as: \(F_{i}()=_{2}_{i}^{}(_{i}_{1}),  i[N]\), in which \(_{i}\) is obtained by:

\[*{arg\,max}_{\{0,1\}^{d D}}_{ _{i}}\|_{1}\|_{1}_{D}=,^{}_{d},\] (3)

where \(\) is constrained to be a selection matrix without replacement. The mask for each layer is jointly optimized so that the resultant experts are aligned layerwise and dedicated to the same data distribution. In our experiments, we set \(d D/2\). In addition, we observe that a certain subset of channels is essential for all data, potentially due to the system prompt and the presence of commonsense knowledge. Therefore, we isolate the corresponding neurons as the _permanent expert_, which will be activated for all tokens, similar to previous designs [18; 24].

**Continual Training Objective.** After initializing experts via structured pruning, we perform joint training of randomly initialized gating networks and expert subnetworks via causal language modeling. In addition, we propose _routing distillation loss_ to enhance the alignment between expert choice in pre-gating MoE and the activation sparsity in the original dense model.

We illustrate the training of our router in Fig. 2 (c). Suppose the predicted token has embedding \(_{t+1}\). We feed \(_{t+1}\) into the original dense model \(F_{0}\) and get a sparse selection matrix \(_{0}\) that indicates neurons with top 50% magnitude similar to Eq. 3. Then we penalize this loss function:

\[_{RD}=_{KL}((G(_{ t+1})) \|([\|_{0}_{1}^{}\|_{F}^{2},,\|_{0 }_{N}^{}\|_{F}^{2}])).\] (4)

Here, \(_{KL}(\|)\) represents Kullback-Leibler divergence. \(\|(_{0}_{1}^{}\|_{F}^{2}=_{d}^{}_{0}_{j} ^{}_{d}\) computes the Hamming distance between two masks induced by \(_{0},_{j}\). We apply softmax to normalize these scores as the estimated selection probability of each expert for predicted token \(_{t+1}\).

## 4 Expert-aware Inference System

We demonstrate how our refactoring and pregating concepts enable a novel, high-performance, and efficient MoE inference method. We address two key challenges in existing MoE models' inference: inadequate memory management and limited support for batched inference. Our problem setting is broad, aiming to serve multiple requests using an MoE model, each comprising a sequence of tokens. This differs from previous systems, which focused on optimizing performance for individual requests.

### Pre-gating Optimized Expert Prefetching and Caching

MoE models promise reduced memory usage during inference by loading only the parameters of required experts, skipping the rest. However, traditional layer-wise gating imposes significant loading costs. Previous approaches, such as on-demand loading , prefetching , and expert caching [8; 27], attempt to address this. However, on-demand loading adds overhead to the critical inference path, and prefetching often loads unnecessary experts due to incomplete routing information, leading to suboptimal memory usage and performance . Additionally, caching strategies, based on request characteristics like temporal locality or activation sparsity, have mostly been evaluated in isolated single-request scenarios. In practice, expert caches are shared across multiple requests, making cache policies relying on per-request traits suboptimal. A global view across all requests is necessary for effective caching (see Table 4). Our work leverages pre-gating to develop more informed prefetching and caching strategies, resulting in significant system-level improvements.

**Fine-grained Prefetching.** By design, our pre-gating MoE architecture enables us to prefetch the exact expert layers needed for a token or a request, avoiding guesswork. To further hide the latency in prefetching, we pipeline and thus overlap loading of experts and experts' computation at layer-wise granularity: specifically, while computing the \(i\)th layer's forward path in the compute stream, we load the \(i+1\)st layer's experts in a separate loading stream.

**Belady-inspired Caching.** Prefetching can hide the loading latency of all but the first layer, which incurs significant cost. To mitigate this, we need a cache that stores relevant initial layers, and we argue that pre-gating enables an optimal caching strategy.

The classical Belady algorithm is known to be the _optimal offline cache replacement algorithm_, replacing the object that will be accessed farthest in the future. While impractical in real-world systems (due to unknown future accesses), our pre-gating architecture allows us to approximate it. By decoupling the router from the backbone MoE, we can compute future expert references across requests in advance, enabling near-optimal cache replacement.

Suppose that the cache at time step \(t-1\) is as follows: \(C(t-1)=\{e_{1},e_{2},...,e_{k}\}\), where the cache is of size \(k\) and is filled with \(k\) experts \(e_{1...k}\). \(F(e,t)\) represents the next time after \(t\) when expert \(e\) will be requested. Then, our policy chooses the expert \(e_{evict}=argmax_{e C(t-1)}F(e,t)\) for eviction.

### Expert-aware Batching

Current serving systems heavily rely on batching to improve inference efficiency, but effective batching for MoE models remains challenging. As shown in Figure 3 (a), each token in MoE models may invoke a different set of experts per layer, leading to multiple expert activations for a batch of requests. For example, in a toy model with 4 experts per layer and a batch of 3 tokens (one per request), 2/3/3 experts would be activated across the layers. In the Mixtral8x7B model  applied to the chatbot arena dataset , we observed an average activation of **7.63 out of 8 experts**, even with a modest batch size of 56.8.

The core challenge is that while each token requires computation from only one expert per layer, it must wait for all other tokens in the batch to complete their expert computations in the same layer . This bottleneck repeats at each layer, reducing the efficiency of batching. Ideally, a single loaded expert would serve multiple tokens in a batch, but this is rarely achieved, affecting both performance and efficiency. For example, we observe a linear increase in average per-token processing latency as the number of unique experts per batch grows (see Figure 3 (b)).

In contrast, pre-gating enhances inference performance by enabling the _delayed creation of an optimal batch based on required experts_. For a given set of tokens, we pre-gate each one and select a subset for batching, depending on their identified expert requirements. The goal is to minimize the number of unique experts across all layers while maximizing the number of tokens in the batch. Moreover, as discussed in SS 2.3, our expert selection remains consistent across layers--if a token is assigned to Expert 1, it will be routed to Expert 1 in every layer. This approach, combined with our batching strategy, ensures optimal efficiency. Algorithm 1 provides our batching pseudocode.

We note that in other MoEs, such batching isn't feasible because, as shown in Figure 3, their expert selection at each layer remains unknown until the request reaches the router. In _Read-ME_, experts are determined first, which allows batches to be created and submitted to MoE layers efficiently.

## 5 Evaluation

In this section, we start by describing the experimental details in SS 5.1. Then we validate the refactorization effectiveness on downstream tasks in SS 5.2. In SS 5.3, we evaluate the effectiveness of pre-gating and batching. SS 5.4 analyzes memory optimization techniques. In addition, we provide experimental details in SS 5.1, and more experimental results in SS. A.

### Experimental Details

Model and DatasetWe perform the MoE refactorization based on Llama2-7B-chat  model, a popular open-source model pre-trained on 2 trillion tokens. The training corpus  involves the data collected from 7 different resources: Arxiv , Books , Common Crawl, C4 , Github, Wikipedia , and StackExchange . To generate experts, we collect \(16\) samples from each data domain, with each sample consisting of \(4096\) consecutive tokens. During router tuning, we use the subset of RedPajama dataet , with the same curation strategy. We present our detailed router design in Table 1. We use the standard Transformer  architecture with a 1-layer, 4-head

   \# Layers & 1 \\ \# Heads & 4 \\ Vocab size & 32000 \\ Embedding Dim. & 512 \\ Feature Dim. & 512 \\ MLP Intermediate Dim. & 512 \\ Activation Function & SwiGLU  \\  Positional Embedding & RoPE  \\ Normalization & RMSNorm  \\   \# Params & 18.0 M \\   

Table 1: Details of router design. Following the standard Transformer architecture , the inserted router adds only 18 million additional parameters.

Figure 3: Challenges of MoE serving in current serving systems and _Read-ME_’s batching pipeline.

design. The router is lightweight, consisting of 18 million additional parameters, and incurs negligible computational overhead. We use 8 A100 GPUs with 80GB of memory for all tuning experiments.

Continual-Tuning DetailsTo co-optimize the router and expert networks, we iteratively tune each model component. Specifically, we first optimized the router by \(_{RD}\), as detailed in SS 3, for \(100\) steps. We use the batch size of \(64\) in this router tuning stage. During this _router tuning_ stage, we freeze the expert weights and solely tune the router weights. Then, during the _expert tuning_ stage, we fix the router weights and modify the expert weights via language modeling loss, for \(200\) steps, with a batch size of \(128\). We set sequence length to \(4096\) for all stages, following the choice in the pre-training stage of Llama2 model . This iterative training schedule is conducted 8 times. Detailed visualizations of the training dynamics are provided in Section A.1. For each round, the router tuning and expert tuning stages will cost 26 million and 105 million tokens, respectively. The whole continual-tuning process merely uses \(1.04\) billion tokens, negligible compared to the pre-training cost (2 trillion tokens). During each round of tuning, we use the cosine learning rate decay. At round \(0\), the initial learning rates are \(5e^{-4}\) for router tuning and \(5e^{-5}\) for expert tuning. The initial learning rate decays exponentially with a decay rate of \(0.8\) as the number of rounds increases.

Inference System EvaluationFor our workload, we utilize the Chatbot Arena Conversation Dataset  to generate inference requests and replay conversation traces. Our setup employs a single A100 GPU with 80GB of memory. The implementation is built on top of DeepSpeed inference engine . We use normalized latency as our primary metric, defined as the end-to-end latency divided by the generated token length, in line with previous works [9; 39; 38].

### Downstream Task Evaluations

We first validate the refactorization effectiveness on downstream tasks, as shown in Table 3, comparing it to other models of similar scales, including the open-source models that trained from scratch, and

  Stage & Router Tuning & Expert Tuning \\  \# Iteration per Round & 100 & 200 \\ \# Rounds & 8 & 8 \\  Initial LR at Round 0 & \(5e^{-4}\) & \(5e^{-5}\) \\ LR Decay within Round & Cosine & Cosine \\ LR Decay type across Rounds & Exponential & Exponential \\ LR Decay rate across Rounds & 0.8 & 0.8 \\ Weight Decay & 0.01 & 0.01 \\ Batch Size & 64 & 128 \\  Sequence Length & 4096 & 4096 \\ \# Tokens per Round & 26 M & 105 M \\  \# Tokens in Total & & 1.04 B \\  

Table 2: Hyper-parameter choice during the training.

the dense models pruned from larger pre-trained LLMs. We achieve the best average performance, outperforming all model variants from the Pythia  and Open-Llama-v2  families, as well as Sheared-Llama . We use just 1 billion training tokens, considerably less than other models.

In Fig. 4, we further provide a direct comparison with other compression methods, which converts a large LLM to a small dense variant, on MMLU  benchmarks. Besides open-source models and Sheared-Llama  which are mentioned in the previous table, we additionally include recent compression techniques, including LLM-Pruner , SliceGPT , LaCo , and Compresso , as our baselines. _Read-ME_achieves the best performance among the models with the number of activation parameters less than \(5\) billion, and shows comparable performance with Open-Llama-v2-7B . More analysis is included in SS 1.2.

### Pre-gating and Expert-aware Batching

**Inference Latency Breakdown.** We evaluate the impact of the auto-regressive router introduced by our refactoring of the dense MoE on per-request inference latency. Unlike conventional layer-wise routers, usually linear layers, our auto-regressive router comprises a multi-head attention layer and an MLP layer (see SS 1.3), potentially raising its computational cost.

Fig. 5 (left) illustrates the average per-token latency breakdown of a single isolated inference request measured in OpenMoE with conventional layerwise routers, our refactored model with pregating router, and the original dense Llama2-7b model  we refactored. We find that the computational

Figure 4: Evaluation of _Read-ME_on MMLU  benchmark, compared to other open-source models and compression techniques ( performance numbers are collected from their respective papers.

Figure 5: Latency evaluation and Temporal locality analysis. (Left) Single inference latency measured on a \(124\) token generation task. (Center) Latency distribution measured on synthetic workload replaying Chatbot Arena Dataset  (§ 5.1). (Right) Temporal distance measured on Arxiv dataset , and a subset of Redpajama .

   Method & \#Param & Cost & MMLU & Hell. & Wino. & ARC-E & ARC-C & LogiQA & CoQA & avg. \\  Sheared-Llama & 2.7B & 50B & 26.4\% & **70.8**\% & 67.0\% & **67.0**\% & 41.2\% & 28.3\% & 71.7\% & 53.2\% \\ Pythia & 2.8B & 300B & 26.9\% & 60.8\% & 59.7\% & 64.4\% & 36.4\% & 27.7\% & 61.9\% & 48.3\% \\ Open-Llama-v2 & 3.4B & 1T & 25.7\% & 67.6\% & 63.5\% & 66.5\% & 39.0\% & 28.1\% & 54.4\% & 49.3\% \\ OpenMoE & 2.1B-8B & 1.1T & 26.2\% & 45.5\% & 60.3\% & 64.1\% & 30.3\% & - & - & - \\ _Read-ME_ & 4.7B-17B & 1B & **38.9**\% & 68.5\% & **67.7**\% & 66.6\% & **42.3**\% & **29.7**\% & **74.8**\% & **55.5\%** \\  Pythia & 6.9B & 300B & 25.5\% & 67.1\% & 64.1\% & 67.3\% & 31.3\% & 25.3\% & 63.6\% & 49.2\% \\ Open-Llama-v2 & 6.9B & 1T & 40.2\% & 66.7\% & 66.0\% & 63.0\% & 36.0\% & 27.6\% & 64.5\% & 52.0\% \\ Llama-2 & 6.9B & 2T & 45.3\% & 78.6\% & 69.3\% & 76.4\% & 53.0\% & 31.0\% & 75.9\% & 61.4\% \\   

Table 3: Downstream task evaluation of our proposed method (_Read-ME_) compared to open-source models, including dense models Pythia and Open-Llama-v2, the MoE model OpenMoE, and the compression method Sheared-Llama. The evaluation includes zero-shot performance on WinoGrande, ARC-Easy, LogiQA, CoQA; 5-shot performance on MMLU; 10-shot on Hellaswag; and 25-shot on ARC-Challenge. The "#Param" column presents in the form of (# Activated-Parameters - # Total-Parameters). Training cost is measured by the number of tokens used. For compression methods like ours and Sheared-Llama, only tokens used for conversion are counted, excluding Llama-2 pre-training costs.

overhead of our auto-regressive router is minimal - its contribution of 0.4% is much less compared to the router's net contribution in other MoE models (3.95%). This is because we use a single router unlike other models with gating for each MoE layer; also, our router design is compact with only 18M parameters (Table 1). Compared to the dense model, we achieve a net 19% reduction in latency via refactoring the MLP to MoE.

**Batched Inference.** We now evaluate the efficacy of our expert-aware batching. Fig 5 (center) shows the latency distribution and the 95-th percentile latency (p95) during batched inference. We compare with two widely used techniques - Decoding-prioritized batching , and Prefill-prioritized batching [39; 47]. These methods utilize distinct queues for decoding requests and prefill requests, prioritizing batching of tokens from decoding and prefill requests, respectively.

Prioritizing either decoding or prefill requests yields comparable performance. In contrast, our method of constructing batches based on activated experts enhances the mean latency by 5.0-6.1% and reduces the p95 latency by 9.5-10.0% compared to these approaches.

The primary reason for this improvement is that our batching approach directly reduces the average number of unique experts invoked per batch by leveraging pre-gated information. Specifically, for decoding-prioritized and prefill-prioritized batching, the average number of unique experts per batch was 5.08 and 5.21, respectively, whereas our method reduces this to 3.51.

We observed a significant performance impact as prefill requests invoke more experts per batch compared to decoding requests. Prefill requests require tokens to be dispatched to different experts, making it impractical to batch tokens by shared experts due to attention operations. As a result, a substantial number of experts are invoked for each batch, negatively affecting performance. Fortunately, our auto-regressive router design improves temporal locality in prefill requests, often allowing tokens within the same request to select the same or a small number of experts. We explore this locality in greater detail in the following section.

**High Temporal Locality.** To analyze the locality, we measure the temporal distance of the tokens in a sequence (Fig. 5 (c)). We define temporal distance as the distance between two tokens selecting the same expert within a sequence . Our result shows that our router leads to a smaller distance, indicating a high degree of temporal locality. Specifically, out of 4096 tokens, 2921 tokens follow the choice of the last token, compared to 850 tokens in Mixtral-8x7B. The locality is attributed to the auto-regressive design of our router, where the router's decision is based on the current and all previous tokens. As a result, a given token is likely to have similar expert selections with its recent predecessor tokens. However, note that this temporal locality appears only within the token sequence of a single request and does not appear across different requests.

### Memory-Efficient Inference

We evaluate how well our approach can ensure good performance while improving memory efficiency. In particular, we constrain the expert cache capacity to \(k\) (that is, up to \(k\) experts can reside in accelerator memory). In this setup, if a requested expert is not in memory, it must be loaded from host memory, potentially increasing loading latency. As explained in SS 4.1, this loading overhead can be mitigated with prefetching, provided that we know which expert will be needed in _ReadME_. We compare the end-to-end latency of requests from the prefetching our approach enables (Prefetching) versus not leveraging prefetching (On-demand Loading) . Figure 6 shows that for varying cache capacities, we consistently outperform On-demand Loading, with up to 30% better latency.

In addition to proactively loading experts into memory, our approach also retains experts in a cache to further use memory optimally. Table 4 compares three representative caching policies' hit ratios across varying cache capacities, including the Belady-inspired approach that our architecture enables. As noted earlier, our approach accommodates multiple requests where each request has a token sequence, in contrast with prior works focusing on a single request/token-sequence [8; 27].

Figure 6: Latency impact of prefetching: We measured end-to-end latency on a synthetic workload generated by replaying Chatbot Arena Dataset . (Appendix 5.1)

When multiple requests share the expert cache, temporal locality within a single request cannot be leveraged across requests, limiting its effectiveness. This explains why LRU, which works well in single-request scenarios, underperforms in our setup. In contrast, our Belady-based algorithm excels at all cache capacities by utilizing future expert information across requests, thanks to the pre-gating router. When cache capacity is constrained by system memory, latency can be significantly reduced with an optimized cache policy. Our Belady approach notably improves latency, particularly under limited cache sizes, though we omit detailed results for brevity.

## 6 Related Work

**MoE Refactorization.** Recent "MoE-fication" methods [11; 12; 13; 49] optimize or group channels using graph-based techniques but still rely on system-inefficient layer-wise routers. In contrast, we are the first to identify the redundancy in layer-wise routers and propose a pre-gating router that enables expert pre-fetching. Similar to [50; 14; 51], we leverage activation sparsity  to construct experts, adaptively identifying important neurons and evicting less-important ones during inference.

**Efficient Inference Serving.** To deal with the limited memory in resource-constrained settings, prior LLM inference works focused on optimizations such as offloading parameters to host memory [52; 53; 25], quantization [54; 55; 56], sparsity [57; 58] and MoE architectures [4; 59; 26]. However, while token batching  has garnered significant attention for dense models [39; 47; 38; 60], it remains problematic and underexplored in the context of MoE models.

Pre-gated MoE  is related to _Read-ME_as they too fine-tune a router to pre-gate using the \(i\)th layer's hidden states to compute the \(i+1\)th layer's routing; but they still maintain a layer-wise architecture which constrains batching. SiDA-MoE  separates the router from the inference path. However, tokens cannot be batched together because they do not share routing decisions across all layers. In addition, the offline routing function of SiDA is an approximation that may incorrectly guess expert selection, especially when the model scales. In contrast, _Read-ME_has exact routing, ensuring no performance drop during inference.

Mixtral-offloading  introduces speculation to "guess" routing decisions, resorting to costly on-demand loading if speculation fails. Caching is commonly used [62; 52; 63; 53; 64], including in MoE systems [8; 27], which typically focus on single requests. Prior caching methods are limited by layer-wise routing and lack of foresight into future requests.

## 7 Conclusions and Limitations

We address the under-explored challenge of reusing a pre-trained LLM to create a smaller MoE model that enables efficient inference with minimal training cost. By leveraging activation sparsity, we construct specialized experts and integrate them via a router. Upon analyzing the layer-wise router design used in all open-source MoEs, we identify its inefficiency and redundancy. To overcome this, we propose a pre-gating router, decoupled from the MoE backbone, enabling system-level optimizations that were previously unattainable.

**Limitations.** Our serving system is designed for a single accelerator, and extending it to distributed serving remains a non-trivial task for future work. Our method has no negative societal impact, as it uses publicly released data and model checkpoints. This work is foundational research and is not tied to specific applications.