# Practical Differentially Private Hyperparameter Tuning with Subsampling

Antti Koskela

Nokia Bell Labs

antti.h.koskela@nokia-bell-labs.com &Tejas Kulkarni

Nokia Bell Labs

tejas.kulkarni@nokia-bell-labs.com

###### Abstract

Tuning the hyperparameters of differentially private (DP) machine learning (ML) algorithms often requires use of sensitive data and this may leak private information via hyperparameter values. Recently, Papernot and Steinke (2022) proposed a certain class of DP hyperparameter tuning algorithms, where the number of random search samples is randomized. Commonly, these algorithms still considerably increase the DP privacy parameter \(\) over non-tuned DP ML model training and can be computationally heavy as evaluating each hyperparameter candidate requires a new training run. We focus on lowering both the DP bounds and the compute cost of these methods by using only a random subset of the sensitive data for the hyperparameter tuning and by extrapolating the optimal values to a larger dataset. We provide a Renyi differential privacy analysis for the proposed method and experimentally show that it consistently leads to better privacy-utility trade-off than the baseline method by Papernot and Steinke.

## 1 Introduction

Our aim is two-fold: to decrease the computational cost as well as the privacy cost of hyperparameter tuning of DP ML models. The reasons for this are clear. As the dataset sizes grow and models get more complex, blackbox optimization of hyperparameters becomes more expensive since evaluation of a single set of hyperparameters often requires retraining a new model. On the other hand, tuning the hyperparameters often depends on the use of sensitive data, so it requires privacy protection as well, as illustrated by the example by Papernot and Steinke (2022). Intuitively, the leakage from hyperparameters is much smaller than from the model parameters, however, providing tuning algorithms with low additional DP cost has turned out challenging. Current best algorithms (Papernot and Steinke, 2022) still come with a considerable DP cost overhead.

Although our methods and results are applicable to general DP mechanisms, we focus in particular on tuning of the DP stochastic gradient descent (DP-SGD) (Song et al., 2013; Bassily et al., 2014; Abadi et al., 2016) which has become the most widely used method to train ML models with DP guarantees. Compared to plain SGD, DP brings additional hyperparameters to tune: the noise level \(\) and the clipping constant \(C\). Additionally, also the subsampling ratio \(\) affects the DP guarantees, as well as length of the training. Tuning all the hyperparameters of DP-SGD commonly requires use of sensitive data.

We use the results by Papernot and Steinke (2022) as building blocks of our methods. Their work was based on the analysis of Liu and Talwar (2019) who provided the first results for DP blackbox optimization of hyperparameters, where, if the base training algorithm is \((,0)\)-DP, then the tuned model is approximately \((3,0)\)-DP. Papernot and Steinke (2022) provided a Renyi differential privacy (RDP) analysis for a class of black-box tuning algorithms, where the number of runs in the hyperparameter tuning is randomized. As the privacy bounds are in terms of RDP and assume only RDP bounds about the candidate model training algorithms, they are particularly suitable to tuningDP-SGD. However, still, running these algorithms increase the \(\)-values two or three-fold or more, and they can be computationally heavy as evaluating each candidate model requires training a new model. Our novelty is to consider using only a random subset of the sensitive data for the tuning part and use the output hyperparameter values (and potentially the model) for training subsequent models. Using a random subset for the privacy and computation costly part automatically leads to both lower DP privacy leakage as well as computational cost. We also consider ways to appropriately extrapolate the optimal value from the small subset of data to a larger dataset.

The RDP bounds for the DP tuning methods by Papernot and Steinke (2022) assume that the RDP-values of the candidate model training algorithms are fixed. We also consider ways to use these bounds for tuning hyperparameters that affect the RDP-values of the base algorithm, being the noise level \(\), the subsampling ratio \(\) and the length of training in case of DP-SGD.

### Related Work on Hyperparameter Tuning

Chaudhuri and Vinterbo (2013) were the first ones to focus on DP bounds for hyperparameter tuning. An improvement was made by Liu and Talwar (2019) who considered black-box tuning of \((,)\)-DP mechanisms. Mohapatra et al. (2022) showed that for reasonable numbers of adaptively chosen private candidates a naive RDP accounting (i.e., RDP parameters grow linearly w.r.t. the number of model evaluations) often leads to lower DP bounds than the methods by Liu and Talwar (2019). Papernot and Steinke (2022) gave RDP bounds for black-box tuning algorithms that grow only logarithmically w.r.t. the number of model evaluations. In a non-DP setting, hyperparameter tuning with random subsamples has been considered for SVMs (Horvath et al., 2017) and for large datasets in healthcare (Waring et al., 2020). Small random subsets of data have been used in Bayesian optimization of hyperparameters (Swersky et al., 2013; Klein et al., 2017). Recent works (Killamsetty et al., 2021, 2022) consider using subsets of data for hyperparameter tuning of deep learning models.

### Our Contributions

* We propose a subsampling strategy to lower the privacy cost and computational cost of DP hyperparameter tuning. We provide a tailored RDP analysis for the proposed strategy. Our analysis is in terms of RDP and we use existing results for tuning Papernot and Steinke (2022) and DP-SGD (Zhu and Wang, 2019) as building blocks.
* We propose algorithms to tune hyperparameters that affect the RDP guarantees of the base model training algorithms. We provide a rigorous RDP analysis for these algorithms.
* We carry out experiments on several standard datasets, where we are able to improve upon the baseline tuning method by a clear margin. While our experiments focus mainly on training of deep learning models with DP-SGD and DP-Adam, our framework is currently applicable to any computation that involves selecting the best among several alternatives (consider e.g., DP model selection, Thakurta and Smith, 2013).

## 2 Background: DP, DP-SGD and DP Hyperparameter Tuning

We first give the basic definitions. An input dataset containing \(n\) data points is denoted as \(X=\{x_{1},,x_{n}\}\). Denote the set of all possible datasets by \(\). We say \(X\) and \(Y\) are neighbors if we get one by adding or removing one data element to or from the other (denoted \(X Y\)). Consider a randomized mechanism \(\,:\,\), where \(\) denotes the output space. The \((,)\)-definition of DP can be given as follows (Dwork, 2006).

**Definition 1**.: _Let \(>0\) and \(\). We say that a mechanism \(\) is \((,)\)-DP, if for all neighboring datasets \(X\) and \(Y\) and for every measurable set \(E\) we have:_

\[((X) E)^{}((Y) E)+.\]

We will also use the Renyi differential privacy (RDP) (Mironov, 2017) which is defined as follows. Renyi divergence of order \(>1\) between two distributions \(P\) and \(Q\) is defined as

\[D_{}(P||Q)=()^{ }Q(t)\;t.\] (2.1)

**Definition 2**.: _We say that a mechanism \(\) is \((,)\)-RDP, if for all neighboring datasets \(X\) and \(Y\), the output distributions of \((X)\) and \((Y)\) have Renyi divergence of order \(\) at most \(\), i.e.,_

\[_{X Y}D_{}(X)||(Y).\]

We can convert from Renyi DP to approximate DP using, for example, the following formula:

**Lemma 3** (Canonne et al. 2020).: _Suppose the mechanism \(\) is \(,^{}\)-RDP. Then \(\) is also \((,())\)-DP for arbitrary \( 0\) with_

\[()=(-1)(^{}- )}{}(1-)^{-1}.\] (2.2)

As is common in practice, we carry out the RDP accounting such that we do bookkeeping of total \(()\)-values for a list of RDP-orders (e.g. integer \(\)'s) and in the end convert to \((,)\)-guarantees by minimizing over the values given by Equation(2.2) w.r.t. \(\). RDP accounting for compositions of DP mechanisms is carried using standard RDP composition results (Mironov, 2017).

DP-SGD differs from SGD such that sample-wise gradients of a random mini-batch are clipped to have an \(L_{2}\)-norm at most \(C\) and normally distributed noise with variance \(^{2}\) is added to the sum of the gradients of the mini-batch (Abadi et al., 2016). One iteration is given by

\[_{j+1}=_{j}-_{j}_{x B_{j}}( f(x,_{j}),C)+Z_{j},\] (2.3)

where the noise \(Z_{j}(,^{2}}{|B|^{2}}I_{d})\), \(f\) denotes the loss function, \(\) the model parameters, \(_{j}\) the learning rate hyperparameter at iteration \(j\) and \(|B|\) is the expected batch size (if we carry out Poisson subsampling of mini-batches, \(|B_{j}|\) varies). There are several results that enable the RDP analysis of DP-SGD iterations (Abadi et al., 2016; Balle et al., 2018; Zhu and Wang, 2019). The following result by Zhu and Wang (2019) is directly applicable to analyzing DP-SGD, however, we also use it for analyzing a variant of our hyperparameter tuning method.

**Theorem 4** (Zhu and Wang 2019).: _Suppose \(\) is a \(,()\)-RDP mechanism, w.r.t. to the add/remove neighbourhood relation. Consider the subsampled mechanism \((_{()})(X)\), where \(_{()}\) denotes Poisson subsampling with sampling ratio \(\). If \(\) is \(,()\)-RDP then \(_{()}\) is \(,^{}()\)-RDP (\( 2\) is an integer), where_

\[^{}() =(1-)^{-1}( -+1)+^{2}(1-)^{-2}(( 2))\] \[+3_{j=3}^{}^{j}(1 -)^{-j}((j-1)(j)).\]

We remark that the recent works (Koskela et al., 2020; Gopi et al., 2021; Zhu et al., 2022) give methods to carry out \((,)\)-analysis of DP-SGD tightly. As the state-of-the-art bounds for hyperparameter tuning methods are RDP bounds (Papernot and Steinke, 2022), for simplicity, we will also analyze DP-SGD using RDP.

Intuitively, the leakage from hyperparameters is much smaller than from the model parameters, however, considering it in the final accounting is needed to ensure rigorous DP guarantees. Currently the most practical \((,)\)-guarantees for DP hyperparameter tuning algorithms are those of (Papernot and Steinke, 2022). In the results of Papernot and Steinke (2022) it is important that the number of runs \(K\) with the hyperparameter tuning is randomized. They analyze various distributions for drawing \(K\), however, we focus on using the Poisson distribution as it is the most concentrated around the mean among all the alternatives. The corresponding hyperparameter tuning algorithm and its privacy guarantees are given by Thm.5.

First recall: \(K\) is distributed according to a Poisson distribution with mean \(>0\), if for all non-negative integer values \(k\): \((K=k)=^{-}}{k!}\).

**Theorem 5** (Papernot and Steinke 2022).: _Let \(Q:\,^{N}\) be a randomized algorithm satisfying \(,()\)-RDP and \((,)\)-DP for some \((1,)\) and \(,, 0\). Assume \(\) is totally ordered. Let the Poisson distribution parameter \(>0\). Define the hyperparameter tuning algorithm \(A:\,^{N}\) as follows. Draw \(K\) from a Poisson distribution with mean \(\). Run \(Q(X)\) for \(K\) times. Then \(A(X)\) returns the best value of those \(K\) runs (both the hyperparameters and the model parameters). If \(K=0\), \(A(X)\) returns some arbitrary output. If \(^{} 1+\), then \(A\) satisfies \(,^{}()\)-RDP, where \(^{}()=()++ \)._

## 3 DP Hyperparameter Tuning with a Random Subset

We next consider our main tool: we carry out the private hyperparameter tuning on a random subset, and if needed, extrapolate the found hyperparameter values to larger datasets that we use for training subsequent models. In our approach the subset of data used for tuning is generally smaller than the data used for training the final model and thus we extrapolate the hyperparameter values.

### Our Method: Small Random Subset for Tuning

Our method works as below:

1. Use Poisson subsampling to draw \(X_{1} X\): draw a random subset \(X_{1}\) such that each \(x X\) is included in \(X_{1}\) with probability \(q\).
2. Compute \((_{1},t_{1})=_{}(X_{1})\), where \(_{}\) is a hyperparameter tuning algorithm (e.g., the method by Papernot and Steinke, 2022) that outputs the vector of optimal hyperparameters \(t_{1}\) and the corresponding model parameters \(_{1}\).
3. If needed, extrapolate the hyperparameters \(t_{1}\) to the dataset \(X X_{1}\): \(t_{1} t_{2}\).
4. Compute \(_{2}=_{}(_{1},t_{2},X X_{1})\), where \(_{}\) is the base mechanism (e.g., DP-SGD).

Denote the whole mechanism by \(\). Then, we may write

\[(X)=_{}(X_{1}),_{ }_{}(X_{1}),X X_{1} \,,\] (3.1)

where \(X_{1}_{(q)}(X)\). Additionally, we consider a variation of our method in which we use the full dataset \(X\) instead of \(X X_{1}\) from step 3 onwards, i.e., the mechanism

\[(X)=_{}(X_{1}),_{ }_{}(X_{1}),X\,,\] (3.2)

where \(X_{1}_{(q)}(X)\). We call these methods variant 1 and variant 2, respectively. The RDP bounds for the variant 2 can be obtained with a standard subsampling and composition result (e.g., Thm 4). We provide a tailored privacy analysis of the variant 1 in Section 3.3.

### Extrapolating the DP-SGD Hyperparameters

We use simple heuristics to transfer the optimal hyperparameter values found for the small subset of data to a larger dataset. The clipping constant \(C\), the noise level \(\), the subsampling ratio \(\) and the total number of iterations \(T\) are kept constant in this transfer. As a consequence the \((,)\)-privacy guarantees are also the same for the models trained with the smaller and the larger dataset. For scaling the learning rate, we use the heuristics used by van der Veen et al. (2018): we scale the learning rate \(\) with the dataset size. I.e., if we carry out the hyperparameter tuning using a subset of size \(m\) and find an optimal value \(^{*}\), we multiply \(^{*}\) by \(n/m\) when transferring to the dataset of size \(n\).

This can be also heuristically motivated as follows. Consider \(T\) iterations of the DP-SGD (2.3). With the above rules, the distribution of the noise that gets injected into the model trained with dataset of size \(n\) is

\[_{j=1}^{T}Z_{j}(0,^{ *}^{2}^{2}C^{2}}{( n)^{2}}I_{d}) (0,^{2}C^{2}}{( m)^{2}}I_{d})\]

which is exactly the distribution of the noise that was added to the model trained with the subsample of size \(m\). This principle of keeping the noise constant when scaling the hyperparameters was also used by Sander et al. (2022).

We arrive at our scaling rule also by taking a variational Bayesian view of DP-SGD. Mandt et al. (2017) model the stochasticity of the SGD mini-batch gradients in a region approximated by a constant quadratic convex loss by invoking the central limit theorem, and arrive at a continuous-time multivariate Ornstein-Uhlenbeck (OU) process for which the discrete approximation is given by

\[=- g()+}L W, W (0,I_{d}),\] (3.3)

where \(|B|\) denotes the batch size of the SGD approximation, \(g()\) the full gradient and \(LL^{T}\) the covariance matrix of the SGD noise. By minimizing the Kullback-Leibler divergence between the stationary distribution of this OU-process and the Gaussian posterior distribution \(f()(-n())\), where \(()\) denotes the quadratic loss function and \(n\) is the size of the dataset, they arrive at the expression

\[^{*}=2(LL^{T})}\]

for the optimal learning rate value (see Thm. 1, Mandt et al., 2017). We consider the case where the additive DP noise dominates the SGD noise, and instead of the update (3.3) consider the update

\[=- g()+ W,  W(0,I_{d})\] (3.4)

which equals the DP-SGD update (2.3) with the mini-batch gradient replaced by the full gradient. Essentially the difference between (3.3) and (3.4) is \(\) replaced by \(|B|\), and by the reasoning used in (Thm. 1, Mandt et al., 2017), we see that the learning rate value that minimizes the KL divergence between the approximate posterior and the Gaussian posterior \(f()\) is then given by

\[^{*}=2}{n}(^{2}C^{2}I)}=2 }{n^{2}C^{2}}=2n}{^{2}C^{2}}.\] (3.5)

The scaling rule (3.5) also indicates that the optimal value of the learning rate should be scaled linearly with the size of the dataset in case \(\), \(\) and \(C\) are kept constant.

Training of certain models benefits from use of adaptive optimizers such as Adam (Kingma and Ba, 2014) or RMSProp, e.g., due to sparse gradients. Then the above extrapolation rules for DP-SGD are not necessarily meaningful anymore. In our experiments, when training a neural network classifier using Adam with DP-SGD gradients, we found that keeping the value of the learning rate fixed in the transfer to the larger dataset lead to better results than increasing it as in case of DP-SGD. We mention that there are principled ways of extrapolating the hyperparameters in non-DP setting such as those of Klein et al. (2017).

### Privacy Analysis

The RDP analysis of the variant 2 given in Equation (3.2) is straightforward. Since the tuning set \(X_{1}\) is sampled with Poisson subsampling with subsampling ratio \(q\), we may write the mechanism as an adaptive composition

\[(X)=(}_{}(X),_ {}}_{}(X),X\,,\]

where \(}_{}(X)=(_{} _{(q)})(X)\). Using the RDP values given by Thm. 5 for \(_{}\) and the subsampling amplification result of Thm. 4, we obtain RDP bounds for \(}_{}(X)\). Using RDP bounds for \(_{}\) (e.g., DP-SGD) and RDP composition results, we further get RDP bounds for the mechanism \(\) given in (3.2).

**Tailored RDP-Analysis.** When we use the variant (3.1), i.e., we only use the rest of the data \(X X_{1}\) for \(_{}\), we can get even tighter RDP bounds. The following theorem gives tailored RDP bounds for the mechanism (3.1). Similarly to the analysis by Zhu and Wang (2019) for the Poisson subsampled Gaussian mechanism, we obtain RDP bounds using the RDP bounds of the non-subsampled mechanisms and by using binomial expansions (the proof is given in Appendix C).

**Theorem 6**.: _Let \(\) be the mechanism (3.1), such that the subset \(X_{1}\) is Poisson sampled with subsampling ratio \(q\), \(0 q 1\) and let \(>1\). Denote by \(_{}()\) and \(_{}()\) the RDP-values of mechanisms \(_{}\) and \(_{}\), respectively. Then, \(\) is \((,())\)-RDP for_

\[()=\{_{1}(),_{2}()\},\]_where_

\[&_{1}()=(q^{ }((-1)_{}())+(1-q )^{}((-1)_{}()) .\\ &+_{j=1}^{-1} q^{-j}(1-q )^{j}((-j-1)_{}(-j)) ((j-1)_{}(j)))\] (3.6)

_and_

\[&_{2}()=( (1-q)^{-1}((-1)_{}() ).\\ &+_{j=1}^{-1} q^{j}(1-q)^{ -1-j}(j_{}(j+1)) ((-j-1)_{}(-j))) .\] (3.7)

**Remark 7**.: _The RDP bound given by Thm. 6 is optimal in a sense that it approaches \(_{}()\) and \(_{}()\) as \(q 1\) and \(q 0\), respectively._

**Remark 8**.: _We can initialize the subsequent model training \(_{}\) using the model \(_{1}\). This adaptivity is included in all the RDP analyses of both mechanisms (3.1) and (3.2)._

Notice that in the bounds (3.6) and (3.7) the RDP parameter of the tuning algorithm, \(_{}()\), is weighted with the parameter \(q\) and the RDP parameter of the base algorithm, \(_{}()\), is weighted with \(1-q\). This lowers the overall privacy cost in case the tuning set is chosen small enough.

Figure 1 illustrates how the \((,)\)-bounds of the two variants (3.1) and (3.2) behave as functions of the sampling parameter \(q\) used for sampling the tuning set \(X_{1}\), when the base mechanism DP-SGD is run for 50 epochs with the subsampling ratio \(=0.01\) and noise level \(=2.0\). The bounds for the variant 1 given in Equation (3.1) are computed using the RDP results of Thm. 6 and the bounds for the variant 2 are computed using the subsampling amplification result of Thm. 4. The RDP bounds are converted to \((,)\)-bounds using the conversion rule of Lemma 3 with \(=10^{-5}\). The fact that the bounds for the variants 1 and 2 cross when \(=45\) at small values of \(q\) suggests that the bounds of Thm. 6 could still be tightened.

### Computational Savings

Our scaling approach for DP-SGD described in Section 3.2 implies that the DP-SGD subsampling ratio \(\), the noise level \(\) and the number of iterations \(T\) are the same when evaluating the private candidate models using the tuning set \(X_{1}\) and when evaluating the final model using the larger dataset.

Figure 1: Comparison of \((,)\)-bounds for the variant 1 given in Equation (3.1) and the variant 2 given in Equation (3.2) as a function of the subsampling ratio \(q\) used for sampling the tuning set \(X_{1}\). Also shown is the \((,)\)-bound for the baseline algorithm described in Thm. 5. Here \(\) refers to the expected number of model evaluations in the tuning algorithm.

Thus, if we run the base algorithm for \(\) epochs, we easily see that the expected number of required gradient evaluations for the variant 1 given in (3.1) is given by \(( q n+(1-q) n)\) and for the variant 2 given in (3.2) it is given by \(( q n+n)\), whereas the baseline requires in expectation \( n\) evaluations in case it is carrying out tuning with the same hyperparameter candidates as our method. Since the number of iterations \(T\) is kept fixed, there are some constant overheads in the compute cost such as those coming from the model updates. Therefore the actual speed ups are slightly smaller.

For example, in our experiments with \(=15\) and \(q=0.1\), the baseline requires \( 6\) times more gradient evaluations than our method and when \(=45\) and \(q=0.1\) the baseline requires \( 8\) times more gradient evaluations. The actual speed ups are shown in the figures of Section 5.

## 4 Dealing with DP-SGD Hyperparameters that Affect the DP Guarantees

Thm. 5 gives RDP-parameters of order \(\) for the tuning algorithm, assuming the underlying candidate picking algorithm is \((,())\)-RDP. In case of DP-SGD, if we are tuning the learning rate \(\) or clipping constant \(C\), and fix rest of the hyperparameters, these \((,())\)-RDP bounds are fixed for all the hyperparameter candidates. However, if we are tuning hyperparameters that affect the DP guarantees, i.e., the subsampling ratio \(\), the noise level \(\) or the length of the training \(T\), it is less straightforward to determine suitable uniform \(()\)-upper bounds. As is common practice, we consider a grid \(\) of \(\)-orders for RDP bookkeeping (e.g. integer values of \(\)'s).

### Grid Search with Randomization

To deal with this problem, we first set an approximative DP target value \((,)\) that we use to adjust some of the hyperparameters. For example, if we are tuning the subsampling ratio \(\) and training length \(T\), we can, for each choice of \((,T)\), adjust the noise scale \(\) so that the resulting training iteration is at most \((,)\)-DP. Vice versa, we may tune \(\) and \(\), and take maximal value of \(T\) such that the resulting training iteration is at most \((,)\)-DP.

More specifically, we first fix \(,>0\) which represent the target approximative DP bound for each candidate model. Denote by \((T,,,)\) the \(\)-value of the subsampled Gaussian mechanism with parameter values \(,\) and \(T\) and for fixed \(\). To each pair of \((,T)\), we attach a noise scale \(_{,T}\) such that it is the smallest number with which the resulting composition is \((,)\)-DP:

\[_{,T}=\{^{+}\;:\;(T,, ,)\}.\]

As the RDP values increase monotonously w.r.t. the number of compositions, it is straightforward to find \(_{,T}\), e.g., using the bisection method. Alternatively, we could fix a few values of \(\), and to each combination of \((,)\), attach the largest \(T\) (denoted \(T_{,}\)) such that the target \((,)\)-guarantee holds.

We consider a finite grid \(\) of possible hyperparameter values \(t\) (e.g., \(t=(,,T)\), where \(T\) is adjusted to \(\) and \(\)). Then, for all \(t\), we compute the corresponding RDP value \(_{t}()\) for each \(\). Finally, for each \(\), we set

\[()=_{t}_{t}().\]

Then, since for each random draw of \(t\), the DP-SGD trained candidate model is \(()\)-RDP, by Lemma 9 given below, the candidate picking algorithm \(Q\) is also \(()\)-RDP. This approach is used in the experiments of Figure 4, where we jointly tune \(T\), \(\) and \(\).

### RDP Analysis

For completeness, in Appendix D we prove the following result which gives RDP bounds for the case we randomly draw hyperparemeters that affect the privacy guarantees of the candidate models.

**Lemma 9**.: _Denote by \(\) the random variable of which outcomes are the hyperparameter candidates (drawing either randomly from a grid or from given distributions). Consider an algorithm \(Q\), that first randomly picks hyperparameters \(t\), then runs a randomized mechanism \((t,X)\). Suppose \((t,X)\) is \((,())\)-RDP for all \(t\). Then, \(Q\) is \((,())\)-RDP._Experimental Results

We perform our evaluations on standard benchmark datasets for classification: CIFAR-10 (Krizhevsky and Hinton, 2009), MNIST (LeCun et al., 1998), FashionMNIST (Xiao et al., 2017) and IMDB (Maas et al., 2011). Full details of the experiments are given in Appendix A. When reporting the results, we set \(=10^{-5}\) in all experiments.

**Learning rate tuning.** Figures 2 and 3 summarize the results for learning rate tuning using our methods and the baseline method by Papernot and Steinke (2022). The learning rate grid size is either 9 or 10 and the grid values are specified in Table 2 (Appendix). We fix the subsampling ratio \(\) and the number of epochs to the values given in Table 1 (Appendix) for all models. The batch sizes in the submodels are defined by scaling \(\) on the corresponding dataset sizes. We use \(q=0.1\) which means that, for example, if the Poisson subsampling of DP-SGD gives in expectation a batch size of 128 in the tuning phase of our methods, the expected batch sizes for the final models of variant 1 and 2 are 1152 and 1280, respectively. We use \(=15\) (the expected number of runs for the tuning algorithm).

**Tuning all hyperparameters.** Next, we jointly optimize the number of epochs, the DP-SGD subsampling ratio \(\), and the learning rate \(\) using the hyperparameter candidates given in Table 2 (Appendix). The remaining setup is the same as in the previous experiment. Figure 4 shows the same

Figure 2: Tuning learning rate with DP-SGD. Test accuracies are averaged across 10 independent runs and the error bars denote the standard error of the mean. The numbers in the legends refer to the mean training timings of the baseline scaled with respect to minimum of variant 1 and 2. For example, for CIFAR-10, the average training time for the baseline method is 6.06 times bigger than for the fastest of our methods. For perspective, we also add curves showing the privacy cost of training a single model with optimal hyperparameters obtained from the baseline.

quantities as Figures 2 and 3, however, higher values of \(\) are used to accommodate to increased hyperparameter spaces.

**Takeaways.** Overall, for both DP-SGD and DP-Adam, we observe that both variants of our method provide better privacy-utility trade-off and have a lower computational cost than the baseline method. Additionally, we also note the benefits of tailored analysis (Thm 6) in Figure 2 in terms of slightly higher accuracy for variant 1 compared to variant 2 for DP-SGD. In Figure 4 where we are also tuning the batch size and epochs, the noise levels are higher compared to Figure 2. One reason for slightly better privacy-utility trade-off for variant 2 with DP-SGD is possibly the fact that our tailored bound is less tight for higher values of \(\) and small values of \(q\) (see Figure 1).

## 6 Discussion

We have considered a simple strategy for lowering the privacy cost and computational cost of DP hyperparameter tuning: we carry out tuning using a random subset of data and extrapolate the optimal values to the larger training set used to train the final model. We have also provided methods to tune the hyperparameters that affect the DP guarantees of the model training themselves, those

Figure 3: Tuning learning rate with DP-Adam. Test accuracies are averaged across 10 independent runs and the error bars denote the standard error of the mean. The numbers in the legends refer to the mean training timings of the baseline scaled with respect to minimum of variant 1 and 2. For example, for FashionMNIST, the average training time for the baseline method is 9.03 times bigger than the fastest of our methods. For perspective, we also add curves showing the privacy cost of training a single model with optimal hyperparameters obtained from the baseline. Figure 6 (Appendix) shows a more detailed version of this plot.

being the noise level and subsampling ratio in case of DP-SGD. Our experiments show a clear improvement over the baseline method by Papernot and Steinke (2022) when tuning DP-SGD for neural networks and using simple but well-justified heuristics for the extrapolation. One obvious limitation of our method is that it is limited to DP-SGD although we show also positive results for the Adam optimizer combined with DP-SGD gradients. Finding out whether effective scaling rules could be derived for DP-SGD with momentum, DP-FTRL (Kairouz et al., 2021) or more refined adaptive DP optimizers such as DP\({}^{2}\)-RMSprop (Li et al., 2023), is left for future work. An interesting avenue of future work is also to find more black-box type of extrapolation methods, something that has been considered in the non-DP case (see, e.g. Klein et al., 2017). Another interesting question is how to carry out more accurate privacy analysis using the so-called privacy loss distributions (PLDs) and numerical accounting. The main reason for using RDP instead of PLD accounting in this work was that the tightest privacy bounds for DP hyperparameter tuning are given in terms of RDP. We have used Poisson subsampling to obtain the tuning set as it is relatively easy to analyze, however, other sampling methods could be analyzed as well.

Figure 4: Tuning of subsampling ratio, training epochs, and learning rate with DP-SGD. Test accuracies are averaged across 10 independent runs and the error bars denote the standard error of the mean. The numbers in the legends refer to the mean timings of the baseline method scaled with respect to the minimum of variant 1 and 2. For perspective, we also add curves showing the privacy cost of training a single model with optimal hyperparameters obtained from the baseline. Figure 7 (Appendix) shows a more detailed version of this plot.

## 7 Broader Impact Statement

Our present work makes DP machine learning more appealing and potentially more widespread in practice. This can improve privacy protection in general but can also carry negative side effects. The proposed method can make DP learning more appealing by improving DP hyperparameter tuning leading to higher utility machine learning models at equivalent provable total privacy cost. Our method has lower compute cost than some alternatives, potentially leading to considerable resource savings. While DP gives strong privacy guarantees, it may have negative impacts as well, as some DP learning methods have for example been shown to have a relatively lower utility for minorities.