# Addressing Spectral Bias of Deep Neural Networks by Multi-Grade Deep Learning

Ronglong Fang, Yuesheng Xu

Department of Mathematics and Statistics, Old Dominion University

{rfang002, ylxu}@odu.edu

Corresponding author: yixu@odu.edu

###### Abstract

Deep neural networks (DNNs) have showcased their remarkable precision in approximating smooth functions. However, they suffer from the _spectral bias_, wherein DNNs typically exhibit a tendency to prioritize the learning of lower-frequency components of a function, struggling to effectively capture its high-frequency features. This paper is to address this issue. Notice that a function having only low frequency components may be well-represented by a shallow neural network (SNN), a network having only a few layers. By observing that composition of low frequency functions can effectively approximate a high-frequency function, we propose to learn a function containing high-frequency components by composing several SNNs, each of which learns certain low-frequency information from the given data. We implement the proposed idea by exploiting the multi-grade deep learning (MGDL) model, a recently introduced model that trains a DNN incrementally, grade by grade, a current grade learning from the residue of the previous grade only an SNN (with trainable parameters) composed with the SNNs (with fixed parameters) trained in the preceding grades as features. We apply MGDL to synthetic, manifold, colored images, and MNIST datasets, all characterized by presence of high-frequency features. Our study reveals that MGDL excels at representing functions containing high-frequency information. Specifically, the neural networks learned in each grade adeptly capture some low-frequency information, allowing their compositions with SNNs learned in the previous grades effectively representing the high-frequency features. Our experimental results underscore the efficacy of MGDL in addressing the spectral bias inherent in DNNs. By leveraging MGDL, we offer insights into overcoming spectral bias limitation of DNNs, thereby enhancing the performance and applicability of deep learning models in tasks requiring the representation of high-frequency information. This study confirms that the proposed method offers a promising solution to address the spectral bias of DNNs. The code is available on GitHub: Addressing Spectral Bias via MGDL.

## 1 Introduction

Deep neural networks (DNNs) have achieved tremendous success in various applications, including computer vision , natural language processing , speech recognition , and finance . From a mathematical perspective, the success is mainly due to their high expressiveness, as evidenced by theoretical demonstrations showing their capability to approximate smooth functions with arbitrary precision . Various mathematical aspects of DNNs as an approximation tool were recently investigated in . However, it was noted in  that the standard deep learning model, which is called single grade deep learning (SGDL) in this paper,trains a DNN end-to-end leading to learning bias towards low-frequency functions. While this bias may explain the phenomenon where DNNs with a large number of parameters can achieve low generalization error [7; 40; 41], DNNs trained by SGDL struggle to capture high-frequency components within a function even though they can well-represent its low-frequency components. This bias may potentially limit the applicability of DNNs to problems involving high-frequency features, such as image reconstruction [12; 24; 37], seismic wavefield modeling , high-frequency wave equations in homogenization periodic media , and high energy physics . Especially, in medical image reconstruction such as PET/SPECT, high-frequency components play a crucial role in determining image resolution, which is critical in clinical practice, as higher resolution leads to earlier and more accurate disease diagnosis.

There have been some efforts to address this issue. A phrase shift DNN was proposed in , where the original dataset was first decomposed into subsets with specific frequency components, the high-frequency component was shifted downward to a low-frequency spectrum for learning, and finally, the learned function was converted back to the original high frequency. An adaptive activation function was proposed in  to replace the traditional activation by scaling it with a trainable parameter. A multiscale DNN was introduced in [6; 23], in which the input variable was first scaled with different scales and then the multiscale variables were combined to learn a DNN. It was proposed in  first to map the input variable to Fourier features with different frequencies and then to train the mapped data by DNNs. All these approaches can mitigate the spectral bias issue of DNNs to some extent.

Despite of encouraging progresses made in mitigating the spectral bias of DNNs, practical learning with DNNs remains a persistent challenge due to the bias, especially for learning from higher-dimensional data. This issue deserves further investigation. We propose to address this issue by understanding how a high-frequency function can be more accurately represented by neural networks. On one hand, it has been observed [7; 30; 31] that a function having only low frequency components can be well represented by a shallow neural network (SNN), a network having only a few layers. On the other hand, the classical Jacobi-Anger identity expresses a complex exponential of a trigonometric function as a linear combination of its harmonics that can contain significant high-frequency components. Even though the complex exponential function and the trigonometric function both are of low frequency, their composition could contain high frequency components. This motivates us to decompose a function containing high-frequencies as a _sum-composition_ form of low-frequency functions. That is, we decompose it into a sum of different frequency components, each of which is further broken down to a _composition of low-frequency functions_. In implementing this idea, we find that the multi-grade deep learning (MGDL) model recently introduced in [43; 44] matches seamlessly for constructing the sum-composition form for a function of high-frequency. It is the purpose of this study to introduce the general methodology in addressing the spectral bias issue of DNNs and implement it by employing MGDL as a technical tool. We demonstrate the efficacy of the proposed approach in four experiments with one-dimensional synthetic data, two-dimensional manifold data, two-dimensional colored images, and very high-dimensional modified National Institute of Standards and Technology (MNIST) data. Our numerical results endorse that the proposed approach can effectively address the spectral bias issue, leading to substantial improvement in approximation accuracy in comparison with the traditional SGDL training approach.

**Contributions** of this paper include: (a) We propose a novel approach to address the spectral bias issue by decomposing a function containing high-frequencies as a sum of different frequency components, which are represented as compositions of low-frequency functions. (b) We investigate the efficacy of MGDL in decomposing a function of high-frequency into its "sum-composition" form of SNNs. (c) We successfully apply the proposed approach to synthetic data in 1 and 2 dimensions and real data in 2 and 784 dimensions, showing that it can effectively address the spectral bias issue.

## 2 Proposed Approach and Multi-Grade Learning Model

We introduce a novel approach to tackle the spectral bias issue and review the MGDL model.

We begin with a quick review of the definition of DNNs. A DNN is a successive composition of an activation function composed with a linear transformation. Let \(\) denote the set of all real numbers, and \(d,s\) be two positive integers. A DNN with depth \(D\) consists of an input layer, \(D-1\) hidden layers, and an output layer. Let \(_{D}:=\{1,2,,D\}\). For \(j\{0\}_{D}\), let \(d_{j}\) denote the number of neurons in the \(j\)-th hidden layer with \(d_{0}:=d\) and \(d_{D}:=s\). We use \(_{j}^{d_{j} d_{j-1}}\) and \(_{j}^{d_{j}}\)to represent the weight matrix and bias vector, respectively, for the \(j\)-th layer. By \(:\) we denote an activation function. When \(\) is applied to a vector, it means that \(\) is applied to the vector componentwise. For an input vector \(:=[x_{1},x_{2},,x_{d}]^{}^{d}\), the output of the first layer is defined by \(_{1}():=(_{1}+ _{1}).\) For a DNN with depth \(D 3\), the output of the \((j+1)\)-th hidden layer can be identified as a recursive function of the output of the \(j\)-th hidden layer, defined as \(_{j+1}():=(_{j+1}_{j} ()+_{j+1}),\) for \(j_{D-2}\). Finally, the output of the DNN with depth \(D\) is an \(s\)-dimensional vector-valued function defined by

\[_{D}(\{_{j},_{j}\}_{j=1}^{D}; )=_{D}():=_{D}_{D- 1}()+_{D}.\] (1)

Suppose that data samples \(:=\{_{},_{}\}_{=1}^{N}\) are chosen. The loss on \(\) is defined as

\[(\{_{j},_{j}\}_{j=1}^{D}; ):=_{=1}^{N}\|_{ }-_{D}(\{_{j},_{j}\}_{j=1}^ {D};)(_{})\|_{2}^{2}.\] (2)

The traditional SGDL model is to minimize the loss function \(L\) defined by (2) with respect to \(:=\{_{j},_{j}\}_{j=1}^{D}\), which yields the optimal parameters \(^{*}:=\{_{j}^{*},_{j}^{*}\}_{j=1}^{D}\) and the corresponding DNN \(_{D}(^{*};)\). When \(D\) is relatively small, for example, \(D<5\), we call \(_{D}\) an SNN. It is well-recognized that training an SNN is notably easier than training a DNN.

We motivate the proposed idea by a simple example. We consider the function \(f()\), \(\), whose Fourier transform is shown in Figure 1 (Left), where the Fourier transform is defined by \(():=_{-}^{}f()e^{-i2 }d\). To compute the Fourier transform of \(f\) defined on \(\), we extend \(f\) to the entire real line by assigning its value to be zero for \(\). Observing from Figure 1 (Left), the function \(f\) has significant high-frequency components, with frequencies varying from \(0\) to \(200\). The function \(f\) can be represented as

\[f()=f_{1}()+(f_{2} f_{1})()+(f_{3} f_{ 2} f_{1})()+(f_{4} f_{3} f_{2} f_{1})(),\ \ ,\] (3)

where \(\) denotes the composition of two functions. Note that the Fourier transforms \(_{j}\), \(j=1,2,3,4\), are displayed in Figure 1 (Right). Clearly, the functions \(f_{j}\), \(j=1,2,3,4\), are of low-frequency, with frequencies mainly concentrating on the interval \(\). This example surely demonstrates that a function of high-frequency can be expressed as a sum of compositions of lower-frequency functions. This observation leads to the proposed approach of addressing the spectral bias of DNNs to be studied in this paper. The legitimacy of the proposed idea may be reinforced by the Jacobi-Anger identity , which expresses a complex exponential of a trigonometric function as a linear combination of its harmonics. Even though both the complex exponential function and the trigonometric function are of low-frequency, their composition contains many high-frequency components. We now review the Jacobi-Anger identity, the identity named after the 19th-century mathematicians Carl Jacobi and Carl Theodor Anger. It has the form

\[e^{ia(b)}=_{n=-}^{}J_{n}(a)e^{inb },\] (4)

where \(i\) denotes the imaginary unit and \(J_{n}(a)\) denotes the \(n\)-th Bessel function of the first kind, see details in . Taking the real part of the both sides of the Jacobi-Anger identity (4), we obtain that

\[(a(b))=_{n=-}^{}J_{n}(a)(nb ).\] (5)

The left-hand side of (5) is a composition of two low-frequency functions \((a)\) and \((b)\), having frequencies \(a/(2)\) and \(b/(2)\), respectively, while the right-hand side is a linear combination of \((nb)\) with \(n\) taking all integers. The high-frequency of the composition can be estimated by a rule of thumb. Specifically, the left-hand side of (5) is a frequency-modulated sinusoidal signal , with its frequencies spreading on an interval centered at zero. It follows from the well-known Carson bandwidth rule , regarded as a rule of thumb, that more than \(98\%\) frequencies are located within the interval \([-(ab+b)/(2),(ab+b)/(2)]\). Therefore, the highest frequency of \((a(b))\) can be well-estimated by \(\), which is greater than the frequencies of \((a)\) and \((b)\) when \(a>0\) and \(b>1\). These suggest that a composition of two low-frequency functions may lead to a high-frequency function.

The example presented earlier, together with the Jacobi-Anger identity, inspires us to decompose a given function into a sum of different frequency components, each of which is a composition of lower-frequency functions, a decomposition similar to equation (3) for the function \(f\) represented in Figure 1 (Left). In other words, for a function \(g\) of high-frequency, we decompose it in a "sum-composition" form as

\[g=_{k=1}^{K}_{j=1}^{k}g_{j},\] (6)

where \(_{j=1}^{k}g_{j}:=g_{k} g_{2} g_{1}\), and \(g_{j}\), \(j_{k}\), are all of low-frequency. The function \(f\) represented in (3) is a special example of (6). In the context of approximation by neural networks, we prefer expressing \(g_{j}\) by SNNs, as a function having only low-frequency components can be well-represented by an SNN. The MGDL model originated in  furnishes exactly the decomposition (6), with each \(g_{j}\) being an SNN. We propose to employ MGDL to learn the decomposition (6), where the low-frequency function \(g_{j}\) is represented by an SNN.

It is worth explaining the motivation behind the MGDL model. MGDL was inspired by the human education system which is arranged in grades. In such a system, students learn a complex subject in grades, by decomposing it into sequential, simpler topics. Foundational knowledge learned in previous grades remains relatively stable and serves as a basis for learning in a present and future grades. This learning process can be modeled mathematically by representing a function that contains higher-frequency components by a "sum-composition" form of low-frequency functions. MGDL draws upon this concept by decomposing the learning process into multiple grades, where each grade captures different levels of complexity.

We now review the MGDL model that learns given data \(:=\{_{},_{}\}_{=1}^{N}\). Following , we split a DNN with depth \(D\) into \(L\) grades, with \(L<D\), each of which learns an SNN \(_{D_{l}}\), defined as (1), with depth \(D_{l}\), from the residue \(\{_{}^{l}\}_{=1}^{N}\) of the previous grade, where \(1<D_{l}<D\) and \(_{l=1}^{L}D_{l}=D+L-1\). Let \(_{l}:=_{j}^{l},_{j}^{l}}_{j=1}^{D_{ l}}\) denote the parameters to be learned in grade \(l\). We define recursively \(g_{1}(_{1};):=_{D_{1}}(_{1};)\), \(g_{l+1}(_{l+1};):=_{D_{l+1}}(_{l+1}; )_{D_{l}-1}(_{1}^{*};) _{D_{1}-1}(_{1}^{*};)()\), for \(l_{L-1}\), and the loss function of grade \(l\) by

\[_{l}(_{l};):=_{ =1}^{N}_{}^{l}-g_{l}(_{l};_{ })_{2}^{2},\] (7)

where \(_{l}^{*}:=_{j}^{l*},_{j}^{l*}}_{j=1}^ {D_{l}}\) are the optimal parameters learned by minimizing the loss function \(_{l}\) with respect to \(_{l}\). The residues are defined by \(_{}^{1}:=_{}\) and \(_{}^{l+1}:=_{}^{l}-g_{l}(_{l}^{*};_{})\), for \(l_{L-1}\), \(_{N}\). When minimizing the loss function \(_{l}(_{l};)\) of grade \(l\), parameters \(_{j}^{*}\), \(j_{l-1}\), learned from the previous \(l-1\) grades are all _fixed_ and \(_{D_{l-1}-1}(_{l-1}^{*};)_{D_{ l-1}}(_{1}^{*};)\) serves as a feature or "basis". After \(L\) grades are learned, the function \(_{L}\) learned from MGDL is the summation of the function learned in each grade, that is,

\[_{L}(\{_{l}^{*}\}_{l=1}^{L};):= _{l=1}^{L}g_{l}(_{l}^{*};),\] (8)

where \(g_{l}(_{l}^{*};):=_{D_{l}}(_{l}^{*}; )_{D_{l-1}-1}(_{l-1}^{*};) _{D_{l-1}}(_{1}^{*};)()\), and \(_{D_{L-1}-1}\) for \(1 k L\) and \(_{D_{L}}\) are SNNs learned in different grades. Thus, MGDL enables us to construct the desired "sum-composition" form (6). When \(L=1\), MGDL reduces to the traditional SGDL model.

In MGDL, we use the mean squared error (MSE) loss function. It was established in  that when the loss function is defined by MSE, MGDL either learns the zero function or results in a strictly decreasing residual error sequence (see, Theorem 1 in Appendix A). Since the regression problems conducted in this paper naturally align with MSE losses, it is a suitable choice. In practice, MGDL can also be applied with other loss functions, such as cross-entropy loss, when solving classification problems. In MGDL, the computation cost remains relatively consistent across all grades. For \(_{}^{l}:=_{D_{l-1}-1}(_{l-1}^{*};) _{D_{l-2}-1}(_{l-2}^{*};)_{D_{ 1}-1}(_{1}^{*};)(_{})\), we recursivelylet \(_{}^{1}:=_{},\ \ _{}^{2}:=_{D_{n-1} -1}(_{k-1}^{*};)_{}^{k-1},\ \ k=2,3,,n\). When training grade \(l\), we use the output of grade \(l-1\), denoted as \(_{}^{l}\) along the residual \(_{}^{l}\), which are already obtained. The training dataset in grade \(l\) consists of \(\{(_{}^{l},_{}^{l})\}_{=1}^{N}\). This dataset is used to train a new shallow network, which is independent of the previous \(l-1\) grades. Moreover, \(_{}^{l}\) can be computed recursively, ensuring that the computation cost for each grade remains relatively consistent.

MGDL avoids training a DNN from end to end. Instead, it trains several SNNs sequentially, with the current grade making use the SNNs learned from the previous grades as a feature and composing it with a new SNN to learn the residue of the previous grade. This allows MGDL to decompose a function that contains higher-frequency in a form of (6), with \(g_{j}\) being a SNN learned from grade \(j\). In this way, higher-frequency components in the data can be effectively learned in a grade-by-grade manner. Note that the training time of MGDL increases linearly with the number of grades. This makes MGDL an effective and scalable solution for tackling complex tasks. MGDL is an adaptive approach by nature. When the outcome of the present grade is not satisfactory, we can always add a new grade without changing the previous grades.

It is worth noting that while ResNet  also has a sum-composition form, MGDL differs from it significantly. The "Composition" for ResNet refers to composition of layers, while that for MGDL emphasizes the composition of the SNNs sequentially learned in the previous grades. Moreover, ResNet learns all parameters of the entire sum of DNNs at once, training it from end to end, whereas MGDL learns the sum incrementally, grade by grade, in each grade training an SNN composed with the feature (the composition of the SNNs learned in the previous grades). MGDL also differs from the relay backpropagation approach proposed in , where a DNN is divided into multiple segments, each with its own loss function. The gradients from these losses are then propagated to lower layers of their respective segments and all segments are optimized all together by minimizing the sum of the losses. While MGDL trains SNNs in a multi-grade manner, each of which learns from the residue of the previous grade, freezing the previously learned SNNs (serving as features or "bases").

MGDL is a principle applicable to various models, including standard DNNs, convolutional neural networks, and ResNet. In this paper, we demonstrate its feasibility by applying it to standard DNNs.

## 3 Numerical Experiments

In this section, we study MGDL empirically in addressing the spectral bias issue of SGDL. We consider four examples: Subsections 3.1, 3.2, and 3.4 investigate regression on synthetic, manifold, and MNIST data, respectively, for which the spectral bias phenomena of SGDL are identified in . Section 3.3 deals with regression on colored images, which were studied in  by using the Fourier features to mitigate the spectral bias. Our goal is to compare the learning performance of MGDL with that of SGDL on these datasets and understand to what extent MGDL can overcome the spectral bias exhibited in SGDL.

The loss functions defined in (2) for SGDL and (7) for MGDL are used to compute the training and validation loss when \(\) is chosen to be the training and validation data, respectively. We use the relative squared error (RSE) to measure the accuracy of predictions obtained from both SGDL and MGDL. Assume that \(\) is a trained neural network. For a prediction value \(}_{}:=(_{})\) at \(_{}\), we define \(:=_{=1}^{N}\|}_{}-_{}\|_{2} ^{2}/_{=1}^{N}\|_{}\|_{2}^{2}\). When \(\) represents the training, validation, and testing data, RSE is specialized as TrRSE, VaRSE, and TeRSE, respectively.

Details of the numerical experiments conducted in this section, including computational resources, the network structure of SGDL and MGDL for each example, the choice of activation function, the optimizer, parameters used in the optimization process, and supporting figures are provided in Appendix B.

**3.1 Regression on the synthetic data.** In this experiment, we compare the efficacy of SGDL and MGDL in learning functions of four different types of high-frequencies.

The experiment setup is as follows. Given frequencies \(:=(_{1},_{2},,_{M})\) with corresponding amplitudes \(:=(_{1},_{2},,_{M})\), and phases \(:=(_{1},_{2},,_{M})\), we consider approximating the function \(:\) defined by

\[():=_{j=1}^{M}_{j}(2_{j }+_{j}),\] (9)

by neural networks learned with SGDL and MGDL. We consider four settings, in all of which we choose \(M:=20\), \(_{j}:=10j\) and \(_{j}(0,2)\) for \(j_{20}\), where \(\) denotes the uniform 

[MISSING_PAGE_FAIL:6]

Figure 3 compares the progress of the training and validation losses against the number of training epochs for SGDL and MGDL across the four settings. We observe that when learning a task involving high-frequency components by SGDL, the training and validation losses decrease slowly due to the spectral bias of DNN. While the same task is learned by MGDL, the learning process progresses through distinct grades. In grade 1, MGDL primarily learns low-frequency, resulting in a slow decrease in loss. In grade 2, the training loss and validation loss both decrease more rapidly due to the use of the composition of SNN \(_{2}^{*}\) with the feature \(_{1}^{*}\), facilitating in learning high-frequency features. This accelerated learning aspect of MGDL is further evidenced in grades 3 and 4 (as well as grade 5 for setting 4). Table 1 compares the accuracy achieved by SGDL and MGDL. Within a comparable or even less training time, MGDL increases accuracy, measured by TeRSE from \(10^{-1}\) to \(10^{-5}\), \(10^{-3}\) to \(10^{-6}\), \(10^{-1}\) to \(10^{-5}\), and \(10^{-1}\) to \(10^{-3}\) in settings 1, 2, 3 and 4, respectively. Across the four settings, TeRSE values are reduced by a factor of \(592 7,058\). These comparisons highlight MGDL's advantage in effectively learning high-frequency oscillatory functions.

Figure 8 in Appendix B.1 depicts the functions, in the Fourier domain, learned by SGDL (row 1) and MGDL (row 2) across the four settings, demonstrating that MGDL has a substantial reduction in the'spectral bias' exhibited in SGDL. This is because high-frequency components are learned in a higher grade, where they are represented as the composition of a low-frequency component with the low-frequency components learned in the previous grades, and each grade focuses solely on learning a low-frequency component by an SNN. We also include Figure 9 in Appendix B.1 to compare the spectrum evolution between SGDL (1st row) and MGDL (2nd row) across settings 1-4. Notably, although in iterations SGDL and MGDL both learn low-frequency components first and then followed by middle and high-frequency components, MGDL learns in grade by grade, exhibiting significant outperformance.

**3.2 Regression on the manifold data.** The second experiment compares regression by SGDL and MGDL on two-dimensional manifold data, studied in  but with twice higher frequencies.

The goal of this experiment is to explore scenarios where data lies on a lower-dimensional manifold embedded within a higher-dimensional space. Such data is commonly referred to as manifold data . Let \(\) be an injective mapping from \(^{m}^{d}\) with \(m d\) and \(:=(^{m})\) denote the manifold data. A target function \(:\) defined on the manifold can be identified with function \(:=\) defined on \(^{m}\). Regressing the target function \(\) is therefore equivalent to finding \(f:^{d}\) such that \(f\) matches \(\). Following , we set \(m:=1\), \(d:=2\), and choose the mapping \(\) as

\[_{q}():=[1+(2 q)/2]((2 ),(2)),\ \ ,\] (10)

for a nonnegative integer \(q\). Clearly, \(_{q}:^{2}\), and \(:=_{q}()\) defines the manifold corresponding to a flower-shaped curve with \(q\) petals when \(q>0\), and a unit circle when \(q=0\). Suppose that \(:\) is the function defined by (9). Our task is to learn a DNN \(f:^{2}\) such that \(f_{q}\) matches \(\). We consider two settings for \(\). In settings 1 and 2, we choose \(_{j}:=0.025j\) and \(_{j}():=e^{-}(j)\) for \(j_{40}\), respectively. For both the settings, we choose \(_{j}:=10j\) and \(_{j}(0,2)\) for \(j_{40}\) with the random seed set to be \(0\), and consider the cases where \(q:=4\) and \(q:=0\). Note that the smaller \(q\) is, the more difficult the learning task is. The training data consists of pairs \(\{_{q}(_{}),(_{})\}_{ _{10200}}\), where \(_{}\)'s are equally spaced between \(0\) and \(1\). The validation and testing data consist of pairs \(\{_{q}(_{}),(_{})\}_{ _{4000}}\), where \(_{}\)'s are generated from a random uniform distribution on \(\), with random seed set to be 0 and 1, respectively.

Numerical results for this example are reported in Figures 4-5, and 10 (in Appendix B.2), and Table 2. Figure 4 illustrates the frequency of functions learned across four grades of MGDL for settings 1 and 2, where \(q:=0\). In both of the settings, MGDL exhibits a pattern of learning low-frequency components in grade \(1\), middle-frequency components in grade \(2\), and high-frequency components in grades \(3\) and \(4\). Therefore, the high-frequency components within the function mainly learned in higher grades, in which the learned function is a composition of the SNNs learned from several grades. That is, MGDL decomposes a high-frequency component as the composition of several lower-frequency components, facilitating effectively learning high frequency features within the data.

Table 2 compares the approximation accuracy achieved by SGDL and MGDL for settings 1 and 2. For SGDL, reducing the value of \(q\) makes the learning task for both settings more challenging, due to the spectral bias of DNNs. When \(q:=4,0\) in setting 1 and \(q:=0\) in setting 2, learning becomes especially challenging for SGDL. In such cases, MGDL significantly outperforms SGDL by achieving higher accuracy in approximately half to one-third of the training time for both settings. Figure 5 displays the training and validation loss for SGDL and MGDL. Figure 10 illustrates the

[MISSING_PAGE_EMPTY:8]

"9". We represent each digit \(j=0,1,,9\) by a one-hot vector \(e_{j+1}^{10}\), whose \((j+1)\)-th component is one and all others are zero, and denote by \(_{0}:^{784}^{10}\) the classifier, which is a piecewise constant function defined by \(_{0}():=e_{j+1}\) if \(\) represents the digit \(j\). We split the available training samples to form the training and validation data, denoted as \(_{0}:=\{_{},_{0}(_{})\}_{ _{net_{train}}}\) and \(^{}{}_{0}:=\{^{}{}_{},_{0}(^{}{}_{})\}_{_{net_{val}}}\) respectively, with \(n_{train}:=45,000\) and \(n_{val}:=15,000\), and use the testing samples as the testing data, denoted as \(^{}{}_{0}:=\{^{}{}_{},_{0 }(^{}{}_{})\}_{_{net_{test}}}\) with \(n_{test}:=10,000\).

Clearly, \(_{0}\), \(_{0}{}^{}\) and \(^{}\) are subsets of \(\{^{784},\{e_{j+1}\}_{j=0}^{9}\}\). Letting \(_{}():=(2\|\|_{2})\), corresponding to a radial wave defined on the input space \(^{784}\), we define the target function by \(_{,}():=_{0}()(1+_{ }()),\) where \(\) is the frequency of the wave and \(\) is the amplitude. Note that \(_{0}\) and \(_{}\) contribute respectively the lower-frequency and high-frequency components (regarded as noise) of the target function \(_{,}\), as discussed in . The modified training and validation data denoted by \(_{,}:=\{_{},_{,}(_{})\}_{_{net_{train}}}\) and \(^{}_{,}:=\{^{}_{},_ {,}(^{}_{})\}_{_{net_{val}}}\), respectively, are used to train DNNs. Our goal is to use SGDL and MDGL to regress the modified data \(_{,}\) through minimizing their respective training loss, to compare their robustness to noise. The training loss is evaluated on \(_{,}\) and validation loss is on \(^{}_{,}\). TrRSE, VaRSE, and TeRSE are evaluated on \(_{,}\), \(^{}_{,}\), and \(^{}_{0}\), respectively, noting that \(^{}_{0}\) are test data without noise.

  image & method & grade & learning rate & time (s) & TrPSNR & TePSNR \\   &  & \(1\) & \(10^{-3}\) & \(38\) & \(20.45\) & \(20.41\) \\  & & \(2\) & \(10^{-3}\) & \(40\) & \(22.97\) & \(22.67\) \\  & & \(3\) & \(5 10^{-4}\) & \(40\) & \(25.14\) & \(23.71\) \\  & & \(4\) & \(5 10^{-4}\) & \(28\) & \(28.59\) & \(24.18\) \\   & SGDL & \)} & \(77\) & \(21.93\) & \(21.83\) \\   &  & \(1\) & \(10^{-2}\) & \(160\) & \(18.62\) & \(18.62\) \\  & & \(2\) & \(10^{-3}\) & \(173\) & \(21.57\) & \(21.50\) \\  & & \(3\) & \(10^{-3}\) & \(174\) & \(24.17\) & \(23.42\) \\  & & \(4\) & \(10^{-3}\) & \(182\) & \(27.31\) & \(24.32\) \\   & SGDL & \)} & \(685\) & \(20.43\) & \(20.39\) \\   &  & \(1\) & \(5 10^{-3}\) & \(171\) & \(17.30\) & \(17.29\) \\  & & \(2\) & \(5 10^{-3}\) & \(181\) & \(18.97\) & \(18.95\) \\   & & \(3\) & \(10^{-3}\) & \(182\) & \(20.86\) & \(20.67\) \\   & & \(4\) & \(10^{-3}\) & \(182\) & \(23.36\) & \(21.97\) \\    & SGDL & \)} & \(742\) & \(19.12\) & \(19.09\) \\  

Table 3: PSNR comparison: SGDL versus MGDL.

Figure 6: Comparison of PSNR values for SGDL and MGDL on images Cat, Sea, and Building: SGDL (a)-(c), MGDL (d)-(f).

[MISSING_PAGE_FAIL:10]