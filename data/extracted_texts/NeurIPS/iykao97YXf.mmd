# Reinforcement Learning with LTL and \(\omega\)-Regular Objectives via Optimality-Preserving Translation to Average Rewards

Reinforcement Learning with LTL and \(\)-Regular Objectives via Optimality-Preserving Translation to Average Rewards

Xuan-Bach Le\({}^{1}\)1  Dominik Wagner\({}^{1}\)1

Leon Witzman\({}^{1}\)   Alexander Rabinovich\({}^{2}\)   Luke Ong\({}^{1}\)

\({}^{1}\)NTU Singapore  \({}^{2}\)Tel Aviv University

{bach.le,dominik.wagner,luke.ong}@ntu.edu.sg

witz20001@e.ntu.edu.sg   rabinoa@tauex.tau.ac.il

These authors contributed equally to this work.

###### Abstract

Linear temporal logic (LTL) and, more generally, \(\)-regular objectives are alternatives to the traditional discount sum and average reward objectives in reinforcement learning (RL), offering the advantage of greater comprehensibility and hence explainability. In this work, we study the relationship between these objectives. Our main result is that each RL problem for \(\)-regular objectives can be reduced to a limit-average reward problem in an optimality-preserving fashion, via (finite-memory) reward machines. Furthermore, we demonstrate the efficacy of this approach by showing that optimal policies for limit-average problems can be found asymptotically by solving a sequence of discount-sum problems approximately. Consequently, we resolve an open problem: optimal policies for LTL and \(\)-regular objectives can be learned asymptotically.

## 1 Introduction

Reinforcement learning (RL) is a machine learning paradigm whereby an agent aims to accomplish a task in a generally unknown environment . Traditionally, tasks are specified via a scalar reward signal obtained continuously through interactions with the environment. These rewards are aggregated over entire trajectories either through averaging or by summing the exponentially decayed rewards. However, in many applications, there are no reward signals that can naturally be extracted from the environment. Moreover, reward signals that are supplied by the user are prone to error in that the chosen low-level rewards often fail to accurately capture high-level objectives. Generally, policies derived from local rewards-based specifications are hard to understand because it is difficult to express or explain their global intent.

As a remedy, it has been proposed to specify tasks using formulas in Linear Temporal Logic (LTL)  or \(\)-regular languages more generally . In this framework, the aim is to maximise the probability of satisfying a logical specification. LTL can precisely express a wide range of high-level behavioural properties such as liveness (infinitely often \(P\)), safety (always \(P\)), stability (eventually always \(P\)), and priority (\(P\) then \(Q\) then \(T\)).

Motivated by this, a growing body of literature study learning algorithms for RL with LTL and \(\)-regular objectives (e.g. ). However, to the best of our knowledge, all of these approaches may fail to learn provably optimal policies without prior knowledge of a generally unknown parameter such as the optimal \(\)-return mixing time  or the \(\)-recurrence time ,which depend on the (unavailable) transition probabilities of the MDP. Moreover, it is known that neither LTL nor (limit) average reward objectives are PAC (probably approximately correct) learnable . Consequently, approximately optimal policies can only possibly be found asymptotically but not in bounded time. 1

In this work, we pursue a different strategy: rather than solving the RL problem directly, we study _optimality-preserving_ translations  from \(\)-regular objectives to more traditional rewards, in particular, limit-average rewards. This method offers a significant advantage: it enables the learning of optimal policies for \(\)-regular objectives by solving a single more standard problem, for which we can leverage existing off-the-shelf algorithms (e.g. [26; 15; 30]). In this way, all future advances--in both theory and practice--for these much more widely studied problems carry over directly, whilst still enjoying significantly more explainable and comprehensible specifications. It is well-known that such a translation from LTL to discounted rewards is impossible . Intuitively, this is because the latter cannot capture infinite horizon tasks such as reachability or safety [2; 42; 19]. Hence, we instead investigate translations to limit-average rewards in this paper.

#### Contributions

We study reinforcement learning of \(\)-regular and LTL objectives in Markov decision processes (MDPs) with unknown probability transitions, translations to limit-average reward objectives and learning algorithms for the latter. In detail:

1. We prove a negative result (Proposition 4): in general it is not possible to translate \(\)-regular objectives to limit average objectives in an optimality-preserving manner if rewards are memoryless (i.e., independent of previously performed actions, sometimes called history-free or Markovian).
2. On the other hand, our main result (Theorem 12) resolves Open Problem 1 in : such an optimality-preserving translation is possible if the reward assignment may use finite memory as formalised by reward machines [23; 24].
3. To underpin the efficacy of our reduction approach, we provide the first convergence proof (Theorem 16) of an RL algorithm (Algorithm 1) for average rewards. To the best of our knowledge (and as indicated by ), this is the first proof _without assumptions on the induced Markov chains_. In particular, the result applies to multichain MDPs, which our translation generally produces, with unknown probability transitions. Consequently, we also resolve Open Problem 4 of : RL for \(\)-regular and LTL objectives can be learned in the limit (Theorem 18).

#### Outline.

We start by reviewing the problem setup in Section 2. Motivated by the impossibility result for simple reward functions, we define reward machines (Section 3). In Section 4 we build intuition for the proof of our main result in Section 5. Thereafter, we demonstrate that RL with limit-average, \(\)-regular and LTL objectives can be learned asymptotically (Section 6). Finally, we review related work and conclude in Section 7.

## 2 Background

Recall that a _Markov Decision Process (MDP)_ is a tuple \(=(S,A,s_{0},P)\) where \(S\) is a finite set of states, \(s_{0} S\) is the initial state, \(A\) is the finite set of actions and \(P:S A S\) is the probability transition function such that \(_{s^{} S}P(s,a,s^{})=1\) for every \(s S\) and \(a A\). MDPs may be graphically represented; see e.g. Fig. 0(a). We let \(_{^{1}}(S,A)=S(A S)^{*}\) and \((S,A)=(S A)^{}\) denote the set of finite runs and the set of infinite runs in \(\) respectively.

A _policy_\(:_{^{1}}(S,A)(A)\) maps finite runs to distributions over actions. We let \((S,A)\) denote the set of all such policies. A policy \(\) is _memoryless_ if \((s_{0}a_{0} s_{n})=(s^{}_{0}a^{}_{0} s^{}_ {m})\) for all finite runs \(s_{0}a_{0} s_{n}\) and \(s^{}_{0}a^{}_{0} s^{}_{m}\) such that \(s_{n}=s^{}_{m}\). For each MDP \(\) and policy \(\), there is a natural induced probability measure \(_{}^{}\) on its runs.

The desirability of policies for a given MDP \(\) can be expressed as a function \(:(S,A)\). Much of the RL literature focuses on discounted-sum \(_{^{}}^{}\) and limit-average reward objectives \(_{^{}}^{}\),which lift a reward function \(:S A S\) for single transitions to runs \(=s_{0}a_{0}s_{1}a_{1}\) as follows:

\[_{^{}}^{}():=_{ _{}^{}}[_{i=0}^{}\ ^{i} r_{i}]_{^{}}^{ }():=_{t}_{_{}^{ }}[_{i=0}^{t-1}\ r_{i}]\]

where \(r_{i}=(s_{i},a_{i},s_{i+1})\) and \((0,1)\) is the _discount factor_.

\(\)-Regular Objectives.\(\)-regular objectives (which subsume LTL objectives) are an alternative to these traditional objectives. Henceforth, we fix an alphabet \(\) and a _label function_\(:S A S 2^{}\) for transitions, where \(2^{X}\) is the power set of a set \(X\). Each run \(=s_{0}a_{0}s_{1}a_{1}s_{2}\) induces a sequence of labels \(()=(s_{0},a_{0},s_{1})(s_{1},a_{1},s_{2})\). Thus, for a set \(L(2^{})^{}\) of "desirable" label sequences we can consider the probability of a run's labels being in that set: \(_{_{}^{}}[() L]\).

**Example 1**.: For instance, an autonomous car may want to "visit a petrol station exactly once" to conserve resources (e.g. time or petrol). Consider the MDP in Fig. 0(a) where the state \(s_{1}\) represents a petrol station. We let \(=\{p\}\) (\(p\) for petrol), \((s_{0},b,s_{1})=\{p\}\), and the rest are labeled with \(\). The desirable label sequences are \(L=\{_{1}_{2}|\ i,_{i}=\{p\}\}\).

In this work, we focus on \(L\) which are \(\)-regular languages. It is well known that \(\)-regular languages are precisely the languages recognised by Deterministic Rabin Automata (DRA) :

**Definition 2**.: A DRA is a tuple \(=(Q,2^{},q_{0},,F)\) where \(Q\) is a finite state set, \(2^{}\) is the alphabet, \(q_{0} Q\) is the initial state, \(:Q 2^{} Q\) is the transition function, and \(F=\{(A_{1},R_{1}),,(A_{n},R_{n})\}\), where \(A_{i},R_{i} Q\), is the accepting condition. Let \((2^{})^{}\) be an infinite run and \(()\) the set of states visited infinitely often by \(\). We say \(\) is accepted by \(\) if there exists some \((A_{i},R_{i}) F\) such that \(\) visits some state in \(A_{i}\) infinitely often whilst visiting every state in \(R_{i}\) finitely often, i.e. \(() A_{i}\) and \(() R_{i}=\).

For example, the objective in Example 1 may be represented by the DRA in Fig. 0(b).

Thus, the desirability of \(\) is the probability of \(\) generating an accepting sequence in the DRA \(\):

\[_{}^{}()\ :=\ _{_{ }^{}}[()]\] (1)

Remarks.The class of \(\)-regular languages subsumes languages expressed by Linear Temporal Logic (LTL, see e.g. [4, Ch. 5]), a logical framework in which e.g. reachability (eventually \(P\), \( P\)), safety (always \(P\), \( P\)) and reach-avoid (eventually \(P\) whilst avoiding \(Q\), \(( Q)\,\,P\)) properties can be expressed concisely and intuitively. The specification of our running Example 1 to visit the petrol station exactly once can be expressed as the LTL formula \(( p)\,\,(p p)\), where \( Q\) denotes "\(Q\) holds at the next step". Furthermore, our label function \(\), which maps transitions to labels, is more general than other definitions (e.g. ) instead mapping states to labels. As a result, we are able to articulate properties that involve actions, such as "to reach the state \(s\) while avoiding taking the action \(a\)".

Optimality-Preserving Specification Translations.Rather than solving the problem of synthesising optimal policies for Eq. (1) directly, we are interested in reducing it to more traditional RL

Figure 1: Examples of an MDP and DRA.

problems and applying off-the-shelf RL algorithms to find optimal policies. To achieve this, the reduction needs to be _optimality preserving2_:

**Definition 3** ().: An _optimality-preserving specification translation_ from \(\)-regular objectives to limit-average rewards is a computable function mapping each tuple \((S,A,,)\) to \(_{(S,A,,)}\) s.t.

 policies maximising \(^{}_{^{}}\) also maximise \(^{}_{}\), where \(:=_{(S,A,,)}\)

for every MDP \(=(S,A,s_{0},P)\), label function \(:S A S 2^{}\) and DRA \(\).

We stress that since the probability transition function \(P\) is generally not known, the specification translation may not depend on it.

## 3 Negative Result and Reward Machines

Reward functions emit rewards purely based on the transition being taken without being able to take the past into account. On the other hand, DRAs have finite memory. Therefore, there cannot generally be optimality-preserving translations from \(\)-regular objectives to limit average rewards provided by reward functions:

**Proposition 4**.: _There is an MDP \(\) and an \(\)-regular language \(L\) for which it is impossible to find a reward function \(:S A S\) such that every \(^{}_{^{}}\)-optimal policy of \(\) also maximises the probability of membership in \(L\)._

Remarkably, this rules out optimality-preserving specification translations even if transition probabilities are fully known3.

Proof.: Consider the deterministic MDP in Fig. 0(a) and the objective of Example 1 "to visit \(s_{1}\) exactly once" expressed by the DRA \(\) in Fig. 0(b). Assume towards contradiction there exists a reward function \(:S A S\) such that optimal policies w.r.t. \(^{}_{^{}}\) maximise acceptance by \(\). Note that every policy \(^{*}\) maximising acceptance by the DRA induces the run \(s_{0}(as_{0})^{n}bs_{1}bs_{0}(as_{0})^{}\) for some \(n\), and \(^{}_{}(^{*})=1\). Thus, its limit-average reward is \(^{}_{^{}}(^{*})=(s_{ 0},a,s_{0})\). Now, consider the policy \(\) always selecting action \(a\) with probability \(1\). As the run induced by \(\) is \(s_{0}(as_{0})^{}\), we deduce that \(^{}_{}()=0\) and \(^{}_{^{}}()=(s_{0},a,s_{0})=^{}_{^{}}(^{*})\), which is a contradiction since \(\) is not \(^{}_{}\)-optimal. 

Since simple reward functions lack the expressiveness to capture \(\)-regular objectives, we employ a generalisation, reward machines , whereby rewards may also depend on an internal state:

**Definition 5**.: A _reward machine (RM)_ is a tuple \(=(U,u_{0},_{u},_{r})\) where \(U\) is a finite set of states, \(u_{0} U\) is the initial state, \(_{r}:U(S A S)\) is the reward function, and \(_{u}:U(S A S) U\) is the update function.

Intuitively, a RM \(\) utilises the current transition to update its states through \(_{u}\) and assigns the rewards through \(_{r}\). For example, Fig. 0(a) depicts a reward machine for the MDP of Fig. 0(a), where the states count the number of visits to \(s_{1}\) (0 times, once, more than once).

Let \(=s_{0}a_{0}s_{1}\) be an infinite run. Since \(_{u}\) is deterministic, it induces a sequence \(u_{0}u_{1}\) of states in \(\), where \(e_{i}=(s_{i},a_{i},s_{i+1})\) and \(u_{i+1}=_{u}(u_{i},e_{i})\). The _limit-average reward_ of a policy \(\) is defined as:

\[^{}_{^{}}()\ :=\ _{t}_{^{ }_{}}[_{i=1}^{t-1}\,_{r}(u_{i},e_{i})]\]

It is seen that limit-average optimal policies \(^{*}\) for the MDP in Fig. 0(a) and the RM in Fig. 0(a) eventually select action \(b\) exactly once in state \(s_{0}\) to achieve \(^{}_{^{}}(^{*})=1\).

In the following two sections, we present a general translation from \(\)-regular languages to limit-average reward machines, and we show that our translation is optimality-preserving (Theorem 12).

Remarks.Our definition of RM is more general than the one presented in [23; 24], where \(^{}_{u}:U[S A S]\) and \(^{}_{r}:U 2^{A^{}} U\). Note that \((^{}_{u},^{}_{r})\) can be reduced to \((_{u},_{r})\) by expanding the state space of the RM to include the previous state and utilising the inverse label function \(^{-1}\). It is worth pointing out that Theorem 12 does not contradict a negative result in  regarding the non-existence of an optimality-preserving translation from LTL constraints to _abstract_ limit-average reward machines (where only the _label_ of transitions is provided to \(_{u}\) and \(_{r}\)).

## 4 Warm-Up: Transitions with Positive Probability are Known

To help the reader gain intuition about our construction, we first explore the situation where the support \(\{(s,a,s^{}) S A S P(s,a,s^{})>0\}\) of the MDP's transition function is known. Crucially, we do not assume that the _magnitude_ of these (non-zero) probabilities are known. Subsequently, in Section 5, we fully eliminate this assumption.

This assumption allows us to draw connections between our problem and a familiar scenario in probabilistic model checking [4, Ch. 10], where the acceptance problem for \(\)-regular objectives can be transformed into a reachability problem. Intuitively, our reward machine monitors the state of the DRA and provides reward \(1\) if the MDP and the DRA are in certain "good" states (\(0\) otherwise).

For the rest of this section, we fix an MDP without transition function \((S,A,s_{0})\), a set of possible transitions \(E S A S\), a label function \(:S A S 2^{P}\) and a DRA \(=(Q,2^{A^{}},q_{0},,F)\). Our aim is to find a reward machine \(\) such that for every transition function \(P\) compatible with \(E\) (formally: \(E=\{(s,a,s^{}) P(s,a,s^{})>0\}\)), optimal policies for limit-average rewards are also optimal for the acceptance probability of the DRA \(\).

### Product MDP and End Components

First, we form the _product MDP_\(\) (e.g. [41; 15]), which synchronises the dynamics of the MDP \(\) with the DRA \(\). Formally, \(=(V,A,v_{0},,F_{})\) where \(V=S Q\) is the set of states, \(A\) is the set of actions, \(v_{0}=(s_{0},q_{0})\) is the initial state. The transition probability function \(:V A V\) satisfies \((v,a,v^{})=P(s,a,s^{})\) given that \(v=(s,q)\), \(v^{}=(s^{},q^{})\), and \((q,(s,a,s^{}))=q^{}\). The accepting condition is \(F_{}=\{(A^{}_{1},R^{}_{1}),(A^{}_{2},R^{} _{2}),\}\) where \(A^{}_{i}=S A_{i}\), \(R^{}_{i}=S R_{i}\), and \((A_{i},R_{i}) F\). A run \(=(s_{0},q_{0})a_{0}\) is accepted by \(\) if there exists some \((A^{}_{i},R^{}_{i}) F_{}\) such that \(() A^{}_{i}\) and \(() R^{}_{i}=\), where \(\) is the set of states \((s,v)\) in the product MDP visited infinitely often by \(\).

Note that product MDPs have characteristics of both MDPs and DRAs which neither possesses in isolation: transitions are generally probabilistic and there is a notation of acceptance of runs. For example, the product MDP for Fig. 1 is shown in Fig. 1(b). Due to the deterministic nature of the DRA \(\), every run \(\) in \(\) gives rise to a unique run \(^{}\) in \(\). Crucially, for every policy \(\),

\[_{^{}_{}}[]=_{^{}_{}}[^{ }]\] (2)

We make use of well-known almost-sure characterisation of accepting runs via the notion of accepting end components:

Figure 2: A reward machine and the product MDP for the running Example 1.

**Definition 6**.: An _end component_ (EC) of \(=(V,A,v_{0},,F_{})\) is a pair \((T,)\) where \(T V\) and \(:T 2^{A}\) satisfies the following conditions

1. For every \(v T\) and \(a(v)\), we have \(_{v^{} T}(v,a,v^{})=1\), and
2. The graph \((T,_{})\) is strongly connected, where \(v_{}v^{}\) iff \((v,a,v^{})>\ 0\) for some \(a(v)\).

\((T,)\) is an _accepting EC (AEC)_ if \(T A^{}_{i}\) and \(T R^{}_{i}=\) for some \((A^{}_{i},R^{}_{i}) F_{}\).

Intuitively, an EC is a strongly connected sub-MDP. For instance, for the product MDP in Fig. 1(b) there are five end components, \((\{(s_{0},q_{0})\},(s_{0},q_{0})\{a\})\), \((\{(s_{0},q_{1})\},(s_{0},q_{1})\{a\})\), \((\{(s_{0},q_{2})\},(s_{0},q_{2})\{a\})\), \((\{(s_{0},q_{2})\},(s_{0},q_{2})\{b\})\) and \((\{(s_{0},q_{2})\},(s_{0},q_{2})\{a,b\})\). \((\{(s_{0},q_{1})\},(s_{0},q_{1})\{a\})\) is its only accepting end component.

It turns out that, almost surely, a run is accepted iff it enters an accepting end component and never leaves it . Therefore, a natural idea for a reward machine is to use its state to keep track of the state \(q Q\) the DRA is in and give reward 1 to transitions \((s,a,s^{})\) if \((s,q)\) is in some AEC (and \(0\) otherwise). Unfortunately, this approach falls short since the AEC may contain non-accepting ECs, thus assigning maximal reward to sub-optimal policies.4 As a remedy, we introduce a notion of minimal AEC, and ensure that only runs eventually committing to one such minimal AEC get a limit-average reward of 1.

**Definition 7**.: An AEC \((T,)\) is an _accepting simple EC (ASEC)_ if \(|\,(v)|=1\) for every \(v T\).

Let \(_{1}=(T_{1},_{1}),,_{n}=(T_{n}, _{n})\) be a collection of ASECs covering all states in ASECs, i.e. if \((s,q)\) is in some ASEC then \((s,q) T_{1} T_{n}\). In particular, \(n|S Q|\) is sufficient.

We can prove that every AEC contains an ASEC (see Lemma 20 in Appendix B). Consequently,

**Lemma 8**.: _Almost surely, if \(\) is accepted by \(\) then \(^{}\) reaches a state in some ASEC \(_{i}\) of \(\)._

### Reward Machine and Correctness

Next, to ensure that runs eventually commit to one such ASEC we introduce the following notational shorthand: for \((s,q) T_{1} T_{n}\), let \(_{(s,q)}=(T_{(s,q)},_{(s,q)})\) be the \(_{i}\) with minimal \(i\) containing \((s,q)\), i.e. \(C_{(s,q)}:=C_{\{1 i n|(s,q) T_{1}\}}\).

Intuitively, we give a reward of 1 if \((s,q)\) is in one of the \(_{1},,_{n}\). However, once an action is performed which deviates from \(_{(s,q)}\) no rewards are given thereafter, thus resulting in a limit average reward of \(0\).

A state in the reward machine has the form \(q Q\), keeping track of the state in the DRA, or \(\), which is a sink state signifying that in a state in \(_{1},,_{n}\) we have previously deviated from \(_{(s,q)}\).

Finally, we are ready to formally define the reward machine \(=_{(S,A,,)}\) exhibiting our specification translation as \((Q\{\},q_{0},_{u},_{r})\), where

\[_{u}(u,(s,a,s^{})):=&\\ &(s,u) T_{1} T_{n}a_{(s,u )}(s,u)\\ (u,(s,a,s^{}))&\] \[_{r}(u,(s,a,s^{})):=1& T_{n}$}\\ 0&\]

For our running example, this construction essentially yields the reward machine in Fig. 1(a) (with some inconsequential modifications cf. Fig. 4 in Appendix B).

**Theorem 9**.: _For all transition probability functions \(P\) with support \(E\), policies maximising the limit-average reward w.r.t. \(\) also maximise the acceptance probability of the DRA \(\)._

This result follows immediately from the following (the full proof is presented in Appendix B):

**Lemma 10**.: _Let \(P\) be a probability transition function with support \(E\) and \(:=(S,A,s_{0},P)\)._

1. _For every policy_ \(\)_,_ \(_{^{}}^{}()_{ }^{}()\)_._
2. _For every policy_ \(\)_, there exists some policy_ \(^{}\) _satisfying_ \(_{}^{}()_{^{ }}^{}(^{})\)_._

Proof sketch.: 1. By construction, every run receiving a limit-average reward of \(1\), must have entered some ASEC \(_{i}\) and never left it. Furthermore, almost surely all states are visited infinitely often and the run is accepted by definition of accepting ECs.

2. By Lemma 8, almost surely, a run is only accepted if it enters some \(_{i}\). We set \(^{}\) to be the policy agreeing with \(\) until reaching one of the \(_{1},,_{n}\) and henceforth following the action \((s_{t},q_{t})(s_{t},q_{t})\), where \(q_{t}\) is the state of the DRA at step \(t\), yielding a guaranteed limit-average reward of \(1\) for the run by construction. 

**Remark 11**.: Our construction considers a collection of ASECs covering all states in ASECs. Whilst it does not necessarily require listing all possible ASECs but only (up to) one ASEC per state, it is unclear whether this can be obtained in polynomial time. In Appendix B.1, we present an alternative (yet more complicated) construction which has polynomial time complexity.

## 5 Main Result

In this section, we generalise the approach of the preceding section to prove our main result:

**Theorem 12**.: _There exists an optimality-preserving translation from \(\)-regular languages to limit-average reward machines._

Again, we fix an MDP without transition function \((S,A,s_{0})\), a label function \(:S A S 2^{}\) and a DRA \(=(Q,2^{},q_{0},,F)\). Note that the ASECs of a product MDP are uniquely determined by the non-zero probability transitions. Thus, for each set of transitions \(E(S Q) A(S Q)\), we let \(_{1}^{E}=(T_{1},_{1}),,_{n}^{E }=(T_{n},_{n})\) denote a collection of ASECs covering all states in ASECs w.r.t. the MDPs in which \(E\) is the set of non-zero probability transitions.5 Then, for each set \(E\) and state \((s,q) T_{1}^{E} T_{n}^{E}\), we let \(_{(s,q)}^{E}=(T_{(s,q)}^{E},_{(s,q)}^{E})\) be the ASEC \(_{i}^{E}\) that contains \((s,q)\) in which the index \(i\) is minimal.

Our reward machine \(=_{(S,A,,)}\) extends the ideas from the preceding section. Importantly, we keep track of the set of transitions \(E\) taken so far and assign rewards according to our current knowledge about the graph of the product MDP. Therefore, we propose employing states of the form \((q,f,E)\), where \(q Q\) keeps track of the state of the DRA, \(f\{,\}\) is a _status flag_ and \(E(S Q) A(S Q)\) memorises the transitions in the product MDP encountered thus far.

Intuitively, we set the flag to \(\) if we are in MDP state \(s\), \((s,q)\) is in one of the \(_{1}^{E},,_{n}^{E}\) and the chosen action deviates from \(_{(s,q)}^{E}(s,q)\). We can recover from \(\) by discovering new transitions. Besides, we give reward \(1\) if \(f=\) and \((s,q)\) is in one of the \(_{1}^{E},,_{n}^{E}\) (and \(0\) otherwise).

The status flag is required since discovering new transitions will change the structure of (accepting simple) end components. Hence, differently from the preceding section, it is not sufficient to have a single sink state.

The initial state of our reward machine is \(u_{0}:=(q_{0},,)\) and we formally define the update and reward functions as follows:

\[_{u}((q,f,E),(s,a,s^{})):=(q^{},,E)&f=e E\\ (q^{},,E)&f=,e E,(s,q) T_{1}^{E} T_{n}^ {E}\\ &a_{(s,q)}^{E}(s,q)\\ (q^{},,E\{e\})&\]

\[_{r}((q,f,E),(s,a,s^{})):=1&f=,(s,q) T_{1}^{E} T_{n}^ {E}\\ 0&\]

where \(q^{}:=(q,(s,a,s^{}))\) and \(e:=((q,s),a,(q^{},s^{}))\).

**Example 13**.: For our running example (see Example 1 and Fig. 1) initially no transitions are known (hence no ASECs). Therefore, all transitions receive reward \(0\). Once action \(a\) has been performed in state \(s_{0}\) in the MDP \(\) and \((q_{1},f,E)\) in the reward machine \(\), we have discovered the ASEC \((\{(s_{0},q_{1})\},(s_{0},q_{1})\{a\})\) and a reward of \(1\) is given henceforth unless action \(b\) is selected eventually. In that case, we leave the ASEC and we will not discover further ASECs since there is only one. From here, it is not possible to return to state \(q_{1}\) in the DRA and henceforth only reward \(0\) will be obtained.

Theorem 12 is proven by demonstrating an extension of Lemma 10 (see Appendix C):

**Lemma 14**.: _Suppose \(=(S,A,s_{0},P)\) is an arbitrary MDP._

1. _For every policy_ \(\)_,_ \(^{}_{^{}}()^{ }_{}()\)_._
2. _For every policy_ \(\)_, there exists some policy_ \(^{}\) _satisfying_ \(^{}_{}()^{}_{ ^{}}(^{})\)_._

Note that Lemma 14 immediately proves that the reduction is not only optimality preserving (Theorem 12) but also robust: every \(\)-approximately limit-average optimal policy is also \(\)-approximately optimal w.r.t. \(^{}_{}\). This observation is important because _exactly_ optimal policies for the limit average problem may be hard to find.

Intuitively, to see part 1 of Lemma 14 we note: If an average reward of \(1\) is obtained for a run, the reward machine believes, based on the partial observation of the product MDP, that the run ends up in an ASEC. Almost surely, we eventually discover all possible transitions involving the same state-action pairs as this ASEC and therefore this must also be an ASEC w.r.t. the true, unknown product MDP. For part 2, we modify the policy \(\) similarly as in Lemma 10 by selecting actions \((s_{t},q_{t})\) once having entered an ASEC \(=(T,)\) w.r.t. the true, unknown product MDP.6

## 6 Convergence for Limit Average, \(\)-Regular and LTL Objectives

Thanks to the described translation, advances (in both theory and practice) in the study of RL with average rewards carry over to RL with \(\)-regular and LTL objectives. In this section, we show that it is possible to learn optimal policies for limit average rewards in the limit. Hence, we resolve an open problem : also RL with \(\)-regular and LTL objectives can also be learned in the limit.

We start with the case of simple reward functions \(:S A S\). Recently, [18, Theorem 4.2] have shown that discount optimal policies for sufficiently high discount factor \([0,1)\) are also limit average optimal.7 This result alone is not enough to demonstrate Theorem 16 since \(\) is generally not known and in finite time we might only obtain _approximately_ limit average optimal policies.

Our approach is to reduce RL with average rewards to a _sequence_ of discount sum problems with increasingly high discount factor, which are solved with increasingly high accuracy. Our crucial insight is that eventually the approximately optimal solutions to the discounted problems will also be limit average optimal (see Appendix D for a proof):

**Lemma 15**.: _Suppose \(_{k} 1\), \(_{k} 0\) and suppose each \(_{k}\) is a memoryless policy. Then there exists \(k_{0}\) such that for all \(K k k_{0}\), \(_{k}\) is limit average optimal, where \(K\) is the set of \(k\) satisfying \(^{}_{^{_{k}}}(_{k})^{}_{^{_{k}}}()-_{k}\) for all memoryless policies \(\)._

Our proof harnesses yet another notion of optimality: a policy \(\) is _Blackwell optimal_ (cf.  and [22, Sec. 8.1]) if there exists \((0,1)\) such that \(\) is \(\)-discount optimal for all \(<1\). It is well-known that memoryless Blackwell optimal policies always exist  and they are also limit-average optimal .

Thanks to the PAC (probably approximately correct) learnability of RL with discounted rewards , there exists an algorithm Discounted which receives as inputs a simulator for \(\), \(\) as well as \(,\) and \(\), and with probability \(1-\) returns an \(\)-optimal memoryless policy for discount factor \(\). In view of Lemma 15, our approach is to run the PAC algorithm for discount-sum RL for increasingly large discount factors \(\) and increasingly low \(\) and \(\) (Algorithm 1).

**Theorem 16**.: _RL with average reward functions can be learned in the limit by Algorithm 1: almost surely there exists \(k_{0}\) such that \(_{k}\) is limit-average optimal for \(k k_{0}\)._

Proof.: Using the definition for \(K\) of Lemma 15 of iterations where the PAC-MDP algorithm succeeds,

\[[\#( K)]_{k} [k]_{k}_{k}=_{k}}<\]

The claim follows immediately with Lemma 15. 

Next, we turn to the more general case of reward _machines_.  observe that optimal policies for reward machines can be learned by learning optimal policies for the modified MDP which additionally tracks the state the reward machine is in and assigns rewards accordingly. We conclude at once:

**Corollary 17**.: _RL with average reward machines can be learned in the limit._

Finally, harnessing Theorem 12 we resolve Open Problem 4 of :

**Theorem 18**.: _RL with \(\)-regular and LTL objectives can be learned in the limit._

Discussion.Algorithm 1 makes independent calls to black box algorithms for discount sum rewards. Many such algorithms with PAC guarantees are model based (e.g. ) and sample from the MDP to obtain suitable approximations of the transition probabilities. Thus, Algorithm 1 can be improved in practice by re-using approximations obtained in earlier iterations and refining them.

## 7 Related Work and Conclusion

The connection between acceptance of \(\)-regular languages in the product MDP and AECs is well-known in the field of probabilistic model checking . As an alternative to DRAs , Limit Deterministic Buchi Automata  have been employed to express \(\)-regular languages for RL .

A pioneering work on RL for \(\)-regular rewards is , which expresses \(\)-regular objectives using Deterministic Rabin Automata. Similar RL approaches for \(\)-regular objectives can also be found in . The authors of  approach RL for \(\)-regular objectives directly by studying the reachability of AECs in the product MDP and developing variants of the R-MAX algorithm  to find optimal policies. However, these approaches require prior knowledge of the MDP, such as the structure of the MDP, the optimal \(\)-return mixing time , or the \(\)-recurrence time .

Various studies have explored reductions of \(\)-regular objectives to discounted rewards, and subsequently applied Q-learning and its variants for learning optimal policies . In a similar spirit,  present a translation from LTL objectives to _eventual discounted_ rewards, where only strictly positive rewards are discounted. These translations are generally not optimality preserving unless the discount factor is selected in a suitable way. Again, this is impossible without prior knowledge of the exact probability transition functions in the MDP.

 propose a translation to limit-average rewards for \(\)-regular specifications which are also _absolute liveness_ properties. (In particular, optimal policies satisfy such specifications with either probability \(0\) or \(1\).) Their translation is optimality-preserving provided the MDP is _communicating_ and the magnitute of penalty rewards in their construction are chosen sufficiently large (which requires knowledge of the MDP).

Furthermore, whilst there are numerous convergent RL algorithms for average rewards for _unichain_ or _communicating8_ MDPs (e.g. ), it is unknown whether such an algorithm exists for general multichain MDPs with a guaranteed convergence property. In fact, a negative result in  shows that there is no PAC (probably approximately correct) algorithm for LTL objectives and limit-average rewards when the MDP transition probabilities are unknown.

 have proposed an algorithm with PAC guarantees provided \(\)-return mixing times are known. They informally argue that for fixed sub-optimality tolerance \(\), this assumption can be lifted by guessing increasingly large candidates for the \(\)-return mixing time. This yields \(\)-approximately optimal policies in the limit. However, it is not clear how to asymptotically obtain exactly optimal policies as this would require simultaneously decreasing \(\) and increasing guesses for the \(\)-return mixing time (which depends on \(\)).

Conclusion.We have presented an optimality-preserving translation from \(\)-regular objectives to limit-average rewards furnished by reward machines. As a consequence, off-the-shelf RL algorithms for average rewards can be employed in conjunction with our translation to learn policies for \(\)-regular objectives. Furthermore, we have developed an algorithm asymptotically learning provably optimal policies for limit-average rewards. Hence, also optimal policies for \(\)-regular and LTL objectives can be learned in the limit. Our results provide affirmative answers to two open problems in .

Limitations.We focus on MDPs with finite state and action sets and assume states are fully observable. The assumption of Section 4 that the support of the MDP's probability transition function is known is eliminated in Section 5. Whilst the size of our general translation--the first optimality-preserving translation--is exponential, the additional knowledge in Section 4 enables a construction of the reward machine of the same size as the DRA expressing the objective. Hence, we conjecture that this size is minimal relative to the DRA specification. Since RL with average rewards is not PAC learnable, we cannot possibly provide finite-time complexity guarantees of our Algorithm 1.