# A Fast, Robust Elliptical Slice Sampling Method for Truncated Multivariate Normal Distributions

Kaiwen Wu

University of Pennsylvania

kaiwenwu@seas.upenn.edu

&Jacob R. Gardner

University of Pennsylvania

jacobrg@seas.upenn.edu

###### Abstract

Elliptical slice sampling, when adapted to linearly truncated multivariate normal distributions, is a rejection-free Markov chain Monte Carlo method. At its core, it requires analytically constructing an ellipse-polytope intersection. The main novelty of this paper is an algorithm that computes this intersection in \((m m)\) time, where \(m\) is the number of linear inequality constraints representing the polytope. We show that an implementation based on this algorithm enhances numerical stability, speeds up running time, and is easy to parallelize for launching multiple Markov chains.

## 1 Introduction

Let \((,)\) be a \(d\)-dimensional standard normal random variable. This paper is concerned with sampling from the truncated multivariate normal distribution

\[p()=()&,\\ 0&,\]

where \(()-^{} \) is the standard normal density, \(Z=_{}()\,\) is a normalization constant, and the domain \(=\{^{d}:\}\) is a polytope defined by \(m\) linear inequalities with \(^{m d}\) and \(^{m}\). We assume the polytope domain has a non-empty interior but is not necessarily bounded. The standard normal assumption is without loss of generality, since non-standard normal distributions can be handled by a change of variable, as shown in SSA.

Truncated normal sampling has numerous applications in machine learning and statistics, with recent ones in skew Gaussian processes (e.g., Benavoli et al., 2021) and preferential Bayesian optimization (Benavoli et al., 2021; Takeno et al., 2023). In addition, truncated normal sampling is a key building block of sophisticated numerical methods estimating integrals related to truncated normal distributions (Gessner et al., 2020).

Linear elliptical slice sampling (e.g., Murray et al., 2010; Fagan et al., 2016; Gessner et al., 2020) is a rejection-free tuning-free Markov chain Monte Carlo method for truncated normal distributions. Each iteration analytically constructs the intersection of an ellipse and the polytope domain, from which the next iterate is sampled. In principle, this method is particularly suitable for high dimensional truncated normal distributions thanks to its rejection free property.

However, the devil is in the details. Despite its conceptual simplicity, constructing the ellipse-polytope intersection is easier said than done. We will show that all existing implementations share a worst-case time complexity of \((m^{2})\), which scales poorly as the number of constraints increases. Moreover, existing implementations have complex control flows, which makes it hard, if not impossible, to parallelize on GPUs. Indeed, to the best of our knowledge, there is no batch implementation of elliptical slice sampling to this date, which is likely due to the programming complexity.

**Contributions.** We develop a new algorithm computing the ellipse-polytope intersection that has a better time complexity and is easier to implement. The algorithm runs in \((m m)\) time and is faster than the existing implementations. Moreover, this algorithm has a simple control flow and is particularly amenable to GPU parallelism. As a result, we are able to parallelize thousands of independent Markov chains easily. Experiments show that our implementation accelerates truncated normal sampling massively in high dimensions.

## 2 Elliptical Slice Sampling for Truncated Normal Sampling

In the \(t\)-th iteration of linear elliptical slice sampling (e.g., Fagan et al., 2016; Gessner et al., 2020), we sample a multivariate normal random variable \(_{t}(,)\) and form an ellipse

\[=\{_{t}+_{t}: \}.\] (1)

The next iterate \(_{t+1}\) is sampled from the ellipse-polytope intersection \(\), i.e., the parts of the ellipse that lie inside the polytope domain. This intersection can be constructed analytically by exploiting the polytope structure, and thus no rejection sampling is needed. See Figure 1 for an illustration and Algorithm 1 for the pseudocode. The arising questions are, of course, how to "analytically construct" the ellipse-polytope intersection \(\) and how to do it efficiently.

Note that the polytope domain itself is the intersection of \(m\) halfspaces:

\[=_{i=1}^{m}_{i}=_{i=1}^{m}\{ ^{d}:_{i}^{} b_{i}\},\]

where \(_{i}\) is the \(i\)-th row of \(\). Thus, the ellipse-polytope intersection \(\) reduces to constructing each ellipse-halfspace intersection \(_{i}\), which does admit an analytical construction.

The intersection of the ellipse and the \(i\)-th halfspace \(_{i}\) is an elliptical arc. The end points of the elliptical arc are identified by the intersection angles, i.e., the roots of the trigonometry equation

\[_{i}^{}_{t}+_{i}^{}_{ t}=b_{i},\] (2)

which typically indeed has two distinct roots \(_{i}\) and \(_{i}\) in closed-forms (see SSB). Without loss of generality, we assume all intersection angles \(_{i}\) and \(_{i}\) are converted into \([0,2]\) by, if necessary,

Figure 1: An ellipse \(_{t}+_{t}\) whose angle \([0,2]\) increases counterclockwise. The next iterate \(_{t+1}\) is sampled from the ellipse-polytope intersection, as shown in red. The intersection consists of two disjoint elliptical arcs. The left one is represented by \([,]\) and the right one is represented by \([0,][,2]\).

adding or subtracting a multiple of \(2\). In addition, we assume \(_{i}\) is strictly smaller than \(_{i}\). A simple observation is that the ellipse-halfspace intersection \(_{i}\) is precisely represented by the union of two disjoint intervals:

\[I_{i}=[0,_{i}][_{i},2].\]

Note that the interval \(I_{i}\) has two disjoint segments due to periodicity: The point \(_{t}\) is represented by two distinct angles \(0\) and \(2\). Intersecting all \(I_{i}\)'s gives the interval representation of the ellipse-polytope intersection:

\[I_{}=_{i=1}^{m}I_{i},\]

which we call the active intervals. Note that the plural form is used because \(I_{}\) may consist of several disjoint intervals, each of which is an active interval. There is an one-to-one correspondence between angles in the active intervals (except the repetition of \(=0\) and \(=2\)) and points in the ellipse-polytope intersection.

Below we discuss existing methods constructing the active intervals.

**Brute Force.** The most straightforward algorithm follows the definition of the active intervals:

\[I_{}^{(0)}=[0,2], I_{}^{(i)}=I_{ }^{(i-1)}[0,_{i}][_{i},2].\]

In the end, \(I_{}^{(m)}\) equals to the desired active intervals \(I_{}\). However, this brute force intersection is tedious to implement and hard to parallelize. Moreover, its worst-case time complexity is as slow as \((m^{2})\). See SSD for why it is not \((m)\), contrary to how it may appear.

**Angle Perturbation.** In Figure 1, \(=\) and \(=\) are not active, since they do not contribute to the active intervals. The hard part of computing the active intervals precisely lies in identifying those active intersection angles. Gessner et al. (2020) identify the active angles by angle perturbations: An intersection angle \(\) is active if and only if exactly one of the perturbations \(_{i}-\) and \(_{i}+\) corresponds a point within the domain \(\). The time complexity is \((m^{2})\).

## 3 A Simple Method for the Ellipse-Polytope Intersection

Sorting \(_{i}\)'s in ascending order yields

\[0_{i_{1}}_{i_{2}}_{i_{k}} _{i_{m}} 2.\] (3) \[\\ _{i_{1}}\\ _{i_{2}}\\ _{i_{k}}\\ _{i_{k}}_{i_{m}}\]

Note that \(_{i_{k}}\) is not necessarily monotonic in \(k\). Our algorithm is based on the observation below.

**Proposition 1**.: _Let \(_{i}<_{i}\) for all \(i[m]\) and let \(\{_{i_{k}}\}_{k=1}^{m}\) be sorted in ascending order as in (3). Then, the active intervals \(I_{}=_{i=1}^{m}[0,_{i}][_{i},2]\) have an equivalent representation_

\[I_{}=[0,_{i_{1}}](_{k=2}^{m}[_{k-1}, _{i_{k}}])[_{m},2],\]

_where \(_{k}=\{_{i_{1}},_{i_{2}},,_{i_{k}}\}\) is the cumulative max until \(_{i_{k}}\). We interpret the interval \([_{k-1},_{i_{k}}]\) as an empty set if \(_{k-1}>_{i_{k}}\)._

Proposition 1 gives a closed-form expression for the active intervals \(I_{}\), which yields Algorithm 2. Despite a somewhat lengthy proof, the idea and the final expression are both very simple. The time complexity is \((m m)\), faster than the brute force algorithm and likelihood testing. In addition, it is simple to program, amenable to GPU parallelism, and easy to batch, since the sorting and cumulative max operations are well supported in every popular machine learning package nowadays.

## 4 Experiments

All simulations are run on a single machine with a RTX 3090 GPU using single precision floating points. We use the linear elliptical slice sampling implementation in BoTorch v0.11.1 as the baseline. Our code will be released publicly.

### Sanity Check: One Dimensional Truncated Normal Sampling

We run elliptical slice sampling with Algorithm 2 on two univariate truncated normal distributions: \((0,1)\) truncated by \(-1 x 3\) and \(15 x 16\), respectively. We draw \(10^{5}\) samples from each distribution by running \(2000\) independent Markov chains in parallel with \(500\) iterations of burn-in and a thinning of \(10\). Hence, the total number of steps is \(2000 500+10 10^{5}=2 10^{6}\). The mean and variance estimates are accurate at least to the second digit after the decimal point (see SSE).

### Accelerate High Dimensional Truncated Normal Sampling

We demonstrate Algorithm 2 accelerates high dimensional truncated normal sampling, especially when the number of inequality constraints \(m\) is large. We generate a set of random instances with varying dimensions as follows. First, we generate a \(d d\) random matrix \(\) whose entries are _i.i.d._ samples from a univariate standard normal distribution. Second, we generate a random vector \(_{0}\) drawn from a \(d\)-dimensional standard normal distribution, which will used as the initialization the Markov chain. Third, we set \(=_{0}+\), where \(\) is a random vector drawn uniformly from the hypercube \(^{d}\). By construction, the initialization \(_{0}\) lies in the interior of the domain. Note that the number of constraints \(m=d\) increases as the number of dimensions increases.

In Figure 2, we draw \(1000\) samples from the general instances of truncated normal distributions and compare the running time against BoTorch's implementation. BoTorch's implementation runs a single Markov chain for \(1000\) steps. Our implementation runs either a single Markov chain for \(1000\) steps or \(10\) chains in parallel for \(100\) steps. Both of them use no burn-in and no thinning. No rejection occurs when running our implementation on these high dimensional distributions. With a single Markov chain, our implementation is over \(10\)x faster than BoTorch's implementation in high dimensions, e.g., \(d 1000\) on CPU and \(d 4000\) on GPU. This speed-up solely comes from the improved per iteration complexity \((m m)\). Furthermore, running \(10\) Markov chains on GPU in parallel yields an additional \(10\)x speed-up in high dimensions.

## 5 Conclusion

We have presented a \((m m)\) algorithm computing the active intervals in linear elliptical slice sampling for linearly truncated normal distributions. We hope our algorithm and implementation unlock the full potential of elliptical slice sampling for linearly truncated normal distributions, and enable new applications that are previously bottlenecked by the speed of sampling.

We end this paper by mentioning two extensions. First, it is interesting to adapt elliptical slice sampling to handle linear equality constraints, in which case the Markov chain has to run in the null space of the linear equality constraints. Second, it is interesting to support differentiable samples by adapting the idea of Zoltowski et al. (2021).

Figure 2: **1st and 2nd subfigures:** Draw \(10^{5}\) samples from two univariate truncated normal distributions with parallel Markov chains. **3rd and 4th subfigures:** Compare running time of drawing \(1000\) samples from high dimensional truncated normal distributions.