# On the Complexity of Identification in

Linear Structural Causal Models

 Julian Dorfler

Saarland University

&Benito van der Zander

University of Lubeck

&Markus Blaser

Saarland University

&Maciej Liskiewicz

University of Lubeck

Equal contribution as first authors.Equal contribution as last authors.Equal contribution as last authors.

###### Abstract

Learning the unknown causal parameters of a linear structural causal model is a fundamental task in causal analysis. The task, known as the problem of identification, asks to estimate the parameters of the model from a combination of assumptions on the graphical structure of the model and observational data, represented as a non-causal covariance matrix. In this paper, we give a new sound and complete algorithm for generic identification which runs in polynomial space. By a standard simulation result, namely \(\), this algorithm has exponential running time which vastly improves the state-of-the-art double exponential time method using a Grobner basis approach. The paper also presents evidence that parameter identification is computationally hard in general. In particular, we prove, that the task asking whether, for a given feasible correlation matrix, there are exactly one or two or more parameter sets explaining the observed matrix, is hard for \(\), the co-class of the existential theory of the reals. In particular, this problem is \(\)-hard. To our best knowledge, this is the first hardness result for some notion of identifiability.

## 1 Introduction

Recognizing and predicting the causal effects and distinguishing them from purely statistical correlations is an important task of empirical sciences. For example, identifying the causes of disease and health outcomes is of great significance in developing new disease prevention and treatment strategies. A common approach for establishing causal effects is through randomized controlled trials (Fisher, ) - called the gold standard of experimentation - which, however, requires physical intervention in the examined system. Therefore, in many practical applications, experimentation is not always possible due to cost, ethical constraints, or technical feasibility. E.g., to learn the effects of radiation on human health one cannot conduct interventional studies involving human participants. In such cases, a researcher may use an alternative approach and establish cause-effect relationships by combining existing observed data with the knowledge of the structure of the system under study. This is called the problem of _identification_ in causal inference (Pearl, ) and the approach is commonly used in various fields, including modern ML.

A key ingredient of this framework is the way the underlying structure models the true mechanism behind the system. In general, this is done using structural causal models (SCMs) . In this work, we focus on the problem of identification in linear SCMs, known also as structural equation models (SEMs) . They represent the causal relationships between observed random variablesassuming that each variable \(X_{i}\), with \(i=1,,n\) is linearly dependent on the remaining variables and an unobserved error term \(_{i}\) of normal distribution with zero mean: \(X_{j}=_{i}_{i,j}X_{i}+_{j}\). The model implies the existence of some covariance matrix \(=(_{i,j})\) between the error terms. In this paper, we consider mainly _recursive models_, i.e., we assume that, for all \(i>j\), we have \(_{i,j}=0\), nonetheless we discuss how our methods can be extended to the general case.

Linear SCMs can be represented as a graph with nodes \(\{1,,n\}\) corresponding to variables \(X_{1},,X_{n}\) and with directed and bidirected edges. A directed edge \(i j\) represents a linear influence \(_{i,j} 0\) of a parent node \(i\) on its child \(j\). A bidirected edge \(i j\) represents a correlation \(_{i,j} 0\) between error terms \(_{i}\) and \(_{j}\) (cf. Figure 1).

Writing the coefficients of all directed edges as an adjacency matrix \(=(_{i,j})\) and the coefficients of all bidirected edges as an adjacency matrix \(=(_{i,j})\), the covariances \(_{i,j}\) between each pair of observed variables \(X_{i}\) and \(X_{j}\) can be calculated as matrix \(=(_{i,j})\):

\[=(I-)^{-T}(I-)^{-1},\] (1)

where \(I\) is the identity matrix . Knowledge of the parameters \(_{i,j}\) allows for the prediction of all causal effects in the system. The key task here is to learn \(\) from the observed covariances \(\) assuming \(\) remains unknown. This leads to the formulation of the identification problem in linear SCMs as solving for the parameter \(\) using equation (1). If the problem asks to find symbolic solutions involving only symbols \(_{i,j}\), we call it the problem of _symbolic identification_. In the case when the parameter can be determined uniquely almost everywhere using \(\) alone, we call the instance to be _generically identifiable_ (for a formal definition, see Sec. 2). If the goal is to find, for a given \(\) of rational numbers, the numerical solutions, we call it the problem of _numerical identification_. In this paper, we study the computational complexity of both variants of the problem.

Previous Work.The identification in linear SCMs and its applications have been a subject of research interest for many decades, including the early work in econometrics and agricultural sciences [42; 41; 19; 8]. Currently, it seems, that one of the most challenging tasks in this field is providing efficient computational methods to find solutions, both for symbolic and for numeric variants, or providing evidence that the problems are computationally intractable.

The generic identification can be computed using standard algebraic tools for solving symbolic polynomial equations (1). Such an approach provides a _sound_ and _complete_ method, i.e., it is guaranteed to identify all identifiable instances. However, common algorithms for solving such equations usually use Grobner basis computation, whose time complexity is doubly exponential in the worst case . So far, it has remained widely open whether the double exponential function is a sharp upper bound on the computational complexity of the generic identifiability.

Most approaches to solving the problem in practice are based on instrumental variables, in which the causal direct effect is identified as a fraction of two covariances [41; 8]. For example, in the linear model shown in Figure 1, one can calculate first \(_{1,2}=_{1,2}\) and then \(_{2,3}=_{2,3}}{_{1,2}}=}{_{1,2}}\). The variable \(X_{1}\) is then called an instrumental variable (IV). This method is sound but not complete, that is, when it identifies a parameter, then it is always correct. However, when the method fails due to a missing IV, then the parameter might still be identified by other means. This approach has inspired intensive research aimed at providing computational methods that may not be complete but enable efficient algorithms and identify a significantly large number of cases.

Conditional IVs (cIVs) are one of the most natural extensions of simple IVs [8; 31]. The corresponding identification method is based on an efficient, polynomial time algorithm for finding conditional IVs . More complex criteria and methods proposed in the literature, which are also accompanied by polynomial time algorithms, involve instrumental sets (IS)  half-treks (HTC) , instrumental cutsets (ICs) , auxiliary instrumental variables (aIVs) . The generalized HTC (gHTC) [13; 40] and auxiliary variables (AVS) [13; 14] can be implemented in polynomial time provided

Figure 1: An IV example.

that the number of incoming edges to each node in the causal graph is bounded. The methods based on generalized IS (gIS), a simplified version of the criterion (scIS), and generalized AVS (gAVS) appeared to be computationally intractable . The auxiliary cutsets (ACID) algorithm  subsumes all the above methods in the sense that it covers all the instances identified by them. Recently  provide the TreeID algorithm for identification in tree-shaped linear models. TreeID is incomparable since it is complete for the subclass of tree-like SCMs. However, TreeID does not work for general SCMs, which is the focus of our work. Figure 2 summarizes these results.

Numerical parameter identification, known in the literature as the estimation of the parameters of structural equation models, has been the subject of a considerable amount of research, which has resulted in significant progress in theoretical understanding and development of estimation methods . Currently, in practical applications (e.g. in econometrics, psychometrics, or biometrics), methods based on maximum likelihood (ML) or generalized least squares estimator (GLS) are commonly used to find model parameters. However, despite the great importance of this problem and considerable effort in method development, the computational complexity of the parameter estimation problem remains unexplored. In our work, we provide, to our knowledge, the first hardness result for a very basic variant of the SEM parameter estimation problem, which we call numerical identification.

Our Contribution.We improve significantly the best-known upper bound on the computational complexity for generic identification and provide evidence that parameter identification is computationally hard in general. In more detail, our contributions are as follows:

* We provide a polynomial-space algorithm for sound and complete generic parameter identification in linear models. This gives an exponential running time which vastly improves the state-of-the-art double exponential time method using Grobner basis. In our approach, we formulate generic identifiability as a formula over real variables with both existential and universal quantifiers and then use Renegar's algorithm .
* Our constructive technique allows us to prove an \(\) (and \(\)) upper bound on generic identifiability, for the well-studied complexity class \(\) (see Sec. 2.2 for definitions). It is an intermediate class between \(\) and \(\).
* We prove that numerical identification is hard for the complexity class \(\). In particular, the problem is \(\)-hard. Our complexity characterization is quite precise since we show a (promise) \(\) upper bound for numerical identification. To the best of our knowledge, this is the first hardness result for some notion of identifiability.
* On the other hand, we show that numerical identifiability can be decided in polynomial space.
* If an instance is non-identifiable, then an important task is to identify as many model parameters as possible. We are particularly interested in identifying the parameters of specific edges in the graph representing the linear model. In the paper, we obtain, for "edge identifiability", the same results as for the common identifiability problem. Since these proofs are essentially the same, they can be found in Appendix A.

Figure 2: Methods for generic identification in linear SCMs. An arrow from methods \(A B\) means that \(B\) subsume all methods \(A\), i.e., any instance that can be identified by any of methods \(A\) can be identified by method \(B\) and this inclusion is proper. Green boxes mean there exist polynomial-time algorithms to apply the method, a red box means no such algorithm is known or the method has been proven to be \(\)-hard. The blue box includes the complete methods.

## 2 Preliminaries

### The Problems of Identification in Linear Causal Models

A mixed graph is a triple \(G=(V,D,B)\) where \(V:=\{1,,n\}\) is a finite set of nodes and \(D V V\) and \(B\) are two sets of directed and bidirected edges, respectively. Let \(^{D}\) be the set of matrices \(=(_{i,j})^{n n}\) with \(_{i,j}=0\) if \(i j\) is not in \(D\) and let \((n)\) denote the cone of positive definite \(n n\) matrices. Let \((B)\) be the set of matrices \(=(_{i,j})(n)\) with \(_{i,j}=0\) if \(i j\) and \(i j\) is not an edge in \(B\). For now, we will only consider recursive models, i.e. we assume that, for all \(i>j\), we have \(_{i,j}=0\) (in Sec. 7 we will discuss how our methods can be extended to general graphs allowing cycles). Thus, the directed graph \((V,D)\) accompanied with the model is acyclic. We will assume w.l.o.g. that the nodes are topologically sorted, i.e., there are no edges \(i j\) with \(i>j\).

Denote by \(_{n}(,)\) the multivariate normal distribution with mean \(^{n}\) and covariance matrix \(\). The linear SCMs \((G)\) associated with \(G=(V,D,B)\) is the family of multivariate normal distributions \(_{n}(0,)\) with \(\) satisfying equation (1), for \(^{D}\) and \((B)\). A model in \((G)\) is specified in a natural way in terms of a system of linear structural equations: \(X_{j}=_{i(j)}_{i,j}X_{i}+_{j}\), for \(j=1,,n\), where \((j)\) denote the parents of \(j\) in \(G\). If \(=(_{1},,_{n})\) is a random vector with the multivariate normal distribution \(_{n}(0,)\) and \(^{D}\), then the random vector \(X=(X_{1},,X_{n})\) is well defined as a solution to the equation system and follows a centered multivariate normal distribution with covariance matrix \((I-)^{-T}(I-)^{-1}\) (see, e.g. ).

For a given (acyclic) mixed graph \(G=(V,D,B)\), define the parametrization map

\[_{G}:(,)(I-)^{-T}(I-)^{-1}\]

and let \(:=^{D}(B)\). We say that \(G\) is _globally_ identifiable if \(_{G}\) is injective on \(\).

Global identification can be decided easily, see [17, Theorem 2]. However, it is a very strong property. For instance, as seen in the introduction, in Figure 1, we can recover the parameter \(_{2,3}\) as \(}{_{1,2}}\). If \(_{1,2}=0\), then the identification fails, so the instance is not globally identifiable. But identification fails only in the (very unlikely) case that \(_{1,2}=0\). This leads to the concept of _generic identifiability_:

**Definition 1** (Generic Identifiability, ).: _The mixed graph \(G\) is said to be generically identifiable if \(_{G}\) is injective on the complement \(\) of a proper (i.e., strict) algebraic subset \(\)._

Given matrices \(_{0}^{D}\) and \(_{0}(B)\), the corresponding _fiber_ is defined by

\[_{G}(_{0},_{0})=\{(,)_{G}(,)=_{G}(_{0},_{0}),^{D}, (B)\}.\]

A fiber contains all pairs of matrices that induce the same observed covariance matrix \(\). For \(\,_{G}\), we also write \(_{G}()\) for the fiber belonging to \(\). We can phrase identifiability in terms of fibers:

* \(G\) is globally identifiable, if \(|_{G}(_{0},_{0})|=1\) for all \(_{0}^{D}\) and \(_{0}(B)\).
* \(G\) is generically identifiable, if \(|_{G}(_{0},_{0})|=1\) for Zariski almost all \(_{0}^{D}\) and \(_{0}(B)\).

Generic identifiability asks whether all parameters are almost always identifiable in the Zariski sense, that is, everywhere except for a lower dimensional algebraic set. For generic identifiability, we only consider the parameters \(_{i,j}\) since the parameters \(_{k,l}\) can be recovered from the \(_{i,j}\) and \(_{i,j}\) using (1), see also .

It is also of interest to ask whether a single parameter \(_{i,j}\) is almost always identifiable. For this, we consider the projection of the fiber on the single parameter, which we will also call an _edge fiber_:

\[_{G}^{i,j}(_{0},_{0})=\{_{i,j}(, )_{G}(_{0},_{0})\}.\]

(Above \(_{i,j}\) denotes the entry of \(\) in the position \((i,j)\), that is, \(_{i,j}\).)

**Definition 2**.: _The parameter \(_{i,j}\) is generically edge identifiable, if \(|_{G}^{i,j}(_{0},_{0})|=1\) for Zariski almost all \(_{0}^{D}\) and \(_{0}(B)\)._Global and generic identifiability are properties of the given mixed graph. In this work, we also study identification as a property of the observed numerical data, i.e., of the observed covariance matrix \(\).

**Definition 3** (Numerical Identifiability).: _Given an acyclic mixed graph \(G=(V,D,B)\) and a feasible matrix \(\), decide whether the parameters are uniquely identifiable, i.e. if \(|_{G}()|=1\)?_

Note that this is a promise problem. We assume that \(\) is feasible, i.e., in the image of \(_{G}\). Therefore, we shall also study the feasibility problem: Given \(\), is it contained in \(\,_{G}\)?

Similarly we can also define numerical edge identifiability: For a given feasible \(\), test whether the edge fiber \(\) belongs to has size \(1\) or \(>1\).

### The (Existential) Theory of the Reals

The existential theory of the reals (\(\)) is the set of true sentences of the form

\[ x_{1} x_{n}\;(x_{1},,x_{n}),\] (2)

where \(\) is a quantifier-free Boolean formula over the basis \(\{,,\}\) and a signature consisting of the constants \(0\) and \(1\), the functional symbols \(+\) and \(\), and the relational symbols \(<\), \(\), and \(=\). The sentence is interpreted over the real numbers in the standard way. The theory forms its own complexity class \(\) which is defined as the closure of \(\) under polynomial-time many-one reductions. Many natural problems have been shown to be complete for \(\), for instance the computation of Nash equilibria , the famous art gallery problem , or training neural networks , just to mention a few. See the recent compendium  for a complete overview.

It turns out that one can simplify the form of an \(\)-instance. We can get rid of the relations \(<\) and \(\) and it is sufficient to consider only Boolean conjunctions. More precisely, the following problem is \(\)-complete: Given polynomials \(p_{1},,p_{m}\) in variables \(x_{1},,x_{n}\), decide whether there is a \(^{n}\) such that

\[p_{1}()==p_{m}()=0.\] (3)

By Tseitin's trick, we can assume that all polynomials are of one of the forms

\[ab-c,\;\;a+b-c,\;\;a-b,\;\;a-1,\;\;a\] (4)

and all variables in each of the polynomials are distinct. Note that all polynomials in (4) have degree at most two. Therefore, this problem is also called the feasibility problem of quadratic equations \(\). For a proof, see e.g. .

Universal Quantification.If, instead of considering existentially quantified true sentences, we consider universally quantified true sentences of the form

\[ x_{1} x_{n}\;(x_{1},,x_{n}),\] (5)

where \(\) is again a quantifier-free Boolean formula, and form the closure under polynomial-time many-one reductions, we obtain the complexity class \(\). Using De Morgan's law, it is easy to see the well-known fact that \(=\), i.e. it is the complement class of \(\).

It is also possible to alternate quantifiers, giving rise to a whole hierarchy, comparable to the well-known polynomial time hierarchy, see . We call the corresponding classes \(\), \(\),...

Complexity of \(\) and \(\).It is easy to see that quantification over real variables can be used to simulate quantification over Boolean variables by adding the constraint \(x(x-1)=0\). This way we can convert \(3\)-formulas to \(\)-formulas, proving the well-known containment \(\).

With his celebrated result about quantifier elimination, Renegar  proved that the truth of any sentence over the reals with a constant amount of quantifier alternations is decidable in \(\). This in particular implies

\[ .\] (6)

While all these inclusions are believed to be strict, it is unknown for all of them.

Finding Another Solution

Numerical identification is a promise problem, i.e., we assume that the given input is feasible. Being a promise problem means that an algorithm for numerical identification should output the correct answer whenever the input is feasible. But it can output anything when the input is not feasible. We give some further information about promise problems in Appendix B for the reader's convenience.

For our hardness proof, we need to look at instances of \(\) or \(\) that are satisfiable. Of course, deciding whether a satisfiable instance is satisfiable is a trivial task. So the task will be to decide whether the satisfiable instance has another solution. We call the corresponding promise problems \(^{++}\) and \(^{++}\).

It turns out that these promise problems are \(\)-hard. Since \(^{++}\) is a special case of \(^{++}\), it suffices to prove this for \(^{++}\). Let \(y\) be an extra variable. We will plant an extra solution into the system (3):

\[y(y-1) =0\] (7) \[yx_{i} =0\] (8) \[(y-1)p_{j} =0\] (9)

**Lemma 1**.: _The system above has the following solutions:_

1. \(y=1\)_,_ \(x_{1}==x_{n}=0\)__
2. \(y=0\)_,_ \(x_{1}=_{1},,x_{n}=_{n}\)_, where_ \(^{n}\) _is any solution to the original instance._

_In particular, the system always has a solution. It has more than one solution iff the original \(\)-instance is satisfiable._

Proof.: The first equation (7) constrains \(y\) to be \(\{0,1\}\)-valued. If \(y=0\), then the equations (8) are trivially satisfied and (9) reduces to the original instance (3). If \(y=1\), then the equations (9) are trivially satisfied and (8) reduces to \(x_{1}==x_{n}=0\). Note that in both cases we always get different solutions since the \(y\)-value differs. 

Using the transformation in the lemma above, we can map any \(\)-instance into a \(^{++}\)-instance and obtain

**Corollary 1**.: \(^{++}\)_and \(^{++}\)are \(\)-hard._

## 4 Hardness of Numerical Identifiability

This section is dedicated to proving:

**Theorem 2**.: _Numerical identifiability is \(\)-hard._

The proof consists of building a polynomial-time reduction from the complement of \(^{++}\) to numerical identifiability, i.e., we construct an acyclic mixed graph \(G\) and a \(\,_{G}\), such that the fiber \(_{G}()\) has size \(1\) iff the given \(^{++}\)-instance has only one solution. For this, we use the following characterization of fibers due to :

**Lemma 3**.: _Let \(G=(V,D,B)\) be an acyclic mixed graph, and let \(\,_{G}\). The fiber \(_{G}()\) is isomorphic to the set of matrices \(^{D}\) that solve the equation system_

\[[(I-)^{T}(I-)]_{i,j} =0, i j,i j B\] (10)

We construct \(G\) as follows: The directed edges form a bipartite graph with edges going from the bottom layer to the top layer. Every node at the bottom layer has outdegree one. Moreover bidirected edges exist between all pairs of nodes, except for certain pairs of nodes of the top layer. See Figure 3 (left-hand side) for an illustration.

This missing edge in Figure 3 corresponds to the equation

\[0=_{i,j}-_{=1}^{n}_{a_{},j}_{a_{},i}-_ {k=1}^{m}_{b_{k},i}_{b_{k},j}+_{=1}^{n}_{k=1}^{m} _{a_{},b_{k}}_{a_{},i}_{b_{k},j}\] (11)

in Lemma 3.

**Observation 4**.: _All \(\) values that appear in (11) cannot appear in any other missing edge equation of missing edges in the top layer. Parameters \(_{a_{},j}\) can only appear in an equation of a missing edge that contains the node \(j\) and another node \(h\) such that there is a directed edge from \(a_{}\) to \(h\). However, \((a_{},i)\) is the only such edge, since the nodes in the bottom layer only have outdegree one. The same is true for \(_{b_{k},j}\). \(_{a_{},b_{}}\) can only appear in an equation of a missing edge \(h h^{}\) if there are directed edges \((a_{},h)\) and \((b_{k},h^{})\). By the same argument, \(i j\) is the only such missing edge. Furthermore \(_{i,j}\) can obviously only appear in this equation._

The above observation means that we can freely "program" the equations, that is, we can freely choose the \(\)-values in each missing edge equation without interfering with any other missing edge equation.

We start with a gadget with one node \(r\) in the top layer and \(n\) nodes in the bottom layer connected to it. It is used to store the value of each variable of our ETR instance, \(_{1,r}\) corresponds to \(x_{1}\), \(_{2,r}\) corresponds to \(x_{2}\), etc, see Figure 3 (right-hand side) for an illustration.

By assuming all polynomials in our \(^{++}\)-instance are of the forms (4), we need to be able to encode products and affine linear forms. We start by showing how to encode an arbitrary affine linear constraint \(_{=1}^{n}_{}x_{}=\) using a single additional node \(i\) in the top layer, "connected" to \(r\) via a missing edge as in Figure 4.

Setting \(_{r,i}=\) and \(_{,i}=_{}\), \(1 n\), makes (11) together with \(_{,r}=x_{}\) directly equivalent to \(_{=1}^{n}_{}x_{}=\).

Encoding a product \(x_{a}=x_{b} x_{c}\) requires two additional nodes \(i\) and \(j\) in the top layer, with missing bidirectional edges between them and \(r\). Furthermore we introduce two nodes \(i^{}\) and \(j^{}\) in the bottom layer, connected to \(i\) and \(j\) respectively, see Figure 4 (right-hand side). This introduces three equations. The missing edge \(r i\) enforces \(_{i^{},i}=_{c,r}\) by setting \(_{r,i}=_{1,i^{}}==_{n,i^{}}=0\), \(_{r,i^{}}=-1\), \(_{c,i}=1\), and \(_{,i}=0\), for all \(\{1,,n\}\{c\}\) in (11). We use the missing edge \(i j\) to further ensure \(_{j^{},j}=_{i^{},i}=_{c,r}\), for which we set \(_{i,j}=_{i^{},j^{}}=0\), \(_{i^{},j}=1\), and \(_{i,j^{}}=-1\). After having copied \(_{c,r}\) twice, we are finally able to enforce the multiplication itself using the missing edge \(r j\). We set \(_{r,j}=_{r,j^{}}=0\), \(_{a,j}=1\), \(_{b,j^{}}=1\), \(_{,j}=0\), for all \(\{1,,n\}\{a\}\), and \(_{,j^{}}=0\), for all \(\{1,,n\}\{b\}\). We need to copy the parameter \(_{c,r}\) twice to be able to "program" the equation corresponding to the missing edge \(r j\).

Proof of Theorem 2.: Let polynomials \(p_{1},,p_{m}\) in variables \(x_{1},,x_{n}\) be a \(^{++}\)-instance with all polynomials being one of the forms in (4). Let the number of affine linear polynomials among \(p_{1},,p_{m}\) be \(k\). Then the graph \(G=(V,D,B)\) constructed above has \(:=1+n+k+4(m-k)=1+n+4m-3k\) nodes. Using Observation 4, we see that the construction induces a well-defined partial matrix \(^{}\). Every entry of \(\) not defined by the construction is set to

Figure 4: Left: Gadget for affine linear constraints. Right: Gadget for multiplicative constraints.

Figure 3: Left: A single missing edge on the top layer. Right: The gadget storing the value of each variable. \(_{i,r}\) corresponds to \(x_{i}\).

\(0\) if it is off-diagonal and \(\) if it is on the diagonal. Since all \(_{i,j}\) set in the construction are from \(\{-1,0,1\}\) and off-diagonal, \(\) strictly diagonally dominant by our choice of \(\) and thus positive definite by the Gershgorin circle theorem .

Remains to prove \(_{G}\). Let \(^{n}\) be any solution with \(p_{1}()==p_{m}()=0\). The existence of \(\) is guaranteed by the promise of \(^{++}\). Create \(^{}\) as follows: \(_{i,r}=_{i}\) for \(i\{1,,n\}\) and \(_{i^{},i}=_{j^{},j}=_{c}\) whenever the vertices \(i,i^{},j,j^{}\) are the vertices added by the construction due to a multiplication. All other entries of \(\) are \(0\). Then \(I-\) is invertible and we have \(=_{G}(,)\) for \(=(I-)^{T}(I-)\). Furthermore \(\) is positive definite due to \(\) being positive definite and \((B)\).

By Lemma 3, this implies that \(|_{G}()|\) is precisely the number of solutions of our \(^{++}\)-instance. So if the \(^{++}\)-instance is a yes-instance, that is, has more than one solution, then our constructed instance is not numerically identifiable. If the \(^{++}\)-instance is a no-instance, that is, has only one solution, then our constructed instance is numerically identifiable. So we have a reduction from the complement of \(^{++}\). The theorem now follows, since by Corollary 1, \(^{++}\) is \(\)-hard and the complement of an \(\)-hard problem is \(\)-hard. 

## 5 Upper Bound for Numerical Identifiability

In this section, we show a \(\) upper bound for numerical identifiability and thus, combined with Theorem 2, prove an almost3 matching lower and upper bound. We start with the following lemma. The \(\) part will be needed in the next section.

**Lemma 5**.: _Membership in \((n)\) and \((B)\) can be expressed in \(\) and \(\). 4_

Proof.: For the \(\) expression, we use the fact that every real positive definite matrix \(A^{n n}\) has a Cholesky decomposition \(A=LL^{T}\) where \(L\) is a real lower triangular matrix with positive diagonal entries. We can thus express \(A(n)\) as

\[ L^{n n}:A=LL^{T}_{i\{1,,n\} }(L_{i,i}>0_{j\{i+1,,n\}}L_{i,j}=0).\] (12)

We quantify over matrices and consider matrix equations in (12). But this can be easily rewritten as an \(\)-instance by quantifying over all entries of the matrix and having one individual equation for each entry of the matrix equation.

For the \(\) expression, we directly use the definition of positive definite matrices to express \(A(n)\) as

\[ x^{n}:x 0 x^{T}Ax>0.\] (13)

For membership \(A(B)\), in both \(\) and \(\), we add the constraint \(_{(i,j) B i j}A_{i,j}=0\) to (12) and (13), respectively. 

We remind the reader that numerical identifiability is a promise problem with the promise that the input \(_{G}\), so it suffices to check whether all elements in the fiber \(_{G}()\) are identical.

\[_{1},_{2}^{D}, _{1},_{2}(B):\] \[_{G}(_{1},_{1})=_{G}(_{2},_{2}) =(_{1}=_{2}_{1}=_{2}).\] (14)

The checks \(_{G}(_{i},_{i})=\) are implemented using \(_{i}=(I-_{i})^{T}(I-_{i})\), which is equivalent due to \(I-_{i}\) being invertible for any \(_{i}^{D}\). This proves the following:

**Theorem 6**.: _Numerical identifiability is in (the promise version of) \(\)._

**Remark 7**.: _Strictly speaking, numerical identifiability is not contained in \(\), since it is a promise problem, that is, the outcome is not specified for \(\) that are not feasible. \(\) consists by definition only of classical decision problems, where the outcome is specified for all inputs. So the corresponding complexity class is \(\). Section B contains some more information on promise problems for the reader's convenience._However, we can express feasibility in \(\):

**Lemma 8**.: _Membership in \(_{G}\) can be expressed in \(\)._

Proof.: We use the expression \(^{D},(B):(I-)^{T} (I-)=\), where we use Lemma 5 to express \((B)\) in \(\), that is, we quantify over an arbitrary matrix \(\) first and add the ETR expression from Lemma 5 to ensure that \(\) is in \((B)\). 

Hence, we can check in \(\) whether the input \(\) is feasible and then in \(\) whether the fiber has only one element. Using Renegar's algorithm, we get:

**Corollary 2**.: _Numerical identifiability can be decided in polynomial space._

## 6 Generic Identifiability is in PSPACE

Let \(\) denote the following problem: Given an encoding of a semi-algebraic set \(S\) and a number \(d\), decide whether \( S d\).

**Lemma 9** (Koiran 5).: _The problem \(\) is \(\)-complete. Moreover, this is even true when the set is given by an existentially quantified formula as in (2)._

We use the same notation as in Section 2.1. Let \(G=(V,D,B)\) be a mixed graph. Let \(S_{G}=\{(,)\ |\ |_{G}(,)|>1, ^{D},(B)\}\).

**Observation 10**.: \(G\) _is generically identifiable iff \(^{D}+(B)> S_{G}\)._

Proof.: As \(S_{G}^{D}(B)\) and \((^{D}(B))=^{D}+ (B)\), the right-hand side is just the definition of being generically identifiable. 

We postpone the proof that membership in \(S_{G}\) can be expressed in \(\), in favor of first giving our algorithm to decide generic identifiability, using this observation:

**Theorem 11**.: _Generic identifiability is both in \(\) and \(\)._

Proof.: Let \(G\) be the given mixed graph. Formulate membership in \(^{D},(B)\), and \(S_{G}\) as instances of \(\) using Lemmas 5 and 12. Note that the number of variables and the sizes of these instances are polynomial in the size of \(G\). Now we can check whether \(G\) is generically identifiable by checking the condition in Observation 10.

We first assume that we have oracle access to \(\), that is, we can query \(\) a polynomial number of times. We decide whether \(G\) is generically identifiable as follows:

1. Use Koiran's algorithm (see Lemma 9) repeatedly to compute \( S_{G}\) by checking whether \( S_{G} d\) for \(d=0,,2n^{2}\). (We could even use binary search.)
2. Compute \(^{D}\) and \((B)\) in the same way.6 Here it suffices to check up to the maximum possible dimension of \(d=n^{2}\). 3. Accept if \(^{D}+(B)> S_{G}\), and reject otherwise.

The algorithm is correct by Observation 10. The algorithm above would already show the \(\) upper bound for generic identifiability.

However, we can implement the algorithm above by a single formula by replacing the repeated use of Koiran's algorithm by a big disjunction:

\[_{d_{1}=0}^{n^{2}}_{d_{2}=0}^{n^{2}}(^{D} d_ {1}(B) d_{2} S_{G}<d_{1}+d_{2})\,.\]Note that the check \( S_{G}<d_{1}+d_{2}\) needs to be implemented as \(( S_{G} d_{1}+d_{2})\), thus being in \(\) by De Morgan's laws. The existential and universal quantifiers are however independent, giving upper bounds of both \(\) and \(\). 

Using Renegar's algorithm this implies:

**Corollary 3**.: _Generic identifiability can be decided in \(\)._

It only remains to show how to express membership in \(S_{G}\) as an \(\)-formula.

**Lemma 12**.: _Membership in \(S_{G}\) can be expressed in \(\)._

Proof.: The membership of some \((,)\) in \(S_{G}\) can be expressed as

\[^{D}(B) ^{n n},^{}^{D}, ^{}(B): (I-)^{T}(I-)=\] \[(I-^{})^{T}(I-^{})=^ {}\] \[(^{}^{})\,.\]

**Remark 13**.: _The algorithm of Theorem 11 as is only tests generic identifiability. Since the problem has a high degree, one cannot expect that the solutions have easy expressions. However, Renegar's algorithm shows that the solutions are the linear factors of a certain polynomial, see ._

## 7 A Note on Cyclic Graphs

Our results so far have depended on the fact that every matrix \(I-\) with \(^{D}\) is invertible if the graph is acyclic. However, if the graph is cyclic, \(I-\) is not necessarily invertible. So in this case, we need to explicitly consider the subset \(^{D}_{}\) of matrices \(^{D}\) such that \(I-\) is invertible.

For matrices \(_{0}^{D}_{}\) and \(_{0}(B)\),  define fibers as

\[_{G}(_{0},_{0})=\{(,)_{G}( ,)=_{G}(_{0},_{0}),^{D}_{ },(B)\}.\]

They determine generic identifiability for _cyclic_ graphs in terms of these fibers. That is a mixed (cyclic) graph \(G\) is said to be _generically_ identifiable if \(|_{G}(_{0},_{0})|=1\) for Zariski almost all \(_{0}^{D}_{}\) and \(_{0}(B)\).

This is the same criterion used for acyclic graphs, except \(^{D}\) has been replaced by \(^{D}_{}\) twice. Matrix invertibility can be easily expressed in \(\), using the definition of invertibility:

\[A B^{n n}:AB=I.\]

Hence, all our upper bounds also hold for general graphs.

## 8 Conclusions

Due to double exponential runtime, the state-of-the-art algorithm for the generic identification problem is often too slow to solve instances of reasonable size. For example, Garcia-Puente et al.  report that the runtime varies between seconds and 75 days for graphs with four nodes. An interesting topic for future work would be to implement the (theoretical) algorithm presented in our paper.

We have given a new upper on the complexity of generic identifiability, namely \(\). More precisely, we showed that it is in \(\) and \(\). This can be even improved to \(\). It is not necessary to express the dimension of \(^{D}\) and \((B)\) in terms of the theory of the reals, but they can be calculated directly, \(^{D}=|D|\) as well as \((B)=n+|B|\). In the light of our hardness proofs for the new notion of numerical identifiability, we conjecture that generic identifiability is hard for \(\), too.