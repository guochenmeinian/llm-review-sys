# ToolQA: A Dataset for LLM Question Answering

with External Tools

 Yuchen Zhuang, Yue Yu, Kuan Wang, Haotian Sun, Chao Zhang

College of Computing, Georgia Institute of Technology, Atlanta GA

{yczhuang, yueyu, kuanwang, haotian.sun, chaozhang}@gatech.edu

These authors contributed equally to this work.

###### Abstract

Large Language Models (LLMs) have demonstrated impressive performance in various NLP tasks, but they still suffer from challenges such as hallucination and weak numerical reasoning. To overcome these challenges, external tools can be used to enhance LLMs' question-answering abilities. However, current evaluation methods do not distinguish between questions that can be answered using LLMs' internal knowledge and those that require external information through tool use. To address this issue, we introduce a new dataset called ToolQA, which is designed to faithfully evaluate LLMs' ability to use external tools for question answering. Our development of ToolQA involved a scalable, automated process for dataset curation, along with 13 specialized tools designed for interaction with external knowledge in order to answer questions. Importantly, we strive to minimize the overlap between our benchmark data and LLMs' pre-training data, enabling a more precise evaluation of LLMs' tool-use reasoning abilities. We conducted an in-depth diagnosis of existing tool-use LLMs to highlight their strengths, weaknesses, and potential improvements. Our findings set a new benchmark for evaluating LLMs and suggest new directions for future advancements. Our data and code are freely available for the broader scientific community on GitHub 2.

## 1 Introduction

Large Language Models (LLMs) have demonstrated superior performance in a myriad of NLP tasks . These models have captured vast amounts of knowledge from enormous and diverse corpora during pre-training. After instruction fine-tuning , they have demonstrated impressive capabilities in information-seeking question answering . Despite their remarkable performance, LLMs face several challenges. For example, they are susceptible to hallucinations--generating plausible yet ungrounded information--which can mislead users and affect content integrity . Additionally, they exhibit weaknesses in numerical reasoning, an essential skill in numerous real-life applications . These limitations highlight the need for techniques that can enhance LLMs' question-answering abilities.

Recent research has shown that these issues can be mitigated by augmenting LLMs with _external tools_, such as retrieval augmentation , math tools , and code interpreters . For example, a Wolfram math plugin can enhance numerical reasoning , and a verified database can mitigate hallucinations by providing up-to-date fact-checked knowledge . However, existing evaluation methodologies struggle to distinguish whether the model is simply recalling pre-trained information or truly utilizing external tools for problem-solving . This challenge arises, in part, because the external data used for evaluation may have already been exposed to LLMs during the pre-training phase . This exposure can lead to a biased evaluation of LLMs' tool-use abilities, as the models could just use their ingrained knowledge and their reasoning abilities, bypassing the use of external tools. As a result, these evaluations cannot accurately reflect the true competency of themodels. We need a fair and explicit way to check if LLMs are really good at problem-solving with tools or if they are just using their memorized information.

To fill this gap, we introduce ToolQA, a question answering (QA) benchmark to evaluate LLMs' ability in using external tools for answering questions. ToolQA comprises data from 8 domains and defines 13 types of tools to acquire information from external reference corpora. Each instance in ToolQA consists of a question, an answer, reference corpora, and a list of available tools. ToolQA is unique in that all its questions can be answered only by using appropriate tools to obtain information from the reference corpus. This minimizes the possibility of LLMs answering questions by merely recalling their internal knowledge, and allows for faithfully evaluating LLMs' abilities in using tools.

ToolQA is curated with an automated three-phase process: (1) The first phase, _Reference Data Collection_, involves gathering various types of public corpora including text, tables, and graphs from different domains. These corpora have no overlap with the LLM pre-training data and will serve as reference corpora for tool-based question answering. (2) The second phase is _Human-guided Question Generation with LLMs_. In this phase, we generate questions that can only be answered by using tools over the reference corpora. Our approach is a _template-based_ question generation process, which includes human-guided template generation, template validation, and question instantiation with tool attributes. (3) The third phase is _Programmatic Answer Generation_. This phase produces accurate answers for the generated questions. To ensure answer correctness, we implement operators corresponding to the tools and obtain answers from the reference corpora programmatically. Our three-phase procedure ensures that we generate questions that can only be answered using external knowledge, along with their precise answers. Additionally, the process is highly efficient and requires minimal human labeling efforts.

We conducted experiments using both standard LLMs and tool-augmented LLMs to answer questions in ToolQA. Our findings indicate that ChatGPT and Chain-of-thoughts prompting , which rely solely on their internal knowledge, have low success rates of approximately 5% for easy questions and 2% for hard questions. In contrast, tool-augmented LLMs such as Chameleon  and ReAct  perform better by leveraging external tools. For easy questions, the best performance achieved by tool-augmented LLMs is 43.15%, while for hard questions, the best performance drops to 8.2%. Our results and error analysis demonstrate that ToolQA is a challenging benchmark for existing tool-augmented LLM methods, especially for its hard questions that require more complex reasoning about tool composition.

## 2 Related Work

### Knowledge-Augmented LLMs

Several prior works aim to enhance LLMs with explicit external knowledge. Specifically, one line of research focus on _retrieval-augmented language models_[58; 3; 17; 27; 30; 80; 34; 72], where they use sparse  or dense retrieval [22; 16] to extract relevant knowledge from the corpus. These works mainly focus on leveraging free text, without considering multiple types of tools for task solving. On the other hand, Program-of-Thought , PAL , MathPrompt , and

Figure 1: Pre-trained on vast range of corpus, LLMs possess extensive knowledge, which may overlap with evaluation data. This overlap poses a significant challenge to current evaluation methods, as it becomes difficult to discern whether the model is merely recalling pre-trained information or genuinely employing external tools for problem-solving.

Code4Struct  apply code-based tools to enhance LLMs' abilities in question answering with a focus on tabular and math-related tasks. Several additional works [56; 32; 57] expand the scope of tool utilization by incorporating different types of basic tools (_e.g._ calculator, calendar, machine translation) to solve complex reasoning tasks. To synergize different functional tools together for problem-solving, LLMs must have advanced planning and memory capabilities. In terms of planning, current methods either enable LLMs to autonomously break down complex tasks into intermediate reasoning steps [45; 24; 47; 50; 65; 75; 31; 76], or encourage LLMs to self-reflect the previous decisions with environmental feedback [39; 76; 35; 8]. Memory capabilities, on the other hand, provide LLMs with opportunities to learn and adapt based on past experiences, whether successes or failures . In addition, several works have extended this line of learning paradigm to other modalities [73; 69] and other domains . Concurrent to our work, there are also several studies [70; 37] that investigate the parametric and nonparametric knowledge from LLMs. A detailed comparison between existing tool-use LLMs can be found in Appendix A.

### Benchmarks on Tool-Augmented LLMs

Earlier tool-augmented LLMs primarily assess single tool usage based on downstream task performance across existing benchmarks. For example, there are works that study how text retrievers augment LLMs' performance on open-domain question-answering [21; 74], fact-checking , and timely information benchmarks [7; 23; 78; 12]. Besides, the mathematical reasoning abilities of external calculators and Python interpreters are evaluated using computation-intensive QA datasets [11; 33]. However, these evaluation benchmarks may not faithfully reflect the extent to which models leverage external tools, as some questions could still be correctly answered solely using the internal knowledge of the LLMs. ToolQA attempts to mitigate these issues by selecting data from out-of-scope sources that have not been memorized by LLMs. Concurrent with our work, there are several recent benchmarks for evaluating LLMs' ability in using multiple tools for solving challenging tasks, including API-Bank , APIBench , and ToolBench [52; 71]. They mainly focus on constructing high-quality tool chains for LLM fine-tuning and evaluating API call trace accuracy against a fixed ground truth trace. In contrast, ToolQA is unique in that it focuses on the open-ended use of tools for question-answering, rather than benchmarking the intermediate process of tool use. Specifically, ToolQA creates tool-based question-answer pairs and assesses whether LLMs can arrive at the correct answer, regardless of the tool chains used.

Figure 2: ToolQA, aiming to faithfully evaluate LLMsâ€™ abilities to use external tools, curates data through three phases: (a) Reference Data Collection; (b) Human-Guided Question Generation; and (c) Programmatic Answer Generation.

## 3 ToolQA Dataset

### Dataset Details

We curate the ToolQA benchmark to evaluate LLMs' capability in leveraging external tools for question answering. ToolQA consists of data from 8 distinct domains, each instance being a tuple -- (_question_, _answer_, _reference corpora_, and _tools_). The _reference corpora_ are external knowledge sources that can be queried, which can be a text corpus, a tabular database, or a graph. To enable obtaining information from the reference corpora, we have developed 13 tools for text retrieval, database operations, code interpretation, mathematical computations, and more. The questions are designed to simulate real-world information-seeking inquiries. However, they cannot be answered directly with LLMs' internal knowledge, but instead require LLMs to obtain information from the reference corpora via tool use. Table 1 shows the detailed statistics of ToolQA.

To reduce human efforts in generating faithful question-answer pairs to evaluate LLMs' tool-use capabilities, we propose an automatic three-phase process (Figure 2): (1) We first select data from public sources that are unmemorized by LLMs during _Reference Data Collection_; (2) We adopt _Human-Guided Question Generation_ to steer LLMs to generate valid questions according to pre-defined templates; (3) We produce accurate answers for the generated questions with _Programmatic Answer Generation_. We detail the three-phase generation process in the following.

### Reference Data and Tools

To evaluate LLMs' ability in using external tools for question answering, it is crucial to ensure that they cannot directly answer the questions with their internal knowledge. To this end, we collect reference corpora that meet the following criteria (Figure 2(a)): 1) The reference corpora should ideally not overlap with the LLM's pre-training data; 2) The reference corpora should contain context-sensitive facts for generating questions that cannot be directly answered solely based on LLMs' internal knowledge and reasoning abilities; 3) LLMs should be able to obtain all the necessary information from the reference corpora to correctly answer the questions.

Based on these criteria, we define 6 contextual dimensions: _temporal_, _spatial_, _social_, _scientific_, _mathematical_, and _personal_. We collect reference corpora that can yield _context-specific_ questions along one or more of the 6 dimensions. Specifically: 1) Along the _temporal_ dimension, we collect the Flights and Coffee corpora, which contain the latest information that is out of the temporal scope of the LLM's pre-training data. 2) Along the _spatial_ dimension, we collect Yelp and Airbnb, which are two non-text corpora that can yield questions with spatial contexts. 3) Along the _mathematical_ dimension, we collect the questions from GSMBK that ChatGPT cannot answer correctly with its own mathematical reasoning ability; 4) SciREX emphasizes detailed model performances from the _scientific_ domain , where GPT family models can easily hallucinate . 5) To incorporate _personal_ data and avoid privacy issues, we synthesize the personal Agenda corpus with ChatGPT with virtual names and events. 6) In addition, we also select data from the most recent DBLP database and create graphs between authors and papers, where _social_ relational knowledge cannot be understood by LLMs currently. Further details can be found in Appendix B.

To obtain information from these reference corpora, we design \(13\) tools that are available to the LLMs (Table 2). These tools are designed as follows:

    &  &  &  &  \\   & & Format & Size & \# Templates & \# Questions & \# Templates & \# Questions \\   & Flight & Tabular Database & 4078318 & 10 & 100 & 10 & 100 \\  & Coffee & Tabular Database & 5746 & 8 & 100 & 13 & 130 \\   & Yelp & Tabular Database & 150346 & 11 & 100 & 10 & 100 \\  & Airbnb & Tabular Database & 102599 & 10 & 100 & 10 & 100 \\   & GSMSK & Professional Ability & - & - & 100 & - & - \\   & DBLP & Graph & 553320 & 10 & 100 & 10 & 100 \\   & SciREX & Pure-Text Corpus & 438 & 1 & 100 & 4 & 100 \\   & Agenda & Pure-Text Corpus & 10000 & 5 & 100 & 5 & 100 \\   & - & - & **55** & **800** & **62** & **730** \\   

Table 1: Dataset Statistics of ToolQA.

* **Text:**_AgendaRetriever_ and _SciREXRetriever_ are text retrieval tools. They can retrieve relevant information to a given query from the (synthesized) personal agenda corpus and scientific corpus.
* **Database:**_Database Loader_ loads data from the local tabular Database. _Data Filter_ can filter the database according to a set of conditions, each of which is composed of a column name, a relation, and a pre-determined value (_e.g._, "Date=2022-10-15"). _Get Value_ returns all the values under a certain column in the database.
* **Math:**_Calculator_ is a mathematical tool that treats the input string as a formula and calculates the corresponding result. We use the WolframAlpha API portal as the calculator 3, which can perform both simple computations (_e.g._, add, subtraction, multiplication) and complicated operations (_e.g._, averaging, finding maximum values). * **Graph:**_Graph Loader_ loads the graph from local files for future operations. _Neighbour Checker_ lists all the neighbors of the query node in the graph. _Node Checker_ and _Edge Checker_ return the detailed attribute information of the query node and edge, respectively.
* **Code:** The _SQL Interpreter_ and the _Python Interpreter_ are responsible for interpreting and executing SQL commands and Python code, respectively. They can receive and transform data from other tools, serving as bridges between different tools and the LLM.
* **System:**_Finish_ parses the feedback from execution and returns the answer to finish the task.

### Human-Guided Question Generation

The question generation phase aims to generate questions that can be answered by using the available tools over the reference corpora. There are two straightforward strategies to generate questions: 1) letting human experts come up with questions about reference corpora, or 2) relying solely on LLMs to generate questions about the reference corpora. However, both strategies have their drawbacks. While human experts can produce high-quality questions, the entire process is labor-intensive, time-consuming, and hard to scale. Depending solely on LLMs may generate unanswerable questions or hallucinate information that does not exist in the reference data. Besides, some of the LLM-generated questions are too easy and can be directly answered with only LLMs' internal knowledge.

To address these challenges, we propose a human-guided LLM generation approach that uses question templates to bridge human guidance and automatic LLM generation [67; 79]. We first ask ChatGPT to generate _candidate question templates_ from reference data, using prompts such as "_Generate diverse and challenging template questions that users may have based on the given information._". To obtain diverse questions, we generate around 50 template questions for each external data source. We then perform manual validation to select the templates that cannot be answered with LLMs' internal knowledge but become answerable with the reference corpora. We go through all question templates and eliminate those that meet either of the following conditions: (1) Template questions that vanilla ChatGPT can answer based on its internal knowledge with a success rate of over \(50\%\) (e.g., "What is the distance between LAX and SFO?", where distance information can be memorized by ChatGPT); (2) Template questions posing queries about information not present in the external data (e.g., "What is the average price from LAX to SFO?", where price information is missing from the flight data). After examining all the templates, we selected 117 most representative and diverse question templates for the entire ToolQA dataset.

After the high-quality question templates are manually selected, we sample values from the reference data to automatically fill into the templates to generate concrete questions. For example, given the template "_Did the flight from \(\{Orig\}\) to \(\{Dest\}\) on \(\{Date\}\) get canceled or diverted?_", we can sample the values "LAX", "MDW", "01/09/22" from the reference Flight tabular data and fill into the template to form a question: "_Did the flight from_ LAX _to_ MDW _on_01/09/22_ get canceled or diverted?_"

   Tool Types & \# Tools & Tools \\  Text Tools & 2 & Agenda Retriever, SciREX Retriever \\ Database Tools & 3 & Database Loader, Data Filter, Get Value \\ Math Tools & 1 & WolframAlpha Calculator \\ Graph Tools & 4 & Graph Loader, Neighbour Checker, Node Checker, Edge Checker \\ Code Tools & 2 & Python Interpreter, SQL Interpreter \\ System Tools & 1 & Finish \\   

Table 2: Different tools in ToolQA.

Depending on the difficulty of the questions, we classify them into two classes -- easy and hard. Easy questions primarily focus on extracting a single piece of information from external knowledge, thus requiring fewer tools to involve in the solution. Conversely, hard questions require complex operations (_e.g._, average) and reasoning (_e.g._, comparison) over multiple information pieces drawn from the reference corpora, requiring more tools and complex reasoning among them. We provide a comprehensive list of both easy and hard question templates in Appendix C and D.

### Programmatic Answer Generation

Our final step is to create accurate answers for the generated questions. To guarantee the validity of these responses, we implement 1) operators, which are functions corresponding to the predefined tools; and 2) tool chains, which are schemas for composing different operators for different question templates. For each question, as we know the true arguments filled into the question template, we can run the tool chains with the corresponding arguments to programmatically extract answers from the reference data. This process enables automatic generation correct answers to questions, even for those questions that involve multi-step reasoning. Figure 2(c) demonstrates this generation process. When answering a generated question with sampled values _"Did the flight from_LAX _to_MDW _on_01/09/22 _get canceled or diverted?_", we write Python codes to implement the operators over the reference data, including database loader, data filter, and get-value function. Then, the programmatic pipeline runs a tool chain of these operators to automatically generate the correct answer (details in Appendix E).

## 4 Experiments

### Baselines

We evaluate the performance of the following methods on ToolQA, covering both standard LLMs and tool-augmented LLMs: (1) **LLaMA-2** and **Falcon** are state-of-the-art open-sourced large language models. We directly feed the questions into two versions (13B and 70B) of LLaMA-2 and Falcon (40B) to obtain the predictions; (2) **ChatGPT**: We directly feed the questions into OpenAI's ChatGPT model (gpt-3.5-turbo) and obtain its response as the final answer. (3) **CoT**: We use chain-of-thoughts prompting for ChatGPT, adding the prompt "Let's think step by step:" after the question to leverage LLMs' reasoning ability for question answering. (4) **Chameleon** is a recent method that uses LLMs as a controller to use multiple tools for solving subtasks and has shown promising results in reasoning and QA tasks. When running Chameleon on ToolQA, we set the tool pool to our defined tools in SS 3.1. (5) **ReAct** integrates reasoning with tool use by prompting LLMs to generate interleaved verbal reasoning traces and tool calls. This integration has been shown effective in enhancing LLMs' problem-solving capabilities. We instantiate two versions of ReAct using gpt-3.5-turbo and text-davinci-003.

Different from the existing works that mainly provide task-level few-shot exemplars, we provide tool-level demonstrations. We used 8 demonstrations about how to use tools for QA, ensuring that each tool in the pool is covered at least once by the demonstrations. Such tool-level demonstrations provide a concise tutorial to the LLMs for tool use, covering all tool uses with the LLM context limit. Details about the demonstrations and our prompts are included in Appendix F. To assess the performance of methods on the ToolQA benchmark, we normalize both the ground-truth answers and the model predictions to ensure uniformity in format. Success rates are then computed based on the exact match between these normalized answers. We use a series of rules for normalization: (1) We normalize different time string formats, (_e.g._, converting "18:06" and "1806.0" to "1806."); (2) For price-related questions, we normalize the units by removing price units (_e.g._, USD, SS); (3) We remove all the punctuations from both the model predictions and ground-truth answers; (4) We normalize the article usage (_e.g._, a, an, the) via removing all articles from both the model predictions and ground-truth answers; (5) We normalize the white spaces by trimming multiple spaces into single space. As most of the predictions and answers are numerical values or entities, these normalization rules address most of the false negative cases during matching. We evaluate the model's ability against the generated question-answer pairs in an open-ended manner, focusing on whether the model can arrive at the correct answer, regardless of the used tool chains.

### Results

**Internal Knowledge vs. External Knowledge.** From the results in Tables 3 and 4, the vanilla open-sourced LLMs and ChatGPT underperform their tool-augmented counterparts on both easy and hard questions. This is expected, as vanilla LLMs lack access to external information for question answering. Additionally, the vanilla LLMs show near-zero performance on different tasks, indicating that there is little overlap between the benchmark data and the LLMs' internal knowledge.

**Comparing Different Tool-Use LLMs.** Tables 3 and 4 show the results of different methods on the easy and hard questions. ChatGPT and CoT achieve very poor success rates (\(<10\)) on both easy and hard questions across different tasks. This is expected as the questions in ToolQA cannot be answered solely based on LLMs' internal knowledge and reasoning. Chameleon achieves slightly better performance, with 10.6% and 1.9% success rates on easy and hard questions, respectively. This is because Chameleon incorporates tool descriptions and integrates human-induced orderings of these tools in its context, enabling it to comprehend and compose different tools for QA. However, Chameleon cannot take feedback from the execution trace, thus often suffering from infeasible actions or omitted arguments in its generated plans. ReAct is the best-performing model. It can use observations in the execution trace to generate its next action, allowing it to iteratively refine its tool use chain and obtain better success rates.

**Easy vs. Hard Questions.** Comparing Tables 3 and 4, we observe that all the baselines perform much worse on hard questions. The best method achieves an average success rate of \(43.13\%\) on easy questions, while that number drops to \(8.24\%\) on hard questions. As mentioned in SS 3, the hard questions in ToolQA require more tool calls and more complicated compositions. Current tool-augmented LLMs struggle with answering such hard questions, which requires further development of techniques to improve their ability to reason about the task and generate plans for tool use.

**GPT-3 vs. GPT3.5**. 4 Comparing the different versions of ReAct, we observe that the ReAct (GPT-3) outperforms ReAct (GPT-3.5) on easy questions, yet it shows inferior performance on hard questions. Our hypothesis is that for easy questions, it is more important to learn and follow the format of the tool calls in the context, which GPT-3 is stronger at. For hard questions, the better reasoning and code understanding abilities of GPT-3.5 enables it to come up with "innovative" solutions that never appear in the context, leading to higher success rates. An example can be referred to in SS 5.3.

## 5 Result Analysis and Discussion

We analyze the drawbacks and possible improvements of existing tool-augmented LLMs, taking the best-performed ReAct (GPT-3.5) model on the hard questions of ToolQA as an example.

### Main Error Type I: Argument Errors

By performing comprehensive error analysis, we found that the most common error type when asking LLMs to use tools for QA is argument error -- LLMs calling the tools with wrong arguments.

  
**LLM Category** & **Models** & **Flight** & **Coffee** & **Agenda** & **Yelp** & **Airbnb** & **DBLP** & **SciREX** & **Average** \\   & LLMaA-2 (13B) & 1.0 & 0.0 & 0.0 & 4.0 & 1.0 & 5.0 & 1.0 & 1.7 \\  & Falcon (40B) & 1.0 & 0.0 & 0.0 & 4.0 & 1.0 & 6.0 & 1.0 & 1.9 \\  & LLMaA-2 (70B) & 1.0 & 0.0 & 0.0 & 4.0 & 1.0 & 4.0 & 3.0 & 1.9 \\   & ChatGPT & 2.0 & 2.3 & 1.0 & 0.0 & 2.0 & 4.0 & 3.0 & 2.0 \\  & CoT & 0.0 & 0.8 & 0.0 & 1.0 & 0.0 & 3.0 & 5.0 & 1.4 \\   & Chameleon & 3.0 & 2.3 & 0.0 & 0.0 & 0.0 & 8.0 & 0.0 & 1.9 \\  & ReAct (GPT-3) & 3.0 & 10.8 & 0.0 & 3.0 & 0.0 & **19.0** & 0.0 & 5.1 \\   & ReAct (GPT-3.5) & **5.0** & **17.7** & **7.0** & **8.0** & **7.0** & 5.0 & **8.0** & **8.2** \\   

Table 4: Success rate on hard questions.

  
**LLM Category** & **Models** & **Flight** & **Coffee** & **Agenda** & **Yelp** & **DBLP** & **SciREX** & **GSMSK** & **Airbnb** & **Average** \\   & LLMaA-2 (13B) & 0.0 & 2.0 & 0.0 & 5.0 & 1.0 & 0.0 & 9.0 & 1.0 & 2.3 \\  & Falcon (40B) & 1.0 & 1.0 & 2.0 & 8.0 & 1.0 & 0.0 & 8.0 & 5.0 & 3.3 \\  & LLMaA-2 (70B) & 2.0 & 6.0 & 5.0 & 15.0 & 0.0 & 0.0 & 9.0 & 4.0 & 5.1 \\   & ChatGPT & 2.0 & 0.0 & 0.0 & 15.0 & 0.0 & 2.0 & 26.0 & 0.0 & 5.6 \\  & CoT & 1.0 & 1.0 & 0.0 & 9.0 & 0.0 & 0.0 & 30.0 & 0.0 & 5.1 \\   & Chameleon & 30.0 & 9.0 & 4.0 & 8.0 & 3.0 & 0.0 & 27.0 & 4.0 & 10.6 \\  & ReAct (GPT-3) & **61.0** & **90.0** & **29.0** & **77.0** & **28.0** & **3.0** & **32.0** & 25.0 & **43.1** \\   & ReAct (GPT-3.5) & 48.0 & 81.0 & 24.0 & 64.0 & 23.0 & 2.0 & 23.0 & **29.0** & 36.8 \\   

Table 3: Success rates on easy questions.

For ReAct, this error type makes \(44.56\%\) and \(48.23\%\) out of the \(377\) and \(436\) error cases on easy and hard questions respectively, as shown in Figure 3(a). Interestingly, ReAct shows different argument error patterns on easy and hard questions. On easy questions, it tends to make more mistakes on database-related tools. For example, the model commits a total of 120 errors when calling LoadDB, FilterDB, and GetValue tools for easy questions, while this number reduces to 95 for hard questions. On the other hand, when dealing with code-related tools (_e.g._, SQLInterpreter and PythonInterpreter), ReAct makes nearly 10x more errors for hard questions than for easy ones. This phenomenon is likely because the solution logic for hard questions is often more complex and cannot be fully inferred from the context alone. Consequently, the LLMs tend to rely on their understanding of code and programming concepts to tackle these intricate questions. In contrast, for easy questions, the LLMs tend to follow the patterns provided in the context, attempting to combine different database operations to arrive at a solution.

### Main Error Type II: Incorrect Data Source

We have conducted an investigation into the data sources preferred by LLMs when answering questions. We found that LLMs also have difficulties in identifying the proper reference corpora answer the questions. This behavior is graphically represented as a confusion matrix in Figure 3(b). Upon examining the figure, it is apparent that for target reference corpora like Flight, Coffee, Airbnb, and Yelp that contain temporal information, LLMs are more likely to query the Agenda corpus for answering questions. Similarly, given that the SciREX knowledge corpora and DBLP graph are both in the scientific domain, LLMs tend to be confused about which source to query when answering scientific questions.

### Main Error Type III: Innovation and Hallucination

For in-context tool-augmented LLMs, it is typical to include descriptions and use-case examples of each tool in the prompt. However, as the problem complexity increases with the number of tools, it becomes challenging to encompass all possible instances of compositional tool use as few-shot exemplars. Consequently, it is vital for LLMs to uncover logical relationships among different tools, which have never been encompassed in the human-provided exemplars, to solve challenging tasks -- a process we refer to as "innovation." However, these innovative behaviors are a double-edged sword as they are often accompanied by hallucinations. Figure 4 illustrates this phenomenon with a case study, where LLMs answer hard questions with reference Coffee data. Given the context length constraint, the few-shot exemplar only showcases the basic usage of database operations and the SQL interpreter. For the hard question in Figure 4(a), ReAct (GPT-3) strictly follows the operations displayed in the context, leading to failure. On the contrary, ReAct (GPT-3.5) innovatively identifies the SQL interpreter as a possible alternative to database operations, especially when the latter fails repeatedly. However, such innovations can oftentimes lead to hallucinations. As shown in Figure 4(b), when answering another hard question from the Coffee data, ReAct (GPT-3.5) opts to hallucinate certain observations (highlighted in yellow) that are non-existent in the feedback from tool execution.

### Other Error Types

We manually go through and count all the errors made by the ReAct (GPT-3.5) model and show the errors on both easy and hard questions in Figure 5. In addition to the aforementioned 3 main error types, there are 4 error types that frequently occur:

Figure 3: Analysis of incorrect tool calls and incorrect data sources made by ReAct on ToolQA.

* **Infeasible Actions:** The execution of tool calls are infeasible in the environment, often involving new tools that do not exist in the pre-defined tool pool.
* **Too Long Context:** The encoding of interaction history, observations, and tool-use plans exceed the length limitation of GPT family models, resulting in runtime errors;
* **Mis-understanding:** The LLMs cannot understand the observations obtained from external interaction and fail to determine the next steps or generate answers;
* **Low-Quality Retrieval:** This error occurs when the retrieval model fails to extract the relevant information from text corpora, indicating insufficient external knowledge for LLMs to answer questions accurately.

Comparing these error types on easy and hard questions, we find that the overall distribution is similar, though there is a slightly higher rate of hallucination and long-context errors when answering hard questions. This can be attributed to the complexity of hard questions, which often require composing more tools for question answering.

### Potential Misuse of ToolQA

We summarize the potential misuse of the ToolQA dataset and Tool-augmented LLMs as follows:

* If LLMs can be trained or prompted to use external tools, they could be prompted to use tools that extract personal information, propagate malware, or provide misleading information;
* There is potential for future LLMs to over-rely on these external tools, sacrificing their intrinsic reasoning abilities. This can make them less versatile in situations where tool use is not feasible;

Figure 4: An example of innovation and hallucination when answering hard questions on Coffee data. Actions and observations shrouded in pink are incorrect, whereas those in green are correct. Terms highlighted in yellow signify hallucinations produced by ReAct (GPT-3.5).

Figure 5: Error analysis of ReAct on ToolQA.

* As LLMs are prompted to interact with more external systems, the security risks can increase. Malicious actors might find ways to exploit the interactions between LLMs and the external tools they leverage.

### Comparing Open-Source LLMs with ChatGPT

Table 5 shows the comparison of vanilla LLaMA-2, tool-augmented LLaMA-2, and tool-augmented ChatGPT. There is a significant performance gap between vanilla LLaMA-2 and tool-augmented LLaMA-2, which is consistent with what we have observed on closed-source LLMs in Section 4.2. In terms of the ability to use external tools for answering the questions, we found that LLaMA-2 is indeed lagging behind ChatGPT. The prompts tailored for tool-augmented LLMs tend to be complicated and lengthy, containing tool descriptions, few-shot examples, and interaction history with the environment. Such long contexts make it difficult for LLaMA-2 to understand complex instructions hidden inside.

## 6 Conclusion and Recommendation

We have developed ToolQA, a dataset that assesses the ability of Large Language Models (LLMs) in using external tools for solving complex problems. ToolQA is curated by an automated three-phase process, including reference data collection, template-based question generation, and programmatic answer generation. This pipeline is general and can be expanded to incorporate external knowledge corpora in different domains. We tested both standard LLMs and tool-augmented LLMs on ToolQA. Our experiments showed that even the strongest model achieved limited performance on the hard questions of ToolQA. Our analysis found that current tool-augmented LLMs tend to make errors such as incorrect tool calls and using incorrect data sources. These issues could be potentially addressed by fine-tuning using a collection of tool-use corpora with open-source LLMs. In the future, we plan to collect high-quality tool-use sequences to fine-tune open-source LLMs, and subsequently evaluating their performance on ToolQA.

It is important to note that the reported performance of closed-source LLMs, such as ChatGPT, is based on specific versions of these models. As these closed-source models undergo further development and updates, the results may change accordingly. We advocate two strategies to mitigate the issue: (1) We plan to continuously include the performance of newly released models in our repository, with the collective efforts of both our team and peer researchers of the community. We intend to integrate results from different versions of such product APIs and document the identifiers of each version (_e.g._, 0314, 0613, _etc._) to promote reproducibility. (2) The reported performance of closed-source LLMs should be regarded primarily as a reference, and making comparisons with them is optional. Instead, we encourage the community to use the performance of open-source LLMs as the primary baseline when employing the ToolQA benchmark. This will promote reproducibility and consistency of the evaluation on ToolQA over time.

#### Acknowledgments and Disclosure of Funding

This work was supported in part by NSF (IIS2008334, IIS-2106961, CAREER IIS-2144338), ONR (MURI N00014-17-1-2656), IDEaS Cyberinfrastructure Resources, and Microsoft Accelerate Foundation Models Research Program.