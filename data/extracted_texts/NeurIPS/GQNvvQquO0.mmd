# Differentially Private Set Representations

Sarvar Patel\({}^{*}\)

Google

sarvar@google.com

&Giuseppe Persiano\({}^{*}\)

Universita di Salerno

giuper@gmail.com

&Joon Young Seo\({}^{*}\)

Google

jyseo@google.com

&Kevin Yeo\({}^{*}\)

Columbia University, Google

kwlyeo@google.com

###### Abstract

We study the problem of differentially private (DP) mechanisms for representing sets of size \(k\) from a large universe. Our first construction creates \((,)\)-DP representations with error probability of \(1/(e^{}+1)\) using space at most \(1.05ke(e)\) bits where the time to construct a representation is \(O(k(1/))\) while decoding time is \(O((1/))\). We also present a second algorithm for pure \(\)-DP representations with the same error using space at most \(ke(e)\) bits, but requiring large decoding times. Our algorithms match our lower bounds on privacy-utility trade-offs (including constants but ignoring \(\) factors) and we also present a new space lower bound matching our constructions up to small constant factors. To obtain our results, we design a new approach embedding sets into random linear systems deviating from most prior approaches that inject noise into non-private solutions.

## 1 Introduction

Consider the problem of releasing a set \(S\) of elements from a potentially very large universe \(U\) in a differentially privately manner. The goal is to construct a differentially private representation of \(S\), denoted by \(\). The representation \(\) can be used to try and determine whether an element \(u U\) belongs to the original input set \(S\). \(\) may err in two ways. For any \(u S\), \(\) may report a false negative stating that \(u\) is not in \(S\). Also, for \(u S\), \(\) may report a false negative claiming \(u\) appears in \(S\). Ideally, we should minimize the error probability for maximal utility while obtaining strong privacy for \(S\). This problem is useful for applications where users wish to privately disclose information such as sets of bookmarked websites, visited IP addresses, installed mobile apps, etc. One particularly important application is training machine learning models using the above examples as feature vectors while maintaining user privacy. As some concrete examples, good solutions to our problem could enable privately training models for web traffic forecasting using user's visited webpages , app install predictions with user's installed apps sets  and detecting shared IP addresses from user's visited IP addresses .

A naive approach is to interpret the universe \(U\) as a bit vector where each element corresponds to a unique entry of the vector \(\{0,1\}^{|U|}\). Encoding \(S U\) works by setting the corresponding coordinates of \(S\) to 1 and the rest to 0. Then, we can apply randomized response  to each entry of \(\). The noisy vector \(\) is then released as the encoding of \(S\). Accessing an element proceeds by reading the value at the corresponding coordinate of the noisy vector \(\). With this approach, the

[MISSING_PAGE_FAIL:2]

We can compare the error probabilities achieved by our DP set mechanisms compared to prior works. For private histograms, per-entry expected error is \((1/)\) as shown in . In contrast, our constructions err with probability \(1/(e^{}+1)\). Note, we can convert this into the expected per-entry error as \(1/(e^{}+1)\). So, we obtain exponentially smaller per-entry error of \(1/(e^{}+1)\), which is impossible for private histograms. We also perform experimental evaluation in Section 5 to corroborate our error being exponentially smaller compared to private histograms.

**Lower bounds.** We show that our constructions achieve optimality in two important dimensions: trade-offs between privacy and utility as well as privacy and space. First, we present a lower bound on the best possible trade-off between privacy and utility (that is, error probability). Our pure-DP solution matches this lower bound exactly including constants. Similarly, our approximate-DP algorithm matches the lower bound (including constants) if we ignore the \(\) factor. We also present a lower bound showing the best possible trade-off between privacy and space (encoding size).

**Theorem 1.3** (Utility-privacy trade-off).: _Let \(S U\) be a set of size \(k\). For any \( 0\) and \(0 1\), any \((,)\)-DP algorithm for representing \(S\) must have error probability \((1-)/(e^{}+1)\)._

**Theorem 1.4** (Space-privacy trade-off).: _Let \(S U\) be a set of size \(k\). For any \( 0\) and \(0 1\), any \((,)\)-DP algorithm for representing \(S\) with error probability \(0<<1/2\), the encoding bit size must be \((((1+/e^{}) k((1/)-1)),)\)._

We can consider the space lower bound restricted to algorithms that obtain the optimal privacy-utility trade-off as well. Therefore, we can set \(=(1-)/(e^{}+1)\) into the above lower bound. Assuming standard values of very small \(\), we can see that the lower bound becomes \((k(1/))=(k)\). Note that our constructions use space of \(1.05ke(e)\) and \(ke(e)\) bits respectively with error probability \(=1/(e^{}+1)\). In other words, the space usage asymptotically matches our lower bound for all reasonable parameter choices of \(\). In our proof, we work out the exact constants and show that the constant in the lower bound approaches \((e)\) for larger values of \(\). In fact, we show that both our constructions exactly match the lower bound up to a very small constant of at most \(4\) that only occurs when \(=0\). Furthermore, we note our lower bounds also apply to probabilistic filters (such as Bloom filters) that could also emit false negative errors.

### Related work

**Private filters.** Bloom filter  is a space efficient, probabilistic data structure that can be used to test whether an element is a member of a set.  show that flipping each bit of a Bloom filter with probability \(1/(1+e^{/t})\) is \(\)-DP where \(t\) is the number of hash functions. However, their work only experimentally evaluates the utility without any provable guarantees. Additionally, we note that prior works have attempted to analyze the privacy properties of filter data structures without modification. For example, this has been studied for Bloom filters , counting Bloom filters  as well as groups of multiple filter data structures . In general, the conclusion is that filter data structures without modification fail to obtain reasonable privacy guarantees. Finally, we note Bloom filters have also been used in other differential privacy contexts such as RAPPOR  where the goal is to aggregate discrete value responses from clients with local DP.

**Private sparse histograms and vectors.** A histogram is a frequency vector where each coordinate may take on real values. It is known that histograms can be made differentially private by adding Laplacian noise to each coordinate . The expected error of each entry is \(O(1/)\) where \(\) is the privacy parameter, and it was shown that this privacy-utility trade-off is essentially optimal [23; 4].

Several works have considered the setting where the histogram is sparse and at most \(k\) out of \(d\) coordinates are non-zero. The goal is to release a representation of the histogram whose size does not depend on \(d\). Compared to the Laplacian mechanism, earlier works either suffered from significantly worse privacy-utility trade-offs [25; 13] or incurred very slow access time . More recently, Aumuller _et al._ proposed an ALP mechanism that achieves expected error of \(O(1/)\) (matching the lower bound asymptotically) with access time of \(O(1/)\). The space usage is also very efficient, obtaining \(O(k(d+u))\) bits where \(u\) is the upper bound on the value of the entries.

Another line of work considers private versions of count sketch, introduced in , which can be viewed as a generalization of the Bloom filter. Each element in the set has an associated frequency, and the goal is to estimate the frequency of any element in the universe. Viewing the set as a sparse vector of frequencies, the basic idea of the count sketch is to transform the sparse vector \(^{d}\) to a lower dimensional vector via an affine transformation \(^{D}\), where \(\) is a random matrix from a specific distribution. From \(\), each coordinate \(_{i}\) can be estimated with error that depends on \(D\) and the norm of \(\). Several works [24; 28; 34; 35] analyze the privacy-utility trade-off of the private count sketch with different noise distributions in the context of estimating the frequencies of the elements. Due to the linearity of count sketch, these works also studied the problem in the local model where the histogram is distributed amongst multiple parties. These works consider a more general problem setting than ours. As discussed earlier, it is not immediately obvious how the error guarantees of private count sketch will translate to our problem setting.

## 2 Preliminaries

**Notation.** Throughout our paper, we will use \( x\) to denote natural (base-\(e\)) logarithms and use \( x\) to denote base-2 logarithms. We denote \([x]\) as the set \(\{1,,x\}\) for any integer \(x 0\). We denote all vectors in lower case boldface \(\) and matrices in capital case boldface \(\). We denote \([i]\) as the \(i\)-th entry of \(\). Similarly, we denote \([i][j]\) as the \(j\)-th entry of the \(i\)-th row vector of \(,[i]\) as the \(i\)th row vector, and \([:][j]\) as the \(j\)th column vector. We denote \([a:b]\) as the subvector of \(\) in range \([a,b]\). We use \(^{}\) as the transpose of \(\). We use \(^{n}\) to denote the set of all column vectors of length \(n\) over a field \(\) and \(^{n m}\) to denote the set of all \(n\) by \(m\) matrices over a field \(\). We use the notation \(_{x S}\) such that \(_{x S}=1\) if and only if \(x S\) and \(_{x S}=0\) otherwise when \(x S\). Finally, given a countable set \(S\), we will use \(S_{i}\) to denote the \(i\)-th element in \(S\) (in arbitrary order). The subscript is simply used as a label to distinguish the elements.

**Differential privacy.** The notion of differential privacy (DP) was introduced by . DP algorithms guarantee that small changes to the input will not drastically change the output probability distribution. In other words, two similar (or nearby) inputs will result in very similar output distributions.

Throughout our work, our inputs will be sets \(S\) from a universe \(U\), \(S U\). We measure the distance between two sets \(S\) and \(S^{}\) as the symmetric set difference that we denote as \(S S^{}=|S S^{}|+|S^{} S|\). This is the number of elements that appear in exactly one of \(S\) and \(S^{}\). One can interpret the symmetric set difference as the minimum number of elements that need to be added or removed to obtain \(S^{}\) from \(S\) (or vice versa). We say that two input sets are neighboring when their symmetric set difference is one, that is, \(S S^{}=1\). For convenience, we will denote the distance between two sets \(S\) and \(S^{}\) as \(|S-S^{}|=S S^{}\) to conform with standard differential privacy notation.

We note that one can also interpret the above using \(_{1}\) distances between vectors. For every entry \(u U\), we can denote with a unique integer from the set \([|U|]\). Suppose, we use a function \(z:U[|U|]\) as this mapping. For any set \(S U\), we map \(S\) to the vector \(_{S}\{0,1\}^{|U|}\) such that \(_{S}[i]=1\) if and only if there exists \(u S\) such that \(z(u)=i\). With this interpretation, we note that the symmetric set difference between two sets \(S\) and \(S^{}\), \(S S^{}\), is identical to the \(_{1}\) distance between the corresponding vectors defined as \(|_{S}-_{S^{}}|_{1}=_{i[|U|]}|_{S}[ i]-_{S^{}}[i]|\).

We present the definition of differential privacy following standard definitions .

**Definition 2.1**.: A randomized algorithm \(\) with domain \(\) is \((,)\)-differentially private if, for all \(R()\) and for all \(x,y\) such that \(|x-y|=1\), then

\[[(x) R] e^{}[ (y) R]+\]

over the randomness of the algorithm \(\).

**Differentially private set representations.** We focus on differentially private algorithms for releasing sets \(S\) of size at most \(\), that is, \(S U\) such that \(|S|\) for some input parameter \(\). We will focus on the case where the universe \(U\) is substantially larger than the input set \(S\).

**Definition 2.2**.: An algorithm \(=(.,.)\) for representing sets consists of:

* \((S)\): The (randomized) encoding takes set \(S U\) and returns encoding \(\).
* \(b.(,u)\): The decoding takes encoding \(\) and element \(u U\) and outputs \(b\{0,1\}\).

The construction (encoding) time is the running time of \(.\) and the access (decoding) time is the running time of \(.\). The space is the size of encoding \(\).

In other words, an algorithm for releasing sets creates an encoding \(\) of a set \(S U\). Furthermore, the algorithm enables checking whether any element \(u U\), appears in \(S\) using the encoding \(\).

Next, we define the utility of the differentially private set problem through its error probability. An error occurs when the decoding algorithm for a query \(q U\) returns an answer that is inconsistent with the original input set \(S\).

**Definition 2.3**.: An algorithm \(=(.,.)\) for representing sets has error probability at most \(\) if, for any input set \(S U\) and any set of queries \(Q U\),

\[[ q Q,_{q S}.(,q)] ^{|Q|}\]

where \(.(S)\) and the probability is over the randomness of \(.\).

For any set of queries \(Q\), the probability that all \(|Q|\) queries are incorrect is at most \(p^{|Q|}\). This is a stronger definition than prior works that consider \(|Q|=1\) because it also ensures independence of incorrect answers. For example, consider any two queries \(q_{1} q_{2} U\). Each of them must be incorrect with probability at most \(\) by setting \(Q=\{q_{1}\}\) or \(Q=\{q_{2}\}\). Furthermore, they must be independent since the probability that they are both incorrect is at most \(^{2}\) by setting \(Q=\{q_{1},q_{2}\}\). This independence argument may be extended to arbitrary query set with more than two queries.

We can also interpret this definition as per-entry expected error used in private histograms that bounds the absolute value between the true and decoded value. Our definition may be viewed as privately encoding an \(|U|\)-length binary vector such that \([|_{q S}-.(,q)|]\) for any element \(q U\) and encoding \(.(S)\). In other words, the expected per-entry error is at most \(\).

## 3 Differentially private sets

In this section, we present our main two constructions for differentially private sets. Before we present our constructions, we present a framework for building these algorithms using linear systems that satisfy certain properties. In particular, our work is inspired and generalizes prior retrieval data structures based on linear systems such as [29; 15; 16; 7]. Afterwards, we instantiate the linear systems in two different ways to obtain our constructions (although, one could use other linear systems as we will provide some examples later).

### Framework from linear systems

We present a general framework based on linear systems for building DP set mechanisms. We consider linear systems over a finite field \(\) with two functions: Row and Solve.

Recall that our problem is to release differentially private representation of \(S U\) such that \(|S|\), where \(\) is the input to the algorithm. We assume \(:U^{1 m}\) is a hash function mapping universe elements to row vectors of length \(m\). Here, the parameter \(m\) is a function of \(\) and does not depend on the size of the input set \(S\). Given a set \(S=\{s_{1},,s_{k}\} U\) of \(k\) elements, one can view Row as hashing \(S\) to a \(k m\) matrix:

\[=[(s_{1})\\ \\ (s_{k})].\]

The algorithm Solve takes an matrix \(^{k m}\) and solution vector \(^{k}\) to compute the solution \(^{m}\) satisfying \(=\). In particular, Solve will make the assumption that \(\) is the generated output of Row for some set \(S U\) of size \(k\). For our chosen linear systems, Solve will be faster than the naive application of Gaussian elimination. We also make some additional assumptions about Solve. First, we will exclusively focus on the case where the matrix has more columns than rows, \(n k\). Secondly, if the input matrix \(\) does not have full rank, then Solve will return \(\). Lastly, all free variables will be set to uniformly random elements from \(\).

We note that Row will generate rows in some structured way depending on the chosen linear system to ensure Solve successfully outputs a solution with high probability assuming the number of columns \(m\) is sufficiently larger compared to the number of rows \(k\). In our work, we focus on two constructions:random band  and Vandermonde matrices. Although, our framework is compatible with any linear system.

We will also use a hash function \(h:U\) that maps each element in the universe \(U\) to elements in \(\). We will use \(h\) to generate the solution vector \(\) in the above linear system. For some noised input set \(S=\{s_{1},,s_{k}\} U\), the solution vector will be \(=[h(s_{1}),,h(s_{k})]^{}\).

In our work, we will assume that all hash functions are fully random following prior works including . In practical implementations, we use cryptographic hash functions to replace this assumption as done in the past . Specifically, we will assume that \(h\) and \(\) are fully random when necessary (for one of our constructions, \(\) will be deterministic).

**Encoding.** Suppose we are given an input set \(S=\{s_{1},,s_{k}\} U\) of size \(|S|=k\). First, we generate random hash function \(h\) and (possibly random) row function \(\). Next, we will randomly sample a subset \(S^{} S\) such that each element of \(S\) will appear in \(S\) except with some _exclusion probability_\(p\) (that we pick later during analysis). For convenience, denote \(S^{}=\{s^{}_{1},,s^{}_{k^{}}\}\) where \(k^{}=|S^{}|\). Encoding works by constructing a matrix \(\) using \(\) and noisy input set \(S^{}\) as \(=[(s^{}_{1}),,(s^{}_{k^{ }})]^{}\). Next, a solution vector \(\) is created by hashing each of the elements in \(S^{}\) using the hash function \(h\). So, \(=[h(s^{}_{1}),,h(s^{}_{k^{}})]^{}\). Finally, we compute encoding \(\) using \(\) for the following linear system:

\[=[(s^{}_{1})\\ \\ (s^{}_{k^{}})]=[ h(s^{}_{1})\\ \\ h(s^{}_{k^{}})].\]

The final encoding will be \(=(,h,)\). See Algorithm 1 for formal pseudocode.

```
0:\(S,p,m\): input, exclusion probability \(p\), output length \(m\)
0:\(:\) DP encoding of \(S\)  Generate random hash function \(h:U\).  Generate (random) \(:U^{1 m}\). \(S^{}\{\}\) for\(s S\)do  Add \(s\) to \(S^{}\) with probability \(1-p\) endfor \(|S^{}| m\) matrix \(^{|S^{}| m}\) \(\) length \(|S^{}|\) column vector. for\(i[|S^{}|]\)do \([i](S^{}[i])\) \([i] h(S^{}[i])\) endfor \((,)\) if\(bx\)then return\((,,h,)\) else return\((,,,S)\) endif
```

**Algorithm 1**\(\) algorithm

```
0:\(=(,,h,S),u\)
0: returns \(b\{0,1\}\) if\(S\)then return\(u S\) endif
```

**Algorithm 2**\(\) algorithm

```
0:\(=(,,h,S),u\)
0: returns \(b\{0,1\}\) if\(S\)then return\(u S\) endif \(y(u)\) return\(_{y=h(u)}\)
```

**Algorithm 3**\(\) algorithm

We can view the above as using the linear system to embed linear constraints that are satisfied by elements of the noisy input set \(S^{}\). For every \(s^{} S^{}\), we know that \((s^{}

**Decoding.** Suppose we are given an encoding \(=(,h,)\) and an element \(u U\). Decoding checks whether an element's corresponding linear system is satisfied by computing \((u)\) and comparing with \(h(u)\). In other words, the decoding algorithm simply returns \(_{(u)=h(u)}\). We present the pseudocode in Algorithm 2.

We start by presenting the error probability (utility) with respect to field size \(||\) and the exclusion probability \(p\) of removing any element. We defer the proofs to Appendix A.

**Theorem 3.1**.: _If \(||=^{-1}\) and \(p=/(1-)\), then \(.\) has error probability \(\)._

For error probability \(\), we pick \(|| 1/\) holds where \(\) is a finite field. We note that there is a finite field of size \(q^{r}\) for any prime \(q\) and positive integer \(r 1\). For practical purposes, we use the smallest integer \(q^{r}\) larger than \(1/\) that gives us slightly smaller error probability.

Next, we prove privacy of our framework. We defer the full proof to Appendix B.

**Theorem 3.2**.: _If \(\) errs with probability at most \(\), then \(\) is \((,)\)-DP with error \((e^{}+1)^{-1}\)._

Our construction's expected per-entry error of \(=1/(e^{}+1)\) is exponentially smaller than achievable by private histograms where \((1/)\) error is required .

Next, we analyze the encoding size. In general, these are largely dependent on the underlying linear system. The encoding size depends on the number of variables (columns) \(m\) in the linear system. Additionally, it also includes representations of the functions \(h\) and \(\).

**Theorem 3.3**.: \(.\) _outputs encodings of \(m\) field elements and encodings of \(h\) and \(\)._

In Appendix E, we outline a possible optimization to reduce encoding size by picking \(m\) closer to the expected size of the sampled set \(S^{}\). This turns out to be a more theoretical as we were unable to observe space improvements empirically for reasonable choices of set size \(k\) and error probability \(\).

**Computational time.** For computation, the majority of the work is done by the underlying linear system. In particular, \(.\) requires only \(O(k)\) time outside of \(\) and \(\). Similarly, \(.\) requires an execute of \(\) and the computation will depend on the number of non-zero entries in \(\). We analyze the computational costs for our instantiations later.

**Larger error of \(>1/2\).** Our constructions only consider error probabilities \( 1/2\). This is implicit as the smallest field has size at least \(2\). There are trivial algorithms to obtain mechanisms with \(=0\) and \(=0\) for the case of \( 1/2\) using a random hash function (see Appendix F).

### Approximate differentially private sets

From Section 3.1, our goal essentially boils down to constructing a linear system where a solution exists and may be efficiently computed with high probability. Furthermore, we want to minimize the number of variables required to ensure small encoding sizes. To this end, we will use the _random band row vector_ construction of .

The random band construction is parameterized by the row length \(m\) and the band length \(w\). At a high level, each row consists of a single band of \(w\) random field elements. The band's location is chosen uniformly at random. All \(m-w\) entries outside of the band will be zero. Formally, the construction uses hash functions \(h_{1}:U[m-w+1]\) and \(h_{2}:U^{1 w}\). For \(u U\), \(h_{1}(u)\) denotes the band's starting location and \(h_{2}(u)\) is the \(w\) elements in the band. Generating a random \(_{}\) is equivalent to generating the two random hash functions \(h_{1}\) and \(h_{2}\). \(_{}\) works by sorting the rows by starting band location and executing Gaussian elimination. See Algorithms 3 and 4.

```
\(u\): element \(u U\)
0:\(\) : random band row vector \(m\) length of the vector \( 0^{1 m}\) (all zero row vector of length \(m\)) \(s h_{1}(u)\) \([s:s+w-1] h_{2}(u)\) return\(\)
```

**Algorithm 4**\(_{}\) algorithm

```
\(,\): matrix and vector \(\) : solution satisfying \(=\)  Sort rows by starting band location.  Execute Gaussian elimination and set free variables to be random elements in \(\) to obtain encoding \(\). return\(\)
```

**Algorithm 5**\(_{}\) algorithm

```
\(,\): matrix and vector \(\) : solution satisfying \(=\)  Sort rows by starting band location.  Execute Gaussian elimination and set free variables to be random elements in \(\) to obtain encoding \(\). return\(\)
```

**Algorithm 6**\(_{}\) algorithm

```
\(,\): matrix and vector \(\) : solution satisfying \(=\)  Sort rows by starting band location.  Execute Gaussian elimination and set free variables to be random elements in \(\) to obtain encoding \(\). return\(\)
```

**Algorithm 7**\(_{}\) algorithm

``` \(,\): matrix and vector \(\) : solution satisfying \(\) runs in \(O(mw)\) time except with probability \(O(1/m)\). Bienstock _et al._ extended this result to show that, if \(w=O((1/)+ k)\), then the matrix has full row rank and the linear system can be solved in time \(O(mw)\) except with probability \(\). \(\) takes \(O(w)\) time since computing the dot product scales linearly with \(w\), the length of the band. We obtain the following using random band row vectors:

**Theorem 3.4**.: _For any \(>0\), \(>0\), \(>0\), there is an \((,)\)-DP set mechanism with error \((e^{}+1)^{-1}\) and encodings consisting of \((1+)k\) field elements and three hash functions. \(\) takes \(O(kw)\) time and \(\) takes \(O(w)\) time where \(w=O((1/)+ k)\)._

### Pure differentially private sets

We consider a pure differentially private construction of the framework in Section 3.1 with \(=0\). In Section 3.1, the failure probability of solving the constructed linear system corresponds to \(\) in the DP definition. To obtain a pure DP construction, our goal is to construct a linear system that is solvable with probability 1. So, we want to construct a matrix \(\) that has full rank with probability 1. To do this, we use the _Vandermonde matrix_ construction (where Row is deterministic) that may be solved in \(O(k^{2}k)\) time as shown in . This construction has another advantages over the random band approach beyond obtaining \(=0\). The resulting encodings are smaller with only \(k\) field elements whereas the other construction requires \(m=(1+)k\) field elements with \(>0\). In contrast, decoding times are larger here. See Appendix C for full description and proof.

**Theorem 3.5**.: _For any \(>0\), there exists an \(\)-DP set mechanism with error \((e^{}+1)^{-1}\). \(\) takes \(O(k^{2}k)\) time and \(\) takes \(O(k)\) time._

**Other Constructions.** We present two concrete constructions from specific linear systems, but it is possible to plug in other linear systems. For example, plugging in  would result in a pure DP solution with faster encoding times, but larger encoding sizes compared to Theorem 3.5.

## 4 Lower bounds

**Privacy-utility lower bounds.** We start by considering the possibility of improving the error probability (utility) with respect to the desired levels of privacy. Our construction achieved error probability at most \(1/(e^{}+1)\) for any choice of \( 0\). In other words, for any error \(\), our construction achieves privacy \(=((1-)/)\). We show that this trade-off between \(\) and error probability is optimal even up to constants (ignoring \(\) factors). See Appendix D for the proof.

**Theorem 4.1**.: _Consider any \((,)\)-DP algorithm \(\) for sets of size \(k\). Suppose that \(\) has error probability at most \( 1/2\). Then, \(((1--)/)\). In other words, for a fixed privacy level \( 0\) and \( 0\), the error probability of \(\) must be \((1-)(e^{}+1)\)._

**Space lower bounds.** Next, we move onto determining the necessary space usage of set representations. There exist space lower bounds for probabilistic membership data structures (such as Bloom filters) that have a false positive probability of \(\) and no false negatives. It is well known that such data structures require \(k(1/)\) bits of space when given an input of size \(k\). However, these lower bounds only apply when the false negative rate is \(0\). See Broder and Mitzenmacher  for the prior lower bound. We present a space lower bound for DP mechanisms with non-zero false negatives using a proof through compression that deviates from prior counting arguments (see Appendix D).

**Theorem 4.2**.: _Consider any \((,)\)-DP \(\) for sets of size \(k\). If \(\) produces \(s\)-bit encodings with error probability \(0< 1/2\), then \([s]=((1+/(e^{})) k(1/))\)._

## 5 Experimental evaluation

**Setup.** We implemented \(\), ALP  and DP Count Sketch  in C++ using 800 lines of code. For \(\), we use the analysis of Bienstock _et al._ to choose appropriate parameters for \( 2^{-40}\) with parameter \(=0.05\). To fit ALP and DP Count Sketch to our problem setting, we round the query results of these mechanisms to the nearest 0 or 1. We target privacy parameter \( 2^{-40}\) for all three constructions. To fairly compare utility, we chose parameters to ensure that encoding sizes are approximately equal for all three constructions (see Appendix G for more details on encoding sizes).

We consider experiments for input sets of size \(k\{2^{12},2^{16},2^{20}\}\). Each trial picks input sets as \(k\) uniformly random \(128\)-bit strings from a universe of all \(n=2^{128}\) strings. Although, all three constructions are agnostic to the distribution of the input set. We ran all experiments using a Ubuntu PC with 12 cores, 3.7 GHz Intel Xeon W-2135 and 64 GB of RAM. Our experiments enable AVX2 and AVX-512 instruction sets with SIMD instructions. All reported results use single-thread execution as the average of at least 1,000 trials with standard deviation less than 10% of the average. The entire experimental evaluations (including setup) took approximately 1 hour of compute time.

**Utility.** To measure utility, we query the entire input set of size \(k\) as well as a random subset of \(k\) elements outside of the set in each trial. We plot our results in Figure 1 along with our lower bound (Theorem 4.1). We see that \(\) has much better utility compared to the prior works. Furthermore, our experiments corroborate our theoretical analysis that error probability exponentially decreases in \(\) and essentially matches our lower bound of \((1-)/(e^{}+1)(1-2^{-40})/(e^{}+1)\).

**Efficiency.** We compare the efficiency of encoding input sets and decoding random elements. For larger input set sizes \(k\) and bigger \(\), our constructions have faster encoding times. In contrast, \(\) has slower encoding for smaller \(k\) and \(\). For decoding, \(\) has slower times than both prior works. Nevertheless, decoding times of \(\) remain very fast and are less than \(0.3\) milliseconds.

Figure 1: Comparisons of of \(\), ALP, and DP Count Sketch with \( 2^{-40}\). The \(x\)-axis is privacy parameter \(\) and the \(y\)-axis is error probability, encoding time (ms) or decoding time (ms).

Conclusions

In this work, we present constructions of DP sets that are essentially optimal in privacy-utility and space trade-offs nearly matching our lower bounds. The error obtained is exponentially smaller (both theoretically and empirically) than possible for private histograms mostly studied in prior works. Additionally, we experimentally show that our constructions are concretely efficient.

**Limitations.** A limitation of our work is that we consider sparse sets (as opposed to the more general sparse histograms). Nevertheless, we believe this specific problem has several important applications with the added benefit of exponentially smaller error. Our constructions assume fully random hash functions (following several prior works) and instantiations are limited to finite field sizes. If we assume pseudorandom hash functions (PRFs), our construction obtains computational DP instead.

## 7 Acknowledgements

The authors would like to thank Rachel Cummings for feedback on earlier versions of this paper.