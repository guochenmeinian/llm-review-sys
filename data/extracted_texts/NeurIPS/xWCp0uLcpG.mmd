# Robust Data Pruning under Label Noise

via Maximizing Re-labeling Accuracy

 Dongmin Park\({}^{1}\), Seola Choi\({}^{1}\), Doyoung Kim\({}^{1}\), Hwanjun Song\({}^{2}\), Jae-Gil Lee\({}^{1}\)

\({}^{1}\) KAIST, \({}^{2}\) AWS AI Labs

{dongminpark, seola.choi, dodokim, jaegil}@kaist.ac.kr, hwanjun.song@amazon.com

Corresponding author.

###### Abstract

_Data pruning_, which aims to downsize a large training set into a small informative subset, is crucial for reducing the enormous computational costs of modern deep learning. Though large-scale data collections invariably contain annotation noise and numerous robust learning methods have been developed, data pruning for the _noise-robust learning_ scenario has received little attention. With state-of-the-art _Re-labeling_ methods that self-correct erroneous labels while training, it is challenging to identify which subset induces the most accurate re-labeling of erroneous labels in the entire training set. In this paper, we formalize the problem of _data pruning with re-labeling_. We first show that the likelihood of a training example being correctly re-labeled is proportional to the prediction confidence of its neighborhood in the subset. Therefore, we propose a novel data pruning algorithm, Prune4ReLU, that finds a subset maximizing the total neighborhood confidence of all training examples, thereby maximizing the re-labeling accuracy and generalization performance. Extensive experiments on four real and one synthetic noisy datasets show that Prune4ReLU outperforms the baselines with Re-labeling models by up to 9.1\(\%\) as well as those with a standard model by up to 21.6\(\%\).

## 1 Introduction

By virtue of ever-growing datasets and the neural scaling law [1; 2], where the model accuracy often increases as a power of the training set size, modern deep learning has achieved unprecedented success in many domains, _e.g._, GPT , CLIP , and ViT . With such massive datasets, however, practitioners often suffer from enormous computational costs for training models, tuning their hyper-parameters, and searching for the best architectures, which become the main bottleneck of development cycles. One popular framework to reduce these costs is _data pruning_, which reduces a huge training set into a small subset while preserving model accuracy. Notably, Sorscher et al.  have shown that popular data pruning approaches can break down the neural scaling law from power-law to exponential scaling, meaning that one can reach a desired model accuracy with much fewer data. Despite their great success, the impact of _label noise_ on data pruning has received little attention, which is unavoidable in real-world data collection [7; 8; 9].

Noisy labels are widely known to severely degrade the generalization capability of deep learning, and thus numerous robust learning strategies have been developed to overcome their negative effect in deep learning . Among them, _Re-labeling_, a family of methods that identify wrongly labeled examples and correct their labels during training by a self-correction module such as self-consistency regularization , has shown state-of-the-art performance. For example, the performance of DivideMix  trained on the CIFAR-10N  dataset containing real human annotation noise is nearly identical to that of a standard model trained on the clean CIFAR-10 dataset. Consequently, it is evident that this excellent performance of re-labeling must be carefully considered when designing a framework for data pruning under label noise.

In this paper, we formulate a new problem of _data pruning with re-labeling_ for a training set with noisy labels, which aims to maximize the generalization power of the selected subset with expecting that a large proportion of erroneous labels are self-corrected (_i.e._, re-labeled). Unfortunately, prior data pruning and sample selection algorithms are not suitable for our problem because the re-labeling capability is not taken into account, and have much room for improvement as shown in Figure 1(a). Popular data pruning approaches (denoted as Forgetting  and GraNd  in blue and yellow, respectively) favor hard (_i.e._, uncertain) examples because they are considered more beneficial for generalization ; however, because it is very difficult to distinguish between hard examples and incorrectly-labeled examples , many of the incorrectly-labeled examples can be included in the subset causing unreliable re-labeling. In addition, the small-loss trick  (denoted as SmallLoss in green) for sample selection favors easy examples because they are likely to be correctly labeled; however, they are not beneficial for generalization at a later stage of training. Therefore, this new problem necessitates the development of a new data pruning approach.

Accordingly, we suggest a completely novel approach of finding a subset of the training set such that _the re-labeling accuracy of all training examples is preserved as much as possible with the model trained on the subset_. The first challenge in this direction is how to estimate whether each example can be re-labeled correctly even before fully training models on the candidate subset. The second challenge is how to find the subset that maximizes the overall re-labeling accuracy of the entire training set in an efficient manner.

Addressing these two challenges, we develop a novel framework, called **Prune4ReLU**. For the first challenge, we define the concept of the _neighborhood confidence_ which is the sum of the prediction confidence of each neighbor example in the selected subset. We show that, as in Figure 1(b), an example with high neighborhood confidence is likely to be corrected by Re-labeling methods. We further provide theoretical and empirical evidence of this argument. For the second challenge, we show that the overall re-labeling accuracy is maximized by selecting a subset that maximizes the sum of its reachable neighborhood confidence for all training examples, as shown in Figure 1(c). Furthermore, because enumerating all possible subsets is a combinatorial optimization problem which is NP-hard , we provide an efficient greedy selection algorithm that expands the subset one by one by choosing the example that most increases the overall neighborhood confidence.

Extensive experiments on four real noisy datasets, CIFAR-10N, CIFAR-100N, WebVision, and Clothing-1M, and one synthetic noisy dataset on ImageNet-1K show that Prune4ReLU consistently outperforms the _eight_ data pruning baselines by up to 9.1%. Moreover, Prune4ReLU with Re-labeling models significantly outperforms the data pruning baselines with a standard model by up to 21.6\(\%\), which reaffirms the necessity of data pruning with re-labeling.

## 2 Preliminary and Related Work

### Robust Learning under Noisy Labels

A long line of literature has been proposed to improve the robustness of DNNs against label noise, and refer to  for a detailed survey for deep learning with noisy labels. While some studies have

Figure 1: Key idea of Prune4ReLU: (a) shows data pruning performance of Prune4ReLU and existing sample selection methods on CIFAR-10N with DivideMix; (b) shows how the neighborhood confidence affects the re-labeling correctness; (c) shows the goal of Prune4ReLU that maximize the neighbor confidence coverage to the entire training set, thereby maximizing the re-labeling accuracy.

focused on modifying the architectures [20; 21; 22] and the loss functions [23; 24; 25], others have opted for sample selection approaches [26; 18; 27; 28] that select as many clean examples as possible while discarding noisy examples based on a certain cleanness criterion, _e.g._, small-loss . Note that, these works do not consider the compactness or efficiency of the selected subset. Meanwhile, to further exploit even noisy examples for training, _Re-labeling_[11; 29] approaches try to correct noisy labels and reuse them for training with a re-labeling module, _e.g._, a heuristic rule . Notably, according to recent benchmark studies on real-world noisy datasets , a family of Re-labeling methods with _self-consistency regularization_ has shown state-of-the-art performance.

In general, Re-labeling methods with self-consistency regularization are based on

\[_{Relabeling}(};,)=_ {(x,)}}_{[C_{}(x)]} _{ce}(x,;)+_{x}} _{reg}(x;,),\] (1)

where \(}=\{(x_{i},_{i})\}_{i=1}^{m}\) is a given noisy training set obtained from a noisy joint distribution \(}\), \(\) is a classifier, \(\) is a strong data augmentation, \(_{}()\) is a prediction confidence score, and \(\) is a threshold to identify confident (clean) examples for the supervised loss \(_{ce}(x,;)\), _i.e._, cross-entropy. The noisy labels are implicitly corrected by the self-consistency loss \(_{reg}(x;)\) leveraging the power of strong augmentations . DivideMix , ELR+ , CORES , and SOP+  are popular approaches belonging to this family. DivideMix uses a co-training framework to further improve the re-labeling accuracy, and SOP+ introduces additional learnable variables combined with a self-consistency loss. For simplicity, we call this Re-labeling family with self-consistency regularization as "Re-labeling" throughout the paper. Despite their effectiveness, Re-labeling models tend to require more computation time due to additional data augmentations, multiple backbones, and longer training epochs, which raises a need to enhance its efficiency.

### Data Pruning

In order to achieve high generalization performance with a selected subset, most data pruning approaches often prioritize the selection of hard or uncertain examples. Specifically, _uncertainty-based_ methods [34; 35; 36] favor selecting less confident examples over more confident ones, as the former is assumed to be more informative than the latter. Similarly, _geometry-based_ methods [37; 38] focus on removing redundant examples that are close to each other in the feature space, and _loss-based_ methods [14; 15; 39; 40] favor selecting the examples with a high loss or gradient measured during training. However, these existing methods may not be effective in realistic scenarios under label noise because noisy examples also exhibit high uncertainty and could be wrongly considered informative for training . Meanwhile, some recent works reported that existing data pruning methods do not work well at high pruning ratios [41; 42]. To alleviate this drawback, AL4DP  shows that mixing various levels of uncertain examples is better for data scarcity, Moderate  aims to select examples with the distances close to the median, and CCS  proposes a coverage-based method that jointly considers data coverage with sample importance. While a few works attempted to improve the robustness of sample selection against label noise by filtering the noise , no work yet considers the effect of data pruning on noise-robust learners such as Re-labeling.

## 3 Methodology

We formalize a problem of data pruning with re-labeling such that it finds the most informative subset \(\), where a model \(_{}\) trained on \(\) maximizes the re-labeling accuracy of the entire noisy training set \(}=\{(x_{i},_{i})\}_{i=1}^{m}\)2. Formally, we aim to find an optimal subset \(^{*}\) such that

\[^{*}=*{argmax}_{:\ |\| s} _{(x,)}}_{[(x;_{ })=y^{*}]}\ :\ \ _{}=*{argmin}_{}\ \ _{Re labeling}(;,),\] (2)

where \(y^{*}\) is the ground-truth label of a noisy example \(x\), \(f(x;_{})^{c}\) is a \(c\)-way class prediction of the example \(x\) from the Re-labeling model \(_{}\), and \(s\) is the target subset size.

Finding the optimal subset \(^{*}\) through direct optimization of Eq. (2) is infeasible because the ground-truth label \(y^{*}\) is unknown in practice. In addition, the subset should be found at the early stage of training, _i.e._, in a warm-up period, to reduce the computational cost . To achieve these goals in an accurate and efficient way, in Section 3.1, we first introduce a new metric, _the reduced neighborhood confidence_, that enables estimating the re-labeling capacity of a subset even in the warm-up period. Then, in Section 3.2, we propose a new data pruning algorithm _Prune4ReL_ using this reduced neighborhood confidence to find a subset that maximizes the re-labeling accuracy.

### Reduced Neighborhood Confidence

As a measurement of estimating the re-labeling accuracy, we use the confidence of neighbor examples for each target noisy example \(x\), because the noisy examples are known to be corrected by their _clean neighbor_ examples with self-consistency regularization . Specifically, once an augmentation of a noisy example has a similar embedding to those of other clean neighbors in the representation space, the self-consistency loss can force the prediction of the noisy example to be similar to those of other clean neighbors as a way of re-labeling. This property is also evidenced by a theory of re-labeling with a generalization bound . Thus, the neighboring relationship among examples can be a clear clue to estimate the re-labeling accuracy even in the early stage of training.

We define a _neighborhood_ and its _reduced neighborhood confidence_ to utilize the relationship of neighboring examples in Definitions 3.1 and 3.2.

**Definition 3.1**.: (Neighborhood). Let \((x_{i})=\{x||(x_{i})-x||\}\) be a set of all possible augmentations from the original example \(x_{i}\) using an augmentation function \(\). Then, given a noisy training set \(}\), a _neighborhood_ of \(x_{i}\) is defined as \((x_{i})=\{x}(x_{i}) (x)\}\), which is the set of examples that are reachable by the augmentation \(\). 

**Definition 3.2**.: (Reduced Neighborhood Confidence). The _reduced neighborhood confidence_\(C_{}(x_{i};)\) of an example \(x_{i}\) is the sum of the prediction confidence \(C()\) of its neighbors \(x_{j}(x_{i})\) in a given reduced (_i.e._, selected) subset \(\), which is formalized as

\[C_{}(x_{i};)=_{x_{j}}_{[x_ {j}(x_{i})]} C(x_{j}),\] (3)

and its _empirical reduced neighborhood confidence_ is computed by using the cosine similarity among the augmentations of all possible pairs of example embeddings,

\[_{}(x_{i};)=_{x_{j}} _{[sim((x_{i}),(x_{j}))]} sim (x_{i}),(x_{j}) C(x_{j}),\] (4)

where \(sim()\) is the cosine similarity between the augmentations \((x)\) of two different examples in the embedding space, and \(\) is a threshold to determine whether the two examples belong to the same neighborhood. Unlike Eq. (3), Eq. (4) is calculated as a weighted sum of prediction confidences with cosine similarity to approximate the likelihood of belonging to the neighborhood. 

Based on these definitions, we investigate the theoretical evidence of employing the reduced neighborhood confidence as a means to estimate the re-labeling capacity of a subset.

**Theoretical Evidence.** A subset \(\) with a _high_ value of the _total_ reduced neighborhood confidence, the sum of the reduced neighborhood confidence of each example in \(\), allows a Re-labeling model to maximize its re-labeling accuracy in the entire training set. We formally support this optimization by providing a theoretical analysis that extends the generalization bound in the prior re-labeling theory  to data pruning.

**Assumption 3.3**.: (Expansion and Separation). Following the assumption in , the \(\)-expansion and \(\)-separation assumptions hold for the training set \(}\). The \(\)-expansion means that an example is reachable to the \(\) number of augmentation neighbors on average, _i.e._, \(_{x}}[|(x)|]=\). The \(\)-separation means that data distributions with different ground-truth classes are highly separable, such that the average proportion of the neighbors from different classes is as small as \(\).

Under these assumptions, we can obtain a training accuracy (error) bound of a Re-labeling model trained on a subset \(S\) as in Theorem 3.4.

**Theorem 3.4**.: _Assume that a subset \(}\) follows \(_{}\)-expansion and \(_{}\)-separation, where \(_{}\). Then, the training error of a Re-labeling model \(_{}\) trained on \(\) is bounded by the inverse of the total reduced neighborhood confidence \(_{x}}C_{}(x;)\) such that,_

\[Err(_{})| Err(_{ })}{_{x}}C_{}(x;)}+ }}{_{}-1}_{},\] (5)

_where \(_{}\) is a model trained with the supervised loss in Eq. (1) on a given clean set \(\)._

Proof.: We extend the label denoising theorem in  by incorporating the influence of the subset to the expansion factor \(_{}\). The complete proof is available in Appendix A. 

Since \(_{}\) is usually very small, its effect on the error bound is negligible. Then, the bound highly depends on the total reduced neighborhood confidence. That is, as the total reduced neighborhood confidence increases, the error bound becomes tighter. This theorem supports that we can utilize the reduced neighborhood confidence for the purpose of maximizing the re-labeling accuracy.

**Empirical Evidence.** To empirically support Theorem 3.4, we validate the correlation between the empirical reduced neighborhood confidence3 and the re-labeling accuracy using CIFAR-10N, which is a real-world noisy benchmark dataset.

Specifically, we train DivideMix  on the \(20\%\) randomly selected subset \(\) for a warm-up training epoch of 10 and calculate the empirical reduced neighborhood confidence \(_{}(x;)\) for the entire training set. Next, we fully train DivideMix  on the random subset \(\). Last, we divide the entire training set into 15 bins according to the obtained \(_{}(x;)\) and verify the average re-labeling accuracy for each bin.

Figure 2 shows how the re-labeling accuracy changes according to the empirical reduced neighborhood confidence in Eq. (4). (The term "empirical" is simply omitted hereafter.) The re-labeling accuracy shows a strong positive correlation with the reduced neighborhood confidence. Interestingly, as the neighborhood confidence increases, its _utility_ in improving the re-labeling accuracy decreases, eventually reaching a convergence point after surpassing a certain threshold.

### Data Pruning by Maximizing Neighborhood Confidence Coverage

We present a new data pruning algorithm called _Prune4ReL_ which optimizes the total reduced neighborhood confidence defined in Eq. (4). This objective is equivalent to identifying a subset that maximizes the re-labeling accuracy on the entire training set, as justified in Theorem 3.4. Therefore, the objective of Prune4ReL is to find the subset \(^{*}\), which is formulated as

\[^{*}=*{argmax}_{:~{}|| s} _{x_{i}}}_{ }(x_{i};),\] (6)

where \((z)\) is a _utility_ function of the reduced neighborhood confidence \(_{}(x_{i};)\) in improving the re-labeling accuracy. By the observation in Figure 2, we define \((z)\) as a _non-decreasing_ and _concave_ function where \((0)=0\). In our implementation, we use the positive of the \(tanh\) function as the utility function, _i.e._, \((z)=tanh(z)\). However, directly solving Eq. (6) is computationally expensive and impractical due to its NP-hard nature as a Set-Cover problem . Accordingly, we employ an approximation solution to efficiently address this combinatorial optimization.

**Optimization with Greedy Approximation.** We present a practical solution for solving the optimization problem stated in Eq. (6) using a greedy approximation. The objective function satisfies both the _monotonicity_ and _submodularity_ conditions, indicating that the return of the objective function monotonically increases and the marginal benefit of adding an example decreases as the subset grows. Thus, a greedy sample selection can be employed as in Algorithm 1.

Figure 2: Correlation between neighborhood confidence and re-labeling accuracy on a 20\(\%\) randomly selected subset of CIFAR-10N.

In detail, we begin with an empty set \(\) and initialize the reduced neighborhood confidence \(_{}\) to 0 (lowest confidence) for all training examples (Line 1). Next, at every step, we select an example \(x\) that maximizes the marginal benefit \((_{}(x)+C(x))-(_ {}(x))\) of Eq. (6), and update the reduced neighborhood confidence \(_{}\) based on the similarity scores (Lines 3-7). To further improve robustness and efficiency, we introduce a class-balanced version, Prune4ReL\({}_{B}\), of which the detailed process is elaborated in Appendix B.

In Theorem 3.5, we guarantee the selected subset \(\) obtained by our greedy solution achieves a \((1-1/e)\)-approximation of the optimum.

**Theorem 3.5**.: _Since Eq. (6), denoted as \(OBJ\), is a monotone, submodular, and non-negative function on \(x\), the greedy solution provides a set with a \((1-1/e)\)-approximation of the optimum. Formally,_

\[OBJ()(1-1/e) OBJ(^{*}).\] (7)

Proof.: We prove the monotonicity and submodularity of Eq. (6). If the two conditions are satisfied, Eq. (7) naturally holds. See Appendix C for the complete proof. 

**Time Complexity Analysis.** We analyze the time complexity of our greedy approximation in Algorithm 1. At each step, Prune4ReL takes the time complexity of \(O(m m)\) + \(O(md)\), where \(m\) is the training set size and \(d\) is the embedding dimension size of the warm-up classifier. Specifically, in Line 3, sampling an example with the largest marginal benefit of confidence takes \(O(m m)\), and in Lines 5-6, updating the reduced neighborhood confidence of all training examples takes \(O(md)\). In addition, with Prune4ReL\({}_{B}\), the time complexity is reduced to \(O(m(m/c))\) + \(O(md)\) because it iteratively selects the example with the largest marginal benefit within each class subset, which is lower than the time complexity of a similar distance-based data pruning work, kCenterGreedy  aiming to maximize the _distance_ coverage of a selected subset to the entire training set by a greedy approximation. At each iteration, kCenterGreedy's runtime is \(O(mk_{t})\), where \(k_{t}\) is the size of the selected set at iteration \(t\). Note that, its time complexity increases as the subset size grows, which hinders its usability on a large-scale dataset. In Section 4.2, we empirically show that Prune4ReL is scalable to prune Clothing-1M, a large dataset with 1M examples, whereas kCenterGreedy is not.

```
1:\(}\): training set, \(s\): target subset size, and \(C(x)\): confidence from warm-up classifier
2:Initialize \(; x},\ _{}(x)=0\)
3:repeat
4:\(x\!=\!*{argmax}_{x}} (_{}(x)\!+\!C(x))\!-\!(_{}(x))\)
5:\(\!=\!\{x\}\)
6:for all\(v}\)do
7:\(_{}(v)\!+\!=_{ sim(x,v) } sim(x,v) C(x)\)
8:until\(||=s\)
9: Final selected subset \(\) ```

**Algorithm 1** Greedy Neighborhood Confidence

## 4 Experiments

### Experiment Setting

**Datasets.** We first perform the data pruning task on four _real_ noisy datasets, CIFAR-10N, CIFAR-100N, Webvision, and Clothing-1M. CIFAR-10N and CIFAR-100N  contain human re-annotations of 50K training images in the original CIFAR-10 and CIFAR-100 . Specifically, each training image in CIFAR-10N contains three noisy labels, called Random 1,2,3, which are further transformed into the Worst-case label. Each image in CIFAR-100N contains one noisy label. WebVision  and Clothing-1M  are two large-scale noisy datasets. WebVision contains 2.4M images crawled from the Web using the 1,000 concepts in ImageNet-1K . Following prior work , we use mini-WebVision consisting of the first 50 classes of the Google image subset with approximately 66K training images. Clothing-1M consists of 1M training images with noisy labels and 10K clean test images collected from online shopping websites. Additionally, a large-scale _synthetic_ noisy dataset, which we call ImageNet-N, is included in our experiments. It consists of 1.2M training images, which are the training images of ImageNet-1K  with asymmetric label noise. See Appendix D for details of the noise injection.

**Algorithms.** We compare Prune4ReL with a random selection from a uniform distribution, Uniform, a clean sample selection algorithm, SmallLoss , and six data pruning algorithms including Margin , \(k\)-CenterGreedy , Forgetting , GraNd , SSP , and Moderate . SmallLoss favors examples with a small loss. For data pruning algorithms, (1) Margin selects examples in the increasing order of the difference between the highest and the second highest softmax probability; (2) \(k\)-CenterGreedy selects \(k\) examples that maximize the distance coverage to the entire training set; (3) Forgetting selects examples that are easy to be forgotten by the classifier throughout the warm-up training epochs; (4) GraNd uses the average norm of the gradient vectors to measure the contribution of each example to minimizing the training loss; (5) SSP leverages a self-supervised pre-trained model to select the most prototypical examples; and (6) Moderate aims to select moderately hard examples using the distances to the median.

**Implementation Details.** We train two representative Re-labeling models, DivideMix  and SOP+  for our experiments. The hyperparameters for DivideMix and SOP+ are favorably configured following the original papers. Following the prior Re-labeling work , for CIFAR-10N and CIFAR-100N, PreAct Resnet-18  is trained for 300 epochs using SGD with a momentum of 0.9, a weight decay of 0.0005, and a batch size of 128. The initial learning rate is 0.02, and it is decayed with a cosine annealing scheduler. For WebVision, InceptionResNetV2  is trained for 100 epochs with a batch size of 32. For Clothing-1M, we use ResNet-50  pre-trained on ImageNet and fine-tune it for 10 epochs with a batch size of 32. The initial learning rates of WebVision and Clothing-1M are 0.02 and 0.002, which are dropped by a factor of 10 at the halfway point of the training epochs. For ImageNet-N, ResNet-50  is trained for 50 epochs with a batch size of 64 and an initial learning rate of 0.02 decayed with a cosine annealing scheduler.

For data pruning algorithms, following prior work , we perform sample selection after 10 warm-up training epochs for CIFAR-10N, WebVision, and ImageNet-N, and 30 warm-up epochs for CIFAR-100N. For Clothing-1M, we perform the sample selection after 1 warm-up training epoch from the ImageNet pre-trained ResNet-50. The hyperparameters for all data pruning methods are favorably configured following the original papers. For Prune4ReL, we set its hyperparameter \(\) to 0.975 for CIFAR-10N, to 0.95 for CIFAR-100N, WebVision, and ImageNet-N, and to 0.8 for Clothing-1M. More implementation details can be found in Appendix E. All methods are implemented with PyTorch 1.8.0 and executed on NVIDIA RTX 3080 GPUs. The code is available at https://github.com/kaist-dmlab/Prune4Rel.

**Evaluation.** For CIFAR-10N, CIFAR-100N, and WebVision, we select the subset with the selection ratios {0.2, 0.4, 0.6, 0.8}. For Clothing-1M and ImageNet-N, we construct the subset with {0.01, 0.05, 0.1, 0.2} and {0.05, 0.1, 0.2, 0.4} selection ratios, respectively. We measure the test accuracy of the Re-labeling models trained from scratch on the selected subset. Every experiment is run three times, and the average of the last accuracy is reported. For CIFAR-10N with the Random noise, we average the test accuracy of the models trained using the three noisy labels.

    Re-label \\ Models \\  } &  Selection \\ Methods \\  } &  &  \\  & &  &  &  \\  & & 0.2 & 0.4 & 0.6 & 0.8 & 0.2 & 0.4 & 0.6 & 0.8 & 0.2 & 0.4 & 0.6 & 0.8 \\   & Uniform & 87.5\(\)0.2 & 91.9\(\)0.2 & 93.7\(\)0.1 & 94.8\(\)0.1 & 83.2\(\)0.2 & 88.5\(\)0.1 & 90.2\(\)0.0 & 91.4\(\)0.0 & 30.5\(\)1.0 & 55.3\(\)0.5 & 57.5\(\)1.9 & 58.6\(\)0.9 \\  & SmallL & 68.1\(\)0.0 & 82.4\(\)0.8 & 89.0\(\)0.3 & 93.1\(\)0.1 & 70.3\(\)0.6 & 80.3\(\)0.2 & 89.1\(\)0.0 & 92.1\(\)0.0 & 33.3\(\)2.3 & 47.4\(\)1.1 & 59.4\(\)0.7 & 62.0\(\)1.2 \\  & Margin & 68.5\(\)0.2 & 88.5\(\)0.3 & 93.2\(\)0.2 & 94.7\(\)0.1 & 61.3\(\)0.9 & 75.1\(\)0.7 & 85.3\(\)0.2 & 90.2\(\)0.1 & 17.1\(\)0.3 & 30.8\(\)0.1 & 46.3\(\)2.4 & 61.2\(\)1.3 \\  & ACenter & 88.4\(\)0.9 & **93.0\(\)0.1** & 94.4\(\)0.2 & 95.0\(\)0.0 & 82.7\(\)0.8 & 88.4\(\)0.1 & 90.6\(\)0.1 & 92.2\(\)0.0 & 38.0\(\)0.1 & 50.1\(\)5.9 & 97.1\(\)1.3 & 63.0\(\)0.9 \\  & Forget & 88.2\(\)0.9 & **93.0\(\)0.1** & 94.5\(\)0.1 & 95.1\(\)0.1 & 78.3\(\)0.3 & 88.2\(\)0.1 & 90.4\(\)0.2 & 90.2\(\)0.1 & 26.4\(\)1.5 & 34.3\(\)0.3 & 63.1\(\)1.6 & 66.6\(\)1.1 \\  & GraNd & 21.8\(\)0.6 & 60.9\(\)0.5 & 92.5\(\)0.1 & 94.8\(\)0.1 & 18.5\(\)1.7 & 25.5\(\)0.9 & 49.3\(\)0.9 & 88.0\(\)0.5 & 15.5\(\)1.2 & 26.0\(\)1.9 & 44.7\(\)1.5 & 60.4\(\)1.6 \\  & SSP & 85.8\(\)0.1 & 92.2\(\)1.5 & 93.0\(\)0.1 & 94.5\(\)0.1 & 81.4\(\)2.5 & 86.5

### Main Results on Real Noisy Datasets

**Test Accuracy.** Table 1 summarizes the test accuracy of _eight_ baselines and Prune4ReL on CIFAR-10N and CIFAR-100N trained with two Re-labeling models. Overall, Prune4ReL consistently achieves the best performance for all datasets across varying selection ratios. Numerically, Prune4ReL improves DivideMix and SOP+ by up to 3.7% and 9.1%, respectively. Compared with six data pruning baselines, they show rapid performance degradation as the size of the subset decreases; most of them, which are designed to favor hard examples, tend to select a large number of noisy examples, resulting in unreliable re-labeling. While Moderate selects moderately hard examples, it is still worse than Prune4ReL since it is not designed for noise-robust learning scenarios with Re-labeling models. On the other hand, SmallLoss, a clean sample selection baseline, shows poor performance in CIFAR-10N (Random), because this dataset contains a relatively low noise ratio, and selecting clean examples is less critical. Although SmallLoss shows robust performance in CIFAR-100N, it is worse than Prune4ReL because it loses many informative noisy examples that help generalization if re-labeled correctly. Meanwhile, Uniform is a fairly robust baseline as it selects easy (clean) and hard (noisy) examples in a balanced way; many selected noisy examples may be relabeled correctly by other selected clean neighbors, resulting in satisfactory test accuracy.

Similarly, Figures 3(a) and 3(b) visualize the efficacy of the baselines and Prune4ReL on the WebVision and Clothing-1M datasets. We train SOP+ on WebVision and DivideMix on Clothing-1M. Similar to CIFAR-N datasets, Prune4ReL achieves better performance than existing baselines on two datasets. Quantitatively, Prune4ReL outperforms the existing sample selection methods by up to 2.7% on WebVision with a selection ratio of 0.4. This result confirms that the subset selected by Prune4ReL, which maximizes the total neighborhood confidence of the training set, successfully maintains the performance of Re-labeling models and is effective for model generalization.

**Efficiency.** In Figure 3(c), we further show the GPU time taken for selecting subsets within the warm-up training. We train SOP+ on WebVision with a selection ratio of 0.8. Powered by our efficient greedy approximation, Prune4ReL fastly prunes the dataset in a reasonable time. GraNd takes almost 10 times longer than SmallLoss or Margin, since it trains the warm-up classifier multiple times for the ensemble. kCenterGreedy is infeasible to run in our GPU configuration due to its huge computation and memory costs.

    &  &  &  \\   & &  &  &  &  &  &  &  \\   & & & 0.2 & 0.4 & 0.6 & 0.8 & 0.2 & 0.4 & 0.6 & 0.8 & 0.2 & 0.4 & 0.6 & 0.8 \\   & Uniform & 75.6\(\)0.1 & 81.0\(\)0.1 & 83.0\(\)0.1 & 84.3\(\)0.5 & 58.6\(\)0.3 & 63.9\(\)0.2 & 66.4\(\)0.1 & 67.5\(\)0.3 & 37.4\(\)0.2 & 46.1\(\)0.2 & 50.1\(\)0.0 & 52.3\(\)0.1 \\  & SmallL & 75.0\(\)1.5 & 83.4\(\)0.6 & 87.5\(\)0.3 & 90.1\(\)0.2 & 70.1\(\)0.3 & 77.5\(\)1.6 & 80.6\(\)0.5 & 76.4\(\)0.1 & 42.2\(\)0.4 & 54.7\(\)0.8 & 57.7\(\)0.1 & 57.4\(\)0.2 \\  & Forget & 82.2\(\)0.8 & 86.2\(\)0.1 & 86.1\(\)0.8 & 85.4\(\)0.2 & 71.2\(\)0.3 & 73.3\(\)0.7 & 71.4\(\)0.2 & 69.6\(\)0.1 & 43.5\(\)0.4 & 54.5\(\)0.1 & 57.5\(\)0.4 & **56.6\(\)**0.3 \\  DivMix & **Pr4ReL\({}_{D}\)** & **88.1\(\)0.3** & **93.0\(\)0.2** & **94.5\(\)0.2** & **95.1\(\)0.1** & **83.7\(\)**0.4 & **88.6\(\)**0.4 & **90.8\(\)**0.2 & **92.4\(\)**0.2 & 39.4\(\)0.3 & **56.3\(\)**0.5 & **63.5\(\)**0.3 & **67.4\(\)**0.7 \\  & **Pr4ReL\({}_{D}\)** & **88.5\(\)0.3** & **93.1\(\)0.2** & **94.4\(\)**0.1 & **95.3\(\)**0.1 & **84.9\(\)**0.1 & **89.2\(\)**0.6 & **91.3\(\)**0.3 & **92.9\(\)**0.1 & **52.9\(\)**0.0 & **60.1\(\)**0.6 & **64.1\(\)**0.4 & **66.2\(\)**0.3 \\   

Table 2: Performance comparison of the standard cross-entropy model and Re-labeling models when combined with data pruning methods on CIFAR-10N and CIFAR-100N.

Figure 3: Data pruning performance comparison: (a) test accuracy of SOP+ trained on each selected subset of WebVision; (b) test accuracy of DivideMix trained on each selected subset of Clothing-1M; (c) elapsed GPU time for selecting a subset on WebVision with a selection ratio of 0.8.

### Necessity of Data Pruning with Re-labeling under Label Noise

Table 2 shows the superiority of the Re-labeling models over the standard learning model, _i.e._, only with the cross-entropy loss, for data pruning under label noise. When combined with the data pruning methods, the performance of the Re-labeling models such as DivideMix and SOP+ significantly surpasses those of the standard models on CIFAR-10N and CIFAR-100N by up to 21.6\(\%\). That is, the re-labeling capacity can be well preserved by a proper data pruning strategy. This result demonstrates the necessity of data pruning for the Re-labeling models in the presence of noisy labels.

### Ablation Studies

**Effect of Confidence Metrics.** Prune4ReL can be integrated with various metrics for the confidence of predictions in Eq. (6). In our investigation, we consider two widely-used metrics: (1) MaxProb, which represents the maximum value of softmax probability and (2) DiffProb, which measures the difference between the highest and second highest softmax probabilities. Table 3 shows the effect of the two confidence metrics on the test accuracy of SOP+ on CIFAR-10N (Worst) and CIFAR-100N. The result indicates that both metrics perform similarly and yield higher accuracy compared to existing data pruning baselines, which demonstrates Prune4ReL is open to the choice of the confidence metric.

**Effect of Neighborhood Size.** Prune4ReL involves a hyperparameter \(\) in Eq. (6) to determine the neighborhood of each example, where a larger (smaller) value introduces a fewer (more) number of neighbors. Figure 4 shows the effect of \(\{0.93,0.95,0.99\}\) on the test accuracy of SOP+ trained on CIFAR-100N with varying selection ratios. In general, Prune4ReL shows better or comparable performance than other sample selection baselines. Among them, Prune4ReL with \(=0.95\) shows a satisfactory accuracy across varying selection ratios. With a smaller value of \(=0.93\), it shows the best performance in a high selection ratio of 0.8, but it becomes less effective in low selection ratios, due to the increasing influence of noisy examples caused by a relatively large neighborhood size. On the contrary, with a large value of \(=0.99\), it primarily selects clean yet easy examples due to a small neighborhood size, leading to a relatively less improvement in performance.

### In-depth Analysis of Noisy Examples in Selected Subset

**Noise Ratio of Selected Subset.** Table 4 shows the ratio of noisy examples in the subset selected by each sample selection method. SmallLoss shows a very low ratio of noisy examples in the subset because it prefers clean examples. Many data pruning methods, including Margin, GraNd, SSP, and Moderate (for CIFAR-100N), tend to select a higher ratio of noisy examples compared with that of each original dataset since they prefer to select hard examples. On the other hand, Prune4ReL selects a low ratio of noisy examples when the subset size is small and gradually increases the noise ratio as the subset size increases. This result indicates that Prune4ReL expands the confident subset through Algorithm 1--_i.e._, selecting the most confident (clean) examples first and then trying to select less confident (hard or noisy) neighbors to ensure accurate re-labeling. While some baselines, such as kCenterGreedy, Forget, and Moderate (for CIFAR-10N), also select a somewhat low ratio of noisy examples, their data pruning performances are worse than Prune4ReL because the quality (or self-correctability) of noisy examples is not considered when selecting the subset, which is further investigated in Table 5.

**Self-correctability of Selected Noisy Examples.** Table 5 shows the self-correctability of selected subsets, which indicates the ratio of correctly re-labeled noisy examples out of all selected noisyexamples. Here, we compare Prune4ReLU with kCenterGreedy and Forgetting on CIFAR-10N (Random) with the selection ratio of 0.2, where the ratio of noisy examples (_i.e._, \(\%Noisy\)) in the selected subset of each method is similar (_i.e._, from \(17\%\) to \(19\%\)). Although these methods select almost equal amounts of noisy examples, there were differences in the self-correctability (_i.e._, \(\%Correct\)) of the selected subsets. Noisy examples selected by Prune4ReLU are mostly self-correctable as it maximizes the total neighborhood confidence of the training set. In contrast, those selected by existing data pruning methods such as kCenter and Forget are not guaranteed to be self-correctable. This result confirms that Prune4ReLU not only selects a low ratio of noisy examples but also considers the quality of the selected subset in terms of maximizing re-labeling accuracy. Therefore, Prune4ReLU fully takes advantage of the Re-labeling methods.

### Results on ImageNet-N with Synthetic Label Noise

We further validate the efficacy of Prune4ReLU on ImageNet-N by injecting synthetic label noise of \(20\%\) to the commonly-used benchmark dataset ImageNet-1K (see Appendix D for details). Table 6 shows the test accuracy of Prune4ReLU and three representative sample selection baselines with varying selection ratios of \(\{0.05,0.1,0.2,0.4\}\). Similar to the result in Section 4.2, Prune4ReLU consistently outperforms the baselines by up to 8.6\(\%\), thereby adding more evidence of the superiority of Prune4ReLU. In addition, owing to its great computation efficiency, Prune4ReLU is able to scale to ImageNet-N, a large-scale dataset with approximately 1.2M training examples.

## 5 Conclusion

We present a noise-robust data pruning method for Re-labeling, called Prune4ReLU, that finds a subset that maximizes the total neighborhood confidence of the training examples, thereby maximizing the re-labeling accuracy and generalization performance. To identify a subset that maximizes the re-labeling accuracy, Prune4ReLU introduces a novel metric, the _reduced neighborhood confidence_, which is the prediction confidence of each neighbor example in the selected subset, and the effectiveness of this metric in estimating the re-labeling capacity of a subset is theoretically and empirically validated. Furthermore, we optimize Prune4ReLU with an efficient greedy algorithm that expands the subset by selecting the example that contributes the most to increasing the total reduced neighborhood confidence. Experimental results demonstrate the substantial superiority of Prune4ReLU compared to existing data pruning methods in the presence of label noise.

   Re-label & Selection &  \\ Model & Methods & 0.05 & 0.1 & 0.2 & 0.4 & & & & & & \\   & Uniform & 27.8 & 42.5 & 52.7 & 59.2 & & & & & & \\  & SmallL & 22.8 & 31.4 & 42.7 & 54.4 & & & & & & \\   & & Forget & 4.1 & 8.3 & 50.6 & 57.2 & & & & & & \\   & & **Pr4ReLU\({}_{B}\)** & **30.2** & **44.3** & **53.5** & **60.0** & & & & & \\   

Table 6: Data pruning performance on ImageNet with a 20\(\%\) synthetic label noise.

   Re-label & Selection &  &  &  \\ Model & Methods & 0.2 & 0.4 & 0.6 & 0.8 & 0.2 & 0.4 & 0.6 & 0.8 & 0.2 & 0.4 & 0.6 & 0.8 \\   & SmallL & 0.1 & 0.2 & 1.0 & 4.0 & 0.8 & 3.6 & 11.5 & 26.2 & 3.5 & 8.7 & 16.3 & 27.4 \\  & Margin & 29.7 & 25.7 & 22.5 & 19.7 & 54.6 & 52.1 & 48.5 & 44.6 & 61.5 & 56.8 & 51.6 & 46.2 \\  & kCenter & 19.0 & 18.8 & 19.1 & 18.6 & 40.0 & 41.1 & 41.6 & 42.1 & 37.5 & 38.7 & 39.9 & 40.4 \\  & Forget & 17.0 & 17.7 & 17.5 & 17.8 & 37.7 & 38.8 & 39.2 & 40.2 & 37.9 & 34.6 & 33.0 & 36.8 \\  & GraNd & 67.5 & 41.7 & 28.6 & 21.5 & 91.5 & 79.4 & 64.2 & 50.1 & 93.9 & 57.3 & 61.2 & 49.3 \\  & SSP & 25.2 & 23.7 & 21.6 & 19.5 & 48.5 & 46.4 & 43.2 & 42.1 & 52.7 & 52.3 & 46.8 & 43.0 \\  & Moderate & 6.6 & 7.1 & 8.4 & 13.5 & 31.7 & 33.4 & 34.7 & 40.0 & 33.2 & 54.6 & 60.2 & 64.6 \\  & **Pr4ReLU** & 17.0 & 18.7 & 19.3 & 22.5 & 38.7 & 42.7 & 43.5 & 46.5 & 28.3 & 29.1 & 33.3 & 37.2 \\   

Table 4: Ratio (\(\%\)) of noisy examples in the selected subset.

   Re-label & Selection &  \\ Model & Methods & _Test Acc._ \% _Noisy_ \% _Correct_ \\   & kCenter & 86.3 & 19.0 & 75.2 \\  & Forget & 82.4 & 17.0 & 61.7 \\  & **Pr4ReLU** & 88.1 & 17.0 & **90.3** \\   

Table 5: Ratio of correctly re-labeled noisy examples in the selected subset (denoted as \(\%\)_Correct_).