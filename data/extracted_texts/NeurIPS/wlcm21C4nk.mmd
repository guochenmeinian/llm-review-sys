# Advancing Training Efficiency of Deep Spiking Neural Networks through Rate-based Backpropagation

Chengting Yu\({}^{1,2}\), Lei Liu\({}^{2}\), Gaoang Wang\({}^{2}\), Erping Li\({}^{1,2}\), Aili Wang\({}^{1,2}\)

\({}^{1}\) College of Information Science and Electronic Engineering, Zhejiang University

\({}^{2}\) ZJU-UIUC Institute, Zhejiang University

chengting.21@intl.zju.edu.cn, ailiwang@intl.zju.edu.cn

Corresponding author.

###### Abstract

Recent insights have revealed that rate-coding is a primary form of information representation captured by surrogate-gradient-based Backpropagation Through Time (BPTT) in training deep Spiking Neural Networks (SNNs). Motivated by these findings, we propose rate-based backpropagation, a training strategy specifically designed to exploit rate-based representations to reduce the complexity of BPTT. Our method minimizes reliance on detailed temporal derivatives by focusing on averaged dynamics, streamlining the computational graph to reduce memory and computational demands of SNNs training. We substantiate the rationality of the gradient approximation between BPTT and the proposed method through both theoretical analysis and empirical observations. Comprehensive experiments on CIFAR-10, CIFAR-100, ImageNet, and CIFAR10-DVS validate that our method achieves comparable performance to BPTT counterparts, and surpasses state-of-the-art efficient training techniques. By leveraging the inherent benefits of rate-coding, this work sets the stage for more scalable and efficient SNNs training within resource-constrained environments. Our code is available at https://github.com/Tab-ct/rate-based-backpropagation.

## 1 Introduction

Spiking Neural Networks (SNNs) are conceptualized as biologically inspired neural systems, incorporating spiking neurons that closely mimic biological neural dynamics . Unlike Artificial Neural Networks (ANNs) based on continuous data representations, SNNs adopt spike-coding strategies to facilitate data transmission through discrete binary spike trains . The intrinsic binary mechanism eliminates the need for the extensive multiply-accumulate operations typically required for synaptic connectivity , thereby enhancing energy efficiency and inference speed when deployed on neuromorphic hardware systems .

The mainstream training methods for SNNs primarily utilize Backpropagation Through Time (BPTT) with surrogate gradients to overcome non-differentiable spike events, allowing SNNs to achieve comparable results with ANNs counterparts . However, the direct training method necessitates the storage of all temporal activations for backward propagation across the network's depth and duration, leading to high training costs in terms of both computational time and memory demands . To alleviate memory burdens, online training techniques have been developed that partially decouple the time dependencies of backward computations in BPTT . However, online methods still require iterative computations based on the time dimension, increasing training time complexity as the number of timesteps grows.

Observed across most biological sensory systems, rate coding is a phenomenon where information is encoded through the rate of neuronal spikes, regardless of precise spike timing [52; 64; 23]. Recent explorations into spike representation have demonstrated the significant role of rate coding in enhancing the robustness of SNNs, further confirming its dominant position as the encoding representation in networks [38; 60; 18]. A significant observation has shown that BPTT-trained SNNs on static benchmark exhibit spike representation primarily following the rate-coding manner by highlighting strong similarities in representation between SNNs and their ANN counterparts . A similar conclusion resonated with findings in fields of adversarial attacks, where recent methods significantly benefit from rate-based representations to enhance attack effectiveness [6; 29; 50].

Motivated by rate coding's status as the most effective and predominant form of representation in SNNs, we posit that targeted training based on rate-based information could offer a high cost-effectiveness ratio. We propose to decouple BPTT based on rate-coding approximation and simplify rate-based derivative computations to a single spatial backpropagation. We further provide theoretical analysis and empirical evidence to reveal the rationality of the gradient approximation between BPTT and the proposed method. Experimental results demonstrate that the proposed method achieves performance comparable to BPTT counterparts while significantly reducing memory and computational demands. Comparison results also indicate that the proposed method outperforms state-of-the-art efficient training methods on benchmarks. We expect our work to facilitate more efficient and scalable training for SNNs in resource-constrained environments. Our main contributions are as follows:

* We propose rate-based backpropagation that leverages rate-coded information for efficient training of deep SNNs. This method simplifies the computational graph by decoupling and compressing temporal dependencies, reducing training time and memory requirements.
* Alongside the proposed method, we conduct theoretical analysis and empirical validation to demonstrate its effectiveness in approximating the gradient computations performed by BPTT-based SNNs training.
* We conduct experiments on CIFAR-10, CIFAR-100, CIFAR10-DVS, and ImageNet, demonstrating that our proposed method matches the comparable performance of the BPTT counterpart and achieves state-of-the-art results among efficient SNN training methods.

## 2 Related Work

**Training Methods for Deep SNNs.** Deep SNNs are trained primarily through two principal strategies: (1) conversion methods that establish links between SNNs and ANNs through equivalent closed-form mappings, and (2) direct training from scratch utilizing Backpropagation Through Time (BPTT). Conversion methods develop closed-form formulations for spike representations [39; 67; 72; 88; 73; 47], enabling seamless transitions of pre-trained ANNs into SNNs and facilitating comparable performance on large-scale datasets [8; 15; 27; 59; 57; 12; 42; 16]. However, the precision of these mappings under ultra-low latency conditions is not consistently reliable, often necessitating extensive time steps to accumulate spikes, which may compromise performance [7; 40; 31; 28; 34]. Direct training methods permit SNNs' performance with extremely low time steps by employing BPTT along with surrogate gradients to compute derivatives of discrete spiking events [51; 62; 74; 22; 81; 87; 85; 43; 66; 69; 13]. The strategy fosters innovation in SNN-specific modules, including optimized neurons, synapses, and network architectures, thereby enhancing performance [25; 21; 20; 17; 79; 83; 24; 80; 61]. Despite the advantages of low latency, direct training imposes substantial memory and time burdens to maintain the backward computational graph [43; 86; 35; 77; 76; 47; 13]. To mitigate training costs associated with direct methods, light training strategies have attracted considerable attention [49; 35; 86; 55; 70]. Several studies have explored the concept of decoupling the forward and backward passes in SNNs, which generally assumes that neuronal dynamics follow deterministic processes and aims to establish closed-form fixed-point equivalences between spike representations and corresponding rate-based activations [72; 73; 77; 47; 68]. Drawing on online training techniques from recurrent neural networks, several studies have adapted the principles of Real-time Recurrent Learning (RTRL)  to streamline the online training process for SNNs, aiming to decrease memory demands while preserving biologically plausible online properties of the networks [84; 2; 4; 82; 55; 76; 47; 89]. The online methodologies have proven effective in large-scale tasks [76; 47; 89]. Nevertheless, the significant time costs associated with training methods continue to challenge SNNs' broader application.

**Spike Coding in SNNs.** SNNs transmit information through spike trains , with encoding mechanisms classified into temporal and rate coding. Temporal coding is defined on firing times, employed by several direct trainings [49; 75; 88] and ANN-to-SNN conversions [26; 65], is noted for its low energy consumption due to sparse spiking. However, temporal coding schemes often require specialized neuron configurations and are generally effective only on simpler datasets [26; 65; 88]. Conversely, rate coding is widely adopted across both conversion [12; 15; 16; 27; 36; 57; 59; 78] and direct training approaches [73; 77; 47], consistently achieving superior performance and facilitating low-latency operations [77; 47]. Moreover, rate coding has demonstrated significant potential in enhancing the robustness of SNNs against adversarial attacks [38; 60; 18], with attack methods specifically designed to exploit rate-based representations showing promise in surpassing benchmarks for SNNs defense against attacks [6; 30; 50]. By employing representation similarity analysis to compare BPTT-trained SNNs with their ANN counterparts, Li et al.  has indicated that rate coding serves as the primary mode of information representation . Inspired by previous findings, we consider that rate-coded information represents the most effective and predominant form of signal expression in SNNs, and the targeted training based on rate-based spike representations may offer a high cost-effectiveness ratio. Therefore, we propose to decouple BPTT towards rate-based backpropagation with the purpose of enhancing the efficiency of SNNs training.

## 3 Preliminaries

### Spiking Neural Networks

Inspired by the brain's ability to transmit information through discrete spikes, the Leaky Integrate-and-Fire (LIF) model serves as the basic building block of SNNs due to its simplicity. For practical implementation of SNNs based on connected spiking neurons, the dynamics of the LIF model are typically rendered in a discrete iterative format:

\[_{t}^{l}=(_{t-1}^{l}-V_{}_{t-1}^{l})+ ^{l}_{t}^{l-1},_{t}^{l}=H(_{t}^{l}-V_{})\] (1)

where \(_{t}^{l}\) and \(_{t}^{l}\) represent the membrane potential and output spike of neurons in layer \(l\) at time \(t\), respectively. \(^{l}\) denotes the linear synaptic connections between layers \(l-1\) and \(l\), and \(\) acts as the decay term for the membrane potential. The Heaviside step function, \(H()\), determines spike generation, ensuring \(_{t}^{l}\) in binary forms. Noting that \(H()\) is not differentiable, SNNs' direct training employs surrogate gradients to achieve error propagation by creating various pseudo-derivatives [51; 74; 19], following the basic idea of Straight-Through Estimator (STE) .

### Training SNNs with BPTT

The network outputs at each timestep \(t\) are given by \(_{t}=^{L}_{t}^{L}\), where \(^{L}\) denotes the classifier's weights. Classification is based on the average of these outputs across all timesteps, computed as \(_{}=_{t=1}^{T}_{t}\). The loss function \(\) is defined over averaged outputs and is typically formulated as \(=(_{t=1}^{T}_{t},),\) where \(\) represents the true labels and \(\) could be the cross-entropy function, as noted in various studies [87; 48; 19; 69]. BPTT unfolds the iterations described in Eq. (1), and propagates gradients back along the computational graphs across both temporal and spatial dimensions, as illustrated in Fig. 0(a). The gradients of the membrane potential \(\) incorporate elements

Figure 1: Illustration of the forward and backward procedures of different training methods.

from both (spatial) spike generation and (temporal) potential accumulation, expressed as:

\[}{_{t}^{l}}& =}{_{t}^{l}}_{t}^{l}}{_{t}^{l}}+}{_{t +1}^{l}}(_{t+1}^{l}}{_{t}^{l}}+_{t+1}^{l}}{_{t}^{l}}_{t}^{l}} {_{t}^{l}})\\ &=}{_{t}^{l}}_{t}^{l}}{_{t}^{l}}+_{>t}}{_{}^{l}}_{}^{l}}{ _{}^{l}}_{i=-1}^{t}(_{t+1} ^{l}}{_{t}^{l}}+_{t+1}^{l}}{_ {t}^{l}}_{t}^{l}}{_{t}^{l}})\] (2)

Subsequently, the weight update for layer \(l\) is determined among all timesteps \(T\), i.e. \(_{^{l}}=_{t=1}^{T}}{ _{t}^{l}}_{t}^{l}}{^{l}}=_ {t=1}^{T}}{_{t}^{l}}{_{t}^{l-1}}^ {}\), and the gradient is further propagated to previous layers through the linear part by \(}{_{t}^{l-1}}=} {_{t}^{l}}{^{l}}^{}\).

## 4 Rate-based Backpropagation for SNNs Training

### Derivation of Rate-based Backpropagation

**Incorporating rate-based representation.** Under the rate coding assumption, essential information is effectively encapsulated within the spike frequency averages. We start by defining the rate-based representation as an approximation for the forward procedure in SNNs, as shown in Figure 2. The average firing rate at each layer \(l\), denoted as \(^{l}\), is calculated as the expected value of the spike outputs \(_{t}^{l}\) over the temporal dimension \(^{l}=[_{t}^{l}]=_{t T}_{t}^{l}\).

Considering the forward propagation through linear operators with weights \(^{l}\) that compute the inputs as \(_{t}^{l}=^{l}_{t}^{l-1}\), instead of transmitting distinct spikes over multiple timesteps, we transform the average rates into average inputs \(^{l}\) in the approximate representation:

\[^{l}=[_{t}^{l}]=[^{l}_{t}^{l-1}]= ^{l}[_{t}^{l-1}]=^{l}^{l-1}.\]

Supposing input representations are well captured within \(^{l}\), we approximate the exact inputs with the average inputs for all timesteps, \(_{t}^{l}^{l}\), and follow the neuronal dynamics in Eq. (1) to derive the output rates \(^{l}=[_{t}^{l}]\). With the rate-coding approximation in place, we can derive the gradients with respect to the weights in the linear part based on the error propagated through the average inputs:

\[(_{^{l}})_{}}{^{l}}^{l}}{^ {l}}=}{^{l}}{^{l-1}}^{}\] (3)

**Handling temporal dependency during backward.** For back-propagating the error, the linear parts operate smoothly as \(^{l}}{^{l-1}}={^{l}}^{}\). The next step is to define the correlation between the averages of inputs and output spike rates, \(^{l}}{^{l}}\), within the neurons of layer \(l\). Since there is no deterministic relationship between \(r^{l}\) and \(c^{l}\), we first look into the influence of separated inputs following the exact

Figure 2: The implementation of rate-based backpropagation across layers. A rate-coding approximation is utilized for the forward procedure to connect average inputs with rate outputs, enabling fast rate-based error backpropagation throughout the training process.

gradients in Eq. (2):

\[_{}^{l}}{_{t}^{l}}=_{ }^{l}}{_{t}^{l}}=\{_{}^{l}}{_{}^{l}}_{i=-1}^{t}(_{i+1}^{l}}{_{i}^{l}}+_{i+1}^{ l}}{_{i}^{l}}_{i}^{l}}{_{i}^{l}} )& t\\ _{}^{l}}{_{t}^{l}}&=t\\ 0&<t.\] (4)

By accumulating the intricate dynamics over time, we can derive the gradients of the overall spikes with respect to the inputs at time \(t\):

\[_{t}^{l}=_{}_{}^{l}}{ _{t}^{l}}=(_{}^{l}}{_{}^ {l}}+_{>t}_{}^{l}}{_{}^{l}} _{i=-1}^{t}(_{i+1}^{l}}{_{i}^ {l}}+_{i+1}^{l}}{_{i}^{l}}_{i}^{l}}{_{i}^{l}}))\] (5)

Here, with rate-coding approximating \(_{t}^{l}^{l}\), we follow the idea of Straight-Through Estimator  and define the backward gradients as \(_{t}^{l}}{^{l}}=Id\), with \(Id\) representing the identity matrix. Then, we can derive the surrogate gradients of neural dynamics through the mean estimator:

\[(^{l}}{^{l}})_{} _{}([_{t}^{l}])}{ _{}^{l}})_{}^{l}}{ {c}^{l}})=_{t}_{}(_{t}^ {l}}{_{}^{l}})=[_{t}^{l}]\] (6)

With the compressed gradients of neuron parts, the error backpropagation of the rate-based representation is then determined, dependent only on the spatial domain:

\[(}{^{l}})_{}= (}{^{L}}_{i=L-1}^{l}( ^{i+1}}{^{i}}(^{i}}{ ^{i}})_{}))=(}{^{L}}_{i=L-1}^{l}(^{i^{}}[_{t}^{l}]))\] (7)

where we define the objective \(=([_{t}],y)=( ^{L},)\). Note that the rate-based representation, while instrumental in constructing the backward computational graph for learning, does not necessitate actual implementation during the forward pass.

### Rate-based Gradient Computation for Memory and Time Efficiency

As previously discussed, rate-based backpropagation can be executed on spatial-dimension computation by decoupling BPTT. We now show how rate-based backpropagation can be efficiently implemented within the overall learning framework. As depicted in Figure 1(b), online schemes apply eligibility traces \(_{t}^{l}\) locally within neurons to store historical information, effectively blocking backward access to past gradients. The gradient computation is optimized by compressing all past temporal dependencies into \(_{t}^{l}\). Similarly, we utilize iterative variables \(\{_{t}^{l}\}_{t L}\) and \(\{_{t}^{l}\}_{l L}\) as the accumulated post- and pre-synaptic dependencies, synchronously recorded during the neural dynamics computations. The iteration of \(\{_{t}^{l}\}_{l L}\) dynamically records the firing rates, where \(_{t}^{l}=((t-1)_{t-1}^{l}+_{t}^{l})\), and it is straightforward to derive \(^{l}=_{T}^{l}\). Considering the surrogate gradients of neural dynamics, \(^{l}}{^{l}}\), to estimate future-dependent terms outlined in Eq. 5, we first construct equivalent eligibility trace forms, \(\{_{t}^{l}\}_{t T}\), with iterative expressions starting at \(_{1}^{l}=1\):

\[_{t}^{l}=1+_{t-1}^{l}(_{t}^{l}}{ _{t-1}^{l}}+_{t}^{l}}{_{t-1}^{ l}}_{t-1}^{l}}{_{t-1}^{l}})=1+_{ <t}_{i=t-1}^{}(_{i+1}^{l}}{_ {i}^{l}}+_{i+1}^{l}}{_{i}^{l}}_{i}^{l}}{_{i}^{l}})\] (8)

with the equivalence that:

\[_{t}_{t}^{l}&=_{t}( _{t}^{l}}{_{t}^{l}}+_{>t}(_{}^{l}}{_{}^{l}}_{i=-1}^{t}( _{i+1}^{l}}{_{i}^{l}}+_{i+1 }^{l}}{_{i}^{l}}_{i}^{l}}{_{i}^{l }})))\\ &=_{t}(_{t}^{l}}{_{t}^ {l}}(1+_{<t}_{i=t-1}^{}(_{i+1}^{l}}{ _{i}^{l}}+_{i+1}^{l}}{_{i}^{l}} _{i}^{l}}{_{i}^{l}})))=_{t }(_{t}^{l}}{_{t}^{l}}_{t}^{l} )\] (9)

By iteratively accumulating \(_{t}^{l}=((t-1)_{t-1}^{l}+_{t}^{l}}{ _{t}^{l}}_{t})\), we obtain \(_{T}^{l}=[_{t}^{l}}{_{t}^{l}} _{t}^{l}]=[_{t}^{l}]\). Now, we have collapsed the required computation graph through the iterative calculation to complexity \((L)\). The rate-based propagation is then conducted in one go, relying only on the intermediate variables \(_{T}^{l}\), \(_{T}^{l}\), and \(^{l}\), within one-time spatial-dimension backpropagation.

### Connecting Error Backward of Rate-based Backpropagation to BPTT

Having derived the fundamental form of rate-based backpropagation through the rate-encoding approximation, we now explore potential divergences with BPTT during error propagation. Although rate-based backpropagation is derived from the approximated forward pass, it still provides valid gradients for the original network parameters.

The primary divergence between rate-back and BPTT in backward computation primarily arises from the assumptions regarding the approximation of rate-based representation through mean estimators, as outlined in Eq.(3) and Eq.(6). The rate-coding motivations establish equivalence with BPTT by assuming temporal components are independent, which is formalized in Theorem 1.

**Theorem 1**.: _Given \(_{t}^{(^{t})}=}{_{t}^{t}}\) that refers to gradients computed following the chain rule of BPTT in Eq. (2), and \(_{t}^{l}=_{}_{t}^{t}}{_{ }^{l}}\) (where \([_{t}^{l}]=[_{t}^ {l}]\) in Eq.(6-7)), if \([_{t}^{(^{t})}_{t}^{l}]= [_{t}^{(^{t})}][_{t}^{l}]\) holds for \( l\), we have \([_{t}^{(^{t})}]=(}{^{l}})_{}\). Furthermore, given \(_{t}^{(^{l})}=}{_{t}^ {l}}\), if \([_{t}^{(^{l})}_{t}^{l-1}]=[_{t}^{(^{l})}][_{t}^{l-1}]\) for \( l\), we then obtain \((_{^{l}})_{}=(_{^{l} })\). Here, \([_{t}]=_{t}_{t}\) refers the mean value of tensor \(_{t}\) over temporal dimension \(T\)._

To confirm our hypotheses, we carried out empirical experiments, the results of which are detailed in the experimental section. Our empirical findings support the core assumptions outlined in Theorem 1, demonstrating the relative independence between \(_{t}^{(^{t})}\) and \(_{t}^{l}\) (Figure 2(a),b), as well as between \(_{t}^{(^{l})}\) and \(_{t}^{l}\) (Figure 2(c)). For minor discrepancies that may arise, we introduced Theorem 2, which tolerates small deviations and confirms that approximation errors in rate-based backpropagation can be effectively bounded, ensuring the robustness of training under practical conditions.

**Theorem 2**.: _For gradients \(_{t}^{(^{t})}=}{_{t}^{l}}\) and \(_{t}^{l}=_{}_{t}^{l}}{_{ }^{l}}\), given the approximation error bound \(>0\) s.t. \(\|[_{t}^{(^{t})}_{t}^{l} ]-[_{t}^{(^{t})}]| (1+\|[_{t}^{(^{t})}]\|)\) for \( l\). Denote the stacked tensor \(^{l}=[_{1}^{l},...,_{T}^{l}]\) and \(^{l}=[_{1}^{l},...,_{T}^{l}]\). Assuming the backward procedure follows non-expansivity s.t. \(^{l+1}}{ T}=^{l+1}^{l}} {^{l}}\) is 1- lipschitz continuous without loss of generality and the biases are bounded uniformly by B, i.e. \(\|^{l+1}}{^{l}}-}^{l+1}}{^{l}}\|\|-}\|\) for \(,}\). Define \(_{}^{l}=(}{^{ l}})_{}\) as the error propagated through Eq. (7), and \(_{t}^{(^{l})}=}{_{t}^ {l}}\) as the error propagated through BPTT, with \(_{}^{L}=[_{t}^{(^{L})}]\). We have the gradient difference bounded by \(\|_{}^{L-k}-[_{t}^{(^{L-k} )}]\|=(k^{2})\)._

Theorem 2 elucidates the stability of rate-based backpropagation relative to BPTT, showing that the proposed method can provide a bound on the overall objective solution. The bounded error could further be interpreted as a form of randomness suitable for stochastic optimization. The similarity measurement of the descent directions between the two methods provides empirical evidence for the effectiveness of the proposed method (Figure 2(d)). Detailed proof is provided in Appendix A.

### Implementation Details

For implementations of direct training, two distinct training modes are recognized: (multi-step) activation-based and (single-step) time-based , differing fundamentally in handling the timesteps loop. We implement our rate-based propagation in both modes: \(}_{M}\) denotes the multi-step training mode where \(T\) loops are embedded within layers, and \(}_{S}\) refers to the single-step training mode with \(T\) loops outside the layers. A detailed discussion of training modes is included in Appendix B.

Another aspect of our implementation concerns handling batch normalization (BN), especially given its critical role in BPTT, which adjusts mean and variance statistics during the forward pass. The application of BN varies depending on the training mode. In the multi-step mode, BN benefits from access to information across all timesteps and can normalize based on statistics aggregated over temporal dimensions. We employed tdBN  in \(}_{M}\) since it has been widely adopted in direct training on various benchmarks. In contrast, the single-step mode limits BN to current timestep inputs, necessitating normalization across spatial dimensions only. In line with online schemes, SLTT  demonstrates the feasibility of implementing spatial BN iteratively across timesteps, an approach we adopt for \(}_{S}\). Further details on the BN implementation are provided in Appendix B.

## 5 Experiments

In this section, we conduct experiments on CIFAR-10 , CIFAR-100 , ImageNet , and CIFAR10-DVS  to evaluate the proposed training method. We implement SNNs training on the Pytorch  and SpikingJelly  frameworks. We set \(V_{th}=1\), \(=0.2\), and employ the sigmoid-based surrogate function  for LIF neurons. Detailed setups are provided in Appendix C.

### Empirical Validation

Empirical experiments are conducted to support the preconditions of theorems discussed in Section 4.3. These preconditions assert the independence of paired variables across the temporal dimension: \([_{t}^{(s^{})}_{t} ^{t}]=[_{t}^{(s^{})}] [_{t}^{l}]\) (A1) and \([_{t}^{(I^{})}_{t}^{l-1 }]=[_{t}^{(I^{})}][_{t}^{l-1}]\) (A2). To explore these relationships, we conducted experiments training ResNet-18 on CIFAR-100 using BPTT. Cosine similarity measures were employed to compare the empirical expectation products, \(cos[_{t}^{(s^{})}_{t}^{l}],[_{t}^{(s^{}) }][_{t}^{l}]\) as shown in Figure 3a, where values approaching 1 indicate a high degree of alignment, suggesting that the variables' directions are similar. Additionally, the correlation coefficient, \(\) was measured to further assess the independence of these variables \(=(_{t},_{t}^{( s^{})})}{(_{t})( _{t}^{(s^{})})}}\) where \((_{t},_{t}^{(s^{})}) =[_{t}^{(s^{})}_{t }^{l}]-[_{t}^{(s^{})}] [_{t}^{l}]\) It is clear that \(\) equals the cosine distance between the variables after centering by their means, \(=cos_{t}^{(s^{})}-[ {}_{t}^{(s^{})}],_{t}^{l}-[ _{t}^{l}]\). Results, shown in Figure 3b, reveal that the correlation coefficients are constrained within a very small range, typically around the magnitude of \( 10^{-5}\), supporting the hypothesis of their relative independence. We also conducted cosine similarity measurements to validate the assumption \([_{t}^{(I^{})}_{t}^{l- 1}]=[_{t}^{(I^{})}] [_{t}^{l-1}]\), as shown in Figure 3c. Additionally, we implement both BPTT and the proposed method simultaneously within the same training iteration, allowing direct observation of the gradient descent directions. The relation \((_{I^{}})_{}=( _{I^{}})\) (A3) was visualized in Figure 3d, which revealed that the convergence directions for rate-based backpropagation and BPTT are closely aligned. Remarkably, all tests consistently demonstrate that configurations with T=6 better adhere to the theoretical assumptions than T=4, suggesting that the proposed method can more closely mimic BPTT computations as the timestep increases. This observation also highlights the intrinsic link between our method and rate-coding, suggesting that a larger temporal window may facilitate more stable manifestations of rate-coding.

### Comparison with the State-of-the-Art

We present comparison results in Table 1. In single-step mode, \(}_{S}\) offers fair comparisons with online schemes, while \(}_{M}\) in multi-step mode competes fairly with other methods employing one-step backpropagation. Unlike online methods such as OTTT, SLTT, and OS, which necessitate spatial backpropagation at every timestep, our proposed method conducts this process only once at the final timestep. Although methods of DSR  and SSF delay decoupled backpropagation until the final timestep, allowing for parallel processing across all timesteps to enhance computational speed, they still require each timestep's backpropagation to be managed independently within the backward computation graph. In contrast, our method fully compresses the temporal dimension, achieving one-step time-independent spatial backpropagation. As shown in Table 1, our method yields comparable performance with BPTT counterparts on benchmarks, showcasing promising capabilities compared to other efficient training methods. While our theoretical

Figure 3: Empirical measurements conducted on the training procedure of BPTT. The experiments are carried out on the CIFAR-100 dataset using ResNet-18. Each subplot is labeled according to the naming convention “A{test#}-T{timesteps#}-{target}-L{layer#}B{block#}N{LIF#}/C{conv#}.”analysis and motivation primarily adhere to rate-coding approximations, the performance on static datasets aligns with expectations. The results on the dynamic dataset CIFAR10-DVS also achieve comparable levels, implying a significant presence of rate-based representation within CIFAR10-DVS. More results regarding the performance comparisons between the proposed method and BPTT across various architectures and settings have been detailed in Appendix D.

### Impact of Time Expansion

we assess the impact of extending timesteps on both accuracy and training efficiency. Figure 3(a) validates that our method capably manages increased timesteps, thereby confirming the scalability of the proposed method for larger \(T\) values. Figure 3(b) displays the computational and memory expenses incurred during the backward phase, which, as anticipated, do not escalate with increasing \(T\).

    & Training & Method & Model & Timesteps & Top-1 Acc (\%) \\   & QCFS  & ANN25NN & ResNet-18 & 8 & 94.82 \\   & DSR  & one-step & PreAct-ResNet-18 & 20 & 95.10\(\)0.15 \\   & SSE  & one-step & PreAct-ResNet-18 & 20 & 94.90 \\   & BPTT\({}_{M}\) & BPTT & ResNet-18 & 4 & 95.64 \\   & **rate\({}_{M}\) (ours)** & one-step & ResNet-18 & 4 & 95.61\(\)0.02(95.64) \\   & OTT  & online & VGG-11\({}^{*}\) & 6 & 93.52\(\)0.06 \\   & SLTT  & online & ResNet-18 & 6 & 94.44\(\)0.21 \\   & OS  & online & VGG-11 & 4 & 94.35 \\   & BPTT\({}_{S}\) & BPTT & ResNet-19 & 4 & 95.20 \\   & BPTT\({}_{S}\) & BPTT & ResNet-18 & 4 & 95.53 \\   & & VGG-11 & 4 & 95.61 \\   & **rate\({}_{S}\) (ours)** & one-step & ResNet-18 & 4 & 95.42\(\)0.11(95.56) \\   & & VGG-11 & 4 & 95.57\(\)0.08(95.68) \\    } & DSR  & one-step & PreAct-ResNet-18 & 20 & 78.50\(\)0.12 \\   & SSF  & one-step & PreAct-ResNet-18 & 20 & 75.48 \\   & BPTT\({}_{M}\) & BPTT & ResNet-18 & 4 & 77.93 \\   & **rate\({}_{M}\) (ours)** & one-step & ResNet-18 & 4 & 78.26\(\)0.12(78.38) \\   & OTTT  & online & VGG-11\({}^{*}\) & 6 & 71.05\(\)0.04 \\   & SLTT  & online & ResNet-18 & 6 & 74.38\(\)0.30 \\   & OS  & online & VGG-11 & 4 & 76.48 \\   & BPTT\({}_{S}\) & BPTT & ResNet-19 & 4 & 77.86 \\   & **BPTT\({}_{S}\)** & BPTT & ResNet-18 & 4 & 77.72 \\   & **rate\({}_{S}\) (ours)** & one-step & ResNet-18 & 4 & 77.73\(\)0.28(77.93) \\   & **rate\({}_{S}\) (ours)** & VGG-11 & 4 & 77.87\(\)0.35(78.13) \\    } & OTTT  & online & PreAct-ResNet-34\({}^{*}\) & 6 & 65.15 \\   & SLTT  & online & PreAct-ResNet-34\({}^{*}\) & 6 & 66.19 \\   & OS  & online & SEW-ResNet-34 & 4 & 64.14 \\   & BPTT & SEW-ResNet-34 & 4 & 67.04 \\   & **rate\({}_{S}\) (ours)** & one-step & SEW-ResNet-34 & 4 & 65.66 \\   & **rate\({}_{S}\) (ours)** & one-step & PreAct-ResNet-34 & 4 & 69.58 \\   & **rate\({}_{M}\) (ours)** & one-step & SEW-ResNet-34 & 4 & 65.84 \\   & DSR  & one-step & VGG-11 & 20 & 77.27\(\)0.24 \\   & SSF  & one-step & VGG-11 & 20 & 78.0 \\   & OTTT  & online & VGG-11\({}^{*}\) & 10 & 76.63\(\)0.34 \\   & SLTT  & online & VGG-11 & 10 & 77.17\(\)0.23 \\   & BPTT\({}_{S}\) & BPTT & VGG-11 & 10 & 76.73 \\   & BPTT\({}_{M}\) & BPTT & VGG-11 & 10 & 76.86 \\   & **rate\({}_{S}\) (ours)** & one-step & VGG-11 & 10 & 76.48\(\)0.23(76.71) \\   & **rate\({}_{M}\) (ours)** & one-step & VGG-11 & 10 & 76.96\(\)0.13(77.13) \\   

Table 1: Performance on CIFAR-10, CIFAR-100, ImageNet, and CIFAR10-DVS. Results are averaged over three runs of experiments, except for single crop evaluations on ImageNet. Models marked with (\({}^{*}\)) employ scaled weight standardization, adapting to normalizer-free architectures.

### Analysis of Rate Statistics

Our method, derived from the principles of rate-based representation, necessitates examining the impact of rate coding on model behavior. Following an insightful approach from , we assess the robustness of our models by shuffling the temporal order of spike sequences while maintaining their rate consistency. This experiment, designed to disrupt temporal information without changing the firing rate, was applied to models trained using rate-based backpropagation. During inference on the test dataset, we introduced perturbations by randomly shuffling the temporal dimensions of input tensors across all neurons, as reported in Table 2. Notably, models mostly resisted these changes to some degree, which suggests that they follow the basic rules of rate coding, where the reordering of timesteps does not significantly impact overall accuracy. Furthermore, we tracked the average firing rates across each layer over time, presented in Figure 5. As layers increase, the average spike rates per layer are closely aligned with the temporal mean, validating the idea of rate-coding approximation. Those two experiments support the notion that rate-based backpropagation proficiently captures rate-based representations during training.

## 6 Conclusion

In this work, we propose rate-based backpropagation, utilizing rate-coding approximation to streamline the gradient computational graph, significantly reducing both memory usage and training time. Through theoretical analyses and empirical validation, we show the method's feasibility in approximating the optimization direction of BPTT. Experimental results across benchmarks reveal that our

Figure 4: Results of BPTT and \(_{M}\) across various timesteps.

Figure 5: Firing rates statistics for models trained by \(_{M}\).

method achieves comparable performance with BPTT and surpasses other state-of-the-art efficient training methods. We expect our work to pave the way for more scalable and resource-efficient training of SNNs.