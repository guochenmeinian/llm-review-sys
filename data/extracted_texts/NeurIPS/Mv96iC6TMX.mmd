# A Near-Linear Time Algorithm for the Chamfer Distance

Ainesh Bakshi

MIT

ainesh@mit.edu

&Piotr Indyk

MIT

indyk@mit.edu

&Rajesh Jayaram

Google Research

rkjayaram@google.com

&Sandeep Silwal

MIT

silwal@mit.edu

&Erik Waingarten

University of Pennsylvania

ewaingar@seas.upenn.edu

###### Abstract

For any two point sets \(A,B^{d}\) of size up to \(n\), the Chamfer distance from \(A\) to \(B\) is defined as \((A,B)=_{a A}_{b B}d_{X}(a,b)\), where \(d_{X}\) is the underlying distance measure (e.g., the Euclidean or Manhattan distance). The Chamfer distance is a popular measure of dissimilarity between point clouds, used in many machine learning, computer vision, and graphics applications, and admits a straightforward \((dn^{2})\)-time brute force algorithm. Further, the Chamfer distance is often used as a proxy for the more computationally demanding Earth-Mover (Optimal Transport) Distance. However, the _quadratic_ dependence on \(n\) in the running time makes the naive approach intractable for large datasets.

We overcome this bottleneck and present the first \((1+)\)-approximate algorithm for estimating the Chamfer distance with a near-linear running time. Specifically, our algorithm runs in time \((nd(n)/^{2})\) and is implementable. Our experiments demonstrate that it is both accurate and fast on large high-dimensional datasets. We believe that our algorithm will open new avenues for analyzing large high-dimensional point clouds. We also give evidence that if the goal is to _report_ a \((1+)\)-approximate mapping from \(A\) to \(B\) (as opposed to just its value), then any sub-quadratic time algorithm is unlikely to exist.

## 1 Introduction

For any two point sets \(A,B^{d}\) of sizes up to \(n\), the Chamfer distance1 from \(A\) to \(B\) is defined as

\[(A,B)=_{a A}_{b B}d_{X}(a,b)\]

where \(d_{X}\) is the underlying distance measure, such as the Euclidean or Manhattan distance. The Chamfer distance, and its weighted generalization called Relaxed Earth Mover Distance , are popular measures of dissimilarity between point clouds. They are widely used in machine learning (e.g., ), computer vision (e.g., ) and computer graphics . Subroutines for computing Chamfer distances are available in popular libraries, such as Tensorflow , Pytorch  and PDAL . In many of those applications (e.g., ) Chamfer distance is used as a faster proxy for the more computationally demanding Earth-Mover (Optimal Transport) Distance.

Despite the popularity of Chamfer distance, the naive algorithm for computing it has quadratic \(\!(n^{2})\) running time, which makes it difficult to use for large datasets. Faster approximate algorithms can be obtained by performing \(n\) exact or approximate nearest neighbor queries, one for each point in \(A\). By utilizing the state of the art approximate nearest neighbor algorithms, this leads to \((1+)\)-approximate estimators with running times of \(\!(n(1/)^{\!(d)} n)\) in low dimensions  or roughly \(\!(dn^{1+-1}})\) in high dimensions . Alas, the first bound suffers from exponential dependence on the dimension, while the second bound is significantly subquadratic only for relatively large approximation factors.

### Our Results

In this paper we overcome this bottleneck and present the first \((1+)\)-approximate algorithm for estimating Chamfer distance that has a _near-linear_ running time, both in theory and in practice. Concretely, our contributions are as follows:

* When the underlying metric \(d_{X}\) is defined by the \(_{1}\) or \(_{2}\) norm, we give an algorithm that runs in time \(\!(nd(n)/^{2})\) and estimates the Chamfer distance up to \(1\) with \(99\%\) probability (see Theorem 2.1). In general, our algorithm works for any metric \(d_{X}\) supported by Locality-Sensitive Hash functions (see Definition 2.2), with the algorithm running time depending on the parameters of those functions. Importantly, the algorithm is quite easy to implement, see Figures 1 and 2.
* For the more general problem of _reporting_ a mapping \(g:A B\) whose cost \(_{a A}d_{X}(a,g(a))\) is within a factor of \(1+\) from \((A,B)\), we show that, under a popular complexity-theoretic conjecture, an algorithm with a running time analogous to that of our _estimation_ algorithm does not exist, even when \(d_{X}(a,b)=\|a-b\|_{1}\). Specifically, under a Hitting Set Conjecture , any such algorithm must run in time \((n^{2-})\) for any constant \(>0\), even when the dimension \(d=(^{2}n)\) and \(=\). (In contrast, our estimation algorithm runs in near-linear time for such parameters). This demonstrates that, for the Chamfer distance, estimation is significantly easier than reporting.
* We experimentally evaluate our algorithm on real and synthetic data sets. Our experiments demonstrate the effectiveness of our algorithm for both low and high dimensional datasets and across different dataset scales. Overall, it is much faster (**>5x**) than brute force (even accelerated with KD-trees) and both faster and more sample efficient (**5-10x**) than simple uniform sampling. We demonstrate the scalability of our method by running it on _billion-scale_ Big-ANN-Benchmarks datasets , where it runs up to **50x** faster than optimized brute force. In addition, our method is robust to different datasets: while uniform sampling performs reasonably well for some datasets in our experiments, it performs poorly on datasets where the distances from points in \(A\) to their neighbors in \(B\) vary significantly. In such cases, our algorithm is able to adapt its importance sampling probabilities appropriately and obtain significant improvements over uniform sampling.

## 2 Algorithm and Analysis

In this section, we establish our main result for estimating Chamfer distance:

**Theorem 2.1** (Estimating Chamfer Distance in Nearly Linear Time).: _Given as input two datasets \(A,B^{d}\) such that \(|A|,|B| n\), and an accuracy parameter \(0<<1\), Chamfer-Estimate runs in time \(\!(nd(n)/^{2})\) and outputs an estimator \(\) such that with probability at least \(99/100\),_

\[(1-)(A,B)(1+)(A,B),\]

_when the underlying metric is Euclidean \((_{2})\) or Manhattan \((_{1})\) distance._

For ease of exposition, we make the simplifying assumption that the underlying metric is Manhattan distance, i.e. \(d_{X}(a,b)=\|a-b\|_{1}\). Our algorithm still succeeds whenever the underlying metric admits a locality-sensitive hash function (the corresponding analogue of Definition 2.2).

**Definition 2.2** (Hashing at every scale).: There exists a fixed constant \(c_{1}>0\) and a parameterized family \((r)\) of functions from \(X\) to some universe \(U\) such that for all \(r>0\), and for every \(x,y X\)

1. Close points collide frequently: \[}_{(r)}[(x)(y) ]}{r},\]2. Far points collide infrequently: \[*{}_{(r)}[(x)=(y) ](-c_{1}}{r}).\]

Uniform vs Importance Sampling.A natural algorithm for estimating \(*{H}(A,B)\) proceeds by _uniform sampling_: sample an \(a A\) uniformly at random and explicitly compute \(_{b B}\|a-b\|_{1}\). In general, we can compute the estimator \(\) for \(*{H}(A,B)\) by averaging over \(s\) uniformly chosen samples, resulting in runtime \((nds)\). It is easy to see that the resulting estimator is un-biased, i.e. \(*{}[]=*{H}(A,B)\). However, if a small constant fraction of elements in \(A\) contribute significantly to \(*{H}(A,B)\), then \(s=(n)\) samples could be necessary to obtain, say, a \(1\%\) relative error estimate with constant probability. Since each sample requires a linear scan to find the nearest neighbor, this would result in a quadratic runtime.

While such an approach has good empirical performance for well-behaved datasets, it does not work for data sets where the distribution of the distances from points in \(A\) to their nearest neighbors in \(B\) is skewed. Further, it is computationally prohibitive to verify the quality of the approximation given by uniform sampling. Towards proving Theorem 2.1, it is paramount to obtain an algorithm that works regardless of the structure of the input dataset.

A more nuanced approach is to perform _importance sampling_ where we sample \(a A\) with probability proportional to its contribution to \(*{H}(A,B)\). In particular, if we had access to a distribution, \(_{a}\), over elements \(a A\) such that, \(_{b B}\|a-b\|_{1}_{a}_{b B}\|a-b\| _{1}\), for some parameter \(>1\), then sampling \(O()\) samples results in an estimator \(\) that is within \(1\%\) relative error to the true answer with probability at least \(99\%\). Formally, we consider the estimator defined in Algorithm 1, where we assume access to \(*{rudeNN}(A,B)\), a sub-routine which receives as input \(A\) and \(B\) and outputs estimates \(_{a}_{ 0}\) for each \(a A\) which is guaranteed to be an upper bound for \(_{b B}\|a-b\|_{1}\). Based on the values \(\{_{a}\}_{a A}\) we construct an importance sampling distribution \(\) supported on \(A\). As a result, we obtain the following lemma:

**Lemma 2.3** (Variance Bounds for Chamfer Estimate).: _Let \(n,d\) and suppose \(A,B\) are two subsets of \(^{d}\) of size at most \(n\). For any \(T\), the output \(\) of \(*{}(A,B,T)\) satisfies_

\[*{}[] =*{H}(A,B),\] \[*{ar}[] *{H}(A,B)^{2} (}{*{H}(A,B)}-1),\]

Figure 1: The Chamfer-Estimate Algorithm.

_for \(\) from Line 1 in Figure 1. The expectations and variance are over the randomness in the samples of Line 3 of \((A,B,T)\). In particular,_

\[[\,|-(A,B)| (A,B)] T}(}{(A,B)}-1).\]

The proof follows from a standard analysis of importance sampling and is deferred to Appendix A. Observe, if \((A,B)\), it suffices to sample \(T=O/^{2}\) points in \(A\), leading to a running time of \(Ond/^{2}\).

Obtaining importance sampling probabilities.It remains to show how to implement the \((A,B)\) subroutine to obtain the distribution over elements in \(A\) which is a reasonable over-estimator of the true probabilities. A natural first step is to consider performing an \(( n)\)-approximate nearest neighbor search (NNS): for every \(a^{} A\), find \(b^{} B\) satisfying \(\|a^{}-b^{}\|_{1}/_{b B}\|a^{}-b\|_{1}=(  n)\). This leads to the desired guarantees on \(\{_{a}\}_{a A}\). Unfortunately, the state of the art algorithms for \(( n)\)-approximate NNS, even under the \(_{1}\) norm, posses extraneous \(( n)\) factors in the runtime, resulting in a significantly higher running time. These factors are even higher for the \(_{2}\) norm. Therefore, instead of performing a direct reduction to approximate NNS, we open up the approximate NNS black-box and give a simple algorithm which directly satisfies our desired guarantees on \(\{_{a}\}_{a A}\).

To begin with, we assume that the aspect ratio of all pair-wise distances is bounded by a fixed polynomial, \((n/)\) (we defer the reduction from an arbitrary input to one with polynomially bounded aspect ratio to Lemma A.3). We proceed via computing \(((n/))\) different (randomized) partitions of the dataset \(A B\). The \(i\)-th partition, for \(1 i((n/))\), can be written as \(A B=_{j}_{j}^{i}\) and approximately satisfies the property that points in \(A B\) that are at distance at most \(2^{i}\) will be in the same partition \(_{j}^{i}\) with sufficiently large probability. To obtain these components, we use a family of _locality-sensitive hash functions_, whose formal properties are given in Definition 2.2. Intuitively, these hash functions guarantee that:

1. For each \(a^{} A\), its _true_ nearest neighbor \(b^{} B\) falls into the _same_ component as \(a^{}\) in the \(i_{0}\)-th partition, where \(2^{i_{0}}=(\|a^{}-b^{}\|_{1})\)2, and 2. Every other extraneous \(b b^{}\) is _not_ in the same component as \(a^{}\) for each \(i<i_{0}\).

It is easy to check that any hash function that satisfies the aforementioned guarantees yields a valid set of distances \(\{_{a}\}_{a A}\) as follows: for every \(a^{} A\), find the smallest \(i_{0}\) for which there exists a \(b^{} B\) in the same component as \(a^{}\) in the \(i_{0}\)-th partition. Then set \(_{a^{}}=\|a^{}-b^{}\|_{1}\). Intuitively, the \(b^{}\) we find for any fixed \(a^{}\) in this procedure will have distance that is at least the closest neighbor in \(B\) and with good probability, it won't be too much larger. A caveat here is that we cannot show the

Figure 2: The \(\) Algorithm.

above guarantee holds for \(2^{i_{0}}=(\|a^{}-b^{}\|_{1})\). Instead, we obtain the slightly weaker guarantee that, _in the expectation_, the partition \(b^{}\) lands in is a \(( n)\)-approximation to the minimum distance, i.e. \(2^{i_{0}}=( n\|a^{}-b^{}\|_{1})\). Therefore, after running \((A,B)\), setting \(= n\) suffices for our \(\!(nd(n)/^{2})\) time algorithm. We formalize this argument in the following lemma:

**Lemma 2.4** (Oversampling with bounded Aspect Ratio).: _Let \((X,d_{X})\) be a metric space with a locality-sensitive hash family at every scale (see Definition 2.2). Consider two subsets \(A,B X\) of size at most \(n\) and any \((0,1)\) satisfying_

\[1_{a A,b B\\ a b}d_{X}(a,b)_{a A,b B}d_{X}(a,b) (n/).\]

_Algorithm 2, \((A,B)\), outputs a list of (random) positive numbers \(\{_{a}\}_{a A}\) which satisfy the following two guarantees:_

* _With probability_ \(1\)_, every_ \(a A\) _satisfies_ \(_{a}_{b B}d_{X}(a,b)\)_._
* _For every_ \(a A\)_,_ \([_{a}]( n)_{b B}d_ {X}(a,b)\)_._

_Further, Algorithm 2, runs in time \((dn(n/))\) time, assuming that each function used in the algorithm can be evaluated in \((d)\) time._

Proof Sketch for Theorem 2.1.: Given the lemmas above, it is straight-forward to complete the proof of Theorem 2.1. First, we reduce to the setting where the aspect ratio is \((n/)\) (see Lemma A.3 for a formal reduction). We then invoke Lemma 2.4 and apply Markov's inequality to obtain a set of distances \(_{a}\) such that with probability at least \(99/100\), for each \(a A\), \(_{b B}\|a-b\|_{1}_{a}\) and \(_{a A}_{a}((n))\,(A,B)\). We then invoke Lemma 2.3 and set the number of samples, \(T=((n)/^{2})\). The running time of our algorithm is then given by the time of \((A,B)\), which is \(O(nd(n/))\), and the time needed to evaluate the estimator in Lemma 2.3, requiring \((nd(n)/^{2})\) time. Refer to Section A for the full proof. 

Other Related WorksWe note that importance sampling is a popular technique used for speeding up geometric algorithms. For example,  uses it to obtain a fast \(c\)-approximate algorithm for computing Earth Mover Distance (EMD) in two (or any constant) dimensions, for some constant \(c>2\). However, the application and implementation of importance sampling in that paper is quite different from ours. In , the space containing all input points is subdivided into regions, and the total EMD value is represented as a sum of EMDs restricted to point-sets in each region (plus an additional representing the "global" EMD). The EMD cost in each region is then approximated quickly by embedding EMD into \(_{1}\) using a randomly shifted quadtree with logarithmic distortion; these estimations define the sampling probabilities.

In contrast, in our paper, the value of the Chamfer distance is exactly equal to the sum of distances from each point to its nearest neighbor, so there is no decomposition involved. Instead, we approximate each distance to nearest neighbor using a randomized hierarchical decomposition; for the case of the \(_{1}\) norm, each level of the decomposition partitions the space into rectangular boxes, as in quadtrees. Crucially, however, to ensure that the running time of our algorithm is within the stated bounds, we cannot use a standard randomly shifted quadtree where each level is shifted by the same random vector (as in ). This is because shifting all levels by the same amount only ensures that the expected distortion between a fixed pair of points is logarithmic; to ensure that the distance to the nearest neighbor is distorted by \(O( n)\), we would need to use \(O( n)\) independent quadtrees and apply the union bound. Instead, we use independent random partitions at each level, and show (Lemma 2.4) that this suffices to bound the expected distortion of the distance to the nearest neighbor, without incurring any additional factors. This makes it possible to obtain the running time as stated.

There are other works on quickly computing EMD and related distances. For example, the algorithm of  runs in time that is linear in the number of distances, i.e. it runs in \((n^{2})\) time and gets a \(1+\) approximation to EMD. This means that their approach requires a runtime quadratic in the size of the dataset \(n\). In contrast, Chamfer distance admits a trivial time \(O(n^{2})\) algorithm and our main contribution is to provide a nearly linear \(O(n(n)/^{2})\) algorithm to get \((1+)\)-approximation to Chamfer distance.

Experiments

We perform an empirical evaluation of our Chamfer distance estimation algorithm.

Summary of ResultsOur experiments demonstrate the effectiveness of our algorithm for both low and high dimensional datasets and across different dataset sizes. Overall, it is much faster than brute force (even accelerated with KD-trees). Further, our algorithm is both faster and more sample-efficient than uniform sampling. It is also robust to different datasets: while uniform sampling performs well for most datasets in our experiments, it performs poorly on datasets where the distances from points in \(A\) to their neighbors in \(B\) vary significantly. In such cases, our algorithm is able to adapt its importance sampling probabilities appropriately and obtain significant improvements over uniform sampling.

### Experimental Setup

We use three different experimental setups, small scale, outlier, and large scale. They are designed to'stress test' our algorithm, and relevant baselines, under vastly different parameter regimes. The datasets we use are summarized in Table 1. For all experiments, we introduce uniform sampling as a competitive baseline for estimating the Chamfer distance, as well as (accelerated) brute force computation. All results are averaged across \(20+\) trials and \(1\) standard deviation error bars are shown when relevant.

Small ScaleThese experiments are motivated from common use cases of Chamfer distance in the computer vision and NLP domains. In our small scale experiments, we use two different datasets: (a) the ShapeNet dataset, a collection of point clouds of objects in three dimensions . ShapeNet is a common benchmark dataset frequently used in computer graphics, computer vision, robotics and Chamfer distance is a widely used measure of similarity between different ShapeNet point clouds . (b) We create point clouds of words from text documents from . Each point represents a word embedding obtained from the word-to-vec model of  in \(^{300}\) applied to the Federalist Papers corpus. As mentioned earlier, a popular relaxation of the common Earth Mover Distance is exactly the (weighted) version of the Chamfer distance [16; 7].

Since ShapenNet is in three dimensions, we implement nearest neighbor queries using KD-trees to accelerate the brute force baseline as KD-trees can perform exact nearest neighbor search quickly in small dimensions. However, they have runtime exponential in dimension meaning they cannot be used for the text embedding dataset, for which we use a standard naive brute force computation. For both these datasets, we implement our algorithms using Python 3.9.7 on an M1 MacbookPro with 32GB of RAM. We also use an efficient implementation of KD trees in Python and use Numpy and Numba whenever relevant. Since the point clouds in the dataset have approximately the same \(n\) value, we compute the symmetric version \((A,B)+(B,A)\). For these experiments, we use the \(_{1}\) distance function.

OutliersThis experiment is meant to showcase the robustness of our algorithm. We consider two point clouds, \(A\) and \(B\), each sampled from Gaussian points in \(^{100}\) with identity covariance. Furthermore, we add an "outlier" point to \(A\) equal to \(0.5n\) **- 1**, where **1** is the all ones vector.

This example models scenarios where the distances from points in \(A\) to their nearest neighbors in \(B\) vary significantly, and thus uniform sampling might not accurately account for all distances, missing a small fraction of large ones.

**Dataset** & \(|A|,|B|\) & \(d\) & **Experiment** & **Metric** & **Reference** \\  ShapeNet & \( 8 10^{3}, 8 10^{3}\) & 3 & Small Scale & \(_{1}\) &  \\ Text Embeddings & \(2.5 10^{3},1.8 10^{3}\) & 300 & Small Scale & \(_{1}\) &  \\ Gaussian Points & \(5 10^{4},5 10^{4}\) & 2 & Outliers & \(_{1}\) & - \\ DEEP1B & \(10^{4},10^{9}\) & 96 & Large Scale & \(_{2}\) &  \\ Microsoft-Turing & \(10^{5},10^{9}\) & \(100\) & Large Scale & \(_{2}\) &  \\ 

Table 1: Summary of our datasets. For ShapeNet, the value of \(|A|\) and \(|B|\) is averaged across different point clouds in the dataset.

Large ScaleThe purpose of these experiments is to demonstrate that our method scales to datasets with billions of points in hundreds of dimensions. We use two challenging approximate nearest neighbor search datasets: DEEP1B  and Microsoft Turing-ANNS . For these datasets, the set \(A\) is the query data associated with the datasets. Due to the asymmetric sizes, we compute \((A,B)\). These datasets are normalized to have unit norm and we consider the \(_{2}\) distance function.

These datasets are too large to handle using the prior configurations. Thus, we use a proprietary in-memory parallel implementation of the SimHash algorithm, which is an \(_{2}\) LSH family for normalized vectors according to Definition 2.2 , on a shared virtual compute cluster with 2x64 core AMD Epyc 7763 CPUs (Zen3) with 2.45Ghz - 3.5GHz clock frequency, 2TB DDR4 RAM and 256 MB L3 cache. We also utilize parallization on the same compute cluster for naive brute force search.

### Results

Small ScaleFirst we discuss configuring parameters. Recall that in our theoretical results, we use \(( n)\) different scales of the LSH family in \(\). \(\) then computes (over) estimates of the nearest neighbor distance from points in \(A\) to \(B\) (in near linear time) which is then used

Figure 4: Runtime experiments. We set the number of samples for uniform and importance sampling such that the relative errors of their respective approximations are similar.

Figure 3: Sample complexity vs relative error curves.

for importance sampling by \(\)-\(\). Concretely for the \(_{1}\) case, this the LSH family corresponds to imposing \(( n)\) grids with progressively smaller side lengths. In our experiments, we treat the number of levels of grids to use as a tuneable parameter in our implementation and find that a very small number suffices for high quality results in the importance sampling phase.

Figure 6 (b) shows that only using \(3\) grid levels is sufficient for the crude estimates \(_{a}\) to be within a factor of \(2\) away from the true nearest neighbor values for the ShapeNet dataset, averaged across different point clouds in the dataset. Thus for the rest of the Small Scale experiments, we fix the number of grid levels to be \(3\).

Figure 3 (a) shows the sample complexity vs accuracy trade offs of our algorithm, which uses importance sampling, compared to uniform sampling. Accuracy is measured by the relative error to the true value. We see that our algorithm possesses a better trade off as we obtain the same relative error using only \(10\) samples as uniform sampling does using \(50+\) samples, resulting in at least a **5x** improvement in sample complexity. For the text embedding dataset, the performance gap between our importance sampling algorithm and uniform sampling grows even wider, as demonstrated by Figure 3 (b), leading to **> 10x** improvement in sample complexity.

In terms of runtimes, we expect the brute force search to be much slower than either importance sampling and uniform sampling. Furthermore, our algorithm has the overhead of first estimating the values \(_{a}\) for \(a A\) using an LSH family, which uniform sampling does not. However, this is compensated by the fact that our algorithm requires much fewer samples to get accurate estimates.

Indeed, Figure 4 (a) shows the average time of 100 Chamfer distance computations between randomly chosen pairs of point clouds in the ShapeNet dataset. We set the number of samples for uniform sampling and importance sampling (our algorithm) such that they both output estimates with (close to) \(2\%\) relative error. Note that our runtime includes the time to build our LSH data structures. This means we used \(100\) samples for importance sampling and \(500\) for uniform. The brute force KD Tree algorithm (which reports exact answers) is approximately 5x slower than our algorithm. At the same time, our algorithm is \(50\%\) faster than uniform sampling. For the Federalist Papers dataset (Figure 4 (b)), our algorithm only required \(20\) samples to get a \(2\%\) relative error approximation, whereas uniform sampling required at least \(450\) samples. As a result, our algorithm achieved **2x** speedup compared to uniform sampling.

OutliersWe performed similar experiments as above. Figure 3 (c) shows the sample complexity vs accuracy trade off curves of our algorithm and uniform sampling. Uniform sampling has a very large error compared to our algorithm, as expected. While the relative error of our algorithm decreases smoothly as the sample size grows, uniform sampling has the same high relative error. In fact, the relative error will stay high until the outlier is sampled, which typically requires \((n)\) samples.

Large ScaleWe consider two modifications to our algorithm to optimize the performance of \(\) on the two challenging datasets that we are using; namely, note that both datasets are standard for benchmarking billion-scale nearest neighbor search. First, in the \(\) algorithm, when computing \(_{a}\) for \(a A\), we search through the hash buckets \(h_{1}(a),h_{2}(a),\) containing

Figure 5: The figures show sample complexity vs relative error curves as we vary the number of LSH data structures and window sizes. Each curve maps \(k W\) where \(k\) is the number of LSH data structures we use to repeatedly hash points in \(B\) and \(W\) is the window size, the number of points retrieved from \(B\) that hash closest to any given \(a\) at the smallest possible distance scales.

\(a\) in increasing order of \(i\) (i.e., smallest scale first), and retrieve the first \(W\) (window size) distinct points in \(B\) from these buckets. Then, the whole process is repeated \(k\) times, with \(k\) independent LSH data structures, and \(_{a}\) is set to be the distance from \(a\) to the closest among all \(Wk\) retrieved points.

Note that previously, for our smaller datasets, we set \(_{a}\) to be the distance to the first point in \(B\) colliding with \(a\), and repeated the LSH data structure once, corresponding to \(W=k=1\). In our figures, we refer to these parameter choices as \(k W\) and test our algorithm across several choices.

For the DEEP and Turing datasets, Figures 3 (d) and 3 (e) show the sample complexity vs relative error trade-offs for the best parameter choice (both \(64 10^{6}\)) compared to uniform sampling. Qualitatively, we observe the same behavior as before: importance sampling requires fewer samples to obtain the same accuracy as uniform sampling. Regarding the other parameter choices, we see that, as expected, if we decrease \(k\) (the number of LSH data structures), or if we decrease \(W\) (the window size), the quality of the approximations \(\{_{a}\}_{a A}\) decreases and importance sampling has worse sample complexity trade-offs. Nevertheless, for all parameter choices, we see that we obtain superior sample complexity trade-offs compared to uniform sampling, as shown in Figure 5. A difference between these parameter choices are the runtimes required to construct the approximations \(\{_{a}\}_{a A}\). For example for the DEEP dataset, the naive brute force approach (which is also optimized using parallelization) took approximately \(1.3 10^{4}\) seconds, whereas the most expensive parameter choice of \(64 10^{6}\) took approximately half the time at \(6.4 10^{3}\) and the cheapest parameter choice of \(8 10^{5}\) took \(225\) seconds, leading to a **2x-50x** factor speedup. The runtime differences between brute force and our algorithm were qualitative similar for the Turing dataset.

Similar to the small scale dataset, our method also outperforms uniform sampling in terms of runtime if we require they both output high quality approximations. If we measure the runtime to get a \(1\%\) relative error, the \(16 2 10^{5}\) version of our algorithm for the DEEP dataset requires approximately \(980\) samples with total runtime approximately \(1785\) seconds, whereas uniform sampling requires \(>1750\) samples and runtime \(>2200\) seconds, which is \(>23\%\) slower. The gap in runtime increases if we desire approximations with even smaller relative error, as the overhead of obtaining the approximations \(\{_{a}\}_{a A}\) becomes increasingly overwhelmed by the time needed to compute the exact answer for our samples.

Additional Experimental ResultsWe perform additional experiments to show the utility of our approximation algorithm for the Chamfer distance for downstream tasks. For the ShapeNet dataset, we show we can efficiently recover the true exact nearest neighbor of a fixed point cloud \(A\) in Chamfer distance among a large collect of different point clouds. In other words, it is beneficial for finding the 'nearest neighboring point cloud'. Recall the ShapeNet dataset, contains approximately \(5 10^{4}\) different point clouds. We consider the following simple (and standard) two step pipeline: (1) use our algorithm to compute an approximation of the Chamfer distance from \(A\) to every other point cloud \(B\) in our dataset. More specifically, compute an approximation to \((A,B)+(B,A)\) for all \(B\) using \(50\) samples and the same parameter configurations as the small scale experiments. Then filter the dataset of points clouds and prune down to the top \(k\) closest point cloud candidates according to our approximate distances. (2) Find the closest point cloud in the top \(k\) candidates via exact computation.

We measure the accuracy of this via the standard recall \(@k\) measure, which computes the fraction of times the _exact_ nearest neighbor \(B\) of \(A\), averaged over multiple \(A\)'s, is within the top \(k\) choices. Figure 6 (a) shows that the true exact nearest neighbor of \(A\), that is the point cloud \(B\) which minimizes \((A,B)+(B,A)\) among our collection of multiple point clouds, is within the top \(30\) candidates \(>98\%\), time (averaged over multiple different choices of \(A\)). This represents a more than **1000x** reduction in the number of point clouds we do exact computation over compared to the naive brute force method, demonstrating the utility of our algorithm for downstream tasks.

## 4 Lower Bound for Reporting the Alignment

We presented an algorithm that, in time \(\!(nd(n)/^{2})\), produces a \((1+)\)-approximation to \((A,B)\). It is natural to ask whether it is also possible to _report_ a mapping \(g:A B\) whose cost \(_{a A}\|a-g(a)\|_{1}\) is within a factor of \(1+\) from \((A,B)\). (Our algorithm uses on random sampling and thusdoes not give such a mapping). This section shows that, under a popular complexity-theoretic conjecture called the _Hitting Set Conjecture_, such an algorithm does not exists. For simplicity, we focus on the case when the underlying metric \(d_{X}\) is induced by the Manhattan distance,i.e., \(d_{X}(a,b)=\|a-b\|_{1}\). The argument is similar for the Euclidean distance, Euclidean distance squared, etc. To state our result formally, we first define the Hitting Set (HS) problem.

**Definition 4.1** (Hitting Set (HS) problem).: The input to the problem consists of two sets of vectors \(A,B\{0,1\}^{d}\), and the goal is to determine whether there exists some \(a A\) such that \(a b 0\) for every \(b B\). If such an \(a A\) exists, we say that \(a\)_hits_\(B\).

It is easy to see that the Hitting Set problem can be solved in time \(n^{2}d\). The Hitting Set Conjecture  postulates that this running time is close to the optimal. Specifically:

**Conjecture 4.2**.: _Suppose \(d=(^{2}n)\). Then for every constant \(>0\), no randomized algorithm can solve the Hitting Set problem in \(n^{2-}\) time._

Our result can be now phrased as follows.

**Theorem 4.3** (Hardness for reporting a mapping).: _Let \(T(N,D,)\) be the running time of an algorithm \(ALG\) that, given sets of \(A",B"\{0,1\}^{D}\) of sizes at most \(N\), reports a mapping \(g:A" B"\) with cost \((1+)(A",B")\), for \(D=(^{2}N)\) and \(=\). Assuming the Hitting Set Conjecture, we have that \(T(N,D,)\) is at least \((N^{2-})\) for any constant \(>0\)._

## 5 Conclusion

We present an efficient approximation algorithm for estimating the Chamfer distance up to a \(1+\) factor in time \((nd(n)/^{2})\). The result is complemented with a conditional lower bound which shows that reporting a Chamfer distance mapping of similar quality requires nearly quadratic time. Our algorithm is easy to implement in practice and compares favorably to brute force computation and uniform sampling. We envision our main tools of obtaining fast estimates of coarse nearest neighbor distances combined with importance sampling can have additional applications in the analysis of high-dimensional, large scale data.

## 6 Acknowledgement

AB was supported by Ankur Moitra's ONR grant and the NSF TRIPODS program (award DMS-2022448). PI was supported by the NSF TRIPODS program (award DMS-2022448), Simons Investigator Award and GIST-MIT Research Collaboration grant.