# Learning Cuts via Enumeration Oracles

Daniel Thuerck

Quantagonia

Bad Homburg, Germany

daniel.thuerck@quantagonia.com

&Boro Sofranac

Quantagonia

Bad Homburg, Germany

boro.sofranac@quantagonia.com

&Marc E. Pfetsch

Department of Mathematics, TU Darmstadt

Darmstadt

pfetsch@mathematik.tu-darmstadt.de

&Sebastian Pokutta

Zuse Institute Berlin and TU Berlin

Berlin, Germany

pokutta@zib.de

###### Abstract

Cutting-planes are one of the most important building blocks for solving large-scale integer programming (IP) problems to (near) optimality. The majority of cutting plane approaches rely on explicit rules to derive valid inequalities that can separate the target point from the feasible set. _Local cuts_, on the other hand, seek to directly derive the facets of the underlying polyhedron and use them as cutting planes. However, current approaches rely on solving Linear Programming (LP) problems in order to derive such a hyperplane. In this paper, we present a novel generic approach for learning the facets of the underlying polyhedron by accessing it implicitly via an enumeration oracle in a reduced dimension. This is achieved by embedding the oracle in a variant of the Frank-Wolfe algorithm which is capable of generating strong cutting planes, effectively turning the enumeration oracle into a separation oracle. We demonstrate the effectiveness of our approach with a case study targeting the multidimensional knapsack problem (MKP).

## 1 Introduction

In this paper, we deal with _integer programs_ (IP)

\[\,\{ c,x:Ax b,\ x^{n}\},\] (IP)

where \(A^{m n}\), \(b^{m}\), and \(c^{n}\). Let \(P\{x^{n}:Ax b\}\) be the underlying polyhedron and its integer hull \(P_{I}(P^{n})\). We restrict attention to the case in which all variables are required to be integral, as the methods we will propose are more readily applicable to this case, but the general idea works for mixed-integer programs (MIP) as well.

Solving IPs is \(\)-hard in general, however, surprisingly fast algorithms exist in practice . The most successful approach to solving IPs is based on the _branch-and-bound_ algorithm and its extensions. This algorithm involves breaking down the original problem into smaller subproblems that are easier to solve through a process known as branching. By repeatedly branching on subproblems, a search tree is obtained. The bounding step involves computing upper bounds for subproblems and pruning suboptimal nodes of the tree in order to avoid enumerating exponentially many subproblems. Upper bounds are generally computed with the help of Linear Programming (LP) relaxations

\[\,\{ c,x:x P\}.\] (LP)

Because the integrality constraints are relaxed, optimal solutions of (LP) provide an upper bound for the original problem (IP).

Alternatively, _cutting plane_ procedures iteratively solve LP-relaxations as long as the solution \(x^{*}\) is not integral (and thus \(x^{*} P_{I}\)). To remove these solutions \(x^{*}\) from the relaxation's polyhedron, one adds cutting planes (or _cuts_) \(,x\) with \(a^{n}\), \(\), and \(,x^{*}>\). The search for such cutting planes or to determine that none exists is called the _separation problem_. The strongest cuts are those that define a _facet_, i.e., the face \(P_{I}\{x:,x=\}\) has co-dimension 1 with respect to \(P_{I}\). When the cutting plane method is combined with branch-and-bound, the resulting algorithm is often called _branch-and-cut_. Gomory conducted foundational work in this field, demonstrating that pure cutting plane approaches can solve integer programs with rational data in a finite number of steps without the need for branching .

Gomory's initial approach to cutting planes suffered from numerical difficulties at that time, preventing pure cutting plane methods from being effective in practical applications. However, his proposed (Gomory) mixed integer (GMI) cuts are very efficient if combined with branch-and-bound (see the computational study in ) and still are one of the most important types of cutting planes used by contemporary solvers. As more GMI cuts are added to a problem, their incremental value tends to diminish. To address this issue, modern MIP and IP solvers use a range of techniques to generate cuts, e.g., mixed-integer-rounding (MIR) inequalities , knapsack covers , flow covers , lift-and-project cuts , {0, \(\)}-Chvatal-Gomory cuts , and others.

Most cutting plane separation algorithms rely on fixed formulas to derive valid inequalities that separate the target point \(x^{*}\) from the polyhedron \(P_{I}\). An alternative approach is to directly seek to derive the facets of \(P_{I}\) that separate the point \(x^{*}\). Notice that while the facets of the polyhedron \(P\) are explicitly known from the problem definition, the facets of its integer hull \(P_{I}\) are unknown in general. While the facet-defining inequalities are intuitively the strongest cuts, they can be relatively expensive to explicitly compute, limiting their applicability in practice. _Local cuts_, a type of cutting planes that try to derive facets of \(P_{I}\), approach this problem by deriving facets of \(P_{I}\) in a reduced dimension, and then _lifting_ those cuts to obtain facets in the original dimension. In this paper, we will propose a new variant of the _Frank-Wolfe_ algorithm with the goal of _learning_ the (unknown) facets of \(P_{I}\) (or at least valid inequalities) in a reduced dimension, which can then be lifted to the original dimension and be used as strong cutting planes. In our learning approach, the underlying polyhedron will only be accessed via an algorithmically simple linear optimization oracle, in contrast to existing approaches, which also need to solve LPs.

### Related Work

Local cuts have first been introduced as "Fenchel cuts" in Boyd , who developed an algorithm to exactly separate inequalities for the knapsack polytope via the equivalence of separation and optimization. They were subsequently investigated extensively by Applegate et al.  for solving the traveling salesman problem (TSP). Buchheim et al.  and Althaus et al.  adopted local cuts into their approaches for solving constrained quadratic 0-1 optimization problems and Steiner-tree problems, respectively. In , Chvatal et al. generalize the local cuts method to general MIP problems.

In the context of knapsack problems, after the aforementioned work of Boyd , Boccia  introduced an approach based on local cuts, as stated by Kaparis and Letchford 1, who further refined the algorithm. Vasilyev presented an alternative approach with application to the generalized assignment problem in , see also the comprehensive computational study conducted by Avella et al. in . In , Vasilyev et al. propose a new implementation of this approach, with the goal of making it more efficient. In , Gu presents an extension of the algorithm of Vasilyev et al. .

Existing works on the application of learning methods in solving IP (and more generally MIP) problems can in general be divided into two categories: learning decision strategies within the solvers, and learning heurisitcs to obtain feasible (primal) solutions. Examples of the former would be learning to select branching variables , learning to select branching nodes , learning to select cutting planes , learning to optimize the usage of primal heuristics . A typical example of the latter case would be learning methods to develop _large neighborhood search_ (LNS) heuristics . Additionally, a number of works in the literature have focused on learning algorithms for solving specific IP problems . For a more detailed overview of using learning methods in IP, we refer the interested reader to .

### Contribution

The contributions of this paper can be summarized as follows:

1. We present an efficient, LP-free separation framework that aims to learn local cuts for IPs through the solution of subproblems. We propose to use a variant of the Frank-Wolfe  algorithm to solve the associated separation problem. The resulting framework is general and - given the availability of a suitable lifting method - applicable to any IP.
2. We propose a new, dynamic stopping criterion for the application of Frank-Wolfe to the separation problem at hand. This new criterion, derived by exploiting duality information, directly evaluates the strength of the resulting cut and thus dramatically decreases the number of iterations.
3. We illustrate the benefit of our approach in a case study for the multidimensional knapsack (MKP) problem, demonstrating its effectiveness. Our computational results show that embedding our method in the academic solver SCIP leads to 31% faster solving times on the instances solved to optimality, on average.

The rest of this paper is organized as follows: In Section 2, the fundamental framework of local cuts and required notation are introduced. Section 3 presents our approach for the LP-less generation procedure for local cuts. Section 4 demonstrates how the aforementioned framework can be applied to solve the multidimensional knapsack problem. Computational experiments are presented in Section 5. Finally, Section 6 summarizes conclusions and future work.

## 2 Local Cuts

To describe the idea of local cuts, assume that \(P^{n},n>0\), is a polytope, i.e., bounded, and full-dimensional. Then one considers a small subproblem with underlying polytope \(\), which is usually an orthogonal projection of \(P\) onto a lower-dimensional space. The polytope \(\) is restricted to being non-empty and its dimension \(0<k n\) is chosen small enough such that integer optimization problems over \(\) can be solved efficiently in practice, for example, by enumeration. Consider a projection \(\) of the point to be separated \(x^{*}\) on \(^{k}\). The procedure tries to generate a valid cut \(,x\) with \(^{k}\), \(\), such that \(,>\), i.e., it cuts off \(\) from \(\). This cut can be "lifted" to the original space, which yields a cut \(,x\) that hopefully cuts off \(x^{*}\).2

The approach to generate \(,x\), in the literature mentioned above, relies on the equivalence between optimization and separation  and can be very briefly explained as follows. By the Minkowski-Weyl Theorem, we can express \(\) as the convex hull of its vertex set \(V\). Let \(^{0}\) be an interior point. Then consider the LP

\[_{,}\ \{:_{v V}v\,_{v}+(-^{0})=,\ _{v V}_{v}=1,\  0\}.\]

The dual problem \((D)\) is

\[_{,}\ \{,-: v, \  v V,\ -^{0}, 1\}.\]

Let \(\), \(\) be an optimal solution of \((D)\). Then \(,x\) is a valid inequality for \(\), since by construction \( v,\) holds for all \(v V\) and thus by convexity for all points in \(\). The objective enforces that this cut is maximally violated by \(\) if the optimal value is positive.

Since \(\) may have an exponential number of vertices, problem \((D)\) can be solved by a column generation algorithm (or cutting plane algorithm in the primal). In each iteration, one needs to solve the following pricing problem for the current point \((,)\): Decide whether there exists \(v V\) with \( v,>\). This can be done by maximizing \(\) over the subproblem \(\), i.e., one can use a linear optimization oracle for the subproblem. This subproblem can contain integrality constraints, thereby requiring, again, IP techniques. Note that the most interesting case is where we operate on integerhulls, i.e. \(=_{l}\) to generate cuts for \(P=P_{I}\). In this way, local cuts can help solving an integer optimization problem over \(P\). Hence, in the following sections, any reference to \(P\), \(\) holds for the integer case as well and our case study illustrates exactly that.

As mentioned above, the strongest cutting planes are those that define facets. The tilting method by Applegate et al.  produces such a facet. Buchheim et al.  introduced a different formulation that automatically produces a facet. Chvatal et al.  developed a formulation for general MIPs using linear optimization oracles. All three approaches use a sequence LPs at their heart; either for tilting a plane or through a column-generation procedure.

## 3 Learning Strong Cuts from Enumeration

The local cuts framework, applicable to general IPs, relies on a sequence of three operators: SEP, FACET and LIFT. SEP refers to a separation oracle separating the projected point \(\) from \(\) that returns a separating cut \(,x\) (or certifies that \(\)). FACET further refines the cut until it represents a facet of \(\) and lastly, LIFT transforms the resulting facet into the space of \(P\) such that it separates \(x^{*}\) from \(P\) with high probability. In some variants of local cuts, SEP and FACET may be combined into one step similar to , whereas in , the _tilting_ process is a separate, concrete embodiment of FACET. Note that that facets of the subproblem, when lifted, result in the strongest cuts. In practice, it is often sufficient to find good valid inequalities of \(\). As mentioned before, the original approach for local cuts through duality requires an expensive column-generation method which is based on LPs. In this section, we derive an alternative and LP-less approach.

The general idea of our new approach is sketched in Figure 1: Given a point \(^{n}\) that we intend to separate from \(P\), we solve the following optimization problem:

\[y^{*}=*{argmin}_{y}f(y),\] (Separation)

with \(f(y)\|y-\|^{2}\). Observe that this is effectively the projection of \(\) onto \(\) under the \(_{2}\)-norm and that \( f(y)=(y-)\).

We solve (Separation) with a suitable variant of the Frank-Wolfe algorithm. The _Frank-Wolfe_ algorithm  (also called: _Conditional Gradients_) is a method to minimize a smooth convex function \(f\) over a compact convex domain \(P\) by only relying on a _First-order Oracle (FO)_ for \(f\), i.e., given a point \(x\) the oracle returns \( f(x)\) (and potentially \(f(x)\)) as well as a _Linear Minimization Oracle (LMO)_ ("oracle" for the remainder of this paper), i.e., given an objective vector \(c\), the oracle returns \(v*{argmin}_{x} c,x\). The original Frank-Wolfe algorithm, provided with step sizes \(_{t}>0\), iteratively calls the LMO to determine \(v_{t}*{argmin}_{v c} f(y_{t}),v\) and updates the iterate to \(y_{t+1} y_{t}+_{t}(v_{t}-y_{t})\). There are various step-size strategies for \(_{t}\), but the actual choice is irrelevant for the discussion here; a common choice is \(_{t}=\).

The main advantages of using Frank-Wolfe are (1) if there is a LP-less oracle, valid inequalities can be generated without solving LPs, (2) the computational overhead of the Frank-Wolfe steps compared to calls to the LMO are very light and, finally, (3) as we will show, for the case of (Separation), we can derive a new dynamic stopping criterion that can dramatically reduce the number of iterations. Note that we are not guaranteed to end up with facets, especially when the method is stopped early, however, valid inequalities that are "close" to being a facet can still serve as strong cutting planes.

For our problem minimizing \(f\), the Frank-Wolfe algorithm iteratively calls the oracle and updates its current iterate through a convex combination of the previous iterate and oracle's solution vertex. Step by step, the solution is thus expressed through a convex combination of vertices in \(\) as shown in Figures 0(a) - 0(c). At convergence, the hyperplane \( f(y^{*}),x f(y^{*}),y^{*}\) forms the desired cut.

### Separation via Conditional Gradients

Let \(y^{*}\) be an optimal solution to (Separation) and let \(x\) be arbitrary. By convexity, it follows that \(0 f(x)-f(y^{*}) f(x),x-y^{*}_{v} f(x),x-v\) and the last quantity is referred to as _Frank-Wolfe gap (at \(x\))_. Moreover, the following lemma holds, which is a direct consequence of the first-order optimality condition.

**Lemma 1** (First-order Optimality Condition).: _Let \(y^{*}\). Then \(y^{*}\) is an optimal solution to \(_{y}f(y)\) if and only if \( f(y^{*}),y^{*}-v 0\) for all \(v\) (and in particular \(_{v} f(y^{*}),y^{*}-v=0\))._

Note that in the constrained case, it does not necessarily hold that \( f(y^{*})=0\), if \(y^{*}\) is an optimal solution. In fact, if the \(\) that we want to separate is not contained in \(\), then \(f(y^{*})>0\) and \( f(y^{*}) 0\) since \(y^{*}\) will lie on the boundary of \(\).

It turns out that we can naturally use an optimal solution \(y^{*}\) to (Separation) to derive a separating hyperplane. By Lemma 1:

\[ f(y^{*}),y^{*} f(y^{*}),v,\] (Cut)

which holds for all \(v\). Moreover, if \(\), then (Cut) is violated by \(\), i.e., \( f(y^{*}),y^{*}> f(y^{*}),\), since \( f(y^{*}),y^{*}- f(y^{*})-f()=f(y^{* })>0\).

Usually, however, we do not solve Problem (Separation) exactly, but rather up to some accuracy. In fact, the Frank-Wolfe algorithm often uses the Frank-Wolfe gap as a stopping criterion, minimizing the function until for some iterate \(y_{t}\) it holds \(_{v} f(y_{t}),y_{t}-v\) for some target accuracy \(\); note that the Frank-Wolfe gap converges with the same rate (up to small constant factors) as the primal gap (see e.g., ). Given an accuracy \(>0\), we obtain the valid inequality

\[ f(y_{t}),y_{t}- f(y_{t}),v,\] (approxCut)

for all \(v\), which also separates \(\) from \(\) if it is \(\)-far from \(\), i.e., \(\|y^{*}-\|>\):

\[ f(y_{t}),y_{t}-- f(y_{t})-f( )- f(y^{*})->0.\]

The accuracy \(\) is chosen depending on the application; see also  for a sensitivity analysis for conditional gradients.

#### 3.1.1 A dynamic stopping criterion

It turns out, however, that in our case of interest, the above can be significantly improved by exploiting duality information. This allows us not only to stop the algorithm much earlier, but we also obtain a separating inequality directly from the associated stopping criterion and duality information.

The stopping criterion is derived from a few simple observations, which provide a new characterization of a point \(\) that can be separated from \(\). Our starting point is the following standard expansion. Let \(v\) be arbitrary and let \(y_{t}\) be an iterate from above. Then,

\[\|-v\|^{2}=\|-y_{t}\|^{2}+\|y_{t}-v\|^{2}-2 y_{t}- ,y_{t}-v,\]

Figure 1: We propose the following approach to separate a fractional point \(\) from a full-dimensional polytope \(\): We solve \(_{y}f(y):=\|y-\|^{2}\), i.e., the \(L_{2}\) projection of \(\) onto \(\), through a variant of the Frank-Wolfe algorithm. Starting from a random vertex (a), the algorithm iteratively computes the gradient of \(f\) at the current iterate \(y_{k}\) and uses an _oracle_ to solve a linear integer optimization problem over \(\), building up an _active set_ of vertices that form iterates through a convex combination (b). At convergence (c) the optimal solution \(y^{*}=y_{k+i}\) together with its gradient forms a cut that induces a facet of \(\): \( f(y_{k+i})^{}x f(y_{k+i})^{}y_{k+i}\) (except for degenerate cases).

which is equivalent to

\[ y_{t}-,y_{t}-v=\|-y_{t}\|^{2}+\|y_{t}-v\|^{2}-\|-v\|^{2}.\] (1)

Observe that the left hand-side is the Frank-Wolfe gap expression at iterate \(y_{t}\) (except for the maximization over \(v\)) since \( f(y_{t})=y_{t}-\).

Necessary Condition.Let us first assume \(\|y_{t}-v\|<\|-v\|\) for all vertices \(v\) in some iteration \(t\). Then (1) yields

\[ y_{t}-,y_{t}-v<\|-y_{t}\|^{2}.\] (altTest)

If \(v_{t}\) is the Frank-Wolfe vertex in iteration \(t\), we obtain:

\[\|y_{t}-\|^{2} -\|y^{*}-\|^{2}=f(y_{t})-f(y^{*})\] \[_{v} f(y_{t}),y_{t}-v=  f(y_{t}),y_{t}-v_{t}= y_{t}-,y_{t}-v_{t} <\|-y_{t}\|^{2}.\]

Subtracting \(\|-y_{t}\|^{2}\) on both sides and re-arranging yields: \(0<\|y^{*}-\|^{2}\), which proves that \(\). Moreover, (1) also immediately provides a separating hyperplane: observe that (altTest) is actually a linear inequality in \(v\) and it holds for all \(v\) since the maximum is achieved at a vertex. However, for the choice \(v=\) the inequality is violated.

Sufficient Condition.Suppose that in each iteration \(t\) there exists a vertex \(_{t}\) (not to be confused with the Frank-Wolfe vertex), so that \(\|y_{t}-_{t}\|\|-_{t}\|\). In this case (1) ensures:

\[ y_{t}-,y_{t}-_{t}=\|-y_{t }\|^{2}+\|y_{t}-_{t}\|^{2}-\|-_{t}\|^{2}\ \|-y_{t}\|^{2}.\]

Thus, the Frank-Wolfe gap satisfies in each iteration \(t\) that

\[_{v} f(y_{t}),y_{t}-v y_{t}- ,y_{t}-_{t}\|-y_{t}\|^{2},\]

i.e., the Frank-Wolfe gap upper bounds the distance between the current iterate \(y_{t}\) and point \(\) in each iteration. Now, the Frank-Wolfe gap converges to \(0\) as the algorithm progresses, with iterates \(y_{t}\), so that with the usual arguments (compactness and limits etc.) it follows that \(\). In total, we obtain the following result.

_Characterization 2_.: The following are equivalent:

1. (Non-Membership) \(\).
2. (Distance) There exists an iteration \(t\), so that \(\|y_{t}-v\|<\|-v\|\) for all vertices \(v\).
3. (FW Gap) For some iteration \(t\), \(_{v} y_{t}-,y_{t}-v<\| -y_{t}\|^{2}\).

In particular, Characterization 2.3 can be easily tested within the algorithm, since the Frank-Wolfe gap is computed anyways. Using this criterion significantly improves the performance of the algorithm. Moreover, the characterization above can also be combined with standard convergence guarantees to estimate the number of iterations required to either certify non-membership or membership (up to an \(\)-error): If we use the vanilla Frank-Wolfe algorithm, then by standard guarantees (see e.g., ) it is known that the Frank-Wolfe gap \(g_{t}=_{v} y_{t}-,y_{t}-v\) satisfies \(_{0 t}g_{}}{t+3}\) for appropriate positive constants \(L\) and \(D\). Suppose that \(_{v} y_{t}-,y_{t}-v\| -y_{t}\|^{2}\) holds for all iterations \(0 t T\). We want to estimate how long this can hold. If \(\), then using the convergence guarantee yields:

\[0<(,)^{2}_{0  t}\|-y_{}\|^{2}}{t+3}.\]

Using \(L=1\) as \(f(y)=\|-y\|^{2}\) and rearranging we obtain

\[t T}{(,)^{2}}-3,\]

i.e., after at most \(T\) iterations we have certified that \(\) is not in \(\). Guarantees for more advanced Frank-Wolfe variants can be obtained similarly.

### Computational Aspects

A common trait of the local cuts framework is that \(\) is accessed implicitly via an oracle returning vertices. By far the simplest black-box oracle for any bounded IP is _enumeration_, which simply evaluates all possible solutions \(x\) and picks the best one. If the IP is unbounded, then pure enumeration does not suffice any more and the oracle needs to take the unboundedness into account. For some problems, we can find _problem-specific_ algorithms that only enumerate over feasible solutions or otherwise exploit the structure of the problem at hand to reduce the complexity of enumeration. Examples are the _dynamic programming_ approach for knapsack problems, see Section 4.1, or directly enumerating \(n!\) possible permutations of \(n\) items for the _linear ordering problem_ (LOP).

Similarly to the enumeration oracle, the _lifting_ routine can also avail of problem-specific structure in some cases. In the case of LOPs, the so-called _trivial lifting_ lemma holds, that is, facet-defining inequalities of the LOP polytope in dimension \(n\) also define facets in dimension \(r>n\), meaning that no lifting is needed at all in this case. For knapsack problems, we can again use a dynamic programming approach, see Section 4.2.

In general, to apply our method to a given class of IP problems, one needs three components: i) a projection \(P\). ii) An oracle solving linear optimization problems over \(\) to optimality; in order to be practical, the selected \(\) should be such that the oracle runs reasonably fast. iii) A lifting method to lift cuts from \(\) up to \(P\).

In our implementation, we use the _Lazy Away-Step Frank-Wolfe algorithm_ of [18; 19], which converges linearly for (Separation). We integrate the novel termination criterion from Characterization 2.3, leading to Algorithm 1. This algorithm should be thought of as a more advanced version of the vanilla Frank-Wolfe algorithm. This variant is motivated by the fact that Frank-Wolfe trends towards sparse solutions and hence the oracle will often return previously-seen vertices. Hence, instead of querying the expensive oracle, one stores all previous vertices in a _active set_ whose size is controlled through so-called away steps. It provides superior convergence speed both in iterations andwall-clock time, exploiting the strong convexity of our objective function of the separation problem; we refer the interested reader to [46; 52; 16] for an overview. Lazification, to be thought of as an advanced caching technique, further reduces the per-iteration cost by reusing previously computed LMO solutions. Lastly, we note that in our setting and case study presented in Section 4, the LMO always returns a vertex. Even though this is not a theoretical requirement for the results presented in this paper, we do not consider the alternative case for brevity.

## 4 Case Study: The Multidimensional Knapsack Problem

The _multidimensional knapsack problem_ (MKP) is a well-known problem in combinatorial optimization and is strongly \(\)-hard. It has been used to address various practical resource allocation problems . The problem involves maximizing the total profits of selected items, taking into account \(m\) resource capacity (knapsack) constraints. There are \(n\) items that contribute profits given by \(c^{n}\). The resource consumption of item \(j\) for the \(i\)th knapsack is given by \(a_{ij}_{+}\); this defines a matrix \(A=(a_{ij})_{+}^{m n}\). The capacities of the knapsacks are given by \(b^{m}\). We define binary variables \(x\{0,1\}^{n}\) such that \(x_{j}\) is equal to 1 if item \(j\) is selected and 0 otherwise. Then MKP can be expressed as an IP:

\[\{ c,x:Ax b,\ x\{0,1\}^{n}\}.\] (MKP)

There exists abundant literature on the knapsack problems; we refer the interested reader to the recent survey by Hojny et al. .

We will also test our approach on the instances of the _generalized assignment problem_ (GAP), see Section 5. GAP is a variant of MKP with applications in scheduling . In addition to the constraints from the MKP problem, it is required that each of the \(n\) items be assigned to exactly one knapsack. The interested reader can find a survey, more details, and a comprehensive reference list in [4; 58].

In order for our approach to work, we need to provide two things: the _oracle_, presented in Section 4.1, and the _lifting_ routine, presented in Section 4.2, cf. Section 2 and Section 3.

We consider each knapsack problem in turn and try to generate inequalities that are valid for each individual knapsack. This has the advantage that there are practically efficient oracles and more importantly efficient lifting processes. The disadvantage is that the cuts might be weaker, since they are valid for all integer solutions for all knapsack constraint instead of their intersection. An alternative would be to consider optimization oracles for the complete set of knapsack constraints as done by Gu . However, then either lifting becomes more computationally demanding or one cannot use lifting.

### The Linear Minimization Oracle

The process begins with a solution \(x^{*}\) of the LP relaxation of the MKP. We create a reduced knapsack problem of dimension \(k_{+},k n\) by removing variables of each knapsack that have integral values (0/1) in the LP relaxation. The oracles now solve the knapsack problems (KP) for each constraint of the form \(\,\{ c,x: w,x C,\ x\{0,1\}^{n}\}\), with \(c^{k}\), \(w_{+}^{k}\), \(C_{+}\). In practice, the dimension \(k\) is rather small (in our test sets, see Section 5, we observe an average \(k\) value of 9.6 with a maximal size of 26), allowing for efficient solution approaches. In our implementation, we use a LMO based on _dynamic programming_. We note that we also apply the preprocessing improvements described by Vasilyev et al. , before we run the oracle on the reduced problem.

Dynamic programming, as presented by Bellman in 1957 , was one of the earliest exact algorithms for solving KPs. Toth  presents additional improvements to the algorithm. More recently, Boyer et al. present massively-parallel implementations running on GPUs . The space and time complexity of the dynamic programming algorithm for KP is \((kC)\), where \(k\) is the number of items and \(C\) is the knapsack capacity. For this work, we reuse the single-threaded, CPU-based implementation of dynamic programming available in the open-source solver SCIP . As we rely on existing implementations, we refer the interested reader to the above references for more details on this algorithm.

### The Lifting Routine

Lifting knapsack constraints has been extensively studied in literature, see  for a short survey with comprehensive references. Therefore, we only briefly summarize the implemented methods here and refer the interested reader to  and references therein for more details.

Let \(\{x\{0,1\}^{n}:_{j=1}^{n}a_{j}x_{j} a_{0}\}\) be one of the original knapsack constraints (corresponding to a single row in \(Ax b\) in (MKP)). Define \([n]\{1,,n\}\), \(F_{0}\{j[n]:x_{j}^{*}=0\}\), and \(F_{1}\{j[n]:x_{j}^{*}=1\}\). Then \(S[n](F_{0} F_{1})\) are the variable indices in the reduced knapsack. The lifting procedure then lifts a given inequality \(_{j S}_{j}x_{j}_{0}\) valid for the reduced knapsack polytope \(\{x\{0,1\}^{S}:_{j S}a_{j}x_{j} a_{0}-_{j F_{1}}a_{j}\}\) to a valid inequality for the original knapsack by computing new coefficients \(_{j}\), \(j F_{0} F_{1}\):

\[_{j S}_{j}x_{j}+_{j F_{1}}_{j}x_{j}+_{j F_{0} }_{j}x_{j}_{0}+_{j F_{1}}_{j}.\] (2)

We implemented algorithms known as _sequential up-lifting_ and _sequential down-lifting_, respectively. The implementation is based on dynamic programming as described by Vasilyev et al. .

## 5 Computational Experiments

We implemented the described methods in C/C++, using a developer version of SCIP 8.0.4 (github 3dbcb38) and CPLEX 12.10 as LP-solver. All tests were performed on a Linux cluster with 3.5 GHz Intel Xeon E5-1620 Quad-Core CPUs, having 32 GB main memory and 10 MB cache. All computations were run single-threaded and with a time limit of one hour. To concentrate on the improvement of local cuts on the dual bound, we initialize all runs with the optimal value. We used \(=1 10^{-9}\) in Algorithm 1.

To demonstrate the advantage of using local cuts with the Frank-Wolfe approach, we run our implementation on the generalized assignment instances from the OR-Library available at http://people.brunel.ac.uk/~mastjjb/jeb/orlib/gapinfo.html. These instances have also been used by Avella et al. .

The results are presented in Table 1. Here, "default" are the default, factory settings of SCIP. The other settings are lcX-nc-Y, where \(X=0\) means that we only separate local cuts in the root node and \(X=1\) means that we separate local cuts in the whole tree; \(Y\) refers to whether we perform down lifting (\(Y=\)) or up- and down lifting (\(Y=\)). Note that for these settings, where local cuts are enabled, we turn the generation of all other cuts off, because this (somewhat surprisingly) showed better performance. The CPU time in seconds ("time") and separation time ("sep. time") as well as number of nodes ("#nodes") are given as shifted geometric means3. The numbers of generated cuts ("#cuts") are arithmetic means. Note that the iteration limit for the Frank-Wolfe algorithm is \(10\,000\) in the root node and \(1000\) in the subtree. We also reduce the effect of cut filtering allowing for more cuts to enter the main LP. Moreover, we initialize the runs with the best know solution values as in .

The results show that the best version is lc1-nc-lifting, i.e., it helps to separate local cuts in every node and perform up- and down lifting. This version is roughly 31% faster than the default settings on the instances solved to optimality. Using only down lifting performs badly. In any case, on these

  variant & \# solved & time & sep. time & \#cuts \\ default & 29 & 98.2 & – & – \\ lc-nc-downlift & 21 & 411.7 & 54.0 & 10858.6 \\ lc-nc-lifting & 26 & 113.7 & 9.8 & 4933.6 \\ lc1-nc-lifting & 29 & 86.8 & 31.8 & 160244.4 \\  

Table 1: Statistics for a branch-and-cut run with separation of local cuts for 45 generalized assignment problem instances (left) and 21 instances that were solved to optimization by all variants (right).

instances, using our local cuts method is a big advantage. Additional results are given in the appendix. In addition, we also ran an experiment in which we applied complemented mixed-integer rounding (CMIR) on the produced cut, which turned out to not be helpful and is therefore not reported in detail.

Some additional observations over all 45 instances in the test set are as follows: Variant lc1-nc-lifting called local cuts separation \(16\,870.6\) times on average. The total time for Frank-Wolfe separation is about one third of the total time. The time spent in the oracle is \(17.3\) seconds on average compared to a total of \(87.9\) seconds for the complete Frank-Wolfe algorithm. On average \(69\,968.8\) calls ended running into the iteration limit, \(81.2\) detected optimality with a zero gradient, \(8652.9\) stopped because the primal gap is small enough, and \(143\,155.9\) stopped because of the termination criterion of Section 3.1.1. This demonstrates the effect of this criterion.

## 6 Conclusion and Future Work

In this paper, we presented a novel method to learn local cuts without relying on solutions of LPs in the process. To show the effectiveness of our approach, we selected the multidimensional knapsack problem as a case study and presented computational results to support our claims.

Solving LPs has proved to be notoriously hard to parallelize, with only minor performance improvements reported in literature to date [40; 45]. Thus, existing methods for deriving local cuts, which rely on solving LPs, typically run single-threaded, on CPUs. Our approach is quite fast, as demonstrated in the computational experiments for our target problem class, but also paves the way for exploring highly parallel implementations on heterogeneous hardware and compute accelerators. This is made possible by eliminating the dependence on LPs and instead relying on the Frank-Wolfe algorithm. One such option we would like to explore in the future is to derive a _vectorized_ version of our Frank-Wolfe algorithm that could work on multiple separation problems at the same time, increasing the computational density of the operations performed and availing of massively parallel compute accelerators like _GPUs_ in the process.

The presented method is generic and can be applied to any (M)IP. We have chosen one important problem class in this paper to demonstrate the method. A natural extension of this work would be to consider other important problem classes and evaluate the benefits of using our method on those problems - especially those with beneficial properties as outlined in Section 3.2.