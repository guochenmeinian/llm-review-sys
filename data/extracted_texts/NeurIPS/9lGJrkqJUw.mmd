# Score-based 3D molecule generation with neural fields

Matthieu Kirchmeyer, Pedro O. Pinheiro, Saeed Saremi

Prescient Design, Genentech

Equal contribution. Correspondence to kirchmeyer.matthieu@gene.com, oliveira_pinheiro.pedro@gene.com, saremi.saeed@gene.com

###### Abstract

We introduce a new representation for 3D molecules based on their continuous atomic density fields. Using this representation, we propose a new model based on walk-jump sampling  for unconditional 3D molecule generation in the continuous space using neural fields. Our model, FuncMol, encodes molecular fields into latent codes using a conditional neural field, samples noisy codes from a Gaussian-smoothed distribution with Langevin MCMC (walk), denoises these samples in a single step (jump), and finally decodes them into molecular fields. FuncMol performs all-atom generation of 3D molecules without assumptions on the molecular structure and scales well with the size of molecules, unlike most approaches. Our method achieves competitive results on drug-like molecules and easily scales to macro-cyclic peptides, with at least one order of magnitude faster sampling.1

## 1 Introduction

Generative modeling of 3D molecular structures, if deployed successfully, can help on many problems in material and life sciences. Recently, state-of-the-art image and text generative models were adapted to 3D molecule generation, achieving some degree of success . However, unlike other domains where the data modality is defined by the representation itself (e.g., a digital image _is_ a tensor of pixels), there are multiple ways to represent a molecule. Therefore, an important problem to consider when modeling 3D molecules is: _what constitutes a good representation for molecules?_

Recent methods for 3D molecule generation usually represent molecules as point clouds of atoms  or discrete grids of atomic densities , which we will refer to as voxel grids. Point clouds are processed by graph neural networks (GNNs), usually based on equivariant architectures . GNNs are known to be less expressive than other architectures due to the message passing formalism  and often scale quadratically with the number of atoms. On the other hand, voxel grids are compatible with more expressive models (e.g., convnets and transformers) but computation and memory scales cubically with the volume occupied by the molecules. These limitations in expressivity and scalability hinder the scope of application of these models.

In this work, we propose a new representation for molecules that overcomes those limitations. Inspired by the 3D computer vision community , we represent _molecules as fields encoding atomic occupancy_, i.e., continuous functions that map 3D coordinates to atomic densities. Arguably this representation is more natural for molecules than for visual data: while visual data is obtained via discrete measurements, molecular fields are continuous by nature. We handle these fields as such, by parameterizing the molecular occupancy field with a neural network, shared among all molecules, and modulation codes, specific to each molecule. Fields that are parametrized by neural networks are referred to as neural fields, implicit neural representations (INR) or coordinate-based neural networks. The former models common molecular structures (e.g., bonds, angles, valencies, symmetries) while the later encodes variations that make each molecule unique. Given a modulation code, we decode themolecular field by predicting the occupancy of each atom at given 3D coordinates (see Figure 1(a)). This decodes the molecules into explicit representations (such as discrete grids at arbitrary resolution or a.sdf format file), useful for downstream tasks.

We perform generative modeling in the continuous function space simply by sampling new modulation codes. Our proposed approach, _FuncMol_, leverages a modulation code denoiser to sample molecules following the (score-based) walk-jump sampling (WJS) approach . WJS enjoys many properties such as fast-mixing, simplicity for training and fast sampling speed. Sampling is composed of three steps: (i) _(walk)_ sample noisy modulation codes with a Langevin Markov chain Monte Carlo (MCMC), (ii) _(jump)_ estimate the "clean" modulation codes, and (iii) _(decode)_ convert the estimated codes into a molecule. Figure 1(b) illustrates a WJS chain, with samples generated by our model trained on a macrocyclic peptides dataset .

The neural molecular field representation has many advantages over prior representations: (i) it represents complex high-dimensional data in a relatively low-dimensional compact space, (ii) it is scalable (w.r.t. the number of points, size of molecules and resolution) and has low memory footprint, (iii) it does not make any assumptions on molecular structure or geometry, (iv) it can represent molecular structures at arbitrary resolutions and for a free-form discretization, (v) it is compatible with expressive machine learning architectures, and (vi) it is domain-agnostic and can be used for a variety of molecular design problems that can be expressed over fields, e.g., atomic densities, surfaces, pharmacophores, molecular orbitals, electron densities etc.

In summary, our contributions are as follows. We introduce a new way to represent molecular structures with neural fields. These representations are low-dimensional, compact, scalable and do not make any assumptions on the molecular structure. We then propose FuncMol, a score-based model for 3D molecule generation that leverages these representations. We show that FuncMol performs competitively against representative baselines on the drug-like molecules dataset GEOM-drugs , based on a wide set of standard and new metrics that we introduce to better measure the generation quality. These results were achieved with one order magnitude faster sampling time.2 Finally, we illustrate FuncMol's ability to scale to larger 3D molecules by training it on CREMP , a recent macro-cyclic peptide dataset, to which our baselines are currently unable to scale.

## 2 Related work

Neural fields.Neural fields, also referred to as implicit neural representations (INRs), are coordinate-based neural networks that map coordinates (e.g., pixels on an image or coordinates in 3D Euclidean space) to features (e.g., RGB values or atomic occupancies). The idea of representing data points implicitly as neural networks dates back to the work of . Recently, these representations have been successfully applied to model continuous signals, e.g., 2D images [15; 16; 17], 3D shapes [18; 19; 20; 21], 3D scenes [22; 23], videos [24; 25], physics [26; 27], due to their appealing properties. Recently, two concurrent seminal work lead to a fast progress of neural fields by overcoming the spectral bias of coordinate-based neural networks . Sitzmann _et al._ propose SIREN, a neural network that uses periodic activation functions, while Tancik _et al._ considers a posi

Figure 1: (a) a conditional neural field encodes a molecular field \(v\) into a low dimensional latent code \(z\). (b) using a learned score function \(g_{}\), FuncMol performs sampling in latent space via Langevin MCMC. These codes are decoded back into molecules.

tional encoding based on Fourier features. Built on top of those architectures, multiplicative filter networks (MFNs)  represent fields as a simple linear combination over an exponential number of basis functions (e.g. Fourier or Gabor basis). Due to their simplicity and strong performance, we use MFNs to model the atomic occupancy fields.

Generative models of fields.Generative models for neural fields were first applied in 3D computer vision problems. Mescheder _et al._ learn the distribution of shape occupancy fields with VAEs , while [18; 33] achieves similar objectives using GANs . Diffusion models  have also been applied to learn the distribution of neural fields [36; 37; 38; 39]. Some work [37; 40] parameterize the neural field with the vector of all the corresponding weights. However, when the signal is complex and the neural fields have large number of parameters (e.g., in the order of millions), it is preferable to parameterize the field with a latent code with much lower dimension [36; 41; 42; 43]. Dupont _et al._ fit the whole dataset with a shared coordinate-based network and learn a latent modulation code for each field with gradient-based meta learning . Similarly to them, we parameterize neural fields with latent modulation codes. However, instead of applying meta learning, we learn the latent codes through stochastic optimization, either following the "auto-encoding"  or the "auto-decoding"  framework.

3D molecule generation.Most 3D molecule generation approaches represent atoms as points (with coordinates and atom types) and molecules as a set of points. For example, [45; 46; 47] propose autoregressive approaches to sample atoms, while [48; 49] use normalizing flows . Hoogeboom _et al._ propose EDM, a diffusion model  applied to point cloud of atoms with E(3) equivariance . Many follow-up works extend EDM [51; 52; 53]. For example, [54; 55; 56] improve its performance by leveraging extra information during training (such as molecular graph and formal charges). This contribution is orthogonal to ours and can potentially be incorporated into our generative model. Other approaches [57; 58] map atomic densities on discrete 3D regular grids and leverage computer vision techniques for generation. Recently, VoxMol  (and its latent version ), a score-based generative model based on walk-jump sampling , shows that voxel-based representations can achieve state-of-the-art results on 3D drug-like molecule generation. However, these methods scale cubically with the volume occupied by molecules, which limits its scope of application. Neural fields are the continuous generalization of discrete 3D grid representations: they achieve good performance on 3D molecule generation and are more efficient in terms of memory and computation.

Conditional molecule generation.Voxels and point-clouds have also been used for conditional 3D molecule generation, usually by building upon an unconditional model. The authors in  condition generation on 3D pharmacophores features, [60; 61; 62; 63] generate ligands conditioned on protein pockets,  generate molecules conditioned on fragments and [65; 66] generate 3D conformations conditioned on molecular graphs. We are aware of only one other work that uses field-based representation for molecules . There are several differences between our works: they use different data representation, neural network architecture and noise model. While they consider the problem of generating molecule conformations given a molecular graph, we handle the more general problem of unconditional 3D molecule generation (without access to a molecular graph). Our model can easily be adapted to conformer generation by conditioning the generative model to the molecular graph. Moreover, our approach can also be conditioned to tasks where we do not have access to molecular graphs, such as structure-based drug design or electron density generation.

## 3 Neural atomic occupancy fields

We now describe how we represent molecules as continuous occupancy fields, how we approximate them with neural fields and how we decode the neural fields to retrieve molecular conformations. We finish the section by providing some useful properties of our neural field representations.

### Molecules as continuous occupancy fields

We represent atoms as continuous Gaussian-like shapes in 3D space, centered around their atomic coordinates. Molecules are defined as fields mapping every point in the 3D space to the atomic densities of each atom type, \(v:^{3}^{n}\), where \(n\) is the number of atom types in the dataset \(\). We follow previous work [68; 69; 70], and compute the occupancy field \(v_{a}\) for each atom type \(a\) by integrating the occupancy generated by all atoms of this type as follows:

\[ x^{3},\,v_{a}(x)=1-_{i=1}^{n_{a}}1- -}\|}{.93r}^{2},\] (1)

where \(a_{i}\) is the \(i^{}\) atom of type \(a\), for a total of \(n_{a}\) atoms. We set the atoms' radius to be \(r=.5\)A for all atom types. Molecular fields are smooth functions taking values between 0 (far away from all atoms) and 1 (at the center of atoms).

### Molecular neural fields

Each molecule in the dataset is mapped to a modulation code \(z^{d}\) and we parameterize the molecular occupancy \(v\) with a conditional neural field \(f_{}:^{3}^{d}^{n}\). Our objective is to learn the parameters \(\) and the modulation code \(z\) such that for any molecular field \(v\) and coordinate \(x^{3}\), \(f_{}(x,z) v(x)\). We approximate the molecular fields with a linear combination of an exponential large number of parameterized basis functions, such that amplitudes are modulated by the individual codes \(z\). This parametrization is achieved by modeling the neural field with multiplicative filter networks (MFN) , a type of coordinate-based network that provides an elegant way to perform this linear combination under some assumptions on the basis functions. We introduce the parameters associated with these functions in Equation (4).

Our conditional MFN is a network with \(L\) multiplicative blocks, as illustrated on Figure 2(a). We implement conditioning of its parameters with FiLM . Each multiplicative block is composed of a fully-connected layer, a FiLM modulation layer and an elementwise product with a basis, as illustrated on Figure 2(b). The neural field can be expressed by the following recursive expression:

\[h^{(0)}(x) =s_{^{(0)}}(x),\] \[h^{(l)}(x) =^{(l-1)}W_{f}^{(l-1)}h^{(l-1)}(x) +b^{(l-1)}+^{(l-1)} s_{^{(l)}}(x),\,\,\,l(1,L-1),\] \[f_{}(x,z)  h^{(L)}(x)=W_{f}^{(L-1)}h^{(L-1)}(x)+b^{(L-1)},\]

where \(s_{^{(l)}}\) is a spatial basis function parameterized by \(^{(l)}\), \(\) denotes the Hadamard product and

\[^{(l-1)}=W_{}^{(l-1)}z,^{(l-1)}=W_{}^{(l-1)}z,\]

are the bias and scale modulation terms. We propose two approaches to learn the neural field's parameters \(=\{W_{f}^{(l)},b^{(l)},^{(l)},W_{}^{(l)},W_{}^{(l)}\}\) and the codes \(z\) (one per each molecule in \(\)).

Auto-decoding.In this setting, introduced by , we initialize each code \(z\) randomly and directly learn them (together with the parameters of the neural field) with backpropagation. This is achieved by solving the following optimization problem:

\[*{arg\,min}_{,\{z_{v}\}_{v}}\,_{v }\,\|f_{}(x,z_{v})-v(x)\|_{2}^{2}\,x,\] (2)

where the integral is approximated by sampling finite sets of points \(^{3}\). While auto-decoding was usually applied in settings with relatively few samples, we were able to scale the training to large datasets of one million samples (see Appendix B). See Algorithm 1 on Appendix B for more details.

Figure 2: Conditional neural field \(f_{}\) using the multiplicative filter network architecture. (a) A latent code \(z\) and some coordinates \(x\) are given as input to the model that outputs the occupancy field at that location for the corresponding molecule, \(f_{}(x,z)\). (b) The code and coordinates are processed via FiLM layers and Hadamard products. We denote the overall operation at layer \(l\) as \(H^{(l)}\).

Auto-encoding.This approach, introduced by  and illustrated in Appendix B Figure 4, generates the modulation code via an encoder \(_{}\), parameterized by \(\) and decodes the neural field back. In this work, \(_{}\) is a (trainable) 3D convolutional network encoder that takes (low-resolution) voxel grids \(\) as inputs. This approach is flexible and compatible with other encoder architectures and molecule representations (e.g., GNN/point clouds). The parameters of the encoder and the neural field are learned with the following objective:

\[*{arg\,min}_{,}\;_{v}\;\|f_{}(x,_{}())-v(x)\|_{2}^{2}\;x.\] (3)

Once training is done, we generate the code with the trained encoder. See Algorithm 2 on Appendix B for more details. Instead of learning the codes individually, this approach learns an encoder, which allows to leverage data augmentation more efficiently. As a result it helps learn a more structured latent space. These benefits are reflected empirically in our experiments.

### From codes to atomic coordinates

By leveraging the modulation codes \(z\) and the neural field \(f_{}\), we have access to the (learned) continuous occupancy field, \(f_{}(,z)\). However, in many useful applications in chemistry and biology, we are more interested in the 3D conformation of molecules. Next, we describe how we can extract the molecular conformation from a learned (or generated, as we will see next) modulation code. This is the decoding step outlined in the introduction.

We start by identifying all atoms in the field, their approximate locations and their type. To this end, we render a discretized voxel grid from the molecular field using a uniform discretization of space and the neural field \(f_{}(,z)\). We then apply a _peak finding_ algorithm to infer the number of atoms in the molecule on each channel of the grid (each representing a separate atom type) and their (discretized) coordinates. Finally, we introduce a new continuous refinement to find the local maximum of the neural field. For each identified atoms \(a\), we refine its coordinates around the neighborhood of the coordinates found with the peak detector \(x_{a}^{0}\):

\[x_{a}=*{arg\,max}_{x^{3}:\|x-x_{a}^{0}\| r}[f_{ }(x,z)]_{a},\]

where \([f_{}(x,z)]_{a}\) denotes the field restricted to the channel corresponding to the atom type. This continuous refinement finds atomic coordinates that lie beyond the initial coarse uniform discretization. In practice, we batch the refinement process across molecules and use L-BFGS. We demonstrate in Appendix E.2 its efficiency compared to prior non-continuous refinement approaches from [72; 5].

### Molecular neural fields properties

The proposed conditional neural field enjoys many properties that make it a natural choice for handling large 3D molecules represented as continuous fields.

Flexibility w.r.t. basis.Conditioning MFNs gives the flexibility to choose any type of spatial basis that satisfies a multiplicative-sum property (see the definition in ). In our preliminary experiments, we observed that setting the spatial basis to Gabor filters performed better than Fourier filters as they account for the sparse nature of occupancy fields. For each layer \(l\), we consider the following Gabor parameterization, also used in :

\[s_{^{(l)}}(x)=-}{2}\|x-^{(l)}\|_{2}^{2} ((^{(l)}x),(^{(l)}x)),\] (4)

where \(^{(l)}\) is the mean of the Gabor filter, \(^{(l)}\) is the scale, \(^{(l)}\) is the frequency and \((,)\) refers to the concatenation operator. Equation (4) combines both real and imaginary parts of the complex Gabor filter. This allows to remove phase parameters and reduce the overall parameter count of MFNs . Other choices of basis are also possible and are left for future work.

Parameter efficiency.Our overall conditional MFN formulation is parameter efficient and shares parameters across molecules and channels (i.e. atom types). As , we excluded the basis functions parameters \(\) from FiLM to further decrease the parameter count.

Memory efficiency.Our conditional neural field can be trained on any free-form discretization of the input field. Occupancy values are computed on the fly. This allowed to train FuncMol with large batch size even on large 3D molecules. We found that training the neural field by up-sampling points close to the atoms' center improved training time as further detailed in Appendix B. Alternative approaches like VoxMol  cannot be trained efficiently in this setting: for reference, on the macro-cyclic peptide generation task of Section 5.4, on 4 A100 GPUs VoxMol's training cost per epoch was 10 hours while our neural field's training cost was less than 12 minutes.

Reconstruction quality and robustness to noise.Finally our neural field reconstructs accurately the input data as demonstrated in Appendix E.1. Moreover, operating on these latent codes makes our model extremely robust to noise in code space. We demonstrate this property in Appendix E.3 by reporting the sampling metrics when perturbing the codes \(z\) by a Gaussian noise.

Sampling efficiency.We use the latent codes for generative modeling as explained in Section 4. Most sampling operations are done on a small dimensional latent space, while decoding into a full molecular field is done only after sampling. As we show in Section 5, our approach (which involves sampling latent code followed decoding them into molecules) achieves at least one order magnitude faster molecule sampling time than previous methods.

## 4 Score-based generative modeling

We use our latent modulation representations for a downstream generative modeling task. Section 4.1 describes the neural empirical Bayes (NEB) formalism used in our method and Section 4.2 explains how we perform sampling.

### Neural empirical Bayes

Let \(p(z)\) be the distribution of codes and \(p(v)\) be the (unknown) distribution of molecular fields, defined more formally as the pushforward of \(p(z)\) via the mapping \(z f_{}(,z)\). NEB estimates the score function of a smoothed density of the codes \(p(y)\), \(g_{}(y) p(y)\). Indeed sampling from a smoothed density \(p(y)\) benefits from faster mixing than on the original density \(p(z)\). This smoothed distribution is defined by transforming the random variable \(Z\) with an additive isotropic Gaussian noise with a known noise level \(\), \(Y=Z+N\), where \(N(0,^{2}I_{d})\). The noise level \(\) plays a key role, trading-off simplicity of the denoising objective and the sampling quality.

NEB is based on an empirical Bayes view of (denoising) score-based models that relates the estimator of clean data (denoiser) and the score function of the smoothed density at a fixed noise level . The denoiser is taken to be the least-square estimator of \(Z\) given \(Y=y\) which is the Bayes estimator, i.e. \((y)=[Z|Y=y]\). Under Gaussian noise, denoiser and smoothed score function are related by the Tweedie-Miyasawa formula:

\[(y)=y+^{2} p(y).\] (5)

The denoiser is parameterized by a neural network and learned by minimizing the following objective:

\[()=_{z p(z),(0, ^{2}I_{d})}z-_{}(z+)_{2}^{2}.\] (6)

The score function is recovered from a learned denoiser via Equation (5) and is used for sampling smoothed codes (see Section 4.2). In practice, we optimize the empirical loss based on the latent codes inferred from a set of molecular fields \(\). See pseudo-code in Appendix B, Algorithm 3.

### Walk-jump sampling

We use the score function \(g_{}\) to sample codes using the _walk-jump sampling_ (WJS) scheme . This approach samples molecules from \(p(z)\) using the learned score function of noisy data instead of clean data. It consists of two main steps: walking and jumping as detailed in Appendix B, Algorithm 4. Figure 1(b) illustrates these two main steps in a WJS chain: walking consists in generating noisy codes while jumping consists in generating clean codes \(z\).

_(initialization)_ To improve mixing, as , we initialize the chains by adding uniform noise to Gaussian noise (with the same \(\) used when training the denoiser). In practice we sample the uniform noise over the range of code values, \(_{d}(_{z_{z},i\{1 d\}}z_{i},_{z _{z},i\{1 d\}}z_{i})\), where \(_{z}\) is the training dataset of codes, arriving at \(y_{0}=+\), \((0,^{2}I_{d})\).

_(walk)_ Noisy codes are sampled from \(p(y)\) with Langevin MCMC algorithms that discretize the underdamped Langevin diffusion  starting from \(y_{0}\) and \(u_{0}=0\):

\[u_{t}=- u_{t}t\ +\ g_{}(y_{t})t\ +\ \ B_{t},y_{t}=u_{t} t\,\] (7)

where \(B_{t}\) is the standard Brownian motion in \(^{d}\) and \(\) is the friction (the "mass" is set to 1). We discretize this SDE using the ABOBA scheme from Sachs _et al._, given a discretization step \(\) and a fixed number of walk steps \(K\). We analyze the impact of \(K\) in Appendix E.4.

_(jump)_ At a given time step \(K\), clean samples are estimated by denoising the smooth code, i.e., \(z_{K}=_{}(y_{K})\). These codes are then used to obtain the atomic coordinates as detailed in Section 3.3.

## 5 Experiments

We now evaluate our model for unconditional generation. We start with a description of our experimental setup (Section 5.1), then present our results on two popular small molecule datasets (Sections 5.2 and 5.3) and a recent macro-cyclic peptide dataset (Section 5.4).

### Experimental setup

Datasets.We evaluate FuncMol on three datasets: _QM9_, _GEOM-drugs_ and _CREMP_. QM9 contains an enumeration of all possible molecules up to 9 heavy atoms (29 including hydrogens) satisfying some constraints . GEOM-drugs contains multiple conformations for 430K drug-sized molecules (computed with semi-empirical density functional theory), with an average of 44 heavy atoms per molecule. CREMP is a recent dataset that contains multiple conformations of macrocyclic peptides 4-6 residue long, with an average of 74 heavy atoms per molecule. We model hydrogen explicitly and consider 5 chemical elements for QM9 (C, H, O, N, F), 6 for CREMP (C, H, O, N, F, S) and 8 for GEOM-drugs (C, H, O, N, F, S, Cl and Br), ignoring the P, I and B elements that occur extremely rarely. We use a split of 100K/20K/13K molecules for QM9, 1.1M/146K/146K on GEOM-drugs and 409K/10K/9K on CREMP for train, validation and test, respectively. We use the same pre-processing and splits in  for QM9 and GEOM-drugs and in  for CREMP.

Implementation details.Our main model, _FuncMol_, follows the auto-encoding approach described in Section 3.2. The codes \(z\) are computed with an encoder that takes as input a low-resolution voxelized representation of the molecular field with grid dimension of 16\(\)16\(\)16. The encoder is a 3D CNN containing 4 residual blocks, where each block contains 3 convolutional layers followed by BatchNorm, ReLU and pooling (max pooling on the first three blocks and average pooling on the last one) layers. We consider modulation codes with dimension 1024 on QM9 and 2048 on GEOM-drugs and CREMP. We use the same neural field network for all datasets: a conditional MFN with Gabor filters and 6 FiLM-modulated layers, where each fully-connected layer has 2048 hidden units. We augment the training set by applying random rotations on the three Euler angles. The weights of the latent code encoder and neural field decoder are trained jointly.

We also show results for the auto-decoding based model, _FuncMol\({}_{}\)_. In this setting, we initialize the codes randomly and optimize them together with the neural field weights. This approach is less fit for performing large amounts of augmentation as it solves a costly per-sample optimization problem; thus we did not apply data augmentation. As a consequence, we observed that this model is more prone to memorization than the auto-encoding approach (e.g., on GEOM-drugs, around 33% of the generated molecules are copies from the training set).

We normalize the codes to have zero mean and unit variance. We choose a noise level in normalized space of \(=1.2\) for GEOM-drugs and CREMP, \(=2.0\) for QM9. Our code denoiser is a modified version of the denoiser used in : a fully-connected network with 18 residual blocks (each with two linear layers with 6144 hidden units) and skip connections. We remove the bias of all layers and use ReLU activations as in . To limit memorization in \(_{}\), we add dropout (ratio 0.3) between the fully-connected layers in each residual block. For QM9, we consider a smaller network (6 residual blocks and 4096 hidden units). We initialize the MCMC chains with noise and use the following sampling hyperparameters \(=1.0\) and \(=/2\) as in . For evaluation purposes, we generate one sample per chain. We consider 1000 steps for QM9 and GEOM-drugs and 10000 steps for CREMP. See Appendix B for more details on the implementation.

Baselines.We compare FuncMol and FuncMol\({}_{}\) to three state-of-the-art approaches. _EDM_ and _GeoLDM_ are diffusion models operating on point clouds (the latter is a latent-space extension of the former). _VoxMol_ is a voxel-based generative model that uses neural empirical Bayes, similar to our generative approach. All of the methods generate molecules as a set of atom types and their coordinates. EDM and GeoLDM apply diffusion directly to point clouds, while VoxMol and FuncMol rely on an additional (cheap) post-processing step to extract atomic coordinates from voxel grids or modulation codes, respectively. We follow previous work [58; 54; 5; 62; 86], and use standard cheminformatics software (OpenBabel ) to determine the molecule's atomic bonds given their atomic coordinates. The same post-processing is applied to all models for fairness of comparison.

Metrics.We consider several metrics used in previous work  to benchmark unconditional molecule generation for the standard QM9 and GEOM-drugs datasets (for the CREMP metrics, see Section 5.4): _stable mol_ and _stable atom_, the percentage of stable molecules and atoms (as defined in ); _validity_, the percentage of generated molecules that passes RDKit 's sanitization filter; _uniqueness_, the proportion of valid molecules that have different canonical SMILES; _valency_\(W_{1}\), the Wasserstein distance between the distribution of valencies in the generated and test set; _atoms TV_ and _bonds TV_, the total variation between the distribution of atom types and bond types; _bond length_\(W_{1}\) and _bond angle_\(W_{1}\), the Wasserstein distance between the distribution of bond and lengths. We also report the _average sampling time per molecule_. In the case of our method, this time includes the MCMC "walk" steps, the denoising "jump", the rendering, peak detection and bond inference.

To further investigate the quality of molecular conformations and other molecular properties on GEOM-drugs, we consider some additional metrics. These include: _single fragment_, the percentage of molecules that contains only a single fragment; _median strain energy_, the difference between the internal energy of the generated molecule's pose and a relaxed pose of the molecule using RDKit's Universal Force Field , computed over all molecules; _ring size TV_, the total variation between the empirical distribution of ring sizes (i.e. number of heavy atoms in rings) in generated and test sets; _number of atoms/mol TV_, the total variation between the empirical distribution of number of atoms per molecule in generated and test sets (in the case of molecules with multiple fragments, we consider only the largest fragment); _QED, SA and logp_, measure the drug-likeness score , the synthesizability score  and the lipophilic efficiency, respectively (computed with RDKit).

Ablations.In Appendix E we report a series of ablation studies for the neural field and the generative model. Appendix E.1 measures the reconstruction quality of the training molecules. Appendix E.2 illustrates the improvements due to continuous atomic coordinate refinement. Appendix E.3 shows that our field-based decoder is robust to noise, making it an ideal choice for generative modeling. Appendix E.4 ablates the impact of the number of walk steps in the WJS scheme of Section 4.2. Finally, Appendix E.5 ablates the impact of the chosen resolution when sampling codes and decoding them back to molecules. In practice, we observe that 0.25A provides a good trade-off between the sampling time and the quality of the generated molecules.

### Results on QM9

As pointed by previous authors [93; 4], this dataset is not fully suited for unconditional generative models: a model that captures the training distribution will have to generate samples from training set, due to the enumeration. However, many previous work report results on this dataset. Therefore, we also show results for completeness.

Table 1 report the metrics described in Section 5.1. We see that FuncMol slightly improves VoxMol and both models perform worse compared to the equivariant point-cloud based baselines. We note that sampling time of FuncMol is an order of magnitude better than baselines.

### Results on GEOM-drugs

Table 2 reports the same set of metrics as in the previous dataset. FuncMol performs favorably over point cloud diffusion models and is close to VoxMol's performance. In particular, FuncMol and VoxMol generate molecules that are significantly more stable and better capture the distribution of bond angles. Table 3 shows results on additional metrics (described in Section 5.1). We also include

the following plots of Appendix F: Figure 9 shows the cumulative distribution function of strain energies for generated molecules and Figures 10 and 11 show the histograms of the other metrics.

The results are clear: _FuncMol samples better drug-like molecules than point-cloud diffusion models_. In fact, about half the molecules of point cloud methods have multiple fragments, they have an order of magnitude higher median strain energy, the distribution of ring sizes is off and the QED, SA and logp scores are lower. The results of FuncMol are close to VoxMol in most but not all metrics. However, our approach is much more scalable and efficient: _FuncMol generates molecules an order of magnitude faster than previous methods_ (see the last column of Table 2). Appendix H shows some molecules generated by FuncMol on GEOM-drugs.

    & stable & stable & valid & unique & valency & atom & bond & bond & bond & time \\  & mol \(\%_{}\) & atom\(\%_{}\) & \(\%_{}\) & \(\%_{}\) & \(W_{1}\) & \(_{}\) & \(_{}\) & len \(W_{1}\) & ang \(W_{1}\) & s/mol.\(\) \\  _data_ & 98.7 & 99.8 & 98.9 & 99.9 &.001 &.003 &.000 &.000 &.120 & - \\  EDM & 97.9 & 99.8 & 99.0 & 98.5 &.011 &.021 &.002 &.001 &.440 & 0.54 \\ GeoLDM & 97.5 & 99.9 & 100. & 98.0 &.005 &.017 &.003 &.007 &.435 & 0.65 \\ VoxMol & 89.3 & 99.2 & 98.7 & 92.1 &.023 &.029 &.009 &.003 & 1.96 & 0.83 \\  FuncMol\({}_{}\) & 88.6 & 99.2 & 100. & 81.1 &.022 &.066 &.032 &.006 & 1.21 & 0.05 \\ FuncMol & 89.2 & 99.0 & 100. & 92.8 &.021 &.012 &.006 &.005 & 1.56 & 0.05 \\   

Table 1: QM9 results w.r.t. test set for 10000 samples per model. \(\)\(\) indicate that higher/lower numbers are better. The row _data_ are randomly sampled molecules from the validation set. We report 1-sigma error bars over 3 sampling runs.

    & stable & stable & valid & unique & valency & atom & bond & bond & bond & time \\  & mol \(\%_{}\) & atom\(\%_{}\) & \(\%_{}\) & \(W_{1}\) & \(_{}\) & \(_{}\) & len \(W_{1}\) & ang \(W_{1}\) & s/mol.\(\) \\  _data_ & 99.9 & 99.9 & 99.8 & 100.0 &.001 &.001 &.025 &.000 & 0.05 & - \\  EDM & 40.3 & 97.8 & 87.8 & 99.9 &.285 &.212 &.048 &.002 & 6.42 & 9.35 \\ GeoLDM & 57.9 & 98.7 & 100. & 100. &.197 &.099 &.024 &.009 & 2.96 & 8.96 \\ VoxMol & 75.0 & 98.1 & 93.4 & 99.6 &.254 &.033 &.024 &.002 & 0.64 & 7.55 \\  FuncMol\({}_{}\) & 69.7 & 95.3 & 100. & 77.5 &.268 &.035 &.028 &.003 & 2.13 & 0.29 \\ FuncMol & 69.7 & 98.8 & 100. & 95.3 &.245 &.109 &.052 &.003 & (.003) & 2.49 & 0.29 \\  & (\(\)2) & (\(\)0) & (\(\)0) & (\(\)0) & (\(\)1) & (\(\)0) & (\(\)0) & (\(\)0) & (\(\)0) & (\(\)0) & (\(\)0) \\   

Table 2: GEOM-drugs results, standard metrics w.r.t. test set for 10000 samples per model. \(\)\(\) indicate that higher/lower numbers are better. The row _data_ are randomly sampled molecules from the validation set. We report 1-sigma error bars over 3 sampling runs.

    & single & median & ring sz & atms/mol & QED & SA & logp \\  & frag \(\%_{}\) & energy\({}_{}\) & \(_{}\) & \(_{}\) & \(\) & \(\) & \(\) \\  _data_ & 100. & 54.5 &.011 &.000 &.658 &.832 & 2.95 \\  EDM & 42.2 & 951.3 &.976 &.604 &.472 &.514 & 1.11 \\ GeoLDM & 51.6 & 461.5 &.644 &.469 &.497 &.593 & 1.05 \\ VoxMol & 82.6 & 69.2 &.264 &.636 &.659 &.762 & 2.73 \\  FuncMol\({}_{}\) & 80.2 & 96.4 &.324 &.970 &.677 &.788 & 2.87 \\ FuncMol & 70.5 & (\(\)1) & (\(\)1) & (\(\)0) & (\(\)0) & (\(\)0) & (\(\)0) & (\(\)0) & (\(\)0) \\   

Table 3: GEOM-drugs results, additional metrics w.r.t. test set for 10000 samples per model. \(\)\(\) indicate that higher/lower numbers are better. The row _data_ are randomly sampled molecules from the validation set. We report 1-sigma error bars over 3 sampling runs.

### Results on CREMP

To showcase the scalability of FuncMol, we train it on a dataset of larger molecules. We choose the macrocyclic peptides of CREMP, that contains on average 74 atoms, making it challenging to train models using point-clouds. These molecules also pose serious limitations to voxel-based approaches as they require modeling a volume of \(24^{3}\) cubic Angstroms. We tried to train VoxMol on this dataset using the official implementation, but did not succeed: it takes around 10 hours per epoch on 4 A100 GPUs, while FuncMol takes less than 12 minutes per neural field epoch and 15s per denoiser epoch. We use the same code dimension and neural field architecture as in GEOM-drugs, therefore the computational training cost of FuncMol remains unchanged.

Figure 3 shows that FuncMol captures well the underlying distribution of macrocyclic conformations. We show the distribution of bond angles (\(_{1}\), \(_{2}\), \(_{3}\)) and dihedrals (\(\), \(\), \(\)) of both molecules from test set and generated molecules. We also show the KL-divergence between test and generated samples. Approximately 65% of the generated molecules were valid peptides (that is, we could extract a sequence of amino acids from the SMILES strings). The Ramachandran plots  show that FuncMol recovers the main modes of the distribution. We note that the bond angles and dihedrals distributions are learned without having any explicit priors on the structure of these peptides. Appendix H shows some generated macrocylic peptides. Finally, our model takes around 1.5s to generate a molecule. For reference, should VoxMol be trained successfully, it would take over a minute to sample a single molecule (assuming similar sampling parameters as in other datasets). This is a substantial speedup that showcases the potential of FuncMol to scale to even larger molecules.

## 6 Discussion

We introduce a new continuous representation of 3D molecules based on their atomic occupancy field and a score-based generative model operating on this representation. Each molecule is assigned a code that modulates a shared neural field. We demonstrate that we can build an all-atom generative model of 3D molecules, FuncMol, with state-of-the-art sampling time and competitive performance on challenging drug-like datasets. We believe that this model introduces a new paradigm for all-atom 3D modeling of molecules that has many useful properties, namely scalability, expressivity, and flexibility, as it can model various molecular design problems (involving structure, electron densities, etc.) with minor architecture changes. Future research directions include exploring different neural field architectures, adapt the model for conditional generation (e.g., structure conditioning) or model the molecular bonds alongside the atomic coordinates3. Moreover, the scalability of FuncMol can be a potential alternative for all-atom representations of large biomolecules.

Figure 3: Qualitative evaluation on CREMP following . Left: Comparison of the bond angles (\(_{1}\), \(_{2}\), \(_{3}\)) in each residue and dihedral distributions (\(\), \(\), \(\)) for each residue from the reference test set (gray) and the generated samples (blue). KL divergence is calculated as \((\ ||\ )\). Right: Ramachandran plots  (colored by density where darker tones represent high density regions).

AcknowledgementsWe would like to thank the Prescient Design team for helpful discussions and Genentech's HPC team for providing a reliable environment to train and analyze models.