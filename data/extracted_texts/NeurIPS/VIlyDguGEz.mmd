# Learning Where to Edit Vision Transformers

Yunqiao Yang\({}^{1}\)  Long-Kai Huang\({}^{2}\)  Shengzhuang Chen\({}^{1}\)

**Kede Ma\({}^{1}\) Ying Wei\({}^{3}\)**

\({}^{1}\)City University of Hong Kong  \({}^{2}\)Tencent AI Lab  \({}^{3}\)Zhejiang University

{yyayang.cs, szchen9-c}@my.cityu.edu.hk  hlongkai@gmail.com

kede.ma@cityu.edu.hk  ying.wei@zju.edu.cn

Part of the work was done when the author interned at Tencent AI Lab.Corresponding authors.

###### Abstract

Model editing aims to data-efficiently correct predictive errors of large pre-trained models while ensuring generalization to neighboring failures and locality to minimize unintended effects on unrelated examples. While significant progress has been made in editing Transformer-based large language models, effective strategies for editing vision Transformers (ViTs) in computer vision remain largely untapped. In this paper, we take initial steps towards correcting predictive errors of ViTs, particularly those arising from subpopulation shifts. Taking a locate-then-edit approach, we first address the "where-to-edit" challenge by meta-learning a hypernetwork on CutMix-augmented data generated for editing reliability. This trained hypernetwork produces generalizable binary masks that identify a sparse subset of structured model parameters, responsive to real-world failure samples. Afterward, we solve the "how-to-edit" problem by simply fine-tuning the identified parameters using a variant of gradient descent to achieve successful edits. To validate our method, we construct an editing benchmark that introduces subpopulation shifts towards natural underrepresented images and AI-generated images, thereby revealing the limitations of pre-trained ViTs for object recognition. Our approach not only achieves superior performance on the proposed benchmark but also allows for adjustable trade-offs between generalization and locality. Our code is available at https://github.com/hustyyq/Where-to-Edit.

## 1 Introduction

In many scientific and engineering disciplines, computational models serve as approximations of complex real-world phenomena. As a consequence, they are inherently prone to predictive errors, aptly encapsulated by George Box's adage: "_All models are wrong, but some are useful_." Model editing  has emerged as a promising technique to make (large) pre-trained models _more useful_ by enabling targeted updates to model behavior on specific inputs or tasks in a data-efficient manner without pre-training again from scratch. An ideal model editing method should satisfy three major desiderata : 1) _reliability_, ensuring the model behavior is effectively updated for the current sample; 2) _generalization_, so that the changes extend to neighboring samples; and 3) _locality_, meaning the edit should have minimal impact on the model behavior on unrelated samples.

Model editing has allowed many fascinating applications, including error correction, factual knowledge update, bias mitigation, policy compliance, and personalization, though most of them have predominantly been within large language models (LLMs)  in the natural language processing (NLP) community . With the enormous and often inaccessible pre-training datasets and the ever-growing model sizes that make retraining computationally demanding, the need for effectivelyediting computer vision (CV) models is also becoming urgent. Adapting model editing techniques from NLP to CV is non-trivial and presents unique challenges. From the data perspective, NLP deals with one-dimensional, discrete signals that are highly semantic and information-dense, whereas CV requires processing high-dimensional continuous sensor data that is spatially redundant. From the model perspective, lots of model editing methods in NLP are specially designed for LLMs with _unidirectional_ (_i.e._, autoregressive) attention, such as GPT-3  and GPT-4 . In contrast, CV models have primarily been based on convolutional networks [33; 52; 24], with more recent implementations using vision Transformers (ViTs) [11; 35] that otherwise employ _bidirectional_ attention. These differences in data formats and model structures make targeted edits more challenging to implement in CV models, and when such edits are achieved, they often result in suboptimal performance.

In this paper, we take initial steps towards editing pre-trained ViTs for object recognition , aiming to correct predictive errors without the need for costly and time-consuming retraining. Specifically, we take a locate-then-edit approach, which breaks down model editing into two key subproblems: where-to-edit and how-to-edit. Moreover, we prioritize learning where to edit rather than how to edit to facilitate a simpler yet better trade-off between generalization and locality, without needing to store previously trained data.

For the where-to-edit phase, we first narrow the editing scope using a greedy search-based heuristic. Next, inspired by the proven effectiveness of meta-learning  in optimizing training strategies for individual samples, we meta-train a hypernetwork to generate a binary task, indicating which parameters are critical for the editing sample. To address the issue of limited data, the hypernetwork is trained solely using pseudo-samples, each comprising a natural image paired with its CutMix version  (see Fig. 1). The optimization objective is to align the predicted probability distribution of the CutMix sample to that of the original. By controlling the sizes of patches used in CutMix and randomly varying their locations, we simulate distribution shifts in backgrounds, contextual objects, and object attributes, creating opportunities to learn generalizable binary masks that effectively respond to real-world failures. Additionally, we apply a sparsity constraint to the binary masks, acting as an indirect, data-free regularizer to promote locality. Once the where-to-edit problem is solved, the how-to-edit phase becomes straightforward: we simply fine-tune the selected parameters using a variant of gradient descent to apply targeted edits.

To validate our method, we construct an editing benchmark that exposes the weaknesses of pre-trained ViTs by introducing two types of subpopulation shifts. The first is a natural subpopulation shift [45; 50], with underrepresented natural images of certain categories efficiently identified by the maximum discrepancy (MAD) competition . The second is an artificial subpopulation shift, introduced by synthesized images from high-quality text-to-image generative models like Stable Diffusion .

In summary, our key contributions are as follows:

* a first-of-its-kind model editing method for pre-trained ViTs that leverages meta-learning to prioritize the where-to-edit phase;
* an editing benchmark that provides valuable resources for future model editing research in CV;
* an extensive experimental demonstration that our method achieves the best Pareto front between generalization and locality on the proposed benchmark, while offering flexible trade-offs in the how-to-edit phase.

## 2 Related Work

In this section, we provide a brief overview of current model editing methods in NLP and CV.

### Model Editing in NLP

**Memory-based Methods** rely on external mechanisms, such as wrappers  and caches , to store factual updates without modifying the internal model parameters. A common theme in these studies is the use of a gating mechanism to determine whether a test sample falls within the editing scope; if so, the base model behavior is overridden. For instance, SERAC  and GRACE  employ a scope classifier as a form of hard gating, while Murty _et al._ utilized a soft gating function, allowing for smoother integration. More recent approaches like IKE  and MeLLo  alter the input prompts of an LLM for knowledge update, where the gating mechanism is implicitly embedded within the LLM itself. Generally, memory-based methods offer advantages such as non-destructive updates, modularity, and suitability for continual and few-shot learning settings. However, they face scalability issues when handling a large number of edits. Additionally, the editing success heavily depends on the accuracy of the gating mechanism.

**Parameter-based Methods** modify the internal model parameters, which offers a more fine-grained approach to editing. These methods can roughly be categorized into two subgroups: locate-then-edit approaches and hypernetwork-based approaches. Locate-then-edit methods focus on identifying a subset of key parameters for editing. For instance, ROME , MEMIT , and MEMIT\({}_{}\) leverage causal mediation analysis (_i.e._, representation denoising) to locate hidden states (_i.e._, intermediate representations, not model parameters) responsible for knowledge storage. The theory of associative memory  is then applied to transfer the state localization results to model parameters. Recent studies  suggest that knowledge localization may not reliably inform successful edits. Furthermore, the very notion that knowledge can be localized may be inherently flawed, as factual information in LLMs may be encoded in a distributed manner . _Single-step_ integrated gradient across multiple editing samples [8; 60] is another commonly used statistic for localization. Here, we adopt a more principled meta-learning strategy to locate key parameters, using _multi-step_ gradient information that more accurately captures the changes in model behavior.

Hypernetwork-based methods, such as KnowledgeEditor , MEND , and MALMEN , train an external network to directly generate parameter updates for the editing sample, which is represented by either feedforward feature representation  or backward gradient decomposition . Localization techniques can be applied beforehand to restrict the functional space of the hypernetwork. Existing hypernetwork-based methods emphasize the how-to-edit aspect but treat the where-to-edit superficially, and often result in suboptimal performance, especially when adapting to CV applications. In contrast, our method prioritizes learning where to edit, achieving a better balance between generalization and locality.

### Model Editing in CV

Limited research on model editing has been conducted in CV. Bau _et al._ took a locate-then-edit approach to rewrite generative adversarial networks. Santurkar _et al._ adapted this method for editing image classifiers based on convolutional networks by mapping the representation of the new visual concept to that of a previously learned concept. However, this approach requires prior knowledge of the new visual concept, its location within the image, and the specific target concept for correction. In practical applications, such detailed information may not always be available. In contrast, our method relaxes all these assumptions and is one of the first applied to ViTs.

## 3 Learning Where to Edit ViTs

In this section, we first present the preliminaries, followed by a detailed description of the proposed method for learning where to edit ViTs. The system diagram of our method is shown in Fig. 1.

### Preliminaries

Problem FormulationGiven a base computational model \(f(;):\), parameterized by \(\), model editing aims to modify the model behavior for specific inputs \(x\) (or regions of the input space, \(\)) while keeping its overall performance intact. Denote the post-edited model as \(f(;^{(e)})\), where \(^{(e)}\) represents the updated parameter vector3 after editing. Typically, \(f(;^{(e)})\) is evaluated based on three main criteria: reliability, generalization, and locality.

* **Reliability**: For any editing sample \((x,y)\), the edited model \(f(x;^{(e)})=y\).
* **Generalization**: For any neighboring4 sample \((x^{},y^{})(x,y)\), \(f(x^{};^{(e)})=y^{}\), even if \((x^{},y^{})\) is not directly used in the editing process.

* **Locality**: For any sample \((x^{},y^{})(x,y)\), the model behavior should remain unchanged, _i.e._, \(f(x^{};^{(e)})=f(x^{};)\).

An ideal model editing method shall ensure reliable edits while balancing generalization and locality effectively. As initial model editing attempts in CV, we limit our scope to single-example editing.

Vision TransformersA ViT  feature extractor, denoted by \(e(;)\) with parameter vector \(\), consists of a linear embedding layer followed by \(L\) attention blocks. Each block is composed of a multiheaded self-attention (MSA) layer and a feedforward neural network (FFN). The FFN, which underpins most model editing methods, including ours, comprises two fully-connected (FC) layers: \((z)=(zW+b)W^{}+b^{}\). Here, \(W^{N N_{m}}\) and \(W^{}^{N_{m} N}\) are weight matrices, where \(N_{m}\) denotes the intermediate dimension. \(b^{N_{m} 1}\) and \(b^{}^{N 1}\) are bias terms. The activation function \(()\) is the Gaussian error linear unit .

An input image \(x\) is first partitioned into \(M\) non-overlapping, fixed-size patches, each linearly embedded in an \(N\)-dimensional feature space together with a class token [cls], yielding a concatenation of patch embeddings of size \((M+1) N\). These embeddings are processed through the \(L\) attention blocks for feature extraction. A linear classification head, \(h()\), maps the extracted features to a probability distribution over classes in \(\), represented as \(p(y=c|x;)=h_{c}(e(x;))\), where \(c\). For notation simplicity, we omit the parameters in the classification head \(h()\), as they constitute only a small fraction of the total parameters and are generally frozen during model editing.

### Model Editing at Training Time: Where-to-edit

The simplest way of editing a ViT is through vanilla fine-tuning, which involves updating all model parameters. However, modern ViTs have millions to billions of parameters, and fine-tuning on a single sample \((x,y)\) can lead to overfitting, while incurring substantial computation costs. To overcome these, prior research [8; 23] first identifies a subset of key parameters, followed by editing:

\[^{}=+,\] (1)

where \(\) is a binary mask of the same dimension as \(\), \(\) represents the parameter update, and \(\) is the Hadamard product.

Prevailing localization strategies in NLP rely on casual mediation analysis , integrated gradients , or pure heuristic methods , which may not be ideal for ViTs due to differences in data modalities and model architectures. In this work, we follow the locate-the-edit approach, and decompose model editing into two subproblems: where-to-edit (_i.e._, computing \(\)) and how-to-edit (_i.e._, computing \(\)), with a focus on where-to-edit. Drawing inspiration from the demonstrated success of meta-learning [34; 14] in tailoring training strategies for individual samples, we meta-train a hypernetwork to generate the binary mask \(\) for each editing sample.

Meta-learning [34; 14], also known as learning-to-learn, involves training models on a collection of training episodes  to enable effective generalization and adaptation to novel, unseen episodes. In

Figure 1: System diagram of the proposed model editing method.

our context, a training episode corresponds to a single editing example. We employ optimization-based meta-learning approaches [14; 44], framing where-to edit as a bi-level optimization problem. In the inner loop, key parameters, indicated by \(\), are updated for the editing sample by optimizing a reliability loss via gradient-descent over \(T\) iterations. In the outer loop, the hypernetwork \(g(;)\), parameterized by \(\), is refined to generate \(\). Mathematically, we have

\[_{}&(x,y;^{(T )})+\|\|_{0}\\ &=g(x;)\\ &^{(t)}=^{(t-1)}-_{} (x,y;^{(t-1)}),\,t\{1,2,,T\}\\ &^{(t)}=^{(0)}+^{(t)},\,t\{1,2, ,T\},\] (2)

where \((x,y)\) is the editing sample. \(^{(T)}\) is the updated parameter after \(T\) iterations of inner-loop optimization, and \(^{(0)}\) denotes the pre-trained parameters of the base model as initialization. The term \(^{(t)}\) is the parameter update after the \(t\)-th iteration, with \(^{(0)}=0\). The loss function \((x,y;^{(t)})\) measures the reliability of the edit. To encourage sparsity in the binary mask \(\), we add an \(_{0}\)-norm term in the outer-loop objective, which acts as an indirect, data-free regularizer to encourage locality. The scalar \(\) controls the trade-off between the two terms. In our implementation, the hypernetwork takes the last-stage features corresponding to the [cls] token from the ViT feature extractor \(e(;^{(0)})\) as input, _i.e._, \(=g(e(x;^{(0)});)\).

### Optimization Challenges

Despite mathematical elegance, solving the bi-level optimization problem in (2) presents three challenges. First, meta-training the hypernetwork necessitates a sizable of high-quality editing samples, which are expensive and time-consuming to collect in practice. To address this, we generate pseudo-samples using a data augmentation technique known as CutMix . Second, identifying key parameters within the entirety of the ViT presents a vast search space. This combinatorial complexity not only introduces unacceptable computational costs but also makes the localization of key parameters a challenging endeavor [36; 51]. To alleviate this, we shrink the editing scope based on a greedy search-based heuristic. Third, generating a binary mask typically involves a binarization operation in \(g(;)\), which produces zero gradients almost everywhere and is thus ineffective in optimizing. To resolve this, we use a gradient-friendly approximation to binarization.

**Pseudo-sample Generation** We employ CutMix  to generate pseudo-samples for editing. Specifically, given a natural image \(x^{}\), we apply CutMix  to randomly overlay a small patch from another irrelevant image onto \(x^{}\), producing a pseudo-sample \(x\). This patch-based perturbation tends to alter the predicted probability distribution, resulting in \(p(y=c|x;^{(0)}) p(y=c|x^{};^{(0)})\), for \(c\). This motivates us to instantiate the reliability loss \((x,y;^{(t)})\) in Problem (2) as the Kullback-Leibler (KL) divergence  between \(p(y|x^{};^{(0)})\) and \(p(y|x;^{(t)})\):

\[(x,\{p(y|x^{};^{(0)})\};^{(t)} )=_{c}p(y=c|x^{};^{(0)}) (;^{(0)})}{p(y=c|x;^{(t)} )}),\] (3)

where \(\{p(y|x^{};^{(0)})\}\) is treated as the soft ground-truth label.

**Editing Scope Shrinkage** Previous studies [38; 40] have suggested that modifying FFNs within a Transformer is more effective for achieving successful edits [17; 18]. For example, MEND focuses on editing the last three FFNs, while ROME  targets the middle FFNs. Here, we conduct a similar empirical investigation to identify a subset of consecutive FFNs in a ViT, by greedy search for the optimal generalization and locality trade-off. Specifically, we fine-tune ten groups of FFNs (or MSAs) in three consecutive layers  of a pre-trained ViT/B-16, denoted as \(\{13\), \(24\), \(\), \(1012\}\). The editing set comprises \(100\) predictive failures of the ViT, where volleyball is mistaken for basketball (see Fig. 1(a)), identified by the MAD competition  (see more details in Sec. 4.1). The average results across the editing set are shown in Fig. 1(b), where we see that editing MSAs is not conducive to preserving locality. In contrast, editing the \(8\)-th to \(10\)-th FNNs tends to achieve the best trade-off, which are selected as the default layers for subsequent experiments.

To further limit the output space of the hypernetwork, we employ structured tuning  by selecting specific rows/columns of the weight matrices in the FFNs for updating. As suggested in , we select the weights along the intermediate dimension \(N_{m}\), which further reduces the output dimension of the hypernetwork to \(N_{m} 6\) (_i.e._, three FFNs with two FCs each).

**Binarization Approximation** As a special case of quantization in signal processing, binarization can be approximated to enable gradient-based training through three main approaches: straight-through estimation , uniform noise addition , and soft-to-hard annealing . Here, we use a fixed parametric sigmoid function with favorable gradient behavior as the approximation:

\[=(k m),\] (4)

where \(m\) is a continuous map computed by the hypernetwork right before binarization, and \(k\) is a hyperparameter that controls the degree to which the sigmoid curve approximates the desired binarization operation. Empirically, we set \(k=10\). We have also experimented with a soft-to-hard annealing for \(k\), and observed comparable results. After adopting Eq. (4), we substitute \(\) with \(\) and replace the \(_{0}\)-norm with the \(_{1}\)-norm in Problem (2) to facilitate gradient-based optimization.

### Model Editing at Test Time: How-to-edit

At test time, we solve the how-to-edit problem in a manner similar to the inner-loop optimization. The two minor differences lie in the loss function and the binarization operation.

At test time, we are provided with the editing sample \(x\) and its ground-truth label \(y\). Therefore, the KL divergence during training reduces the cross-entropy loss during testing:

\[(x,y;^{(t)})=-_{c}[y=c] (p(y=c|x;^{(t)})).\] (5)

Also, we can directly employ the threshold-based binarization without approximation to obtain

\[_{i}=q(m_{i})=1&m_{i}\\ 0&m_{i}<,\] (6)

where \(i\) is the positional index, and \(\) is a hyperparameter that can be adjusted for different model editing applications. When \(\) is set to zero, all parameters in the selected FFNs are updated with improved reliability. As \(\) increases, fewer parameters are updated, which favors locality.

### Hypernetwork Architecture

Similar to the ViT feature extractor \(e(;^{(0)})\), the hypernetwork \(g(;)\) comprises five attention blocks, an FC layer as the projection head, and a binarization operation. As shown in Fig. 1, we introduce six learnable tokens, each corresponding to an FC layer within the three selected FFNs of the base ViT. These tokens are concatenated with the image features derived from \(e(;^{(0)})\) and serve as input to the hypernetwork to compute the binary mask \(\).

Figure 2: The left subfigure shows representative editing examples, highlighting the predictive errors of the base ViT when predicting volleyball as basketball. The right subfigure depicts the generalization and locality trade-offs when editing different groups of FFNs or MSAs in the base ViT. It is evident that editing the \(8\)-th to \(10\)-th FFNs achieves the optimal Pareto front.

## 4 Editing Benchmark with Subpopulation Shifts

In this section, we establish an editing benchmark that exposes failures of the base ViT in object recognition by introducing subpopulation shifts to underrepresented natural and AI-generated images.

### Natural Image Subset

To build the natural image subset, we first compile a large dataset of unlabeled images, denoted as \(\), from Flickr, by leveraging keywords relevant to the object categories in ImageNet-1k . Next, we employ the MAD competition  to facilitate failure identification of the base ViT to be edited. Under the principle of model falsification as model comparison, MAD chooses to identify images that best distinguish two classifiers, \(f()\) and \(f^{}()\), by maximizing their prediction discrepancies. This can be mathematically formulated as

\[x^{(i)}=*{arg\,max}_{x^{}_{n}}d(f(x^{}),f^{}(x^{})),\] (7)

where \(_{n}=\{x^{(j)}\}_{j=1}^{i-1}\) is the set of \(i-1\) images that have been identified. \(d(,)\) is the multi-hop distance defined over the WordNet  to measure prediction discrepancy at a semantic level. Intuitively, if one classifier is weaker, the identified image set \(_{n}\) is more likely to include its predictive failures, thereby substantially reducing the human effort for failure identification. Moreover, the "ground-truth" labels for these failures can be first suggested by the stronger model and then verified by two of the authors. To leverage this intuition, we pair our base model (_i.e._, a ViT/B-16 pre-trained on ImageNet-1k) with a stronger one (_i.e._, the same ViT/B-16 pre-trained using CLIP  and fine-tuned on ImageNet), which generally exhibits better generalization to unseen data. In total, we collect \(2,354\) MAD-searched natural images, which are partitioned into \(16\) groups, _i.e._, \(_{n}=\{^{(i)}\}_{i=1}^{16}\), based on the predictions by the two models. Each group is named according to the format "prediction of the stronger model"-"prediction of the base model," with the statistics and visual examples given in the Appendix.

### AI-generated Image Subset

Classifiers pre-trained on natural images often struggle to generalize to AI-generated images [56; 59]. To exploit this, we construct an AI-generated image subset containing two groups of images, denoted as \(_{a}=\{^{(i)}\}_{i=17}^{18}\). The \(17\)-th group includes \(860\) images with an art style shift (_i.e._, oil painting) generated by Textural Inversion , while the \(18\)-th group comprises \(1,092\) images with a lighting condition shift (_i.e._, stage light) produced by PUG . Both Textural Inversion and PUG are text-to-image generators, wherein the "ground-truth" label is embedded in the input text prompt and subsequently verified by two of the authors. Additional details of the AI-generated image subset can be found in the Appendix.

Figure 3: Visual examples seen by the base ViT/B-16 during pre-training, contrasted with visual examples in the proposed editing benchmark as predictive errors of the base ViT/B-16.

## 5 Experiments

In this section, we first describe the experimental setups and then present comparison results on the proposed editing benchmark.

### Experiment Setups

Evaluation MetricsFollowing , we evaluate all model editing methods on the single-example editing task and compare their performance using three evaluation metrics. The first is the _success rate_ (SR), which indicates the reliability (_i.e._, accuracy) of the edited model \(f(;^{(e)})\):

\[(f,_{r})=_{r}|}_{(x,y) _{r}}[y=f(x;^{(e)}(x,y))],\] (8)

where \(_{r}=_{n}_{a}\) consists of all MAD-searched and AI-generated images, and we make it explicit the dependence of the updated parameters \(^{(e)}\) on the editing sample \((x,y)\). The second metric is the _generalization rate_ (GR), which assesses the accuracy of the edited model on neighboring samples that fall within the editing scope:

\[(f,)=|(||-1)}_{(x^{ },y^{})}_{(x,y)(x^{ },y^{})}[y=f(x;^{(e)}(x^{},y^{ }))],\] (9)

where \(\) denotes one of the \(18\) groups in the proposed editing benchmark. We further average the GR values across all groups as an overall indicator of generalization. The third metric is the _locality rate_ (LR), which examines whether the edited model maintains its predictions on unrelated samples outside the editing scope:

\[(f,_{r},_{l})=_{r}|| _{l}|}_{(x^{},y^{})_{r}}_{(x,y) _{l}}[y=f(x;^{(e)}(x^{},y^{ }))],\] (10)

where \(_{l}\) includes out-of-scope images. Using the validation set from ImageNet-1k as \(_{l}\) does not adequately examine locality, as the majority are easy samples that lie far from the decision boundary . To more closely examine the adverse effects of model editing, we have carefully curated \(2,071\) images near the decision boundary of the base model from the validation sets of ImageNet-1k , ImageNet-R , and ImageNet-Sketch , whose predictions are more susceptible to change. Our selection criteria rely on the predicted probabilities of the pre-trained ViT/B-16 model as follows: 1) the predicted probability for the true label is the highest, and 2) the difference between the top two predicted probabilities is less than \(0.05\), suggesting a highly ambiguous class. We also employ the GR-LR curve to delineate the generalization and locality trade-off.

Base ModelsFor all model editing methods, we experiment with two ViT backbones, ViT-B/16 and ViT/S-16, both pre-trained on ImageNet-21k and ImageNet-1k [53; 47].

Figure 4: Editing results for ViT/B-16 on the proposed benchmark.

Competing MethodsWe compare our method with several recent model editing approaches as follows. 1) Fine-tuning (FT) updates the \(8\)-th to \(10\)-th FFNs, which have been identified as the most effective layers using greedy search (see Fig. 2). 2) FT-\(_{2}\) incorporates \(_{2}\)-norm regularization during fine-tuning. 3) T-Patcher  adds and tunes a single neuron in the last FFN. 4) KN  and 5) SPT  select key parameters based on integrated gradient information. 6) ROME  is implemented to adjust the second FC layer of the last FFN by solving a constrained least squares problem. 7) LoRA  introduces trainable low-rank matrices to update the queries and values of all MSAs. 8) KE  and 9) MEND  employ hypernetworks to generate parameter updates for the last three FFNs. In line with previous work [40; 39], early stopping is applied when the training loss drops below \(0.01\) or the maximum of \(100\) editing steps is reached. Detailed implementations of the competing methods and additional training configurations are provided in the Appendix.

### Main Results

Fig. 4 shows the GR-LR curves for different editing methods applied to ViT-B/16, averaged across \(18\) groups in the proposed benchmark. We highlight several interesting observations. First, correcting a single predictive error is generally feasible, as evidenced by a nearly \(100\%\) SR for most methods. Second, achieving high levels of generalization and locality simultaneously proves to be a significant challenge. T-Patcher and ROME utilize previously seen data to maintain locality. Nevertheless, T-Patcher, which relies on an editing scope classifier, exhibits noticeable generalization variability across different editing samples. ROME, being specifically designed for language-based GPT , shows limited promise in generalizing to ViTs. LoRA manages to maintain locality because of its low-rank updates but struggles to generalize. Both KE and MEND exhibit low locality on the MAD-searched natural images and poor generalization to the AI-generated images. Third, our method achieves the new state-of-the-art without relying on previously trained data to explicitly enforce locality. Similar conclusions can be drawn for ViT-S/16, shown in the Appendix.

We then evaluate our method across different parameter sparsity levels in the three FFNs from \(\{0.25,0.50,0.75,0.90,0.95\}\), corresponding to \(\{12.4\%,8.25\%,4.13\%,1.65\%,0.83\%\}\) parameters of the entire model, by adjusting \(\) in Eq. (6). The competing methods--FT-\(_{2}\), KN, and SPT--are adjusted to comparable levels of parameter sparsity by tuning their respective hyperparameters. Note that our method reduces to FT when \(=0\). The resulting GR-LR curves are shown in Fig. 4. As expected, increasing the parameter sparsity in KN, SPT, and our method improves locality at the expense of generalization. Notably, our method achieves the best Pareto front among all methods, which we believe arises from our proposed strategy of learning where to edit towards editing success.

### Ablation Studies

Localization EffectivenessTo substantiate that the effectiveness of our method is indeed due to the successful localization of a specific subset of key parameters, rather than merely due to sparsity, we compare the binary masks produced by our hypernetwork to random masks at the same sparsity levels, together with FT-\(_{1}\) and FT-\(_{2}\). As depicted in Fig. 4(a), FT-\(_{1}\) generally surpasses FT-\(_{2}\) at various regularization levels as \(_{1}\)-norm is more effective in zeroing out less important parameters. Applying random masks shows effects akin to FT-\(_{1}\). When the ratio of editing parameters falls below \(1.65\%\), the performance of random masking becomes significantly inferior to our method.

Figure 5: Ablation results of the hypernetwork for ViT/B-16.

Mask SpecificityTo confirm the specificity of the parameters identified by the hypernetwork for different editing samples, we compute the intersection over union (IoU) of the corresponding binary masks at the \(0.95\) sparsity level for samples within and outside the same groups in the natural image subset. Fig. 5(b) illustrates that the identified parameters demonstrate substantial overlaps for images within the same group and much lower overlaps between images from different groups. These findings support that the hypernetwork successfully pinpoints key parameters necessary to correct specific errors while effectively excluding parameters associated with other unrelated samples. This learned mask specificity allows our method to balance effectively between generalization and locality.

More Editing SamplesWe further evaluate our method when multiple editing samples in the same group (_i.e._, with similar failure causes) are available. As a straightforward extension, we compute the average of the continuous masks generated from each sample, followed by binarization using Eq. (6). Fig. 4(b) presents the results of using one, two, and three samples for model editing. Remarkably, the editing performance improves with more editing samples, which can be attributed to more precise parameter localization as a result of the ensemble of masks.

More Ablation StudiesMore ablation studies (_e.g._, the alternative pseudo-sample generation strategy, the sparsity regularization in the outer loop, the gradient step and learning rate in the inner loop, and the number of attention blocks in the hypernetwork) are in the Appendix.

## 6 Conclusion and Discussion

We have introduced a model editing method to correct predictive errors in ViTs. Our method prioritizes where-to-edit over how-to-edit by meta-training a hypernetwork to identify a subset of structured parameters for editing. By applying \(_{1}\)-norm regularization, our method promotes sparsity in the generated mask, thereby indirectly ensuring locality without needing to retrain on previously used data. Comprehensive tests on the proposed editing benchmark confirm that our method effectively corrects predictive errors in ViTs. Moreover, the introduced edits are not only reliable but also generalize well to neighboring samples, while maintaining a high rate of locality.

Our work is among the early endeavors in CV model editing, and it raises several intriguing questions for future research. First, our approach utilizes the CutMix technique  to generate cost-effective pseudo-samples for training, but its effectiveness has only been confirmed empirically. The reasons why the hypernetwork trained on such synthetic data achieves reasonable generalization and the identification of optimal synthetic data generation techniques remain wide open. Second, it would be beneficial to adapt our method to other vision architectures, such as convolutional networks or Swin Transformers , and extend its application to other vision areas like dense prediction, generative modeling, and multimodal LLMs. Third, exploring how to apply our method in a batch-editing setting represents a promising avenue. In such scenarios, the use of a decoupling trick (see more details in the Appendix) may prove essential for effectively reducing computational and memory demands.

Figure 6: Mask specificity results.