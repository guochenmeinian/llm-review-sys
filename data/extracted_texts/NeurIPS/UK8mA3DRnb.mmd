# Simple and Asymmetric Graph Contrastive

Learning without Augmentations

 Teng Xiao\({}^{1}\)\({}^{*}\), Huaisheng Zhu\({}^{1}\)\({}^{*}\), Zhengyu Chen\({}^{2}\), Suhang Wang\({}^{1}\)

\({}^{1}\)The Pennsylvania State University, \({}^{2}\)Zhejiang University,

{tengxiao,hvz5312,szw494}@psu.edu, chenzhenegyu@zju.edu.cn

Equal contribution

###### Abstract

Graph Contrastive Learning (GCL) has shown superior performance in representation learning in graph-structured data. Despite their success, most existing GCL methods rely on prefabricated graph augmentation and homophily assumptions. Thus, they fail to generalize well to heterophilic graphs where connected nodes may have different class labels and dissimilar features. In this paper, we study the problem of conducting contrastive learning on homophilic and heterophilic graphs. We find that we can achieve promising performance simply by considering an asymmetric view of the neighboring nodes. The resulting simple algorithm, Asymmetric Contrastive Learning for Graphs (GraphACL), is easy to implement and does not rely on graph augmentations and homophily assumptions. We provide theoretical and empirical evidence that GraphACL can capture one-hop local neighborhood information and two-hop monophily similarity, which are both important for modeling heterophilic graphs. Experimental results show that the simple GraphACL significantly outperforms state-of-the-art graph contrastive learning and self-supervised learning methods on homophilic and heterophilic graphs. The code of GraphACL is available at https://github.com/tengxiao1/GraphACL.

## 1 Introduction

Contrastive learning has emerged as a promising regime for unsupervised vision representation learning without using annotated labeled data . Recently, graph contrastive learning (GCL) has also been introduced to graph-structured data due to the lack of task-specific node labels . GCL has achieved competitive (or even better) performance on many downstream tasks on graphs compared to its counterparts trained with annotated ground-truth labels .

Generally, existing GCL methods can be categorized into two categories. The first contrastive scheme  reconstructs the local network structure (i.e., observed edges) to align with traditional network-embedding objectives . Specifically, this scheme treats one-hop or random-walk local neighboring nodes of the target node as positive examples and non-neighboring nodes as negative samples. It then employs contrastive loss functions to minimize the representation distance of positive pairs and maximize the distance of negative pairs . The key motivation behind this scheme is the _explicit_ homophily assumption that semantically similar nodes are more likely to be linked than dissimilar ones. Thus, connected nodes should have similar representations in the latent space. However, in heterophilic graphs, connected nodes are not necessarily from the same semantic class , and should not be simply pulled together in the latent space. This scheme empirically faces issues with performance in graphs exhibiting heterophily .

The second graph contrastive scheme involves graph augmentations . Specifically, it constructs two views through stochastic graph augmentation and then learns representations by contrasting these views based on the information maximization principle . A positive nodepair consists of two views resulting from stochastic data augmentation of the same node, while a negative pair might consist of two views of different nodes . This scheme is built based on the idea that augmentations can preserve the semantic nature of samples, i.e. augmented nodes have consistent semantic labels with the same original nodes. However, recent work has shown that graph augmentation methods struggle to achieve good performance on heterophilic graphs  as they still _implicitly_ rely on homophily . Studies have shown that stochastic augmentation primarily captures the common low-frequency information between two views, while neglecting the high-frequency one  (also see Appendix C.4). The latter is known to be more crucial for heterophilic graphs [21; 22]. Given that heterophilic graphs are prevalent across various real-world domains [16; 23], a fundamental and open question naturally arises: _What kind of contrastive learning objectives can learn robust node representations on both homophilic and heterophilic graphs?_

This work is the first to address the aforementioned question without relying on augmentations and homophily assumptions. Instead, we take into account two more generalized insights, as depicted in Figure 1. (i) Even in heterophilic graphs, two nodes of the same semantic class often share a similar one-hop neighborhood context [24; 18]. Thus, capturing this heterophilic one-hop neighborhood context can lead to more discriminative node representations. (ii) While homophily might be minimal or non-existent in heterophilic graphs, another frequently observed phenomenon in real-world graphs is monophily . _Monophily_ describes situations in real-world graphs where the attributes of a node's friends are likely to be similar to the attributes of that node's other friends . Put another way, "monophily" essentially induces similarities between two-hop neighbors. As noted by [25; 26], the two-hop similarities brought about by monophily can persist even in the total absence of any one-hop similarities that might be suggested by homophily.

To support our motivations, we provide statistics of homophily, two-hop monophily ratios, and neighborhood similarities of various graphs in the real-world in Appendix C. As shown in these statistics, homophilic and heterophilic graphs in the real-world exhibit relatively strong neighborhood similarity calculated based on one-hop neighborhoods compared to homophily. In cases where homophily is weak or non-existent, monophily has been shown to still hold in real-world graphs.

In this work, we focus on exploiting the above insights to design new objectives for better node representations on both homophilic and heterophilic graphs. We propose a simple yet effective framework termed as graph asymmetric contrastive learning (GraphACL) for better node representation learning. Essentially, we are faced with the challenge of simultaneously capturing the one-hop neighborhood context and monophily in the contrastive objective. To solve this challenge, we consider each node to play two roles: the node itself (identity representation) and specific "neighbors" of other nodes (context representation), and thus should be treated differently. GraphACL trains the node identity representation by predicting the context representation of one-hop neighbors through an asymmetric predictor. Intuitively, by enforcing identity representations of two-hop neighbors to reconstruct the same context representation of the same central nodes, GraphACL implicitly makes representations of two-hop neighbors similar and captures the one-hop neighborhood context (Figure 2).

**Our primary technical contributions are: (1)** We propose a _simple_, _effective_, and _intuitive_ graph contrastive learning approach which captures one-hop neighborhood context and two-hop monophily similarities in a simple asymmetric learning framework. (2) We theoretically analyze the learning behavior and prove that GraphACL is guaranteed to yield good node representations for both homophilic and heterophilic graphs. (3) Empirically, we corroborate the effectiveness of GraphACL on 15 graph benchmarks. The results demonstrate that GraphACL can significantly outperform previous GCL methods. The surprising effectiveness of GraphACL shows that in the context of GCL, simpler methods have been underexplored in favor of more elaborate algorithmic contributions.

## 2 Related Work

**Graph Contrastive Learning.** Contrastive methods are central to traditional network-embedding methods [27; 13; 14], but have recently been applied in graph self-supervised learning [9; 28; 10].

Figure 1: The graphs of pure homophily and pure heterophily, where color denotes the semantic class. For both graphs, nodes with a similar one-hop neighborhood context have similar semantic classes and two-hop similarities still exist even without the one-hop homophily.

The key motivation behind them is the _explicit_ homophily assumption that connected nodes belong to the same class and, thus, should be treated as positive pairs in contrastive learning. However, real-world graphs do not always obey the homophily assumption , limiting their applicability to heterophilic graphs . Recently, many GCL algorithms with augmentations [2; 3; 4; 5; 6; 29] have been proposed. However,  recently proved that GCL with augmentations attempts to manipulate the encoder to capture low-frequency information instead of the high-frequency part and suffers performance degradation in heterophilic graphs . In contrast, we propose a simple asymmetric contrastive learning framework for graphs without augmentations and homophily assumption.

**Heterophilic Graphs.** There are many heterophilic graphs in the real world that exhibit nonhomophilic properties, such as transaction [30; 31], ecological food  and molecular networks , where the linked nodes have different characteristics and different class labels. Various graph neural networks (GNNs) [33; 15; 21; 34; 35; 23; 36; 37] have been proposed to achieve higher performance in low homophily settings. They focus on designing advanced GNN architectures and consider the semi-supervised setting with labels. In contrast, we focus on designing the contrastive learning algorithm without labels, not on specific GNN architectures. Recently, DSSL  and HGRL  have been proposed to conduct self-supervised learning on nonhomophilous graphs by capturing global and high-order information. Specifically, HGRL is based on graph augmentation, and DSSL works by assuming a graph generation process, which may not always hold true for real-world graphs. In contrast, our work provides a novel perspective on graph contrastive learning, which does not make any assumptions about the generation process or rely on any augmentations.

## 3 Preliminaries

**Notations and Problem.** Let \(=(,)\) be a input graph, where \(=\{v_{1},,v_{||}\}\) is the set of \(||\) nodes and \(\) is the set of edges. Let \(=[_{1},_{2},,_{||}] ^{|| D_{x}}\) be the node attribute matrix, where \(_{i}\) is the \(D_{x}\)-dimensional feature vector of \(v_{i}\). Each edge \(e_{i,j}\) denotes a link between node \(v_{i}\) and \(v_{j}\). The graph structure can be denoted by an adjacency matrix \(^{||||}\) with \(_{i,j}=1\) if \(e_{i,j}\), otherwise \(_{i,j}=0\). We denote the normalized adjacency matrix \(}=^{-1/2}^{-1/2}\) where \(\) is the diagonal degree matrix. Let \(=-}\) be the symmetric normalized graph Laplacian matrix. We also define the unweighted two-hop graph \(_{2}\), whose adjacency matrix is \(_{2}\). \((_{2})_{ik}=1\) if there exists \(j\) such that \(e_{ij}\) and \(e_{jk}\). The input graph \(\) can be denoted as a tuple of matrices \(G=(,)\). Our goal is to learn a GNN encoder \(f_{}\) parameterized by \(\), such that the representation of node \(v\): \(=f_{}(G)[v]^{D}\), can perform well for downstream tasks.

**Homophily Ratio.** Typically, the graph homophily ratio [33; 15] is defined as the fraction of edges connecting nodes with the same labels, i.e., \(()=|\{(u,v):(u,v) y_{u}=y_{v} \}|/||\). Homophily Graphs have high edge homophily ratio \(() 1\), while heterophilic graphs (i.e., low/weak homophily) correspond to small edge homophily ratio \(() 0\)[15; 16].

**GCL with Representation Smoothing.** This paradigm [13; 9; 28; 12] ensures that local neighboring nodes have similar representations and has also been shown to be equivalent to factorizing graph proximity . Despite minor differences, the objective for this paradigm can be expressed as:

\[_{}=-|}_{v}(v)|}_{u(v)}^{}/)}{(^{} /)+_{v-}_{-}}( ^{}_{-}/).\] (1)

Here \(\), \(\) and \(_{-}\) are the projected node representations by \(f_{}(G)\) of nodes \(v\), \(u\) and \(v_{-}\), respectively. \(\) is the temperature hyper-parameter. Typically, \((v)\) is the positive sample set containing one-hop

Figure 2: An illustration of various design motivations. (a) The heterophilic graph where the color denotes nodeâ€™s semantic class. (b) Contrastive objectives with the homophily assumption encourage one-hop neighbors to have similar representations. GraphACL simply encourages the node to predict its neighbors, which can implicitly capture neighborhood context (c) and two-hop monophily (d).

local neighborhoods of node \(v\), and \(_{-}\) is the negative sample set that can be randomly sampled from the node space \(\) or sampled proportionally to the power \(3/4\) of the degree of the node . Figure 3 (a) illustrates this contrastive learning scheme with this explicit homophily assumption.

**GCL with Augmented Views.** This paradigm [4; 20; 39; 3] learns representations by contrasting views based on stochastic augmentations. Specifically, for node \(v\), its representation in one augmented view is learned to be close to the representation of the same node \(v\) from the other augmented view and far away from the representations of negative samples from other nodes. Given two augmentations \(G_{1}\) and \(G_{2}\) extracted from original graph \(G\) in a predefined way, the contrastive objective is as follows:

\[_{}=-|}_{v}^{1}^{2}/)}{(^{1}^{2}/)+_{v_{-}_{-}} (^{1}_{-}/)}.\] (2)

Here \(^{1}=f_{}(G_{1})[v]\) and \(^{2}=f_{}(G_{2})[v]\) are projected representations of node \(v\) from two augmented views. \(_{-}\) is the set of negative samples of \(v\) from the inter- or intra-view . Inspired by BYOL , non-contrastive BGRL [5; 41] predicts the target augmented view of the nodes: \(_{V}=-1/||_{v}^{1 }^{2}/\|^{1}\|\|^{2}\|\), where \(^{1}=g_{}(^{1})\) is the prediction of the representation from the target augmented view. An illustration for this scheme is presented in Figure 3 (b).

## 4 Simple Asymmetric Contrastive Learning of Graphs

In this section, we elaborate on our GraphACL. The key idea behind GraphACL is encouraging the encoder to learn representations by simultaneously capturing one-hop neighborhood context and two-hop monophily, which generalizes the homophily assumption for modeling both homophilic and heterophilic graphs. Specifically, GraphACL introduces an additional predictor \(g_{}\) which maps the graph \(G\) to node representations that can predict the one-hop neighborhood context from the representation of the central node as shown in Figure 3 (c). Importantly, unlike previous contrastive schemes, which force neighboring nodes to have similar representations, GraphACL directly predicts the original neighborhood signal of each node through an asymmetric design induced by a predictor. This simple asymmetric design allows neighboring nodes to have different representations but still can capture the one-hop neighborhood context and two-hop monophily as illustrated in Figure 2.

### Graph Asymmetric Contrastive Learning

Based on the above motivation, for each node \(v\), we first propose to learn its representation by capturing its one-hop neighborhood signal. A natural idea of capturing the neighborhood signal is learning the representations of \(v\) that can well predict the original features of \(v\)'s neighbors, i.e., \(_{u}\) of neighbor \(u\). However, the original features are typically noisy and high-dimensional . To solve this issue, we cast the prediction problem in the representation space, i.e., the representation of the central node should be predictive of representations of its neighbors. Specifically, we adopt the following simple prediction loss induced by an asymmetric predictor on neighbors:

\[_{}=|}_{v}(v)|}_{u(v)}\|g_{}( )-\|_{2}^{2},\] (3)

where \(=f_{}(G)[v]\) and \(=f_{}(G)[u]\) are representations, and \(g_{}()\) is a introduced predictor which maps the latent representation \(\) to reconstruct the neighbor's representation \(\). Intuitively, in this case, each node is treated as a specific neighbor "context", and nodes with similar distributions over the neighbor "context" are assumed to be similar. Here, we utilize only one single simple \(g_{}\) to predict representations of all \(v\)'s neighbors and empirically find that it works very well.

Figure 3: Illustration of existing contrastive schemes and GraphACL. (a) forces neighboring nodes to have similar representations based on the homophily assumption. (b) augments the graph and learns the augment-invariant representations of the same node. Our GraphACL in (c) simply reconstructs the neighborhood signal of each node based on an asymmetric predictor without relying on the homophily assumption and augmentation.

This simple prediction objective in Equation (3) can preserve local neighborhood distribution in representations without homophily assumption since we do not directly enforce \(\) and \(\) to be similar to each other. To prevent \(g_{}\) from degenerating to the identity function, we consider the representations of central node \(v\) and the one-hop neighbor \(u\) come from two decoupled encoders: \(=f_{}(G)[v]\) and \(=f_{}(G)[u]\), where \(f_{}\) is the online identity encoder and \(f_{}\) is the preference target encoder. Importantly, the gradient of the loss in Equation (5) is only used to update the online encoder \(f_{}\), while being blocked in the target encoder \(f_{}\) as shown in Figure 3 (c). The weights of the target network \(\) are updated using the exponential moving average of online network weights \(\): \(+(1-)\) where \(\) is the target decay rate. An intuitive illustration for using two encoders is that each node typically plays two roles: the node itself and a specific context of other nodes, corresponding to separated notions of node identity and node preference in real-world graphs. The key principle of decoupled encoders is to allow the identity representation of a node to be more possibly different from the identity representation with which the node prefers to link.

The simple objective in Equation (3) can capture the one-hop neighborhood context without relying on the homophily assumption or requiring graph augmentation as shown in Figure 2 (c). This matches our first motivation in the introduction part. Another remaining problem is why optimizing this simple objective helps capturing 2-hop node similarity, i.e., monophily. Consider a pair of 2-hop neighbors \(v\) and \(u_{2}\) which both neighbor on the same node \(u\). Intuitively, by enforcing \(\) and \(_{2}\) to reconstruct the same context representation of neighborhood \(\), we implicitly make their representations similar. Thus, the 2-hop neighbors serve as positive pairs that will be implicitly aligned as shown in Figure 2 (d). We formally prove this intuition in Theorem 2 in our following theoretical analysis.

We note that some contrastive objectives based on augmentations such as BGRL  and BYOL  also utilize a predictor as shown in Figure 2 (b). However, the idea behind our loss in Equation (3) differs significantly from them. Specifically, they rely on data augmentations, and are built based on the idea that the augmentation can preserve the semantic nature of samples, i.e., the augmented samples have consistent semantic labels with the original ones. Nevertheless, unlike images, it is theoretically difficult to design graph augmentations without changing the semantic nature of nodes  and augmentations tend to capture homophily [20; 18]. In contrast, the simple loss in Equation (3) does not rely on augmentations but directly considers modeling one-hop neighborhood distribution. We theoretically prove that our GraphACL maximizes the mutual information between representations and one-hop neighborhood context, and captures two-hop monophily in SS 5.

Although this simple neighborhood prediction objective can capture both one-hop neighborhood pattern and two-hop monophily, it may result in a collapsed and trivial encoder: all node representations degenerate to a the same single vector on the hypersphere. The main reason is that the prediction loss operates in a fully flexible latent space, and it can be minimized when the encoder produces a constant representation for all nodes. To address this issue, we introduce an explicit uniformity regularization to further enhance the representation diversity. Specifically, we add the following explicit regularization on representation uniformity into Equation (3):

\[_{}=-|}|} _{v}_{v_{-}}\|-_{-}\|_{2 }^{2},\] (4)

where \(=f_{}(G)[v]\) and \(_{-}=f_{}(G)[v_{-}]\). Here, we consider the representations of negative samples \(_{-}\) coming from the same online encoder as central sample. This uniformity loss is typically approximated by randomly sampling \(K\) negative samples \(v_{-}\). Intuitively, minimizing this term will push all node representations away from each other and alleviate the representation collapse issue.

**Graph Asymmetric Contrastive Loss**. Directly combining Equations (3) and (4) arrives at a loss function: \(_{}=_{}+_{}\). However, minimizing this combination loss is an ill-posed problem, it approaches \(-\) as we can simply scale the norm of representations to reduce the loss. Even if the representations are normalized, minimizing \(_{}\) still leads to a relatively poor performance as shown in our experiments. To address this issue, we instead minimize an upper bound of \(_{}\), which results in the following simple objective of GraphACL (see Appendix A.1 for details):

\[_{}=-|}_{v}(v)|}_{u(v)}^{} /)}{^{}/+_{v_{- }}^{}_{-}/}.\] (5)

Here prediction \(=g_{}()\) with \(=f_{}(G)[v]\), representations \(=f_{}(G)[u]\) and \(_{-}=f_{}(G)[v_{-}]\). \(_{A}\) is a simple generalization of the graph contrastive loss with representation smoothing in Equation (1) from symmetric view to an asymmetric view. Note that when the predictor \(g_{}\) becomes the identity function, \(_{A}\) degenerates to the GCL loss \(_{S}\). We demonstrate in extensive experiments that such asymmetric framework via a simple predictor helps achieve better downstream performance on both homophilic and heterophilic graphs than many GCL methods with prefabricated augmentations.

## 5 Theoretical Analysis

In this section, we provide theoretical understandings of GraphACL. We show that our simple GraphACL can simultaneously capture one-hop neighborhood context and two-hop monophily, which are important for heterophilic graphs. We also establish theoretical guarantees for the downstream performance of the learned representations. _All proofs can be found in Appendix B._

**Notations.** We denote the random variable of node representations as \(V\), and define the mean representations from the one-hop neighborhoods of node \(v\) as \(=(v)}_{u(v)}\). This means that the representation \(\) profiles the one-hop neighborhood pattern of node \(v\). Since two nodes of the same semantic class tend to share similar neighborhood patterns in real-worlds, \(\) can be viewed sampled from \(Z|Y(_{Y},I)\) where \(Y\) is the latent semantic class indicating the one-hop pattern of \(v\). Given the above, we first demonstrate the rationality of GraphACL in capturing one-hop patterns:

**Theorem 1**.: _Minimizing GraphACL's objective in Equation (5) with exponential moving average is equivalent to maximizing mutual information between representation \(V\) and the one-hop pattern \(Y\):_

\[_{} H(V|Y)-H(V)=-I(V;Y).\] (6)

Theorem 1 indicates that minimizing GraphACL loss in Equation (5) promotes maximizing the mutual information \(I(V;Y)\) between representations and one-hop neighborhood context. Next, we theoretically verify that our GraphACL can capture intuition about the two-hop monophily similarity.

**Theorem 2**.: _Let \(_{2}(v)\) denote the set of two-hop neighbors of \(v\). Minimizing the GraphACL objective in Equation (5) is approximately minimizing the following alignment loss between two-hop neighbors:_

\[_{}=|}_{v }_{2}(v)|}_{u_{2}_{2}(v)} \|-_{2}\|_{2}^{2},\] (7)

_where \(L\) is the \(L\)-bi-Lipschitz constant of \(g_{}\): \((_{1},_{2}),\)\(1/L\|_{1}-_{2}\|_{2}^{2}\|g_{}( _{1})-g_{}(_{2})\|^{2}.\)_

The above theorem shows that minimizing the GraphACL objective implies a small alignment loss of two-hop neighbors. Thus, GraphACL not only captures the one-hop neighborhood pattern, but also the two-hop monophily implicitly, i.e., encouraging a large similarity between two-hop neighbors.

Next, we theoretically show that the learned representations can achieve better downstream performance. We evaluate the representation by its performance on a multi-class classification task using the mean classifier [43; 44; 45]. Specifically, we consider the classifier \(p_{W}(v)=*{arg\,max}\), where \(=f_{}(G)[v]\) and \(^{C D}\) is the weight of the linear classification head. The \(y_{}\) row of \(\) is the mean \(_{y}\) of representations of nodes with the label \(y\): \(_{y}=_{v|y}[]\). For simplicity, we assume that the node classes are balanced but our results can be easily extended to unbalanced settings by considering a label shift term as shown in the domain adaptation literature .

**Theorem 3**.: _Let \(_{2}=(_{2})\) be the homophily ratio of the two-hop graph \(_{2}\). Suppose that the downstream task is the M-categorical linear classification and the class is balanced. Then, \( q\) the hypothesis class with \(q=g f\), the upper bound for the classification error on the optimal \(^{*}\) is :_

\[P(y_{v} p_{W}(^{*})) 4M^{2}(4L_{ }(q)+(1-_{2}))+const.\] (8)

This theorem says that the downstream error on representations is bounded by GraphACL loss and homophily ratio \(_{2}\) of the two-hop graph \(_{2}\), i.e, monophily. Specifically, a larger monophily ratio \(_{2}\) would provably imply a smaller downstream classification error. Prior work  and the statistics of real-world graphs in Appendix C show that although the one-hop graph may be heterophily-dominant, the two-hop graph will always be homophily-dominant (\(_{2}\) is large). This theorem reveals why the simple GraphACL enjoys good performance on both homophilic and heterophilic graphs.

## 6 Experiments

### Experimental Settings

**Datasets and Splits.** We conduct experiments on both homophilic and heterophilic graphs. For heterophilic graphs, we adopt Wisconsin, Cornell, Texas , Actor, Squirrel, Crocodile, and Chameleon [33; 47]. We also use two large heterophilic graphs proposed recently: Roman-empire (Roman)  and arXiv-year  (\(\)170k) nodes. For homophilic graphs, we adopt three citation graphs: Cora, Citeseer and Pubmed [49; 50], and two co-purchase graphs: Computer and Photo [5; 51]. We further include a large-scale homophilic graph Ogbn-Arxiv (Arxiv) . For all datasets, we use the public and standard splits used by cited papers. Detailed descriptions, splits, and one-hop homophily and two-hop monophily statistics of datasets are given in the Appendix C.1.

**Baselines.** We compare GraphACL with a traditional network embedding method: LINE , and the recent state-of-the-art self-supervised learning methods: VGAE , DGI , GCA , Local (L)-GCL , HGRL , BGRL , CCA-SSG , SP-GCL , and DSSL . The descriptions and implementation details of baselines are given in Appendix C.2.

**Evaluation Protocol.** We utilize node and graph classification and node clustering to evaluate the quality of the representation. For classification, we follow the standard linear evaluation protocol . We train a linear classifier on top of the frozen representation and report the test accuracy. For node clustering, we perform k-means clustering on the obtained representations and set the number of clusters to the number of ground truth classes and report the normalized mutual information .

**Setup.** For all methods, we use a standard GCN model  as the encoder. We randomly initialize the model parameters and use the Adam optimizer to train the encoder. We run experiments with ten random seeds and report the average performance and standard deviation. For fair comparison, for all methods, we select the best configuration of hyperparameters only based on accuracy on the validation set. For baselines that did not report results in part of datasets or do not use standard public data splits [18; 29], we reproduce the results using the official code of the authors. More details on the implementation and the hyperparameter search space can be found in Appendix C.3.

### Overall Performance Comparison

Table 1 reports the average node classification accuracy on both heterophilic and homophilic graphs. We provide the graph classification and node clustering results in Appenxi C.6 and C.5, respectively, showing that GraphACL can also effectively adapt to various downstream tasks. Surprisingly, among all methods, our simple GraphACL achieves the best performance in 14 of 15 data sets with various homophily ratios, as shown in Table 1. Specifically, GraphACL achieves significant improvements on most of the heterophilic datasets and comparable performance on homophilic graphs compared with the second-best method. Specifically, GraphACL achieves 4.3% (Roman), 11.6% (Cornell), 14.4% (Texas), 5.1% (Crocodile), and 3.1% (Arxiv-year) relative improvement over the second-best method. We can observe that contrastive strategies (CCA-SSG, GCA, and BGRL) with augmentations can not work well on heterophilic graphs compared to homophilic graphs. This verifies that they still implicitly leverage homophily. In contrast, GraphACL does not need augmentations, and we attribute our significant improvement to modeling the one-hop neighborhood context and two-hop monophily.

### Ablation Study and Sensitivity Analysis

**Ablation Study.** We conduct an ablation study in Table 2 to validate our motivation and design, with the following three ablations: **(i)** directly minimize the combination loss \(_{}\), **(ii)** Removing the

  
**Method** & **LINE** & **VGAE** & **DGI** & **GCA-SSG** & **BGRL** & **L-GCL** & **HGRL** & **DSSL** & **SP-GCL** & **GraphACL** \\  Squirrel & 38.92\(\)38 & 29.13\(\)11.26 & 26.44\(\)11.48 & 48.09\(\)02.61 & 46.76\(\)36.36 & 36.22\(\)19.79 & 52.94\(\)48.83 & 48.18\(\)0.51\(\)0.85 & 52.10\(\)0.25 & **54.05\(\)**43.13 \\ Chameleon & 45.94\(\)17 & 42.65\(\)17 & 60.27\(\)39.36 & 63.66\(\)32.52 & 64.14\(\)12.02 & 54.68\(\)0.68 & 68.74\(\)4.08 & 65.82\(\)0.66 & 66.15\(\)33.62 & 65.20\(\)0.53 & **69.12\(\)**12.44 \\ Corcolle & 42.21\(\)13.12 & 45.72\(\)15.31 & 52.56\(\)0.370 & 52.77\(\)0.39 & 53.87\(\)0.60 & 60.18\(\)0.11 & 61.87\(\)0.62 & 62.98\(\)0.53 & 61.72\(\)0.21 & **66.17\(\)**34.36 \\ Actor & 27.55\(\)30.26 & 29.94\(\)18.26 & 28.08\(\)28.76 & 27.87\(\)26.02 & 28.80\(\)0.54 & 28.58\(\)24.81 & 27.95\(\)0.80 & 28.15\(\)1.92 & 28.94\(\)0.30 & 30.63\(\)3.13 \\ Wisconsin & 37.54\(\)25.35 & 55.67\(\)17.91 & 52.11\(\)21.95 & 59.50\(\)18.66 & 55.96\(\)32.14 & 55.28\(\)0.39 & 52.15\(\)0.39 & 52.25\(\)0.65 & 52.21\(\)0.10 & **69.22\(\)**24.40 \\ Cornell & 43.68\(\)17.48 & 47.33\(\)14.95 & 45.33\(\)15.61 & 52.31\(\)0.09 & 52.17\(\)10.04 & 50.33\(\)2.25 & 52.11\(\)23.7 & 57.18\(\)10.10 & 53.51\(\)1.15 & 52.29\(\)1.21 & 59.33\(\)**34.14 \\ Texas & 46.69\(\)17.02 & 52.72\(\)18.53 & 52.35\(\)0.29 & 52.92\(\)0.59 & 59.80\(\)0.68 & 52.77\(\)18.60 & 68.61\(\)18.1 & 63.10\(\)0.61 & 62.11\(\)13.59 & 58.11\(\)13.7 & **71.08\(\)**34.84 \\ Roman & 55.42\(\)0.87 & 50.90\(\)0.63 & 65.11\(\)0.579 & 67.50\(\)0.75 & 65.56\(\)0.68 & 66.69\(\)0.79 & 67.

asymmetric encoder architecture, **(iii)** Removing the uniformity loss with negative samples. We also test the combination **(ii)**\(\&\)**(iii)** by removing both asymmetric architecture and uniformity loss. First, minimizing the ill-posed combination loss is a valid baseline, but can not achieve better performance and is unstable with large standard deviations. We also find that the model without uniformity loss (ablation **(ii)**) does not achieve the best in homophily graphs, although it does still serve as a strong ablation. When each component is individually applied, the asymmetric architecture alone achieves the very best performance in Cornell and arXiv-year. This confirms our motivation that the asymmetric architecture is of more importance for modeling neighbors in heterophilic graphs where connected nodes have different classes. The full model (last row) achieves the best performance, demonstrating that our designed components are complementary to each other.

**Representation Dimension.** In Figure 4 (a), we analyze the effect of the dimension of node representations. We can observe that having a large dimension can generally lead to better performance for both homophilic and heterophilic graphs. Moreover, we find that the dimension effect is more obvious in heterophilic graphs compared to it in homophily graphs. This could be justified by our Theorems 3, which give the lower bound and upper bound of GraphACL loss in terms of the homophily ratio. Specifically, since the two-hop homophily ratio is still smaller in heterophilic graphs compared to homophilic graphs, and a small downstream error requires a small loss. Thus, a large dimension can effectively reduce the lower bound of the training loss and benefit the learning on heterophilic graphs. Training with extremely large dimensions for some graphs may lead to a slight drop of performance as GraphACL may suffer from the over-fitting issue, limiting its generalization performance.

**Other Hyper-parameters.** Figure 5 shows the performance with various decay rate \(\). We observe that (i) \(\) plays an important role in GraphACL. Having a large \(\) typically improves the model performance; (ii) Instantaneously updating the target network, i.e., when \(=0\), destabilizes training and leads to poor performance. Thus, there is a trade-off between updating the target too often and updating it too slowly. The temperature \(\) and the number of negative samples \(K\) are not included here since they are not directly relevant to our key motivation and have been employed and evaluated in the recent works [55; 56]. Thus, we provide corresponding results in Appendices C.8 and C.9.

### Qualitative Analysis and Case Study

**Similarity Visualization.** Figures 4 (b) and (c) plot the distribution of pair-wise cosine similarities of randomly sampled nodes, one-hop neighbor, and two-hop neighbor pairs based on learned representations. We can observe that, for the homophilic graph, that is, Cora, nodes are forced to have representations similar to those of their neighbors. GraphACL enlarges the similarities between neighbor nodes compared to randomly sampled node pairs, demonstrating that GraphACL can well preserve one-hop neighborhood contexts. Compared to the homophilic graph Cora, GraphACL seeks to further pull the two-hop neighbor nodes together on the heterophilic graph, i.e., Squirrel. This observation matches our motivation and analysis that GraphACL can effectively discover the underlying two-hop monophily, which benefits the learning on heterophilic graphs. Figures 6 (a) and (b) show the cosine similarity between the \(\) and prediction \(g_{}()\) for each node. We find that the cosine similarities are typically smaller than 1, showing that the predictor \(g_{}\) is not an identity matrix after convergence. Moreover, we can observe that, compared to the homophilic graph Cora, the

  
**Baseline** & **Cora** & **Pubmed** & **Cornell** & **arXiv-year** \\ 
**(i)** minimize \(_{COM}\) & 83.08\(\)0.35 & 81.31\(\)0.92 & 58.10\(\)2.89 & 45.79\(\)0.62 \\
**(ii)** w/o asymmetric encoder & 82.21\(\)0.60 & 81.05\(\)0.75 & 57.13\(\)0.13 & 45.33\(\)0.22 \\
**(iii)** w/o uniform loss & 81.39\(\)0.29 & 80.56\(\)0.35 & 57.87\(\)0.27 & 46.54\(\)0.28 \\
**(iii)** \& **(iii)** w/o both & 80.58\(\)0.65 & 77.05\(\)0.15 & 42.03\(\)1.21 & 42.71\(\)0.20 \\ 
**GraphACL** & **84.20\(\)0.31** & **82.02\(\)0.15** & **59.33\(\)1.48** & **47.21\(\)0.39** \\   

Table 2: Ablation studies on the node classification task.

Figure 4: The effect of representation dimension, and the pair-wise similarities of randomly sampled node pairs, one-hop and two-hop neighbors. More results are provided in Appendix C.10.

similarities on the heterophilic graph Squirrel are smaller. This verifies that GraphACL automatically differentiates node identity and context representations, which is important for heterophilic graphs.

**Case Study.** In Figures 6 (c) and (d), we randomly sample the two-hop subgraph of a central node and calculate the cosine similarity based on learned representations between the central node and neighbor nodes. We can observe that GraphACL can successfully identify the node whose local neighborhood patterns are similar to the central node on both homophilic and heterophilic graphs. Additionally, our GraphACL can pull two-hop neighbor nodes, which share a similar semantic class to the central nodes, instead of favoring nearby one-hop neighbor nodes. These observations endorse our intuition that heterophilic graphs can not benefit much from one-hop neighbor nodes, and our GraphACL can effectively capture the latent semantic information related to two-hop monophily.

## 7 Conclusions

We propose a simple contrastive learning framework named GraphACL for homophilic and heterophilic graphs. The key idea of GraphACL is to capture both a local neighborhood context of one hop and a monophily similarity of two hops in one single objective. Specifically, we present a simple asymmetric contrastive objective for node representation learning. We provide a theoretical understanding of GraphACL, which shows that GraphACL can explicitly maximize mutual information between representations and one-hop neighborhood patterns. We show that GraphACL also implicitly aligns the two-hop neighbors and enjoys a good downstream performance. Extensive experiments on 15 graph benchmarks show that GraphACL significantly outperforms state-of-the-art methods. We hope that the straightforward nature of our approach serves as a reminder to the community to reevaluate simpler alternatives that may have been overlooked, thus inspiring future research.

### The Loss of Graph Asymmetric Contrastive Learning

We provide details of the derivations of GraphACL in Equation (5) and show that minimizing GraphACL is approximately to minimize the combination of prediction and uniformity losses.

\[_{} =-|}_{v}(v)|}_{u(v)}^{ }/)}{^{}/+ _{v_{-}}^{}_{-}/ }\] \[=|}_{v}(v)|}_{u(v)}-^{} }{}+^{}/ +_{v_{-}}^{}_{-} /\,\] \[|}_{v}(v)|}_{u(v)}-^{} }{}+_{v_{-}} ^{}_{-}/\] (9) \[=|}_{v}(v)|}_{u(v)}-^{} }{}+_{v_{-}} ^{}_{-}/}{||}||\] \[|}_{v}(v)|}_{u(v)}-^{} }{}+||+_{v_{-}} ^{}_{-}/}{||}\] (10) \[|}_{v} (v)|}_{u(v)}-^{ }}{}+|}_{v_{-}}^{}_{-}/\] \[|}_{v} (v)|}_{u(v)}-^{} +|}_{v_{-}}^{}_{-}\] \[|}_{v} (v)|}_{u(v)}\|- \|_{2}^{2}-|}|} _{v}_{v_{-}}\|- _{-}\|_{2}^{2},\] (11)

where the symbol \(\) indicates equality up to a multiplicative and/or additive constant. Here, we utilize Jensen's inequality in Equation (10). Equation (11) holds because \(\) and \(\) are both \(_{2}\)-normalized. Given the above, we can conclude that minimizing GraphACL objective is approximately to minimizing the combination of the prediction and uniformity losses.

## Appendix B Proofs in Section 5

### Proof of Theorem 1

**Theorem 1**.: _Minimizing GraphACL's objective in Equation (5) with exponential moving average is equivalent to maximizing mutual information between representation \(V\) and the one-hop pattern \(Y\):_

\[_{} H(V|Y)-H(V)=-I(V;Y).\] (12)

Proof.: According to the derivations in Appendix A.1, we have:

\[_{} |}_{v}(v)|}_{u(v)}-^{} +|}_{v_{-}}^{}_{-}\] \[|}_{v} \|-(v)|}_{u(v)} \|_{2}^{2}-|}_{v} _{v_{-}}\|-_{-}\|_{2}^{2}\] (13) \[=|}_{v}\| -\|_{2}^{2}-|}|} _{v}_{v_{-}}\|- _{-}\|_{2}^{2},\] (14)

where \(=(v)}_{u(v)}\) is the mean representations from one-hop neighborhoods of node \(v\). Equation (13) holds because that gradient of \(\) is being blocked in the target encoder with exponential moving average; thus it can be viewed as a constant that depends only on the target encoder but not the variable \(f_{}\). Since two nodes of the same semantic class tend to share similar one-hop neighborhood patterns even in non-homophilous graphs, thus we can view the neighborhood representations \(z\) is sampled from the conditional distribution given the pseudo label \(Y\) which indicates the one-hop neighborhood pattern: \(Z|Y(_{Y},I)\). As demonstrated in , we can interpret the first term as a conditional cross-entropy between \(V\) and another random variable \(Z\) whose conditional distribution given the pseudo-label \(Y\) indicates the one-hop neighborhood pattern: \(Z|Y(_{Y},I)\):

\[|}_{v}\|- \|_{2}^{2}}}{{=}}H(V;Z|Y)=H(V|Y)+ _{KL}(V||Z|Y) H(V|Y),\] (15)

where \(H()\) and \(_{KL}()\) denote the entropy and KL-divergence, respectively. Minimizing the first term in Equation (14) is approximately minimizing \(H(V|Y)\). We then inspect the second term in Equation (14). As shown in [58; 57], the second term is close to the differential entropy estimator:

\[|}|}_{v }_{v_{-}}\|-_{-}\|_{2}^{2}  H(V).\] (16)

As a result, minimizing the loss of GraphACL can be seen as a proxy for maximizing the mutual information between the representations \(V\) and the pseudo-labels \(Y\) which indicates the neighborhood patterns of one hop nodes. Thus, the proof is completed. 

### Proof of Theorem 2

**Theorem 2**: _Let \(_{2}(v)\) denote the set of two-hop neighbors of \(v\). Minimizing the GraphACL objective in Equation (5) is approximately minimizing the following alignment loss between two-hop neighbors:_

\[_{}=|} _{v}_{2}(v)|}_{u_{2} _{2}(v)}\|-_{2}\|_{2}^{2},\] (17)

_where \(L\) is the \(L\)-bi-Lipschitz constant of \(g_{}\): \((_{1},_{2})\), \(1/L\|_{1}-_{2}\|_{2}^{2}\|g_{}(_{1})-g_{}(_{2})\|^{2}\)._

_Proof._ Given the derivations in Appendix A.1, we have:

\[_{}}}{{=}} |}_{v}(v )|}_{u(v)}-^{}}{} +^{}/+ _{v_{-}}^{}_{-}/ \,\] \[-|}_{v}(v)|}_{u(v)}^{}g _{}()}{}}}{{=}}-|}_{v}(v)|} _{u(v)}^{}g_{}(),\] (18)

where the last line holds because \(v\): \(_{v_{-}}(^{}_{-}/ )>(^{})=e>1\). To conduct the proof, we first formulate the degree-related predictions and representations as two matrices: \(}\) and \(}\). Here, \(}_{v_{1}}=}\) is the \(u\)-th row of the matrix \(}^{N D}\) and \(}_{v}=} g_{}()\) is the \(v\)-th row of the matrix \(}^{N D}\). Recall that the normalized adjacency matrix \(}=^{-1/2}^{-1/2}\) where \(\) is the diagonal degree matrix. With the above and Equation (18), we have:

\[_{} -|}_{v}(v)|}_{u(v)}g_{}()^{ }\] \[=-|}_{v}(v)|}_{u(v)}}}}}g_{}()}\] \[}}{{=}}-|} _{v}}}{|(v)|} _{u(v)}}}}}g_{ }()}\] \[-|}_{v} _{u(v)}}}}}g_{ }()}\] \[=-|}(}}}^{})-|}( \|}}\|_{2}^{2}+\|}^{}\|_ {2}^{2})\] (19) \[=-|}(} }^{}}^{}})-|}_{u}d_{u}\|\|_{2}^{ 2}}}{{=}}-|} (}}^{}}^{} }),\] (20)

where \(d_{}\) is the maximum degree of nodes and \(()\) denotes the matrix trace. In Equation (19), we utilize the inequality: \(()(\|\|_{2}^{2}+\| \|_{2}^{2})\) for any two matrices \(^{m n}\) and \(^{n t}\). Equation (20) holds as \(\) is normalized. Since the trace is the sum of elements on the main diagonal of the matrix, the \(v\)-th diagonal value of \((}}^{}}^{}})\) is:

\[(}}^{}}^{ }})_{v,v} =_{u_{2}}(}^{} })_{v,u_{2}}(}}^{})_{u_{2},v}= _{u_{2}}_{v(v)(u_ {2})}}_{v,u_{2}}^{}}_{u,u_{2}} }}}_{v}^{}_{u_{2}}\] \[=_{u(v)}_{u_{2} (u)}}}}}}}}}_{v}^{}_{u_{2}}\] \[=_{u(v)}_{u_{2} (u)}(u)|}_{v}^{}_{u_{ 2}}}{=}-_{u(v)}_{u_ {2}(u)}(u)|}\|_{v}-_{u_{ 2}}\|_{2}^{2}\] \[=-_{u(v)}_{u_{2} (u)}(u)|}\|g_{}()-g_{}( _{2})\|_{2}^{2}\] \[-_{u_{2}(u)} _{u(v)}(u)|}\|-_{2}\|_{2}^{2},\] (21)

where Equation (21) holds is because the decoder is \(L\)-bi-Lipschitz: \((_{1},_{2})\), \(1/L\|_{1}-_{2}\|^{2}\|g_{}( _{1})-g_{}(_{2})\|^{2}\). Combining Equations (18), (20) and (21), we have:

\[_{,}_{} _{,}-|} _{v}(v)|}_{u (v)}^{}g_{}()\] \[_{,}-|} (}}^{}}^{ }})_{,}-|}_{v}(}}^{}}^{}})_{v,v}\] \[_{,}|} _{v}_{u(v)}(u)|}_{u_{2}(u)}\|-_ {2}\|_{2}^{2}\] \[_{,}|} _{v}_{u_{2}_{2}(v)}\| -_{2}\|_{2}^{2}\] \[_{,}|} _{v}_{2}(v)|}_{u _{2}_{2}(v)}\|-_{2}\|_{2}^{2},\] (22)

where \(_{}f_{1}_{}f_{2}\) represents that minimizing function \(f_{1}\) with respect to \(\) is equivalent to maximizing function \(f_{2}\) with respect to \(\). Thus, the proof is completed. 

### Proof of Theorem 3

**Theorem 3**: _Let \(_{2}=(_{2})\) be the homophily ratio of the two-hop graph \(_{2}\). Suppose that the downstream task is the M-categorical linear classification and the class is balanced. Then, \( q\) the hypothesis class with \(q=g f\), the upper bound for the classification error on the optimal \(^{*}\) is:_

\[P(y_{v} p_{W}(^{*})) 4M^{2}(4L_{A}(q)+(1- _{2}))+const,\] (23)

Proof.: We define the adjacency matrix of the two-hop graph of \(G\) as \(_{2}\), i.e., \((_{2})_{ik}=1\) if there exists node \(j\) such that \(e_{ij}\) and \(e_{jk}\), otherwise \((_{2})_{ik}=0\). The normalized form of \(_{2}\) is \(}_{2}=}^{-1/2}_{2}}_{2}\) where \(}_{2}\) is the diagonal degree matrix of the two-hop graph. \(_{2}(v)\) is the set of the neighbors of \(v\) on the two-hop graph. We also define the label matrix of all nodes as \(^{N M}\) and the representation matrix \(^{M D}\) with the \(v\)-th node representation as \(_{v}=\). Let \(c_{i}\) be the number of nodes belonging to class \(i\). For any class \(i\), we have \(c_{i}=c=|}{M}\) since we assume the ideal balanced setting for simplicity. However, our theoretical results can be easily extended to unbalanced settings by explicitly considering the shift of label distributions . Given the above definitions, we have the following:

\[_{v,_{v}}\|_{v}-\|_{2}^{2} |}_{v}\| _{v}-\|_{2}^{2}=|}\| -^{}\|_{2}^{2},\] \[=|}\|-_{2}+ _{2}-^{}\|_{2}^{2},\] \[|}2\|-_{2} \|_{2}^{2}+2\|_{2}-^{}\| _{2}^{2},\] (24)

where \(_{v,i}=c_{i}^{-1}1_{y_{v}=i}\) and \(\) is the indicator function. \(y_{v}\) is the label index of node \(v\) and \(_{v}\) is the one-hot vector of label \(y_{v}\). The last line holds because \(\|+\|_{2}^{2}<2\|\|_{2}^{2}+2\|\|_{2}^{2}\) for any two matrices \(\) and \(\) of the same dimension. The \((v,i)\)-th elements of matrices \(\) and \(_{2}\) are: \(_{v,i}=_{y_{v}=i}\) and \((_{2})_{v,i}=_{u_{2}_{2}(v)}c_{i}^{-1} _{y_{v_{2}}=i}\). If \(y_{v}=i\), we have:

\[(-_{2})_{v,i}=_{y_{v}=i}- _{u_{2}_{2}(v)}}_{y_{u_{2}}=i}=1- _{u_{2}_{2}(v)}}_{y_{u_{2}}=i},\] (25)

Similarly, for \(y_{v} i\), we have:

\[(-_{2})_{v,i}=_{y_{v}=i}- _{u_{2}_{2}(v)}}_{y_{u_{2}}=i }=-_{u_{2}_{2}(v)}}_{y_{u_ {2}}=i}.\] (26)

Given the above, we further have:

\[\|-_{2}\|_{2}^{2} =_{v}\|(-_{2})_{v}\|_ {2}^{2}=_{v}_{i=1}^{M}(-_{2})_ {v,i}^{2}\] \[=_{v}_{i=1}^{M}_{y_{v}=i}(1- _{u_{2}_{2}(v)}}_{y_{u_{2}}=i })^{2}+(1-_{y_{v}=i})(-_{v_{u}_{2}(v)} }_{y_{u_{2}}=i})^{2}\] \[=_{v}(1-_{u_{2}_{2}(v)} }_{y_{u_{2}}=y_{v}})^{2}+_{i=1}^{M}_{y_ {v} i}(_{u_{2}_{2}(v)}}_{y_{u_{2}}=i})^{2}\] \[_{v}(1-_{v_{2}_{2}(v)} }_{y_{u_{2}}=y_{v}})^{2}+(_{u_{2} _{2}(v)}_{i=1}^{M}_{y_{v} i}} _{y_{u_{2}}=i}))^{2}\] \[=_{v}1+|||}( _{u_{2}_{2}(v)}(_{i=1}^{M}_{y_{v} i }_{y_{u_{2}}=i}))^{2}\] \[=_{v}1+|||}( _{u_{2}_{2}(v)}_{y_{u_{2}} y_{v}})^{2} ||+|}_{v}_{u_{ 2}_{2}(v)}_{y_{u_{2}} y_{v}}.\] (27)

For the second term \(\|_{2}-^{}\|_{2}^{2}\) in Equation (24), we have:

\[\|_{2}-^{}\|_{2}^{2} =\|(_{2}-^{}+^{ })-^{}\|_{2}^{2}\] (29) \[=\|(_{2}-^{})+(^{}-^{})\|_{2}^{2}\] \[ 2\|(_{2}-^{})\|_{2}^{2}+2\| (^{}-^{})\|_{2}^{2}\] \[ 2\|(_{2}-^{})\|_{2}^{2}\| \|_{2}^{2}+2\|\|_{2}^{2}\|(^{}- ^{})\|_{2}^{2}\] \[ 2\|(_{2}-^{})\|_{2}^{2}\| \|_{2}^{2}+2\|\|_{2}^{2}\|(^{}- ^{})\|_{2}^{2}\] \[=2\|(_{2}-^{})\|_{2}^{2}\| \|_{2}^{2}\] \[=2|}\|(_{2}-^{ })\|_{2}^{2},\] (30)

where Equation (29) holds because the \(i_{}\) row of \(\) is the mean of representations of nodes with label \(i\): \(\|(^{}-^{})\|_{2}^{2}=0\). Combining Equations (24), (27), and (30), we have:

\[_{v,_{v}}\|_{v}-\|_{2}^{2} |}2\|-_{2} \|_{2}^{2}+2\|_{2}-^{}\|_{2 }^{2}\] \[ 4|||}\|(_{2}- ^{})\|_{2}^{2}+2(1+|||} _{v}_{v_{2}_{2}(v)}_{y_{v_{2}}  y_{v}})\] \[ 4|||}\|(_{2}- ^{})\|_{2}^{2}+2M^{2}(1-_{2})+2,\] (31)where \(_{2}=(_{2})\) is the homophily ratio of the two-hop graph. Based on the derivations in Theorem 2 and Equation (9), we have:

\[_{}(q) |}_{v }_{2}(v)|}_{v_{2}_ {2}(v)}\|-_{2}\|_{2}^{2}+_{v_{- }}(^{}_{-}/ )\] \[-|}_{v }_{2}(v)|}_{v_{2}_ {2}(v)}^{}_{2}/)}{_{v _{-}}(^{}_{-}/ )}\] (32) \[-|||} _{v}_{v_{2}_{2}(v)} ^{}_{2}/)}{_{v_{- }}(^{}_{-}/ )}|||} _{}().\] (33)

We can find the last line is exactly the SimCLR-style loss  over two-hop graphs. Recent work  proves that finding the global optimum of the un-normalized SimCLR-style objective \(_{}()\) is equivalent to solving the matrix factorization problem: \(_{}\|_{2}-^{T}\|_{2}^{2}\). Given Equations (31) and (33), we further have:

\[P(y_{v} p_{W}(^{*}))  2_{v,_{v}}\|_{v}- ^{*}\|_{2}^{2}\] (35) \[ 8|||}\|(_{2}- ^{*}^{*})\|_{2}^{2}+4M^{2}(1-_{2})+4\] \[=8}{||||}_{}(^{*})+4M^{2}(1-_{2})+4+\] \[ 16M^{2}L_{}(q^{*})+4M^{2}(1-_{2})+\] \[ 4M^{2}(4L_{}(q)+(1-_{2}))+.\]

Here, we convert the mean-squared error bound to classification error bound in Equation (34) as shown by Claim B.9 in . The \(\) is the constant indicating the gap between the optimal loss value of SimCLR-style and matrix factorization losses  and \(=+4\). 

## Appendix C Experimental Details

### Datasets Details and Statistics

#### c.1.1 One-hop Homophily Levels

We utilize the following edge homophily ratio  to measure the one-hop neighbor homophily of the graph. Specifically, the edge homophily ratio \(()\) is the proportion of edges that connect two nodes of the same class:

\[()= y_{u}=y_ {v}\}|}{||}\] (36)

  
**Dataset** & **\#Nodes** & **\# Edges** & **\#Classes** & **\#Features** & \(()\) & \((_{2})\) & \(()\) \\  Cora & 2,708 & 5,278 & 7 & 1,433 & 0.81 & 0.71 & 0.89 \\ Citeseer & 3,327 & 4,552 & 6 & 3,703 & 0.74 & 0.56 & 0.81 \\ Pubmed & 19,717 & 44,324 & 3 & 500 & 0.80 & 0.74 & 0.87 \\ Photo & 7,650 & 119,081 & 8 & 745 & 0.83 & 0.66 & 0.91 \\ Computer & 13,752 & 574,418 & 10 & 767 & 0.78 & 0.55 & 0.90 \\ Arxiv & 169,343 & 2,332,386 & 40 & 128 & 0.66 & 0.61 & 0.79 \\  Texas & 183 & 309 & 5 & 1,793 & 0.11 & 0.54 & 0.79 \\ Cornell & 183 & 295 & 5 & 1,703 & 0.30 & 0.40 & 0.40 \\ Wisconsin & 251 & 466 & 5 & 1,703 & 0.21 & 0.42 & 0.42 \\ Chameleon & 2,277 & 36,101 & 5 & 2,325 & 0.23 & 0.35 & 0.67 \\ Squirrel & 5,201 & 216,933 & 5 & 2,089 & 0.22 & 0.22 & 0.73 \\ Crccodolite & 11,631 & 360,040 & 5 & 2,089 & 0.25 & 0.30 & 0.71 \\ Actor & 7,600 & 33,544 & 5 & 931 & 0.22 & 0.21 & 0.68 \\ Roman & 22,662 & 32,927 & 18 & 300 & 0.05 & 0.67 & 0.59 \\ Arxiv-year & 169,343 & 1,166,243 & 5 & 128 & 0.22 & 0.58 & 0.77 \\   

Table 3: Statistics of used homophilic and heterophilic graph datasets in this paper.

#### c.1.2 Neighborhood Context Similarity

To justify our first intuition that two nodes of the same semantic class tend to share similar one-hop neighborhood patterns even in heterophilic graphs, we consider if the same label shares similar one-hop neighborhood distributions of labels in the neighborhoods regardless of the homophily. To measure this property, we calculate the class neighborhood similarity  defined as follows:

\[s(m,m^{})=_{m}\|_{m^{ }}|}_{u_{m},v_{m^{}}}(d( u),d(v)),\] (37)

where \(M\) is the number of classes, \(_{m}\) is the set of nodes with class \(m\), and \(d(u)\) is the empirical label histogram of node \(u\)'s neighbors over \(M\) classes. \(cos()\) represents the cosine similarity function. This cross-class neighborhood similarity measures the neighborhood distributions between different classes. When \(m=m^{}\), \(s(m,m^{})\) calculates the intra-class similarity. To measure the neighborhood similarity, we average the intra-class similarities of all classes:

\[()=_{m=1}^{M}s(m,m).\] (38)

If nodes with the same label share the same neighborhood distributions, the class neighborhood similarity \(_{s}()\) is high.

#### c.1.3 Two-hop Monophily Levels

To further verify our second intuition in the introduction: two-hop similarities (monophily) still exist even without the one-hop homophily assumption, we also consider monophily properties of two-hop neighborhoods. Following , we use the following two-hop homophily to measure the monophily, where the neighborhood of each node is defined to be the nodes of exactly two hops away.

\[(_{2})=|} _{v}_{2}(v)|}_{v_{2} _{2}(v)}_{y_{v_{2}}=y_{v}},\] (39)

where \(_{2}(v)\) denotes the set of two-hop neighborhoods of \(v\).

The statistics of datasets, including their one-hop and two-hop homophily levels and neighborhood similarities, are given in Table 3. We can observe both homophilic and heterophilic graphs exhibit strong neighborhood similarity calculated based on one-hop neighborhoods. In addition, the two-hop homophily level is generally higher than the one-hop homophily level in heterophilic graphs. This observation confirms our intuition that two-hop similarities still exist without a strong one-hop homophily level. The descriptions of the datasets are given below:

**Cora, Citeseer, and Pubmed**. They are among the most widely used node classification benchmarks. Each dataset is a citation and high-homophily graph, where nodes are documents, and edges are citation relationships from one to another. The class label of each node is based on the research field. A bag of words of its abstracts is used as the features of nodes. The public split is used for these datasets, where each class has fixed 20 nodes for training, another fixed 500 nodes and 1000 nodes for validation/test, respectively for evaluation.

**Computer and Photo**. They are co-purchase graphs from Amazon, where nodes represent products and frequently bought products are connected by edges. Node features represent product reviews, and class labels indicate the product category. Following the experiment settings from , we randomly split the nodes into train/validation/test (10%/10%/80%) sets.

For these homophilic datasets, we utilized the process version of them provided by Deep Graph Library . These datasets can be found in https://docs.dgl.ai/en/0.6.x/api/python/dgl.data.html.

**Ogbn-arxiv (Arxiv)**. It is a citation network between all Computer Science (CS) arXiv papers. Each node represents one paper and each edge indicates the citation relationships between two papers. The feature of each node is obtained by a 128-dimensional feature vector through averaging the embeddings of words in its title and abstract. The embeddings of words are obtained by running the skip-gram over the MAG corpus. Following , we also use 10%/10%/80% split for this dataset.

**Texas, Wisconsin and Cornell**. They are webpage networks collected from computer science departments of different universities by Carnegie Mellon University. For each network, nodes areweb pages and edges indicate hyperlinks between web pages. Node features are bag-of-words representations of web pages. The task is to classify nodes into five categories: student, project, course, staff, and faculty.

**Chameleon, Crocodile and Squirrel**. They are Wikipedia networks, where nodes represent web pages and edges represent hyperlinks between them. Features of nodes are several informative nouns on Wikipedia pages. Labels of nodes are based on the average daily traffic of the web page.

**Actor**. It is an actor-only induced subgraph of the film-director-actor-writer network. Nodes correspond to actors and edges represent the co-occurrence of two nodes on the same Wikipedia page. Node features are keywords in Wikipedia pages. Labels are assigned five categories in terms of words on the actor's Wikipedia.

For **Texas, Wisconsin, Cornell, Chameleon, Crocodile, Squirrel and Actor**, we use the raw data provided by the Geom-GCN  with the standard fixed 10-fold split for our experiment. These datasets can be downloaded from: https://github.com/graphdml-uiuc-jlu/geom-gcn.

**Roman-empire (Roman)** is a heterophilous graph based on the Roman Empire article in English Wikipedia. Each node in the graph corresponds to one (non-unique) word in the text. The node features are from word embeddings. The class of a node is its syntactic role (the 17 most frequent roles as unique classes and all the other roles are grouped into the 18th class). Following , we utilize the fix 10 random 50%/25%/25% train/validation/test splits. This dataset can be found in https://github.com/yandex-research/heterophilous-graphs.

**Arxiv-year** is a citation network from a subset of the Microsoft Academic Graph, where the task focuses on predicting the year that a paper is posted. Nodes are papers, and edges are relevant to citations. The node features correspond to the average of word embeddings of the title and abstract of the papers. Following , 50%/25%/25% train/val/test split is utilized for this dataset. This dataset can be found in https://github.com/CUAI/Non-Homophily-Large-Scale.

### Baselines

**LINE**: This network embedding model proposed an objective function to preserve both the first-order and second-order proximities.

**VGAE**: VGAE is a generative model based on variational autoencoder for node representation learning by directly reconstructing adjacency matrix.

**DGI**: It is a self-supervised learning method that maximizes the mutual information between node representations and graph summary.

**GCA**: This is a graph contrastive representation learning method with adaptive augmentation that incorporates various priors for topological and semantic aspects of the graph.

**BGRL**: This model is a graph contrastive learning method, where the alternative augmentations of the graph are predicted to learn representations of nodes.

**CCA-SSG**: CCA-SSG is a graph contrastive learning model, which encourages the learned representations of nodes by reducing the correlation between different views.

**L-GCL**: It is a self-supervised node representation learning method, which samples positive samples from the first order neighborhoods and kernelizes negative loss to reduce the training time.

**SP-GCL**: This is a single-pass graph contrastive learning method based on the concentration property of node representations.

**HGRL**: This is a self-supervised representation learning framework on graphs with heterophily, which leverages the node original features and the high-order information.

**DSSL**: This method introduces a representation learning framework by decoupling the diverse neighborhood context of a node in an unsupervised manner.

### Setup and Hyper-parameter Settings

We use official implementation publicly released by the authors on Github of the baselines. For fair comparison, we used grid search to find the best hyperparameters of the baselines. We run experiments on a machine with a NVIDIA RTX A6000 GPU with 49GB of GPU memory. In all experiments, we use the Adam optimizer . A small grid search is used to select the best hyperparameter for all methods. In particular, for our GraphACL, we search \(\) from {0, 0.90, 0.95, 0.97, 0.99, 0.999, 1}, \(D\) from {256, 512, 1024, 2048, 4096, 8192}, \(\) from {0.25, 0.5, 0.75, 0.99, 1}, and \(K\) from {1, 5, 10} when we utilize the negative sampling. We tune the learning rate over {0.001, 0.0005, 0.0001} and weight decay over {0, 0.0001, 0.0003, 0.00001}. We select the best configuration of hyper-parameters based on average accuracy only based on the validation set.

### The Spectrum Changes in Augmented Views

In Figure 7, we categorize the eigenvalues (spectrum) of the symmetric normalized graph Laplacian into five distinct frequency bands, ranging from low to high. Subsequently, we computed the average spectrum changes across these frequency bands for two augmented views. The perturbations resulting from augmentations reveal a consistent trend in the graph spectrum. After augmenting the graph, we can observe that the perturbations in the low-frequency components (far left) are comparatively smaller than those observed in the high-frequency components (far right) for both homophilic (PubMed) and heterophilic (Squirrel) graphs. This observation confirms that mainstream GCL methods can not work well on heterophilic graphs, particularly when the perturbation in high-frequency signals is more significant.

### Node Clustering Performance

We also conduct node clustering to evaluate the quality of the learned node representations. Specifically, we obtain node representation with GraphACL, then perform k-means clustering on the obtained representations and set the number of clusters to the number of ground truth classes. The experiment is conducted five times. We report the average normalized mutual information (NMI) for clustering in Table 4 on both homophilic and heterophilic graphs. From the table, we can observe that our GraphACL can consistently improve node clustering performance compared to the state-of-the-art self-supervised learning baselines on eight datasets. This observation, along with the results of the node classification, demonstrates the effectiveness of GraphACL in learning more expressive and robust node representations for various downstream tasks. These results further validate that

  
**Method** & **Citeseer** & **Computer** & **Photo** & **Arxiv** & **Texas** & **Cornell** & **Squirrel** & **Arxiv-year** \\ 
**VGAE** & 36.40\(\)0.01 & 22.30\(\)0.00 & 53.00\(\)0.04 & 31.10\(\)0.01 & 27.75\(\)0.16 & 17.87\(\)0.13 & 10.83\(\)0.09 & 25.64\(\)0.05 \\
**DGI** & 43.90\(\)0.00 & 31.80\(\)0.02 & 47.60\(\)0.03 & 31.90\(\)0.01 & 34.17\(\)0.07 & 15.92\(\)0.15 & 8.49\(\)0.13 & 24.35\(\)0.08 \\
**BGRL** & 45.38\(\)0.00 & 36.20\(\)0.07 & 54.61\(\)0.08 & **33.71\(\)0.09** & 33.59\(\)0.15 & 19.74\(\)0.14 & 15.13\(\)0.09 & 25.31\(\)0.05 \\
**DSSL** & 45.91\(\)0.06 & 36.82\(\)0.08 & 54.99\(\)0.05 & 32.98\(\)0.06 & **32.22\(\)0.15** & **32.06\(\)0.08** & 19.85\(\)0.13 & 24.45\(\)0.07 \\
**L-GCL** & 46.52\(\)0.08 & 37.51\(\)0.09 & 55.25\(\)0.01 & 32.77\(\)0.05 & 37.92\(\)0.10 & 19.25\(\)0.05 & 18.15\(\)0.11 & 26.87\(\)0.09 \\ 
**GraphACL** & **46.82\(\)0.07** & **39.51\(\)0.09** & **55.97\(\)0.04** & **34.15\(\)0.06** & **43.31\(\)0.08** & **22.79\(\)0.05** & **23.96\(\)0.09** & **29.84\(\)0.08** \\   

Table 4: Node clustering performance in terms of NMI (%) on homophilic and heterophilic graphs

Figure 7: The average spectrum changes across these frequency bands for two augmented views. The perturbations resulting from augmentations reveal a consistent trend in the graph spectrum.

[MISSING_PAGE_FAIL:21]

### The Effect of the Number of Negative Samples

We run a sweep over the size of negative samples \(K\) to study how it affects performance. We vary \(K\) as \(\{1,5,10\}\). For each \(K\), we first learn node representation and then use the learned node representation for node classification. Figure 12 shows the results with varying \(K\). From the figure, we can observe that a small number of negative samples (e.g., \(K=5\)) is enough to achieve good performance on all graphs. For homophilic graphs, we can observe that large \(K\) can promote the

Figure 11: The effect of temperature \(\) on five heterophilic graphs.

Figure 12: The effect of the number of negative samples \(K\).

Figure 10: The effect of temperature \(\) on five homophilic graphs.

Figure 13: The distribution of pair-wise cosine similarity calculated by learned representations on randomly sampled node pairs, one-hop neighbors and two-hop neighbors.

performance of GraphACL. In contrast, for heterophilic graphs, training with large \(K\) will lead to a slight drop in performance. A possible reason is that the randomly sampled negative samples can not represent the whole node-set, given the heterogeneous and diverse patterns of heterophilic graphs.

### More Similarity Histograms of Node Pairs

Figure 13 shows the additional results on the representation similarity. The observations are generally similar to the results in the main body of the paper. As shown by the figure, we can observe that the randomly sampled node pairs are easier to be distinguished from one-hop and two-hop neighbors based on the representation similarity, which demonstrates that our GraphACL indeed captures the semantic meaning of node and will desirably push away the semantically dissimilar nodes. Moreover, the two-hop similarities in heterophilic graphs are much larger than that in homophilic graphs. These phenomena provide explanations for why GraphACL achieves good performance by capturing two-hop monophily structure information. Figure 14 shows the cosine similarity between the \(\) and prediction \(g_{}()\) for each node on other graphs. We can find that the cosine similarities are typically smaller than 1, which shows that the predictor \(g_{}\) is not an identity matrix after convergence. Moreover, we can observe that, compared to the homophilic graph Cora, the similarities on the heterophilic graph Squirrel are smaller. Since the objective of GraphACL will pull \(=g_{}()\) and \(\) together, thus GraphACL can automatically differ identity representation \(\) and preference representation \(\), which is important for modeling heterophilic graphs. For the homophilic graph

Figure 14: Similarity (cosine similarity between representation \(\) and prediction \(=g_{}()\)) histogram on different graphs.

Figure 15: Case studies. Node colors denote the semantic labels of nodes. The size of the node is proportional to its similarity to the central node denoted as the star.

Cora, the node identity representation \(\) and the preference representation \(\) should be similar, which is also captured by our simple contrastive objective in GraphACL.

### Additional Case Study Results

In Figure 15, we provide the additional case studies and visualization results on other graphs. We can find that, in most cases, nodes sharing the same semantic classes with the central nodes have larger similarities to the central nodes. This observation interprets the reason why GraphACL can achieve good performance. We observe that GraphACL can effectively capture the local neighborhood pattern and two-hop monophily for both homophilic and heterophilic graphs, which empirically verifies our theoretical analysis given in the main body of the paper.

## Appendix D Societal Impacts and Limitations

There are numerous graphs in the real world that exhibit heterophilic properties, such as transaction networks, ecological food networks, and molecular networks, in which the connected nodes possess dissimilar features and distinct class labels. Given the successful deployment of Graph Neural Networks (GNNs) in various human-related real-world applications, including social networks, knowledge graphs, and molecular property prediction, it is crucial to propose unsupervised representation learning techniques for GNNs that can effectively handle both homophilic and heterophilic graphs, thereby potentially yielding direct social impacts.

The collection of labeled data is often expensive and impractical, particularly in domains requiring specialized knowledge, such as medicine and chemistry. Considering the potential positive impact, we believe that our work can assist researchers and practitioners in devising solutions that alleviate the reliance on labeled data. However, it is important to acknowledge the potential negative consequences, as these learned representations could also be exploited for malicious purposes, such as adversarial attacks on GNNs that exploit systematic biases. Nonetheless, we believe that our simple framework and theoretical insights derived from this work contribute as a small step towards advancing the simplicity and generalizability of graph contrastive learning models within the research community.