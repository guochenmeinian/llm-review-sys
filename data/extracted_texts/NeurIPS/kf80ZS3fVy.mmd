# Towards Unified Multimodal Editing

with Enhanced Knowledge Collaboration

Kaihang Pan\({}^{1,*}\), Zhaoyu Fan\({}^{1,*}\), Juncheng Li\({}^{1,}\), Qifan Yu\({}^{1}\), Hao Fei\({}^{2}\)

Siliang Tang\({}^{1}\), Richang Hong\({}^{3}\), Hanwang Zhang\({}^{4}\), Qianru Sun\({}^{5}\)

Equal Contribution.Corresponding Author.

Zhejiang University\({}^{1}\), National University of Singapore\({}^{2}\)

Hefei University of Technology\({}^{3}\), Nanyang Technological University\({}^{4}\)

Singapore Management University\({}^{5}\)

{kaihangpan, zyfan, junchengli, yuqifan, siliang}@zju.edu.cn

haofei37@nus.edu.sg, hongrc.hfut@gmail.com

hanwangzhang@ntu.edu.sg, qianrusun@smu.edu.sg

###### Abstract

The swift advancement in Multimodal LLMs (MLLMs) also presents significant challenges for effective knowledge editing. Current methods, including intrinsic knowledge editing and external knowledge resorting, each possess strengths and weaknesses, struggling to balance the desired properties of reliability, generality, and locality when applied to MLLMs. In this paper, we propose **UniKE**, a novel multimodal editing method that establishes a unified perspective and paradigm for intrinsic knowledge editing and external knowledge resorting. Both types of knowledge are conceptualized as vectorized key-value memories, with the corresponding editing processes resembling the assimilation and accommodation phases of human cognition, conducted at the same semantic levels. Within such a unified framework, we further promote knowledge collaboration by disentangling the knowledge representations into the semantic and truthfulness spaces. Extensive experiments validate the effectiveness of our method, which ensures that the post-edit MLLM simultaneously maintains excellent reliability, generality, and locality. The code for UniKE is available at [https://github.com/beepkh/UniKE](https://github.com/beepkh/UniKE).

## 1 Introduction

The rapid development of Large Language Models (LLMs)  has made it increasingly important to ensure the real-time accuracy of their outputs in an efficient manner. To this end, in the NLP community, **Knowledge Editing** has been proposed as a data- and time-efficient way to edit LLMs, correcting errors or outdated responses while ensuring no negative impacts are created. The post-edit model is required to generate the desired output given the input (**Reliability**), also generalize over other equivalent neighbors of inputs (**Generality**) without altering the output over other irrelevant inputs (**Locality**). Knowledge editing methods can be divided into two main categories based on the type of knowledge involved: **intrinsic knowledge editing** where we update specific model parameters to store new knowledge in a parametric manner; **external knowledge resorting** that LLMs perceive the new knowledge contained in the relevant context (e.g., via in-context learning). Both types of methods have shown good effectiveness in editing LLMs.

Going a step further, with the emergence of advanced multimodal large language models (MLLMs ), there has been a further exploration into **Multimodal Editing**. Unfortunately,  finds that thoughefficient in editing LLMs, existing methodologies face considerable challenges for MLLMs due to the inherent diversity and complexity of multimodal knowledge. Despite still maintaining high reliability, **they struggle to simultaneously achieve both ideal locality and generality**, as shown in Figure 1.

We argue that both approaches, whether intrinsic knowledge editing or external knowledge resorting, have respective drawbacks for multimodal editing. Specifically, **intrinsic knowledge editing** (_e.g._, T-Patcher  that integrates additional neurons into MLLM) tries to eliminate the risk of losing previously-learned facts and preserve locality. However, it also leads to the newly integrated knowledge resembling rote memorization  with **weak generality of its truthfulness**, as multimodal reasoning requires a coordinated understanding of semantics from multiple modalities. Conversely, though **external knowledge resorting** (_e.g._, in-context editing ) retrieves generalizable information from external databases, the in-context knowledge **may not have a strong semantic relevance** with the original input . This can mislead the MLLM into areas they originally excelled, resulting in **weak locality**. Figure 2.a provides direct evidence to support the above discussion.

Therefore, how can we effectively edit MLLMs? One intuitive idea lies in directly combining intrinsic knowledge editing with external knowledge resorting, leveraging the advantages of both. However, in intrinsic knowledge editing (such as T-Patcher), the extra integrated knowledge typically incorporates parametric neurons into the model parameters, which is abstract with high-level semantics. Conversely, external knowledge resorting, such as in-context editing, feeds the MLLM with descriptive images and text at the input end, directly describing the content with low-level semantics. Consequently, these two methods exhibit **significant differences in paradigms at inconsistent semantic levels** and it is **challenging to establish a synergistic correlation** with each other. Figure 2.a demonstrates that simply combining T-Patcher and in-context editing leads to both undesirable locality and generality in the post-edit MLLM, highlighting the drawbacks of each approach separately.

To address the above issue, we propose **UniKE**, a novel multimodal editing method that establishes a unified framework for both intrinsic knowledge editing and external knowledge resorting, enabling a synergistic knowledge collaboration. First, we develop a unified view for intrinsic and external knowledge, both represented as **vectorized key-value memories** at the same semantic levels. Based on this view, we combine both types of knowledge editing methods, executing them in the latent space with a unified paradigm, as shown in Figure 2.b. Specifically, intrinsic knowledge editing integrates extra knowledge into the internal key-value memory at the feed-forward network; external knowledge resorting leverages an external key-value memory to inject knowledge into self-attention via feature shifting. Both methods could be performed in the same transformer layers with a synergistic correlation, preliminarily allowing each to utilize strengths for complementing the other.

Moreover, we further effectively enhance the collaboration between intrinsic knowledge and external knowledge resorting. Within the unified framework, the two editing methods still require emphasis on different aspects of knowledge to further complement their respective drawbacks: intrinsic knowledge should focus on generalizable **truthfulness**, while external knowledge should have relevant **semantics

Figure 1: Comparisons of existing knowledge editing methods and UniKE.

Figure 2: **(a)** The generality and locality on MMEdit  when applying T-Patcher  (intrinsic knowledge editing), IKE  (external knowledge resorting), the combination of these two (TP+IKE), and UniKE for multimodal editing. **(b)** The paradigm of intrinsic knowledge editing (Intrin. KE) and external knowledge resorting (Extern. KE) before and after knowledge unification.

to the input samples. So we leverage contrastive learning to disentangle the knowledge representations into the semantic and truthfulness spaces. In the semantic space, we enable the intrinsic knowledge to assist in selecting appropriate external knowledge with its inclusion magnitude, _preventing the disruption of locality_. Simultaneously, in the truthfulness space, we employ the external knowledge to identify a generalizable editing direction to regulate the integrated intrinsic knowledge, _alleviating its restriction of generality_. Under such a synergistic promotion, extensive experiments show that UniKE achieves promising results under various settings, ensuring that the post-edit MLLM maintains excellent reliability, generality, and locality. Overall, our main contributions are three-fold:

* We propose a unified paradigm for multimodal knowledge editing, with both intrinsic and external knowledge represented as vectorized key-value memories, conducting at the same semantic levels in the same transformer layers.
* We disentangle the knowledge representations into the semantic and truthfulness spaces, promoting the collaboration between intrinsic knowledge editing and external knowledge resorting.
* Our method ensures that, under various backbones and editing scenarios, the post-edit MLLM consistently possesses all three properties well.

## 2 Related Work

Recent years witness a burgeoning in the techniques of knowledge editing for LLMs [41; 45], with the post-edit model expected to exhibit three properties : Reliability, Generality, and Locality (Detailed definitions are given in Appendix B). Knowledge editing methods can be divided into two main categories based on the type of knowledge: intrinsic knowledge editing and external knowledge resorting. Intrinsic knowledge editing [6; 28; 25; 26], involves the parametric storage of knowledge within the model, requiring modifications to LLMs' parameters. While external knowledge resorting [46; 29; 47] typically preserves LLMs' parameters and maintains a knowledge database to retrieve relevant cases for each input with several information retrieval approaches [13; 31]. Overall, intrinsic and external knowledge exhibit significant differences in the knowledge forms (parametric neurons and descriptive in-context examples, respectively).

Furthermore, the emergence of MLLMs [1; 48; 19; 33; 40; 8] has sparked several studies on multimodal knowledge editing [4; 30]. However,  find that existing methods fall short of expectations when editing MLLMs. Though maintaining high reliability, whether intrinsic knowledge editing or external knowledge resorting, often fails to simultaneously achieve ideal locality and generality as shown in Figure 1. In this paper, we propose a synthesis of both types of methods for multi-modal editing. By unifying intrinsic and in-context knowledge as vectorized key-value memories, we facilitate collaborative interaction between the two within the unified paradigm, fully utilizing the strengths of each method and enabling the post-edit MLLM to consistently exhibit all three properties well.

## 3 Method

In this section, we first develop a unified view for knowledge editing (SS3.1). Within the unified framework, we introduce how to realize intrinsic knowledge editing and external knowledge resorting in the latent space (SS3.2). Finally, we further enhance the collaboration between both types of knowledge to control the overall editing process (SS3.3). The overall framework is shown in Figure 3.

### A Unified View for Knowledge Editing

In our general understanding, intrinsic knowledge editing and external (in-context) knowledge resorting seem to have stark differences. In this section, we will demonstrate that both intrinsic and in-context knowledge can be unified as **vectorized key-value memories**, directly acting on the hidden states within the transformer. Consequently, knowledge editing can be understood as adjusting the key-value pairs in the memory to activate appropriate knowledge for a given query representation.

Intrinsic Knowledge as Internal Key-Value Memory.Previous studies have demonstrated that the feed-forward network (FFN) in the transformer harbors a wealth of knowledge [5; 25]. We aim to conduct intrinsic knowledge editing within the FFN and treat FFN as parametric key-value memory storing within the MLLM. Considering a two-layer FFN: given the input latent states, the FFN treats it as a query \(q\), with the first FFN layer acting as keys \(W_{K}^{ffn}^{d d^{}}\), and the second layer as values \(W_{V}^{ffn}^{d^{} d}\). Here, \(d\) is the hidden dimension of the FFN; and \(d^{}\) is the intermediate hidden dimension of the FFN, also interpreted as the memory size. Consequently, FFN effectively uses the query to match the keys, with the intermediate hidden state \(o\) representing the weight for each value in memory. FFN then outputs the weighted sum of all values \((q)\).

\[ o&=(qW_{K}^{ffn}+b_{K}^{ffn }).\\ (q)&=oW_{V}^{ffn}+b_{V}^{ffn}. \]

where \(b_{K}^{ffn}^{d^{}}\), and \(b_{V}^{ffn}^{d}\) are two bias vectors. \(Act()\) is a non-linear activation function.

In-context Knowledge as External Key-Value Memory.Traditional in-context knowledge increases the context window space and makes it difficult to quantitatively control . Here we propose a similar view of in-context knowledge as an external vectorized key-value memory to establish its connection with intrinsic knowledge. Specifically, in-context learning typically concatenates the external multimodal knowledge \(X_{know}\) with the original input sequence \(X_{input}\) to form the combined sequence \(X=[X_{know},X_{input}]\). Considering the self-attention mechanism \((Q=X,K=X,V=X)\) in the transformer, during in-context learning, the attention \((X_{input},X,X)\) for tokens in the original input sequence can actually be formulated as follows:

\[(X_{input},X,X)=(X_{input},X_{input },X_{input})}_{_{input}}+(1-)(X_{ input},X_{know},X_{know})}_{_{know}} \]

The first term \(_{input}\) is the original self-attention output without in-context knowledge. The second term is to treat the hidden states of \(X_{know}\) as a key-value memory, the hidden state of \(X_{input}\) as the query, selectively activating the relevant in-context knowledge \(_{know}\). \(_{know}\) then performs position-wise feature shifting on the original attention output to achieve in-context editing, with \(\) as the scaling factor. We give a more complete analysis in Appendix A.

### Unified Knowledge Editing within Latent Space

**Assimilation: Intrinsic Knowledge Editing.** As intrinsic knowledge is considered as key-value memory stored within the FFN, akin to , we treat intrinsic knowledge editing as the process of integrating extra knowledge into the internal knowledge memory, thereby establishing connections with prior knowledge. This process is analogous to the **Assimilation** phase  in human cognition, where an individual incorporates new knowledge into their existing cognitive structures. Specifically, based on the analysis in Eq.(1), the newly added parametric knowledge is stored in the FFN as key-value pairs (the number of new pairs is \(ne\)), transforming the output of the FFN as:

\[o o_{extra}&=(q\,W_{K}^{ffn} W_{K}^{extra})+b_{K}^{ffn} b_{K}^{extra} )\\ _{edit}(q)&=o o_{extra} W_{V}^{ffn}\\ W_{V}^{extra}+b_{V}^{ffn}=(q)+o_{extra}W_{V}^{extra}  \]

Figure 3: (a) We develop a unified view for multimodal editing, with both intrinsic and external knowledge represented as vectorized key-value memory. (b) We disentangle the knowledge representation into the semantic and truthfulness spaces, further enhancing the knowledge collaboration.

where \(W_{K}^{extra}^{d ne}\) and \(W_{V}^{extra}^{ne d}\) are the extra keys and values, \(b_{K}^{extra}^{ne}\) is an extra bias vector. \(o_{extra}=(q W_{K}^{extra}+b_{K}^{extra})\) represents the activated weight of the extra value. In this way, the newly injected knowledge, in the form of key-value pairs, is seamlessly integrated into the existing knowledge structure of MLLM.

Accommodation: External Knowledge Resorting.As in-context knowledge can also be vectorized into hidden states as external key-value memory, we can interpret in-context knowledge editing as shifting the original post-attention latent states as shown in Eq.(2), which also allows in-context knowledge to be introduced in a more controlled manner. This process is analogous to the **Accommodation** phase in human cognition, where individuals modify their existing cognitive schemas to accommodate new information that does not fit into their prior understanding.

Assuming the hidden states of in-context knowledge have been extracted and stored as key-value pairs \(_{ext}=\{(h_{sem},h_{pos})\}\), in the input end, the MLLM is fed only the original sample without concentrating in-context knowledge. Within a given transformer layer, we initially utilize the pre-attention hidden states \(_{input}^{pre}\) to retrieve the top-K \(\{h_{sem,i}\}_{i=1}^{K}\) that exhibit the highest cosine similarity from \(_{ext}\), obtaining the corresponding \(\{h_{pos,i}\}_{i=1}^{K}\). As indicated in Eq.(2), \(\{h_{pos,i}\}_{i=1}^{K}\) then serves as both keys and values for attention computation, with \(h_{input}^{pre}\) acting as the query, thereby achieving the in-context latent states \(_{know}\). Subsequently, by simply specifying a scalar \(\), \(_{know}\) is integrated with the original self-attention output \(_{input}\), acting as a shifting direction that steers the original states closer to the representations of in-context knowledge, thus facilitating editing.

Analysis of the Unified Framework.In real life, assimilation and accommodation work together with ongoing interaction to drive cognitive development. Within the unified knowledge editing framework, we also inherently establish a **preliminary collaboration** between intrinsic knowledge editing and external knowledge resorting: _external knowledge assists in storing more generalizable intrinsic knowledge; intrinsic knowledge helps to select appropriate external knowledge._ As shown in Figure 3.a, in the \(l\)-th transformer layer, the post-self-attention states following in-context editing, are directly fed into the FFN for intrinsic knowledge editing. when the FFN input integrates generalizable in-context knowledge, the newly added key-value pairs in FFN also tend to store generalizable knowledge to be better activated. Moreover, the output of the FFN, having just undergone intrinsic knowledge editing, is transmitted to the self-attention of the \((l+1)\) layer. Here, it acts as the query to select suitable hidden states of in-context knowledge for in-context editing. Overall, compared to directly combining different knowledge editing methods with various paradigms, we establish _a synergistic correlation with the unification of knowledge editing paradigm, allowing different methods to utilize their strengths to complement each other._

### Enhanced Collaboration with Knowledge Disentangling

To further promote the collaboration between intrinsic knowledge editing and external knowledge resorting, it is essential to emphasize different aspects of knowledge: intrinsic knowledge should prioritize generalizable **truthfulness** to improve generality, whereas external knowledge should maintain **semantic** relevance to the input samples to preserve locality. Inspired by this, we extract diverse hidden states for in-context knowledge and innovatively disentangle the knowledge representations into semantic and truthfulness spaces, further enhancing the collaboration within these two spaces.

Extracting In-context Knowledge Representations.To construct the representations of in-context knowledge, we first acquire knowledge that the MLLM has not previously mastered, and collect triplets \(\{(Q_{I},A_{pos},A_{neg})\}\). \(Q_{I}\) is the input multimodal question, \(A_{pos}\) is the truthful answer, \(A_{neg}\) is the MLLM's hallucinated prediction. For each piece of knowledge, we pair \(Q_{I}+A_{pos}\) as the positive knowledge, \(Q_{I}+A_{neg}\) as the negative knowledge, and separately pass the positive and negative knowledge through the MLLM, obtaining three critical hidden states. **Semantic hidden state**\(h_{sem}\) is related to the last token of the question part before MLLM processes the response, inherently encoding the semantic information on the given examples. **Positive hidden state**\(h_{pos}\) and **negative hidden state**\(h_{neg}\) correspond to the final token of the entire input from the positive and negative knowledge, respectively. They provide insights into how the responses guide the MLLM onto the correct or incorrect track. Note that we store (\(h_{sem},h_{pos}\)) as the key-value pairs in the knowledge memory for in-context editing in SS3.2. More details are given in Appendix C.

Disentangling Knowledge Representations.Then we explicitly disentangle the representations of in-context knowledge into semantic and truthfulness spaces. Within the semantic space, \(h_{pos}\) and \(h_{neg}\) (along with the semantic hidden states \(h_{sem}\)) from the same sample encapsulate identical meanings; whereas in the truthfulness space, \(h_{pos}\) and \(h_{neg}\) must be distinctly differentiated.

Specifically, we introduce a truthfulness encoder \(^{Tru}()\) and a semantic encoder \(^{Sem}()\), mapping each pair of \(\{h_{pos},h_{neg}\}\) to the semantic and truthfulness space, deriving a set of semantic representations (\(H^{Sem}_{pos},H^{Sem}_{neg}\)) and truthfulness representations (\(H^{Tru}_{pos},H^{Tru}_{neg}\)), respectively. Within these two latent spaces, we leverage contrastive learning to probe representations with similar truthfulness but different semantics, and conversely, those that are semantically similar but differ in truthfulness. In the **truthfulness space**, for the given positive or negative truthfulness representations \(h^{Tru}=h^{Tru}_{pos,i}\) (\(h^{Tru}_{neg,i}\)), examples sharing the same truthfulness \(H^{Tru}_{pos}\) (\(H^{Tru}_{neg}\)) form \(S^{+}\), while those with opposite truthfulness \(H^{Tru}_{neg}\) (\(H^{Tru}_{pos}\)) form \(S^{-}\). The objective of contrastive learning is to minimize the distance between \(h^{Tru}\) and \(S^{+}\) while maximizing the distance between \(h^{Tru}\) and \(S^{-}\):

\[_{1}(h^{Tru},S^{+},S^{-})=_{i=1}^{n}(-log_{pos}}exp(s(h^{Tru}_{pos,i},h))}{_{h(H^{Tru}_{pos},H^{Tru}_{neg} )}exp(s(h^{Tru}_{pos,i},h))}-log_{neg}}exp(s(h^{Tru}_{ neg,i},h))}{_{h(H^{Tru}_{pos},H^{Tru}_{neg})}exp(s(h^{Tru}_{neg,i},h))}) \]

where \(s\) is the similarity function. In the **semantic space**, for a given semantic hidden state \(h_{sem,i}\), its corresponding semantic representations (\(h^{Sem}_{pos,i}\) and \(h^{Sem}_{neg,i}\)) form the \(S^{+}\), while those from other examples \(H^{Sem}_{pos} h^{Sem}_{pos,i},H^{Sem}_{neg} h^{Sem}_{neg,i}\) form \(S^{-}\). And the loss of contrastive learning is:

\[_{2}(h_{sem},S^{+},S^{-})=_{i=1}^{n}-log, h^{Sem}_{pos,i}))+exp(s(h_{sem,i},h^{Sem}_{neg,i}))}{_{h H^{Sem}_{pos}}exp(s(h _{sem,i},h))+_{h H^{Sem}_{neg}}exp(s(h_{sem,i},h))} \]

Enhanced Knowledge Collaboration within Disentangled Spaces.After knowledge disentangling, we could further enhance the knowledge collaboration within the two spaces. Specifically, In the **truthfulness space**, we calculate the average truthfulness representations (\(^{Tru}_{pos}\) and \(^{Tru}_{neg}\)) over all positive and negative hidden states of in-context knowledge, to regulate intrinsic knowledge editing. As the representations of positive and negative hidden states exhibit distinct truthfulness after training, we identify an editing direction \(=^{Tru}_{pos}-^{Tru}_{neg}\), pointing from the center of untruthful representations to the center of truthful representations. And then we utilize a learnable weight \(W_{}\) to map \(\) from the truthfulness space back to the representation space: \(^{}=W_{}\). On this basis, during intrinsic knowledge editing in Eq.(3), we further combine \(W^{extra}_{V}\) with \(^{}\) as follows:

\[_{edit}(q)=o&o_{extra} W^{ffn}_{V}\\ W^{extra}_{V}+^{}+b^{ffn}_{V}=(q)+o_{ extra}(W^{extra}_{V}+^{}) \]

where \(\) is an editing scalar. In the **semantic space**, as we leverage \(\) in Eq.(2) to control the inclusion magnitude of in-context knowledge, we further leverage the hidden states after intrinsic knowledge editing to adaptively control \(\). Based on \(_{know},_{input}\) in Eq.(2), we first extract the semantic representations of the injected in-context knowledge \(h^{sem}_{know}=^{Sem}(_{know})\) and the hidden states from the last token of \(_{input}\) (\(_{input}[-1]\) serves a similar role as the semantic hidden state \(h_{sem}\)). We then assign the cosine similarity between \(h^{sem}_{know}\) and \(_{input}[-1]\) to \(\), with Eq.(2) reformulated as:

\[(X_{input},X,X)=(h^{Sem}_{know},_{input}[ -1])_{input}+(1-(h^{Sem}_{know},_{ input}[-1]))_{know}, \]

Analysis of Knowledge Collaboration.In the truthfulness space, \(\) is derived from the distribution deviation between hallucinated knowledge and truthful knowledge based on a large number of examples. As the newly integrated intrinsic knowledge is typically learned from a single editing sample which easily leads to overfitting, \(\) effectively regulates the values of new intrinsic knowledge into a generalizable truthful direction to improve generality. **In the semantic space**, when the relevance between the in-context knowledge and the input sample is weak, \(=(h^{sem}_{know},_{input}[-1])\) adaptively takes a small value thanks to contrastive training. As external knowledge regarding needs to prevent the excessive inclusion of unrelated external knowledge, a smaller \(\) effectively reduces its inclusion magnitude to preserve locality. We further provide quantitative analysis in SS4.5.

## 4 Experiments

We first evaluate UniKE on **one-step editing** (SS4.2), the standard setup of multimodal editing. We further extend the setup to **sequential editing** (SS4.3) and **cross-task editing** (SS4.4) for evaluation.

### Experimental Setup

Dataset & Backbone & baselines.Our experiments are conducted on the MMEdit benchmark , which contains two subtasks: Editing VQA (E-VQA) and Editing Image Caption (E-IC). We leverage Reliability, generality (T-Generality and M-Generality) and locality (T-Locality and M-Locality) as the evaluation metrics. For one-step editing, we conduct experiments on BLIP2-OPT  and MiniGPT-4 ; for sequential editing and cross-task editing, we conduct experiments on MiniGPT-4.

Furthermore, We use the following baselines: **(1) Fine-tuning method:** tuning the last layer of MLLM; **(2) Intrinsic knowledge editing method:** Knowledge Editor (KE) , MEND , T-Patcher ; **(3) External knowledge resorting method:** In-Context Editing (IKE) , SERAC .

Implementation Details.We conduct knowledge editing in the latent space. In intrinsic knowledge editing, we add extra key-value pairs into the last four transformer layers; In external knowledge resorting, we retrieve top-40 in-context hidden states for each case and conduct feature shifting in the last four layers. More details of the experimental setup are shown in Appendix D.

### Main Results on One-step Editing

Table 1 shows the results of one-step editing, where each edit aims to correct a single mistake. We further provide a statistical summary in Append D.4. We have the following observations: _(i)_ Most knowledge editing methods could achieve desirable reliability. _(ii)_ Despite achieving high locality, **most intrinsic knowledge editing methods have room for improvement in generality** (_e.g._, average generality and locality of T-Patcher across all settings are 71.6 and 87.2). _(iii)_ Although achieving commendable generality, **the locality of external knowledge resorting methods is not ideal**. Specifically, the average locality (generality) of IKE and SERAC are 26.8 (88.6) and 52.5(91.3), respectively. _(iv)_**Our method effectively balances all three target properties, outperforming the previous SOTA method, MEND**. Compared to MEND which transforms the gradients of knowledge editing to a generalizable direction for keeping both locality and generality, UniKE significantly achieves superior locality (93.8 vs. 89.4 on average) and generality (95.1 vs. 88.6 on average).

    &  &  \\  Method & Rel. \(\) & T-Gen. \(\) & M-Gen. \(\) & T-Loc. \(\) & M-Loc. \(\) & Rel. \(\) & T-Gen. \(\) & M-Gen. \(\) & T-Loc. \(\) & M-Loc. \(\) \\   \\  Backbone Model & 0.0 & 0.0 & 0.0 & 100.0 & 0.0 & 0.0 & 0.0 & 0.0 & 100.0 & 100.0 \\ FT (last layer) & 58.7 & 54.2 & 49.4 & 67.7 & 63.1 & 61.1 & 52.1 & 51.6 & 55.0 & 49.5 \\  KE & 85.3 & 77.4 & 75.3 & 93.8 & 66.4 & 50.5 & 49.0 & 46.3 & 95.0 & 64.3 \\ T-Patcher & 85.6 & 80.3 & 74.6 & 90.5 & 89.7 & 85.6 & 73.4 & 70.0 & 91.1 & 82.0 \\ MEND & 99.4 & 98.8 & 79.1 & **99.9** & 96.6 & 96.1 & 95.8 & 74.2 & 94.5 & 70.8 \\  In-Context Editing & **99.7** & 93.9 & 93.6 & 48.8 & 2.5 & 96.7 & 78.2 & 87.6 & 49.0 & 3.0 \\ SERAC & 99.4 & **99.4** & 86.8 & 96.8 & 2.9 & **99.7** & **98.9** & 89.2 & 95.7 & 7.5 \\ 
**UniKE (Ours)** & 98.8 & 98.4 & **94.8** & 98.3 & **96.7** & 98.3 & 96.3 & **93.2** & **95.8** & **85.7** \\   \\  Base Model & 0.0 & 0.0 & 0.0 & 100.0 & 100.0 & 0.0 & 0.0 & 0.0 & 100.0 & 100.0 \\ FT (last layer) & 70.1 & 65.7 & 63.9 & 72.6 & 65.8 & 67.4 & 65.1 & 62.8 & 63.5 & 52.7 \\  KE & 91.8 & 89.0 & 60.8 & 96.9 & 67.8 & 96.6 & 67.8 & 57.4 & 97.3 & 64.4 \\ T-Patcher & 83.0 & 68.2 & 66.0 & 84.8 & 82.0 & 83.8 & 72.3 & 67.7 & 93.9 & 83.6 \\ MEND & 98.8 & **98.6** & 82.2 & 98.2 & 81.1 & 96.6 & **96.1** & 76.3 & 98.4 & 75.3 \\  In-Context Editing & **100.0** & 94.9 & 90.5 & 50.3 & 3.7 & 90.9 & 81.6 & 88.5 & 52.2 & 4.7 \\ SERAC & 87.7 & 87.6 & 85.9 & 97.5 & 14.2 & 91.8 & 91.4 & 91.0 & 97.9 & 7.2 \\ 
**UniKE (Ours)** & 98.0 & 97.4 & **92.8** & **98.7** & **88.8** & **96.8** & 95.7 & **92.4** & **98.9** & **87.3** \\   

Table 1: Main results on one-step editing on the MMEdit. Rel., T-Gen., M-Gen., T-Loc., and M-Loc. refer to Reliability, T-Generality, M-Generality, T-Locality, and M-Locality, respectively.

### Main Results on Sequential Editing

In \(K\)-step sequential editing, the model is sequentially edited while encountering mistakes in \(_{edit}(|_{edit}|=K)\). After the \(K\)th edit, the post-edit MLLM is utilized to evaluate the target properties. Table 2 shows the results of sequential editing (\(K=10\), \(20\); we exclude IKE as its setup in sequential editing is meaningless). It can be observed that _(i)_ whether in editing VQA or image captioning tasks, there is a significant decline in the performance of most methods as the number of editing steps (\(K\)) increases. Particularly for MEND, while it remains competitive in one-step editing, the results of sequential editing are suboptimal. _(ii)_ The performance of external knowledge resorting (SERAC) is minimally affected by the increase in \(K\). However, it inherently suffers from a lack of locality. _(iii)_ In contrast, our method **consistently maintains superior performance compared to the baselines**. It consistently outperforms MEND across all metrics of sequential editing, **with its advantages over the baseline becoming increasingly significant as \(K\) increases.**

### Main Results on Cross-task Editing

Cross-task editing builds on the foundation of sequential editing (we select \(K=10\)) and requires the MLLM to simultaneously edit VQA and image-caption samples within the same sequence. Table 3 presents the results of cross-task editing (averaging the results over all E-VQA and E-IC samples). It is evident that most baselines struggle to effectively edit both tasks within a single editing sequence. In contrast, UniKE excels at integrating the knowledge from these two distinct tasks, significantly outperforming baseline methods in terms of reliability, generality, and locality.

### In-Depth Analysis

Effect of Individual Components.We investigate the effectiveness of each component and conduct the following experiments on one-step editing: **(1)**_only_**Intrin & _only_**Latent-IKE:** We utilize either intrinsic knowledge editing or external knowledge resorting (Latent IKE), conducting multimodal editing in the latent space. In Rows 1 and 2 of Table 4, it is evident that single-type knowledge editing approaches cannot simultaneously possess all three properties well, resulting in either generality or locality being unsatisfactory. **(2)****Intrin + IKE:** We simply combine intrinsic knowledge editing and vanilla in-context editing without paradigm unification. The results in Row 3 demonstrate that if

    &  &  \\  Model & Rel. \(\) & TGen. \(\) & M-Gen. & T-Loc. \(\) & M-Loc. \(\) & Rel. \(\) & TGen. \(\) & M-Gen. \(\) & T-Loc. \(\) & M-Loc. \(\) \\ 
1 only & Imrin & 83.5 & 69.2 & 67.4 & 85.3 & 83.1 & 85.7 & 73.3 & 68.5 & 94.1 & 84.4 \\
2 only & Latent-IKE & 94.6 & 92.2 & 93.3 & 54.1 & 30.5 & 89.6 & 85.9 & 84.4 & 59.0 & 36.8 \\
3 Imrin+IKE & 95.5 & 79.0 & 71.8 & 63.8 & 50.1 & 88.9 & 77.2 & 74.4 & 61.0 & 59.4 \\
4 Imrin+Latent-IKE & 95.9 & 93.2 & 89.6 & 95.2 & 85.3 & 96.5 & 92.4 & 89.7 & 95.2 & 85.5 \\ 
**UniKE (Ours)** & **98.0** & **97.4** & **92.8** & **98.7** & **88.8** & **96.8** & **95.7** & **92.4** & **98.9** & **87.3** \\   

Table 4: Results of ablation study to illustrate the effect of individual components.

   Method & Rel. \(\)Gen. & M-Gen. & T-Loc. & M-Loc. \\  FT & 64.9 & 59.6 & 57.9 & 62.6 & 61.7 \\  KE & 79.8 & 74.3 & 55.7 & 80.0 & 60.1 \\ T-Pachter & 76.6 & 56.6 & 54.8 & 81.5 & 78.2 \\ MEND & 85.1 & 80.4 & 75.7 & 82.2 & 73.9 \\ SERAC & 87.1 & 83.0 & 81.0 & 85.5 & 10.7 \\ 
**UniKE (Ours)** & **88.9** & **83.4** & **81.2** & **85.7** & **79.6** \\   

Table 2: Main results on sequential editing on the MMEdit.

   Method & Rel. \(\)Gen. & M-Gen. & T-Loc. & M-Loc. \\  FT & 64.9 & 59.6 & 57.9 & 62.6 & 61.7 \\  KE & 79.8 & 74.3 & 55.7 & 80.0 & 60.1 \\ T-Pachter & 76.6 & 56.6 & 54.8 & 81.5 & 78.2 \\ MEND & 85.1 & 80.4 & 75.7 & 82.2 & 73.9 \\ SERAC & 87.1 & 83.0 & 81.0 & 85.5 & 10.7 \\ 
**UniKE (Ours)** & **88.9** & **83.4** & **81.2** & **85.7** & **79.6** \\   

Table 3: Main results on cross-task editing.

integrating both types of knowledge editing methods without a unified paradigm, it is difficult to fully leverage the individual advantages of each method, still leading to suboptimal generality and locality. **(3) Intrin + Latent IKE:** We remove the enhanced knowledge collaboration proposed in SS3.3. The results in Row 5 validate that the enhanced collaboration based on knowledge representation disentangling further enables the post-edit MLLM to achieve superior generality and locality.

Effect of In-context Editing in Latent Space.To validate the superiority of in-context editing in latent space, in Figure 4.a we compare Latent IKE with vanilla IKE across different numbers of in-context samples/hidden-states (both combined with intrinsic knowledge editing without enhanced knowledge collaboration). IKE is criticized that in-context samples are difficult to quantitatively control and take up context window space . It can be observed that in IKE, as the number of in-context samples increases, though generality generally trends upward, there is a notable decline in locality. While in our method, via quantitatively controlling the inclusion of in-context hidden states while also reducing the prompt length, **both generality and locality of the post-edit MLLM show an overall upward trend as the number of in-context samples increases**.

Effect of Knowledge Collaboration in Semantic Space.During knowledge collaboration, in semantic space, we adaptively adjust the inclusion magnitude of in-context knowledge (assigning the cosine similarity between \(h_{known}^{sem}\) and \(_{input}[-1]\) to \(\)). To demonstrate the superiority of this strategy, we further experiment with several fixed values for \(\). As shown in Figure 4.b, the increase in the fixed \(\) enhances the impact of in-context knowledge, which tends to improve generality. However, it also leads to a reduction in locality. In contrast, our method, which adaptively adjusts \(\) based on semantic relevance, customizes an appropriate injection weight for each in-context knowledge. **Thereby, we ensure an enhancement in generality while also preventing the disruption to locality.**

Effect of Knowledge Collaboration in Truthfulness Space.During knowledge collaboration, in the truthfulness space, we identify a truthful editing direction, \(\) to guide intrinsic knowledge editing. To assess the effects of \(\), we conduct the following experiments: **(1) w/o \(\):** removing the regulation of \(\) as per Eq.(3); **(2) random \(\):** replacing \(\) with a random tensor; **(3) semantic \(\):** generating \(\) in the same manner within the semantic space. As depicted in Figure 4.c, \(\)**could further enhance the generalizability of intrinsic knowledge, thus achieving superior editing performance.** However, when \(\) does not point towards the correct editing direction (random or semantic \(\)), it acts as a disruptor, thereby impairing the editing performance compared to w/o \(\).

Visualization of Different Knowledge Spaces.To give an intuitive perspective on the disentangled knowledge representations, we employ t-SNE  for dimensionality reduction, visualizing the embedding distributions for semantic and truthfulness representations across both positive and

Figure 4: **(a) Performance for IKE & Latent-IKE (both combined with intrinsic knowledge editing) with different number of in-context examples or hidden states on E-VQA. (b) Performance with different fixed value of \(\) and our dynamic \(\). (c) Performance with different \(\) treatments.**

Figure 5: **(a) Visualization of different knowledge spaces. (b) A qualitative example.**

negative hidden states. As shown in Figure 5.a, the positive and negative hidden states display similar distributions in the semantic space, yet are distinctly separated in the truthfulness space. This visualization effectively confirms the efficacy of our approach to knowledge disentangling.

Qualitative Examples.As shown in Figure 5.b and Appendix E, UniKE achieves reliable multimodal editing while generalizing to similar scenarios and ensuring accuracy for irrelevant examples.

## 5 Conclusion

In this paper, we introduce UniKE, a multimodal editing framework that establishes a unified paradigm for both intrinsic knowledge editing and external knowledge resorting. We conceptualize both types of knowledge as vectorized key-value memories and effectively enhance their collaborations with knowledge disentangling. Extensive experimental results demonstrate that our method enhances the post-edit MLLMs across various settings (one-step editing, sequential editing, and cross-task editing), ensuring that they maintain excellent reliability, generality, and locality simultaneously.