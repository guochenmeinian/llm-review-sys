# Slicing Vision Transformer for Flexible Inference

Yitian Zhang\({}^{1,2}\) Huseyin Coskun\({}^{1}\) Xu Ma\({}^{2}\) Huan Wang\({}^{2}\) Ke Ma\({}^{1}\)

**Xi (Stephen) Chen\({}^{1}\) Derek Hao Hu\({}^{3}\) Yun Fu\({}^{2}\)**

\({}^{1}\)Snap Inc. \({}^{2}\)Northeastern University \({}^{3}\)Meta

Work done when Yitian was an intern at Snap Inc.

###### Abstract

Vision Transformers (ViT) is known for its scalability. In this work, we target to scale down a ViT to fit in an environment with dynamic-changing resource constraints. We observe that smaller ViTs are intrinsically the sub-networks of a larger ViT with different widths. Thus, we propose a general framework, named **Scala**, to enable a single network to represent multiple smaller ViTs with flexible inference capability, which aligns with the inherent design of ViT to vary from widths. Concretely, Scala activates several subnets during training, introduces Isolated Activation to disentangle the smallest sub-network from other subnets, and leverages Scale Coordination to ensure each sub-network receives simplified, steady, and accurate learning objectives. Comprehensive empirical validations on different tasks demonstrate that with only one-shot training, Scala learns slimmable representation without modifying the original ViT structure and matches the performance of Separate Training. Compared with the prior art, Scala achieves an average improvement of 1.6% on ImageNet-1K with fewer parameters. Code is available at here.

## 1 Introduction

Vision Transformers (ViTs)  are renowned for its scalability and various avenues  have been explored to scale up ViT models. To tailor ViTs to run on devices with limited resources, some recent progress  utilize knowledge distillation  to scale down ViT. Particularly, DeiT  introduces two smaller variants of DeiT-B: DeiT-Ti and DeiT-S which have been widely used in resource-limited applications. Although these small ViTs exhibit enhanced efficiency, they lack the flexibility to implement customized adjustments that accommodate dynamically changing resource constraints in real-world scenarios, e.g., the computation budget of mobile phones depends on the energy level (low-power mode) and number of running apps. Consequently, the standard Separate Training (ST) protocol trains models with different sizes separately to provide a spectrum of options with diversified performance and computation. ST requires repetitive training procedures to produce multiple model choices, and the challenge is amplified for foundation models . From users' perspective, they are only offered limited model choices, that might not cater to all scenarios.

Analyzing the architectures of ViT-Ti/S/B, we observe that these ViTs are the same architecture with the only difference in the number of embedding dimensions (we ignore the difference in the number of heads as it does not impact the overall model size), indicating smaller ViTs are intrinsically the sub-networks of larger model with different widths (see Fig. 1). This suggests that a large ViT can be transformed to represent small models by uniformly slicing the weight matrix at each layer. Given a width ratio \(r\), we adjust the size of the network by this single hyperparameter, allowing a single ViT to represent multiple small variants with the weights of those sub-networks shared in a nested nature, e.g., ViT-B (\(r\)=0.25) equals ViT-Ti and ViT-B (\(r\)=0.5) corresponds to ViT-S. In this manner, we empower ViTs for flexible inference capability, and we aim to slice a ViT within a broad slicingbound and fine-grained slicing granularity so that the diversity and number of sub-networks can be ensured for higher flexibility. This problem is non-trivial as fully training all the sub-networks within a constrained budget is nearly infeasible. Consequently, it is quite challenging for these subnets to match the performance of separate training.

Although various approaches have delved into slicing deep networks for flexible inference, the problem we target to resolve, i.e., uniformly slicing ViTs within a large slicing bound and fine-grained slicing granularity, is intrinsically different from others in three perspectives: (1) slicing strategy: as shown in Fig. 2 (i) (i), the supernet training techniques  in NAS usually slice through multiple dimensions with a small slicing bound, resulting in irregularities in model architectures and a minor computational adjustment space. (2) slicing granularity: recent width slicing approaches  either slice specific portions of the network or utilize a considerably large slicing granularity, leading to a limited number of models produced. (3) network architecture: US-Net  shares a similar vision with us but it has only demonstrated success in the CNN architecture.

It is crucial to note the fundamental differences between slicing CNN and ViT: (1) vanilla small ViTs such as ViT-Ti/S/B, are inherently designed to vary based on widths, aligning with our approach. Conversely, many CNNs are structured to vary from depths, like ResNet-18/34 , and slicing them by width brings unconventional architectures. (2) slimmable CNN necessitates calibration  for each sub-network pre-inference due to Batch Normalization , unlike slimmable ViTs that can be directly utilized for evaluation. (3) the transformer architecture  has wider applications than CNN in this era, e.g., MAE , CLIP , DINOv2 , LLMs . Nevertheless, ViTs have much less image-specific inductive bias than CNN and their slimmable ability remains unclear. As shown in Fig. 2, we empirically implement US-Net on ViT-S and observe substantial performance gaps at most width ratios compared to ST, indicating that the available solution of uniform slicing does not work well on the transformer architecture.

To investigate the underlying causes of this phenomenon, we conduct analyses in Sec. 3 which are briefly summarized in two folds: (1) ViTs display minimal interpolation ability, indicating that the optimization of intermediate subnets falls notably short compared to Separate Training (ST); (2) sustained activation of the smallest sub-network poses a negative effect on other subnets, which affects the overall performance as their weights are shared in a nested nature. To resolve these issues, we propose a general framework, named _Scala_, to enforce ViTs to learn slimmable representation. Specifically, we propose Isolated Activation to disentangle the representation of the smallest sub-network from other subnets while still preserving the lower bound performance. Besides, we present Scale Coordination to ensure each subnet receives simplified, steady, and accurate learning objectives. In this manner, the slimmable ViT can be transformed into multiple smaller variants during inference and match the performance of ST.

Compared to ST which trains all the subnets individually, Scala reduces the storage and training costs remarkably since the weights of smaller ViTs are shared with the full model and we only need one-shot training without extending the training duration. Further, Scala has a very large slicing bound and fine-grained slicing granularity, enabling diverse sub-network choices during evaluation. In this way, the delivered system can make tailored adjustments that accommodate dynamically changing resource constraints in real-world scenarios, promising the application on edge devices. Compared with the prior art SN-Net  which supports flexible inference on ViTs, Scala clearly outperforms it under different computation with fewer parameters. Moreover, Scala matches the performance of ST on various tasks without modifying the network architecture, demonstrating its generalizability and potential to replace ST as a new training paradigm. The contributions are summarized as follows:

* Although slicing ViTs exhibits multiple advantages, we provide detailed analysis and practical insights into the slimmable ability between different architectures (Sec. 3 and Tab. 2) and find slicing the ViT architecture to be the most challenging problem.
* We propose a general framework _Scala_ to enable ViTs to learn slimmable representation for flexible inference. We present Isolated Activation to disentangle the representation of the smallest subnet and Scale Coordination to ensure each subnet receives simplified, steady, and accurate signals.
* Comprehensive experiments on different tasks demonstrate that Scala, requiring only one-shot training, outperforms prior art and matches the performance of ST, substantially reduces the memory requirements of storing multiple models.

## 2 Related Work

**Scaling Up ViTs.** Like Transformer  in NLP, scalability and performance improvements in ViTs  have been a central focus of recent research. Specifically, strategies have been explored to scale the depth of ViT [46; 30] and it is scaled to even larger sizes with almost 2 billion parameters and reaches new state-of-the-art results . Afterward, ViTs have been scaled up to 4 billion  and 22 billion  parameters with extraordinary performance and enormous costs.

**Scaling Down ViTs.** The advent of ViTs has also sparked interest in scaling down these models. Techniques such as knowledge distillation  have been explored to reduce the ViT model size [36; 35]. For example, DeiT  presents smaller ViTs with 5M parameters. Additionally, researchers have explored quantization methods [22; 21] to further compress ViTs for deployment on edge devices. Unfortunately, these static models cannot make customized adjustments for resource-changing environments in real scenarios.

**Slimmable Neural Network.** The derivation of multiple smaller models from a single network has been previously explored but most works focus on the CNN structure. Slimmable Networks [39; 37] and its variants [34; 3; 10] train a shared network which adapts the width to accommodate the resource constraints during inference. Later, this idea is adapted into two-stage NAS methods [2; 38; 4] for supernet training. The supernet is scaled at multiple dimensions with a small computation change, in contrast to our work where we only scale the width dimension with a large slicing bound. SN-Net  is a recently proposed method that constructs a supernet with several pre-trained models and inserts linear layers to build dynamic routes for flexible inference. Recently, several of these techniques have been extended to Transformer architecture [14; 18], while they either scale part of the network or the slicing granularity is large which means they could only deliver very few models in the end. Differing from the previous works, our method is the first work to scale the ViT structure with large slicing bound and small slicing granularity which is intrinsically a more challenging problem.

## 3 Revisiting Slicing in Vision Transformer

Due to the excessive costs of constantly activating all the sub-networks during training, the sandwich rule is proposed in US-Net  to train the slimmable network at the smallest width, largest width, and 2 random intermediate widths in each iteration so that the performance of the lower bound and upper bound are guaranteed. Although the intermediate sub-networks are optimized less frequently compared to Separate Training (ST), US-Net manages to achieve comparable performance with ST on the CNN architecture. To have a better understanding of the distinction between CNN and ViT, we apply US-Net to MobileNetV2 , a CNN, and DeiT-S , a ViT, but constantly activate four sub-networks with the width ratio of \(\{0.25,0.5,0.75,1.0\}\) at each iteration. Subsequently, we evaluate the pre-trained models at both inbound \([0.25,1.0]\) and outbound \((0,0.25)\) unseen width ratios to evaluate their interpolation and extrapolation abilities, respectively. Shown in Fig. 3, CNN exhibits moderate interpolation and extrapolation capabilities by achieving acceptable performance at previously unobserved widths during training. In stark contrast, ViT fails entirely at unseen widths, suggesting that optimizing larger sub-networks does not directly benefit the performance of smaller ViTs, even though their weights are shared in a nested nature.

We analyze the results from the expected training epochs for each sub-network. Let \(X\) represent the total number of networks to be delivered, wherein \(X-2\) intermediate sub-networks are included, and according to the sandwich rule, two of these are randomly sampled during each iteration. Formally, the expected training epochs for the intermediate networks \(\) can be expressed as:

\[=,\] (1)

where \(\) is the number of training epochs for the full model and it suggests that the optimization of most sub-networks falls notably short compared to ST. As ViT has demonstrated minimal interpolation ability at unseen widths compared to CNN, each sub-network within the slimmable ViT requires optimal utilization of every training iteration to achieve satisfactory performance. Nevertheless, the smallest subnet is constantly activated during training according to the sandwich rule and we hypothesize that the over-emphasis of the smallest sub-network, often exhibits the worse performance, may increase the training difficulty of other subnets as their weights are shared in a nested nature. To validate it, we implement US-Net  on DeiT-S without constantly activating the smallest sub-network. Fig. 4 verifies our hypothesis showing an accuracy drop at the smallest subnet but a significant performance improvement at other width ratios.

## 4 Scala

We first introduce the training and inference paradigms of Scala. Then, we describe Isolated Activation which disentangles the smallest subnet from other sub-networks while maintaining the lower bound performance. Further, we present Scale Coordination to ensure each subnet receives simplified, accurate, and steady learning objectives. Without any modification to the architecture, we deliver a general framework Scala which could be easily built on existing methods.

### Framework

Our goal is to build a general framework that makes a ViT \(F()\) slimmable, i.e., the delivered network can be transformed into different small variants for flexible inference. First, we introduce a hyperparameter \(r\) to denote the width ratio of the sub-network \(F^{r}()\). Based on our analysis in Fig. 4, ViTs have minimal interpolation ability, which suggests that all subnets have to be individually optimized to achieve decent performance. Following the sandwich rule , we sample the smallest \(s\), largest \(l\) (\(l=1\)), and 2 random intermediate width ratios \(m_{1}\), \(m_{2}\) at each iteration during training. The corresponding sub-networks are: \(F^{s}()\), \(F^{l}()\), \(F^{m_{1}}()\) and \(F^{m_{2}}()\). and we accumulate the gradients of those subnets at each iteration. At the inference stage, the network \(F()\) is evaluated at an arbitrary width ratio that has been optimized during training by adjusting \(r\).

### Isolated Activation

Illustrated in Sec. 3, constant activation of the smallest sub-network \(F^{s}()\) ensures its own accuracy at the cost of other subnets' performance. This is a dilemma as there is a significant accuracy drop of \(F^{s}()\) if we do not constantly activate it (see Fig. 4), otherwise, the performance of other sub-networks are severely limited. To alleviate this issue, we propose Isolated Activation to disentangle the representation of \(F^{s}()\) from other sub-networks while still constantly activating it. It not only ensures the performance of the lower bound but facilitates the optimization of other subnets as well.

Formally, given the learnable weight \(^{C_{o} C_{i} H W}\) of a random layer in ViT (\(C_{o},C_{i}\) stands for the output, input channel number, \(H,W\) represents the height and width of the convolution kernel, \(H=W=1\) for fully connected layers), the weight of \(F^{r}()\) where \(r s\) is selected as:

\[^{r}=[:(r C_{o}),:(r C_{i}) ].\] (2)

In contrast, the smallest sub-network \(F^{s}()\) is activated as:

\[^{s}=[-(s C_{o}):,\ -(s C_{i} ):],\] (3)

where we slice the weights in a reverse direction so that we disentangle the representation of \(F^{s}()\) from other sub-networks. With this simple but critical design, we not only ensure the performance of \(F^{s}()\) with constant activation, but also alleviate the negative effects it brings.

### Scale Coordination

We present the training strategy of Scala in this section. We follow the setting of DeiT  to train the full model \(F^{l}()\) with knowledge distillation and introduce a distillation token for knowledge transfer between sub-networks. As our goal is to scale down a given network \(F()\) to multiple smaller variants, we simply choose the pre-trained model itself \(F^{}()\) as the external teacher for the full network \(F^{l}()\) to facilitate training. To optimize the sub-networks at different scales, we present the Scale Coordination training strategy, which is composed of three techniques: Progressive Knowledge Transfer, Stable Sampling, and Noisy Calibration, to ensure that each subnet receives simplified, accurate, and steady learning objectives.

**Progressive Knowledge Transfer.** Given an input image \(v\), the activated sub-network \(F^{r}()\) produces two predictions:

\[p_{cls}^{r},\ p_{dis}^{r}=F^{r}(v;^{r}),\] (4)

where \(p_{cls}^{r}\) and \(p_{dis}^{r}\) denote the prediction generated by the classification and distillation head, respectively. As we activate multiple sub-networks: \(F^{s}()\), \(F^{l}()\), \(F^{m_{1}}()\) and \(F^{m_{2}}()\) at each iteration during training, our idea is to utilize the predictions of the larger network to facilitate the optimization of smaller subnets.

Given the sorted width ratio list \(R=[s,m_{1},m_{2},l]\), we utilize the KL divergence  loss to progressively distill the knowledge of the larger network into the smaller one:

\[_{KL}^{r}=-_{k=1}^{K}p_{dis}^{r^{}}(^{r}}{p_{dis}^{r^{}}}),\] (5)

where \(K\) represents the number of classes, \(r^{}=R[(r)+1]\) and \((r)\) denotes the index of \(r\) in \(R\). Instead of using \(p_{dis}^{l}\) as the optimization target for all smaller networks, we ensure each subnet receives simplified learning objective as small subnet have large capacity gap compared to \(F^{l}()\) (e.g., \(F^{l}()\) is almost 16 times larger than \(F^{s}()\) if \(s=0.25\)) and minimizing their KL loss complicates the optimization process and leads to inferior performance. With Progressive Knowledge Transfer, we simplify the optimization objective for small sub-networks by utilizing \(F^{m_{1}}()\) and \(F^{m_{2}}()\) as the teacher assistants to fill the gap between \(F^{l}()\) and \(F^{s}()\) and train them in a one-shot manner.

**Stable Sampling.** As the knowledge is gradually transferred from the larger network to the smaller one, the two intermediate networks serve as the bridge to connect \(F^{l}()\) and \(F^{s}()\), as \(F^{m_{2}}()\) is the student of \(F^{l}()\) and \(F^{m_{1}}()\) is the teacher of \(F^{s}()\). Therefore, we need to carefully control the width ratios \(m_{1}\) and \(m_{2}\) to prevent the obvious model capacity variation.

Concretely, we introduce the slicing granularity \(\) and the number of networks \(X\) we can deliver (including the full model) with a single ViT is denoted as:

\[X=+1.\] (6)

Then, we divide the slicing bound \(B=\) into two smaller ones:

\[B_{1}=]}{},\ \ B_{2}=,l )}{},\] (7)where \(=\) and \(}\), \(}\) will be the random integer sampled from the uniform distribution \(B_{1}\), \(B_{2}\), respectively. Thus, \(m_{1}\) and \(m_{2}\) are defined as:

\[m_{1}=},\ \ m_{2}=},\] (8)

and we ensure the model capacity gap between the four networks is stable and secure the learning objective for each subnet is steady.

**Noise Calibration.** Although all the subnets receive guidance from larger networks, a notable issue is that the predictions from the teacher are not always accurate, sometimes even noisy, especially at the early training stage. To avoid the noisy signal dominating the optimization direction, we first calculate the Cross-Entropy loss by:

\[_{CE}^{r}=-_{k=1}^{K}_{k}(p_{cls}^{r}),\] (9)

where \(_{k}\) represents the one-hot label for class \(k\). Then, we calibrate the noise by combining the KL divergence loss and Cross-Entropy loss:

\[^{r}=_{CE}^{r}+_{KL}^{r},\] (10)

where \(\) is a hyperparameter used to balance the two losses and we empirically let \(=1\) in our implementations. By doing so, we mitigate the negative effects brought by the noisy predictions of the teacher model and ensure each subnet is guided by the accurate learning objectives.

## 5 Experiments

We validate Scala with the plain ViT structure DeiT . We first analyze of the main property of Scala and compare our method with the state-of-the-art method SN-Net  and Separate Training (ST) at a larger scale. Moreover, we examine the transferability of Scala and its application on Semantic Segmentation. Finally, we provide ablations to validate the efficacy of our designs.

### Experiment Settings

All the object recognition experiments are carried out on ImageNet-1K . We follow the training recipe of DeiT  and conduct the experiments on 4 V100 GPUs. For Scala, we set \(s=0.25\), \(l=1.0\), and \(=0.0625\) so that we could enable a single ViT to represent 13 different networks (\(X=13\)) with a large slicing bound (i.e., \(F^{l}()\) is almost 16 times larger than \(F^{s}()\)).

### Proof-of-Concept

In this part, we conduct experiments over DeiT-S  for 100-epoch training to prove the concept.

**Comparison with scaling baselines.** We compare Scala with multiple scaling baselines, including: (1) AutoFormer : we apply this ViT-based supernet training method into our setting to scale through width; (2) US-Net : the prior work that obtains similar performance with ST over the CNN structure; (3) Separate Training (ST): we repetitively train the model with different widths from scratch and evaluate them individually. Tab. 1 shows that AutoFormer lags behind Scala remarkably as we target to scale in a wider range. US-Net shows significantly worse performance compared to ST which indicates that scaling down ViT is a more challenging problem compared to the CNN architecture. Nevertheless, Scala achieves better performance compared to ST at all width ratios with one-shot training, reducing the storage costs of saving multiple models observably.

    &  &  &  &  &  \\   & & Acc1. & GFLOPs & Acc1. & GFLOPs & Acc1. & GFLOPs & Acc1. & GFLOPs \\  AutoFormer  & 22M & 50.8\(\%\) & 0.4 & 65.6\(\%\) & 1.3 & 69.5\(\%\) & 2.7 & 69.8\(\%\) & 4.6 \\ US-Net  & 22M & 52.7\(\%\) & 0.4 & 60.1\(\%\) & 1.3 & 66.9\(\%\) & 2.7 & 73.2\(\%\) & 4.6 \\ Separate Training & 43M & 45.8\(\%\) & 0.4 & 65.1\(\%\) & 1.3 & 70.7\(\%\) & 2.7 & 75.0\(\%\) & 4.6 \\  Scala & 22M & **58.7\(\%\)** & 0.4 & **68.3\(\%\)** & 1.3 & **73.3\(\%\)** & 2.7 & **76.1\(\%\)** & 4.6 \\   

Table 1: Comparison with scaling baseline methods AutoFormer , US-Net  and Separate Training under different width ratios \(r\). The best results are bold-faced.

**Slicing Granularity and Bound.** Fig. 6 shows the results of various slicing granularity \(\). First, Scala outperforms ST with different \(\) and the advantage at small width ratios is more obvious, which promises its application on edge devices. Moreover, it is shown that less fine-grained granularity \(\) results in better overall performance with the same slicing bound as the expected training epochs \(\) for intermediate subnets increase correspondingly. We further conduct experiments with different \(s\) while fixing \(l\) and \(\) to study the effect of the slicing bound. Fig. 6 shows that smaller bounds lead to markedly better performance and it further verifies that slicing through a large bound is intrinsically more difficult, which distinguishes Scala from the supernet training methods  in NAS.

**Application on Hybrid Structures.** We experiment Scala on the CNN-ViT hybrid architecture Uniformer-S . As Uniformer contains Batch Normalization (BN)  which cannot be directly evaluated after slicing because of normalization shifting , we calibrate the statistics of BN before inference following . Shown in Fig. 8, Uniformer-S is scaled down to 13 different variants with better performance compared to ST, demonstrating the generalization ability of Scala. However, performing BN calibration at each width ratio requires considerable extra effort. This highlights the benefit of ViT, as Layer Normalization (LN) allows direct evaluation without additional operations.

**Application on Lightweight Structures.** We further validate Scala on lightweight structure Uniformer-XS  which integrates the design of token pruning and train these methods for 150 epochs. Shown in Fig. 8, Scala still matches the performance of ST and exhibits a significant advantage at small width ratios, which promises its application on edge devices with a limited budget.

**Fast Interpolation of Slimmable Representation.** Training models with different slicing granularity \(\) from scratch is time-consuming and here we show that the slimmable representation of certain granularity can be scaled to others with a small amount of training epochs. Specifically, we train the model with the original \(\) for 70 epochs and decrease the value of \(\) in the last 30 epochs to deliver more sub-networks for higher inference flexibility. Fig. 9 shows the results of fast interpolation are similar to those trained from scratch and the newly appeared sub-networks are quickly interpolated to achieve decent performance. We further increase \(\) for sub-networks with higher performance and the phenomenon shown in Fig. 10 is similar to down interpolation. Besides, we observe that the accuracy of abandoned sub-networks gradually decreases but they maintain the performance to a great extent.

**Slimmable Ability across Architectures.** We examine the slimmable ability of different architectures in Tab. 2 by applying Scala on different architectures and evaluating these networks at unseen widthratios to explore the interpolation ability. CNN exhibits very strong interpolation ability as the performance at unseen widths lies in the range of trained width ratios. In contrast, CNN-ViT and ViT suffer from remarkable performance decreases to different extents and ViT achieves almost zero accuracy which further validates that the problem we target to solve, i.e., slicing ViT, is the most challenging one.

### Comparisons over Extended Training

In this section, we perform training over DeiT-B  for 300-epoch training following the standard protocol on ImageNet-1K  to compare with the state-of-the-art.

**Comparisons with state-of-the-art.** SN-Net  is state-of-the-art work that supports flexible inference on ViT. Specifically, it utilizes several pre-trained models (e.g., DeiT-Ti/S/B) to construct a supernet and inserts additional layers to build dynamic routes for flexible inference. Shown in Tab. 3, we empirically compare Scala with SN-Net over DeiT-B following the standard 300-epoch training protocol . Scala obtains similar performance with SN-Net at large width ratios and clearly outperforms it at small computational budgets. Besides, SN-Net has to preserve the parameters of multiple models and additional layers, while Scala only needs to keep the weights of the full network. When adopting the stronger teacher network  as SN-Net does, Scala outperforms SN-Net with an average improvement of 1.6\(\%\) across all width ratios.

**Comparisons with Separate Training.** In Tab. 4, we compare with ST on DeiT-B  with longer training process, i.e., 300-epoch training, where \(r=0.25,0.50,1.00\) corresponds to DeiT-Ti, DeiT-S and DeiT-B, respectively. Scala exhibits a clear advantage at \(r=0.25\) and matches the performance of ST except \(r=0.50\) due to significantly less training time. When \(X=7\), we can achieve similar performance at \(r=0.50\) with 40\(\%\) training epochs of ST. Further reducing \(X\) to 4, resulting in the constant activation of the two intermediate networks, allows us to consistently outperform ST at all width ratios. This substantiates the effectiveness of Scala and the slimmable representation.

    &  & \(r=0.25\) & \(r=0.50\) & \(r=0.75\) & \(r=1.00\) \\  & & Acc1. & Acc1. & \(\) & Acc1. & \(\) & Acc1. \\  ST & 16MM & 72.25 & 79.95 & 300 & 81.05 & 300 & 81.85 \\  Scala (X=13) & 66M & 73.55 & 79.95 & 55 & 81.25 & 55 & 82.05 \\ Scala (X=7) & 86M & 75.35 & 79.75 & 120 & 81.45 & 120 & 82.05 \\ Scala (X=6) & 86M & **75.64** & **80.96** & 300 & **81.95** & 300 & **82.27** \\   

Table 4: Comparison with Separate Training (ST) over DeiT-B  on ImageNet-1K under different width ratios \(r\). \(\) denotes the expected training epochs of each model.

### Transferability

To assess the transferability of Scala, we employ DeiT-B  as the backbone for a 300-epoch pre-training on ImageNet-1K and leverage the foundation model DINOv2-B  as the teacher network to inherit good behaviors. Our study aims to address two key questions:

**Whether the slimmable representation can be transferred to downstream tasks?** As depicted in Fig. 10(a), Scala consistently outperforms Separate Training (ST) across all width ratios, despite the intermediate sub-networks being trained for approximately 55 epochs. After that, we conduct linear probing on video recognition dataset UCF101 with 8 evenly sampled frames and average their features for the final prediction. For the classification head added on Scala, we make it slimmable to fit the features with various dimensions and follow the same training protocol as in object recognition. In Fig. 10(b), two notable observations emerge: (1) Scala consistently outperforms ST across different width ratios on the UCF101 dataset, implying the great transferability of the slimmable representation; (2) Scala retains its slimmable ability when applied to a new task and exhibits promising performance across a wide slicing range (10\(\)141 GFLOPs), promising its application on other downstream tasks.

**Whether the generalization ability can be maintained in the slimmable representation?** Inspired by the work  which replicates the success of vision foundation models on ImageNet-1K, we remove all the Cross-Entropy losses during training to alleviate the dataset bias issue and inherit the strong generalization ability of the teacher network DINOv2. Then we conduct linear probing on 12 fine-grained classification datasets following the setup in DINOv2. Tab. 5 shows that Scala significantly outperforms DeiT variants on the average performance of fine-grained classification which suggests that Scala indeed inherits the fruitful knowledge from DINOv2 with remarkable improvement in its generalization ability. Moreover, the improvement over DeiT does not decrease when we scale down the width ratios during inference and it indicates that Scala maintains the flexible inference capability very well even though it contains more knowledge than before.

### Dense Prediction

In previous sections, we have validated the effectiveness of Scala on classification tasks, we further examine whether the slimmable representation could be transferred for dense prediction task like

Figure 11: Transferability of Scala. We first conduct pre-training on ImageNet-1K with the help of foundation model DINOv2-B . Then we conduct linear probing on video recognition dataset UCF101. Improvements over ST are shown.

 Method & \(r\) & Arch & \)} &  segmentation. We utilize the pre-trained model Uniformer-S  drawn from Fig. 7, which has a hierarchical design and is obtained by 100-epoch training (our results lag behind official results where the backbone is trained for 300 epochs), and equip it with Semantic FPN . To compare with Separate Training (ST), we extract four subnets from Scala (Uniformer-S) and train them separately. Shown in Tab. 6, Scala outperforms ST at all widths which verifies the slimmable representation benefits the downstream tasks. Note that we do not scale the decoder as it involves extra designs and is out of the scope of this work. However, we show that the slimmable representation can be generalized to semantic segmentation as feature extractors because the feature maps are spatially intact, promising its application as an end-to-end slimmable framework on dense prediction tasks.

### Ablation Study

We conduct ablation to examine the effectiveness of our designs in Tab. 7. First, we build Scala without Isolated Activation so that the smallest sub-network will entangle with others and it shows an obvious performance drop at all width ratios. Then, we remove Progressive Knowledge Transfer (PKT) and pass the knowledge from \(F^{l}()\) to smaller subnets through classification token following US-Net . It shows much worse performance, especially at small ratios, which proves the strength of PKT as it implicitly introduces some teacher assistants to simplify the optimization objective for small sub-networks. Further, we random sample the width ratios of \(m_{1}\) and \(m_{2}\) between \((s,l)\) and compare it with Stable Sampling (SS). The results are slightly inferior to SS which suggests SS is helpful in securing the steady learning objective for each sub-network. Finally, we remove Noise Calibration (NC) from Scala and only use the predictions from larger networks to guide the small subnets. It shows remarkable performance drops at small width ratios, where the noise from the teacher network is most obvious, demonstrating the effectiveness of NC in calibrating the noise and providing accurate signals for sub-networks.

## 6 Conclusion and Limitations

In this paper, we observed that smaller ViTs are intrinsically the sub-networks of a large ViT with different width ratios. However, slicing ViT is very challenging due to its poor interpolation ability. To address this issue, we proposed Scala to enable a single network to represent multiple smaller variants with flexible inference capability. Specifically, we proposed Isolated Activation to disentangle the representation of the smallest subnet from others and presented Scale Coordination to ensure the sub-network receives simplified, steady, and accurate learning objectives. Extensive experiments on different tasks prove that Scala, requiring only one-shot training, outperforms the state-of-the-art method under different computations and matches the performance of Separate Training with significantly fewer parameters, promising the potential as a new training paradigm.

One limitation of Scala is the longer training time compared to conventional supervised learning of a single model, attributable to the activation of multiple subnets during training. Nevertheless, our training time is obviously less than separately training all the sub-networks. In the future, we aim to enhance the training efficiency of Scala.

    &  \\   & 0.25 & 0.50 & 0.75 & 1.00 \\  Uniformer-S (ST) & 33.9 & 40.4 & 42.6 & 45.3 \\ Uniformer-S (Scala) & **35.0** & **40.7** & **43.7** & **46.1** \\   

Table 6: Evaluation of slimmable representation on dense prediction task Semantic Segmentation over ADE20K  dataset. We equipped the pre-trained Uniformer-S  from Fig. 7 with Semantic FPN  and compare the sub-networks extracted from Scala with Separate Training (ST).

    &  \\   & 0.25 & 0.375 & 0.50 & 0.625 & 0.75 & 0.875 & 1.00 \\  Scala & **58.7** & **63.4** & **68.3** & **71.3** & **73.3** & **74.4** & 76.1 \\ w/o IA & 57.3 & 61.5 & 66.4 & 69.8 & 72.0 & 73.4 & 75.8 \\ w/o PKT & 53.0 & 60.1 & 65.6 & 68.8 & 71.7 & 73.7 & 76.2 \\ w/o SS & 58.7 & 62.7 & 68.1 & 71.3 & 73.1 & 74.2 & 75.9 \\ w/o NC & 50.2 & 62.7 & 67.2 & 70.5 & 72.7 & 74.0 & **76.3** \\   

Table 7: Ablation study of Scala over DeiT-S  on ImageNet-1K under various width ratios. IA, PKT, SS, NC denote Isolated Activation, Progressive Knowledge Transfer, Stable Sampling, Noise Calibration, respectively. The best results are bold-faced.