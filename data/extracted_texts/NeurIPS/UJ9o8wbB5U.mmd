# Provably Safe Reinforcement Learning with Step-wise Violation Constraints

Nuoya Xiong\({}^{1,}\), Yihan Du\({}^{2,}\), Longbo Huang\({}^{1,,}\)

\({}^{1}\)Institute for Interdisciplinary Information Sciences, Tsinghua University

\({}^{2}\)University of Illinois at Urbana-Champaign

\({}^{*}\)nuoyaxiong@gmail.com

\({}^{}\)yihandu@illinois.edu

\({}^{}\)longbohuang@tsinghua.edu.cn

Corresponding author.

###### Abstract

We investigate a novel safe reinforcement learning problem with step-wise violation constraints. Our problem differs from existing works in that we focus on stricter step-wise violation constraints and do not assume the existence of safe actions, making our formulation more suitable for safety-critical applications that need to ensure safety in all decision steps but may not always possess safe actions, e.g., robot control and autonomous driving. We propose an efficient algorithm SUCBVI, which guarantees an \(}()\) or gap-dependent \(}(S/_{}+S^{2}AH^{2})\) step-wise violation and an \(}(SAT})\) regret. Lower bounds are provided to validate the optimality in both violation and regret performance with respect to the number of states \(S\) and the total number of steps \(T\). Moreover, we further study an innovative safe reward-free exploration problem with step-wise violation constraints. For this problem, we design the algorithm SRF-UCRL to find a near-optimal safe policy, which achieves a nearly state-of-the-art sample complexity \(}((AH^{2}}{}+SA}{ ^{2}})(()+S))\), and guarantees an \(}()\) violation during exploration. Experimental results demonstrate the superiority of our algorithms in safety performance and corroborate our theoretical results.

## 1 Introduction

In recent years, reinforcement learning (RL) (Sutton and Barto, 2018) has become a powerful framework for decision-making and learning in unknown environments. Despite the ground-breaking success of RL in games (Lanctot et al., 2019), recommendation systems (Afsar et al., 2022) and complex tasks in simulation environments (Zhao et al., 2020), most existing RL algorithms focus on optimizing the cumulative reward and do not take into consideration the risk aspect, e.g., the agent runs into catastrophic situations during control. The lack of strong safety guarantees hinders the application of RL to broader safety-critical scenarios such as autonomous driving, robotics and healthcare. For example, for robotic control in complex environments, it is crucial to prevent the robot from getting into dangerous situations, e.g., hitting walls or falling into water pools, at all times.

To handle the safety requirement, a common approach is to formulate safety as a long-term expected violation constraint in each episode. This approach focuses on seeking a policy whose cumulative expected violation in each episode is below a certain threshold. However, for applications where an agent needs to avoid disastrous situations throughout the decision process, e.g., a robot needs to avoid hitting obstacles at each step, merely reducing the long-term expected violation is not sufficient to guarantee safety.

Motivated by this fact, we investigate safe reinforcement learning with a more fine-grained constraint, called _step-wise_ violation constraint, which aggregates all nonnegative violations at each step (no offset between positive and negative violations permitted). We name this problem Safe-RL-SW. Our step-wise violation constraint differs from prior expected violation constraint (Wachi and Sui, 2020; Efroni et al., 2020; Kalagaria et al., 2021) in two aspects: (i) Minimizing the step-wise violation enables the agent to learn an optimal policy that avoids unsafe regions deterministically, while reducing the expected violation only guarantees to find a policy with low expected violation, instead of a per-step zero-violation policy. (ii) Reducing the aggregated nonnegative violation allows us to have a risk control for each step, while a small cumulative expected violation can still result in a large cost at some individual step and cause danger, if other steps with smaller costs offset the huge cost.

Our problem faces two unique challenges. First, the step-wise violation requires us to guarantee a small violation at each step, which demands very different algorithm design and analysis from that for the expected violation (Wachi and Sui, 2020; Efroni et al., 2020; Kalagaria et al., 2021). Second, in safety-critical scenarios, the agent needs to identify not only unsafe states but also potentially unsafe states, which are states that may appear to be safe but will ultimately lead to unsafe regions with a non-zero probability. For example, a self-driving car needs to learn to slow down or change directions early, foreseeing the potential danger in advance in order to ensure safe driving (Thomas et al., 2021). Existing safe RL works focus mainly on the expected violation (Wachi and Sui, 2020; Liu et al., 2021; Wei et al., 2022), or requiring some other assumptions such as imposing the prior knowledge of a safe action for each state (Amani et al., 2021). Moreover, many previous works also require strong assumptions that exclude discrete tabular MDP (Amani et al., 2021; Wachi et al., 2021; Wang et al., 2023) which is considered in our paper. Hence, techniques in previous works cannot be applied to handle step-wise violations. More detailed comparisons are provided in Section 2.

To systematically handle these two challenges, we formulate safety as an unknown cost function for each state without assuming safe actions, and consider minimizing the step-wise violation instead of the expected violation. We propose a general algorithmic framework called **S**afe **UCBVI** (SUCBVI). Specifically, in each episode, we first estimate the transition kernel and cost function in an optimistic manner, tending to regard a state as safe at the beginning of learning. After that, we introduce novel dynamic programming to identify potentially unsafe states and determine safe actions, based on our estimated transition and costs. Finally, we employ the identified safe actions to conduct value iteration. This mechanism can adaptively update dangerous regions, and help the agent plan for the future, which keeps her away from all states that may lead to unsafe states. As our estimation becomes more accurate over time, the safety violation becomes smaller and eventually converges to zero. Note that without the assumption of safe actions, the agent knows nothing about the environment at the beginning. Thus, it is impossible for her to achieve an absolute zero violation. Nevertheless, we show that SUCBVI can achieve a sub-linear \(}()\) cumulative violation or an \(}(S/_{}+S^{2}AH^{2})\) gap-dependent violation that is independent of \(T\). This violation implies that as the RL game proceeds, the agent eventually learns how to avoid unsafe states. We also provide a matching lower bound to demonstrate the optimality of SUCBVI in both violation and regret.

Furthermore, we apply our step-wise safe RL framework to the reward-free exploration (Jin et al., 2020) setting. In this novel safe reward-free exploration, the agent needs to guarantee small step-wise violations during exploration, and also output a near-optimal safe policy. Our algorithm achieves \(\) cumulative step-wise violation during exploration, and also identifies a \(\)-optimal and safe policy. See the definition of \(\)-optimal and \(\)-safe policy in Section 6.1. Another interesting application of our framework is safe zero-sum Markov games, which we discuss in Appendix B.

The main contributions of our paper are as follows.

* We formulate the safe RL with step-wise violation constraint problem (Safe-RL-SW), which models safety as a cost function for states and aims to minimize the cumulative step-wise violation. Our formulation is particularly useful for safety-critical applications where avoiding disastrous situations at each decision step is desirable, e.g., autonomous driving and robotics.
* We provide a general algorithmic framework SUCBVI, which is equipped with an innovative dynamic programming to identify potentially unsafe states and distinguish safe actions. We establish an \(}(SAT})\) regret and an \(}()\) or \(}(S/_{}+S^{2}AH^{2})\) gap-dependent violation guarantees, which exhibits the capability of SUCBVI in attaining high rewards while maintaining small violation.

* We further establish an \(()\) regret and an \(()\) violation lower bounds for Safe-RL-SW. The lower bounds demonstrate the optimality of algorithm SUCBVI in both regret minimization and safety guarantee, with respect to factors \(S\) and \(T\).
* We consider step-wise safety constraints in the reward-free exploration setting, which is called the Safe-RFE-SW problem. In this setting, we design an efficient algorithm SRF-UCRL, which ensures \(\) step-wise violations during exploration and plans a \(\)-optimal and \(\)-safe policy for any reward functions with probability at least \(1-\). We obtain an \(}((AH^{2}}{}+S,A}{ ^{2}})(()+S))\) sample complexity and an \(}()\) violation guarantee for SRF-UCRL, which shows the efficiency of SRF-UCRL in sampling and danger avoidance even without reward signals. To the best of our knowledge, this work is the first to study the step-wise violation constraint in the RFE setting.

## 2 Related Work

Safe RL.Safety is an important topic in RL, which has been extensively studied. The constrained Markov decision process (CMDP)-based approaches handle safety via cost functions, and aim to minimize the expected episode-wise violation, e.g., (Yu et al., 2019; Wachi and Sui, 2020; Qiu et al., 2020; Efroni et al., 2020; Turchetta et al., 2020; Ding et al., 2020; Singh et al., 2020; Kalagarla et al., 2021; Simao et al., 2021; Ding et al., 2021), or achieve zero episode-wise violation, e.g., (Liu et al., 2021; Bura et al., 2021; Wei et al., 2022; Sootla et al., 2022). Apart from CMDP-based approaches, there are also other works that tackle safe RL by control-based approaches (Berkenkamp et al., 2017; Chow et al., 2018; Dalal et al., 2018; Wang et al., 2022), policy optimization (Uchibe and Doya, 2007; Achiam et al., 2017; Tessler et al., 2018; Liu et al., 2020; Stooke et al., 2020) and safety shields (Alshiekh et al., 2018).

In recent years, there are also some works studying step-wise violations with additional assumptions. Now we provide detailed comparisons between existing papers with instantaneous constraints. Turchetta et al. (2016); Wachi et al. (2018) propose a GP-based algorithm, which assumes that the transition is deterministic and known, while modeling the reward and cost functions using Gaussian Processes. By using this particular structure, they can infer the safety cost by estimating the parameters. Wachi et al. (2021) assumes the reward and cost functions have a generalized linear structure. Their algorithm explores in a safe space until a time \(t^{*}\) when the agent explores sufficiently. However, the upper bound of the exploring time \(t^{*}\) is not given in their paper. In fact, under the tabular MDP setting \(t^{*}\) can be infinite.

Amani et al. (2021) further considers the reward and cost functions to have a linear structure. It makes two assumptions: (a) There exists a safe action in each state, which prevents the agent from going to a potentially unsafe state. (b) The feature set is a star convex set, which helps them change actions continuously. However, this makes their works infeasible in tabular MDPs: The feature set in tabular MDPs consists of one-hot vectors and is not a star convex set. Hence, the work Amani et al. (2021) cannot solve our problem. Shi et al. (2023) considers safe RL in linear mixture MDPs. Their work also contains assumption (b), making it infeasible in tabular MDPs. Moreover, although they do not have assumption (a), it assumes the transition set \((s,a)\) is known, which is not needed in our paper. Thus our paper is more challenging since we need to estimate \((s,a)\) in our algorithm adaptively.

There are some other papers investigating the safety of RL problems. Alshiekh et al. (2018) represents the safe state by the reactive system, and uses shielding to calculate and restrict the agent within a safe trajectory completely. The main difference between their work and our work is that we need to dynamically update the estimated safe state, while they require to know the mechanism and state to calculate the shield. Dalal et al. (2018) considers restricting the safe action by projecting the action into the closest safe actions. They achieve this goal by solving a convex optimization problem on the continuous action set. However, in their paper, they do not consider the situation where a state can have no safe actions. To be more specific, they do not consider the situation when the convex optimization problem has no solutions. Le et al. (2019) considers the decision-making problem with a pre-collected dataset. Turchetta et al. (2020) and Sootla et al. (2022) both consider cumulative cost constraints rather than step-wise constraints. The former uses a teacher for intervention to keep the agent away from the unsafe region, while the latter encourages safe exploration by augmenting a safety state to measure safety during training.

Reward-free Exploration with Safety.Motivated by sparse reward signals in realistic applications, reward-free exploration (RFE) has been proposed in Jin et al. (2020), and further developedin Kaufmann et al. (2021); Menard et al. (2021). In RFE, the agent explores the environment without reward signals. After enough exploration, the reward function is given, and the agent needs to plan a near-optimal policy based on his knowledge collected in exploration. Safety is also important in RFE: We need to not only guarantee that our outputted policy is safe, but also ensure small violations during exploration.

Recently, Miryoosefi and Jin (2022); Huang et al. (2022) also study RFE with safety constraints. Compared to our paper, Miryoosefi and Jin (2022) only considers the safety constraint after the exploration phase. Huang et al. (2022) differs from our work in the following aspects: (i) They allow different reward functions during exploration and after exploration, and the agent can directly know the true costs during training. In our work, the cost function is the same during and after exploration, but the agent can only observe the noisy costs of a state when she arrives at that state. (ii) They require prior knowledge of safe baseline policies, while we do not need such an assumption. (iii) They consider the zero-expected violation during exploration, while we focus on keeping small step-wise violations.

## 3 The Safe MDP Model

**Episodic MDP.** In this paper, we consider the finite-horizon episodic Markov Decision Process (MDP), represented by a tuple \((,,H,,r)\). Here \(\) is the state space, \(\) is the action space, and \(H\) is the length of each episode. \(=\{_{h}:_{ }\}_{h[H]}\) is the transition kernel, and \(_{h}(s^{}|s,a)\) gives the transition probability from \((s,a)\) to \(s^{}\) at step \(h\). \(r=\{r_{h}:\}_{h[H]}\) is the reward function, and \(r_{h}(s,a)\) gives the reward of taking action \(a\) in state \(s\) at step \(h\). A policy \(=\{_{h}:\}_{h[H]}\) consists of \(H\) mappings from the state space to action space. In each episode \(k\), the agent first chooses a policy \(^{k}\). At each step \(h[H]\), the agent observes a state \(s^{k}_{h}\), takes an action \(a^{k}_{h}\), and then goes to a next state \(s^{k}_{h+1}\) with probability \(_{h}(s^{k}_{h+1} s^{k}_{h},a^{k}_{h})\). The algorithm executes \(T=HK\) steps. Moreover, the state value function \(V^{}_{h}(s,a)\) and state-action value function \(Q^{}_{h}(s,a)\) for a policy \(\) can be defined as

\[V^{}_{h}(s) :=_{}_{h^{}=h}^{H}r_{h^{}}(s _{h^{}},_{h^{}}(s_{h^{}}))s_{h}=s,\] \[Q^{}_{h}(s,a) :=_{}_{h^{}=h}^{H}r_{h^{}}( s_{h^{}},_{h^{}}(s_{h^{}}))s_{h}=s,a_{h}=a.\]

**Safety Constraint.** To model unsafe regions in the environment, similar to Wachi and Sui (2020); Yu et al. (2022), we define a safety cost function \(c:\). Let \(\) denote the safety threshold. A state is called _safe_ if \(c(s)\), and called _unsafe_ if \(c(s)>\). Similar to Efroni et al. (2020); Amani et al. (2021), when the agent arrives in a state \(s\), she will receive a cost signal \(z(s)=c(s)+\), where \(\) is an independent, zero-mean and 1-sub-Gaussian noise. Denote \((x)_{+}=\{x,0\}\). The violation in state \(s\) is defined as \((c(s)-)_{+}\), and the cumulative step-wise violation till episode \(K\) is

\[C(K)=_{k=1}^{K}_{h=1}^{H}(c(s^{k}_{h})-)_{+}.\] (1)

Eq. (1) represents the accumulated step-wise violation during training. When the agent arrives in state \(s^{k}_{h}\) at step \(h\) in episode \(k\), she will suffer violation \((c(s^{k}_{h})-)_{+}\). This violation setting is significantly different from the previous CMDP setting (Qiu et al., 2020; Ding et al., 2020; Efroni et al., 2020; Ding et al., 2021; Wachi and Sui, 2020; Liu et al., 2021; Kalagarla et al., 2021). They study the _episode-wise expected violation_\(C^{}(K)=_{k=1}^{K}([_{h=1}^{H}c(s^{k}_{h},a^{k }_{h})]-).\) There are also some papers (Efroni et al., 2020; Simao et al., 2021) considering a stricter constraint named _episode-wise clipped expected violation_: \(C^{}(K)=_{k=1}^{K}([_{h=1}^{H}c(s^{k}_{h },a^{k}_{h})]-)_{+}.\) Compared to the episode-wise violation (including expected violation and clipped expected violation), our step-wise violation has two main differences: (i) First, the episode-wise violation constraints allow the agent to get into unsafe states occasionally. Instead, the step-wise violation constraint forces the agent to stay in safe regions at all times. (ii) Second, in the episode-wise constraints, the average violation \([c(s_{h},a_{h})]-/H\) at step \(h\) is allowed to be positive or negative, and they can cancel out in one episode to achieve \([_{h=1}^{H}c(s_{h}^{k},a_{h}^{k})]\). Instead, we consider a _nonnegative_ function \((c(s)-)_{+}\) at each step in our step-wise violation, which imposes a stricter constraint.

Define \(:=\{s c(s)>\}\) as the set of all _unsafe states_. Let \(=\{s_{1},a_{1},,s_{H},a_{H}\}\) denote a trajectory. Since a feasible policy needs to satisfy the constraint at each step, we define the set of feasible policies as \(=\{\{\;h[H],s_{h}\}=0\}\). The feasible policy set \(\) consists of all policies under which one never reaches any unsafe state in an episode.

**Learning Objective.** In this paper, we consider the regret minimization objective. Specifically, define \(^{*}=*{argmax}_{}V_{1}^{}\), \(V^{*}=V^{^{*}}\) and \(Q^{*}=Q^{^{*}}\). The regret till \(K\) episodes is then defined as

\[R(K)=_{t=1}^{K}(V_{1}^{*}(s_{1})-V_{1}^{^{k}}(s_{1})),\]

where \(^{k}\) is the policy taken in episode \(k\). Our objective is to minimize \(R(K)\) to achieve a good performance, and minimize the violation \(C(K)\) to guarantee the safety at the same time.

## 4 Safe RL with Step-wise Violation Constraints

### Assumptions and Problem Features

Before introducing our algorithms, we first state the important assumptions and problem features for Safe-RL-SW.

Suppose \(\) is a feasible policy. Then, if we arrive at \(s_{H-1}\) at step \(H-1\), \(\) needs to select an action that guarantees \(s_{H}\). Define the _transition set_\(_{h}(s,a)=\{s^{}_{h}(s^{} s,a)>0\}\) for any \((s,a,h)[H]\), which represents the set of possible next states after taking action \(a\) in state \(s\) at step \(h\). Then, at the former step \(H-1\), the state \(s\) is potentially unsafe if it satisfies that \(_{H-1}(s,a)\) for all \(a\). (i.e., no matter taking what action, there is a positive probability of transitioning to an unsafe next state). Therefore, we can recursively define the set of _potentially unsafe states at step \(h\)_ as

\[_{h}=_{h+1}\{s\;\;a, _{h}(s,a)_{h+1}\},\] (2)

where \(_{H}=\). Intuitively, if we are in a state \(s_{h}_{h}\) at step \(h\), no action can be taken to completely avoid reaching potentially unsafe states \(s_{h+1}_{h+1}\) at step \(h+1\). Thus, in order to completely prevent from getting into unsafe states \(\) throughout all steps, one needs to avoid potentially unsafe states in \(_{h}\) at step \(h\). From the above argument, we have that \(s_{1}_{1}\) is equivalent to the existence of feasible policies. The detailed proof is provided in Appendix D. Thus, we make the following necessary assumption.

**Assumption 4.1** (Existence of feasible policies).: The initial state \(s_{1}\) satisfies \(s_{1}_{1}\).

For any \(s\) and \(h[H-1]\), we define the set of safe actions for state \(s\) at step \(h\) as

\[A_{h}^{safe}(s)=\{a_{h}(s,a)_{h+1}= \},\] (3)

and let \(A_{H}^{safe}(s)=\). \(A_{h}^{safe}(s)\) stands for the set of all actions at step \(h\) which will not lead to potentially unsafe states in \(_{h+1}\). Here, \(\{_{h}\}_{h[H]}\) and \(\{A_{h}^{safe}(s)\}_{h[H]}\) are defined by dynamic programming: If we know sets of all possible next state \(\{_{h}(s,a)\}_{h[H]}\) and unsafe state set \(=_{H}\), we can calculate all potentially unsafe state sets \(\{_{h}\}_{h[H]}\) and safe action sets \(\{A_{h}^{safe}(s)\}_{h[H]}\), and choose feasible policies to completely avoid unsafe states.

### Algorithm SUCBVI

Now we present our main algorithm **S**afe **UCBVI** (SUCBVI), which is based on previous classic RL algorithm UCBVI (Azar et al., 2017), and equipped with a novel dynamic programming to identify potentially unsafe states and safe actions. The pseudo-code is shown in Algorithm 1. First, we provide some intuitions about how SUCBVI works. At each episode, we first estimate all the unsafe states based on the historical data. Then, we perform a dynamic programming procedure introducedin Section 4.1 and calculate the safe action set \(A_{h}^{safe}(s)\) for each state \(s\). Then, we perform value iteration in the estimated safe action set. As the estimation becomes more accurate, SUCBVI will eventually avoid potentially unsafe states and achieve both sublinear regrets and violations.

Now we begin to introduce our algorithm. In the beginning, we initialize \(_{h}(s,a)=\) for all \((h,s,a)[H]\). It implies that the agent considers all actions to be safe at first, because no action will lead to unsafe states from the agent's perspective. In each episode, we first estimate the empirical cost \((s)\) based on historical cost feedback \(z(s)\), and regard state \(s\) as safe if \((s)=(s)->\) for some bonus term \(\), which aims to guarantee \((s) c(s)\) (Line 4). Then, we calculate the estimated unsafe state set \(_{H}^{k}\), which is a subset of the true unsafe state set \(=_{H}\) with a high probability by optimism. With \(_{H}^{k}\) and \(_{h}^{k}(s,a)\), we can estimate potentially unsafe state sets \(_{h}^{k}\) for all \(h[H]\) by Eq. (2) recursively.

Then, we perform value iteration to compute the optimistically estimated optimal policy. Specifically, for any hypothesized safe state \(s_{h}^{k}\), we update the greedy policy on the estimated safe actions, i.e., \(_{h}^{k}(s)=_{a A_{h}^{safe}(s)}Q_{h}^{k}(s,a)\) (Line 13). On the other hand, for any hypothesized unsafe state \(s_{h}_{h}\), since there is no action that can completely avoid unsafe states, we ignore safety costs and simply update the policy by \(_{h}^{k}(s)=_{a}Q(s,a)\) (Line 15). After that, we calculate the estimated optimal policy \(^{k}\) for episode \(k\), and the agent follows \(^{k}\) and collects a trajectory. Then, we update \(_{h}^{k+1}(s,a)\) by incorporating the observed state \(s_{h+1}^{k}\) into the set \(_{h}^{k}(s_{h}^{k},a_{h}^{k})\). Under this updating rule, it holds that \(_{h}^{k}(s,a)_{h}(s,a)\) for all \((s,a)\).

The performance of Algorithm 1 is summarized below in Theorem 4.2.

**Theorem 4.2**.: _Let \((n,)=7H}\) and \((n,)=(SK/)}\). With probability at least \(1-\), the regret and step-wise violation of Algorithm 1 are bounded by_

\[R(K)=}(SAT}), C(K)=}(+S^{2}AH^{2}).\]_Moreover, if \(_{}_{s}(c(s)-)_{+}>0\), we have \(C(K)=}(S/_{}+S^{2}AH^{2})\)._

Theorem 4.2 shows that SUCBVI achieves both sublinear regret and violation. Moreover, when all the unsafe states have a large cost compared to the safety threshold \(\), i.e., \(_{}=_{s}(c(s)-)_{+}>0\) is a constant, we can distinguish the unsafe states easily and get a constant violation. In particular, when \(=1\), Safe-RL-SW degenerates to the unconstrained MDP and Theorem 4.2 maintains the same regret \(}(SAT})\) as UCBVI-CH (Azar et al., 2017), while CMDP algorithms (Efroni et al., 2020; Liu et al., 2021) suffer a larger \(}(S^{3}AT})\) regret.

We provide the analysis idea of Theorem 4.2 here. First, by the updating rule of \(_{h}^{k}(s,a)\), we show that \(_{h}^{k}\) and \(A_{h}^{k,safe}(s)\) have the following crucial properties: \(_{h}^{k}_{h},\ \ A_{h}^{safe}(s) A_{h}^{k,safe}(s)\). Based on this property, we can prove that \(Q_{h}^{*}(s,a) Q_{h}^{k}(s,a)\) and \(V_{h}^{*}(s) V_{h}^{k}(s)\) for all \((s,a)\), and then apply the regret decomposition techniques to derive the regret bound.

Recall that \(^{k}\) is a feasible policy with respect to the estimated unsafe state set \(_{H}^{k}\) and transition set \(\{_{h}^{k}(s,a)\}_{h[H]}\). If the agent takes policy \(^{k}\) and the transition follows \(_{h}^{k}(s,a)\), i.e., \(s_{h+1}^{k}_{h}^{k}(s,a)\), the agent never arrive any estimated unsafe state \(s_{H}^{k}\) in this episode. Hence the agent will suffer at most an \(}()\) step-wise violation or an \(}(S/_{}+S^{2}AH^{2})\) gap-dependent bounded violation. Yet, the situation \(s_{h+1}_{h}^{k}(s,a)\) does not always hold for all \(h[H]\). In the case when \(s_{h+1}^{k}_{h}^{k}(s,a)\), we add the newly observed state \(s_{h+1}^{k}\) into \(_{h}^{k+1}(s_{h}^{k},a_{h}^{k})\) (Line 21). We can show that this case appears at most \(S^{2}AH\) times, and thus incurs \(O(S^{2}AH^{2})\) additional violation. Combining the above two cases, the total violation can be upper bounded.

## 5 Lower Bounds for Safe-RL-SW

In this section, we provide a matching lower bound for Safe-RL-SW in Section 4. The lower bound shows that if an algorithm always achieves a sublinear regret in Safe-RL-SW, it must incur an \(()\) violation. This result matches our upper bound in Theorem 4.2, showing that SUCBVI achieves the optimal violation performance.

**Theorem 5.1**.: _If an algorithm has an expected regret \(_{}[R(K)]\) for all MDP instances, there exists an MDP instance in which the algorithm suffers expected violation \(_{}[C(K)]=()\)._

Now we validate the optimality in terms of regret. Note that if we do not consider safety constraints, the lower bound for classic RL (Osband and Van Roy, 2016) can be applied to our setting. Thus, we also have an \(()\) regret lower bound. To understand the essential hardness brought by safety constraints, we further investigate whether safety constraints will lead to an \(()\) regret, given that we can achieve an \(o()\) regret on some good instances without the safety constraints.

**Theorem 5.2**.: _For any \((0,1)\), there exists a parameter \(n\) and \(n\) MDPs \(M_{1},,M_{n}\) satisfying that:_

_1. If we do not consider any constraint, there is an algorithm that achieves an \(}(T^{(1-)/2})\) regret compared to the unconstrained optimal policy on all MDPs._

_2. If we consider the safety constraint, any algorithm with a \(O(T^{1-})\) expected violation will achieve an \(()\) regret compared to the constrained optimal policy on one of MDPs._

Intuitively, Theorem 5.2 shows that if one achieves sublinear violation, she must suffer at least an \(()\) regret even if she can achieve an \(o()\) regret without considering constraints. This theorem demonstrates the hardness particularly brought by the step-wise constraint, and corroborates the optimality of our results. Combining with Theorem 5.1, the two lower bounds show an essential trade-off between the violation and performance.

## 6 Safe Reward-Free Exploration with Step-wise Violation Constraints

### Formulation of Safe-RFE-SW

In this section, we consider Safe RL in the reward-free exploration (RFE) setting (Jin et al., 2020; Kaufmann et al., 2021; Menard et al., 2021) called Safe-RFE-SW, to show the generality of our proposed framework. In the RFE setting, the agent does not have access to reward signals and only receives random safety cost feedback \(z(s)=c(s)+\). To impose safety requirements, Safe-RFE-SW requests the agent to keep small safety violations during exploration, and outputs a near-optimal safe policy after receiving the reward function.

**Definition 6.1** (\((,)\)-optimal safe algorithm for Safe-RFE-SW).: An algorithm is \((,)\)-optimal safe for Safe-RFE-SW if it outputs the triple \((},(s,a),}_{H})\) such that for any reward function \(r\), with probability at least \(1-\),

\[V_{1}^{*}(s_{1};r)-V_{1}^{^{*}}(s_{1};r),_{}[_{h=1}^{H}(c(s_{h})-)_{+}],\ \ \] (4)

where \(^{*}\) is the optimal feasible policy with respect to \((},(s,a),}_{H},r)\), \(\) is the set of feasible policies with respect to \(((s,a),_{H})\). and \(V(s;r)\) is the value function under reward function \(r\). We say that a policy is _\(\)-optimal_ if it satisfies the left inequality in Eq. (4) and _\(\)-safe_ if it satisfies the right inequality in Eq. (4). We measure the performance by the number of episodes used before the algorithm terminates, i.e., _sample complexity_. Moreover, the cumulative step-wise violation till episode \(K\) is defined as \(C(K)=_{k=1}^{K}_{h=1}^{H}(c(s_{h}^{k})-)_{+}\). In Safe-RFE-SW, our goal is to design an \((,)\)-optimal safe algorithm, and minimize both sample complexity and violation.

### Algorithm SRF-UCRL

The Safe-RFE-SW problem requires us to consider extra safety constraints for both the exploration phase and final output policy, which needs new algorithm design and techniques compared to previous RFE algorithms. Also, the techniques for Safe-RL-SW in Section 4.2 are not sufficient for guaranteeing the safety of output policy, because SUCBVI only guarantees a step-wise violation during exploration.

We design an efficient algorithm **S**afe **RF-UCRL** (SRF-UCRL), which builds upon previous RFE algorithm RF-UCRL (Kaufmann et al., 2021). SRF-UCRL distinguishes potentially unsafe states and safe actions by backward iteration, and establishes a new uncertainty function to guarantee the safety of output policy. Algorithm 2 illustrates the procedure of SRF-UCRL. Specifically, in each episode \(k\), we first execute a policy \(_{h}^{k}\) computed from previous episodes, and then update the estimated next state set \(\{_{h}^{k}(s,a)\}_{h[H]}\) and unsafe state set \(_{H}^{k}\) by optimistic estimation. Then, we use Eq. (2) to calculate the unsafe state set \(_{h}\) for all steps \(h[H]\). After that, we update the uncertainty function \(^{k}\) defined in Eq. (5) below and compute the policy \(^{k+1}\) that maximizes the uncertainty to encourage more exploration in the next episode.

Now we provide the definition of the _uncertainty function_, which measures the estimation error between the empirical MDP and true MDP. For any safe state-action pair \(s_{h},a A_{h}^{k,safe}(s)\), we define

\[_{h}^{k}(s,a)=\{H,M(N_{h}^{k}(s,a),)+_{s^{ }}}_{h}^{k}(s^{} s,a)_{b A_{h+1}^{k,a }(s^{})}_{h+1}^{k}(s^{},b)\}.\] (5)

\[M(N_{h}^{k}(s,a),)=2H^{k}(s,a), )}{N_{h}^{k}(s,a)}}+^{k}(s,a),)}{N_{h}^{k}(s,a )},(n,)_{h+1}^{k,safe}(s^{})\) to \(b\) in the \(\) function. Our algorithm stops when \(_{1}^{K}(s_{1},^{K}(s_{1}))\) shrinks to within \(/2\). Compared to previous RFE works (Kaufmann et al. (2021); Menard et al. (2021)), our uncertainty function has two distinctions. First, for any safe state-action pair \((s,a)(_{h},A_{h}^{k,safe}(s))\), Eq. (5) considers only safe actions \(A_{h+1}^{k,safe}(s)\), which guarantees that the agent focuses on safe policies. Second, Eq. (5) incorporates another term \((SH(N_{h}^{k}(s,a),)/N_{h}^{k}(s,a))\) to control the expected violation for feasible policies. Now we present our result for Safe-RFE-SW.

**Theorem 6.2**.: _Let \((n,)=2((2SAH/)+(S-1)(e(1+n/(S-1)))\), Algorithm 2 is a \((,)\)-PAC algorithm with sample complexity at most2_

\[K=}((AH^{2}}{}+SA}{^{2}})(()+S) ),\]

_The step-wise violation of Algorithm 2 during exploration is \(C(K)=}(S^{2}AH^{2}+)\)._

Compared to previous work (Kaufmann et al., 2021) with an \(}((H^{4}SA/^{2})((1/)+S))\) sample complexity, our result has an additional term \(}((S^{2}AH^{2}/)((1/)+S))\). This term is due to the additional safety requirement for the final output policy, which was not considered in previous RFE algorithms (Kaufmann et al., 2021; Menard et al., 2021). When \(\) and \(\) are sufficiently small, the leading term is \(}((H^{4}SA/^{2})(1/))\), which implies that our algorithm satisfies the safety constraint without suffering additional regret.3

### Analysis for Algorithm SRF-UCRL

For the analysis of step-wise violation (Eq. (1)), similar to algorithm SUCBVI, algorithm SRF-UCRL estimates the next state set \(_{h}(s,a)\) and potentially unsafe state set \(_{h}\), which guarantees a \(}()\) step-wise violation. Now we give a proof sketch for the \(\)-safe property of output policy (Eq. (4)).

First, if \(\) is a feasible policy for \((}^{k},^{k}(s,a),\{_{h}^{k}\}_{h[H]})\) and \(s_{h+1}_{h}^{K}(s_{h},a_{h})\) for all \(h[H]\), the agent who follows policy \(\) will only visit the estimated safe states. Since each estimated safe stateonly suffers a \((1/(s_{h},_{h}(s_{h}))})\) violation, the violation led by this situation is bounded by \(_{1}^{k}(s,_{1}(s_{1}))\). Next, we bound the probability that \(s_{h+1}_{h}^{K}(s_{h},a_{h})\) for some step \(h[H]\). For any state-action pair \((s,a)\), if there is a probability \((s^{} s,a)}((S/)/N_{h }^{K}(s,a))\) that the agent transitions to next state \(s^{}\) from \((s,a)\) at step \(h\), the state \(s^{}\) is put into \(_{h}^{K}(s,a)\) with probability at least \(1-/S\). Then, we can expect that all such states are put into our estimated next state set \(_{h}^{K}(s,a)\). Thus, the probability that \(s_{h+1}_{h}^{K}(s_{h},a_{h})\) is no larger than \(}((S/)/N_{h}^{K}(s,a))\) by a union bound over all possible next states \(s^{}\). Based on this argument, \(_{h}^{k}(s_{h},a_{h})\) is an upper bound for the total probability that \(s_{h+1}_{h}^{K}(s_{h},a_{h})\) for some step \(h\). This will lead to additional \(_{1}^{K}(s_{1},_{1}(s_{1}))\) expected violation. Hence the expected violation of output policy is upper bounded \(2_{1}^{K}(s_{1},_{1}^{K}(s_{1}))\). The complete proof is provided in Appendix A.

## 7 Experiments

In this section, we provide experiments for Safe-RL-SW and Safe-RFE-SW to validate our theoretical results. For Safe-RL-SW, we compare our algorithm SUCBVI with a classical RL algorithm UCBVI (Azar et al., 2017) and three state-of-the-art CMDP algorithms OptCMDP-bonus (Efroni et al., 2020), Optpess (Liu et al., 2021) and Triple-Q (Wei et al., 2022). For Safe-RFE-SW, we report the average reward in each episode and cumulative step-wise violation. For Safe-RFE-SW, we compare our algorithm SRF-UCRL with a state-of-the-art RFE algorithm RF-UCRL (Kaufmann et al., 2021). We do not plot the regret because unconstrained MDP or CMDP algorithms do not guarantee step-wise violation. Applying them to the step-wise constrained setting can lead to negative or large regret and large violations, making the results meaningless. Detailed experiment setup is in Appendix E.

As shown in Figure 1, the rewards of SUCBVI and SRF-UCRL converge to the optimal rewards under safety constraints (denoted by "safe optimal reward"). In contrast, the rewards of UCBVI and UCRL converge to the optimal rewards without safety constraints (denoted by "unconstrained optimal reward"), and those of CMDP algorithms converge to a policy with low expected violation (denoted by "constrained optimal reward"). For Safe-RFE-SW, the expected violation of output policy of SRF-UCRL converges to zero while that of RF-UCRL does not. This corroborates the ability of SRF-UCRL in finding policies that simultaneously achieve safety and high rewards.

## 8 Conclusion

In this paper, we investigate a novel safe reinforcement learning problem with step-wise safety constraints. We first provide an algorithmic framework SUCBVI to achieve both an \(}(SAT})\) regret and an \(}()\) step-wise or an \(}(S/_{}+S^{2}AH^{2})\) gap-dependent bounded violation that is independent of \(T\). Then, we provide two lower bounds to validate the optimality of SUCBVI in both violation and regret in terms of \(S\) and \(T\). Further, we extend our framework to the safe RFE with a step-wise violation and provide an algorithm SRF-UCRL that identifies a near-optimal safe policy given any reward function \(r\) and guarantees an \(}()\) violation during exploration.

Figure 1: Experimental results for Safe-RL-SW and Safe-RFE-SW. The left two figures show the average rewards and step-wise violations of algorithms SUCBVI, UCBVI (Azar et al., 2017), OptCMDP-bonus (Efroni et al., 2020), Triple-Q (Wei et al., 2022) and Optpess (Liu et al., 2021). The right two figures show the reward and expected violation of the policies outputted by algorithms SRF-UCRL and RF-UCRL (Kaufmann et al., 2021).