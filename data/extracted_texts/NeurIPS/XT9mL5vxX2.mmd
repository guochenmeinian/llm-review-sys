# Multitask Learning for Face Forgery Detection: A Joint Embedding Approach

Anonymous Author(s)

Affiliation

Address

email

###### Abstract

Multitask learning for face forgery detection has experienced impressive successes in recent years. Nevertheless, the semantic relationships among different forgery detection tasks are generally overlooked in previous methods, which weakens knowledge transfer across tasks. Moreover, previously adopted multitask learning schemes require human intervention on allocating model capacity to each task and computing the loss weighting, which is bound to be suboptimal. In this paper, we aim at automated multitask learning for face forgery detection from a joint embedding perspective. We first define a set of coarse-to-fine face forgery detection tasks based on face attributes at different semantic levels. We describe the ground-truth for each task via a textural template, and train two encoders to jointly embed visual face images and textual descriptions in the shared feature space. In such a manner, the semantic closeness between two tasks is manifested as the distance in the learned feature space. Moreover, the capacity of the image encoder can be automatically allocated to each task through end-to-end optimization. Through joint embedding, face forgery detection can be performed by maximizing the feature similarity between the test face image and candidate textual descriptions. Extensive experiments show that the proposed method improves face forgery detection in terms of generalization to novel face manipulations. In addition, our multitask learning method renders some degree of model interpretation by providing human-understandable explanations.

## 1 Introduction

The emergence of deep generative models [1; 34; 67; 71] has significantly simplified and automated the process of generating realistic counterfeit face images, popularly known as DeepFake. The prevalence of falsified face images can erode the reliability and credibility of digital visual information. Additionally, the exploitation and manipulation of such technologies pose a threat to individual rights and national security.

Traditional DeepFake detectors were largely influenced by classic photo forensics  to expose forgery traces by examining statistical anomalies [51; 58], visual artifacts [32; 46; 50; 51; 59], and physical and geometric inconsistencies [15; 33; 35; 56]. With the rapid development of deep learning, there has recently been a growing consensus on exploiting multitask learning for face forgery detection [8; 10; 19; 41; 55; 80; 81]. The underlying assumption is that the primary task (_i.e._, global face forgery classification) is likely to benefit from other highly relevant auxiliary tasks through knowledge transfer. Representative auxiliary tasks include manipulation type (and degree) classification , manipulation parameter estimation , blending boundary detection , spatial forgery localization , face reconstruction , and face segmentation .

The prevailing multitask learning paradigm for face forgery detection follows a discriminative approach, predicting multiple target outputs, one for each task, directly from the input face image. Such a paradigm suffers from two main drawbacks. First, semantic relationships across tasks are overlooked, which weakens knowledge transfer. For example, irrelevant information (_e.g._, every detail of the face image in face reconstruction ) may be transferred across tasks. Second, extensive human expertise should be involved, when determining task-agnostic (and task-specific) model parameters and the loss weightings.

In this paper, we explore multitask learning for face forgery detection from a joint embedding perspective . In the joint embedding architecture, both the input and the target output are encoded into latent representations in the shared feature space such that the irrelevant information can be discarded from feature encoding. More importantly, the semantic closeness between two tasks can be naturally modeled as the distance in the learned feature space, which is subsequently end-to-end optimized to facilitate knowledge transfer across multiple tasks. Meanwhile, joint embedding gives us a great opportunity to automate multitask learning in terms of allocating model capacity (_i.e._, specifying task-agnostic and task-specific model parameters). In the context of face forgery detection, the parameters of the face image encoder are shared across all tasks, whose capacity is dynamically adjusted through end-to-end optimization. In addition, the multitask loss weightings can be automatically computed in either theoretical [45; 65] or empirical [13; 36; 47] ways.

More concretely, we first introduce three coarse-to-fine face forgery detection tasks based on face attributes at different semantic levels. Leveraging the recent advances in vision-language correspondence as joint embedding , we encode the binary labels of the three tasks via textural prompts, and thus the semantic dependencies among tasks can be represented with the textual embeddings in the representation space. Fig. 1 shows an example, in which we describe a fake face image with a set of coarse-to-fine textual descriptions: 1) "_A photo of a fake face_," 2) "_A photo of a face with the global attribute of expression altered_," and 3) "_A photo of a face with the local attribute of mouth altered_." By jointly embedding the face image and all its associated textural prompts through a popular vision-language model - CLIP , face forgery detection can then be performed by maximizing the vision-language correspondence.

**Our contributions** are threefold. First, we formulate multitask face forgery detection from a joint embedding perspective. Second, we define a set of coarse-to-fine face forgery detection tasks with corresponding textural templates to describe (fake) face images. Compared to previous multitask learning schemes, our instantiation gives rise to a more interpretable face forgery detector. Third, we conduct extensive experiments on five popular face forgery detection datasets, and show that our method performs favorably against state-of-the-art (SOTA) detectors in terms of generalization to novel face manipulations.

## 2 Related Work

In this section, we briefly review the literature on face forgery detection, multitask learning, and joint embedding architectures.

### Face Forgery Detection

Many face forgery detection methods usually explore the specific clues to detect the forgery inspired by the traditional photo forensics [15; 32; 33; 35; 46; 50; 51; 56], in which they detect eye blinking , head pose , pupil shape , lipreading , statistical anomalies [43; 60; 66; 81], corneal specularity , and idiosyncratic behavioral patterns of a well-known person . In recent years, there is a growing consensus of exploiting multitask learning on face forgery detection [8; 10; 41; 55; 81]. Besides the main face forgery classification task, these methods include auxiliary tasks to get performance improvement by knowledge transfer across tasks, such as manipulation type (and degree) classification , manipulation parameter estimation , blending boundary detection , spatial forgery localization , face reconstruction , and face segmentation .

Figure 1: Illustration of a fake face image with its textural descriptions of three coarse-to-fine face forgery detection tasks at different semantic levels.

With the development of deep learning, some advanced networks are employed to facilitate the face forgery detection based on multiple tasks, such as two-stream CNN , self-attention model , and vision transformers . Additionally, more advanced training strategies are also utilized to enhance the forgery detectors, including adversarial learning , reconstruction learning , and meta learning . However, the previous learning paradigm and human intervention are sub-optimal for multitask learning on face forgery detection. In this paper, we explore an automated multitask learning method for face forgery detection from the joint embedding perspective, where multiple tasks are encoded into the language prompts, and vision-language correspondence is transferred across tasks as the primary knowledge.

### Multitask Learning

Multitask learning aims to jointly learn multiple related tasks to improve the generalization performance of all tasks by leveraging the knowledge contained in each . Two main groups are model parameter sharing and loss weighting. The former involves both manual specifications of shared parameters  and learning to determine parameters for specific tasks . Loss weighting is typically divided as follows: Pareto Optimization (PO) methods and weight adaption methods. PO methods formulate multitask learning as a multi-objective optimization , and find a Pareto stationary solution for the optimal loss weighting. Weight adoption methods adaptively adjust the loss weights during training based on pre-defined heuristics, such as uncertainty , gradient normalization , and loss descending rate . In this paper, we consider multitask learning from the joint embedding perspective, in which the semantic closeness between tasks can be manifested as the distance in the learned feature space. Moreover, we assume all parameters in the image encoder are shared, whose capacity is dynamically allocated to each task during end-to-end optimization. We also adopt the method in  for dynamic loss weighting.

### Joint Embedding Architectures

Joint embedding architectures (JEA)  aim at learning to output similar embeddings for compatible inputs, \(x\) and \(y\), and dissimilar embeddings for incompatible inputs, which is different from the discriminative approaches that predict \(y\) directly from \(x\). Becker _et al._ propose the first JEA for maximizing mutual information between representations from two views of the same scene. Later on, Bromley _et al._ propose a contrastive method of JEA for signatures verification. After a long hiatus, JEA has been re-explored in face verification  and recognition , dimensionality reduction , and video feature learning . With the emergence of self-supervised learning, the use of JEA has explored in recent years with methods training on contrastively (_e.g._, PIRL , MoCo , and SimCLR ) or non-contratively (_e.g._, BYOL , Barlow Twins , and I-JPEA ). More recently, the emerging vision-language foundation models  can also be grouped into JEA, in which two separate encoders encode the compatible visual (_i.e._, \(x\)) and textual (_i.e._, \(y\)) inputs into similar embeddings and contrast incompatible visual and textual embeddings. In this paper, we use CLIP , a joint vision-language model pretrained on massive image-text pairs, to implement the JEA to aid DeepFake detection by vision-language correspondence in the embedding space. Moreover, we end-to-end fine-tune the CLIP in the context of automated multitask learning.

## 3 Method

In this section, we present multitask learning for face forgery detection using a joint embedding approach, including preliminaries of the problem formulation, language prompts over multiple tasks, and specifications of loss functions. The main joint embedding framework for face forgery detection is shown in Fig. 2.

### Preliminaries

Given a face image \(^{N}\), a face forgery detector \(f_{}:^{N}\) aims to predict a binary label \(y\) for the authenticity of \(\), _i.e._, \(0\) as the real or \(1\) as the fake. Considering that existing forged face images are mainly generated by modifying face components/attributes, we include two other related tasks - global face manipulation detection and local face manipulation detection. We consider three face attributes (_i.e._, expression, identity, and physical consistency1) for global face manipulations, and four face attributes (_i.e._, eye, illumination, mouth, and nose) for local face manipulations. Notably, a face image may contain multiple attribute labels.

### Multitask Language Prompts

For each face attribute label from multiple tasks, we encode the ground-truth labels via language prompts. In specific, we design textual templates as follows. 1) **binary level**: _a photo of a \(\{c\}\) face_, where \(c=\{\}\); 2) **global-attribute level**: _A photo of a face with the global attribute of \(\{g\}\) altered_, where \(g=\{\}\); and 3) **local-attribute level**: _A photo of a face with the local attribute of \(\{l\}\) altered_, where \(l=\{\}\). Inspired by contrastive methods [27; 53] in the joint embedding architecture, we also introduce contrastive language prompts, which are opposite in meaning to the original textual templates. Thus, we can have a contrastive prompts pair for each attribute label, as follows: **global-attribute level**: \(\{\)(1) _A photo of a face with the global attribute of \(\{g\}\) altered_, (2) _A photo of a face with the global attribute of \(\{g\}\) unaltered_\(\}\); **local-attribute level**: \(\{\)(1) _A photo of a face with the local attribute of \(\{l\}\) altered_, (2) _A photo of a face with the local attribute of \(\{l\}\) unaltered_\(\}\). Notably, the binary level prompts naturally have the property of contrastive prompt pairing. In this way, multiple tasks are encoded into a text corpus \(\), where each language prompt represents a ground-truth label \(y\) of the corresponding task, and their semantic closeness can be learned through joint embedding.

### Multitask Learning via Joint Embedding

**Joint Embedding Formulation**. Given the input face image \(\) and the set of possible outputs \(\), we predict the output by minimizing an energy-based model , _i.e._, \(=*{arg\,min}_{y}E(,y)\), in the joint embedding architecture. In this paper, we construct \(E\) by two encoders: one image encoder \(_{}:^{N}^{K}\) for encoding the face image and one text encoder \(_{}:^{K}\) for encoding the language prompts, parameterized by \(\) and \(\), respectively.

The ideal energy landscape of joint embedding satisfies that the energy is low for similar embeddings of compatible inputs, while energy is high for dissimilar embeddings . Thus, we calculate the probability of similarity \((|)\) between the visual embedding and textual embeddings for the following optimization. Let \(^{K}\) be the visual embedding, and let \(^{K}\) and \(}^{K}\) be the textual embeddings from the two prompts opposing in meaning, we then estimate \((|)\) as

\[(|)=)}},\] (1)

where

\[s=,}{\|\|\|\|} =,}}{\|\|\| }\|}.\] (2)

Figure 2: Proposed joint embedding paradigm for multitask face forgery detection.

\(,\) denotes the inner product and \(\|\|\) represents the \(_{2}\)-norm. The probability \((|)\) is the abbreviation of \((c|)\), \((g|)\), and \((l|)\) according to a specific task, and a larger probability indicates a closer match to the corresponding semantic meaning of \(\).

**Losses for Multitask Learning**. We use the statistical distance measure in the form of fidelity loss  to calculate the losses for multitask learning. Given the predicted category probability \((c|)\), we design the loss at the **binary level** as

\[_{1}(;)=1-)(c|)}-))(1-(c|))},\] (3)

where \(=\{,\}\) indicates the learnable parameters in image and language encoders, and \(p(c|)=1\) if \(\) belongs to the \(c\) category or otherwise we have \(p(c|)=0\). In our setting, a face image can be assigned with labels regarding one or more global face attribute manipulations, which forms a typical multi-label classification problem. Therefore, the averaged loss at the **global-attribute level** can be defined as follows,

\[_{2}(;)=|}_{g} 1-)(g|)}-))(1- (g|))},\] (4)

where \(p(g|)=1\) if \(\) belongs to the \(g\) category, otherwise we have \(p(g|)=0\). Since the manipulations over different local face attributes may appear in one face image, we also consider it as a multi-label classification task, and the loss at the **local-attribute level** is:

\[_{3}(;)=|}_{l} 1-)(l|)}-))(1-(l|))},\] (5)

where \(p(l|)=1\) if \(\) belongs to the \(l\) category.

Given a minibatch of training data \(\) at the \(t\)-th iteration, we evaluate the overall loss function via the weighted sum of the individual losses in different levels as follows,

\[(,t;)=|}_{ }_{1}(t)_{1}(;)+_{2}(t) _{2}(;)+_{3}(t)_{3}(;).\] (6)

Here, the weighting vector \((t)=[_{1}(t),_{2}(t),_{3}(t)]^{}\) at the \(t\)-th iteration is automatically computed according to the relative descending rate :

\[_{i}(t)=(t-1)/)}}{_{j=1}^{3}(t-1)/ )}},\,\,w_{i}(t-1)=(t-1)}{_{i}(t-2)},\] (7)

and \(\) is a fixed temperature parameter.

## 4 Experiments

### Experimental Setup

**Datasets.** We adopt the widely used FF++  dataset for training. It contains \(1,000\) real videos, among which \(720\) and \(140\) are used for training and validation, respectively, and the remaining \(140\) are reserved for testing. All videos are manipulated by four face grogery methods, including Deepfakes , Face2Face , FaceSwap , and NeuralTextures , with three compression levels, _i.e._, no compression (denoted as Raw), slight compression with quantization parameter \(=23\) (denoted as \(23\)), and severe compression with \(=40\) (denoted as \(40\)). Following [10; 11; 26], \(23\) version is adopted by default in our experiments. We evaluate the generalizability of the proposed method on four popular DeepFake benchmarks, including FaceShifter (FSh) , Celeb-DF (CDF) , DeeperForensics-1.0 (DF-1.0) , and DeepFake Detection Challenge (DFDC) .

**Implementation Details.** To facilitate the multitask learning via joint embedding paradigm, we need face images associated with the proposed textual templates. In this paper, we adopt FF++  to enrich the training data. Following the general generation procedures (_i.e._, detecting face and then blending two faces according to the region-of-interest mask) in [10; 41], we focus on supplementing the tampering of "expression" on "eye" and individual face attribute that is linked to "physical consistency", _i.e._, "eye", "illumination", "mouth", and "nose". Face attribute manipulations associated with other textual prompts are already included in FF++.

As for face pre-processing, we use RetinaFace  to detect faces and save the aligned face images as input with a size of \(317 317\). As in , we only extract the largest face and use an enlarged crop, \(1.3\) the tight crop produced by the face detector.

As for the training, we use CLIP  to implement the joint embedding architecture, where we adopt ViT-B/32  as the visual encoder and GPT-2  with a base size of \(63\)M-parameter as the text encoder. We then train the model by minimizing the loss using AdamW  with a decoupled weight decay of \(1 10^{-3}\). The initial learning rate is set to \(1 10^{-7}\), which changes following a cosine annealing schedule . The model is optimized for \(36\) epochs with mini-batches of \(32\). Data augmentation strategy is also applied during training, which is a common trick in the face forgery detection , and details can be found in Sec. 4.3. A single NVIDIA RTX \(3090\) GPU is used during training.

### Comparison with SOTA Methods

We compare our method with the several SOTA methods, including Face X-ray , PCL , MADD , LipForensics , RECCE , SBI , ICT , SLADD , and OST , to demonstrate its superiority. The test performance on five datasets are listed in Table 1. Table 1 shows that many methods do not perform satisfactorily on the training set of FF++ (or its augmented versions) and tested on the test set of FF++ and other four independent datasets. The evaluation metric we adopt is AUC (%). In the last column are the mean AUC numbers over datasets including / excluding the FF++ test set to emphasize cross-dataset generalization performance. The best results are highlighted in bold.

### Robustness Analysis

In this subsection, we study the robustness performance of the proposed method. Following , we consider four popular perturbations (_i.e._, Patch Substitution (Patch-Sub), additive white Gaussian Noise contamination (Noise), Gaussian Blurring (Blur), and pixelation), and only four severity levels

   Method & FF++ & CDF & FSH & DF-1.0 & DFDC & Mean AUC \\  Face X-ray  & 98.37 & 80.43 & 92.80 & 86.80 & 65.50 & 84.78 / 81.38 \\ PCL  & 99.11 & 81.80 & – & **99.40** & 67.50 & 86.95 / 82.90 \\ MADD  & 98.97 & 77.44 & 97.17 & 66.58 & 67.94 & 81.62 / 77.28 \\ LipForensics  & **99.90** & 82.40 & 97.10 & 97.60 & 73.50 & 89.54 / 87.65 \\ RECCE  & 99.32 & 68.71 & 70.58 & 74.10 & 69.06 & 76.35 / 70.61 \\ SBI  & 99.64 & **93.18** & 97.40 & 77.70 & 72.42 & 88.07 / 85.18 \\ ICT  & 90.22 & 85.71 & 95.97 & 93.57 & 76.74 & 88.44 / 88.00 \\ SLADD  & 98.40 & 79.70 & – & 77.80 & 76.05 & 82.99 / 77.85 \\ OST  & 98.20 & 74.80 & – & 93.08 & 77.73 & 84.95 / 81.87 \\  Ours & 98.49 & 89.02 & **98.68** & 93.38 & **82.06** & **92.33 / 90.79** \\   

Table 1: **Comparison results with the SOTA**. All models are developed using the training set of FF++ (or its augmented versions) and tested on the test set of FF++ and other four independent datasets. The evaluation metric we adopt is AUC (%). In the last column are the mean AUC numbers over datasets including / excluding the FF++ test set to emphasize cross-dataset generalization performance. The best results are highlighted in bold.

(_i.e._, from level \(1\) to level \(4\)) are considered in the experiments2. Two different models are evaluated in this section, _i.e._, our model training without data augmentation (denoted as Ours (w/o Aug)) and our model training with data augmentation strategy (denoted as Ours). In specific, when training with data augmentation strategy, each training data is augmented with a probability of \(0.3\) by one randomly chosen perturbation during training, in which severity level is randomly applied at level \(1\) or \(2\).

To begin, we first evaluate the robustness for the model without data augmentation. We find that the CLIP-based model is sensitive to the perturbations to images, which we argue that the vision-language correspondence is corrupted by perturbations. We then evaluate the model training with data augmentation. In Table 2, we find that training with a slight data augmentation can alleviate the model sensitivity to the perturbations, and achieve a satisfactory performance on average. Moreover, the model of Ours also maintains a satisfactory performance on pixelation and Blur. It is noteworthy that CNND  and Face X-ray  also augment their training data by compression and blurring during training, thus leading to good robustness to perturbations of pixelation and Blur. Fig. 3 demonstrates the effect of increasing the severity for each perturbation, where we compare with Xception , CNND, PatchForensics , Face X-ray, and LipForensics . It can be observed that the proposed method maintains a good performance against the perturbations by Patch-Sub and Noise, while other methods suffer from the Noise, and LipForensics also suffers from the Patch-Sub.

### Ablation Studies

**Joint Embedding Framework.** We conducted a series of ablations to verify the instantiated joint embedding framework by CLIP . We first (1) evaluate the pretrained CLIP, and then (2) fine-tune it with the frozen text encoder on FF++ . The following ablations adopt the same training procedure, while differing in two alternatives: (3) using equal task weights for multiple tasks instead of dynamic loss weighting; (4) training without the contrastive prompt pairs, _i.e._, no contrastive textual descriptions are used during training. From Table 3, we can observe that freezing language encoder negatively affects the generalization performance, which we believe is because forgery-related concepts have not been sufficiently captured during the pretraining stage of CLIP. We also find that utilizing contrastive prompts can improve generalization, further indicating the contrasting

   Method & Clean AUC & Patch-Sub & Noise & Blur & Pixelation & Mean AUC & Drop Rate \\  Face X-ray  & \(98.37\) & **97.72** & 51.13 & 88.98 & 92.33 & 82.54 & -16.09\% \\ CNND  & \(99.56\) & 96.25 & 57.25 & 92.61 & 90.10 & 84.05 & -15.58\% \\ LipForensics  & \(99.90\) & 88.63 & 80.00 & **96.62** & **96.63** & **90.47** & -9.44\% \\  Ours (w/o Aug) & \(98.66\) & 92.47 & 73.12 & 55.20 & 57.17 & 69.49 & -29.57\% \\ Ours & \(98.49\) & 97.65 & **82.85** & 87.31 & 90.70 & 89.63 & **-8.99**\% \\   

Table 2: **Robustness results to low-level image perturbations**, including patch substitution (Patch-Sub), Gaussian noise contamination (Noise), Gaussian blurring (Blur), and pixelation. We constrain the robustness evaluation on the perturbation levels that do not noticeably distort the main face semantics.

Figure 3: Robustness results in terms of AUC. Models are trained on the train set of FF++ and tested on perturbed test sets. Zoom in for clearer comparison.

operation can benefit the joint embedding methods [12; 27]. Moreover, including the dynamic loss weighting scheme is advantageous as it not only yields a slight improvement compared to using equal task weights but also frees us from the burdensome task of hyper-parameter tuning.

**Textual Templates.** In this subsection, we investigate how the textual template design affects the model performance. We try three different alternatives from single task to three tasks: (5) binary-level text templates, _i.e._, single task formulation only considering the label of real or fake; (6) two-level separate text templates, _i.e._, two-level-task formulation, where we consider the separate templates describing the overall authenticity and global face attributes; and (7) the joint text templates putting together labels from three tasks, _e.g._, "A _photo of a {fake} face with the global attribute of {expression} and the local attribute of {mouth} are altered_". The joint probability over multiple tasks can be computed from the similarities between the image embedding and all candidate textual embeddings. Then, we marginalize the joint distribution to obtain the marginal probability for each task. From Table 3, we can observe that the performance of the model using joint templates is inferior to that of the model using separate templates (_i.e._, Ours (Default)), indicating that separate templates for each task are more conducive for learning the semantic closeness between two face forgery detection tasks in joint embedding. On the other hand, less tasks (_i.e._, single task and two tasks) result in the inferior performance. Notably, benefiting from the joint embedding, the model using binary templates also achieves comparable results on generalization, though it only classifies the overall authenticity of the face.

**Encoder Architecture.** In this subsection, we investigate other visual encoders with different settings and model sizes. In specific, we choose (8) ViT-B/16  and (9) ViT-L/14 . As shown in Table 3, two alternative ViT-based architectures achieve better results on generalization. However, the larger model will result in both computationally more expensive and time-consuming.

**Multitask Objective.** In this subsection, we study how different optimization objectives affect the performance. As a reference, we first replace the fidelity loss functions with (10) binary cross entropy loss (BCE Loss). We also adopt the (11) hierarchical probabilistic loss  to jointly formulate multi-level classification tasks under a hierarchical label semantic graph. The relative similarity score (_i.e._, \(s-\)), as a raw score, for each node in the label hierarchy, will be converted into marginal probabilities for loss computation. From Table 3, we observed that the proposed method outperforms the variant trained with BCE loss, thus providing evidence for the effectiveness of the designed fidelity losses. Furthermore, Table 3 shows that fidelity loss yields better performance than the hierarchical probabilistic loss, suggesting that implicitly learning the semantic dependencies may be better than explicitly encoding the prior knowledge in the label hierarchy graph in advance.

### Discussion: Vision-Language Correspondence

**Human-Understandable Interpretation**. The proposed joint embedding approach enjoys the vision-language correspondence, which naturally provides model interpretations by providing human-understandable explanations. Fig. 4 shows some examples of FF++ , in which Deepfakes  indicate the identity swap, leading all local parts of the face are fake; and NeuralTextures  modify the expression in the mouth part. Take an example of NeuralTextures, the texts with a probability over \(50\%\) include "fake", "expression", and "mouth". Hence, we consider this face image to be fake

   Model Variant & CDF & FSH & DF-1.0 & DFDC & Mean AUC \\  (1) Pretrained CLIP & 65.38 & 51.04 & 53.38 & 55.56 & 56.34 \\ (2) Frozen \(g_{}\) & 90.56 & 98.92 & 91.22 & 80.19 & 90.22 \\ (3) Equal Weights & 88.32 & 98.77 & 92.93 & 82.27 & 90.57 \\ (4) w/o Contrastive Pair & 87.89 & 98.34 & 93.30 & 81.27 & 90.20 \\  (5) Binary Templates & 85.03 & 98.42 & 93.33 & 81.58 & 89.59 \\ (6) Two-Levels & 87.57 & 98.47 & 93.74 & 80.81 & 90.15 \\ (7) Joint Templates & 88.05 & 98.42 & 94.21 & 81.31 & 90.50 \\  (8) ViT-B/16 & 88.13 & 99.62 & 93.30 & 82.30 & 90.84 \\ (9) ViT-L/14 & **90.78** & **99.95** & **98.60** & **86.22** & **93.89** \\  (10) BCE Loss & 86.45 & 98.35 & 93.40 & 80.81 & 89.75 \\ (11) Probabilistic Loss & 87.81 & 98.41 & 91.55 & 81.18 & 89.74 \\  Ours (Baseline) & 71.63 & 98.19 & 89.94 & 74.02 & 83.44 \\ Ours (w/o Aug) & 85.53 & 98.82 & 93.95 & 80.41 & 89.68 \\ Ours (Default) & 89.02 & 98.68 & 93.38 & 82.06 & 90.79 \\   

Table 3: **Ablation Studies**. Baseline denotes the single-task formulation w/o contrastive textual pairing nor data augmentation, optimized for the BCE loss.

because the model's prediction relies on the following three textual prompts: "_a photo of a fake face_", "_a photo of a face with the global attribute of expression altered_", and "_a photo of a face with the local attribute of mouth altered_". More examples can be found in Appendix.

**Semantic Closeness across Tasks**. We show the semantic closeness across tasks by a correlation matrix in Fig. 5, in which each entry is represented by the cosine similarity between two textual embeddings from the language prompts depicting the specific tasks. From Fig. 5, we can observe that the text encoder of the pretrained CLIP has not sufficiently captured the semantic closeness across tasks and treats most tasks equally, further verifying the results of the variant with frozen text encoder in Table 3. After joint embedding learning on the forged faces, the semantic closeness across tasks can be sufficiently learned, _e.g._, the concept of "identity" forgery is more related to the "nose", "mouth", and "eye", thus improving the performance of multitask learning for face forgery detection.

## 5 Conclusion and Limitations

**Conclusion**. In this paper, we consider multitask learning for face forgery detection from the joint embedding perspective. We have designed a set of coarse-to-fine language prompts to represent multiple tasks for face forgery detection. We then take an automated multitask learning scheme to train two encoders to joint embed visual face images and textual descriptions. Thus, semantic closeness across tasks is manifested as the distance in the learned feature space, thus improving multitask learning. From extensive experiments, vision-language correspondence after joint embedding shows great promise to support better face forgery detection by maximizing the feature similarity between the face image and candidate textual prompts, verifying the effectiveness and superiority of the proposed method. Moreover, the joint embedding scheme also renders some degree of model interpretation in a human-friendly way.

**Limitations**. The proposed method relies on the assumption that the forged faces are generated with the blending operation . Thus, it may perform unsatisfactorily when fake face images are totally synthesized by GAN- or diffusion-model-based methods. Additionally, our model is image-based, though it can handle video-based DeepFake by sampling frames for prediction, it may fail when encountering the fake video manipulated by only lowering the frame rate .

Figure 4: Bar charts of the similarity scores between the visual image and the textual descriptions a form of human-understandable explanations.

Figure 5: Illustration of semantic closeness across tasks before and after fine-tuning.