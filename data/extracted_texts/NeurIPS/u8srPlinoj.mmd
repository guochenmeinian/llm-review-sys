# ReDS: Offline Reinforcement Learning With Heteroskedastic Datasets via Support Constraints

Anikait Singh\({}^{1,*}\), Aviral Kumar\({}^{1,*}\), Quan Vuong\({}^{2}\), Yevgen Chebotar\({}^{2}\), Sergey Levine\({}^{1}\)

\({}^{1}\)UC Berkeley, \({}^{2}\)Google DeepMind (\({}^{*}\)Equal contribution)

asap7772@berkeley.edu

###### Abstract

Offline reinforcement learning (RL) learns policies entirely from static datasets. Practical applications of offline RL will inevitably require learning from datasets where the variability of demonstrated behaviors changes non-uniformly across the state space. For example, at a red light, nearly all human drivers behave similarly by stopping, but when merging onto a highway, some drivers merge quickly, efficiently, and safely, while many hesitate or merge dangerously. Both theoretically and empirically, we show that typical offline RL methods, which are based on distribution constraints fail to learn from data with such non-uniform variability, due to the requirement to stay close to the behavior policy **to the same extent** across the state space. Ideally, the learned policy should be free to choose **per state** how closely to follow the behavior policy to maximize long-term return, as long as the learned policy stays within the support of the behavior policy. To instantiate this principle, we reweight the data distribution in conservative Q-learning (CQL) to obtain an approximate support constraint formulation. The reweighted distribution is a mixture of the current policy and an additional policy trained to mine poor actions that are likely under the behavior policy. Our method, CQL (ReDS), is theoretically motivated, and improves performance across a wide range of offline RL problems in games, navigation, and pixel-based manipulation.

## 1 Introduction

Recent advances in offline RL  hint at exciting possibilities in learning high-performing policies, entirely from offline datasets, without requiring dangerous  or expensive  active interaction. Analogously to the importance of data diversity in supervised learning , the practical benefits of offline RL depend heavily on the _coverage_ of behavior in the offline datasets . Intuitively, the dataset must illustrate the consequences of a diverse range of behaviors, so that an offline RL method can determine what behaviors lead to high returns, ideally returns that are significantly higher than the best single behavior in the dataset.

One easy option to attain this kind of coverage is to combine many realistic sources of data, but doing so can lead to the variety of demonstrated behaviors varying in highly non-uniform ways across the state space, i.e. the dataset is _heteroskedastic_. For example, a driving dataset might show very high variability in driving habits, with some drivers being timid and some more aggressive, but remain remarkably consistent in "critical" states (e.g., human drivers are extremely unlikely to swerve in an empty road or drive off a bridge). A good offline RL algorithm should combine the _best_ parts of each behavior in the dataset - e.g., in the above example, the algorithm should produce a policy that is _as good as the best human in each situation_, which would be better than _any_ human driver overall. At the same time, the learned policy should not attempt to extrapolate to novel actions in subset of the state space where the distribution of demonstrated behaviors is narrow (e.g., the algorithm should not attempt to drive off a bridge). How effectively can current offline RL methods selectively choose on a _per-state_ basis how closely to stick to the behavior policy?Most existing methods [32; 33; 28; 27; 53; 17; 23] constrain the learned policy to stay close to the behavior policy with so-called "distribution constraints". Using a combination of empirical and theoretical evidence, we first show that distribution constraints are insufficient when the heteroskedasticity of the demonstrated behaviors varies non-uniformly across states, because the strength of the constraint is state-agnostic, and may be overly conservative at some states even when it is not conservative enough at other states. We also devise a measure of heteroskedasticity that enables us to determine if certain offline datasets would be challenging for distribution constraints.

Our second contribution is a simple observation: distribution constraints against a _reweighted_ version of the behavior policy give rise to support constraints. That is, the return-maximization optimization process can freely choose per-state how much the learned policy should stay close to the behavior policy, so long as the learned policy remains within the data support. We show that it is convenient to instantiate this insight on top of conservative Q-learning (CQL) , a recent offline RL method. The new method, CQL (ReDS), changes minimally the form of regularization, design decisions employed by CQL and inherits existing hyper-parameter values. CQL (ReDS) attains better performance than recent distribution constraints methods on a variety of tasks with more heteroskedastic distributions.

## 2 Preliminaries

The goal in offline RL is find the optimal policy in a Markov decision process (MDP) specified by the tuple \(=(,,T,r,_{0},)\). \(,\) denote the state and action spaces. \(T(^{}|,)\) and \(r(,)\) represent the dynamics and reward function. \(_{0}(s)\) denotes the initial state distribution. \((0,1)\) denotes the discount factor. We wish to learn a policy that maximizes return, denoted by \(J():=_{(_{1},_{t})} [_{t}^{t}r(_{t},_{t})]\). We must find this policy while only having access to an offline dataset of transitions collected using a behavior policy \(_{}\), \(=\{(,,r,^{})\}\).

**Offline RL via distributional constraints**. Most offline RL algorithms regularize the learned policy \(\) from querying the target Q-function on unseen actions [17; 30], either implicitly or explicitly. For our theoretical analysis, we will abstract the behavior of distributional constraint offline RL algorithms into a generic formulation following Kumar et al. . As shown in Equation 1, we consider the problem where we must maximize the return of the learned policy \(\) (in the empirical MDP) \(()\), while also penalizing the divergence from \(_{}\):

\[_{}\ \ _{^{}}[( )- D(,_{})()],\] (1)

where \(D\) denotes a divergence between the learned policy \(\) and the behavior policy \(_{}\) at state \(\).

**Conservative Q-learning.** enforces the distributional constraint on the policy _implicitly_. To see why this is the case, consider the CQL objective, which consists of two terms:

\[_{}\ _{, }[Q_{}(,)]-_{ ,}[Q_{}(,) ])}_{()}+_{,, ^{}}[(Q_{}(,)-^{}(,))^{2}]}_{ ()},\] (2)

where \(^{}(,)\) is the Bellman backup operator applied to a delayed target Q-network, \(\): \(^{}(,):=r(,)+ _{^{}(^{}|^{ })}[(^{},^{})]\). The second term (in blue) is the standard TD error [40; 18; 22]. The first term \(()\) (in red) attempts to prevent overestimation in the Q-values for out-of-distribution (OOD) actions by minimizing the Q-values under a distribution \((|)\), which is automatically chosen to pick actions with high Q-values \(Q_{}(,)\), and counterbalances by maximizing the Q-values of the actions in the dataset. Kumar et al.  show that Equation 2 gives rise to a pessimistic Q-function that modifies the optimal Q function by the ratios of densities, \((|)/_{}(|)\) at a given state-action pair \((,)\). Formally, the Q-function obtained after one iteration is given by:

\[Q_{}(,):=^{}(, )-[|)}{_{}(|)}-1].\] (3)

The Q function is unchanged only if the density of the learned policy \(\) matches that of the behavior policy \(_{}\). Otherwise, for state-action pairs where \((|)<_{}(|)\), Eq. 3 increases their Q values and encourages the policy \(\) to assign more mass to the action. Vice versa, if \((|)>_{}(|)\), Eq. 3 encourages the policy \(\) to assign smaller density to the action \(\). In Eq. 3, \(\) is a constant for every state, and hence the value function learned by CQL is altered by the ratio of action probabilities to the same extent at all possible state-action pairs. As we will discuss in the next section, this can be sub-optimal when the learnt policy should stay close to the behavior policy in some states, but not others. We elaborate on this intuition in the next section.

Why Distribution Constraints Fail with Heteroskedastic Data

In statistics, heteroskedasticity is typically used to refer to the condition when the standard deviation in a given random variable varies non-uniformly over time (see for example, Cao et al. ). We call a offline dataset heteroskedastic when the variability of the behavior differs in different regions of the state space: for instance, if for certain regions of the state space, the observed behaviors in the dataset assign the most probability mass to a few actions, but in other regions, the observed behaviors are more diverse. Realistic offline datasets are often heteroskedastic as they are typically generated by multiple policies, each with its own characteristics, under different conditions. E.g., driving datasets come from multiple humans , and many robotic datasets are collected by multiple teleoperators , resulting in systematic variability in different regions of the state space.

### A Didactic Example

To understand why distribution constraints are insufficient with heteroskedastic data, we present a didactic example. Motivated by the driving scenario, we consider a maze navigation task shown in Fig. 1. The task is to navigate from the position labeled as "Start" to the position labeled as "Goal" using five actions at every possible state (L: \(\), R: \(\), U: \(\), D: \(\), No: No Op), while making sure that the executed actions do not hit the walls of the grid.

Dataset construction.To collect a heteroskedastic dataset, we consider a mixture of several behavior policies that attain a uniform occupancy over different states in the maze. However, the dataset action distributions differ significantly in different states. The induced action distribution is heavily biased to move towards the goal in the narrow hallways (e.g., the behavior policy moves upwards at state A)). In contrast, the action distribution is quite diverse in the wider rooms. In these rooms, the behavior policy often selects actions that do not immediately move the agent towards the goal (e.g., the behavior policy at state B), because doing so does not generally hit the walls as the rooms are wider, and hence the agent is not penalized. Whereas, the agent must take utmost precaution to not hit the walls in the narrow hallways. More details are in Appendix B.

Representative distribution constraint algorithms such as AWR [44; 43] and CQL  fail to perform the task, as shown in Figure 1. To ensure fair comparison, we tune each method to its best evaluation performance using online rollouts. The visualization in Figure 1 demonstrates that these two algorithms fail to learn reasonable policies because the learned policies match the random behavior of the dataset actions too closely in the wider rooms, and therefore are unable to make progress towards the Goal position. This is a direct consequence of enforcing too strong of a constraint on the learned policy to stay close to the behaviors in the dataset. Therefore, we also evaluated the performance of CQL and AWR in this example, with lower amounts of conservatism (Appendix B) and found that utilizing a lower amount of conservatism suffers from the opposite failure mode: it is unable to prevent the policies from hitting the walls in the narrow hallways. This means that conservatism prevents the algorithm from making progress in the regions where the behavior in the dataset is more diverse, whereas not being conservative enough hurts performance in regions where the behaviors in the dataset agree with each other. The method we propose in this paper to tackle this challenge, indicated as "CQL (ReDS)", effectively traverses the maze, \(80\%\) of the time.

### Challenges with Distribution Constraints

Having seen that distribution constraints can fail in certain scenarios, we now formally characterize when offline RL datasets is heteroskedastic, and why distribution constraints may be ineffective in

Figure 1: **Failure mode of distribution constraints. In this navigation task, an offline RL algorithm must find a path from the start state to the goal state as indicated in (a). The offline dataset provided exhibits non-uniform coverage at different states, e.g., in the state marked as “B” located in a wide room has more uniform action distribution, whereas the states in the narrow hallways exhibit a more narrow action distribution. This is akin to how the behavior of human drivers varies in certain locations (“B”), but is very similar in other situations (“A”). To perform well, an algorithm must stay close to the data in the hallways (“A”), but deviate significantly from the data in the rooms (“B”), where the data supports many different behaviors (most are not good). AWR and CQL get stuck because they stay too close to the bad behavior policy in the rooms, e.g. the left and right arrows near State B in Fig (b) and (c). Our method, CQL (ReDS), learns to ignore the bad behavior action in state B and prioritizes the good action, indicated by the downward arrow near B in (d).**

such scenarios. Similar to how standard analyses utilize concentrability coefficient , which upper bounds the ratio of state-action visitation under a policy \(d^{}(,)\) and the dataset distribution \(\), i.e., \(_{,}d^{}(,)/(, ) C^{}\), we introduce a new metric called _differential concentrability_, which measures dataset heteroskedasticity (i.e., the variability in the dataset behavior across different states).

**Definition 3.1** (Differential concentrability.).: Given a divergence \(D\) over the action space, the differential concentrability of a given policy \(\) with respect to the behavioral policy \(_{}\) is given by:

\[C^{}_{}=}_{_{1},_{2} d ^{}}[()(_{1})}{( _{1})}}-)(_{2})}{(_{2})}})^{2}].\] (4)

Eq. 4 measures the variation in the divergence between a given policy \((|)\) and the behavior policy \(_{}(|)\) weighted inversely by the density of these states in the offline dataset (i.e., \(()\) in the denominator). For simplicity, let us revisit the navigation example from Section 3.1 and first consider a scenario where \(()=()\). For any given policy \(\), if there are states where \(\) chooses actions that lie on the fringe of the data distribution (e.g., in the wider rooms), as well as states where the policy \(\) chooses actions at the mode of the data distribution (e.g., as in the narrow passages), then \(C^{}_{}\) would be large any policy \(\) that we learn. Crucially, \(C^{}_{}\) would be small even if the learned policy \(\) deviates significantly from the behavior policy \(_{}\), such that \(D(,_{})()\) is large, but \(|D(,_{})(_{1})-D(,_{})(_{2})|\) is small, indicating the dataset is not heteroskedastic.

**Connection between variability in the action distribution and high \(C^{}_{}\).** Consider a simpler formula where we remove the counts \(n()\) from the expression of differential concentrability and set \(\) in \(C^{}_{}\) to be the uniform distribution over actions. Then, we can show that the value of \(C^{}_{}\) is _exactly_ equal to twice the variance of \(D(,_{})()\) across states. Therefore, we will demonstrate in Section 5 that arbitrary policy checkpoints \(\) learned by offline RL algorithms generally attain a low value of the variance in \(D(,_{})()\) on offline datasets from non-heteroskedastic sources, such as those covered in the D4RL  benchmark. Of course, we cannot always exclude the counts of states \(n()\), however, we note that in high-dimensional state spaces, such as those in our experiments, each state in the offline data is likely to be unique, thus validating the condition that \(n()=1\). That said, we do compute the exact value of \(C^{}_{}\) (with \(n()\)) in a didactic gridworld maze shown in Figure 2. In this case, we find that our definition of \(C^{}_{}\) is actually able to reflect the intuitive notion of heteroskedasticity.

We now use the definition of differential concentrability to bound both the improvement and de-provement of \(\) w.r.t. \(_{}\) for distribution constraint algorithms using the framework of safe policy

Figure 2: **Empirically computing \(C^{}_{}\) with three datasets: uniform (top), mixed (middle) and skewed (bottom) on a gridworld. We also visualize \(D(,_{})()\) across states in the maze as the colors on different cells, a histogram of \(D(,_{})()\) to visualize variation in this quantity and the performance of running standard CQL. Top: The uniform distribution leads to low \(C^{}_{}\), uniform \(D(,_{})(s)\), and highest success. Middle: The mixed distribution leads to medium \(C^{}_{}\), less uniformly distributed \(D(,_{})(s)\), and a drop in task success. Bottom: The skewed distribution leads to a high \(C^{}_{}\), non-uniform \(D(,_{})(s)\), and poor performance.**

improvement [37; 33]. We show that when \(C^{}_{}\) is large, then constraints (Eq. 1) may not improve significantly over \(_{}\), even for the best value for the weight \(\) (proof in Appendix C):

**Theorem 3.2** (Informal; Limited policy improvement via distributional constraints.).: _W.h.p. \( 1-\), for any prescribed level of safety \(\), the maximum possible policy improvement over choices of \(\), \(_{}\ [J(_{})-J(_{})]^{+}\), where \(^{+}\) is given by:_

\[^{+}:=_{}\ \ \ ()}{(1-)^{2}} \ \ |||}{}}}{(1-)^{2}} _{}}}{||}-_{ ^{_{}}}[D(_{},_{})()]}{1-},\] (5)

_where \(h^{*}\) is a monotonically decreasing function of \(\), and \(h(0)=(1)\)._

Theorem 3.2 quantifies the fundamental tradeoff with distribution constraints: to satisfy a given \(\)-safety constraint in problems with larger \(C^{}_{}\), we would need a larger \(\). Since the maximum policy improvement \(^{+}\) is upper bounded by \(h^{*}()\), the policy may not necessarily improve over the behavior policy if \(\) is large. On the flip side, if we choose to fix the value of \(\) to be small in hopes to attain more improvement in problems where \(C^{}_{}\) is high for all policies, we would end up compromising on the safety guarantee as \(\) needs to be large for a small \(\) and large \(C^{}_{}\). Thus, in this case, the policy may not improve over the behavior policy reliably.

Note that a larger value of \(C^{}_{}\) need not imply large \(_{^{}}[D(,_{})()]\) because the latter does not involve \(()\). \(C^{}_{}\) also measures the dispersion of \(D(,_{})()\), while the latter performs a mean over states. In addition, Theorem 3.2 characterizes the _maximum possible_ improvement with an _oracle_ selection of \(\), though is not feasible in practice. Thus, when \(C^{}_{}\) is large, distribution constraint algorithms could either not safely improve over \(_{}\) or would attain only a limited improvement with _any possible_ value of \(\). Finally, we remark that complementing [32; 39] that discuss failure modes of distribution constraints with high-entropy behavior policies, Theorem 3.2 quantifies when this would be the case: this happens when \(C^{}_{}\) is large.

## 4 Support Constraints As Reweighted Distribution Constraints

Thus far, we have seen that distribution constraints can be ineffective with heteroskedastic datasets. If we can impose the distribution constraint such that the constraint strength can be modulated per state, then in principle, we can alleviate the issue raised in Theorem 3.2 and Section 3.1.

**Our key insight** is that by reweighting the action distribution in the data before utilizing a distribution constraint, we can obtain a method that enforces a per-state distribution constraint, which corresponds to an approximate _support_ constraint. This will push down the values of actions that are outside the behavior policy support, but otherwise not impose a severe penalty for in-support actions, thus enabling the policy to deviate from the behavior policy by different amounts at different states. Rather than having a distribution constraint between \(\) and \(_{}\) (Eq. 1), if we can impose a constraint between \(\) and a _reweighted_ version of \(_{}\), where the reweighting is state-dependent, then we can obtain an approximate support constraint. Let the reweighted distribution be \(^{re}\). Intuitively, if \((|)\) is within the support of the \(_{}(|)\), then one can find a reweighting \(^{re}(|)\) such that \(D(,^{re})()=0\), whereas if \((|)\) is not within the support of \(^{re}(|)\), then \(D(,^{re})()\) still penalizes \(\) when \(\) chooses out-of-support actions, since no reweighting \(^{re}\) can put non-zero probability on out-of-support actions. This allows us to handle the failure mode from Section 3: at states with wide behavior policy, even with a large \(\), \(\) is not anymore constrained to the behavior distribution, whereas at other "critical" states, where \(_{}\) is narrow, a large enough \(\) will constrain \((|)\) to stay close to \(_{}(|)\). We call this Reweighting Distribution constraints to Support (ReDS).

### Instantiating the Principle Behind ReDS

One option is to reweight \(_{}\) to \(^{re}\), and enforce a distribution constraint \(D(,^{re})\) between \(\) and \(^{re}\). However, this is problematic because the \(^{re}\) would typically be estimated by using importance weighting or by fitting a parametric model, and prior work has shown that errors in estimating the behavior policy [43; 20] using only one action sample often get propagated and lead to poor downstream performance. For CQL, this issue might be especially severe if we push up the Q-values under \(^{re}\), because then these errors might lead to severe Q-value over-estimation.

**Abstract idea of CQL (ReDS).** Instead, we devise an alternative formulation for ReDS that modifies the learned policy \(\) to \(^{re}\), such that applying a distribution constraint on this modified policy imposes a support constraint. Thus, with CQL, now we instead _push down_ the Q-values under \(^{re}\). We define \(^{re}\) as a mixture distribution of the learned policy \(\) and a reweighted version of the behavior policy as follows:\[^{re}(|):=(|)+[_{ }(|) g((|))],\] (6)

where \(g()\) is a monotonically decreasing function. We will demonstrate how pushing down the Q-values under \(^{re}\) modifies CQL to enable a support constraint while reusing existing components of CQL that impose a distribution constraint. As shown in Figure 3, the second term in Equation 6 increases the probability of actions that are likely under the behavior policy, but are less likely under the learned policy (due to \(g\) being a decreasing function). We will show in Lemma 4.1 that utilizing \(^{re}\) in CQL enforces a support constraint on \(\). Thus, the learned policy \(\) can be further away from \(_{}\), allowing \(\) to assign more probability to good actions that are within the behavior policy support, even if they have lower probabilities under \(_{}\). Section 4.2 illustrates theoretically why pushing down the Q-values under Eq. 6 approximates a support constraint in terms of how it modifies the resulting Q-values. For an illustration, please see Figure 3.

**How should we pick \(g\) in practice?** Since we wish to use \(^{re}\) as a replacement for \(\) in the minimization term in the CQL regularizer (Equation 2), we aim to understand how to design the re-weighting \(g\) in practice. Since specifically CQL enforces a distribution constraint by maximizing the Q-value on _all_ actions sampled from the behavior policy \(_{}\), our choice of \(g\) should aim to counter this effect by instead minimizing the Q-value on "bad" actions within the support of the behavior policy. Equation 6 quantifies the notion of these "bad" actions using a monotonically decreasing function \(g((|))\) of the policy probability. In practice, we find it convenient to define \(g\) to be a function of the advantage estimate: \(A_{}(,):=Q_{}(,)-E_{ }[Q_{}(,)]\), that the policy \(\) is seeking to maximize. In fact, if entropy regularization is utilized for training the policy (akin to most offline RL algorithms), the density of an action under a policy is directly proportional to exponentiated advantages, i.e., \((|)(A_{}(,))\). Hence, we choose \(g(x)=1/x\), such that \(g((A(,)))=(-A(,))\) (a decreasing function).

For the rest, we approximate the product distribution \((|) g((|))\) by fitting a parametric function approximator \(_{}(|)\). Since \(_{}(|)\) is being trained to approximate a re-weighted version of the behavior policy, we fit \(_{}\) by minimizing using a weighted maximum log-likelihood objective, as shown in prior work . The concrete form for our objective for training \(_{}\) is shown below (\(\) is a temperature hyperparameter typically introduced in prior work ):

\[_{}(|)=_{_{}}\ \ _{ ,_{}(|)}[ _{}(|)(-A_{}(, )/)].\] (7)

The crucial difference between this objective and standard advantage-weighted updates is the difference of the sign. While algorithms such as AWR  aim to find an action that attains a high advantage while being close to the behavior policy, and hence, uses a positive advantage, we utilize the _negative_ advantage to mine for poor actions that are still quite likely under the behavior policy.

The final objective for the Q-function combines the regularizer in Eq. 8 with a standard TD objective:

Figure 3: **Comparison between support and distributional constraints: Left:** CQL pushes down the Q-function under the policy \(\), while pushing up the function under the behavior policy \(_{}\). This means that the Q-values for bad actions can go up. **Right:** In contrast, ReDS re-weights the data distribution to push down the values of bad actions, alleviating this shortcoming.

\[(;)=(}_{ ,}[Q_{}(,)]+ }_{,}[Q_{ }(,)])-}_{, }[Q_{}(,)]\] (8)

\[_{}\;J_{Q}()=(;)+_{ ,,^{}}[(Q_{}(,)-^{}(,))^{2}]\] (9)

### Theoretical Analysis of CQL (ReDS)

Next, we analyze CQL (ReDS), showing how learning using the regularizer in Eq. 8 modifies the Q-values and justifies our choice of the distribution \(\) in the previous section.

**Lemma 4.1** (Per-state change of Q-values.).: _Let \(g(|)\) be a shorthand for \(g(|)=g((|))\). In the tabular setting, the Q-function obtained after one iteration of objective in Eq. 9 is given by:_

\[Q_{}(,):=^{}(, )-|)+_{}(| )g(|)-2_{}(|)}{2 _{}(|)}\] (10)

_where \(^{}(,)\) is the Bellman backup operator applied to a delayed target Q-network._

Eq. 10 illustrates why the modified regularizer in Eq. 8 leads to a "soft" support constraint whose strength is modulated per-state. Since \(g\) is a monotonically decreasing function of \(\), for state-action pairs where \((|)\) has high values, \(g(|)\) is low and therefore the Q-value \(Q(,)\) for such state-action pairs are underestimated less. Vice versa, for state-action pairs where \((|)\) attains low values, \(g(|)\) is high to counter-acts the low \((|)\) values. Also, since \(_{}(|)\) appears in the denominator, for out-of-support actions, where \(_{}(|)=0\), \((|)\) must also assign \(0\) probability to the actions for the Q values to be well defined. An illustration of this idea is shown in Figure 9. We can use this insight to further derive the closed-form objective optimized by ReDS.

**Lemma 4.2** (CQL (ReDS) objective.).: _Assume that for all policies \(,(,),(|)>0\). Then, CQL (ReDS) solves the following optimization problem:_

\[_{}\;()-_{ ^{}}[D(,_{})()+}_{(|)}[g(( |))\{_{}(|)>0\}]].\] (11)

\(()\) corresponds to the empirical return of the learned policy, i.e., the return of the policy under the learned Q-function. The objective in Lemma 4.3 can be intuitively interpreted as follows: The first term, \(D(,_{})()\), is a standard distribution constraint, also present in naive CQL, and it aims to penalize the learned policy \(\) if it deviates too far away from \(_{}\). ReDS adds an additional second term that effectively encourages \(\) to be "sharp" within the support of the behavior policy (as \(g\) is monotonically decreasing), enabling \(\) to potentially put mass on actions that lead to a high \(()\).

Specifically, this second term allows us control the strength of the distribution constraint per state: at states where the support of the policy is narrow, i.e., the volume of actions such that \(_{}(|)>0\) is small (say, only a single action), the penalty in Equation 51 reverts to a standard distributional constraint by penalizing divergence from the behavioral policy via \(D(,_{})()\) as the second term cannot be minimized. At states where the policy \(_{}\) is broad, the second term counteracts the effect of the distributional constraint within the support of the behavior policy, by enabling \(\) to concentrate its density on only good actions within the support of \(_{}\) with the same multiplier \(\). Thus even when we need to set \(\) to be large to stay close to \(_{}(|)\) at certain states (e.g., in narrow hallways in the example in Sec. 3.1), \(D(,_{})()\) is not heavily constrained at other states.

In fact, we formalize this intuition below to show that for the best possible value of the hyperparameters appearing in the training objective for CQL (ReDS) (Equation 51), CQL (ReDS) is guaranteed to outperform the best-tuned version of CQL for any offline RL problem. A proof is in Appendix C.

**Lemma 4.3** (CQL (ReDS) formal guarantee).: _We will add the following guarantee to show that the policy learned by ReDS for the best possible value of \(\) (Equation 51) and \(\) in CQL (Equation 3) outperforms the best CQL policy. That is, formally we show:_

\[_{,}J(_{;,})_{}J(_{ ;}).\] (12)

## 5 Experimental Evaluation

The goal of our experiments is to understand how CQL (ReDS) compares to distributional constraint methods when learning from heteroskedastic offline datasets. In order to perform our experiments,we construct new heteroskedastic datasets that pose challenges representative of what we would expect to see in real-world problems. We first introduce tasks and heteroskedastic datasets that we evaluate on, and then present our results compared to prior state-of-the-art methods. We also evaluate ReDS on some of the standard D4RL  datasets which are not heteroskedastic in and find that the addition of ReDS, as expected, does not help, or hurt on those tasks.

### Comparison on the D4RL Benchmark

Heteroskedastic data is likely to exist in real-world problems such as driving and manipulation, where datasets are collected by multiple policies that agree and disagree at different states. While standard benchmarks (D4RL  and RLUnplugged ) include offline datasets generated by mixture policies (e.g. the "medium-expert" generated by two policies with different performance), these policies are trained via RL methods (SAC) that constrain the entropy of the action distribution at each state to be uniform. To measure heteroskedasticity, we utilize an approximation to \(C^{}_{}\): the standard deviation in the value of \(D(,_{})()\) across states in the dataset, using a fixed policy \(\) obtained by running CQL. We didn't use \(C^{}_{}\) directly, as it is challenging to compute in continuous spaces. In Table 3, the standard deviation is lower for the D4RL antmaze datasets, corroborating our intuition that these datasets are significantly less heteroskedastic.

### Comparisons on Heteroskedastic datasets

**Heteroskedastic datasets.** To stress-test our method and prior distribution constraint approaches, we collected new datasets for the medium and large mazes used in the antmaze navigation tasks from D4RL: noisy datasets, where the behavior policy action variance differs in different regions of the maze, representative of user variability in navigation, and biased datasets, where the behavior policy admits a systematic bias towards certain behaviors in different regions of the maze, representative of bias towards certain routes in navigation problems. Table 3 shows that these datasets are significantly more heteroskedastic to the D4RL datasets.

Using these more heteroskedastic datasets, we compare CQL (ReDS) with CQL and IQL , recent popular methods, and two prior methods, BEAR  and EDAC , that also enforce support constraints. For each algorithm, including ours, we utilize hyperparameters directly from the counterpart tasks in D4RL. Due to the lack of an effective method for offline policy selection (see Fu et al. ), we utilize oracle checkpoint selection for every method. We compute the mean and standard deviation across 3 seeds. Table 2 shows that the largest gap between CQL (ReDS) and prior methods is on noisy datasets, which are particularly more heteroskedastic (Table 3).

We also compare CQL (ReDS) with recent offline RL algorithms on D4RL, including DT , AWAC , onestep RL , TD3+BC  and COMBO . Table 1 shows that CQL (ReDS) obtains similar performance as existing distributional constraint methods and outperforms BC-based baselines. This is expected given that the D4RL datasets exhibit significantly smaller heteroscedasticity, as previously explained. Also, a large fraction of the datasets is trajectories with high returns. BC using the top \(10\%\) trajectories with the highest episode returns already has strong performance. The previous results compares CQL (ReDS) to baselines in tasks where the MDP states are low-dimensional vectors. Next, we study vision-based robotic manipulation tasks.

**Visual robotic manipulation.** We consider two types of manipulation tasks. In the "Pick & Place" task, the algorithm controls a WidowX robot to grasp an object and place it into a t

   Dataset & BC & 10\%BC & DT & AWAC & Onestep RL & TD3+BC & COMBO & CQL & IQL & **Ours** \\  halfcheeta-medium-replay & 36.6 & 40.6 & 36.6 & 40.5 & 38.1 & 44.6 & **55.1** & 45.5 & 44.2 & **52.3** \\ hopper-medium-replay & 18.1 & 75.9 & 82.7 & 37.2 & **97.5** & 60.9 & 89.5 & 95.0 & 94.7 & **101.5** \\ walker2d-medium-replay & 26.0 & 62.5 & 66.6 & 27.0 & 49.5 & **81.8** & 56.0 & 77.2 & 73.9 & **85.0** \\ halfcheeta-medium-expert & 55.2 & 92.9 & 86.8 & 42.8 & **93.4** & 90.7 & 90.0 & **91.6** & 86.7 & 89.5 \\ hopper-medium-expert & 52.5 & 110.9 & 107.6 & 55.8 & 103.3 & 98.0 & **111.1** & 105.4 & 91.5 & **110.0** \\ walker2d-medium-expert & 107.5 & 109.0 & 108.1 & 74.5 & **113.0** & 110.1 & 103.3 & 108.8 & 109.6 & **112.0** \\  locomotion total & 295.9 & 491.8 & 488.4 & 277.8 & 494.8 & 486.1 & 505 & **523.5** & 500.6 & **550.3** \\   

Table 1: Performance comparison on the D4RL benchmark. (Top 2 **bolded**)

   Dataset & std & \(\) \\  noisy (Ours) & **18** & **253** \\ biased (Ours) & **9** & **31** \\  diverse (D4RL) & 2 & 11 \\ play (D4RL) & 2 & 13 \\   

Table 3: The new antmaze datasets (Ours) are significantly more heteroskedastic than the standard D4RL datasets. We measure heteroskedasticity using the std and max of \(D(,_{})()\) across states in the offline dataset.

[MISSING_PAGE_FAIL:9]

**Atari games.** We collect data on 10 Atari games from multiple policies that behave differently at certain states while having similar actions otherwise. We consider a case of **two** such policies, and a harder scenario of **five**. We evaluate the performance of CQL (ReDS) on the Atari games using the evaluation metrics from prior works [2; 34]. Figure 5 shows that in both testing scenarios: with the mixture of two policies (top figure) and the mixture of five policies (bottom figure), CQL (ReDS) outperforms CQL in aggregate.

**To summarize**, our results indicate that incorporating CQL (ReDS) outperforms distribution constraints with heteroskedastic datasets in a variety of domains.

## 6 Related Work

Offline Q-learning methods utilize mechanisms to prevent backing up unseen actions , by applying an explicit behavior constraint that forces the learned policy to be "close" to the behavior policy [23; 53; 44; 49; 53; 30; 28; 27; 52; 15], or by learning a conservative value function [33; 54; 41; 57; 56; 47; 24; 53]. Most of these offline RL methods utilize a distribution constraint, explicit (e.g., TD3+BC ) or implicit (e.g., CQL ), and our empirical analysis of representative algorithms from either family indicates that these methods struggle with heteroskedastic data, especially those methods that use an explicit constraint. Model-based methods [26; 56; 4; 51; 45; 38; 57] train value functions using dynamics models, which is orthogonal to our method.

Some prior works have also made a case for utilizing support constraints instead of distribution constraints, often via didactic examples [30; 29; 39], and devised algorithms that impose support constraints in theory, by utilizing the maximum mean discrepancy metric  or an asymmetric f-divergences  for the policy constraint . Empirical results on D4RL  and the analysis by Wu et al.  suggest that support constraints are not needed, as strong distribution constraint algorithms often have strong performance. As we discussed in Sections 3.2 (Theorem 3.2 indicates that this distribution constraints may not fail when \(C^{}_{}\) is small, _provided these algorithms are well-tuned_.) and 4, these benchmark datasets are not heteroskedastic, as they are collected from policies that are equally wide at all states and centered on good actions (e.g., Antmaze domains in , control suite tasks in Gulcehre et al. ) and hence, do not need to modulate the distribution constraint strength. To benchmark with heteroskedastic data, we developed some novel tasks which may be of independent interest beyond this work, and find that our method ReDS can work well here.

## 7 Discussion, Future Directions, and Limitations

We studied the behavior of distribution constraint offline RL algorithms when learning from heteroskedastic datasets, a property we are likely encounter in the real world. Naive distribution constraint algorithms can be highly ineffective in such settings both in theory and practice, as they fail to modulate the constraint strength per-state. We propose ReDS, a method to convert distributional constraints into support-based constraints via reweighting, and validate it in CQL. A limitation of ReDS is that it requires estimating the distribution \(_{}\) to enforce a support constraint, which brings about its some additional compute overhead. Additionally, the instantiation of ReDS we develop in Section 4.1 is specific to methods that utilize a conservative regularizer such as CQL (or related approaches like COMBO). We clarify that our main contribution in this work is an analysis of when distributional constraints fail (which we study for AWR and CQL), and developing a principle for reformulating distributional constraints to approximate support constraints via reweighting. Devising approaches for enforcing support constraints that do not require extra machinery is a direction for future work. Understanding if support constraints are less sensitive to hyperparameters or are more amenable to model election is also a direction for future work.