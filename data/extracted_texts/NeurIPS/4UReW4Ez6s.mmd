# Provably Optimal Memory Capacity for Modern Hopfield Models: Transformer-Compatible Dense Associative Memories as Spherical Codes

Provably Optimal Memory Capacity for Modern Hopfield Models: Transformer-Compatible Dense Associative Memories as Spherical Codes

 Jerry Yao-Chieh Hu\({}^{*}\)\({}^{}\)\({}^{}\)  Dennis Wu\({}^{*}\)\({}^{}\)  Han Liu\({}^{}\)\({}^{}\)

\({}^{}\)Center for Foundation Models and Generative AI, \({}^{}\)Department of Computer Science, \({}^{}\)Department of Statistics and Data Science, Northwestern University, Evanston, IL 60208, USA

{jhu,hibb}@u.northwestern.edu, hanliu@northwestern.edu

Equal contribution. Code is available at GitHub. Latest version is on arXiv.

###### Abstract

We study the optimal memorization capacity of modern Hopfield models and Kernelized Hopfield Models (KHMs), a transformer-compatible class of Dense Associative Memories. We present a tight analysis by establishing a connection between the memory configuration of KHMs and spherical codes from information theory. Specifically, we treat the stored memory set as a specialized spherical code. This enables us to cast the memorization problem in KHMs into a point arrangement problem on a hypersphere. We show that the optimal capacity of KHMs occurs when the feature space allows memories to form an optimal spherical code. This unique perspective leads to: (i) An analysis of how KHMs achieve optimal memory capacity, and identify corresponding necessary conditions. Importantly, we establish an upper capacity bound that matches the well-known exponential lower bound in the literature. This provides the first tight and optimal asymptotic memory capacity for modern Hopfield models. (ii) A sub-linear time algorithm U-Hop+ to reach KHMs' optimal capacity. (iii) An analysis of the scaling behavior of the required feature dimension relative to the number of stored memories. These efforts improve both the retrieval capability of KHMs and the representation learning of corresponding transformers. Experimentally, we provide thorough numerical results to back up theoretical findings.

## 1 Introduction

We study the optimal memorization capacity of Kernelized modern Hopfield Models (KHMs) [Wu et al., 2024a], propose a sublinear-time algorithm to achieve it, and analyze parameter selection for these models. KHMs belong to a class of _transformer-compatible_ Dense Associative Memory [Krotov and Hopfield, 2021, 2016] known as Modern Hopfield Models (MHMs) [Wu et al., 2024a,b, Hu et al., 2024a, 2023, Ramsauer et al., 2020]. The defining characteristics of these models include their super-linear memory capacity and strong connection to transformer attention mechanisms [Vaswani et al., 2017]. The former makes them interesting models for associative memory, and the latter makes them versatile transformer-compatible backbones with diverse empirical successes [Burns, 2024, Burns and Fukai, 2023, Hu et al., 2024a,c, Xu et al., 2024, Wu et al., 2024a,b, Hoover et al., 2024b, Seidl et al., 2022, Furst et al., 2022]. However, one major limitation of MHMs is their reliance on the quality of memory distribution for effective pattern storage and retrieval [Wu et al., 2024a, Sec. 1].

Studying this limitation in these models is fundamental and of practical importance. One one hand, it prevents MHMs from functioning as full-fledged content-addressable memory models. On the other hand, it implies that the representation learning ability of current transformer attention [Vaswani et al., 2017] is suboptimal [Wu et al., 2024a, Thm. 3.1]. Addressing this issue benefits both computational neuroscience and large foundation model research [Bietti et al., 2024, Krotov, 2023, Kozachkov et al., 2023, Cabannes et al., 2023, Hoover et al., 2023]. Kernelized modern Hopfield Models (KHMs) [Wu et al., 2024a] alleviate this issue by storing memories in the kernelized feature space. A key advantage of KHMs is their ability to reposition memories in the feature space, resulting in larger storage capacity. However, despite strong empirical performance, their capacity still lacks an optimal guarantee [Wu et al., 2024a, Sec. 5]. In this work, we close this gap by establishing the optimality of KHMs' memory capacity and presenting a sublinear-time algorithm to achieve it.

Let \([_{1},,_{M}]^{d M}\) be a set of memory patterns where each column (indexed by \([M]\)) represents a memory \(_{}^{d}\), and let \(x^{d}\) be the input query. The Hopfield models [Hopfield, 1982] are energy-based associative memory models, which store memories on the local minima of their energy functions. They retrieve a pattern by iteratively updating the query \(x^{t} x^{t+1}\) with its update rule \((x^{t})\), for some \(t\{0,1,...\}\). This update rule converge to a fixed point \(x^{}\), defined by \(x^{}=(x^{})\). \(x^{}\) is the retrieved pattern2 based on initial query \(x^{0}\).

Explicitly, iteratively updating \(x\) with \(\) is defined as a process of minimization to an energy function \(E(x)\). For example, the Modern Hopfield Model [Ramsauer et al., 2020] has the energy function:

\[E(x)= x,x+(,^{ }x),\] (1.1)

where \((,z)\!(_{=1}^{M}\{ z_{} \})\), with some \(>0\). With the Concave-Convex Procedure (CCCP) [Yuille and Rangarajan, 2001], (1.1) is monotonically decreased by an iterative update rule

\[x^{t+1}(x^{t})=(^{ }x^{t}).\] (1.2)

This design boosts MHMs to store _exponentially_ (in pattern dimension \(d\)) many memories compared to the _linear_ capacity of the classic Hopfield model [Hopfield, 1982]. It also provides a model-based interpretation of the transformation mechanism [Wu et al., 2024a,b, Hu et al., 2024a,b, 2023, Ramsauer et al., 2020]. However, their retrieval accuracy and memory capacity hinge on the quality of the stored memory set [Wu et al., 2024a, Sec. 1], and hence are suboptimal in most scenarios.

To be concrete, for retrieving the \(\)-th memory (\([M]\)), the retrieval error of MHM is exponentially suppressed by the pattern separation: \(_{}_{},_{}-_{,} _{},_{}\) ([Wu et al., 2024a, Eqn. 1.3] or [Hu et al., 2023, Eqn. 2.7]). This \(_{}\)-dependence in MHM retrieval accuracy also manifests the \(_{}\)-dependence in memory capacity. To see this, recall that the standard memory capacity is a high-probability bound based on thresholding the separation \(_{}\) for each pattern \([M]\) to determine storage and retrieval (Section 2.1). Explicitly, storing a pattern requires its separation to exceed a threshold that decreases with the _minimal_ separation: \(_{}_{[M]}_{}\). Namely, a larger \(_{}\) leads to larger capacity (Appendix B.1). Thus, the capacity depends on \(_{}\). Yet, \(_{}\) depends on the stored memories \(\). This \(\)-dependence makes the capacity suboptimal.

Wu et al. [2024a] relax such limitation by introducing a kernel as a learnable similarity measure, using stored memory patterns as training data to enhance memory capacity. Specifically, they propose the Kernelized Modern Hopfield Model (KHM) defined by following update rule and energy function:

\[x^{t+1}_{}(x^{t}) ((,x)), E_{}(x)= (x,x)+(,(,x)),\] (1.3)

where the kernel \((,)(),():^{d}^{d}\) is associated with a learnable feature map \(:^{d}^{D_{}}\). Here, \((,)\) acts column-wise on matrix: \((,x)=[\{(_{},x)\}_{=1}^{M}]=[\{( (_{}),(x))_{=1}^{M}\}]^{M}\). Importantly, KHMs shift the dependency on \(_{}\) to \(_{}^{}\), with

\[_{}^{}_{[M]}_{}^{},_{}^{}(_{},_{})- _{,}(_{},_{}).\]

Notably, \(_{}^{}\) is learnable and parameterized via \(\). Wu et al. [2024a] point out that with \((x)=Wx\), where \(W^{d D_{}}\), finding a suitable \(\) that maximizes \(_{}^{}\) benefits memory storage. This construction of \(\) preserves key MHM properties, such as accurate [Wu et al., 2024a, Lemma 2.1] and consistent [Wu et al., 2024a, Thm 2.1] retrieval. However, direct maximization of \(_{}^{}\) is challenging due to its max-min nature. To circumvent, Wu et al. (2024) propose a surrogate loss to maximize \(^{}_{}\)_on average_Wu et al. (2024, Def. 2.2). As a result, their approach achieves strong empirical results in memory retrieval for MHMs and supervised learning for transformer models.

Nevertheless, maximizing \(^{}_{}\) on average, rather than \(^{}_{}\), raises questions about how their surrogate loss benefits memory storage. Moreover, the impact of \(^{}_{}\) on memory capacity lacks a clear analytical characterization, and no theoretical analysis confirms whether maximizing \(^{}_{}\) leads to optimal memorization capacity.

In this paper, we address these questions from the perspective of (optimal) spherical codes from information thoery (Delsarte et al., 1991). A spherical code is a set of points (vectors) distributed on the surface of a hypersphere, and an optimal spherical code is when the minimum angular distance between any two points is maximized. In other words, optimal spherical codes aim to spread the points as evenly as possible over the surface of the sphere. This aligns with the intuition behind KHM -- increasing average separation between stored memories improves memory capacity. Therefore, we treat the stored memory pattern set as a spherical code (Definition 2.3), and require this spherical code to satisfy the _well-separation condition_Hu et al. (2023, Thm 3.1). We term this spherical code as _memory code_. Surprisingly, this unique connection enables a tight analysis on KHMs' capacity.

**Contributions.** Through the memory code perspective, this work makes three main contributions:

* **Provably Optimal Capacity.** We study the optimal memory capacity of KHMs and identify the conditions necessary to achieve it. Specifically, we derive a provably tight and optimal capacity by matching the well-known exponential lower bound for the memory capacity of MHMs (Wu et al., 2024, 2024, 2023, Ramsauer et al., 2020) with an upper bound in the low-temperature region. Notably, we establish this tight bound by showing that KHMs store the most memories when the memory set forms an optimal spherical code (Lemma 2.2). This result suggests a tight exponential scaling of memory capacity with the pattern dimension \(D_{}\) (Proposition 2.1).
* **Fast Algorithm.** We introduce an algorithm, U-Hop+, that achieves the optimal capacity of KHM in sublinear time. Theoretically, we show that, as temperature approaches zero, U-Hop+ finds the optimal feature map for maximal KHM capacity (Theorem 3.1). This result bridges our theoretical findings with practical applications and explains the empirical successes of (Wu et al., 2024).
* **Numerical Validation.** Our experiments validate our theoretical analysis. We observe that (i) U-Hop+ creates distinct low-energy regions for each memory pattern, addressing the memory confusion problem in MHMs (Wu et al., 2024, Krotov and Hopfield, 2016); (ii) U-Hop+ significantly reduces metastable states on both MNIST and synthetic datasets, indicating larger memory capacity; (iii) with U-Hop+, the KHMs update rule converges to fixed points faster.

**Organization.** Section 1 presents a brief review of MHMs and KHMs. Appendix A includes related work discussions. Section 2 presents our main results. Specifically, Section 2.1 presents a memory capacity lower bound for KHMs, Section 2.2 presents the optimal capacity bound based on the notation of memory code. Section 3.1 presents a sublinear time algorithm to search for the optimal \(\). Section 3.2 discusses the relationship between \(\) and \(M\). Section 4 includes numerical experiments.

**Notations.** Lower case letters denote (column) vectors and upper case letters denote matrices. We write \( a,b:=a^{}b\) as the inner product for vectors \(a,b^{d}\). The index set \(\{1,...,I\}\) is denoted by \([I]\), where \(I^{+}\). The spectral norm is denoted by \(_{2}\) which is equivalent to the \(_{2}\)-norm when applied to a vector. We denote the memory patterns (keys) by \(^{d}\) and the query pattern by \(x^{d}\), and \([_{1},...,_{M}]^{d M}\) as shorthand for stored memory patterns \(\{_{}\}_{[M]}\). Throughout this work, we use \(\) interchangeably to refer to either a \(d M\) matrix or a set of \(M\)\(d\)-dimensional memory pattern vectors.

## 2 Main Theory

We provide a theoretical analysis on the optimal memory capacity of KHMs. First, we begin by comparing the memory capacity between MHM and KHM using the standard high-probability lower bound (Hu et al., 2023, Ramsauer et al., 2020). Then, we present a spherical code perspective as a framework for depicting the optimal memory capacity of both MHMs and KHMs. In our analysis, we make the following pattern normalization assumption on memory patterns:3
**Assumption 1**.: We assume memory patterns \(\|_{}\|=1\) in the rest of our paper.

### High-Probability Capacity Lower Bound

We start by showing the memory capacity of KHM using the standard capacity lower bound introduced by Ramsauer et al. (2020). This provides a direct comparison between KHMs and previous works. The definition of the generalized fixed point (Sriperumbudur and Lanckriet, 2009) is

**Definition 2.1** (Generalized Fixed Point (Sriperumbudur and Lanckriet, 2009)).: We say a set \(S^{d}\) is a _generalized fixed point_ w.r.t. \(\) if \((y) S\) for every \(y S\).

**Remark 1**.: In contrast to Definition 2.1, a fixed point of \(\) is a point \(y\) satisfying \((y)=y\).

Let \(S_{}^{}\) be a ball with radius \(R_{}\)4 centered at every memory pattern in the feature space \((_{})\):

\[S_{}^{}=\{y\ |\ \|(_{})-y\| R_{}\}, R_{}_{,[M]\\ }\|(_{})-(_{})\|.\] (2.1)

Following (Wu et al., 2024), we define the memory storage and retrieval as:

**Definition 2.2** (Pattern Storage and Retrieval).: We say a memory pattern \(_{}\) is _stored_ if \(S_{}^{}\) is a generalized fixed point of \(\), and there exists a fixed point \(x_{}^{} S_{}^{}\). A memory pattern \(_{}\) gets _\(\)-retrieved_ by \(\) with an input query \(x\) if \(\|(x)-_{}\|\).

This definition is compatible with both KHMs and MHMs (with identity feature map). Under Definition 2.2, KHM's memory capacity is lower bounded by the following lemma.

**Lemma 2.1** (Memory Capacity of KHM).: Let \(1=p\) be the probability of successfully storing and retrieving a pattern. Assuming the patterns are normalized, the number of patterns \(M_{}\) that can be stored and retrieved by the KHM, following the update rule (1.3), is lower-bounded by:

\[M_{}C^{(D_{}-1)/4},\]

where \(C\) is the solution to \(C=}{{(W_{0}(\{a+ b\}))}}\), with \(W_{0}()\) being the principal branch of Lambert \(W\) function, \(a(}{{D_{}-1}})((-2)} }{{R_{}}})+1)\) and \(b}{{(5(D_{}-1))}}\). For comparison, \(M_{}\) reduces to MHM's capacity lower bound by setting \(=I_{d}\), with \(D_{}=d\).

Proof.: Our proof follows (Hu et al., 2023; Wu et al., 2024). See Appendix C.1 for a proof. 

With a fixed \(D_{}\), the highest lower bound of Lemma 2.1 corresponds to specific a \(\) that maximizes \(R_{}\). This provides an intuitive insight on the design of separation loss (Wu et al., 2024, Definition 2.2) for kernel learning in (Wu et al., 2024, Algorithm 1). With an additional feature space, KHM has an exponential memory capacity in \(D_{}\) that does not depend on \(d\). When \(D_{}=d\), KHMs obtain a tighter lower bound than MHMs if \(R_{}>R\). This bound connects the storage capacities of KHMs and MHMs, showing that their capacities scale exponentially with respect to \(D_{}\) and \(d\).

### Memory Code: Memories as Spherical Code

There are two aspects the lower bound in Lemma 2.1 does not address: the maximal capacity of KHMs and the flexibility of choosing different \(\) in KHMs. Therefore, we present a new framework using spherical codes to take the above perspectives into consideration for further analysis. We begin by introducing the concepts of spherical code and optimal spherical code.

**Definition 2.3** (Spherical Code).: A \(d\)-dimensional spherical code on the unit sphere \(^{d-1}\) is a finite set \(_{N}=\{c_{1},...,c_{N}\}\) of \(^{d-1}\) with \(N\) points, where \(c_{i}^{d}\) for \(i[N]\) and \(|_{N}|=N\).

**Definition 2.4** (Minimal Separation).: The minimal separation \((_{N})\) of a spherical code \(_{N}\) is the maximal inner product between two distinct points in \(_{N}\):

\[(_{N})=_{c_{i},c_{j}_{N}} c_{i}, c_{j},.\]

**Definition 2.5** (Optimal Spherical Code).: Let \(_{N}=\{c_{1},,c_{N}\}^{d-1}\) be a \(d\)-dimensional spherical code with \(N\) points. An optimal spherical code \(_{N}^{}\) minimizes the maximal pairwise inner product, which corresponds to maximizing the minimal separation between points in the code. Formally, the optimal spherical code \(_{N}^{}\) is defined as:

\[_{N}^{}=*{argmin}_{_{N} ^{d-1}}_{i j} c_{i},c_{j}, i,j[N].\]

The minimal separation of the optimal spherical code is denoted as \(^{}\).1

Next, we recall the function class \(\) of the linear feature map introduced by Wu et al. [2024a]:

**Definition 2.6**.: The function class \(\) consists of linear maps that satisfy the following properties:

1. For all \(\), \(:^{d-1}^{D_{}-1}\) is a linear map defined by a matrix \(W^{d D_{}}\).
2. The matrix \(W\) has full column rank.
3. When applying \(\) to different inputs: * For a vector \(^{d}\), \(()=W^{}^{D_{}}\). * For a matrix \(^{d M}\), \(()=((_{1}),,(_{M}))^{D_{} M}\). * For a set of vectors \(=\{v_{1},,v_{N}\}\), \(()=\{(v_{1}),,(v_{N})\}\) with \(|()|=N\).

Definition 2.6 ensures KHMs with feature map \(()\) satisfying the defining characteristics of MHMs: accurate [Wu et al., 2024a, Lemma 2.1] and consistent [Wu et al., 2024a, Thm 2.1] retrieval according to Definition 2.2.6 Now, we combine the concept of spherical code and memory storage.

**Definition 2.7** (Kernelized Well-Separation Condition [Wu et al., 2024a,b, Hu et al., 2023, Ramsauer et al., 2020]).: Given a set of kernelized memory patterns \(()=\{(_{})\}_{=1}^{M}^{D_{}-1}\), the kernelized memory pattern \((_{})\) satisfies the well-separation condition if the following holds:

\[_{}^{}(}),\] (2.2)

where the inverse temperature \(\) is given by (1.3) and \(R_{}\) is defined by (2.1).

The inequality (2.2) is a necessary condition for the \(\)-th memory to have a well-defined attractor basin. Hence, the more memories satisfying (2.2) the greater the memory capacity of the model.

**Definition 2.8** (Memory Code).: Let \(M_{+}\), \(>0\), \(D_{}>1\) and \(\). For any finite set \(()=\{(_{})\}_{=1}^{M}^{D_{}-1}\), we say the set \(()\) is a memory code if all points in \(()\) satisfies (2.2). Further, we denote \(_{D_{}}\) as the set of all memory codes in \(^{D_{}-1}\), including all possible \(\), \(\).

Notably, \(\) includes all the possible pattern sets \(\{()\}\) that are able to be stored and retrieved by kernelized Hopfield models and modern Hopfield models. Naturally, the optimal memory capacity is the size of the largest memory code in \(^{D_{}-1}\). This leads to our next definition:

**Definition 2.9** (Optimal Memory Capacity).: For \(D_{}>1\) and \(\), the optimal capacity \(M^{}\) is the cardinality of the largest memory code in \(_{D_{}}\), i.e., \(M^{}_{()}|()|\) for all possible \(\), \(\).

Definition 2.9 specifies the largest possible memory code in \(_{D_{}}\) for a given \(D_{}\). Let \(\) denote the memory set associated with \(M^{}\), such that \(\|\|=M^{}\). To store all patterns in \(\), we need to find a suitable feature map \(\) such that \(()\) is a valid memory code.

Following this definition, we present the next lemma and proposition on optimal memory capacity.

**Lemma 2.2** (Capacity of Optimal Spherical Code).: Given a fixed \(D_{}>1\), and its corresponding \(M^{}\), if an optimal code \(_{}\) is in \(^{D_{}-1}\) and has size \(M^{}\), then \(_{}_{D_{}}\).

**Proposition 2.1** (Optimal Memory Capacity).: Following Lemma2.2, we have

\[M^{} c^{D_{}},\]

for some \(c>1\). Here \(\) indicates matching upper and lower bounds up to constant factors.

Proof Sketch.: We proof Lemma2.2 by showing that the model capacity is a increasing function w.r.t. the minimal separation value. For Proposition2.1, we utilize the upper bound in (Kabatiansky and Levenshtein, 1978) and lower bound in (Wyner, 1965; Shannon, 1959; Chabauty, 1953) to bound the quantity. Please see AppendixC.2 for a detailed proof. 

Proposition2.1 indicates that the optimal capacity of MHMs and KHMs scales exponentially with \(D_{}\). This capacity bound is provably tight and optimal for large feature dimension \(D_{}\). It echos the exponential capacity lower bound in Lemma2.1 and in prior works (Wu et al., 2024a,b, Hu et al., 2024a,b, c, 2023; Ramsauer et al., 2020). Moreover, Lemma2.2 shows that achieving the maximal capacity in any \(D_{}\) is equivalent to achieving optimal codes. Thus, for a given memory set \(\) of size \(M\), the memory storage problem with KHMs divides into two sub-problems:

* Finding a sufficiently large \(D_{}\) (in Section3.2), and
* Finding a \(\) such that \(()\) is an optimal spherical code (in Section3.1).

Next, we examine these two sub-problems and present a sub-linear time algorithm to solve them.

## 3 Sub-Linear Time Algorithm for Optimal Memory Capacity

In this section, we present an sub-linear time algorithm that achieves optimal capacity. Then, we analyze the scaling behavior of \(D_{}\) for KHMs to store any desired amount of memories.

### Learning to Achieve Optimal Memory Code

Here we present an asymptotic result showing that an algorithm exists to find the optimal \(\) for maximizing memory storage in dimension \(D_{}\). Building on the results from the previous sections, we consider the following problem:

**Problem 1** (HardMax Problem).: Given a memory set \(=\{_{1},,_{M}\}\), and assuming that \(D_{}\) is sufficiently large to satisfy (2.2), we define the HardMax problem as finding a \(\) such that \(()\) forms an optimal spherical code:

\[_{}_{}(), _{}()_{,[M], }(_{}),(_{})^{}.\] (3.1)

This problem setup involves finding a \(\) such that \(()\) forms an optimal spherical code. Ideally, a more expressive function class \(\) would simplify finding such a \(\); exploring explicit forms of more powerful mappings is left for future work. Note that (3.1) represents a min-max optimization problem. Achieving the global optimum is notoriously challenging (Hsieh et al., 2021; Daskalakis et al., 2021; Shen et al., 2020). Thus, we introduce a surrogate objective to solve (3.1):

**Definition 3.1** (Average Separation Loss).: For \(>0\), given a set of memory patterns \(\) and a feature map \(\), we define the average separation loss as

\[(,,)_{=1}^{M}_{}(,,),_{}(,,)[_{=1}^{M} (),(_{})}{})].\] (3.2)

The primary difference between (3.1) and (3.2) is that (3.2) calculates average separation, whereas (3.1) focuses on the maximum separation between a single pair. This surrogate loss alleviates the challenging optimization, as (3.2) is convex. Therefore, with vanishing temperature \(\), the next theorem shows that (3.2) converges to the HardMax problem asymptotically.

**Theorem 3.1**.: For any possible integer \(M\), we have

\[_{ 0}(*{argmin}_{} (,,))*{argmin}_{ }_{}().\]Proof.: we first introduce a helper function \(_{0}\) in (C.10). We show that as \( 0\), \(_{0}\) converges uniformly to \(_{}\). Then, we prove that optimizing \(_{0}\) and \(\) yields the same optimal solution. Please see Appendix C.3 for a detailed proof. 

Theorem 3.1 indicates that, with vanishing temperature, the minimiozation of (3.2) converges to the HardMax problem, i.e., their share the same optimal solution. This provide a theoretical justification for the empirical success of [Wu et al., 2024a]. In particular, the surrogate objective - the maximizing average separation between memories -- leads to provably optimal memory capacity in low-temperature region (i.e., \( 0\)). Lastly, we remark that that this analysis provides theoretical insights rather than practical guidance. To achieve high retrieval accuracy, the setting (\(=1\)) in [Wu et al., 2024a] is sufficient for a wide range of applications.

U-Hop+: Sub-Linear Time Algorithm for Achieving Optimal Memory Capacity.Next, we present Algorithm 1 for finding a \(\) such that \(()\) forms an optimal spherical code. To meet the conditions in Definition 2.6, we use projected gradient descent to convert this constrained optimization problem into an unconstrained one. Several methods satisfy the requirements in Definition 2.6; we discuss them in Appendix B.2. We denote the learning rate as \(\), the input matrix of the loss function as \(X\), and the weight matrix as \(W\). We define a single Projected Gradient Descent (PGD) step as

\[W_{t+1}=(W_{t},,X),\]

We defer the detailed formulation to Appendix B.2. Since the separation loss is convex and smooth, using projected gradient descent with a learning rate \( 1/G\), yields a sub-linear convergence rate of \((}{{N}})\)[Iusem, 2003]. This provides an asymptotic solution to the first sub-problem (P1). Next, we examine the relationship between feature dimension \(D_{}\) and the number of memories \(M\).

### Impact of \(D_{}\)

This subsection analyzes the minimum \(D_{}\) to store a given set of \(M\) memories. Based on the _well-separation condition_ and the derivation in Appendix C.2, the required \(_{}^{}\) to store \(M\) memories scales as \(((M))\). With this insight, the following proposition shows the scaling behavior of required \(D_{}\) with respect to \(M\) and \(_{}^{}\).

**Proposition 3.1**.: Let \(M^{}\) be the optimal memory capacity in \(^{D_{}}\) and \(\). For any optimal code \(C^{}\) in \(^{D_{}-1}\) of size \(M^{}\), the minimal separation \((C^{})\) is bounded by:

\[(}{M^{}}+1}{2})}{(+1}{2}+1)})^{-1}}_{}\,_{}^{} 2 (}{M^{}}+1}{2 })}{(}{2})})^{-1}},\]

where \(()\) is the gamma function.

**Remark 2**.: By gamma function asymptotics, Proposition 3.1 is consistent with Proposition 2.1.

Proof.: Please see Appendix C.4 for a detailed proof. 

Proposition 3.1 establishes the separation value for memory codes that achieve optimal capacity in \(D_{}\)-dimensional space. Using this bound, for a given separation value \(_{}^{}\), the minimum \(D_{}\) required to store \(M\) points scales as \(M^{2}/_{}^{}\). We conduct an experiment to demonstrate the bound's tightness and provide an example with \(D_{}=3\) in Figure 3.

## 4 Experimental Studies

### U-Hop+ Reduces Metastable States

We compare the distribution of metastable state size under standard MHM and KHM update rules. The results are in Table 1. In general, with more metastable state having the size of \(1\), meaning the Hopfield model stores more memories as the query converges to a single memory. For metastable state size larger than 1, it represents that the retrieved pattern converges near the mean of a subset of memories, violating the requirement of \(S_{}^{} S_{}^{}=\).

**Baselines.** We compare different variants of MHMs and KHMs. Santos et al. (2024); Wu et al. (2024) provide comprehensive analyses of modern Hopfield models with various normalization functions. Here, we consider softmax, 1.5-entmax, and sparsemax for normalization. We equip these three baselines with U-Hop to compare against standard MHMs.

**Settings and Metrics.** Let \(p=( x^{})\). We determine whether the update rule converges to either a single memory or a mixture of memories by observing the probability distribution \(p\). The quantity \( p_{0}\) represents the size of the metastable state, which is the number of non-zero entries in the probability distribution. In the case of \(1.5\)-entmax and sparsemax, we calculate \( p_{0}\) directly. For softmax, since it only generates non-zero entries, we use a threshold of \(0.01\) and consider the entries under the threshold as \(0\). We conduct experiments using both synthetic and MNIST datasets. For MNIST, we use the training set as memories and the test set as queries. For synthetic datasets, we randomly generate memories and queries with Gaussian initialization. To ensure the convergence to the fixed point, we perform multiple updates on the query. For more details, refer to Appendix D.1.

**Results.** On both synthetic and MNIST datasets, it is evident that under separation maximization, the size of the metastable state dramatically decreases within just 20 iterations of \(1\). This result demonstrates that, with Algorithm 1, KHMs are capable of storing patterns that MHMs cannot store. The significant percentage of size 1 metastable states in KHMs indicates that they circumvent the memory confusion problem in dense associative memory models (Krotov and Hopfield, 2016). For the MNIST dataset, we see MHMs show close performance with KHMs under \(1.5\)-entmax and sparsemax, showing that the methods in (Santos et al., 2024; Wu et al., 2024; Wu et al., 2024) also circumvent the memory confusion problem. Notably, KHMs require only one-fourth of the dimensions to store memories while perfectly storing 60,000 MNIST patterns. These results suggest that KHMs with Algorithm 1 efficiently utilize feature dimensions for memory storage.

### Energy Landscape under U-Hop+ Stores More Memories

**Settings and Metrics.** We visualize the energy landscape of KHMs at different stages of Algorithm 1 using contour plots. The results are presented in Figure 1. We consider two settings: 2 and 4 memories stored in a 2-dimensional space. Ideally, the energy landscape should position memories in multiple separated low-energy regions (valley), with each region isolated from others by high-energy regions. If multiple memories share the same valley, it leads to memory confusion and the presence of metastable states during energy minimization. For experiment details, refer to Appendix D.2.

**Results.** The first row in Figure 1 shows the raw energy landscape without KHM and Algorithm 1, corresponding to the modern Hopfield energy landscape. On the right side of Figure 1, we observe that MHMs are only able to store 2 out of 4 points, but KHMs are able to further separate one point

    &  &  \\   &  &  &  &  &  &  \\  \( p_{0}\) & - & U-Hop+ & - & U-Hop+ & - & U-Hop+ & - & U-Hop+ & - & U-Hop+ & - & U-Hop+ \\ 
1 & 0.0 & 90.0 & 0.0 & 100.0 & 0.0 & 100.0 & 3.48 & 100.0 & 69.2 & 100.0 & 88.1 & 100.0 \\
2 & 0.0 & 8.0 & 0.0 & 0.0 & 20.0 & 0.0 & 2.16 & 0.0 & 8.6 & 0.0 & 5.2 & 0.0 \\
3 & 0.0 & 0.0 & 0.0 & 0.0 & 30.0 & 0.0 & 1.57 & 0.0 & 3.9 & 0.0 & 2.6 & 0.0 \\
4 & 0.0 & 2.0 & 0.0 & 0.0 & 50.0 & 0.0 & 1.23 & 0.0 & 2.3 & 0.0 & 1.6 & 0.0 \\
5 & 6.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1.2 & 0.0 & 1.6 & 0.0 & 1.1 & 0.0 \\
6 & 10.0 & 0.0 & 25.0 & 0.0 & 0.0 & 0.0 & 0.95 & 0.0 & 0.9 & 0.0 & 0.8 & 0.0 \\
7 & 20.0 & 0.0 & 25.0 & 0.0 & 0.0 & 0.0 & 1.04 & 0.0 & 0.6 & 0.0 & 0.4 & 0.0 \\
8 & 16.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.84 & 0.0 & 0.6 & 0.0 & 0.1 & 0.0 \\
9 & 20.0 & 0.0 & 22.5 & 0.0 & 0.0 & 0.0 & 1.03 & 0.0 & 0.3 & 0.0 & 0.0 & 0.0 \\
10\({}^{+}\) & 28.0 & 0.0 & 27.5 & 0.0 & 0.0 & 0.0 & 86.5 & 0.0 & 12.0 & 0.0 & 0.1 & 0.0 \\   

Table 1: **Distribution of Metastable State (in \(\%\)).** For MNIST, we use the training set as memories and test set as queries. For synthetic data, we randomly generate the memories and queries. \( p_{0}\) denotes the size of metastable state, which is the amount of non-zero entries of the probability distribution. For Softmax, we use a threshold of \(0.01\). For hyperparameter settings, see Table 3.

from the others, resulting in memorizing one extra pattern. Lemma 2.2 and Theorem 3.1 indicate that U-Hop+ pushes memories away from each other, providing more isolated \(S_{}^{}\), for \([M]\). We observe this phenomenon across all settings, especially under the 2-point configuration with Softmax and \(1.5\)-entmax, where the low-energy region is split into two distinct valleys as \(N\) increases. This process shows how U-Hop+ is able to store memories that MHMs cannot. With energy minimization, the query converges to either one of the minima instead of the mixture thereof (also showed in Figure 2). Additionally, we also notice that the contour lines exhibit steep slopes between different local minima in the 2-point setting under \(1.5\)-entmax and sparsemax. This implies that U-Hop+ pushes local minima further away from each other and deepens each one of them. Such sharp changes in energies lead to faster convergence to fixed points due to larger gradients.

**Basins of Attraction.** Figure 2 shows the basins of attraction of queries w.r.t. MHM and KHM under the scenario of storing 5 patterns. We randomly initialize 5 patterns with normal distribution. We run the update rule for \(5\) iterations and see whether each query converges to a single memory (colored) or to a metastable state (white). Following the above setting, we track the attraction basins throughout each iteration of Algorithm 1. We defer more details to Appendix D.3. Specifically, most MHM variants are not capable of converging to fixed points in \(5\) updates. While U-Hop+ dramatically improves such aspect, where most queries are able to converge either one of the memories. Moreover, the increased \(R_{}\) also leads to a larger \(S_{}^{}\), making more queries to converge to a single memory. Additionally, there is a performance gap between Softmax (\(=1\)) and other sparse variants, which matches the findings in (Santos et al., 2024; Hu et al., 2023).

### Multiple Instance Learning

We conduct multiple instance learning (MIL) on 4 real-world datasets using Hopfied-based models with and without our U-Hop+ algorithm. We follow the setup in (Santos et al., 2024; Wu et al., 2024; Hu et al., 2023) by using a model with 1 embedding layer, 1 HopfieldPooling layer and a linear readout layer. We first utilize Algorithm 1 to "pretrain" the embedding and HopfieldPooling layer,

   Method & Tiger & Elephant & Fox & UCSB \\  Modern Hopfield & \(0.871\) & \(0.876\) & \(0.637\) & \(0.828\) \\ Modern Hopfield + U-Hop+ & \(0.881\) & \(0.921\) & \(0.648\) & \(0.831\) \\  Sparse Hopfield & \(0.884\) & \(0.914\) & \(0.610\) & \(0.796\) \\ Sparse Hopfield + U-Hop+ & \(0.887\) & \(0.921\) & \(0.638\) & \(0.805\) \\   

Table 2: **Test AUC of Multiple Instance Learning Datasets.** We compare the HopfieldPooling-based model with and without U-Hop+. We use the dense (Ramsauer et al., 2020) and sparse (Hu et al., 2023) modern Hopfield models as baselines. We use \(K\)-fold cross validation on all 4 datasets, with \(K=10\). The reported AUC is the average AUC score across 10 folds. For the baselines, we use the results reported in (Hu et al., 2023). For our method, we directly use the default hyperparameter without grid search instead of using hyperparameter optimization (HPO) in (Hu et al., 2023; Ramsauer et al., 2020). We exclude the variance as they are all smaller than \(0.07\). The result shows that even without HPO, U-Hop+ is still able to obtain a performance gain.

Figure 1: **Energy Landscape under Different Iterations of Algorithm 1.** Left: \(M=2\), Right: \(M=4\). Lighter color represents higher energy. The first row represents the raw energy landscape without applying U-Hop+. The second to last row represents the energy landscape when \(N=(1,2,5)\). The visualization shows that Algorithm 1 not only separates the local minima better, but also pushes memories closer to the fixed point.

and then fine-tune the whole model on the MIL task. The results are in Table 2. We observe that both dense and sparse Hopfield-based models obtain performance boost when equipped with U-Hop+, indicating our method is also effective in practical scenarios. Further, as demonstrated in Figure 5, the separation loss converges fast, indicating U-Hop+ is a lightweight method for performance boost.

## 5 Discussion and Conclusion

This work complements U-Hop (Wu et al., 2024) by establishing the optimal capacity of kernelized modern Hopfield models (KHMs) and providing the first tight, optimal memory capacity bound for transformer-compatible dense associative memories. We start by connecting stored memories in KHMs to spherical codes from information theory. We then prove that maximizing memory storage in KHMs requires arranging memories as an optimal spherical code in feature space. This allows us to matches the well-known exponential lower bound (Wu et al., 2024, 2024, 2023, Ramsauer et al., 2020) with an upper bound. This achievement is notable, as deriving such a tight bound is challenging due to the max-min structure of maximal separation among stored memories (Wu et al., 2024, Section 5). Moreover, we introduce a sub-linear time algorithm to achieve this optimal capacity, U-Hop+ (Algorithm 1). U-Hop+ performs this rearrangement with a convergence rate of \((}{{N}})\). Additionally, we analyze the minimum dimension \(D_{}\) required to store \(M\) memories. Numerically, we validate the effectiveness of KHMs and demonstrate how Algorithm 1 enhances memory storage in both KHM retrieval tasks and transformer representation learning tasks.

**Can U-Hop+ Preserve Semantic Meanings?** In representation learning, it is crucial to preserve relationships in the feature space after encoding data (Wang et al., 2023; Neelakantan et al., 2022). The primary strategy is to ensure the embeddings of similar instances share similar directions in Euclidean space. At first glance, the approach of pushing all memories away from each other in Equation (3.2) may seem counterintuitive. However, as detailed in Appendix D.5, we find that the learned feature map still encodes similar instances closely together (Figure 4), even without semantic information involved. This result indicates that U-Hop+ stores memories in a semantically coherent manner. A discussion of the separation capability of \(\) can be found in Figure 4.

**Limitations.** One limitation of our work only considers linear affine functions as the feature map \(\). Additionally, standard spherical code analysis focuses only on normalized points on a hypersphere, ignoring memories with varying magnitudes. We leave them for future research.

Figure 2: **Basins of Attraction Comparison of Algorithm 1. The first row represents the raw Basins of Attraction without applying U-Hop+ or KHM. The second to last row shows the basins when \(N=(1,2,5)\). Square points are memories. White area is where queries are not able to converge to a single memory. Colored area is where queries converges to the corresponding memory. The result indicates that U-Hop+ is capable of converging to fixed point fast and reduce metastable states. \(1\) and \(2\)-entmax corresponds to Softmax (Ramsauer et al., 2020) and Sparsemax (Hu et al., 2023).**

### Broader Impact

We expect no negative social impacts as this work mostly present theoretical results and numerical simulations. As discussed in our introduction, this paper develops a theoretical framework to study Kernelized Hopfield models, potentially benefit the area of computational associative (Hopfield) memory models, transformer networks and large foundation models.