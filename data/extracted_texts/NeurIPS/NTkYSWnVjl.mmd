# Amnesia as a Catalyst for Enhancing Black Box Pixel Attacks in Image Classification and Object Detection

Amnesia as a Catalyst for Enhancing Black Box Pixel Attacks in Image Classification and Object Detection

Dongsu Song

Department of Artificial Intelligence

Korea Aerospace University

raister2873@gmail.com &Daehwa Ko

Department of Software

Korea Aerospace University

daehwa001210@gmail.com &Jay Hoon Jung

Department of Artificial Intelligence

Korea Aerospace University

jhjung@kau.ac.kr

Corresponding author.

###### Abstract

It is well known that query-based attacks tend to have relatively higher success rates in adversarial black-box attacks. While research on black-box attacks is actively being conducted, relatively few studies have focused on pixel attacks that target only a limited number of pixels. In image classification, query-based pixel attacks often rely on patches, which heavily depend on randomness and neglect the fact that scattered pixels are more suitable for adversarial attacks. Moreover, to the best of our knowledge, query-based pixel attacks have not been explored in the field of object detection. To address these issues, we propose a novel pixel-based black-box attack called **R**emember and **F**orget **P**ixel **A**ttack using **R**eniforcement Learning(RFPAR), consisting of two main components: the Remember and Forget processes. RFPAR mitigates randomness and avoids patch dependency by leveraging rewards generated through a one-step RL algorithm to perturb pixels. RFPAR effectively creates perturbed images that minimize the confidence scores while adhering to limited pixel constraints. Furthermore, we advance our proposed attack beyond image classification to object detection, where RFPAR reduces the confidence scores of detected objects to avoid detection. Experiments on the ImageNet-1K dataset for classification show that RFPAR outperformed state-of-the-art query-based pixel attacks. For object detection, using the MS-COCO dataset with YOLOv8 and DDQ, RFPAR demonstrates comparable mAP reduction to state-of-the-art query-based attack while requiring fewer query. Further experiments on the Argoverse dataset using YOLOv8 confirm that RFPAR effectively removed objects on a larger scale dataset. Our code is available at https://github.com/KAU-QuantumAILab/RFPAR.

## 1 Introduction

Deep learning models are susceptible to adversarial attacks, which involve subtle modifications of input data that are imperceptible to humans but lead to incorrect predictions by the model. As deep learning technologies become commercialized in the real world, the issue of adversarial attacks has garnered increasing attention.

Adversarial attacks can be broadly categorized into white-box attacks and black-box attacks. In white-box attacks[3; 4; 5], attackers devise attack strategies based on internal information about deep learning models, such as training data, gradients of the outputs with respect to the weights, and other details about the learning process for given samples. Conversely, in black-box attacks[6; 7], attackers can access only limited information such as the probability of the correct prediction for a given sample. Given that real-world attackers typically only possess limited information about the model, black-box attacks are more realistic than white-box attacks. In other words, research on black-box attacks and their defenses is crucial in order to develop robust and secure machine learning systems.

Black-box attacks are also categorized into query-based methods[8; 9; 10; 11] and transfer-based methods. Query-based attacks are generating adversarial examples by repeatedly querying the victim model with modified images. Transfer-based attacks involve generating adversarial examples for a surrogate model that successfully deceive another model. Transfer-based attacks are highly efficient since they do not require knowledge of the victim model. However, the discrepancies in model architecture, training data, and training methodologies between the surrogate and victim models often result in a lower success rate for these attacks compared to query-based attacks. Conversely, although query-based attacks achieve higher success rates, they require a significant number of queries to the victim model. Therefore, reducing the number of queries in query-based attacks is a critical issue.

Figure 1: **Adversarial examples generated by RFPAR. The first column represents images from ImageNet (image classification), the second column from MS-COCO (object detection), and the third column from Argoverse (object detection). Each row represents a different condition: the first row shows clean images, the second row shows adversarially perturbed images, and the third row shows the perturbation levels with the ratio of attacked pixels to total pixels. Labels in the images indicate detected objects or classifications, such as “Cock” in ImageNet, “2 Objects” in MS-COCO, and “5 Objects” in Argoverse. In the adversarial row, labels are altered due to perturbations, resulting in misclassifications or undetected objects, such as “Coil” instead of “Cock” in ImageNet and no objects detected in MS-COCO and Argoverse. The perturbation row indicates the percentage of pixels attacked in the image. The percentages were 0.004% for ImageNet, 0.027% for MS-COCO, and 0.114% for Argoverse.**

The pioneering pixel attack method, OnePixel, employed Differential Evolution (DE) to generate adversarial images. An advanced approach, ScratchThat, used DE to create curves and applied a parametric model to perturbations, reducing parameters and improving performance. A more recent study, PIXLE, enhanced query efficiency and attack success rate by using a simple algorithm instead of DE. Briefly, PIXLE generates adversarial images by selecting arbitrary patches in a clean image and applying the brightness of these pixels to others. Although this method improved performance, it ignored the fact that pixels are independent of each other due to its reliance on patches and exhibited inefficiencies stemming from randomness in brightness mapping. The previous study, PatchAttack, utilized RL model to embed textures in specific regions of the clean image, discovering vulnerable patches and reducing randomness, which significantly decreased the number of queries and improved attack success rates. Unfortunately, this method still depended on patches, requiring at least 3% of the image area to be attacked.

Query-based attacks in object detection are more challenging than those in image classification. The first query-based attack in object detection, PRFA, generated adversarial images using a parallel rectangle flipping strategy. Recent research, GARSDC, employed a genetic algorithm to create adversarial images, improving optimization efficiency by using adversarial examples generated from transfer-based attacks as the initial population. Query-based attacks on black-box models are inherently challenging, and targeting only a few pixels is even more difficult to study. To the best of our knowledge, pixel attacks have been limited to white-box or transfer attack methods. In this study, we extend our proposed attack from image classification to object detection, introducing the first query-based pixel attack. Experiments show that our method achieves a comparable mAP reduction on YOLO to state-of-the-art methods while significantly reducing the number of queries, demonstrating its effectiveness in object detection.

In this study, we introduce a novel method called the Remember and Forget Pixel Attack using Reinforcement Learning (RFPAR). Briefly, in the Remember process, the clean image is initially taken as input by the RL agent, and the loss function is optimized. During this optimization, the highest reward and its corresponding perturbed image are stored in memory. If the highest rewards do not change for a while, we define this as the convergence of rewards. Once the rewards converge, the Forget process is initiated, resetting the RL agent and memory to forget previous information. After resetting, the stored image is fed as input to the RL agent, and the Remember process begins again. Extensive experiments demonstrate that our attack is effective for image classification and successfully extends to object detection.

In summary, our main contributions are:

Figure 2: The model architecture of RFPAR: the Remember and Forget process. During the Remember process, the RL model generates perturbed images and corresponding rewards. Memory compares these with previously stored values and retains only the highest reward and its associated image. Once the rewards converge to a certain value, the Forget process starts and resets the RL agent and memory, then reintroduces the perturbed images that gained the highest reward to the Remember process. The process continues until an adversarial image is generated or a predefined number of cycles is reached, at which point it terminates.

* We propose a novel query-based black-box pixel attack consisting of the Remember and Forget processes. Our approach outperformed state-of-the-art attacks on the ImageNet-1K classification task, achieving an average attack success rate improvement of 12.1%, while reducing the number of queries by 26.0% and the modified \(L_{0}\) norm by 41.1%.
* We advance query-based pixel attacks from image classification to object detection, introducing the query-based pixel attack. Our experiments demonstrate that our proposed method effectively compromises object detection systems. It achieves an average mean Average Precision (mAP) reduction of 0.29 in YOLO, comparable to state-of-the-art query-based attacks, while reducing the number of queries by 52.8%. To the best of our knowledge, the proposed method is the first black-box query-based pixel attack for object detection.
* To evaluate performance on a larger scale dataset, we conducted experiments using YOLOv8 as the victim model on the Argoverse-1.1 validation dataset. We also achieved a high removal rate of detected objects above 0.9 in Argoverse, similar to our results in MS-COCO. The results demonstrate that our proposed method effectively reduces the number of detected objects in images with a resolution of 1920\(\)1200. Additionally, examining the adversarial perturbation results of RFPAR on Argoverse and MS-COCO, we observe that it successfully reduces the number of detected objects while attacking only very small areas of 0.1% and 0.02%, respectively.

## 2 Remember and Forget Pixel Attack Using Reinforcement Learning

In this section, we introduce our proposed method. In Section 2.1, we define the problem mathematically. Section 2.2 details the Remember process, which is the internal iterative structure of our algorithm, including agent, environment, and memory. Finally, we explain the Forget process, which serves as the external iterative structure in Section 2.3.

### The Problem Formalization

We consider an image classifier as \(f:^{C H W}^{c}\), where \(C\), \(H\), and \(W\) represent the channel, height, and width of a given sample \(x\), respectively, and \(c\) denotes the number of classes. The classifier \(f\) computes probabilities for each class for a sample \(x\). Furthermore, \(f_{l}(x)\) is defined as the probability of a sample \(x\) being predicted as the \(l\)-th class. The prediction of the classifier can be expressed as \(_{l}\!f_{l}(x)\). For an image classification attack, the objective is to minimize a pixel perturbation \(\) such that the classifier's prediction for an input \(x\) diverges from its true label \(y\). This problem can be formalized as:

\[_{}&*{arg\, max}_{l}f_{l}(x+) y\\ &\|-x\|_{0}=\|\|_{0} ,^{+}.\] (1)

Here, \(\{1,2,\}\) and \(_{0}\) denotes the attack level and the \(L_{0}\) norm. \(\) is the perturbed image, defined as \(x+\). Notably, the attack levels are positive integers, which implies that the perturbations are at the pixel level.

Similarly, the object detector is defined by the function \(f:^{C H W}^{B 6}\), where \(B\) represents the maximum number of objects that can be detected by the model. The information about each bounding box location, object's class, and confidence score (indexed by \(l_{0}\)) is encapsulated in 6-dimensional vectors. To prevent the attack from targeting objects that are incorrectly predicted, we establish a confidence threshold of 0.5. If \(n\) objects surpass this threshold from among \(B\) candidates, then only these \(n\) objects are classified as detected. Furthermore, \(f_{l_{0}}^{o}(x)\) indicates the confidence score that the model identifies the \(o\)-th object as belonging to the predicted class from a sample \(x\). In this context, the number \(n(x)\) of detected objects from a sample \(x\) is \(_{o}1\{\ f_{l_{0}}^{o}(x)>0.5\}\), where \(1\) signifies the indicator function that takes the value one if the inequality holds and the value zero otherwise.

The goal of the object detector attack is to reduce the number of detected objects by modifying the minimum number of pixels, which is formally expressed as:\[_{} (n(x)-n())\] (2) s.t. \[\|\|_{0},^{+}.\]

where \(\) denotes the attack level and \(\) denotes the perturbed image. Therefore, our objective is to eliminate bounding boxes from the detection model by iteratively accumulating pixel attacks. We address this problem by combining one-step REINFORCE with our approach.

### Remember Process

Agent.We construct an environment where an attacking agent interacts to generate adversarial images. The agent's policy utilizes a CNN-based architecture, where given a sample \(x^{C H W}\), the agent observes the image and takes actions to determine the location (X, Y coordinates) and brightness (R, G, B) to modify, then generates perturbed images. We define two types of actions for brightness: "Write" and "Erase." The "Write" action overwrites the pixel with the maximum brightness, while the "Erase" action sets the brightness to zero. This configuration is chosen because, based on our experience, the attack success rate is higher when applying maximum changes to the pixels. Figure 1 shows the adversarial images generated by the agent. The agent generates the actions through random sampling of normal distributions, where the means and standard deviations are trained by the neural networks. The set of actions \(A_{t}\), where \(t\) represents the training epoch of RL, contains \(\) subsets corresponding to the number of attack pixels in each Remember process. These subsets are composed of the X, Y coordinates, and brightness values for each channel. The set \(A_{t}\) is defined as \(\{a_{1}^{1},a_{2}^{1},a_{3}^{1},,a_{C+2}^{1},,a_{1}^{},a_{2}^{},a_{3}^{},,a_{C+2}^{}\}\), where \(a_{1}\) and \(a_{2}\) represent the X and Y coordinates, respectively, and \(a_{3}\) to \(a_{C+2}\) represent the brightness values for each channel. For the "Write" action, the brightness values are set to the maximum value, whereas for the "Erase" action, they are set to 0. For each pixel, the perturbed image \(\) is generated as follows:

\[_{i,j,k}=a_{i+2}^{d}&j=a_{1}^{d}k=a_{2}^{d},\\ x_{i,j,k}&\] (3)

where \(i\), \(j\), and \(k\) are indices for channel, height, and width, respectively. In other words, \(_{i,j,k}\) represents the brightness at position \((j,k)\). Adding a pixel to the image is repeated for \(d\) from \(1\) to \(\). Hence, the image is perturbed by \(\) pixels. The equation describes the generation of \(\) by repeatedly altering the brightness of each channel at the position \((a_{1},a_{2})\) in the given sample \(x\). The agent trains by using the gradient of the reward and the log probability of the sampled actions.

Environment.The environment evaluates the image generated by the agent and assigns a reward. The reward \(r\) is defined as:

\[r=_{o=1}^{n}f_{l_{0}}^{o}(x)-f_{l_{0}}^{o}()+(),\] (4)

where \(n\) represents the number of detected objects in the image \(x\) for object detection, while \(()=(n(x)-n())\) signifies the number of removed objects after the adversarial attack. \(l_{0}\) is the index for the confidence score of the detected object. Hence, the reward is defined as the sum of the differences in confidence scores for each object plus the number of objects removed.

For classification, \(l_{0}\) is the index for the correct class, and \(n\) is set to 1. \(()\) is set to 1 if the adversarial image generation is successful and 0 otherwise. In essence, the reward is calculated as the sum of the differences in the probability of the correct class between the perturbed and original image, along with an additional component indicating whether the model successfully created an adversarial example.

Memory.The role of memory is to save the best reward value and its corresponding perturbed images. The stored information is also used to determine when the Forget process should start. Without memory, RL models tend to identify universally shared vulnerabilities in the clean images provided to the victim model. In contrast, our objective is to generate adversarial attacks regardless of these common vulnerabilities. To minimize unnecessary queries that converge on such vulnerabilities, we have incorporated memory concepts into the RL approach.

In our approach, memory stores the maximum reward values \(r^{*}\) and their corresponding perturbed images \(^{*}\) by selectively saving the higher reward as \(r^{*}=(r^{*},r_{t})\), where \(r_{t}\) denotes the rewardsgiven by the environments during the \(t\)-th training epoch. After training each epoch of data, the algorithm checks whether the reward values have bounded. We define the rewards as bounded if the following condition is satisfied:

\[-r^{*}}{r^{*}}<\] (5)

where \(\) signifies the bound threshold. This equation indicates that the rate of increase in the reward stored in memory is less than \(\). The convergence of rewards is defined as the rewards being bounded for a certain period, denoted as \(T\). Both \(\) and \(T\) are hyperparameters. If the reward converges, the Remember process ceases and the Forget process starts.

### Forget Process

The goal of the Forget process is to reset the trained RL model and its memory, and to feed the image \(^{*}\) as a new input for the reset RL model. Additionally, the maximum \(L_{0}\) increase for the reset RL model, as it is determined by the number of reward convergences, attack pixels, and channels. This process is implemented to prevent the agent from overfitting, which can hinder effective exploration of new inputs. The impact of memory and initialization is discussed in Section 3.5.

## 3 Experiments

Section 3.1 details the dataset, evaluation metrics, victim models, and hyperparameters used in our experiments. In Section 3.2, we evaluate our proposed attack on image classification by comparing

  Model & Test accuracy & Attack & Succes rate \(\) & \(L_{0}\) & Query \(\) \\   &  & OnePixel & 9.3 \% & 15 & 1453 \\  & & ScratchThat & 40.9 \% & 420 & 9418 \\  & & Pixle & 51.4 \% & 286 & 728 \\  & & **RFPAR(Ours)** & **64.1 \%** & 211 & 613 \\   &  & OnePixel & 8.1 \% & 15 & 5100 \\  & & ScratchThat & 38.1 \% & 95 & 1400 \\  & & Pixle & 89.1 \% & 538 & 663 \\  & & **RFPAR(Ours)** & **95.3 \%** & 138 & 442 \\   &  & OnePixel & 12.3 \% & 15 & 1358 \\  & & ScratchThat & 60.6 \% & 427 & 8653 \\  & & Pixle & 73.7 \% & 276 & 705 \\  & & **RFPAR(Ours)** & **88.4 \%** & 164 & 484 \\   &  & OnePixel & 14.1 \% & 15 & 1248 \\  & & ScratchThat & 60.6 \% & 425 & 8367 \\  & & Pixle & 82.3 \% & 243 & 625 \\  & & **RFPAR(Ours)** & **91.7 \%** & 152 & 464 \\   &  & OnePixel & 14.2 \% & 15 & 1128 \\  & & ScratchThat & 65.3 \% & 425 & 8828 \\  & & Pixle & 83.7 \% & 240 & 607 \\  & & **RFPAR(Ours)** & **95.0 \%** & 150 & 442 \\   &  & OnePixel & 8.1 \% & 15 & 1461 \\  & & ScratchThat & 51.8 \% & 420 & 9293 \\   & & Pixle & 69.6 \% & 306 & 769 \\   & & **RFPAR(Ours)** & **86.6 \%** & 213 & 596 \\  

Table 1: **The results of adversarial attacks on the ImageNet dataset. Each score represents the mean success rate of the attack, mean \(L_{0}\) norm and mean the number of queries. In terms of the success rate, a higher value signifies better performance, whereas for the \(L_{0}\) norm and the number of queries, lower values are indicative of superior performance. The best method is highlighted in bold.**it with previous attack methods. Section 3.3 compares the performance of our method on object detection, varying the attack dimension (\(=0.01\) to \(0.05\)), and compares the results with other query-based attacks. In Section 3.4, we conduct experiments on the Argoverse dataset, which has larger image dimensions, and discuss the findings. Finally, Section 3.5 presents an ablation study on the memory and initialization components we introduced. Additional experimental results can be found in Appendix C and D.

### Experimental Details

Datasets, Metrics and Hardware.For image classification, we use the validation dataset from ImageNet-1K. To reduce computational costs, we extract one correctly classified image per category from the victim model, resulting in a total dataset of 1000 images for adversarial attack attempts. We evaluate our methods with respect to different victim models by calculating the success rate, \(L_{0}\) norm, and the number of queries. The _success rate_ represents the percentage of successful adversarial attacks out of the 1000 images, with higher values indicating better performance. The \(L_{0}\) norm refers to the number of non-zero elements in perturbation \(\), with lower values indicating better performance. The number of _queries_ indicates how often the victim model is queried to generate an adversarial example, with fewer queries indicating better performance. The _ATA_ (ATacked Area) refers to the proportion of pixels in the image that were attacked, a lower value indicates fewer changes. For object detection, we use the 2017 validation set from the MS-COCO dataset and Argoverse-1.1 validation set. To facilitate comparison with PRFA  and GARSDC , we use mAP to evaluate the attacks. The mAP is calculated as the average over thresholds ranging from IOU = 0.5 to 0.95. Additionally, _RM_ indicates the average percentage of objects removed from the clean image, while _RD_ refers to the decrease in mAP. Both a lower mAP and a higher RM indicate greater success. Lastly, we used an AMD Ryzen 9 5900X, RTX 3090TI, and 64.0GB of RAM, running on Windows 11 with CUDA version 12.1.

Victim Models.For image classification, we select six pre-trained models on the PyTorch platform as victim models: VIT, ResNeXt50, RegNetX-32GF, DenseNet161, MNASNet, and MobileNet-V3. We compare the performance of our attack with OnePixel, ScratchThat, and Pixle. For object detection, we use the pre-trained YOLOv8n model from the YOLOv8 platform and the pre-trained DDQ DETR-4scale model from the MMDetection platform.

Hyperparameter.Our attack method utilizes four hyperparameters: the maximum number of iterations, the pixel attack rate \(\), the bound threshold \(\), and the duration \(T\) for maintaining the convergence condition. In the Remember process, \(\) is a hyperparameter that determines the number of pixels to attack, proportional to the image size. The number of pixels \(\) to be attacked is defined as \((H+W)/2\). By default, we set the maximum number of iterations to 100 and \(\) to 0.05. For image classification, we use \(T=3\) and \(=0.01\). For object detection, we experiment with \(T=20\) and \(\) values ranging from \(0.01\) to \(0.05\).

### Evaluation of Classification Attacks

Table 1 presents a performance comparison of various adversarial attack methods on different victim models for image classification. RFPAR consistently achieves the highest success rate, significantly outperforming the other three attack methods. For instance, for the VIT model, RFPAR achieves a success rate of 64.1%, compared to OnePixel's 9.3%, ScratchThat's 40.9%, and Pixle's 51.4%. The trend is similar for other models, with RFPAR showing substantial improvements in success rate. Regarding the \(L_{0}\) norm, which measures the sparsity of the perturbations, RFPAR generally achieves a lower \(L_{0}\) norm than ScratchThat and Pixle but higher than OnePixel. For example, in the case of ResNeXt50, RFPAR has an \(L_{0}\) norm of 138, compared to OnePixel's 15, ScratchThat's 95, and Pixle's 538. While OnePixel has the lowest \(L_{0}\) norm, its success rate is significantly lower than RFPAR's, indicating a trade-off between perturbation sparsity and attack effectiveness. In terms of the number of queries, RFPAR requires fewer queries than the other methods, except for OnePixel in some cases. This demonstrates that RFPAR is more efficient in terms of query cost, which is crucial for practical adversarial attacks. Overall, RFPAR exhibits superior performance across all victim models in terms of success rate while maintaining competitive \(L_{0}\) norms and requiring fewer queries compared to other methods, making it an effective and efficient approach.

### Evaluation of Object Detection Attacks

Attacking object detection models is more challenging than attacking image classification models because there are more objects to consider in the object detection task. More pixels need to be modified, adjusted by \(\) from 0.01 to 0.05, to deceive the victim models. Table 2 compares the performance of different \(\) values of the RFPAR method on two object detection models, YOLOv8 and DDQ. The RM rate for YOLOv8 increases from 0.65 (\(_{0.01}\)) to 0.91 (\(_{0.05}\)) and for DDQ from 0.60 to 0.83, indicating that stronger attacks remove more detected objects. The mAP also decreases from 0.218 to 0.111 for YOLOv8 and from 0.125 to 0.054 for DDQ. At \(=0.05\), our attack successfully reduced the mAP by an average of 0.301 and achieved a RM of 0.87. The number of queries remains relatively stable, ranging from 1254 to 1427 for YOLOv8 and from 1450 to 1690 for DDQ, suggesting a consistent query cost despite increasing perturbation intensity. Overall, the results indicate that the RFPAR method is highly effective in generating adversarial attacks on object detection models, balancing perturbation sparsity, and attack effectiveness while maintaining query efficiency.

To demonstrate the effectiveness of our method, we compared it with other query-based black-box attacks. Table 3 shows the performance of three different attack methods - PRFA, GARSDC, and RFPAR - on the YOLO object detection model. In this table, RD refers to the decreased mAP value, and Query indicates the average number of queries. The RFPAR method shows strong performance by achieving the highest RD (tied with GARSDC) and requiring the fewest queries. This indicates that RFPAR is not only effective in reducing the YOLO model's performance but also efficient in terms of the number of queries needed to achieve this reduction. GARSDC also demonstrates high effectiveness with the same reduction as RFPAR but requires more than twice the number of queries. Overall, RFPAR stands out as the most balanced and efficient attack method in this comparison.

### Experiments on a Larger Scale Data

To verify the effectiveness of our proposed method on larger dimensions 1920\(\)1200, we randomly selected one video sample from the Argoverse dataset and conducted experiments using YOLOv8. The experimental results are presented in Table 4. The RM achieved 0.94, indicating a successful reduction in the number of detected objects. Argoverse achieved a RM of 0.94, similar to the RM observed for MS-COCO. The ATA for these datasets was 0.1% and 0.02%, respectively, indicating that only a very small portion of the image area was attacked. However, the

    &  \\   & RM \(\) & RD \(\) & ATA \(\) & Query \(\) \\  MS-COCO & 0.91 & 0.29 & 0.02 \% & 1270 \\ Argoverse & 0.94 & 0.05 & 0.10 \% & 1906 \\   

Table 4: **Comparison on dataset.** ATA means the ratio of altered pixels to the image size.

    &  &  \\   & RM \(\) & mAP \(\) & L\({}_{0}\) & Query \(\) & RM \(\) & mAP \(\) & L\({}_{0}\) & Query \(\) \\  clean & - & 0.398 & - & - & - & 0.376 & - & - \\ RFPAR\({}_{0.01}\) & 0.65 & 0.218 & 521 & 1403 & 0.60 & 0.125 & 391 & 1450 \\ RFPAR\({}_{0.02}\) & 0.70 & 0.187 & 955 & 1427 & 0.73 & 0.103 & 787 & 1690 \\ RFPAR\({}_{0.03}\) & 0.75 & 0.151 & 1459 & 1374 & 0.76 & 0.075 & 1074 & 1512 \\ RFPAR\({}_{0.04}\) & 0.76 & 0.150 & 1814 & 1348 & 0.80 & 0.061 & 1429 & 1457 \\
**RFPAR\({}_{0.05}\)** & 0.91 & 0.111 & 2043 & 1254 & 0.83 & 0.054 & 1780 & 1528 \\   

Table 2: **Attack Results on Object Detection Models.** The subscripts after RFPAR denote a pixel attack rate, \(\). RM indicates the average percentage of objects removed from the clean image. \(L_{0}\) represents the average \(\|\|_{0}\). Query denotes the average number of queries made to the victim model. Higher RM, lower mAP, lower \(L_{0}\), and lower Query values indicate better performance.

    &  \\   & RD \(\) & Query \(\) \\  PRFA & 0.21 & 2949 \\ GARSDC & **0.29** & 2691 \\ RFPAR & **0.29** & **1270** \\   

Table 3: **Comparison to other methods.** RD means reduction in mAP.

mAP did not decrease as significantly as in previous experiments. This discrepancy can be explained by considering that RFPAR primarily reduces the number of objects detected. If a particular class has many objects, reducing their number may not significantly impact the overall mAP due to the presence of other classes. In summary, while RFPAR successfully removes objects in the larger Argoverse dataset, its effectiveness in reducing mAP is limited in datasets with a high density of objects in specific classes.

### Ablation study

In this section, we analyze the impact of Initialization (I) and Memory (M) on our model's performance. If Initialization is ablated in the Forget process, the Agent is not reinitialized and retains information from the previous Remember process. On the other hand, if Memory is ablated, the Agent's reward, instead of the reward stored in Memory, serves as a bound condition. We conduct ablation experiments under similar query conditions and present the results in Appendix G. As shown in Figure 3, RFPAR denotes the baseline state without I and M, while RFPAR\({}_{*}\) indicates the inclusion of specific processes. Comparing RFPAR and RFPAR\({}_{M}\), it is evident that the introduction of memory significantly enhances the attack success rate. This result suggests that the RL method benefits from storing the highest-reward images of restricted pixels during each Forget process. When comparing RFPAR\({}_{I}\) and RFPAR\({}_{M+I}\), we observe that initialization prevents RL model from overfitting to specific patterns and escaping local optima, thereby improving performance. Conversely, the comparison between RFPAR and RFPAR\({}_{I}\) indicates that Initialization alone, without memory, has a negligible impact. This finding implies that RL model without memory fails to generate meaningful adversarial attacks. In summary, memory supports RL model in generating effective adversarial attacks, while Initialization prevents overfitting and enhances overall performance.

## 4 Conclusion

In this paper, we propose the Remember and Forget Pixel Attack using Reinforcement Learning (RFPAR) for attacking neural network models with limited pixels. Traditional pixel-based attacks have been confined to image classification, but our method extends this approach to include object detection as well. For image classification, we compared the performance of RFPAR against OnePixel, ScratchThat, and PIXLE across six victim models using the ImageNet-1K dataset, and RFPAR demonstrated superior performance. In object detection, we evaluated RFPAR on the MS-COCO dataset using YOLOv8 and DDQ models, comparing it with PRFA and GARSDC attacks. RFPAR achieved performance comparable to the state-of-the-art query-based attack GARSDC, while reducing the number of queries by 52.8%, proving its efficiency. Additionally, we showed that RFPAR is capable of performing pixel attacks on larger datasets, specifically the Argoverse dataset with dimensions, surpassing the sizes of the ImageNet and MS-COCO datasets. Our findings may enable malicious individuals to compromise real-world AI systems. Consequently, research on defenses against adversarial attacks is becoming increasingly important.

Broader Impacts.Defects in camera sensors, such as hot pixels or dead pixels, can impact image quality and degrade the performance of neural network models. Our approach mimics these camera defects. In this paper, RFPAR simulates real-world issues by replacing specific pixels with

Figure 3: **Ablation study. The x and y axes show different victim models and the attack success rate, respectively. The notation \({}_{I}\) signifies the inclusion of the initialization step in the Forget process, and \({}_{M}\) denotes that the Remember process incorporates memory.**

values of either zero or one, inducing incorrect predictions by the neural network. Since these types of perturbations can occur in practice, it is crucial for neural networks to be robust against them. However, research on pixel-based \(L_{0}\) attacks is limited compared to other types of attacks. Our approach helps analyze model vulnerabilities with respect to both adversarial attacks and real-world scenarios, contributing to the development of more robust neural networks that can withstand such defects. Additionally, the phenomenon where the prediction changes with only a small number of pixel modifications that do not alter the overall meaning can be considered an anomaly in artificial neural networks. This type of attack provides important insights into understanding the limitations of neural networks.

Limitations.In this work, the pixel values are either zero or one. While the meaning remains unchanged, this can still make it noticeable in certain cases. Additionally, the Forget process is quite simple. The time complexity of RFPAR is worse than that of other pixel attacks. However, at the ImageNet scale, RFPAR outperforms others in speed. This result is presented in Appendix H. In future work, we will apply meta-learning to the Forget process and aim to reduce not only \(L_{0}\), but also \(L_{}\).

Negative Impacts.In applications like defective product detection  and disease prediction systems , adversarial attacks could degrade product quality or lead to incorrect diagnoses, which may have serious, or even fatal, consequences. Our proposed approach increases the effectiveness of query-based black-box attacks, making them more applicable to real-world scenarios. As a result, vision AI systems may face significant threats to their functionality and reliability. Therefore, it is crucial for these systems to proactively identify potential vulnerabilities and implement robust defenses.

Mitigation of Risks.Our method requires an average of over 1000 queries to successfully deceive an object detection model. Similarly, as shown in Table 7 in the Appendix E, transformer-based models also require an average of over 1000 queries to achieve a high success rate. If we limit the number of queries to around 1000 in a short period of time, our method can easily defend the model. For CNN-based models, since fewer queries are needed, limiting the queries to 400 can effectively defend the model. Additionally, according to the attack results on adversarially trained models shown in Table 8 in the Appendix F, adversarial training effectively reduces the attack success rate and increases the number of queries needed. Therefore, by adversarially training the models and appropriately limiting the queries, this attack can be defended against.