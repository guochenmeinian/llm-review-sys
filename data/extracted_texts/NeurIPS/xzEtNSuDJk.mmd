# LIBERO: Benchmarking Knowledge Transfer for

Lifelong Robot Learning

 Bo Liu,\({}^{}\)Yifeng Zhu\({}^{*}\), \({}^{}\)Chongkai Gao\({}^{*}\), \({}^{}\)Yihao Feng

\({}^{}\)Qiang Liu, \({}^{}\)Yuke Zhu, \({}^{,@sectionsign}\)Peter Stone

\({}^{}\)The University of Texas at Austin, \({}^{@sectionsign}\)Sony AI, \({}^{}\)Tsinghua University

{bliu,yifengz,lqiang,yukez,pstone}@cs.utexas.edu

yihao.ac@gmail.com, gck20@mails.tsinghua.edu.cn

Equal contribution.

###### Abstract

Lifelong learning offers a promising paradigm of building a generalist agent that learns and adapts over its lifespan. Unlike traditional lifelong learning problems in image and text domains, which primarily involve the transfer of declarative knowledge of entities and concepts, lifelong learning in decision-making (LLDM) also necessitates the transfer of procedural knowledge, such as actions and behaviors. To advance research in LLDM, we introduce LIBERO, a novel benchmark of lifelong learning for robot manipulation. Specifically, LIBERO highlights five key research topics in LLDM: **1)** how to efficiently transfer declarative knowledge, procedural knowledge, or the mixture of both; **2)** how to design effective policy architectures and **3)** effective algorithms for LLDM; **4)** the robustness of a lifelong learner with respect to task ordering; and **5)** the effect of model pretraining for LLDM. We develop an extendible _procedural generation_ pipeline that can in principle generate infinitely many tasks. For benchmarking purpose, we create four task suites (130 tasks in total) that we use to investigate the above-mentioned research topics. To support sample-efficient learning, we provide high-quality human-teleoperated demonstration data for all tasks. Our extensive experiments present several insightful or even _unexpected_ discoveries: sequential finetuning outperforms existing lifelong learning methods in forward transfer, no single visual encoder architecture excels at all types of knowledge transfer, and naive supervised pretraining can hinder agents' performance in the subsequent LLDM.2

## 1 Introduction

A longstanding goal in machine learning is to develop a generalist agent that can perform a wide range of tasks. While multitask learning  is one approach, it is computationally demanding and not adaptable to ongoing changes. Lifelong learning , however, offers a practical solution by amortizing the learning process over the agent's lifespan. Its goal is to leverage prior knowledge to facilitate learning new tasks (forward transfer) and use the newly acquired knowledge to enhance performance on prior tasks (backward transfer).

The main body of the lifelong learning literature has focused on how agents transfer _declarative_ knowledge in visual or language tasks, which pertains to _declarative knowledge_ about entities and concepts . Yet it is understudied how agents transfer knowledge in decision-making tasks, which involves a mixture of both _declarative_ and _procedural_ knowledge (knowledge about how to _do_ something). Consider a scenario where a robot, initially trained to retrieve juice from a fridge, failsafter learning new tasks. This could be due to forgetting the juice or fridge's location (declarative knowledge) or how to open the fridge or grasp the juice (procedural knowledge). So far, we lack methods to systematically and quantitatively analyze this complex knowledge transfer.

To bridge this research gap, this paper introduces a new simulation benchmark, LIfelong learning Bechmark on RObot manipulation tasks, LIBERO, to facilitate the systematic study of lifelong learning in decision making (LLDM). An ideal LLDM testbed should enable continuous learning across an expanding set of diverse tasks that share concepts and actions. LIBERO supports this through a procedural generation pipeline for endless task creation, based on robot manipulation tasks with shared visual concepts (declarative knowledge) and interactions (procedural knowledge).

For benchmarking purpose, LIBERO generates 130 language-conditioned robot manipulation tasks inspired by human activities  and, grouped into four suites. The four task suites are designed to examine distribution shifts in the object types, the spatial arrangement of objects, the task goals, or the mixture of the previous three (top row of Figure 1). LIBERO is scalable, extendable, and designed explicitly for studying lifelong learning in robot manipulation. To support efficient learning, we provide high-quality, human-teleoperated demonstration data for all 130 tasks.

We present an initial study using LIBERO to investigate five major research topics in LLDM (Figure 1): **1)** knowledge transfer with different types of distribution shift; **2)** neural architecture design; **3)** lifelong learning algorithm design; **4)** robustness of the learner to task ordering; and **5)** how to leverage pre-trained models in LLDM (bottom row of Figure 1). We perform extensive experiments across different policy architectures and different lifelong learning algorithms. Based on our experiments, we make several insightful or even **unexpected** observations:

1. Policy architecture design is as crucial as lifelong learning algorithms. The transformer architecture is better at abstracting temporal information than a recurrent neural network. Vision transformers work well on tasks with rich visual information (e.g., a variety of objects). Convolution networks work well when tasks primarily need procedural knowledge.
2. While the lifelong learning algorithms we evaluated are effective at preventing forgetting, they generally perform _worse_ than sequential finetuning in terms of forward transfer.
3. Our experiment shows that using pretrained language embeddings of semantically-rich task descriptions yields performance _no better_ than using those of the task IDs.

Figure 1: **Top**: LIBERO has four procedurally-generated task suites: LIBERO-Spatial, LIBERO-Object, and LIBERO-Goal have 10 tasks each and require transferring knowledge about spatial relationships, objects, and task goals; LIBERO-100 has 100 tasks and requires the transfer of entangled knowledge. **Bottom**: we investigate five key research topics in LLDM on LIBERO.

4. Basic supervised pretraining on a large-scale offline dataset can have a _negative_ impact on the learner's downstream performance in LLDM.

## 2 Background

This section introduces the problem formulation and defines key terms used throughout the paper.

### Markov Decision Process for Robot Learning

A robot learning problem can be formulated as a finite-horizon Markov Decision Process: \(=(,,,H,\ _{0},)\). Here, \(\) and \(\) are the state and action spaces of the robot. \(_{0}\) is the initial state distribution, \(R:\) is the reward function, and \(:\) is the transition function. In this work, we assume a sparse-reward setting and replace \(R\) with a goal predicate \(g:\{0,1\}\). The robot's objective is to learn a policy \(\) that maximizes the expected return: \(_{}J()=_{s_{t},a_{t},_{0}}[_{t=1}^{H}g(s_{t})]\).

### Lifelong Robot Learning Problem

In a _lifelong robot learning problem_, a robot sequentially learns over \(K\) tasks \(\{T^{1},,T^{K}\}\) with a single policy \(\). We assume \(\) is conditioned on the task, i.e., \(( s;T)\). For each task, \(T^{k}(_{0}^{k},g^{k})\) is defined by the initial state distribution \(_{0}^{k}\) and the goal predicate \(g^{k}\).3 We assume \(,,,H\) are the same for all tasks. Up to the \(k\)-th task \(T^{k}\), the robot aims to optimize

\[_{}\ J_{}()=_{p=1}^{k}}_{s_{t}^{p},a_{t}^{p}(:T^{p}),\ _{0}^{p}}_{t=1}^{L}g^{p}(s_{t}^{p}).\] (1)

An important feature of the lifelong setting is that the agent loses access to the previous \(k-1\) tasks when it learns on task \(T^{k}\).

Lifelong Imitation LearningDue to the challenge of sparse-reward reinforcement learning, we consider a practical alternative setting where a user would provide a small demonstration dataset for each task in the sequence. Denote \(D^{k}=\{_{i}^{k}\}_{i=1}^{N}\) as \(N\) demonstrations for task \(T^{k}\). Each \(_{i}^{k}=(o_{0},a_{0},o_{1},a_{1},,o_{l^{k}})\) where \(l^{k} H\). Here, \(o_{t}\) is the robot's sensory input, including the perceptual observation and the information about the robot's joints and gripper. In practice, the observation \(o_{t}\) is often non-Markovian. Therefore, following works in partially observable MDPs , we represent \(s_{t}\) by the aggregated history of observations, i.e. \(s_{t} o_{ t}(o_{0},o_{1},,o_{t})\). This results in the _lifelong imitation learning problem_ with the same objective as in Eq. (1). But during training, we perform behavioral cloning  with the following surrogate objective function:

\[_{}\ J_{}()=_{p=1}^{k}}_{o_{t},a_{t} D}_{t=0}^{l^{p}} (o_{ t};T^{p}),a_{t}^{p}\,,\] (2)

where \(\) is a supervised learning loss, e.g., the negative log-likelihood loss, and \(\) is a Gaussian mixture model. Similarly, we assume \(\{D^{p}:p<k\}\) are not fully available when learning \(T^{k}\).

## 3 Research Topics in LLDM

We outline five major research topics in LLDM that motivate the design of LIBERO and our study.

(T1) Transfer of Different Types of KnowledgeIn order to accomplish a task such as _put the ketchup next to the plate in the basket_, a robot must understand the concept _ketchup_, the location of the _plate/basket_, and how to _put_ the ketchup in the basket. Indeed, robot manipulation tasks in general necessitate different types of knowledge, making it hard to determine the cause of failure. We present four task suites in Section 4.2: three task suites for studying the transfer of knowledge about spatial relationships, object concepts, and task goals in a disentangled manner, and one suite for studying the transfer of mixed types of knowledge.

(T2) Neural Architecture DesignAn important research question in LLDM is how to design effective neural architectures to abstract the multi-modal observations (images, language descriptions, and robot states) and transfer only relevant knowledge when learning new tasks.

(T3) Lifelong Learning Algorithm DesignGiven a policy architecture, it is crucial to determine what learning algorithms to apply for LLDM. Specifically, the sequential nature of LLDM suggests that even minor forgetting over successive steps can potentially lead to a total failure in execution. As such, we consider the design of lifelong learning algorithms to be an open area of research in LLDM.

(T4) Robustness to Task OrderingIt is well-known that task curriculum influences policy learning [6; 48]. A robot in the real world, however, often cannot choose which task to encounter first. Therefore, a good lifelong learning algorithm should be robust to different task orderings.

(T5) Usage of Pretrained ModelsIn practice, robots will be most likely pretrained on large datasets in factories before deployment . However, it is not well-understood whether or how pretraining could benefit subsequent LLDM.

## 4 Libero

This section introduces the components in LIBERO: the procedural generation pipeline that allows the never-ending creation of tasks (Section 4.1), the four task suites we generate for benchmarking (Section 4.2), five algorithms (Section 4.3), and three neural architectures (Section 4.4).

### Procedural Generation of Tasks

Research in LLDM requires a systematic way to create new tasks while maintaining task diversity and relevance to existing tasks. LIBERO procedurally generates new tasks in three steps: **1)** extract behavioral templates from language annotations of human activities and generate sampled tasks described in natural language based on such templates; **2)** specify an initial object distribution given a task description; and **3)** specify task goals using a propositional formula that aligns with the language instructions. Our generation pipeline is built on top of Robosuite, a modular manipulation simulator that offers seamless integration. Figure 2 illustrates an example of task creation using this pipeline, and each component is expanded upon below.

Behavioral Templates and Instruction GenerationHuman activities serve as a fertile source of tasks that can inspire and generate a vast number of manipulation tasks. We choose a large-scale activity dataset, Ego4D , which includes a large variety of everyday activities with language annotations. We pre-process the dataset by extracting the language descriptions and then summarize them into a large set of commonly used language templates. After this pre-processing step, we use the templates and select objects available in the simulator to generate a set of task descriptions in the

Figure 2: LIBERO’s procedural generation pipeline: Extracting behavioral templates from a large-scale human activity dataset **(1)**, Ego4D, for generating task instructions **(2)**; Based on the task description, selecting the scene and generating the PDDL description file **(3)** that specifies the objects and layouts **(A)**, the initial object configurations **(B)**, and the task goal **(C)**.

form of language instructions. For example, we can generate an instruction "Open the drawer of the cabinet" from the template "Open...".

Initial State Distribution (\(_{0}\)) To specify \(_{0}\), we first sample a scene layout that matches the objects/behaviors in a provided instruction. For instance, a kitchen scene is selected for an instruction _Open the top drawer of the cabinet and put the bowl in it_. Then, the details about \(_{0}\) are generated in the PDDL language . Concretely, \(_{0}\) contains information about object categories and their placement (Figure 2-(**A**)), and their initial status (Figure 2-(**B**)).

Goal Specifications\((g)\)Based on \(_{0}\) and the language instruction, we specify the task goal using a conjunction of predicates. Predicates include _unary predicates_ that describe the properties of an object, such as Open(X) or TurnOff(X), and _binary predicates_ that describe spatial relations between objects, such as On(A, B) or In(A, B). An example of the goal specification using PDDL language can be found in Figure 2-(**C**). The simulation terminates when all predicates are verified true.

### Task Suites

While the pipeline in Section 4.1 supports the generation of an unlimited number of tasks, we offer fixed sets of tasks for benchmarking purposes. LIBERO has four task suites: LIBERO-Spatial, LIBERO-Object, LIBERO-Goal, and LIBERO-100. The first three task suites are curated to disentangle the transfer of _declarative_ and _procedural_ knowledge (as mentioned in (T1)), while LIBERO-100 is a suite of 100 tasks with entangled knowledge transfer.

Llibero-X LIBERO-Spatial, LIBERO-Object, and LIBERO-Goal all have 10 tasks4 and are designed to investigate the controlled transfer of knowledge about spatial information (declarative), objects (declarative), and task goals (procedural). Specifically, all tasks in LIBERO-Spatial request the robot to place a bowl, among the same set of objects, on a plate. But there are two identical bowls that differ only in their location or spatial relationship to other objects. Hence, to successfully complete LIBERO-Spatial, the robot needs to continually learn and memorize new spatial relationships. All tasks in LIBERO-Object request the robot to pick-place a unique object. Hence, to accomplish LIBERO-Object, the robot needs to continually learn and memorize new object types. All tasks in LIBERO-Goal share the same objects with fixed spatial relationships but differ only in the task goal. Hence, to accomplish LIBERO-Goal, the robot needs to continually learn new knowledge about motions and behaviors. More details are in Appendix C.

Llibero-100 LIBERO-100 contains 100 tasks that entail diverse object interactions and versatile motor skills. In this paper, we split LIBERO-100 into 90 short-horizon tasks (LIBERO-90) and 10 long-horizon tasks (LIBERO-Long). LIBERO-90 serves as the data source for pretraining (**T5**) and LIBERO-Long for downstream evaluation of lifelong learning algorithms.

### Lifelong Learning Algorithms

We implement three representative lifelong learning algorithms to facilitate research in algorithmic design for LLDM. Specifically, we implement Experience Replay (ER) , Elastic Weight Consolidation (EWC) , and PackNet. We pick ER, EWC, and PackNet because they correspond to the memory-based, regularization-based, and dynamic-architecture-based methods for lifelong learning. In addition, prior research  has discovered that they are state-of-the-art methods. Besides these three methods, we also implement sequential finetuning (SeqL) and multitask learning (MTL), which serve as a lower bound and upper bound for lifelong learning algorithms, respectively. More details about the algorithms are in Appendix B.1.

### Neural Network Architectures

We implement three vision-language policy networks, ResNet-RNN, ResNet-T, and ViT-T, that integrate visual, temporal, and linguistic information for LLDM. Language instructions of tasks are encoded using pretrained BERT embeddings . The ResNet-RNN  uses a ResNet as the visual backbone that encodes per-step visual observations and an LSTM as the temporal backbone to process a sequence of encoded visual information. The language instruction is incorporated into the ResNet features using the FiLM method  and added to the LSTM inputs, respectively. ResNet-Tarchitecture  uses a similar ResNet-based visual backbone, but a transformer decoder  as the temporal backbone to process outputs from ResNet, which are a temporal sequence of visual tokens. The language embedding is treated as a separate token in inputs to the transformer alongside the visual tokens. The ViT-T architecture , which is widely used in visual-language tasks, uses a Vision Transformer (ViT) as the visual backbone and a transformer decoder as the temporal backbone. The language embedding is treated as a separate token in inputs of both ViT and the transformer decoder. All the temporal backbones output a latent vector for every decision-making step. We compute the multi-modal distribution over manipulation actions using a Gaussian-Mixture-Model (GMM) based output head [8; 42; 68]. In the end, a robot executes a policy by sampling a continuous value for end-effector action from the output distribution. Figure 6 visualizes the three architectures.

For all the lifelong learning algorithms and neural architectures, we use behavioral cloning (BC)  to train policies for individual tasks (See (2)). BC allows for efficient policy learning such that we can study lifelong learning algorithms with limited computational resources. To train BC, we provide 50 trajectories of high-quality demonstrations for every single task in the generated task suites. The demonstrations are collected by human experts through teleoperation with 3Dconnexion Spacemouse.

## 5 Experiments

Experiments are conducted as an initial study for the five research topics mentioned in Section 3. We first introduce the evaluation metric used in experiments, and present analysis of empirical results in LIBERO. The detailed experimental setup is in Appendix D. Our experiments focus on addressing the following research questions:

**Q1**: How do different architectures/LL algorithms perform under specific distribution shifts?

**Q2**: To what extent does neural architecture impact knowledge transfer in LLDM, and are there any discernible patterns in the specialized capabilities of each architecture?

**Q3**: How do existing algorithms from lifelong supervised learning perform on LLDM tasks?

**Q4**: To what extent does language embedding affect knowledge transfer in LLDM?

**Q5**: How robust are different LL algorithms to task ordering in LLDM?

**Q6**: Can supervised pretraining improve downstream lifelong learning performance in LLDM?

### Evaluation Metrics

We report three metrics: FWT (forward transfer) , NBT (negative backward transfer), and AUC (area under the success rate curve). All metrics are computed in terms of success rate, as previous literature has shown that the success rate is a more reliable metric than training loss for manipulation policies  (Detailed explanation in Appendix E.2). Lower NBT means a policy has better performance in the previously seen tasks, higher FWT means a policy learns faster on a new task, and higher AUC means an overall better performance considering both NBT and FWT. Specifically, denote \(c_{i,j,e}\) as the agent's success rate on task \(j\) when it learned over \(i-1\) previous tasks and has just learned \(e\) epochs (\(e\{0,5,,50\}\)) on task \(i\). Let \(c_{i,i}\) be the best success rate over all evaluated epochs \(e\) for the current task \(i\) (i.e., \(c_{i,i}=_{e}c_{i,i,e}\)). Then, we find the earliest epoch \(e_{i}^{*}\) in which the agent achieves the best performance on task \(i\) (i.e., \(e_{i}^{*}=_{e}c_{i,i,e_{i}}=c_{i,i}\)), and assume for all \(e e_{i}^{*}\), \(c_{i,i,e}=c_{i,i}\).5 Given a different task \(j i\), we define \(c_{i,j}=c_{i,j,e_{i}^{*}}\). Then the three metrics are defined:

\[=_{k[K]}_{k}}{K},\ \ \ _{k}=_{e\{0  50\}}c_{k,k,e}\] (3) \[=_{k[K]}_{k}}{K},\ \ \ _{k}=_{ =k+1}^{K}(c_{k,k}-c_{,k})\] \[=_{k[K]}_{k}}{K},\ \ _{k}= _{k}+_{=k+1}^{K}c_{,k}\]

### Experimental Results

We present empirical results to address the research questions. Please refer to Appendix E.1 for the full results across all algorithms, policy architectures, and task suites.

Study on the Policy's Neural Architectures (Q1, Q2)Table 1 reports the agent's lifelong learning performance using the three different neural architectures on the four task suites. Results are reported when ER and PackNet are used as they demonstrate the best lifelong learning performance across all task suites.

Findings:First, we observe that ResNet-T and ViT-T work much better than ResNet-RNN on average, indicating that using a transformer on the "temporal" level could be a better option than using an RNN model. Second, the performance difference among different architectures depends on the underlying lifelong learning algorithm. If PackNet (a dynamic architecture approach) is

    &  &  \\   & FWT(\(\)) & NBT(\(\)) & AUC(\(\)) & FWT(\(\)) & NBT(\(\)) & AUC(\(\)) \\   \\  ResNet-RNN & 0.16 \(\) 0.02 & **0.16**\(\) 0.02 & 0.08 \(\) 0.01 & 0.13 \(\) 0.00 & 0.21 \(\) 0.01 & 0.03 \(\) 0.00 \\ ResNet-T & **0.48**\(\) 0.02 & 0.32 \(\) 0.04 & **0.32**\(\) 0.01 & 0.22 \(\) 0.01 & **0.08**\(\) 0.01 & 0.25 \(\) 0.00 \\ ViT-T & 0.38 \(\) 0.05 & 0.29 \(\) 0.06 & 0.25 \(\) 0.02 & **0.36**\(\) 0.01 & 0.14 \(\) 0.01 & **0.34**\(\) 0.01 \\   \\  ResNet-RNN & 0.40 \(\) 0.02 & 0.29 \(\) 0.02 & 0.29 \(\) 0.01 & 0.27 \(\) 0.03 & 0.38 \(\) 0.03 & 0.06 \(\) 0.01 \\ ResNet-T & **0.65**\(\) 0.03 & **0.27**\(\) 0.03 & **0.56**\(\) 0.01 & 0.55 \(\) 0.01 & **0.07**\(\) 0.02 & **0.63**\(\) 0.00 \\ ViT-T & 0.63 \(\) 0.01 & 0.29 \(\) 0.02 & 0.50 \(\) 0.02 & **0.57**\(\) 0.04 & 0.15 \(\) 0.00 & 0.59 \(\) 0.03 \\   \\  ResNet-RNN & 0.30 \(\) 0.01 & **0.27**\(\) 0.05 & 0.17 \(\) 0.05 & 0.29 \(\) 0.02 & 0.35 \(\) 0.02 & 0.13 \(\) 0.01 \\ ResNet-T & 0.67 \(\) 0.07 & 0.43 \(\) 0.04 & 0.44 \(\) 0.06 & **0.60**\(\) 0.07 & **0.17**\(\) 0.05 & **0.60**\(\) 0.05 \\ ViT-T & **0.70**\(\) 0.02 & 0.28 \(\) 0.01 & **0.57**\(\) 0.01 & 0.58 \(\) 0.03 & 0.18 \(\) 0.02 & 0.56 \(\) 0.04 \\   \\  ResNet-RNN & 0.41 \(\) 0.00 & 0.35 \(\) 0.01 & 0.26 \(\) 0.01 & 0.32 \(\) 0.03 & 0.37 \(\) 0.04 & 0.11 \(\) 0.01 \\ ResNet-T & **0.64**\(\) 0.01 & **0.34**\(\) 0.02 & **0.49**\(\) 0.02 & 0.63 \(\) 0.02 & **0.06**\(\) 0.01 & 0.75 \(\) 0.01 \\ ViT-T & 0.57 \(\) 0.00 & 0.40 \(\) 0.02 & 0.38 \(\) 0.01 & **0.69**\(\) 0.02 & 0.08 \(\) 0.01 & **0.76**\(\) 0.02 \\   

Table 1: Performance of the three neural architectures using ER and PackNet on the four task suites. Results are averaged over three seeds and we report the mean and standard error. The best performance is **bolded**, and colored in **purple** if the improvement is statistically significant over other neural architectures, when a two-tailed, Student’s t-test under equal sample sizes and unequal variance is applied with a \(p\)-value of 0.05.

Figure 3: Metrics for LLDM.

used, we observe no significant performance difference between ResNet-T and ViT-T except on the LIBERO-Long task suite where ViT-T performs much better than ResNet-T. In contrast, if ER is used, we observe that ResNet-T performs better than ViT-T on all task suites except LIBERO-Object. This potentially indicates that the ViT architecture is better at processing visual information with more object varieties than the ResNet architecture when the network capacity is sufficiently large (See the MTL results in Table 8 on LIBERO-Object as the supporting evidence). The above findings shed light on how one can improve architecture design for better processing of spatial and temporal information in LLDM.

Study on Lifelong Learning Algorithms (Q1, Q3) Table 2 reports the lifelong learning performance of the three lifelong learning algorithms, together with the SeqL and MTL baselines. All experiments use the same ResNet-T architecture as it performs the best across all policy architectures.

Findings:We observed a series of interesting findings that could potentially benefit future research on algorithm design for LLDM: **1)** SeqL shows the best FWT over all task suites. This is surprising since it indicates all lifelong learning algorithms we consider actually hurt forward transfer; **2)** PackNet outperforms other lifelong learning algorithms on LIBERO-X but is outperformed by ER significantly on LIBERO-Long, mainly because of low forward transfer. This confirms that the dynamic architecture approach is good at preventing forgetting. But since PackNet splits the network into different sub-networks, the essential capacity of the network for learning any individual task is smaller. Therefore, we conjecture that PackNet is not rich enough to learn on LIBERO-Long; **3)** EWC works worse than SeqL, showing that the regularization on the loss term can actually impede the agent's performance on LLDM problems (See Appendix E.2); and **4)** ER, the rehearsal method, is robust across all task suites.

Study on Language Embeddings as the Task Identifier (Q4) To investigate to what extent language embedding play a role in LLDM, we compare the performance of the same lifelong learner using four different pretrained language embeddings. Namely, we choose BERT , CLIP , GPT-2  and the Task-ID embedding. Task-ID embeddings are produced by feeding a string such as "Task 5" into a pretrained BERT model.

Findings:From Table 3, we observe _no_ statistically significant difference among various language embeddings, including the Task-ID embedding. This, we believe, is due to sentence embeddings functioning as bag-of-words that differentiates different tasks. This insight calls for better language encoding to harness the semantic information in task descriptions. Despite the similar performance, we opt for BERT embeddings as our default task embedding.

   Lifelong Algo. & FWT(\(\)) & NBT(\(\)) & AUC(\(\)) & FWT(\(\)) & NBT(\(\)) & AUC(\(\)) \\   &  \\  SeqL & **0.54**\(\) 0.01 & 0.63 \(\) 0.01 & 0.15 \(\) 0.00 & **0.72**\(\) 0.01 & 0.81 \(\) 0.01 & 0.20 \(\) 0.01 \\ ER & 0.48 \(\) 0.02 & 0.32 \(\) 0.04 & **0.32**\(\) 0.01 & 0.65 \(\) 0.03 & 0.27 \(\) 0.03 & 0.56 \(\) 0.01 \\ EWC & 0.13 \(\) 0.02 & 0.22 \(\) 0.03 & 0.02 \(\) 0.00 & 0.23 \(\) 0.01 & 0.33 \(\) 0.01 & 0.06 \(\) 0.01 \\ PackNet & 0.22 \(\) 0.01 & **0.08**\(\) 0.01 & 0.25 \(\) 0.00 & 0.55 \(\) 0.01 & **0.07**\(\) 0.02 & **0.63**\(\) 0.00 \\ MTL & & & 0.48 \(\) 0.01 & & & 0.83 \(\) 0.00 \\   &  \\  SeqL & **0.78**\(\) 0.04 & 0.76 \(\) 0.04 & 0.26 \(\) 0.02 & **0.77**\(\) 0.01 & 0.82 \(\) 0.01 & 0.22 \(\) 0.00 \\ ER & 0.67 \(\) 0.07 & 0.43 \(\) 0.04 & 0.44 \(\) 0.06 & 0.64 \(\) 0.01 & 0.34 \(\) 0.02 & 0.49 \(\) 0.02 \\ EWC & 0.56 \(\) 0.03 & 0.69 \(\) 0.02 & 0.16 \(\) 0.02 & 0.32 \(\) 0.02 & 0.48 \(\) 0.03 & 0.06 \(\) 0.00 \\ PackNet & 0.60 \(\) 0.07 & **0.17**\(\) 0.05 & **0.60**\(\) 0.05 & 0.63 \(\) 0.02 & **0.06**\(\) 0.01 & **0.75**\(\) 0.01 \\ MTL & & & 0.54 \(\) 0.02 & & & 0.80 \(\) 0.01 \\   

Table 2: Performance of three lifelong algorithms and the SeqL and MTL baselines on the four task suites, where the policy is fixed to be ResNet-T. Results are averaged over three seeds and we report the mean and standard error. The best performance is **bolded**, and colored in **purple** if the improvement is statistically significant over other algorithms, when a two-tailed, Student’s t-test under equal sample sizes and unequal variance is applied with a \(p\)-value of 0.05.

Study on task ordering (Q5)Figure 4 shows the result of the study on **Q4**. For all experiments in this study, we used ResNet-T as the neural architecture and evaluated both ER and PackNet. As the figure illustrates, the performance of both algorithms varies across different task orderings. This finding highlights an important direction for future research: developing algorithms or architectures that are robust to varying task orderings.

Findings:From Figure 4, we observe that indeed different task ordering could result in very different performances for the same algorithm. Specifically, such difference is statistically significant for PackNet.

Study on How Pretraining Affects Downstream LLDM (Q6)Fig 5 reports the results on LIBERO-Long of five combinations of algorithms and policy architectures, when the underlying model is pretrained on the 90 short-horizon tasks in LIBERO-100 or learned from scratch. For pretraining, we apply behavioral cloning on the 90 tasks using the three policy architectures for 50 epochs. We save a checkpoint every 5 epochs of training and then pick the checkpoint for each architecture that has the best performance as the pretrained model for downstream LLDM.

Findings:We observe that the basic supervised pretraining can _hurt_ the model's downstream lifelong learning performance. This, together with the results seen in Table 2 (e.g., naive sequential fine-tuning

Figure 4: Performance of ER and PackNet using ResNet-T on five different task orderings. An error bar shows the performance standard deviation for a fixed ordering.

   Embedding Type & Dimension & FWT(\(\)) & NBT(\(\)) & AUC(\(\)) \\  BERT & 768 & 0.48 \(\) 0.02 & **0.32**\(\) 0.04 & 0.32 \(\) 0.01 \\ CLIP & 512 & **0.52**\(\) 0.00 & 0.34 \(\) 0.01 & **0.35**\(\) 0.01 \\ GPT-2 & 768 & 0.46 \(\) 0.01 & 0.34 \(\) 0.02 & 0.30 \(\) 0.01 \\ Task-ID & 768 & 0.50 \(\) 0.01 & 0.37 \(\) 0.01 & 0.33 \(\) 0.01 \\   

Table 3: Performance of a lifelong learner using four different language embeddings on LIBERO-Long, where we fix the policy architecture to ResNet-T and the lifelong learning algorithm to ER. The Task-ID embeddings are retrieved by feeding “Task + ID” into a pretrained BERT model. Results are averaged over three seeds and we report the mean and standard error. The best performance is **bolded**. No statistically significant difference is observed among the different language embeddings.

Figure 5: Performance of different combinations of algorithms and architectures without pretraining or with pretraining. The multi-task learning performance is also included for reference.

has better forward transfer than when lifelong learning algorithms are applied), indicates that better pretraining techniques are needed.

Attention Visualization:To better understand what type of knowledge the agent forgets during the lifelong learning process, we visualize the agent's attention map on each observed image input. The visualized saliency maps and the discussion can be found in Appendix E.4.

## 6 Related Work

This section provides an overview of existing benchmarks for lifelong learning and robot learning. We refer the reader to Appendix B.1 for a detailed review of lifelong learning algorithms.

Lifelong Learning BenchmarksPioneering work has adapted standard vision or language datasets for studying LL. This line of work includes image classification datasets like MNIST , CIFAR , and ImageNet ; segmentation datasets like Core50 ; and natural language understanding datasets like GLUE  and SuperGLUE . Besides supervised learning datasets, video game benchmarks (e.g., Atari , XLand , and VisDoom ) in reinforcement learning (RL) have also been used for studying LL. However, LL in standard supervised learning does not involve procedural knowledge transfer, while RL problems in games do not represent human activities. ContinualWorld  modifies the 50 manipulation tasks in MetaWorld for LL. CORA  builds four lifelong RL benchmarks based on Atari, Procgen , MiniHack , and ALFRED . F-SIOL-310  and OpenLORIS  are challenging real-world lifelong object learning datasets that are captured from robotic vision systems. Prior works have also analyzed different components in a LL agent [45; 70; 21], but they do not focus on robot manipulation problems.

Robot Learning BenchmarkA variety of robot learning benchmarks have been proposed to address challenges in meta learning (MetaWorld ), causality learning (CausalWorld ), multi-task learning [27; 35], policy generalization to unseen objects [47; 24], and compositional learning . Compared to existing benchmarks in lifelong learning and robot learning, the task suites in LIBERO are curated to address the research topics of LLDM. The benchmark includes a large number of tasks based on everyday human activities that feature rich interactive behaviors with a diverse range of objects. Additionally, the tasks in LIBERO are procedurally generated, making the benchmark scalable and adaptable. Moreover, the provided high-quality human demonstration dataset in LIBERO supports and encourages learning efficiency.

## 7 Conclusion and Limitations

This paper introduces LIBERO, a new benchmark in the robot manipulation domain for supporting research in LLDM. LIBERO includes a procedural generation pipeline that can create an infinite number of manipulation tasks in the simulator. We use this pipeline to create 130 standardized tasks and conduct a comprehensive set of experiments on policy and algorithm designs. The empirical results suggest several future research directions: 1) how to design a better neural architecture to better process spatial information or temporal information; 2) how to design a better algorithm to improve forward transfer ability; and 3) how to use pretraining to help improve lifelong learning performance. In the short term, we do not envision any negative societal impacts triggered by LIBERO. But as the lifelong learner mainly learns from humans, studying how to preserve user privacy within LLDM  is crucial in the long run.