# Open Compound Domain Adaptation with Object Style Compensation for Semantic Segmentation

Tingliang Feng\({}^{1,2}\)  Hao Shi\({}^{1,3}\)  Xueyang Liu\({}^{1}\)  Wei Feng\({}^{1,2}\)

Liang Wan\({}^{1}\)  Yanlin Zhou\({}^{4}\)  Di Lin\({}^{1}\)

\({}^{1}\)College of Intelligence and Computing, Tianjin University

\({}^{2}\)Laboratory of Computation and Analytics of Complex Management Systems (CACMS), Tianjin University

\({}^{3}\)Department of Automation, Tsinghua University

\({}^{4}\)Dunhuang Academy

{fengtl, xyliu850569498, lwan}@tju.edu.cn shi-h23@mails.tsinghua.edu.cn wfeng@ieee.org zhouyanlin@dha.ac.cn

Co-first authors. Equal contribution.Di Lin is the corresponding author of this paper.

###### Abstract

Many methods of semantic image segmentation have borrowed the success of open compound domain adaptation. They minimize the style gap between the images of source and target domains, more easily predicting the accurate pseudo annotations for target domain's images that train segmentation network. The existing methods globally adapt the scene style of the images, whereas the object styles of different categories or instances are adapted improperly. This paper proposes the _Object Style Compensation_, where we construct the _Object-Level Discrepancy Memory_ with multiple sets of discrepancy features. The discrepancy features in a set capture the style changes of the same category's object instances adapted from target to source domains. We learn the discrepancy features from the images of source and target domains, storing the discrepancy features in memory. With this memory, we select appropriate discrepancy features for compensating the style information of the object instances of various categories, adapting the object styles to a unified style of source domain. Our method enables a more accurate computation of the pseudo annotations for target domain's images, thus yielding state-of-the-art results on different datasets.

## 1 Introduction

The task of open compound domain adaptation (OCDA) for semantic segmentation aims to train the segmentation models [1; 2; 3; 4; 5; 6] using a source domain with pixel-level annotations and target domains of mixed styles with no annotations. The model is trained to perform well on images from the target domains that share the same style as seen during training, as well as on open domain images that are not encountered during training. The recent methods [7; 8; 9; 10; 11] of semantic segmentation utilize the open compound domain adaptation (OCDA), which harnesses the annotated images and the annotation-free images captured in the open environments to train the segmentation network. In this manner, the segmentation network learns from richer data with diverse object appearances while requiring reasonable effort for image labeling. Here, the annotated images belong to the source domain, while the annotation-free images are in the compound target domain for capturing the complexity of open environments.

There is a gap between the image styles of the source and target domains, where the image styles usually are regarded as an array of scene-level properties (e.g., weather and lighting conditions). Thescene styles are adapted3 to narrow the gap between image styles, allowing the segmentation network to focus on the intrinsic object appearances of every domain. It helps the network to predict accurate segmentation masks for many images in the compound target domain. The predicted masks play as the pseudo-pixel-wise annotations for tuning the segmentation network.

Typically, the adaptation of scene styles follows the homologous patterns to change the object styles in the same image. It lets various object categories undergo the style change along the same direction (see Figure 1(a), the clear pedestrians and overexposed cars adapted from the night to day scenes). In the common context, the objects in various categories, even different object instances in the same category, may have specific styles within a scene (see Figure 1(b), the usual cars and pedestrians in the day time). Adapting scene styles may yield unreasonable object styles inconsistent with the usual context, leading to problematic annotations for the network training. Additional, The typical OCDA methods learn deep network parameters. The parameters are learned from the source and target images in the training set. But they cannot trivially transform the open domain's object features that contain many unseen styles. Using the learned parameters directly may transform the object features of the open domain to the latent sub-space misaligned with the source domain.

This paper advocates equipping OCDA with object style compensation for semantic segmentation. In contrast to the adaptation of scene styles, the compensation respects the object style discrepancies between the source and target domains. These discrepancies are captured for the independent object categories and instances. Intuitively, the style discrepancies can be memorized during network learning. It enables the appropriate style discrepancies, which can be regarded as the prior information, to be selected and added to the object features. Meanwhile, rather than using the network parameters to transform the target/open domain's features to the source domain, we learn the discrepancy features representing the style differences across domains. Consequently, we compensate the object features to adapt the object styles to the similar style of source domain. The compensation yields consistent object context within the scene, helping the segmentation network to compute reliable pseudo annotations.

Figure 1: (a) Cars and pedestrians adapted from the night to day scenes. (b) The usual cars and pedestrians in the real day scene. (c) OLDM contains the discrepancy features for representing the difference of object styles in the source and target domains, which are used for adapting the object-level styles from target to source domains.

Specifically, we conduct the object style compensation for adapting the images from target to source domains. The pipeline comprises _Discrepancy Memorization_ and _Style Compensation_, as illustrated in Figure 1(c). During _Discrepancy Memorization_, we construct a feature base, _Object-Level Discrepancy Memory_ (OLDM), which consists of multiple feature sets. Each set contains the discrepancy features for the identical object category. Here, we compute the discrepancy feature by subtracting the target domain's object features from the same category's object features of the source domain, letting the discrepancy features represent the difference of the object styles across two domains. We compute the discrepancy features for the object instances in different images of target domain. During _Style Compensation_, given a query object in the target domain's image, we select the discrepancy feature from the feature set of the requested category, where the discrepancy feature represents the instance much relevant to the query object. In this way, the discrepancy feature customizes the information, which is category- and instance-orientated, for compensating the query object's feature. The compensated object features are used for regressing the pseudo annotations.

We conduct an intensive evaluation of the object style compensation. On the public datasets (e.g., C-Driving , ACDC , Cityscapes , KITTI , and WildDash ) that allows OCDA to assist semantic segmentation, the object style compensation surpasses state-of-the-art methods, demonstrating its effectiveness.

## 2 Related Work

### Domain Adaptation for Semantic Segmentation

Numerous studies have been conducted in the realm of unsupervised domain adaptation (UDA), multi-target domain adaptation (MTDA), and domain generalization (DG) for the task of semantic segmentation. These investigations encompass a plethora of approaches and methodologies, aimed at enhancing the performance and robustness of segmentation models. In the domain of UDA, several notable works have contributed to this field [16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27]. These UDA methods encompass various strategies such as style regression , domain adversarial training [18; 29], and self-training [17; 30] to adapt models to target domains. Similarly, the MTDA domain has witnessed significant attention [31; 30; 32; 29]. These studies tackle the challenge of adapting segmentation models to multiple target domains and employ diverse methodologies to achieve this objective. In contrast to UDA and MTDA, DG methods are characterized by their focus on learning domain-invariant representations. Researchers in this domain have explored techniques like learning domain invariant representation [33; 34; 35], and data augmentation[36; 37; 38], to impart models with generalization capabilities across various domains. Turning to the specific context of OCDA, studies have employed diverse strategies, including style regression based on scene-level attributes [8; 9; 10], and category-level attributes  to address the unique challenges posed by open compound domain adaptation for segmentation task.

The existing methods adapt scene styles to fill in the gap of image appearances between different domains. They are insensitive to the object styles, which are critical to capture the style change of the object appearances of various categories/instances. In contrast, we propose object-style compensation by respecting the individual categories/instances. Our approach appropriately adapts the object styles to the styles similar to the source domain and yield consistent context in the same scene.

### Deep Network with Memorization for Visual Understanding

Recent studies demonstrate the importance of the deep network with memorization for visual understanding [39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55]. Among them, the application of memorization techniques has been notably observed within the realms of image processing [50; 52; 55] and video analysis [44; 56]. Furthermore, these methods can be categorized based on the level of granularity at which objects are stored in memory, with some operating at the scene level [43; 50; 56], while others are geared towards the category level [52; 55].

The previous methods utilize memory that stores scene-level or category-level features extracted from the images. Because these features mainly capture a single domain's image style, they are less powerful for adapting a broad range of image styles of the compounded target domain to the source domain. In contrast, we propose the external memory to store both category- and instance-level discrepancy features learned across different domains. These discrepancy features can directly compensate the images of the target domains, whose category- and instance-level styles are adapted to the source domain. The alignment of the object styles in different domains' images helps the segmentation network to focus on the intrinsic object appearances for producing the pseudo labels.

## 3 Method Overview

We illustrate the object style compensation in Figure 2(a). \(_{s},_{t}^{H W 3}\) are the images in the source and target domains. \(_{s}/_{t}\) is associated with/without the pixel-wise annotation. We denote \(_{s}^{H W L}\) (\(L\) is the category number) as the ground-truth annotation for \(_{s}\). The encoder extracts the object feature maps \(_{s},_{t}^{H W C}\) from \(_{s},_{t}\). \(C\) indicates the feature channels. \(_{s}(x,y),_{t}(x,y)^{C}\) represent the object located at \((x,y)\) in the source and target images.

The object style compensation includes _Discrepancy Memorization_ and _Style Compensation_. The discrepancy memorization uses \(_{s},_{t}\) to construct the _Object-Level Discrepancy Memory_ (OLDM). OLDM stores the discrepancy features, which capture the change of object styles from target to source domain. For the target image \(_{t}\), the style compensation uses discrepancy features to adapt the object style information of \(_{t}\), yielding the compensated feature map \(}_{t}^{H W C}\) used by decoder to compute the pseudo annotation \(_{t}^{H W L}\).

Discrepancy MemorizationThe discrepancy memorization only takes place during network training. Here, we construct category-key and OLDM as \(\{(_{l},_{l})_{l}^{C},l=1,...,L\}\), which contains pairs of category-key feature (e.g., \(_{l}\)) and feature set (e.g., \(_{l}\)). \(_{l}\) is the category-key feature that captures the source domain's representative style of the \(l^{th}\) category. The set \(_{l}=\{(_{l,m},_{l,m})_{l,m}, _{l,m}^{C},m=1,...,M\}\) has pairs of representative-key feature (e.g., \(_{l,m}\)) and discrepancy feature (e.g., \(_{l,m}\)), where \(m\) is the index of the representative-key feature. \(_{l,m}\) captures a representative instance-level style of the \(l^{th}\) category in target domain. We associate \(_{l,m}\) with the discrepancy feature \(_{l,m}\), which captures the change of the representative instance-level style from target to source domain.

Figure 2: (a) Overview of the object style compensation including discrepancy memorization, object-level discrepancy memory, and style compensation. (b) In the discrepancy memorization, we use the object features of the source and target domains, along with their differences, to update the category-key, representative-key, and discrepancy features in OLDM. (c) Given the object features of the target domain, we compute the similarities between the representative-key features and each object feature of the target domain, which is compensated by the discrepancy features weighted by the similarities.

We illustrate the discrepancy memorization in Figure 2(b), where we update the category-key, representative-key, and discrepancy features. We use the \(l^{th}\) category's object features in \(_{s}\) to update the category-key feature \(_{l}\). In the set \(_{l}\), we measure the similarities between the \(l^{th}\) category's object features in \(_{t}\) and the representative-key features \(\{_{l,m} m=1,...,M\}\). According to these similarities, we use the \(l^{th}\) category's object feature \(_{t}(x,y)\) updates representative-key features, while calculating the difference between \(_{l}\) and \(_{t}(x,y)\) to update the discrepancy features \(\{_{l,m} m=1,...,M\}\).

**Style Compensation** We conduct the style compensation during training and testing. We illustrate the style compensation in Figure 2(c), where we use the discrepancy features in OLDM to compensate the target image's object feature map \(_{t}\). Given the object feature \(_{t}(x,y)\) as a query, we use a segmentation head to regress its category scores \(_{t}(x,y)^{H W L}\), selecting the feature sets \(\{_{1},...,_{K}\}\) of OLDM for the style compensation. In \(_{k}\), we calculate the similarities between \(_{t}(x,y)\) and the representative-keys \(\{_{k,m} m=1,...,M\}\). These similarities weight the discrepancy features \(\{_{k,m} m=1,...,M\}\). After averaging the weighted discrepancy features of each set, the results are added to \(_{t}(x,y)\), yielding the compensated feature \(}_{t}(x,y)\). \(}_{t}\) is fed into the decoder for regressing the pseudo annotation \(_{t}\). We borrow the pseudo annotation \(_{t}\) paired with the target image \(_{t}\) to fine-tune the segmentation network.

## 4 Object Style Compensation

### Discrepancy Memorization

During network training, we employ discrepancy memorization to construct the _Object-Level Discrepancy Memory_ (OLDM). We denote category-key and OLDM as \(\{(_{l},_{l})_{l}^{C},l=1,...,L\}\), where \(_{l}=\{(_{l,m},_{l,m})_{l,m}, _{l,m}^{C},m=1,...,M\}\). We use the feature maps \(_{s},_{t}^{H W C}\), which are extracted from the source and target images \(_{s},_{t}^{H W 3}\) by encoder, to update the category-key, representative-key, and discrepancy features in OLDM (see Figure 2(b)).

**Update of Category-Key Features** Given the feature map \(_{s}\) of the source image \(_{s}\), we update the category-key features \(\{_{l}^{C} l=1,...,L\}\). We employ decoder to predict a category for every object feature in the map \(_{s}\). The source image \(_{s}\) has the ground-truth annotation \(_{s}^{H W L}\). The decoder predicts the category scores \(_{s}(x,y)^{L}\), where \(_{s}(x,y,l)\) is the score for predicting the object located at \((x,y)\) of the source image to be the \(l^{th}\) category. We assume the category \(l\) leads to the highest score \(_{s}(x,y,l)\). The predicted label is compared to the ground-truth label \(_{s}(x,y)\). The correct prediction means the object feature \(_{s}(x,y)\) is reliable for updating the category-key feature \(_{l}\) as:

\[_{l}_{l}+_{s}(x,y),\] \[s.t.\;\;_{s}(x,y,l)=\{_{s}(x,y,1),..., _{s}(x,y,L)\},\;\;\;l=_{s}(x,y),\] (1)

where \(\) means the update by overwriting. \(\) is a ratio for controlling the information of \(_{s}(x,y)\) injected into \(_{l}\). In Eq.(1), \(_{l}\) aggregates the information of an array of object features, which consistently point to the \(l^{th}\) category. It helps \(_{l}\) to capture the representative object style of the \(l^{th}\) category in source domain, which is used to compute discrepancy features.

**Update of Representative-Key and Discrepancy Features** We use the feature map \(_{t}\) of the target image \(_{t}\) to update the representative-key features in OLDM. For the object feature \(_{t}(x,y)^{C}\), we use the intermediate segmentation head to regress the category scores in \(_{t}(x,y)^{L}\), where intermediate segmentation head takes input as the target feature for regressing the category score map, and \(_{t}(x,y,l)\) is the score for predicting the object located at \((x,y)\) of the target image to be the \(l^{th}\) category. We use \(_{t}(x,y)\) to update the representative-key feature \(_{l,m}\) as:

\[_{l,m}_{l,m}+_{l,m}_{t}(x,y), \;\;_{l,m}_{l,m}+_{l,m}(_{l} -_{t}(x,y)),\] \[s.t.\;\;_{t}(x,y,l)\!=\!\{_{t}(x,y,1),...,_{t}(x,y,L)\}>;\;_{l,m}\!=\!_{l,m }_{t}(x,y)}{}.\] (2)

The category \(l\) has the highest score in \(\{_{t}(x,y,1),...,_{t}(x,y,L)\}\). We classify the object feature \(_{t}(x,y)\) to the \(l^{th}\) category, thus updating the representative-key features \(\{_{l,m} m=1,...,M\}\)in the set \(_{l}\) for the same category. \(_{l,m}\) is a weight, which is calculated as the dot-product between the representative-key feature \(_{l,m}\) and the object feature \(_{t}(x,y)\), whose similarity is measured. A high weight lets object feature contribute more information to representative-key feature.

Unlike decoder supervised by the ground-truth annotations of source images, the intermediate segmentation head is supervised by the pseudo annotations of target images. It may misclassify object feature, thus misleading the update of representative-key features. To remedy this issue, we set a score threshold \(\) in Eq. (2), to select the reliable object feature \(_{t}(x,y)\), whose highest score \(_{t}(x,y,l)\) is greater than \(\). This threshold only allows the object feature, whose category scores are confident, to update representative-key features. Each representative-key feature aggregates the features of various object instances with similar styles.

In Eq (2), we also update the discrepancy features \(\{_{l,m}^{C} m=1,...,M\}\). Here, we subtract the object feature \(_{t}(x,y)\) from the category-key feature \(_{l}\). Note that \(_{t}(x,y)\) and \(_{l}\) are extracted from the target and source images, respectively. Thus, the subtraction of these features captures the difference between the object styles of in target and source images, which is weighted by \(_{l,m}\) to add to the discrepancy feature \(_{l,m}^{C}\).

We remark that the update of OLDM is disabled during network testing. The style compensation uses the most updated category-key, representative-key, and discrepancy features in OLDM.

### Style Compensation

The style compensation works during network training and testing. It harnesses the category- and representative-key features to find the appropriate discrepancy features in OLDM, which compensate for the object features of target image (see Figure 2(c)).

**Compensation of Object Features** Given the object feature \(_{t}(x,y)\) as a query, which is extracted from the target image \(_{t}\), we use the intermediate segmentation head to predict the category scores \(_{t}(x,y)\). Next, we select the representative-key and discrepancy features from \(\{_{1},...,_{K}\}\), where \(_{k}=\{(_{k,m},_{k,m})_{k,m}, _{k,m}^{C},m=1,...,M\}\) to compensate the object feature \(_{t}(x,y)\), yielding the compensated feature \(}_{t}(x,y)^{C}\) as:

\[}_{t}(x,y)=_{t}(x,y)+_{k}_{m} _{k,m}_{k,m},\]

\[s.t.\ \ _{t}(x,y,k)_{K}\{_{t}(x,y,1),..., _{t}(x,y,L)\};\ _{k,m}=_{k,m}_{t}(x,y)}{},\] (3)

where \(_{K}\) means to select the top-K relevant categories. We use Eq. (3) to achieve the compensated feature \(}_{t}^{H W C}\), which is used for computing the pseudo annotation for the target image \(_{t}\).

**Computation of Pseudo Annotations** Based on the compensated feature \(}_{t}\), the decoder of the segmentation network predicts the category score map \(}_{t}^{H W L}\). We use the category score map \(}_{t}\) to produce the pseudo annotation \(_{t}^{H W L}\), where the pixel-wise annotation \(_{t}(x,y)^{L}\) for the pixel located at \((x,y)\) is determined as:

\[_{t}(x,y,l)=1&\{}_{t}(x,y,1),...,}_{t}(x,y,L)\}=}_{t}(x,y,l)> ,\\ 0&\{}_{t}(x,y,1),...,}_{t}(x,y, L)\}>\{}_{t}(x,y,l),\},\\ &\{}_{t}(x,y,1),..., }_{t}(x,y,L)\}.\] (4)

The pixel-wise annotation \(_{t}(x,y)\) is a one-hot vector. We set the \(l^{th}\) channel \(_{t}(x,y,l)\) to 1 (see the first case), when the category score \(}_{t}(x,y,l)\) is higher than other scores in the set \(\{}_{t}(x,y,1),...,}_{t}(x,y,L)\}\); otherwise, we set \(_{t}(x,y,l)\) to 0 (see the second case). It should be noted that the threshold \(\) is used in the third case, where too low scores let the pseudo annotations be ignored during network training. The computation of pseudo annotations only takes place during network training. For network testing, we resort to the category score map \(}_{t}\) to predict the labels for all pixels, following the convention of semantic segmentation.

### Supervision for Network Training

We use the ground-truth annotations of source images and the pseudo annotations of target images to train segmentation network. We formulate the overall training objective \(\) as:

\[=_{gt}+_{pse}.\] (5)

\(_{gt}\) and \(_{pse}\) represent the objectives with the supervision of ground-truth and pseudo annotations.

Supervision of Ground-truth AnnotationsBased on the object feature map \(_{s}\) of the source image \(_{s}\), decoder predicts the category score map \(_{s}\). We use the cross-entropy loss \(\) to penalize the difference between the predicted score map \(_{s}\) and the ground-truth annotation \(_{s}\) as:

\[_{gt}=(_{s},_{s}).\] (6)

Supervision of Pseudo annotationsWe use intermediate segmentation head to regress the category score map \(_{t}\) for the target image \(_{t}\), based on the object feature map \(_{t}\). We compute the cross-entropy loss, which penalizes the difference between the score map \(_{t}\) and the pseudo annotation \(_{t}\) as the first term of the below Eq. (7).

\[_{pse}=(_{t},_{t})+( }_{t},_{t}).\] (7)

Moreover, we leverage the decoder to predict the category score map \(}_{t}\), based on the compensated feature map \(}_{t}\). We again use cross-entropy loss (see the second term of Eq. (7)) to measure the segmentation errors in the score map \(}_{t}\), by comparing to the pseudo annotation \(_{t}\).

## 5 Experiments

### Experimental Datasets

We use GTA5 , SYNTHIA , C-Driving , ACDC , Cityscapes , KITTI , and WildDash  datasets to evaluate our method. The images in a dataset may be subdivided into source, target, and open domains. All images with annotations in source domain and a portion of images without annotations in target domain are used for network training. We evaluate the segmentation performances on the rest images in target domain and all images in open domain. We list the division of these datasets in Table 1.

In the ablation study of our method, we use 24,966 source images of GTA5 dataset and 14,697 target images of C-Driving dataset for network training. 803 and 627 images of target and open domains in C-Driving dataset are used for testing. We report the segmentation performance regarding mean intersection-over-unions (mIoUs) on target and open domains.

### Implemenration Detail

We employ the PyTorch toolkit to implement our segmentation network with _Object-Level Discrepancy Memory_ (OLDM). Our segmentation architecture is built upon DeepLab-V2  with ResNet101  backbone that has been pre-trained on ImageNet . To optimize the network, we utilize the SGD solver for 250,000 iterations. The initial learning rate is set to 0.00025, which undergoes a linear decay throughout the training process. Each mini-batch consists of 4 images, comprising 2 source images and 2 target images. We apply random cropping, flipping, color jittering, and Gaussian blurring techniques to the training images, using a crop size of 640\(\)360. The network is trained on a single RTX 3090 GPU.

### Ablation Study

Analysis of Discrepancy MemorizationIn Tables 2, 3, and 4, we study various strategies for updating category-key, representative-key, and discrepancy features during the discrepancy memorization.

    &  &  &  \\   & & Source & Target & Open \\  GTA5 & 24,966 & 24,966 & - & - & - \\ SYNTHIA & 9,400 & 9,400 & - & - & - \\ C-Driving & 16,127 & - & 14,697 & 803 & 627 \\ ACDC & 1,906 & - & 1,200 & 306 & 400 \\ Cityscapes & 500 & - & - & - & 500 \\ KITTI & 200 & - & - & - & 200 \\ WashDash & 638 & - & - & - & 638 \\   

Table 1: Divisions of the experimental datasets.

We report different strategies for using category-key features in Table 2. First, we disable the update of category-key features. This is done by removing OLDM (see "w/o OLDM") during training and testing, producing the performance of the stand-alone segmentation network. Another alternative uses the mean of the representative-key features in the same set to replace category-key feature but yields lower performances than our method (see "mean instances"). This is because category-key and instance features are computed based on the image features of discrepant domains (i.e., source and target domains), making none of them replaceable. Second, we experiment with using the mean of the image features of source domain in a local mini-batch to compute the category-key features, which are overridden by new mini-batch. This strategy achieves worse results than our method (see "local"), because we use different mini-batches to compute category-key features globally (see "global"), which more comprehensively capture the object features of source domain.

In Table 3, we compare the performances of various strategies for using representative-key features. By eliminating the representative-key features in OLDM, we lack the similarities between the object features of target domain and the representative-key features for weighting the discrepancy features to compensate for object features. In this case, we experiment with simply averaging discrepancy features (see "mean discrepancy"), using the category-level discrepancy rather than the instance-level, or directly computing the similarities between object features and discrepancy features (see "discrepancy similarity") for compensation. Without representative-key features, these naive strategies lead to worse results than our method. This is because the average discrepancy features and the alternative similarities inappropriately match object instances to the discrepancy features desired for compensation.

We also experiment with enabling and updating representative-key features in various ways. For each set of representative-key and discrepancy features of the same category, we select the representative-key feature, which is updated along with associated discrepancy feature by the object feature of target domain. It degrades the performances (see "top-1 update"), compared to adequately updating 50% or 100% of representative-key and discrepancy features (see "top-50% update" and "100% update").

In Table 4, we evaluate the performances of using discrepancy features in different ways. Removing all discrepancy features in OLDM, we again degrade the whole pipeline to the backbone segmentation network (see "w/o OLDM"). We also experiment with replacing discrepancy features with the discrepancy between the category- and representative-key features. This discrepancy only considers the difference between representative features of source and target domains. Our discrepancy features account for the differences between the representative features of source domain and various instances' object features of target domain. They show a stronger power for compensating the style information of relevant object instances. Moreover, we evaluate several alternatives for enabling discrepancy features for compensation. In contrast to our method that differentiates discrepancy features according to categories and instances, an alternative method merges all discrepancy features as a set (see "merged sets"). This method is insensitive to the specific properties of categories and instances. Another way of separating discrepancy features into multiple sets is to use k-means clustering (see "multi-sets, k-means"), without depending on category-key features. However, these methods neglect the useful category-key features, which select

  Discrepancy & Method & mIoU(T) & mIoU(O) \\  ✗ & w/o OLDM & 36.6 & 39.7 \\  & key discrepancy & 42.7 & 44.3 \\   & merged sets & 39.6 & 41.5 \\ ✔ & multi-sets, k-means & 41.7 & 43.3 \\  & multi-sets, category & **44.1** & **46.9** \\  

Table 4: Results of various ways of using discrepancy features.

   Rep.-Key & Method & mIoU(T) & mIoU(O) \\  ✗ &  mean discrepancy \\ category-level discrepancy \\ discrepancy similarity \\  & 37.8 & 38.8 \\ ✗ &  category-level discrepancy \\ discrepancy similarity \\  & 38.1 & 40.2 \\  ✔ &  top-1 update \\ top-50\% update \\ 100\% update \\  & 40.7 & 41.8 \\ ✔ &  top-50\% update \\ 100\% update \\  & 42.2 & 44.3 \\ ✔ & 
 100\% update \\  & **44.1** & **46.9** \\   

Table 3: Results of various ways of using representative-key features.

representative-key and discrepancy features for compensating the object features of the matched categories. Their performances lag behind our method (see "multi-sets, category").

Variants of Style CompensationIn Tables 5 and 6, we evaluate the effectiveness of the style compensation by replacing it with other schemes during network testing. Here, OLDM has the optimized category-key, representative-key, and discrepancy features.

First, we remove the optimized OLDM and disable the style compensation. Another alternative method of style compensation is averaging all of the discrepancy features without relying on the similarities between target images' and representative-key features for weighting discrepancy features. The above methods (see "w/o OLDM" and "mean discrepancy") yield lower performances than our method, which better utilizes discrepancy features for compensating the style information of different categories and instances in target domain.

Next, we analyze the quality of the pseudo annotations computed by the style compensation. Without pseudo annotations, we only use the ground-truth annotations of source images for training the segmentation network. We also evaluate the quality of the pseudo annotations produced by the intermediate segmentation head for supervising the segmentation network. Without the accurate pseudo annotations computed based on compensated object features, these alternatives yield worse results than our method.

### External Comparison

In Table 7 and 8, we compare the performances of start-of-the-art OCDA, UDA and DG methods . For a fair comparison, we have clearly specified the sets of images used for training and testing in each table. Our method of object style compensation outperforms an array of start-of-the-art methods on different datasets. In Figures 3 and 4, we compare the segmentation results of different methods, where our method yields better results.

## 6 Conclusion

Open compound domain adaptation has been successfully used to improve semantic image segmentation performance. The popular methods globally adapt the scene styles of images. However, they unreasonably change the object styles of various categories and instances, forming unusual object

   
 Pseudo \\ Annotations \\  & Method & mIoU(T) & mIoU(O) \\  ✗ & w/o pseudo & 39.7 & 41.6 \\  ✗ & intermediate & 42.4 & 44.3 \\  & final & **44.1** & **46.9** \\   

Table 6: Results of various ways of computing pseudo annotations.

    &  &  &  \\   & & GTA5(S) &  &  &  \\   & & mIoU(T) & mIoU\({}^{16}\)(T) & mIoU\({}^{11}\)(T) & mIoU(T) & mIoU(O) & mIoU\({}^{16}\)(T) & mIoU\({}^{16}\)(O) \\  Source-only & - & 28.3 & 20.9 & 28.1 & 20.5 & 27.1 & 19.8 & 20.5 \\ CDAS & OCDA & 31.4 & 25.3 & 34.0 & 25.3 & 29.1 & 25.9 & 23.3 \\ CSFU & OCDA & 34.9 & 26.1 & 34.8 & 27.6 & 30.5 & 26.7 & 24.8 \\ DACS & UDA & 36.6 & 28.1 & 36.5 & 29.0 & 34.8 & 28.3 & 27.0 \\ DHA & OCDA & 37.1 & 29.9 & 37.6 & 29.5 & 37.5 & 29.2 & 27.3 \\ AST & OCDA & 38.8 & 31.1 & 38.9 & 30.7 & 39.2 & 30.1 & 27.9 \\ ML-BPM & OCDA & 40.2 & 32.1 & 40.0 & 32.1 & 41.6 & 31.9 & 29.1 \\  Ours & OCDA & **44.1** & **35.6** & **43.7** & **35.7** & **44.1** & **34.7** & **36.4** \\   

Table 7: Comparison with state-of-the-art methods. We clarify the source, target, and open domains for training and testing the compared methods at the top of table. mIoU\({}^{11}\) and mIoU\({}^{16}\) mean the mIoUs on 11 and 16 categories, respectively.

   
 Style \\ Compensation \\  & Method & mIoU(T) & mIoU(O) \\  ✗ & w/o OLDM & 36.6 & 39.7 \\  ✗ & mean discrepancy & 40.7 & 41.9 \\  & instance similarity & **44.1** & **46.9** \\   

Table 5: Results of various compensation methods.

contexts in the adapted images along with incorrect pseudo annotations. In this paper, we propose a novel idea of object-style compensation. Our method leverages the object-level discrepancy memory, where multiple sets of discrepancy features account for the style changes of objects in different categories. Furthermore, the discrepancy features in the same set individually consider instance-level style changes, thus adapting the object styles finely. Our method enables a more accurate computation of the pseudo annotations of the images in the target domains, which eventually assists in training the segmentation network. In the future, we will extend our method to other applications (e.g., object detection and image restoration).

## Negative Societal Impacts

Our approach facilitates the analysis of image semantics, rendering it applicable in various scenarios such as autonomous vehicles and image/video content comprehension. However, it is important to exercise caution when utilizing the results, as they may contain potentially problematic information. Mishandling such information could lead to infringements on privacy or economic interests.