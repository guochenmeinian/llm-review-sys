# [MISSING_PAGE_FAIL:1]

[MISSING_PAGE_FAIL:1]

quantifiers and modular arithmetic over input position indices. Specifically, counting quantifiers take the form \(^{=x_{i}}:(i)\) where \(x\) is a count variable and \(i\) is a position index. They show that there exists a single sentence in this logic that computes the output of the transformer for any input string of any length. This is a powerful result because it shows that a simple logical formalism is fully sufficient to describe all the complexity of a massive finite-precision transformer. It also provides an upper bound on finite-precision transformers: any function that cannot be defined in first-order counting logic with modular indexing cannot be expressed by the transformer.

However, Chiang et al.'s result is not fully general because it relies on the transformer precision being fixed with respect to the transformer's context length. More generally, as we will demonstrate in Section 3, finite-precision transformers are a fundamentally weak variant of transformers: crucially, cannot express uniform attention patterns, which are a core algorithmic primitive of transformers (Weiss et al., 2018). In fact, we show that they can only attend to a constant number of input positions, which may be seen as a rather limited generalization of hard attention.1 For example, Chiang et al. show that their logic for finite-precision transformers cannot recognize \(^{m}^{m}\), whereas in practice, transformers can (Bhattamishra et al., 2020).2 This motivates studying a formal model of transformers where precision grows with context length (which we formalize as _log-precision_), making it possible to capture uniform attention as well as other broad attention patterns. This is useful both for recognizing \(^{m}^{m}\) and more generally for reasoning globally over the input.

We demonstrate that _log-precision_ transformer classifiers can also be expressed as sentences in a simple logic: _first-order logic with majority_, or \(()\), over inputs strings (Barrington et al., 1990). In addition to standard existential and universal quantifiers, \(()\) has _majority_ quantifiers that return true iff more than half the propositions they quantify are true. It also allows comparing input positions (e.g., \(<k\) in Figure 1) and accessing their individual bits. Our main result is as follows:

**Theorem 1** (Informal version of Theorem 2).: _For any log-precision transformer \(\), there exists an \(()\) sentence \(\) that computes the same function as \(\), i.e., \((x)=(x)\) for any input string \(x\)._

Upper bound.Theorem 2 shows transformers with more than finite precision can also be expressed in a simple extension of first-order logic, going beyond Chiang et al. (2023)'s result. On the other hand, \(()\) is a strict superset of Chiang et al.'s counting logic; it can simulate counting quantifiers (see Section 2.2) and allows non-modular position comparisons. Thus, handling a more general class of transformers powerful enough to express uniform attention slightly weakens the bound.

Still, our result constitutes (to our knowledge) the tightest upper bound on log-precision transformers and the first defined in terms of logic, building on a line of complexity-theoretic work analyzing the power of transformers (Hahn, 2020; Merrill et al., 2022; Liu et al., 2023; Merrill and Sabharwal, 2023). In particular, \(()\) strengthens the upper bound of log-space-uniform \(^{0}\) by Merrill and Sabharwal (2023). The refined bound adds to the limitations of transformers identified by Merrill and Sabharwal (2023): for example, it establishes unconditionally that log-precision transformers cannot compute boolean matrix permanents, and shows that, in a certain formal sense, integer division and matching parentheses are among the formally hardest problems that transformers can solve (see Section 4).3

Mechanistic interpretability.Beyond providing an upper bound on the reasoning problems solvable by transformers, we believe Theorem 1 could guide the design of "transformer-complete" programming languages similar in spirit to RASP (Weiss et al., 2018). RASP is a declarative programming language designed to capture transformer computation, and Lindner et al. (2023) implement a compiler from RASP _into_ transformers. Unlike RASP, \(()\) can provably express any transformer (Theorem 1), which we believe justifies using it (or an equivalent but more user-friendly variant) as a target language for programs extracted _from_ transformers.

Similar to a decision tree, an \(()\) sentence has the interpretable property that each sub-sentence corresponds to a constraint on input (see Figure 1). In contrast, the internal modules of a transformer or circuit do not satisfy this since they map between arbitrary latent spaces. We speculate this property could facilitate interpreting models by translating them to \(()\), though a careful exploration of the algorithmic and HCI aspects of this idea lies outside the current paper's theoretical scope.

Contributions.Our results shed new light on how to view the computation inside transformers in terms of logic. Specifically, our main contributions are to prove the following:

1. Fixed-precision transformers can only attend to a fixed number of tokens, and those with precision less than \( n\) cannot uniformly attend over length-\(n\) contexts (Proposition 1).
2. Log-precision transformer classifiers can be expressed as sentences in \(()\) (Theorem 2).

## 2 Preliminaries: Transformers and \(()\)

Let \(\) be a finite alphabet. We denote by \({}^{*}\) the Kleene star operator, i.e., for a set \(X\), \(X^{*}=_{n=0}^{}X^{n}\). We will view transformers and \(()\) sentences both as functions from \(^{*}\{0,1\}\), and show that any function a transformer computes can also be computed by an \(()\) sentence.

### Transformers

We view the transformer precision \(p\) as a function of the context length \(n\), writing \(p(n)\) where appropriate. Let \(_{p}\) be the datatype of \(p\)-precision floats, i.e., tuples \( m,e\) where \(m,e\) are signed integers together taking \(p\) bits. Using \(|x|\) to mean the size of integer \(x\), a float represents the value \(m 2^{e-|m|+1}\).4 Following Appendix A of Merrill and Sabharwal (2023), we define \(p\)-truncated addition (\(+,\)), multiplication (\(\)), and division (\(/\)) over \(_{p}\). We now define a _transformer encoder binary classifier_ over \(_{p}\), largely adopting Merrill and Sabharwal's notation.5

**Definition 1**.: A \(p\)-precision transformer \(\) with \(h\) heads, \(d\) layers, model dimension \(m\) (divisible by \(h\)), and feedforward width \(w\) is specified by:

1. An embedding function \(:_{p}^{m}\) whose form is defined in Appendix C.1.6
2. For each \(1 d\) and \(1 k h\), a head similarity function \(s_{k}^{}:_{p}^{m}_{p}^{m}_{p}\) whose form is defined in Appendix C.2;
3. For each \(1 d\) and \(1 k h\), a head value function \(v_{k}^{}:_{p}^{m}_{p}^{m/h}\) whose form is defined in Appendix C.2;
4. For each \(1 d\), an activation function \(f^{}:(_{p}^{m/h})^{h}_{p}^{m}_{p}^{m}\) whose form is defined in Appendix C.3 and implicitly uses the feedforward dimension \(w\);
5. An output classifier head \(:_{p}^{m}\{0,1\}\) whose form is defined in Appendix C.4.

**Definition 2**.: We define the transformer computation and output as a function of an input \(x^{n}\).

1. Embeddings: For \(1 i n\), \(_{i}^{0}=(x_{i},i)\).6 2. Self Attention: For \(0 d-1\), (multihead) self-attention block \(+1\) computes \(h\) attention heads: \[_{i,k}^{+1}=_{j=1}^{n}^{+1}(_{i}^{ },_{j}^{})}{Z_{i,k}} v_{k}^{+1}(_{j}^{ }),Z_{i,k}=_{j=1}^{n}s_{k}^{+1}(_{i}^{}, _{j}^{}).\]
3. Activation Block: For \(0 d-1\), activation block \(+1\) aggregates the head outputs to produce \(^{+1}\): \[_{i}^{+1}=f^{+1}(_{i,1}^{+1},,_ {i,h}^{+1},_{i}^{}).\]
4. Classifier Head: The network prediction on \(x^{n}\) is \((_{n}^{d})\).

We say \((x)=(^{d}_{|x|})\) and \(L_{}\) is the language of \(x^{*}\) such that \((x)=1\). We refer to \(,s^{}_{k},v^{}_{h},f^{}\), and \(\) as the **core functions** in \(\), and to embeddings, self attention, activation, and the classifier head as the **components** of \(\). We write \(_{}\) for the concatenated vector of parameters for the functions \(,s^{}_{k},v^{}_{h},f^{}\), and \(\), for all \(1 d\) and \(1 k h\).

We define a **log-precision transformer** as one where \(p\) is at most \(( n)\) and is a "simple" function, i.e., computable in \(( n)\) time. In our model, the weights \(_{}\) defining \(\) are fixed, but the precision \(p\) used to compute the forward pass can depend on \(n\) (see Footnote 13 for a generalization).

### First-Order Logic with Majority

As we will show, transformers can be translated into sentences in \(()\). But what do such sentences look like? Informally, \(()\) is first-order logic extended to also have majority (\(\)) quantifiers. Following Barrington et al. (1990), our sense of \(()\) takes _strings_ in \(^{*}\) as input and returns \(0\) or \(1\) to define a formal language. In this setting, quantifiers range over _indices_ (positions) into the string. Predicates can be applied to the variables introduced by these quantifiers.

**Definition 3** (\(()\) index).: Indices in \(()\) are integers denoting positions in the input string:

1. The constant \(1\), representing the first token's position.
2. The constant \(n\), representing the last token's position.
3. Strings (e.g., \(i,j,k\)) representing variables ranging over positions \(1\) to \(n\).
4. Any index built by applying addition or subtraction to other indices.7 
**Definition 4** (\(()\) formula).: Formulas in \(()\) are constructed as follows:8

1. Let \(\) be a finite alphabet. For each \(\) and any index \(i\), \((i)\), e.g., \((i)\), is a formula that is true if the \(i\)-th input token is \(\).9 2. For any indices \(i,j\), \(i=j\), \(i j\), and \(i j\) are formulas with their conventional semantics.
3. For two formulas \(,,\) and \(\) are formulas with their conventional semantics.
4. For any formula \(\) (which may refer to \(i\)), the following are valid formulas: 1. \( i\). \(\) means some value of \(i\) in \([1,n]\) makes \(\) true. 2. \( i\). \(\) means all values of \(i\) in \([1,n]\) make \(\) true. 3. \(i\). \(\) means \( n/2\) values of \(i\) in \([1,n]\) make \(\) true.

We use parentheses where necessary to disambiguate the order of operations. General formulas may contain free (i.e., unbound) variables: e.g., \( i\). \(i=j\). A _sentence_ is an \(()\) formula \(\) with no free variables. Sentences represent functions from from \(^{*}\) to \(\{0,1\}\) and thus define a formal language.11

Extensions.Beyond Definition 4, \(()\) can express _counting_ and _threshold_ quantifiers in terms of majority quantifiers (Barrington et al., 1990). Given a formula \(\), a counting quantifier creates a new formula \(^{k}i:\) that is true iff \(\) is true across exactly \(k\) values of \(i\). Threshold quantifiers \(^{ k}\) and \(^{ k}\) work similarly but check if \(\) is true for at least or at most \(k\) values of \(i\). In addition, we show in Appendix A that \(()\) can express _conditional majority_ quantifiers, which create a formula \(i:[]\) that is true iff \(\) is true for at least half the values of \(i\) that make \(\) true.

#### 2.2.1 Examples

To illustrate the formalism, we provide example languages definable in \(()\) with \(=\{,\}\). First, we show two languages that do not require majority quantifiers to express:

**Example 1** (Bigram matching).: Strings containing the bigram \(\): \( i[(i)(i+1)].\)

**Example 2** (Skip-bigram matching).: Strings containing the long-distance pattern \(\) (cf. "induction heads" of Elhage et al. 2021): \( i[(i) j[j i(j) ]].\)In contrast, Example 3 is a simple example that requires majority quantifiers (Furst et al., 1984):

**Example 3** (Majority).: Strings with more b's than a's: \(i[(i)].\)

Figure 1 showed how \(()\) can be used to recognize patterns like \(^{m}^{m}\). A similar idea can be used to model parentheses matching (Barrington et al., 1990):

**Example 4** (1-Dyck).: The well-balanced parentheses language (with a opening and b closing):

\[ i.\ ( a,b.\ ((^{a}j:(j) j i)( ^{b}j:(j) j i) b a))i.\ (i)j.\ (j).\]

**Example 5** (Integer Arithmetic).: Iterated addition (i.e., summing \(n\)\(n\)-bit numbers), iterated multiplication, and division (Hesse, 2001) can all be expressed in \(()\).

## 3 Finite Precision Transformers Cannot Attend Universally

Attention heads that spread attention weight uniformly across inputs have been observed in transformer LMs (Merrill et al., 2021) and make soft attention fundamentally more powerful than hard attention (Hao et al., 2022; Merrill et al., 2022). In particular, uniform attention is an important primitive that transformers can use to solve tasks involving counting (Bhattamishra et al., 2020; Chiang et al., 2023), taking majority votes (Merrill et al., 2022), and matching parentheses or sorting (Weiss et al., 2021). A transformer with sufficient precision can easily implement uniform attention by setting the keys and queries across all positions to be constant. However, attention heads with finite precision cannot represent uniform attention over long sequences as a consequence of the following:

**Proposition 1**.: _Let \(^{n}\) s.t. \(_{i=1}^{n}a_{i}=1\) and \(}\) its nearest \(p\)-precision float approximation._

1. _Then the number of nonzero entries of_ \(}\) _is upper bounded by its precision: specifically,_ \(}\) _has at most_ \(2^{2^{p}}\) _nonzero entries._
2. _Moreover, if_ \(p< n\) _and_ \(\) _is uniform (i.e.,_ \(a_{i}=1/n\)_), then_ \(}=\)_._

Proof.: The smallest positive value representable by a \(p\)-precision float is \(2^{-(p_{m}-2+2^{p_{e}-1})}\) which is bounded below by \(2^{-2^{p}+1}\). Letting \(k=2^{2^{p}}\), it holds that \(2^{-2^{p}+1}=2/k\). So if \(_{i}\) gets the minimum value, then \(a_{i} 1/k\). Since \(_{i}a_{i}=1\), there can be at most \(k\) indices satisfying this property. This implies there can be at most \(k\) nonzero entries in \(}\). If \(n>k\) and \(\) is uniform, \(1/n\) is less than half of the minimum representable value of \(2/k\). Thus, \(}=\). 

Proposition 1 says that fixed-precision transformers are artificially limited because they can only attend over bounded-length windows, making them similar to hard-attention transformers (Hao et al., 2022). Morever, they cannot compute uniform attention over contexts of length \(n\) with less than \( n\) precision. This explains why Chiang et al. (2023) prove finite-precision transformers provably cannot recognize \(^{m}^{m}\), while in practice transformers have been shown to learn even its harder variant \(^{m}^{m}^{m}\) even with long context lengths (Bhattamishra et al., 2020). In essence, their upper bound only applies in the asymptotic regime when \(n>2^{2^{p}}\).

In contrast, transformers in practice have enough precision both to compute uniform attention and recognize \(^{m}^{m}\) on practical context lengths. More concretely, the bfloat16 representation allows uniform attention over \(2^{6+2^{7}} 10^{42}\) tokens and normal float1612 allows \(2^{10+2^{4}} 10^{8}\) tokens, both well above the typical context window of transformers. This motivates a formal model of transformers with enough precision to compute uniform attention and recognize languages such as \(^{m}^{m}\).

## 4 Main Result: Expressing Log-Precision Transformers in \(()\)

By Proposition 1, precision must grow with the context length \(n\) (\(p> n\)) for a transformer to compute uniform attention and other attention patterns with unbounded range, like practical transformers. In this paper, we analyze any transformer with up to \(( n)\) precision. We show that any function computable by log-precision transformers can be expressed in \(()\):

**Theorem 2**.: _Let \(\) be a log-precision transformer with a parameter vector \(_{}\) fixed for all context lengths \(n\).13 Then, there exists an \(()\) sentence \(\) that computes the same function as \(\), i.e., \((x)=(x)\) for any input string \(x\)._

Theorem 2 is the tightest known upper bound for log-precision transformers and shows that it is still possible to characterize transformers in a simple variant of first-order logic even with log-precision and uniform attention. As alluded to earlier, Theorem 2 immediately implies that any problem complete for \(()\) (or a larger class) is also transformer-hard. Since integer division and Dyck language membership are known to be \(()\)-complete (Hesse, 2001; Aaronson et al., 2022), it follows, perhaps surprisingly, that the entire computation of any transformer on input \(x\) can be reduced to a single integer division or a finite number of Dyck-language queries:

**Corollary 2.1**.: _Let \(\) be a transformer satisfying Theorem 2. For any input \(x\), there exist first-order definable integers \(a,b,\) and \(i\) (dependent on \(\) and \(x\)) such that \((x)\) equals the \(i\)-th bit of \( a/b\). For any \(x\), there also exist first-order definable strings \(w_{1},,w_{m}\) such that \((x)\) is first-order definable in terms of the membership of the \(w_{i}\)'s in \(k\)-Dyck._

## 5 Preliminaries for Proving Theorem 2

### Computation Graphs

A _computation graph_\(G\) over a datatype \(\{0,1\}^{*}\) and a countable set of primitive functions \(^{*}\) is a directed acyclic graph where:

1. Each node is labelled by a _node type_: a function \(f\) computed by this node.
2. Each edge represents a value \(\) flowing as output from one node into another node. We consider the edges flowing into node \(j\) to have an order, i.e., be numbered.
3. \(\) contains the special symbol input, which designates \(k\) nodes as input nodes. We refer to \(k\) as the _arity_ and assume w.l.o.g. that nodes \(0,,k-1\) are inputs.14 4. A single node is taken as the output node (w.l.o.g., the node with the largest index).

A computation graph \(G\) of arity \(k\) parameterizes a function \(^{k}\) in the standard way: the input nodes are assigned the input values, and the value of each node is computed (traversing the graph in a bottom-up topological order) as a function of the values of its children until the output node receives a value. The value of the output node is considered the output of the function. It is worth noting that computation graphs can only process inputs of bounded length. To process arbitrary-length inputs, we will need to generalize them to computation graph families (Section 5.2).

For a computation graph \(G\), \((G)\) is the number of nodes, \((G)\) is the length of the longest path from an input node to the output, and \((G,i)\) is the number of inputs to node \(i\).

**Threshold circuits.** A threshold circuit is a special case of a computation graph where \(=\{0,1\}\) and \(\) is the set of threshold functions of the form \(_{}\) and \(_{}\) over \(^{*}\), defined as follows: \(_{}(x)=1\) if \(_{ x}\) and \(0\) otherwise; \(_{}(x)\) is defined analogously. Typical AND, OR, and NOT gates are a special case of threshold gates, as is an IDENTITY gate.15

We allow nodes with the \(k^{} 1\) largest indices to all be designated as (ordered) output nodes. A threshold circuit with arity \(k\) and \(k^{}\) output nodes will thus be a function from \(\{0,1\}^{k}\) to \(\{0,1\}^{k^{}}\). This will be convenient when simulating neural network components that output multiple bits.

We will find it useful to consider threshold circuits as a kind of compilation target for computation graphs: in other words, we will be concerned with simulating computation graphs defined over more complex functions and data types into threshold circuits.

### Computation Graph Families

A computation graph family over \(\) and \(\) is a mapping from \(n\) to a computation graph \(G_{n}\) for processing inputs of size \(n\). Thus, \(\) defines a function from \(^{*}\), where \((x)=G_{|x|}(x)\)Intuitively, computation graph families are useful because they generalize computation graphs to define functions over _unbounded-length_ strings as inputs.

**Size, depth, and arity.** For computation graph families, the size, depth, and arity become functions of the input length \(n\): \(_{}(n)=(G_{n}),_{}(n)=(G_{n}),_{}(n,i)=(G_{n},i)\).

**Uniformity.** The infinite set \(\) can be alternatively represented by two functions:

1. \(_{}(n,i)\), which returns the type of node \(i\) in \(G_{n}\) if \(i(G_{n})\), and \(\) otherwise. For example, if node \(i\) computes the logical AND of its inputs, then \(_{}(n,i)=\).
2. \(_{}(n,i,j)\), which returns the argument index of \(i\) into node \(j\) if \(G_{n}\) contains an edge \(i j\) and \(-1\) otherwise. \(_{}(n,i,j)\) only needs to be defined over \(i,j<(G_{n})\). For example, if \(G_{n}\) contains a node \(j\) with three incoming edges, the second of which comes from node \(i\), then \(_{}(n,i,j)=1\).

A pair of algorithms implementing these two functions uniquely specifies a computation graph family, as it enables building the computation graph \(G_{n}\) for any \(n\). Uniform computation graph families (generalizing uniform circuits; cf. Arora and Barak, 2009) are families where \(_{}\) and \(_{}\) can be computed efficiently, i.e., under some constraints on space or time:

**Definition 5** (Uniformity).: A computation graph family \(\) is \(T(n)\)-uniform iff \(_{}(n,i)\) and \(_{}(n,i,j)\) can be computed by a deterministic Turing machine in time \(T(n)\). We focus on _log-uniform_ computation graph families: i.e., where \(T(n)=( n)\).16

**Threshold circuit families.** These are simply families of threshold circuits. We will be simulating computation graph families with threshold circuit families. Log-uniform \(^{0}\) is the class of languages recognized by log-uniform constant-depth, poly-size threshold circuit families. See Merrill and Sabharwal (2023); Liu et al. (2023); Arora and Barak (2009) for more background on \(^{0}\) and circuits.

## 6 Proof of Theorem 2

The idea is to simulate a transformer with a log-uniform \(^{0}\) circuit family. Since log-uniform \(^{0}=()\), this would imply any transformer can be expressed in \(()\). First, we note that transformers are log-uniform computation graphs:

**Lemma 1** (Proof in Appendix B.1).: _A transformer \(\) is a log-uniform computation graph family where \(\) contains embedding, self-attention, feedforward, and output components._

Further, each core module of the transformer can be simulated by a log-uniform \(^{0}\) circuit family:

**Lemma 2** (Proof in Appendix B.2).: _Let \(\) be a log-precision transformer with fixed parameters \(_{}\). Then each component in \(\) is computable in log-uniform \(^{0}\)._

Intuitively, we can now simulate a transformer in log-uniform \(^{0}\) by just simulating each of its components with a threshold circuit and routing their inputs and outputs appropriately. However, we will need two more technical conditions to verify that this construction is indeed log-uniform:

**Lemma 3** (Proof in Appendix B.3).: _Let \(\) be a log-precision transformer with fixed parameters \(_{}\). There exists a function \((n)\) that is a power of \(2\) and computable in \(( n)\) time s.t. \(_{}(n)(n)\) for all \(\)._

**Lemma 4** (Proof in Appendix B.4).: _If \(\) is a log-uniform \(^{0}\) family and \(_{}(n)(n)\), there exists a log-uniform \(^{0}\) family \(^{}\) s.t. \((x)=^{}(x)\) for all \(x\) and \(_{^{}}(n)=(n)\)._

Combined, Lemmas 3 and 4 show that each \(\) is computable by a log-uniform \(^{0}\) family with size \((n)\) that is a power of \(2\) and computable in time \(( n)\). We will show these conditions imply a transformer \(\) can be simulated by a \(^{0}\) family \(\) (Theorem 3) and moreover that \(\) is log-uniform (Corollary 3.2). By the equivalence of log-uniform \(^{0}\) and \(()\) (Barrington et al., 1990), we then conclude that any log-precision transformer can be expressed in \(()\).

### Simulating Computation Graph Families with Circuit Families

We give algorithms that take a computation graph family and define a circuit family simulating it. Intuitively, the algorithms creates contiguous blocks of circuit gates simulating each node in the computation graph and route inputs and outputs between blocks appropriately.

Block mapping.This algorithm depends on a _block mapping_, which is an implementation of the following three functions:

1. The _block node_\((n,i)\): the index of the node that gate \(i\)'s block is simulating.
2. The _block start_\((n,i^{})\): the smallest gate index in the block simulating node \(i^{}\).
3. The _block size_\((n,i^{})\): the number of gates in the block simulating node \(i^{}\).

Further, we enforce that a valid block mapping must satisfy that, for all \(i\), with \(i^{}=(n,i)\),

\[(n,i^{}) i<(n,i^{})+(n,i^{}).\]

Let \(\) be a computation graph whose primitive functions are computable by log-uniform threshold circuits. We can identify each primitive function with a log-uniform threshold circuit family \(\) that computes it, where the first \(_{}(n)\) gates are IDENTITY gates reserved for taking input. For such a graph, \(_{}\) can be taken to return a symbol identifying a circuit family \(\). In this case, our algorithm requires that, for all \(i^{}\), the block size of \(i^{}\) must match the size of the circuit for the type of block \(i^{}\), i.e., \((n,i^{})=_{_{}(n,i ^{})}(n)\). These properties let us meaningfully identify a graph node \(i^{}\) with a block of nodes that will simulate it. This intuition enables us to develop Algorithms 1 and 2 for constructing a uniform threshold circuit family from a uniform computation graph family.

```
1:\(_{}(n,(n,i))\)
2:if\(\)then
3:return\(_{}(n,i-(n,i^{}))\)
4:elsereturn\(\) ```

**Algorithm 2**\(_{}(n,i,j)\)

**Theorem 3**.: _Let \(\) be a computation graph over a finite set of node types \(\), where each \(\) is specified by a log-uniform circuit family. Let \(\), \(\), and \(\) be a valid block mapping in the sense above. Then Algorithms 1 and 2 define a circuit family \(\) such that_

1. \(\) _and_ \(\) _compute the same_ \(_{p}^{*}_{p}\) _function (let the final_ \(p\) _gates of each_ \(C_{i}\) _be its output)._
2. \(_{}(n)_{}(n) _{}_{}(n)\)_._
3. \(_{}(n)_{}(n)_{ }_{}(n)\)_._

Proof.: Assume w.l.o.g. that the gates of \(\) are topologically ordered. We show by induction over circuit gates \(j\) (with \(j^{}=(n,j)\)) that:

1. For all \(i^{}<j^{}\), the last \(p\) nodes of block \(i^{}\) store the value of node \(i^{}\).
2. For all \(i\) such that \((n,j^{}) i j\), gate \(i\) of \(\) (as a function of the input nodes of \(j^{}\) ) computes gate \(i-(n,j^{})\) of \(_{}(n,j^{})\).

Base case. We have two circuits with no gates, so the premises are trivially satisfied.

Inductive case. Assume the premises hold up to \(j\). We will show they hold for \(j+1\). Let \(=_{}(n,j^{})\). By Premise 1, we know that the last \(p\) nodes of block \(i^{}\) store the output of node \(i^{}\), for\(i^{}<j^{}\). By Algorithm 2, for each \(i^{}\) such that \(_{}(n,i^{},j^{})=a\) with \(0 k<_{}(n)\), gates \(kp\) through \(k(p+1)-1\) of block \(j^{}\) will copy the final \(p\) gates of block \(i^{}\). Thus, the first \(k_{}(n)\) gates of block \(j^{}\) store the inputs to node \(j^{}\).

At this point, we use Premise 2 to conclude that the first \(j-(n,j^{})\) gates of block \(j^{}\) compute the same function as the first \(j-(n,j^{})\) gates of \(\) with respect to this input. Thus, we just need to show that gate \(j+1\) is also correct. Within Algorithm 2, we fall in case \(i^{}=j^{}\), meaning that gate \(j+1\) of block \(j^{}\) gates the same inputs as gate \(j+1\) of \(\). By Algorithm 1, the type of gate \(j+1\) in block \(j^{}\) is the type of gate \(j+1\) of \(\). Thus, gate \(j+1\) in block \(j^{}\) computes the same function of the input gates as gate \(j+1\) in \(\). If \(j+1=(n,j^{})\), we conclude that the final \(p\) gates of block \(j^{}\) store the output of node \(j^{}\). 

Let \(^{0}\) denote any family of constant-depth, poly-size circuits, including \(^{0}\) and \(^{0}\).17

**Corollary 3.1**.: _Let \(\) be a constant-depth, poly-size computation graph family over a finite \(\). If every node type in \(\) can be computed by \(^{0}\) circuits, the function computed by \(\) is in \(^{0}\)._

Since a transformer has constant depth and polynomial size, Corollary 3.1 lets us easily recover prior results about hard-attention transformers (Hao et al., 2022; Hahn, 2020) and saturated attention transformers (Merrill et al., 2022) using a common framework. All one has to do is show that all individual node types in such transformers can be computed by \(^{0}\) and \(^{0}\) circuits, respectively.

Corollary 3.1 established that Algorithms 1 and 2 construct a circuit family that simulates \(\). With the right block mapping, \(\) will be log-uniform as long as \(\) and its node types are log-uniform.

**Corollary 3.2**.: _Let \(\) be a log-uniform, constant-depth computation graph family over a finite \(\), where each \(\) is specified by a log-uniform \(^{0}\) family with \(_{}(n)=(n)\) that is a power of \(2\) computable in \(( n)\) time. Then \(\) can be simulated by a log-uniform \(^{0}\) family \(\) that obeys the size and depth properties of Theorem 3._

Proof.: Let \(\) be the circuit family defined by Algorithms 1 and 2 given \(\) and the following block mapping: \((n,i)= i/(n),(n,i^ {})=i^{}(n),(n,i^{})= (n)\). Since \((n)\) is a power of \(2\), \(\) and \(\) are reducible to left and right shifting over \(( n)\)-bit integers, which can be implemented in \(( n)\) time. Thus, each block mapping function is computable in time \(( n)\). Since \(_{}\) and \(_{}\) are just calling functions computable in time \(( n)\) with constant overhead, we conclude that \(\), the circuit family they define, is log-uniform, and it is already known to simulate \(\) with constant depth and polynomial size by Theorem 3. 

## 7 Conclusion

We proved that any log-precision transformer classifier can be translated to an \(()\) sentence that computes the same function (on all inputs of any length). This result comes by first simulating a transformer with a highly uniform threshold circuit family, and then leveraging the established equivalence of log-uniform circuits and \(()\). Transformers and other neural nets are often discussed in contrast with symbolic models based on logical formalisms (Garnelo & Shanahan, 2019)--an immediate implication of our result is that it is possible to express the inner workings of transformers also in a simple logic, challenging the premise of a rigid division between symbolic and neural models. Our results also provide the tightest known upper bound on log-precision transformers.

While it is striking that a full transformer can be translated to a sentence in a logic as simple as \(()\), we believe the bound is not tight. In particular, we conjecture that it is possible to simulate any transformer with an \(()\) sentence of quantifier depth of at most 2, which could be proven by establishing a hierarchy theorem describing the \(()\) quantifier depth needed to simulate a \(^{0}\) family of a certain size. It would also be an interesting extension to translate real transformers to \(()\) sentences. In this sense, we believe our results provide a theoretical foundation to guide mechanistic interpretability work (cf. Weiss et al., 2021; Lindner et al., 2023).

Our findings provide a novel view into transformer classifiers and their limits. It would be exciting for future research to extend our results to account for other common practical uses of transformers, such as for long-form generation, chain-of-thought reasoning, and in-context learning.

#### Acknowledgments

We thank Paul Beame, David Chiang, anonymous reviewers, and researchers at the Allen Institute for AI for feedback. WM was supported by an NSF graduate research fellowship and in part by NSF award 1922658.