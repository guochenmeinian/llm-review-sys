# Deep Policy Gradient Methods Without Batch Updates, Target Networks, or Replay Buffers

Gautham Vasan\({}^{12}\)   Mohamed Elsayed\({}^{12}\)   Alireza Azimi\({}^{*12}\)   Jiamin He\({}^{*12}\)

Fahim Shariar\({}^{12}\)   Colin Bellinger\({}^{3}\)   Martha White\({}^{124}\)   A. Rupam Mahmood\({}^{124}\)

\({}^{1}\)University of Alberta   \({}^{2}\)Amii   \({}^{3}\) National Research Council of Canada   \({}^{4}\) CIFAR Canada AI Chair {vasan, mohamedelsayed, sazimi, jiamin12, fshahri1}@ualberta.ca

colin.bellinger@nrc-cnrc.gc.ca {whitem, armahmood}@ualberta.ca

###### Abstract

Modern deep policy gradient methods achieve effective performance on simulated robotic tasks, but they all require large replay buffers or expensive batch updates, or both, making them incompatible for real systems with resource-limited computers. We show that these methods fail catastrophically when limited to small replay buffers or during _incremental learning_, where updates only use the most recent sample without batch updates or a replay buffer. We propose a novel incremental deep policy gradient method -- _Action Value Gradient (AVG)_ and a set of normalization and scaling techniques to address the challenges of instability in incremental learning. On robotic simulation benchmarks, we show that AVG is the only incremental method that learns effectively, often achieving final performance comparable to batch policy gradient methods. This advancement enabled us to show for the first time effective deep reinforcement learning with real robots using only incremental updates, employing a robotic manipulator and a mobile robot.1

## 1 Introduction

Real-time or online learning is essential for intelligent agents to adapt to unforeseen changes in dynamic environments. However, real-time learning faces substantial challenges in many real-world systems, such as robots, due to limited onboard computational resources and storage capacity (Hayes and Kanan 2022, Wang et al. 2023, Michieli and Ozay 2023). The system must process observations, compute and execute actions, and learn from experience, all while adhering to strict computational and time constraints (Yuan and Mahmood 2022). For example, the Mars rover faces stringent limitations on its computational capabilities and storage capacity (Verma et al. 2023), constraining the system's ability to run computationally intensive algorithms onboard.

Deep policy gradient methods have risen to prominence for their effectiveness in real-world control tasks, such as dexterous manipulation of a Rubik's cube (Akkaya et al. 2019), quadruped dribbling of a soccer ball (Ji et al. 2023), and magnetic control of tokamak plasmas (Degrave et al. 2022). These methods are typically used offline, such as in simulations, as they have steep resource requirements due to their use of large storage of past experience in a replay buffer, target networks and computationally intensive batch updates for learning. As a result, these methods are ill-suited for on-device learning and generally challenging to use for real-time learning. To make these methods applicable to resource-limited computers such as edge devices, a natural approach is to reduce the replay buffer size, eliminate target networks, and use smaller batch updates that meet the resource constraints.

In Figure 1, we demonstrate using four MuJoCo tasks (Todorov et al. 2012) that the learning performance of batch policy gradient methods degrades substantially when the replay buffer size isreduced from their large default values. Specifically, Proximal Policy Optimization (PPO, Schulman et al., 2017), Soft Actor-Critic (SAC, Haarnoja et al., 2018), and Twin Delayed Deep Deterministic Policy Gradient (TD3, Fujimoto et al., 2018) fail catastrophically when their buffer size is reduced to \(1\). This case corresponds to _incremental learning_, where learning relies solely on the most recent sample, thus precluding the use of a replay buffer or batch updates.

Incremental learning methods (Vijayakumar et al. 2005, Mahmood 2017) are computationally cheap and commonly used for real-time learning with linear function approximation (Degris et al. 2012, Modayil et al. 2014, Vasan and Pilarski 2017). However, incremental policy gradient methods, such as the incremental one-step actor-critic (IAC, Sutton and Barto 2018), are rarely used in applications of deep reinforcement learning (RL), except for a few works (e.g., Young and Tian 2019) that work in limited settings. The results in Fig. 1 indicate that their absence is due to their difficulty in learning effectively when used with deep neural networks. A robust incremental method that can leverage deep neural networks for learning in real-time remains an important open challenge.

Incremental policy gradient methods, such as IAC, employ the likelihood ratio gradient (LG) estimator to estimate the gradient. An alternative approach to estimating the gradient, the reparameterization gradient (RG) estimator or the pathwise gradient estimator, has been observed to demonstrate lower variance in practice and can effectively handle continuous state and action spaces (Greensmith et al. 2004, Fan et al. 2015, Lan et al. 2022). RG estimators have recently gained interest in RL due to their use in deep policy gradient methods such as TD3 and SAC. However, we currently lack incremental policy gradient methods that use the RG estimator.

We present a novel incremental algorithm, called _Action Value Gradient (AVG)_, which leverages deep neural networks and utilizes the RG estimator. While batch updates, replay buffers, and target networks are required to stabilize deep RL (D'Oro et al. 2022, Schwarzer et al. 2023), AVG instead incorporates normalization and scaling techniques to learn stably in the incremental setting (see Sec. 3). In Sec. 4, we demonstrate that AVG achieves strong results across a wide range of benchmarks, being the only incremental algorithm to avoid catastrophic failure and learn effectively. In Sec. 5, we highlight the key challenges of incremental learning stemming from the large and noisy gradients inherent to the process. Through an ablation study, we discuss how normalization and scaling techniques help mitigate these issues for AVG and how they may salvage the performance of other methods, including IAC and an incremental variant of SAC. We also show that target networks hinder the learning performance of AVG in the incremental setting, with only aggressive updates of the target network towards the critic achieving results comparable to AVG, while their removal reduces memory demands and simplifies our algorithm. Finally, we apply AVG to real-time robot learning tasks, showcasing the first successful demonstration of an incremental deep RL method on real robots.

## 2 Background

We consider the reinforcement learning setting where an agent-environment interaction is modeled as a continuous state and action space Markov Decision Process (MDP) (Sutton and Barto 2018). The state, action, and reward at timestep \(t(0,1,2,)\) is denoted by \(S_{t}\), \(A_{t}\) and \(R_{t+1}\) respectively. We focus on the episodic setting where the goal of the agent is to maximize the discounted return \(G_{t}=_{k=0}^{T-t-1}^{k}R_{t+k+1}\), where \(\) is a discount factor and \(T\) is the episode horizon. The agent selects an action \(A_{t}\) according to a policy \((|S_{t})\) where \((A|S)\)

Figure 1: Impact of reducing replay buffer size on SAC, PPO, and TD3: Decreasing the replay buffer size adversely affects learning. In contrast, AVG succeeds despite learning without a replay buffer, as shown by a “buffer size” of 1 in the plots. Each data point represents the mean episodic return over the final 100K steps, averaged across 30 runs. All methods were trained for 10M timesteps.

gives the probability of sampling an action \(A\) in state \(S\). Value functions are defined to be expected total discounted rewards from timestep \(t\): \(v_{}(s)=_{}[_{k=0}^{T-t-1}^{k}R_{t+k+1}|S_{t}=s]\) and \(q_{}(s,a)=_{}[_{k=0}^{T-t-1}^{k}R_{t+k+1}|S_{t}= s,A_{t}=a]\). Our goal is to find the weights \(\) of a parameterized policy \(_{}\) such that it maximizes the expected return starting from initial states: \(J()_{S d_{0}}[v_{_{}}(S)]\).

Parameterized policies are typically learned based on the gradients of \(J()\). Since the true gradients \(_{}J()\) are typically not available, sample-based methods are commonly used for gradient estimation (Greensmith et al., 2004). Two existing theorems, known as _policy gradient theorem_ and _reparameterization gradient theorem_ provide ways of computing unbiased estimates of the gradient based on likelihood gradient (LG) estimators and reparameterization gradient (RG) estimators, respectively.

LG estimators use the log-derivative technique to provide an unbiased gradient estimate (Glynn, 1990; Williams and Peng, 1991): \(_{}_{p_{}}[(X)]=_{X p_{}} [(X)_{} p_{}(X)]\), where \(p_{}(x)\) is the probability density of \(x\) with parameters \(\), and \((x)\) is a scalar-valued function. In the context of the policy gradient theorem (Sutton et al., 1999), the LG estimator is utilized to adjust the parameters \(\) of a policy \(\), in expectation, in the direction of the gradient of the expected return: \(_{}J()_{S d_{,},A_{ }}[_{}_{}(A|S)q_{_{}}(S,A)]\), where \(d_{,}\) is the discounted stationary state distribution (Che et al., 2023). Many algorithms, including incremental ones like one-step actor-critic (IAC) and batch methods like A2C (Mnih et al., 2016), ACER (Wang et al., 2016) and PPO, are based on the policy gradient theorem and use the LG estimator.

RG estimators, also known as pathwise gradient estimators (Greensmith et al., 2004; Parmas and Sugiyama, 2021), leverage the knowledge of the underlying density \(p_{}(x)\) by introducing a simpler, equivalent sampling procedure: \(X p_{}()=f_{}(), g()\), where \(\) is sampled from a base distribution \(g()\) independent of \(\), and \(f_{}\) is a function that maps \(\) to \(X\). RG estimation can be written as \(_{}_{p_{}}[(X)]=_{ g}[_ {}(f_{}())]\). RG estimators form the foundation of several batch RL algorithms, including Reward Policy Gradient (Lan et al., 2022), SAC and TD3. Lan et al. (2022) showed how RG estimation can be used to provide an alternative approach to unbiased estimation of the policy gradient through the reparametrization gradient theorem: \(_{}J()=_{S d_{,},A_{}} [_{}f_{}(;S)|_{=h_{}(A;S)}_{A}q_{_{ }}(S,A)]\), where \(h\) is a inverse function of \(f\).

Deep reinforcement learning (RL) methods that use LG or RG estimators can often converge prematurely to sub-optimal policies (Mnih et al., 2016) or settle on a single output choice when multiple options could maximize the expected return (Williams and Peng, 1991). This issue can be mitigated through _entropy regularization_, which promotes exploration and smoothens the optimization landscape under certain scenarios (Ahmed et al., 2019). This is accomplished by augmenting the reward function with an entropy term (i.e., \([- p_{}(X)]\)), encouraging the policy to maintain randomness in action selection. In this approach, the value functions are redefined as follows (Ziebart et al., 2010): \(v_{}^{}(s)=_{}[_{k=0}^{T-t-1}^{k} (R_{t+k+1}+((|S_{t+k})))|S_{t}=s],\) and \(q_{}^{}(s,a)=_{}[R_{t+1}+ v_{}^{}(S_{t+1})|S_{t}=s,A_{t}=a],\) where \(\) is the entropy coefficient and entropy \(((|s))=-_{}(a|s)(a|s)da\).

## 3 The Action Value Gradient Method

In this section, we introduce a novel algorithm called Action Value Gradient (AVG, see Alg. 1)2, outlining its key components and functionality and briefly discussing its theoretical foundations. We also discuss additional design choices that are crucial for robust and effective policy learning. AVG uses RG estimation, extended to incorporate entropy-augmented value functions:

\[_{}J()=_{S d_{,},A_{}} [_{}f_{}(;S)|_{=h_{}(A;S)}_{A}(q_ {_{}}(S,A)-(_{}(A|S)))]. \]

A brief derivation of this statement is provided in Appendix A.

The AVG algorithm maintains a parameterized policy or actor \(_{}(A|S)\) to sample actions from a continuous distribution and critic \(Q_{}(S,A)\) that estimates the entropy-augmented action-value function. Both networks are parameterized using deep neural networks. AVG samples actions using the reparameterization technique (Kingma and Welling, 2013), which allows the gradient to flow through the sampled action \(A_{}\) to the critic \(Q_{}(S,A_{})\), enabling the policy parameters \(\) to be updated smoothly based on the critic.

We use the same action \(A_{}\) to update both the actor and critic networks. First, the critic weights \(\) are updated using the temporal difference error; \(_{Q}>0\) is its step size. This step also involves sampling another action \(A^{}\) that is used to estimate the bootstrap target. Then, the actor updates its weights \(\) based on \(Q_{}(S,A_{})\) and the sample entropy \(-(_{}(A_{}|S))\); \(_{}>0\) is the step size of the actor, and \( 0\) is used to weight the sample entropy term.

A careful reader may notice the similarity between the learning updates of SAC and AVG. However, SAC is an off-policy batch method, while AVG is an incremental on-policy method. SAC samples actions and stores them in a replay buffer. Unlike AVG, SAC does not reuse the same action to back-propagate gradients for the actor. Additionally, AVG is simpler than SAC, as it avoids the use of double Q-learning or target Q-networks  for stability. For comparison, we provide the pseudocode of an incremental variant of SAC, termed _SAC-1_ (Alg. 5).

We also use _orthogonal initialization_, _entropy regularization_, a _squashed normal policy_, as is standard in off-policy actor-critic methods like DDPG, TD3, and SAC. To enforce action bounds, a squashed normal policy passes the sampled action from a normal distribution through the tanh function to obtain actions in the range \([-1,1]\): \(A_{}=f_{}(;S)=(_{}(S)+_{}(S))\) where \((0,1)\). This parameterization is particularly useful for entropy-regularized RL objectives. In an unbounded normal policy, the standard deviation \(\) has a monotonic relationship with entropy, such that maximizing the entropy often drives \(\) to large values, approximating a uniform random policy. Conversely, for a squashed univariate normal distribution, entropy increases with \(\) only up to a certain threshold, beyond which it begins to decrease (see Fig. 2).

Incremental methods can be particularly prone to issues stemming from large and noisy gradients. While off-policy batch methods such as SAC and TD3 benefit from many compute-intensive gradient updates, which effectively smooth out noisy gradients, incremental methods require alternative strategies to manage large gradient updates. Hence, we focus on additional incremental normalization and scaling methods that help stabilize the learning process. These techniques can be seamlessly incorporated into our algorithm with minimal computational overhead. Sec. 5 provides an in-depth discussion that motivates and comprehensively analyzes the impact of the normalization and scaling techniques used in our proposed algorithm.

Stable learning in AVG is achieved by normalizing inputs and hidden unit activations, as well as scaling the temporal difference error. Below, we outline three normalization and scaling techniques used in AVG (more details in Sec. 5).

**Observation normalization** We normalize the observation, which is a commonly used technique in on-policy RL algorithms such as PPO to attain good learning performance. We use an online

Figure 2: Effect of \(\) on entropy of normal and squashed normal distribution

algorithm to estimate the sample mean and variance (Welford, 1962, See Alg. 2). Sample running mean and variance are effective for stationary and transient distributions, enabling continuous updates that adapt to time-varying characteristics efficiently. In contrast, weighted means emphasize recent observations, making them ideal when recent data points hold greater importance. We use the sample running mean since standard continuous control benchmarks exhibit transient distributions for policies.

**Penultimate Normalization**Bjorck et al. (2022) suggest normalizing features (\(_{}(S)\)) of the penultimate layer of a neural network. These features are normalized into a unit vector \(_{}(S)=_{}(S)/\|_{}(S)\|_{2}\), with gradients computed through the feature normalization. Unlike layer normalization (Ba et al., 2016), no mean subtraction is performed.

**Scaling Temporal Difference Errors**Schaul et al. (2021) proposed replacing raw temporal difference (TD) errors \(_{t}\) by a scaled version: \(_{t}:=_{t}/_{}\) where \(_{}^{2}:=[R]+[][G^{2}]\). This technique can handle varying episodic return scales across domains, tasks, and stages of learning. It is also algorithm-agnostic and does not require access to the internal states of an agent. In batch RL methods with a replay buffer, \(_{}\) can be computed offline by aggregating the discounted return from each state across stored episodes. However, in the incremental setting, where past data cannot be reused, this approach is infeasible. Consequently, we only use the cumulative return starting from the episode's initial state (See Alg. 3). We also use sample mean and variance of \(R,\) and \(G^{2}\) to calculate \(_{}\).

**On the Theory of AVG** In Appendix I, we provide a convergence analysis for the reparameterization gradient estimator, which the AVG estimator (1) builds upon. The analysis fixes errors in the convergence result for deterministic policies from Xiong et al. (2022) and extends it to the general case of reparameterized policies. To the best of our knowledge, this is the first convergence result for model-free methods that use the reparameterization gradient estimator. Furthermore, a detailed discussion of related theoretical results is also included in Appendix A.

```
Input \(X,n,,\) \(n n+1\) \( X-\) \(+/n\) \(_{2} X-\) \(+_{2}\) \(/n\) \(X_{norm}_{2}/\) return\(X_{norm},n,,,\)
```

**Algorithm 2** Normalize (Welford, 1962)

```
Input \(R,,G,_{},_{},_{}\) \(n_{R},n_{},n_{G}_{};_{R},_{ },_{G}_{}\) \(_{R},_{},_{G} {}_{}\) \(\)\(_{G}\): Sample mean of \(G^{2}\) \(\_,n_{R},_{R},_{R},_{R}(R,n_{R},_{R},_{R})\) \(\_,n_{},_{},_{},_{} (,n_{},_{},_{})\) ifG is not \(\)then \(\_,n_{G},_{G},_{G},\_\)\((G^{2},n_{G},_{G},_{G})\) endif if\(n_{G}>1\)then \(_{}^{2}+_{G}_{}^{2}}\) else \(_{} 1\) endif \(_{}[n_{R},n_{},n_{G}]; _{}[_{R},_{},_{G}]\) \(_{}[_{R},_{}, _{G}]\) return\(_{},_{},_{},_{}\)
```

**Algorithm 3** ScaleTDError

## 4 AVG on Simulated Benchmark Tasks

In this section, we demonstrate the superior performance of AVG compared to existing incremental learning methods. Specifically, we compare AVG against an existing incremental method -- IAC, which has demonstrated strong performance with linear function approximation in real-time learning across both simulated and real-world robot tasks (Degris et al., 2012; Vasan, 2017). The implementation details can be found in Appendix E. Additionally, we evaluate AVG against incremental adaptations of SAC and TD3, both of which, like AVG, use RG estimation.

SAC and TD3 rely on large replay buffers to store and replay past experiences, a crucial feature for tackling challenging benchmark tasks. To adapt these batch-based methods to an incremental setting, we set the minibatch and replay buffer size to 1, allowing them to process each experience as it is encountered. We refer to these incremental variants as _SAC-1_ and _TD3-1_, respectively. We use off-the-shelf implementations of TD3 and SAC provided by CleanRL (Huang et al., 2022). The choice of hyper-parameters and full learning curves can be found in the Appendix F.

In Figure 3, we present the learning performance of AVG in comparison to IAC, SAC-1, and TD3-1. For reference, we also include the final performance of SAC with large replay buffers and default parameters, trained for \(1M\) timesteps, indicated by the gray dashed line (referred to as _SAC_). Notably, AVG is the only incremental algorithm that learns effectively, achieving performance comparable to SAC in Gymnasium  environments and surpassing it in the Dog benchmarks from DeepMind Control Suite . Nauman et al.  suggests that non-default regularization, such as layer normalization is essential for SAC to perform well in the Dog domain.

To optimize the hyperparameters for each method--AVG, IAC, SAC-1, and TD3-1, we conducted a random search, which is more efficient for high-dimensional search spaces than grid search . We evaluated 300 different hyperparameter configurations, each trained with 10 random seeds for \(2M\) timesteps on five challenging continuous control environments: _Ant-vd, Hopper-v4, HalfCheetah-v4, Humanoid-v4_ and _Walker2d-vd_. Each configuration was ranked based on its average undiscounted return per run, with the top-performing configuration selected for each environment. Using the best configuration, we then conducted longer training runs of 10 million timesteps with 30 random seeds.

Sparse reward environments can present additional challenges, often increasing both the difficulty and the time required for learning . Hence, we also evaluate our algorithms on sparse reward environments from the DeepMind Control Suite. We use one unique hyper-parameter configuration per algorithm across four environments: _finger_spin, dog_stand, dog_walk, dog_trot_ (see Fig. 3). Further details are provided in Appendix F.4.

**Learning From Pixels** We use the visual reacher task to ensure that AVG can be used with visual RL. In this task, the agent uses vision and proprioception to reach a goal. As shown in Fig. 4, AVG consistently outperforms IAC, which exhibits high variance and struggles to learn. Task details are provided in Appendix B.3.

Figure 4: AVG and IAC on the Visual Reacher task

Figure 3: AVG on Gymnasium and DeepMind Control Suite tasks. Each solid learning curve is an average of 30 independent runs. The shaded regions represent a 95% confidence interval of the bootstrap distribution. Note that _SAC_ refers to SAC with a replay buffer size of \(1M\). The corresponding dashed line represents the mean performance over the final 10K steps of training.

Stabilizing Incremental Policy Gradient Methods

In this section, we first highlight some issues with incremental policy gradient methods, which arise from the large and noisy gradients inherent to the setting. We perform a comprehensive ablation study to assess the effects of observation normalization, penultimate normalization, and TD error scaling--individually and in combination--on the performance of AVG. Addtionally, we demonstrate how other incremental methods, such as IAC and SAC-1, may also benefit from normalization and scaling.

### Instability Without Normalization

Deep RL can suffer from instability, often manifesting as high variance (Bjorck et al., 2022), reduced expressivity of neural networks over time (Nikishin et al., 2022; Sokar et al., 2023), or even a gradual drop in performance (Dohare et al., 2023; Elsayed and Mahmood, 2024; Elsayed et al., 2024), primarily due to the non-stationarity of data streams. Recently, Lyle et al. (2024) identified another common challenge that may induce difficulty in learning: the large regression target scale. For instance, in the Humanoid-v4 task, bootstrapped targets can range from \(-20\) to \(8000\) during training. Consequently, the critic faces the difficult task of accurately representing values that fluctuate widely across different stages of training. This can lead to excessively large TD errors, destabilizing the learning process.

Figure 5 illustrates a failure condition that can arise due to large regression target scale, high variance, and reduced expressivity -- challenges that are particularly problematic for incremental methods. Here, we compare a successful SAC training run to a failed AVG run without normalization or scaling techniques (termed \(AVG^{-}\)). While batch RL methods like SAC manage large, noisy gradients by smoothing them out through batch updates and improving stability with target Q-networks, incremental methods like AVG are more susceptible to numerically unstable updates, which can lead to failure or divergence in learning. AVG\({}^{-}\) exemplifies this issue by demonstrating excessively large gradient norms, particularly in the critic network, resulting in erratic gradients that hinder learning.

Building on these insights, we _hypothesize_ that stable learning in AVG can be achieved by balancing update magnitudes across time steps and episodes, reducing the influence of outlier experiences. This can be partly accomplished by centering and scaling the inputs, normalizing the hidden unit activations, and scaling the TD errors. Andrychowicz et al. (2021) show that appropriately scaling the observations can help improve performance, likely since it helps improve learning dynamics (Sutton, 1988; Schraudolph, 2002; LeCun et al., 2002). Scaling both the targets (e.g., by scaling the rewards, Engstrom et al., 2019) and the observations (e.g., normalization, Andrychowicz et al., 2021) is a well-established strategy that has shown success and is incorporated into widely used algorithms such as PPO (Schulman et al., 2017), helping improve its performance and stability (Rao et al., 2020; Huang et al., 2022).

### Disentangling the Effects of Normalization and Scaling

A combination of three techniques consistently achieves good performance for AVG: 1) TD error scaling (Schaul et al., 2021) to resolve the issue of large bootstrapped target scale (termed _scaled_td_, 2) observation normalization to maintain good learning dynamics (termed _norm_obs_, and 3) penultimate

Figure 5: The gradient norm of the critic and actor networks for AVG and SAC, along with their average episodic returns. \(AVG^{-}\) denotes AVG without any normalization or scaling applied. The solid lines represent the average, whereas the light lines represent the values for the individual runs. Note that the y-axis in the plots for actor and critic gradient norms is displayed on a logarithmic scale.

normalization to reduce instability and improve plasticity (termed _pnorm_, Bjorck et al. 2022), similar to layer normalization (Lyle et al. 2023). We selected Welford's online algorithm for normalizing observations due to its unbiased nature and its ability to maintain statistics across the entire data stream. In preliminary experiments, weighted methods that favored more recent samples did not perform well. Schaul et al. (2021) illustrate the risks associated with clipping or normalizing rewards, which led us to adopt their straightforward approach of scaling the temporal difference error with a multiplicative factor. Additionally, we favored pnorm over layer normalization since it performed better empirically in our experiments (see Fig. 13, App. B.2). It is worth noting that alternative normalization techniques could potentially achieve similar, if not superior, outcomes. Our focus here is to emphasize the importance of normalization and scaling issues and propose easy-to-use solutions.

We conduct an ablation study to evaluate the impact of the three techniques--norm_obs, pnorm and scaled_td--on the performance of AVG. We assess these techniques both individually and in combination, resulting in a total of 8 variants. The learning curves for the best seed obtained via our random search procedure (detailed in App. F.4) for each variant are shown in Fig. 6. The combination of all three techniques achieves the best overall performance.

Figure 6: Ablation study of normalization and scaling techniques used with AVG. We plot the learning curves of the best hyperparameter configurations for each task variant. Each solid learning curve is an average of 30 independent runs. The shaded regions represent a 95% confidence interval.

Figure 7: Impact of normalization and scaling on IAC, SAC-1 and TD3-1. Suffix “+” denotes each algorithm plus normalization and scaling.

In Fig. 7, we assess the impact of our proposed normalization and scaling techniques on IAC, SAC-1 and TD3-1. While IAC\({}^{+}\) performs in a mostly comparable manner to AVG, SAC-1\({}^{+}\) shows inconsistent performance, performing well in only two tasks but failing or even diverging in environments such as Hopper-v4 and Walker2d-v4. TD3-1\({}^{+}\) fails to learn in all environments.

### AVG with Target Q-Networks

Target networks are commonly used in off-policy batch methods to stabilize learning (Mnih et al., 2015). By using a separate network that is updated less frequently, target networks introduce a delay in the propagation of value estimates. This delay can be advantageous in batch methods with large replay buffers, as it helps maintain a more stable target (Lillicrap et al., 2015; Fujimoto et al., 2018). However, this delayed update can slow down learning in online RL (Kim et al., 2019).

In Figure 8, we evaluate the impact of using target Q-networks with AVG. Similar to SAC, we use Polyak averaging to update the target Q-network: \(_{}=(1-)_{}+\). We run an experiment varying \(\) between \(\), where \(=0\) denotes a fixed target network and \(=1\) implies the target network is identical to the current Q-network. We detail the pseudocode in Appendix C (see Alg. 4). The results show no benefit to using target networks, with only large values of \(\) performing comparably to AVG. Additionally, removing target networks reduces memory usage and simplifies the implementation of our algorithm.

## 6 AVG with Resource-Constrained Robot Learning

On-device learning enables mobile robots to continuously improve, adapt to new data, and handle unforeseen situations, which is crucial for tasks like autonomous navigation and object recognition. Commercial robots, such as the iRobot Roomba, often use onboard devices with limited memory, ranging from microcontrollers with kilobytes of memory to more powerful edge devices like the Jetson Nano 4GB. Leveraging these onboard edge devices can reduce the need for constant server communication, enhancing reliability in areas with limited connectivity. Storing large replay buffers on these devices is infeasible, necessitating computationally efficient, incremental algorithms.

To demonstrate the effectiveness of our proposed AVG algorithm for on-device incremental deep RL, we utilize the _UR-Reacher-2_ and _Create-Mover_ tasks, as developed by Mahmood et al. (2018). We use two robots: UR5 robotic arm and iRobot Create 2, a hobbyist version of Roomba. In the UR-Reacher-2 task, the agent aims to reach arbitrary target positions on a 2D plane (Fig. 8(a)). This

Figure 8: Impact of target Q network on AVG for different values of \(\), which represents the Polyak averaging coefficient. Here, \(=0\) corresponds to a fixed target network, and \(=1\) indicates that the current Q-network and the target network are identical, that is, not using a target network.

Figure 9: Robot Tasks

task is a real-world adaptation of the Mujoco Reacher task. In the Create-Mover task, the agent's goal is to move the robot forward as fast as possible within an enclosed arena. A representative image of the desired behavior is shown in Fig. 8(b). Each run requires slightly over two hours of robot experience time on both robots. In our learning curves (see Fig. 10), the dark lines represent the average over five runs for AVG, whereas the light lines represent the values for the individual runs. Details of the setup can be found in Appendix H.

The performance of AVG and resource-constrained SAC on UR-Reacher-2 is shown in Fig. 10 (top). We term the resource-constrained variants of SAC as _SAC-1_ and _SAC-100_, where the suffix indicates both the replay buffer capacity and mini-batch size used during training. Note that SAC-1 is incremental, but SAC-100 is still a batch method with limited memory resources. In these experiments, both SAC-100 and SAC-1 struggle significantly, failing to learn under the imposed memory limitations. In contrast, AVG demonstrates robust performance, efficiently utilizing limited memory to achieve fast and superior learning.

On the mobile robot task Create-Mover, the learning system is limited to onboard computation using a Jetson Nano 4GB. This introduces additional compute constraints in terms of action sampling time and learning update time. Our implementation requires \(~{}5ms\) to sample an action for both AVG and SAC-1. On the other hand, for learning updates, AVG requires only about \(37ms\) per update, compared to SAC-1's \(~{}67ms\). A batch update for SAC would exceed the action cycle time (\(150ms\)) for Create-Mover. Hence, we compare AVG only against SAC-1. The learning curves on the Create-Mover task in Fig. 10 (bottom) clearly show AVG's superior performance, while SAC-1 fails to learn any meaningful policy. This highlights AVG's efficiency and suitability for real-time learning in resource-constrained environments. Our work demonstrates for the first time effective real-robot learning with incremental deep reinforcement learning methods3.

## 7 Conclusion

This work revives incremental policy gradient methods for deep RL and offers significant computational advantages over standard batch methods for onboard robotic applications. We introduced a novel incremental algorithm called Action Value Gradient (AVG) and demonstrated its ability to consistently outperform other incremental and resource-constrained batch methods across a range of benchmark tasks. Crucially, we showed how normalization and scaling techniques enable AVG to achieve robust learning performance even on challenging high-dimensional control problems. Finally, we presented the first successful application of an incremental deep RL method learning control policies from scratch directly on physical robots--a robotic manipulator and a mobile robot. Overall, our proposed AVG algorithm opens up new possibilities for deploying deep RL with limited onboard computational resources of robots, enabling lifelong learning and adaptation in the real world.

**Limitations and Future Work** The main limitation of our approach is low sample efficiency compared to batch methods. Developing AVG with eligibility traces (Singh and Sutton 1996, van Hasselt et al. 2021) is a natural future direction to generalize our one-step AVG and possibly improve its sample efficiency. We also find that AVG can be sensitive to the choice of hyper-parameters. A valuable extension would be stabilizing the algorithm to perform well across environments using the same hyper-parameters. Our work is limited to continuous action space, but it can also be extended to discrete action spaces following Jang et al. (2017), which we leave to future work. Additionally, AVG omits discounting in the state distribution, which is common and further biases the update but can be addressed with the correction proposed by Che et al. (2023). Finally, we acknowledge a concurrent work by Elsayed et al. (2024), which stabilizes existing incremental methods like AC(\(\)) and Q(\(\)), except for reparameterization policy gradient methods. The robustness of AVG may potentially improve by replacing Adam with an optimizer for adaptive step sizes proposed in that work.

Figure 10: Learning curves on Real Robot Tasks

**Societal Impact** Our paper presents academic findings, but the proposed algorithm offers new opportunities for deploying deep reinforcement learning on robots with limited computational resources. This enables lifelong learning and real-world adaptation, advancing the development of more capable autonomous agents. While our contributions themselves do not cause negative societal effects, we advise the community to reflect on possible consequences as they expand upon our research.