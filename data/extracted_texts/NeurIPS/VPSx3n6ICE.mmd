# PrivCirNet: Efficient Private Inference via Block Circulant Transformation

Tianshi Xu

Peking University

tianshixu@stu.pku.edu.cn

&Lemeng Wu

Meta, Inc.

lmwu@meta

&Runsheng Wang

Peking University

r.wang@pku.edu.cn

&Meng Li

Peking University

meng.li@pku.edu.cn

Corresponding author: meng.li@pku.edu.cn

###### Abstract

Homomorphic encryption (HE)-based deep neural network (DNN) inference protects data and model privacy but suffers from significant computation overhead. We observe transforming the DNN weights into circulant matrices converts general matrix-vector multiplications into HE-friendly 1-dimensional convolutions, drastically reducing the HE computation cost. Hence, in this paper, we propose PrivCirNet, a protocol/network co-optimization framework based on block circulant transformation. At the protocol level, PrivCirNet customizes the HE encoding algorithm that is fully compatible with the block circulant transformation and reduces the computation latency in proportion to the block size. At the network level, we propose a latency-aware formulation to search for the layer-wise block size assignment based on second-order information. PrivCirNet also leverages layer fusion to further reduce the inference cost. We compare PrivCirNet with the state-of-the-art HE-based framework Bolt (IEEE S&P 2024) and HE-friendly pruning method SpENCNN (ICML 2023). For ResNet-18 and Vision Transformer (ViT) on Tiny ImageNet, PrivCirNet reduces latency by \(5.0\) and \(1.3\) with iso-accuracy over Bolt, respectively, and improves accuracy by \(4.1\%\) and \(12\%\) over SpENCNN, respectively. For MobileNetV2 on ImageNet, PrivCirNet achieves \(1.7\) lower latency and \(4.2\%\) better accuracy over Bolt and SpENCNN, respectively. Our code and checkpoints are available on Git Hub.

## 1 Introduction

The past few years have witnessed the rapid evolution of deep learning (DL) as well as its increasing adoption in sensitive and private applications, including face authentication , medical diagnosis , code auto-completion , etc. Privacy emerges as a major concern and leads to a growing demand for privacy-preserving DL . Homomorphic encryption (HE) is proposed as a promising technology for privacy protection and attracts a lot of attention . By encrypting the data into ciphertexts, HE allows computation over the encrypted data directly and produces encrypted results, without leaking any knowledge of the data itself .

To apply HE for private deep neural network (DNN) inference, there are two main approaches, including the end-to-end HE-based schemes  and the **hybrid HE/multi-party computation (MPC)-based schemes**. As shown in Figure 1 (a), the hybrid HE/MPC scheme leverages HE and MPC protocols to evaluate the linearand nonlinear layers separately, which usually demonstrates better accuracy due to its ability to realize accurate activation functions . In contrast, the end-to-end scheme relies on polynomial approximation or TFHE schemes for activation functions, which either suffer from low accuracy or low computation efficiency [25; 11]. Hence, **we focus on the hybrid scheme in our paper.**

While formal privacy protection can be achieved, HE-based DNN inference suffers from high computation cost and orders of magnitude latency overhead [7; 10]. Previous works have proposed algorithm-level optimizations on HE encoding and DNN architectures. HE encoding translates high-dimensional tensor operations of DNNs into 1-dimensional polynomial operations of HE and directly impacts the computation efficiency. For example, Cheetah  and Falcon  propose efficient encoding algorithms for convolutions while Iron  and BubbleBee  optimize for general matrix multiplications (GEMMs). Neujans  and Bolt  further introduce the baby-step giant-step (BSGS) algorithm to reduce the number of HE rotations and achieve state-of-the-art (SOTA) performance. While significant speedup has been achieved, the overall latency of MobileNetV2  and Vision Transformer (ViT)  still exceeds 60s and 170s with Bolt, respectively, as shown in Figure 1 (b) and (c). Meanwhile, linear layers account for more than 75% of total latency due to HE multiplications and rotations, thus, becoming the main optimization target of PrivCirNet.

DNN model optimizations focus on developing HE-friendly architectures. [30; 31; 32; 33; 34; 35; 36] optimize the activation functions for communication and computation reduction, which is orthogonal to our work. [37; 38; 39] propose HE-friendly structured pruning to reduce both HE rotations and multiplications. However, as shown in Figure 1 (c), as these methods are not fully compatible with the SOTA protocols, their latency reduction remains limited, especially for HE rotations1.

To further reduce the computation cost of linear layers and bridge the latency gap, in this paper, we propose PrivCirNet. _Our key observation is that the circulant transformation of weight matrices enables to convert a general matrix-vector multiplication (GEMV) into a HE-friendly 1-dimensional convolution, simultaneously reducing the HE multiplications and rotations,_ as shown in Figure 1 (d). While directly transforming the whole weight matrix into a circulant matrix incurs high accuracy degradation, we propose block circulant transformation and answer the following two questions. First, existing HE encoding algorithms are not fully compatible with block circulant weight matrices, limiting the efficiency gain. How to co-design the encoding algorithm to fully unleash the potential is the first question. Meanwhile, as block circulant transformation introduces structure constraints to weight matrices and inevitably impacts the accuracy, how to determine the layer-wise block sizes for better accuracy/efficiency trade-off becomes the second question.

PrivCirNet features a novel encoding algorithm optimized for block circulant weight matrices, dubbed CirEncode, that reduces the HE computation in proportion to \(block\)\(size\). PrivCirNet also co-design a latency-aware optimization formulation for layer-wise block size assignment based on second-order information. PrivCirNet further leverages layer fusion to reduce the inference cost. With extensive experiments across different DNN architectures (i.e., MobileNetV2, ResNet-18 and ViT) and datasets (i.e, CIFAR, Tiny ImageNet, and ImageNet), we demonstrate PrivCirNet reduces the latency of MobileNetV2, ResNet-18, and ViT by \(1.7\), \(5.0\) and \(1.3\) compared with Bolt , respectively. Compared with SOTA HE-friendly pruning method SpENCNN , PrivCirNet achieves \(4.2\)%, \(4.1\)%, and \(12\)% better accuracy on MobileNetV2, ResNet-18, and ViT, respectively, demonstrating great capability to accelerate private inference for both ConvNets and Transformers.

Figure 1: (a) Illustration of Hybrid HE/MPC-based private inference; (b) latency breakdown of linear layers and nonlinear layers based on Bolt’s protocol; (c) latency breakdown of linear layers of the original model and SpENCNN with 50% sparsity; (d) GEMV with a circulant weight matrix.

[MISSING_PAGE_EMPTY:3]

Attempts have been made to use the circulant matrix to accelerate inference in plaintext [44; 45] and ciphertext  domains. However, two unresolved problems remain in both domains: 1) how to initialize circulant matrices, and 2) determining block sizes for each layer. As a result, it is hard for [44; 45; 25] to be applied to more efficient networks, e.g., MobileNetV2, Transformers, etc. Additionally, in the ciphertext domain,  cannot fully leverage block circulant matrices, resulting in limited or even increased latency. In contrast, PrivCirNet maximizes the potential of block circulant matrices by customizing the HE encoding algorithm and proposing new initialization and block size assignment algorithms, achieving a superior accuracy-latency trade-off. We give a comprehensive comparison between PrivCirNet and [44; 45; 25] in Table 2. We leave a more detailed review of existing works in Appendix A.

## 3 PrivCirNet Framework

### Motivation

While the circulant transformation enables to convert a GEMV into a HE-friendly 1-dimensional convolution, directly transforming the whole weight into a circulant matrix introduces large accuracy degradation due to the high compression ratio. We propose to leverage block circulant transformation and to trade off accuracy with efficiency by controlling the block sizes. However, we observe the following challenges that need to be addressed.

**Challenge 1: existing encoding algorithms are incompatible with block circulant weight matrices.** The computation of a GEMM with a block circulant weight matrix can be naturally decomposed into two steps, i.e., a circulant GEMV within each block and a general GEMM across blocks. Within each block, a circulant GEMV can be converted to a 1-dimensional convolution and be computed with a single HE-Pmult through coefficient encoding. However, when processing the GEMM across blocks, coefficient encoding suffers from either high communication cost [10; 24] or extensive HE rotations . In contrast, while SIMD encoding can process the GEMM across blocks more efficiently , it still requires HE rotations to process the convolution within each block. As shown in

   &  &  &  \\  & Encoding & & & & \\ 
[31; 30; 35; 33] & ✗ & ✗ & ✗ & ReLU/GELU & ReLU/GELU Pruning \\  Cheetah  & Sparse & ✓ & ✗ & GEMM, Conv & / \\ Iron  & Sparse & ✓ & ✗ & GEMM & / \\ Neujeans  & Dense & ✓ & ✗ & Conv & / \\ Bolt  & Dense & ✓ & ✗ & GEMM & Token Pruning \\
[38; 39; 37] & Dense & ✗ & ✓ & GEMM, Conv & Weight Pruning \\  PrivCirNet (ours) & Dense & ✓ & ✓ & GEMM, Conv & Block Circulant Transformation \\  

Table 1: Comparison with existing private inference works.

   &  &  & Variable \\  & & block size \\  CiCN  & Convolution in plaintext & Forechments norm & ✓ & Uniform/Matmally set & / \\  Falcon  & End-to-end HE-based private inference & Forchusion norm & ✗ & Uniform & ✗ & Three-layer network \\  PrivCirNet (ours) & Hybrid HE-MPC private inference & Loss-aware & ✓ & Latency-aware block size assignment & ✓ & ConvNets, Transformers \\  

Table 2: Comparison between PrivCirNet and previous works that use circulant matrix.

Figure 2: Directly using coefficient or SIMD encoding to block circulant GEMMs (\((d_{1},d_{2},d_{3},b)=(256,192,576,2)\)) leads to limited efficiency improvement.

Figure 2, with existing encoding algorithms, block circulant transformation only introduces limited efficiency improvement. _Therefore, it is important to design the encoding algorithm to fully unleash the efficiency potential of the block circulant transformation._

**Challenge 2: accuracy and latency impact of block circulant transformation varies across layers.** We apply the block circulant weight transformation with different block sizes to different layers of a MobileNetV2 on Tiny ImageNet. As shown in Table 3, the accuracy and latency impact on the MobileNetV2 varies significantly. _Hence, to better explore the Pareto optimal of efficiency and accuracy, layer-wise block size assignment becomes important._

**PrivCirNet Overview.** In this paper, we introduce PrivCirNet, which features a joint optimization of the block circulant network and the private inference protocol. Figure 3 provides an overview of PrivCirNet. We first propose CirEncode for the GEMMs with block circulant weights in Section 3.2. Then, we develop a latency-aware optimization algorithm to determine the block sizes for each layer based on second-order information in Section 3.3. We also propose network-protocol co-fusion methods to further boost the inference efficiency in Section 3.4.

### CirEncode: nested encoding for block circulant GEMMs

**High-level idea.** Consider a GEMM \(Y=WX\), where \(Y^{d_{3} d_{1}},W^{d_{3} d_{2}},X ^{d_{2} d_{1}}\). \(W\) is a block circulant matrix with block size \(b\). Then, CirEncode encodes the GEMM following two steps: for each block with \(W^{b b}\) and \(X^{b d_{1}}\), we convert the computation into \(d_{1}\) parallel GEMVs and leverage the coefficient encoding to avoid HE-Rot as shown in Figure 4 (a); then, for across blocks, we regard it as a GEMM and leverage the SIMD encoding to further reduce the HE-Rot as shown in Figure 4 (b). Thereby, CirEncode combines the advantages of both encoding schemes.

**Encoding within a circulant block.** We elaborately design the encoding rule for a circulant GEMM. Formally, we define two encoding functions \(_{}:^{b b}_{n}\) and \(_{}:^{b d_{1}}_{n}\) as follows:

\[=_{}(W),\ \ \ [id_{1}]=W[i,0],  i[b],j[d_{1}]\] \[=_{}(X),\ \ \ [id_{1}+j]=X[i,j],  i[b],j[d_{1}]\]

where other coefficients of \(\) are set to 0. \(=\) directly gives the result of \(Y=WX\) as described in Theorem 1 and we defer the proof to Appendix I.1. 2

**Theorem 1**.: _Given a circulant matrix \(W^{b b}\) and an input matrix \(X^{b d_{1}}\), where \(bd_{1} n\), define two polynomials \(=_{}(W)\) and \(=_{}(X)\). Then, a GEMM \(Y=WX^{b d_{1}}\) can be evaluated by the polynomial multiplication \(=\), where \(Y[i,j]=[id_{1}+j], i[b],j[d_{1}]\)._

Compared with prior-art coefficient encoding algorithms for a GEMM, e.g., Iron , CirEncode features two key advantages: **1)** the encoding density, i.e., number of useful elements encoded per

Figure 4: An example of CirEncode for block circulant GEMM where \((d_{1},d_{2},d_{3},b)=(4,8,8,4)\).

Figure 3: Overview of PrivCirNet.

polynomial, is much higher, minimizing the communication cost; **2)** the input and output of a GEMM follow the same encoding rule described above, enabling layer fusion in Section 3.4.

**Encoding across circulant blocks.** Consider each circulant block as a unit, the computation across blocks can be regarded as a GEMM with dimension \((1,}{b},}{b})\). We apply the SIMD diagonal encoding to pack different circulant blocks in parallel and use DFT for each block to transform the coefficient encoding into the SIMD encoding format, as shown in Figure 4 (b). Similar to Lemma 1, the correctness is given by Theorem 2 and we defer the proof to Appendix I.2.

**Theorem 2**.: _Given \(M\) circulant weight matrices \(W_{0},,W_{M-1}^{b b}\) and input matrices \(X_{0},,X_{M-1}^{b d_{1}}\), define polynomials \(_{m}\) and \(_{m}\) with \(m[M]\) following the coefficient packing in Theorem 1. Then, \(Y_{m}=W_{m}X_{m}\) can be evaluated simultaneously through the polynomial multiplication in SIMD encoding:_

\[(_{0})||(_{M-1 })_{}\] \[= (_{0})||(_{M-1 })_{}(_{0})|| (_{M-1})_{}\,,\]

_where \(|\) represents concatenation of polynomial coefficients and \(Y_{m}[i,j]=_{m}[id_{1}+j], i[b],j[d_{1}],m[M]\)._

We further extend the BSGS algorithm  to CirEncode with details in Appendix B. We also design CirEncode for block circulant convolutions as described in Appendix C.

**Theoretical complexity analysis.** Table 4 shows the theoretical complexity comparison of CirEncode with prior-art encoding methods in the number of HE-Pmult, HE-Rot, and ciphertexts. CirEncode computes a \((d_{1},b,b)\) circulant GEMM with only \(O(bd_{1}/n)\) HE-Pmult and 0 HE-Rot. Therefore, compared to the SOTA scheme, i.e., Bolt and Neujeans, CirEncode reduces the number of HE-Pmult and HE-Rot by a factor of \(b\) and \(\), respectively, for both GEMM and convolution. A detailed proof of theoretical complexity is available in Appendix B.

### Latency-aware block size assignment with loss-aware initialization

Previous works use uniform block size [44; 25] or manually set the block sizes  for each layer, resulting in sub-optimal performance. We now propose a novel latency-aware block size assignment algorithm based on second-order information together with loss-aware initialization, which achieves a superior Pareto front of latency and accuracy.

**Loss-aware initialization for circulant matrices.** Previously, circulant matrices were initialized by minimizing the Frobenius norm between the non-circulant and circulant matrices [46; 45], i.e., \(\|W_{i}^{}-W_{i}\|_{2}^{2}\), where \(W_{i}^{}\) represents the weight matrix after the circulant transformation of layer \(i\). While this method minimizes the min square error (MSE) of the weight matrix, it overlooks that _the network accuracy has different sensitivity towards the MSE of different layers._ Therefore, we propose to directly assess the final loss instead of MSE for the transformation with Taylor expansion:

\[_{W_{i}^{}}()-_{W_{i}}()= ^{}()}{ W_{i}} W_{i}+  W_{i}^{}H W_{i}+(\| W_{ i}\|^{3}),\] (1)

  Framework &  &  \\   & \# HE-Pmult & \# HE-Rot & \# Celebters & \# HE-Pmult & \# HE-Rot & \# Celebents \\  CrypTRow2  & \(O(dd_{1}/n)\) & \(O(d_{1}(d_{2}+d_{3})/n+d_{2})\) & \(O(d_{1}(d_{2}+d_{3})/n)\) & \(O(HW(CN/n)\) & \(O(HW(C+k)/n+K)\) & \(O(HW(C+k)/n)\) \\  & 147456 & 3312 & 240 & 9216 & 208 & 16 \\  Cheetah  & \(O(dd_{1}/n)\) & \(O(dd_{1}/n)+(dd_{1}/n)(dd_{2})\) & \(O(HW(CN/n)\) & 0 & \(O(HW(CN/n+HW/n)|K)\) \\  & 147456 & 0 & \(O((d_{2}+d_{3})}{320})\) & 1408 & 0 & 134 \\  Iron  & \(O(dd_{1}d_{2}/n)\) & 0 & \(O(d_{2}d_{3}}/n)\) & \(O(HW(CN/n)\) & 0 & \(O()\) \\  & 147456 & 0 & 960 & 12672 & 0 & 257 \\  Bumblebee  & \(O(dd_{1}d_{2}/n)\) & \(O(d_{1}(d_{2}(n_{1}/2))\) & \(O(d_{1}(d_{2}+d_{3})/n)\) & \(O(dd_{1}(d_{2}+d_{3})/n)\) & \(O(HW(CN/n)\) & \(O(HW(CN/n)\) \\  & 147456 & 6144 & 240 & 1408 & 256 & 16 \\  Neojans+BSGS  & \(O(dd_{1}d_{2}/n)\) & \(O(d_{2}d_{3}}/n)\) & \(O((dd_{1}+d_{3})/n)\) & \(O(HW(CN/n)\) & \(O()\) & \(O(HW(C+k)/n)\) \\  & 147456 & 588 & 240 & 1024 & 48 & 16 \\  Bolt+BSGS  & \(O(dd_{1}d_{2}/n)\) & \(O(d_{2}d_{3}}/n)\) & \(O((dd_{1}+d_{3})/n)\) & \(O(HW(CN/n)\) & \(O()\) & \(O(HW(CN/n)\) \\  & 147456 & 528 & 240 & 11700 & 106 & 100 \\   &  \\   & \(O(dd_{1}d_{2}/n)\) & \(O(d_{2}d_{3}}/n)\) & \(O(d_{2}d_{3}}/n)\) & \(O(HW(CN/n))\) & \(O()\) & \(O(HW(C+K)/n)\) \\  & 18432 & 48 & 240 & 128 & 8 & 16 \\  

Table 4: Theoretical complexity comparison of CirEncode with prior works. The data of GEMM is measured with dimension \((d_{1},d_{2},d_{3})=(512,768,3072)\), and that of convolution is \((H,W,C,K,R)=(16,16,128,128,3)\). The polynomial degree \(n=8192\) and block size \(b=8\).

where \(\) is the task loss, \(\) is the training dataset, \(H\) is the Hessian matrix and \( W_{i}=W_{i}^{}-W_{i}\). The first term can be neglected as the model has already converged on the training dataset . The Hessian matrix can be approximated using diagonal Fisher information matrix . We then define the sensitivity of layer \(i\) as \(_{i}\):

\[_{i}= W_{i}^{}H W_{i} W_{i}^{} {diag}((()}{ W_{i}} )^{2}) W_{i}\] (2)

Hence, we propose initializing the circulant matrix by minimizing \(_{i}\) instead of the Frobenius norm, which can be solved analytically as \(W_{i}^{}=[W_{i}(( )}{ W_{i}})^{2}]_{diag}_{diag}\) is the expectation of each diagonal of a matrix. An example is provided in Appendix E.

**Latency-aware block size assignment.** Given an \(L\)-layer network, we denote the block size of each layer as \(\{b_{1},,b_{L}\}\), where \(b_{i}\{2^{0},,2^{k-1}\}\). The search space contains \(k^{L}\) possible architectures, which can be extremely large, e.g., \(2 10^{22}\) for \(k=5,L=32\), rendering exhaustive search impractical. Therefore, we propose to formulate the search problem as an integer linear programming (ILP) problem, aiming to minimize the overall network sensitivity under the latency constraint [49; 50; 51]:

\[\ \ _{\{b_{i}\}_{i=1}^{L}}\ \ \ _{i=1}^{L}_{i}^{b_{i}},\ \ \ \ \ \ \ _{i=1}^{L}_{i}^{b_{i}}\] (3)

Here, \(_{i}^{b_{i}}\) is the \(i\)-th layer's sensitivity with block size \(b_{i},_{i}^{b_{i}}\) is the associated latency in private inference. \(_{i}^{b_{i}}\) can be pre-computed given the dimension of the layer.

**Visualization analysis.** We visualize the layer-wise sensitivity and the searched structure of different initialization methods in Figure 5. As we can observe in Figure 5 (a), the previous method fails to tell the different sensitivity of block size 4, 8, and 16 for most of the layers. In contrast, our method, depicted in Figure 5 (b), better captures the effects of varying block sizes on task loss.

### Network-Protocol Co-Fusion

**Circulant ConvBN Fusion.** During the inference, convolution (\(\)) and batch normalization (\(\)) layers are usually fused for lower latency. However, naive fusion destroys the block circulant structure. Hence, we propose a fusion method for circulant \(\) and \(\). Consider the learnable scaling factor \(^{C}\) for a \(\) layer. We combine the elements of \(\) into groups of size \(b\) and set \(^{}^{C}\) such that \(^{}[i]=^{b-1}[i+j-(i b)]}{b}, i[C]\). We use the same strategy for the learnable bias, running mean and variance, which maintains the circulant structure after fusion.

**Inverted Residual (IR) Fusion Protocol.** In the hybrid HE/MPC-based DNN inference, the network is

Figure 5: Layer-wise sensitivity and block size visualization for ViT on CIFAR-100.

Figure 6: Network-Protocol Co-Fusion.

evaluated layer by layer. We identify the potential for layer fusion of consecutive linear layers in MobileNetV2 . Figure 6 (b) shows where we implement fusion, aiming to compute \((x_{res}+(x_{1}))\) all together. Thanks to the encoding consistency provided by CirEncode, we can fuse layers with equal block size. Details of the fusion algorithm are in Appendix F.

## 4 Experiments

### Experimental Setup

**Implementation.** PrivCirNet is built on top of the SEAL library  in C++. We use the OpenChee-tah  to evaluate Cheetah  and CrypTFlow2 . We also implement Falcon , Neujeans  and Bolt  protocols. Following [10; 53; 54], we simulate a LAN network setting via Linux Traffic Control, where the bandwidth is 384 MBps and the echo latency is 0.3ms. All the experiments are performed on a machine with 2.4 GHz Intel Xeon CPU. Following , we set \(n=8192\), security parameter \(=128\), plaintext bitwidth \(p=41\) and ciphertext bitwidth \(q=218\), which is also the default setting in SEAL library .

**Datasets and Models.** We evaluate PrivCirNet on MobileNetV2 , ResNet-18 , and ViT  across four datasets: CIFAR-10, CIFAR-100, Tiny ImageNet and ImageNet.3 Detailed model architectures and training settings can be found in Appendix G.

**Baselines.** We compare PrivCirNet with prior-art HE-based DNN inference frameworks, including CrypTFlow2 , Cheetah , Falcon , Neujeans  and Bolt . We also compare with SpENCNN  which is the SOTA HE-friendly pruning method.

### Micro-Benchmark on Single GEMM and Convolution

**Latency comparison.** In Figure 7, we benchmark PrivCirNet on both GEMMs and convolutions with different block sizes. The layer dimensions are chosen from MobileNetV2, ResNet-18, and ViT. It can be observed that PrivCirNet supports both GEMMs and convolutions efficiently. Compared with Bolt and Cheetah, PrivCirNet (b8), i.e., block size of 8, achieves \(5 7\) latency reduction. With PrivCirNet (b2), we can reduce latency by \(1.7\) on average.

**The number of HE-Pmult and HE-Rot comparison.** In Table 5, we show the number of HE-Rot and HE-Pmult comparisons with different protocols. The layer dimensions are chosen from MobileNetV2, ResNet-18, and ViT. It can be observed that: **1)** Compared with SOTA algorithms Bolt and Neujeans, PrivCirNet (b8) achieves on average \(7\) HE-Rot reduction and \(8.5\) HE-Pmult reduction. And PrivCirNet (b2) achieves on average \(2.1\) HE-Rot reduction and \(1.9\) HE-Pmult reduction which is consistent with the theoretical complexity. **2)** PrivCirNet supports both GEMM and convolution efficiently. On the contrary, Neujeans performs worse in GEMM while Bolt performs worse in convolution.

### End-to-End Inference Evaluation

In Figure 8 and Figure 9, we benchmark PrivCirNet at the full network scale and plot the Pareto front of accuracy and **latency of linear layers**. We make the following observation:

Figure 7: Latency comparison of different protocols for GEMMs and convolutions. PrivCirNet use circulant weight with block size \(b\).

[MISSING_PAGE_FAIL:9]

**Effectiveness of different optimizations in PrivCirNet.** We demonstrate the effectiveness of the proposed optimizations by adding them step by step on MobileNetV2 and Tiny ImageNet. As in Figure 10, we observe that: **1)** without CirEncode, circulant transformation harms the accuracy and cannot reduce latency due to incompatibility with existing encoding algorithms; **2)** latency-aware block size assignment significantly improves the accuracy and even outperforms the uncompressed model; **3)** the fusion methods reduce both the latency and communication with negligible accuracy loss.

**Additional Results.** We present extra experiments to show 1) latency breakdown, and 2) comparison on more networks in Appendix H.

## 5 Limitation and Future Work

PrivCirNet focuses on improving the HE computation efficiency, which accounts for 75% total latency and is the bottleneck in the hybrid HE/MPC scheme. We can also extend PrivCirNet with activation function optimization methods, e.g., ReLU pruning method SNL . As shown in Table 7, we prune \(50\%\) ReLUs in PrivCirNet (b2) without accuracy loss, achieving \(2\) latency reduction in non-linear layers. We regard a more in-depth study of joint linear/nonlinear layer optimization as our future work.

## 6 Conclusion

In this paper, we introduce PrivCirNet, a network/protocol co-optimization framework to enhance the efficiency of HE-based DNN inference. PrivCirNet leverages block circulant transformation to reduce the HE computation. PrivCirNet features a novel encoding method, CirEncode, and a latency-aware block size assignment algorithm. PrivCirNet significantly improves the network-level inference efficiency while maintaining a high accuracy. PrivCirNet achieves a latency reduction of \(1.3 5.0\) compared to Bolt in MobileNetV2, ResNet-18 and ViT. Moreover, when compared with SpENCNN, PrivCirNet attains up to \(12\%\) higher accuracy, demonstrating a high potential to accelerate private inference across both ConvNets and Transformers.

## 7 Acknowledgement

This work was partly supported by Beijing Municipal Science and Technology Program (No. Z241100004224015), Ant Group, and the 111 Project (B18001).

   &  Latency \\ Limitation \\  } &  \\   & &  &  \\   & & CIFAR-10 & CIFAR-100 & Tiny ImageNet & CIFAR-10 & CIFAR-100 & Tiny ImageNet \\  Uncompressed & 100\% & 94.74 & 78.70 & 66.14 & 93.54 & 74.77 & 62.65 \\   & 50\% & 94.81 (\(\)2.23) & 77.98 (\(\)0.60) & 65.26 (\(\)1.10) & 93.38 (\(\)0.06) & 74.41 (\(\)0.30) & **61.87** (\(\)0.08) \\   & 25\% & 93.97 (\(\)0.33) & 76.30 (\(\)1.41) & 62.76 (\(\)2.07) & 92.57 (\(\)0.33) & 72.00 (\(\)0.76) & 58.11 (\(\)0.85) \\   & 12.5\% & 92.71 (\(\)0.55) & 73.89 (\(\)0.96) & 60.34 (\(\)1.50) & 90.98 (\(\)0.46) & 67.51 (\(\)2.22) & 51.90 (\(\)2.16) \\   & 50\% & 94.71 (\(\)0.35) & 78.28 (\(\)0.30) & 65.98 (\(\)0.38) & 93.40 (\(\)0.04) & 74.58 (\(\)0.13) & 61.33 (\(\)0.46) \\   & 25\% & 94.23 (\(\)0.07) & 76.38 (\(\)1.33) & 63.76 (\(\)1.07) & 92.40 (\(\)0.50) & 72.07 (\(\)0.69) & 58.00 (\(\)0.96) \\   & 12.5\% & 92.65 (\(\)0.61) & 43.22 (\(\)0.53) & 61.14 (\(\)0.70) & 90.32 (\(\)1.42) & 68.02 (\(\)1.71) & 51.92 (\(\)2.14) \\   & 50\% & **95.04** & **78.58** & **66.36** & **93.44** & **74.71** & 61.79 \\   & 25\% & **94.30** & **77.71** & **64.83** & **92.90** & **72.76** & **58.96** \\    & 12.5\% & **93.26** & **74.85** & **61.84** & **91.44** & **69.73** & **54.06** \\  

Table 6: Accuracy comparison of different block size assignment methods. Latency limitation represents the proportion of latency relative to the original uncompressed model.

  Method ( CIFAR-100) & Top-1 Acc. & Nonlinear latency & Red latency \\  Original ResNet-18 & 76.52 & 12.64 s & 73.72 s \\ PrvCirNet (b2) & 76.93 & 12.64 s & 43.76 s \\  SNL-50\% ReLU & 76.72 & 63.2 s & 39.44 s \\  SNL-40\% ReLU & 76.27 & 5.06 s & 38.18 s \\  

Table 7: Extend PrivCirNet with nonlinear layer optimization method SNL.

[MISSING_PAGE_FAIL:11]

*  Jongmin Kim, Gwangho Lee, Sangpyo Kim, Gina Sohn, Minsoo Rhu, John Kim, and Jung Ho Ahn. Ark: Fully homomorphic encryption accelerator with runtime data generation and inter-operation key reuse. In _2022 55th IEEE/ACM International Symposium on Microarchitecture (MICRO)_, pages 1237-1254. IEEE, 2022.
*  George Onoufriou, Paul Mayfield, and Georgios Leontidis. Fully homomorphically encrypted deep learning as a service. _Machine Learning and Knowledge Extraction_, 3(4):819-834, 2021.
*  Jian Liu, Mika Juuti, Yao Lu, and N. Asokan. Oblivious neural network predictions via minionnn transformations. In _Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security_, Oct 2017.
*  Pratyush Mishra, Ryan Lehmkuhl, Akshayaram Srinivasan, Wenting Zheng, and RalucaAda Popa. Delphi: A cryptographic inference service for neural networks, Jan 2020.
*  Karthik Garimella, Zahra Ghodsi, NandanKumar Jha, Siddharth Garg, and Brandon Reagen. Characterizing and optimizing end-to-end systems for private inference, Jul 2022.
*  Wen-jie Lu, Zhicong Huang, Zhen Gu, Jingyu Li, Jian Liu, Kui Ren, Cheng Hong, Tao Wei, and WenGuang Chen. Bumblebee: Secure two-party inference framework for large transformers. _Cryptology ePrint Archive_, 2023.
*  Donghwan Kim, Jaiyoung Park, Jongmin Kim, Sangpyo Kim, and Jung Ho Ahn. Hyphen: A hybrid packing method and optimizations for homomorphic encryption-based neural networks. _arXiv preprint arXiv:2302.02407_, 2023.
*  Meng Hao, Hongwei Li, Hanxiao Chen, Pengzhi Xing, Guowen Xu, and Tianwei Zhang. Iron: Private inference on transformers. In _Advances in Neural Information Processing Systems_, 2022.
*  Qian Lou, Wen-jie Lu, Cheng Hong, and Lei Jiang. Falcon: Fast spectral inference on encrypted data. _Advances in Neural Information Processing Systems_, 33:2364-2374, 2020.
*  Tianshi Xu, Meng Li, Runsheng Wang, and Ru Huang. Falcon: Accelerating homomorphically encrypted convolutions for efficient private mobile network inference. _arXiv preprint arXiv:2308.13189_, 2023.
*  Jae Hyung Ju, Jaiyoung Park, Jongmin Kim, Donghwan Kim, and Jung Ho Ahn. Neujeans: Private neural network inference with joint optimization of convolution and bootstrapping. _The ACM Conference on Computer and Communications Security (CCS)_, 2024.
*  Mark Sandler, Andrew Howard, Menglong Zhu, Andrey Zhmoginov, and Liang-Chieh Chen. Mobilenetv2: Inverted residuals and linear bottlenecks. In _Proceedings of the IEEE conference on computer vision and pattern recognition_, pages 4510-4520, 2018.
*  Alexey Dosovitskiy, Lucas Beyer, Alexander Kolesnikov, Dirk Weissenborn, Xiaohua Zhai, Thomas Unterthiner, Mostafa Dehghani, Matthias Minderer, Georg Heigold, Sylvain Gelly, et al. An image is worth 16x16 words: Transformers for image recognition at scale. _arXiv preprint arXiv:2010.11929_, 2020.
*  Minsu Cho, Ameya Joshi, Brandon Reagen, Siddharth Garg, and Chinmay Hegde. Selective network linearization for efficient private inference. In _International Conference on Machine Learning_, pages 3947-3961. PMLR, 2022.
*  Nandan Kumar Jha, Zahra Ghodsi, Siddharth Garg, and Brandon Reagen. Deepreduce: Relu reduction for fast private inference. In _International Conference on Machine Learning_, pages 4839-4849. PMLR, 2021.
*  Souvik Kundu, Shunlin Lu, Yuke Zhang, Jacqueline Liu, and Peter A Beerel. Learning to linearize deep neural networks for secure and efficient private inference. _arXiv preprint arXiv:2301.09254_, 2023.
*  Minsu Cho, Zahra Ghodsi, Brandon Reagen, Siddharth Garg, and Chinmay Hegde. Sphynx: A deep neural network design for private inference. _IEEE Security & Privacy_, 20(5):22-34, 2022.

*  Hongwu Peng, Shaoyi Huang, Tong Zhou, Yukui Luo, Chenghong Wang, Zigeng Wang, Jiahui Zhao, Xi Xie, Ang Li, Tony Geng, et al. Autorep: Automatic relu replacement for fast private network inference. In _Proceedings of the IEEE/CVF International Conference on Computer Vision_, pages 5178-5188, 2023.
*  Wenxuan Zeng, Meng Li, Wenjie Xiong, Wenjie Lu, Jin Tan, Runsheng Wang, and Ru Huang. Mpcvit: Searching for mpc-friendly vision transformer with heterogeneous attention. _arXiv preprint arXiv:2211.13955_, 2022.
*  Souvik Kundu, Yuke Zhang, Dake Chen, and Peter A Beerel. Making models shallow again: Jointly learning to reduce non-linearity and depth for latency-efficient private inference. In _Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition_, pages 4685-4689, 2023.
*  Ran Ran, Xinwei Luo, Wei Wang, Tao Liu, Gang Quan, Xiaolin Xu, Caiwen Ding, and Wujie Wen. Spencnn: orchestrating encoding and sparsity for fast homomorphically encrypted neural network inference. In _International Conference on Machine Learning_, pages 28718-28728. PMLR, 2023.
*  Yifei Cai, Qiao Zhang, Rui Ning, Chunsheng Xin, and Hongyi Wu. Hunter: He-friendly structured pruning for efficient privacy-preserving deep learning. In _Proceedings of the 2022 ACM on Asia Conference on Computer and Communications Security_, pages 931-945, 2022.
*  Ehud Aharoni, Moran Baruch, Pradip Bose, Alper Buyuktosunoglu, Nir Drucker, Subhankar Pal, Tomer Pelleg, Kanthi Sarpatwar, Hayim Shaul, Omri Soceanu, et al. He-pex: Efficient machine learning under homomorphic encryption using pruning, permutation and expansion. _arXiv preprint arXiv:2207.03384_, 2022.
*  Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. _Cryptology ePrint Archive_, 2012.
*  Ran Ran, Nuo Xu, Tao Liu, Wei Wang, Gang Quan, and Wujie Wen. Penguin: Parallel-packed homomorphic encryption for fast graph convolutional network inference. _Advances in Neural Information Processing Systems_, 36, 2024.
*  Qiao Zhang, Chunsheng Xin, and Hongyi Wu. Gala: Greedy computation for linear algebra in privacy-preserved neural networks. _arXiv preprint arXiv:2105.01827_, 2021.
*  Oded Goldreich. Secure multi-party computation. _Manuscript. Preliminary version_, 78(110):1-108, 1998.
*  Caiwen Ding, Siyu Liao, Yanzhi Wang, Zhe Li, Ning Liu, Youwei Zhuo, Chao Wang, Xuehai Qian, Yu Bai, Geng Yuan, et al. Circnn: accelerating and compressing deep neural networks using block-circulant weight matrices. In _Proceedings of the 50th Annual IEEE/ACM International Symposium on Microarchitecture_, pages 395-408, 2017.
*  Siyu Liao and Bo Yuan. Circconv: A structured convolution with low complexity. In _Proceedings of the AAAI Conference on Artificial Intelligence_, volume 33, pages 4287-4294, 2019.
*  Moody T. Chu and Robert J. Plemmons. Real-valued, low rank, circulant approximation. _SIAM Journal on Matrix Analysis and Applications_, page 645-659, Jan 2003.
*  Yuhang Li, Ruihao Gong, Xu Tan, Yang Yang, Peng Hu, Qi Zhang, Fengwei Yu, Wei Wang, and Shi Gu. Brecq: Pushing the limit of post-training quantization by block reconstruction. _arXiv preprint arXiv:2102.05426_, 2021.
*  Genevieve B Orr and Klaus-Robert Muller. _Neural networks: tricks of the trade_. Springer, 1998.
*  Zhen Dong, Zhewei Yao, Amir Gholami, Michael W Mahoney, and Kurt Keutzer. Hawq: Hessian aware quantization of neural networks with mixed-precision. In _Proceedings of the IEEE/CVF International Conference on Computer Vision_, pages 293-302, 2019.

*  Zhen Dong, Zhewei Yao, Daiyaan Arfeen, Amir Gholami, Michael W Mahoney, and Kurt Keutzer. Hawq-v2: Hessian aware trace-weighted quantization of neural networks. _Advances in neural information processing systems_, 33:18518-18529, 2020.
*  Zhewei Yao, Zhen Dong, Zhangcheng Zheng, Amir Gholami, Jiali Yu, Eric Tan, Leyuan Wang, Qijing Huang, Yida Wang, Michael Mahoney, et al. Hawq-v3: Dyadic neural network quantization. In _International Conference on Machine Learning_, pages 11875-11886. PMLR, 2021.
*  Microsoft SEAL (release 3.6). https://github.com/Microsoft/SEAL, November 2020. Microsoft Research, Redmond, WA.
*  Liyan Shen, Ye Dong, Binxing Fang, Jinqiao Shi, Xuebin Wang, Shengli Pan, and Ruisheng Shi. Abnn 2. In _Proceedings of the 59th ACM/IEEE Design Automation Conference_, Aug 2022.
*  Payman Mohassel and Yupeng Zhang. Secureml: A system for scalable privacy-preserving machine learning. In _2017 IEEE symposium on security and privacy (SP)_, pages 19-38. IEEE, 2017.
*  Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In _Proceedings of the IEEE conference on computer vision and pattern recognition_, pages 770-778, 2016.
*  Wenxuan Zeng, Meng Li, Haichuan Yang, Wen-jie Lu, Runsheng Wang, and Ru Huang. Copriv: Network/protocol co-optimization for communication-efficient private inference. _arXiv preprint arXiv:2311.01737_, 2023.
*  Dacheng Li, Rulin Shao, Hongyi Wang, Han Guo, Eric P Xing, and Hao Zhang. Mpcformer: fast, performant and private transformer inference with mpc. _arXiv preprint arXiv:2211.01452_, 2022.
*  Ali Hassani, Steven Walton, Nikhil Shah, Abulikemu Abuduweili, Jiachen Li, and Humphrey Shi. Escaping the big data paradigm with compact transformers. _arXiv preprint arXiv:2104.05704_, 2021.
*  Ilija Radosavovic, Raj Prateek Kosaraju, Ross Girshick, Kaiming He, and Piotr Dollar. Designing network design spaces. In _Proceedings of the IEEE/CVF conference on computer vision and pattern recognition_, pages 10428-10436, 2020.
*  Zhuang Liu, Hanzi Mao, Chao-Yuan Wu, Christoph Feichtenhofer, Trevor Darrell, and Saining Xie. A convnet for the 2020s. In _Proceedings of the IEEE/CVF conference on computer vision and pattern recognition_, pages 11976-11986, 2022.
*  Nandan Kumar Jha and Brandon Reagen. Deepreshape: Redesigning neural networks for efficient private inference. _arXiv preprint arXiv:2304.10593_, 2023.

Related Works

To improve the efficiency of HE-based DNN inference, existing works mainly focus on optimizing the HE encoding algorithm  and the DNN architectures . HE encoding optimizations focus on improving the encoding density (i.e., useful elements per polynomial) to reduce communication  and HE computations . For example, Cheetah  proposes an efficient rotation free encoding algorithm for convolutions and Falcon  further improve the communication efficiency for group-wise convolution. Iron  and BubbleBee  optimize the encoding algorithm for general matrix multiplications (GEMMs). Neujeans  and Bolt  further introduce the baby-step giant-step (BSGS) algorithm to reduce the number of HE rotations.

DNN architecture optimizations focus on developing HE-friendly architectures to improve inference efficiency including HE-friendly activation approximation or pruning , weight pruning , etc.  optimize the ReLU functions through pruning and approximation for communication and computation reduction.  propose to prune and approximate GeLU functions for efficient private transformer inference.  propose HE-friendly structured pruning to reduce both HE rotations and multiplications.

## Appendix B Baby-step Giant-step (BSGS) Algorithm for CirEncode

The BSGS algorithm is used for GEMV and GEMM to reduce the number of HE rotations . We visualize the high-level idea of the BSGS algorithm in Figure 11. Instead of rotating each input polynomial once, the BSGS algorithm divides the rotations into two steps: baby-step and giant-step which can be formulated as

\[_{j=1}^{G}(_{i=1}^{B}_{(j-1)B+i}^{}(<<(i-1)))<<(j-1)B\] (4)

Figure 11: An example of GEMV using BSGS algorithm.

Here, \(G,B\) are the number of giant-step and baby-step, respectively. The total number of rotations is reduced to \(B+G-2\). In GEMM with dimension \((d_{1},d_{2},d_{3})\), tiling is needed to split matrices into smaller blocks whose maximum size is HE polynomial degree \(n\). Moreover, when extend BSGS to CirEncode, the dimension of GEMM becomes \((d_{1},}{b},}{b})\) and the polynomial degree becomes \(\). We do not encode the \(d_{1}\) dimension into each circulant block, instead, we treat the computation cross blocks as a GEMM and use the BSGS algorithm to determine the tiling size of the \(d_{1}\) dimension. Therefore, how to tile and choose \(B,G\) is crucial to minimize the number of rotations. We propose to formulate this optimization problem as a nonlinear programming problem as

\[ =d_{2}}{n}(B-1)+d_{3}}{n}(G-1)\] (5) s.t. \[B*G=d\] \[d_{1}^{}d=\] \[d_{1}^{} d_{1}\] \[d(}{b},}{b})\]

We give an illustration of our BSGS algorithm in Figure 12. The tile sizes of input and weight are \((d_{1}^{},d)\) and \((d,d)\), respectively. The constraints in Equation 5 are derived from a tile containing at most \(n\) elements and a tile size cannot exceed the size of the matrix. This problem has a small solution space. With \(B,G(}{b},}{b})\), The solution space is at most \((}{b},}{b})^{2}\), allowing us to directly solve it using a search algorithm with the complexity of \(O(((}{b},}{b})^{2}))\). Our experiments show that the search algorithm can find the optimal solution within milliseconds for all cases.

**Complexity analysis of # Rot.** We proof in Equation 6 that the complexity of #Rot with our BSGS algorithm is \(O(d_{2}d_{3}/(nb)})\).

\[ =d_{2}}{n}(B-1)+d_{3}}{n}(G-1)\] (6) \[ 2}{n}d_{3}(B-1)(G-1)}\] \[\ d_{2}(B-1)=d_{3}(G-1)\] \[O()=O(}{n}d_{3}d})\] \[=O(}{n}d_{3}n/bd_{1}})\] \[=O(d_{2}d_{3}/(nb)})\]

Figure 12: Illustration of our BSGS algorithm for block circulant GEMM with tiling.

Here we omit the last constraint in Equation 5 for simplicity.

**Complexity analysis of # Mul.** The complexity of # Mul is given by Equation 7.

\[O()=O(}{b}}{b}}{n})\] (7) \[=O(d_{1}d_{2}d_{3}/(nb))\]

**Boundary cases.** When \(d_{1}(}{b},}{b})<\), the tile size of input will be \(d_{1}(}{b},}{b})\) although it's not often the case. In addition, the second constraint in Equation 5 should actually be \([d^{}_{1}b]_{2^{k}}\)\(d=n\). \([]_{2^{k}}\) means the next nearest power of 2. This is because NTT requires the input size to be a power of 2. Consequently, we consider all these boundary conditions in the search algorithm in practice.

## Appendix C CirEncode for Convolutions

In this section, we extend CirEncode to convolutions. We denote the input, weight and output of a block circulant convolution operation as \(X^{C H W},W^{K C R R},Y=W\)\(^{K(H-R+1)(W-R+1)}\). Here \(\) represents the convolution operation. We assume stride=1 for simplicity. \(W\) is a block circulant matrix with respect to the first two dimensions with block size \(b\).

**Encoding within a circulant block.** For each circulant block, we define two encoding functions \(^{}_{}:^{b H W} _{n}\) and \(^{}_{}:^{b b R R} _{n}\) as follows:

\[=^{}_{}(X)  [iHW+jW+k]=X[i,j,k],i[b],j[H],k[W]\] \[=^{}_{}(W)  [iHW+(W+1)(R-1)-jW-k]=W[i,0,j,k],i[b],j[R],k[R]\]

where other coefficients of \(\) are set to 0. Multiplication of polynomials \(=\) directly gives the result of \(Y=W\)\(X\) as described in Theorem 3. We defer the proof to Appendix I.3.

**Theorem 3**.: _Assuming \(HWb n\), given a circulant convolution kernel \(W^{b b R R}\) and input tensor \(X^{b H W}\). Define two polynomials \(=^{}_{}(W)\) and \(=^{}_{}(X)\). The polynomial multiplication result \(=\) directly maps to the result of \(Y=W\)\(X\)\(^{b(H-R+1)(W-R+1)}\) where \(Y[i,j,k]=[iHW+(W+1)(R-1)+jW+k]\)._

We show a toy example of CirEncode for circulant convolution in Figure 13.

**Encoding across circulant blocks.** Consider each circulant block with input dimension \((b,H,W)\) and weight dimension \((b,b,R,R)\) as a basic unit. The computation across circulant blocks can be regarded as a GEMV with dimension \((1,,)\). Then we leverage SIMD diagonal encoding which is the same as the block circulant GEMM.

**BSGS algorithm for block circulant convolution.** Similar to block circulant matrix multiplication, the BSGS algorithm for block circulant convolution can be formulated as an non-linear programming

Figure 13: A toy example of CirEncode within a circulant convolution where \((H,W,b,R)=(4,4,2,3)\).

problem as

\[ \#=(B-1)+(G-1)\] s.t. \[B*G=d\] (8) \[HWbd=n\] \[d(,)\]

We give an illustration in Figure 14 where the tile sizes of input and weight are \((1,d)\) and \((d,d)\), respectively. This problem has a small solution space. With \(B,G(,)\), The solution space is at most \(((,))^{2}\), allowing us to directly solve it using a search algorithm with a complexity of \(O(((,))^{2})\). Our experiments show that the search algorithm can find the optimal solution within milliseconds for all cases.

**Complexity analysis of # Rot.** We proof in Equation 9 that the complexity of # Rot in block circulant convolution with our BSGS algorithm is \(O()\).

\[\# =(B-1)+(G-1)\] (9) \[ 2\] \[ C(B-1)=K(G-1)\] \[O(\#)=O()\] \[=O(})\] \[=O(})\]

Here we omit the last constraint in Equation 8 for simplicity.

**Complexity analysis of # Mul.** The complexity of # Mul is given by Equation 10.

\[O(\#)=O()\] (10) \[=O(HWCK/(nb))\]

## Appendix D Why does structured pruning fail in BSGS algorithm?

HE-friendly structured pruning [38; 37] reduces the number of rotations by pruning the diagonals of weight matrices. However, this technique is not feasible in the BSGS algorithm. Figure 15 demonstrates the limitations of structured pruning in BSGS. To illustrate, consider a GEMM where

Figure 14: Illustration of our BSGS algorithm for block circulant convolution with tiling.

input and weight matrices are tiled into smaller blocks, such as \(X_{1},X_{2}\) and \(W_{11},W_{12},W_{21},W_{22}\). First focusing on the multiplication between \(X_{1}\) and \(W_{11}\), note that in BSGS, rotations are split into baby-step and giant-step. Assuming \(B=2,G=4\), there are four groups, each containing two ciphertexts \((, 1)\), and eight weight polynomials \(_{0},,_{7}\) which are the eight diagonals of the weight matrix \(W_{11}\). Each group requires one baby-step rotation to achieve \( 1\) and one giant-step rotation. Pruning diagonals to reduce rotations in BSGS is challenging. For instance, to reduce a baby-step rotation, all diagonals in the same position across different groups, such as \(_{1},_{3},_{5},_{7}\), must be pruned. Additionally, considering tiling, \(X_{1}\) must multiply with all weight matrices in the first row, i.e., \(W_{11},W_{12}\). Thus, to decrease a single baby-step rotation, diagonals in the same position across all groups for all first-row weight matrices must be pruned. A similar challenge exists for giant-step rotations; to reduce one giant-step rotation, entire groups like \(_{0},_{1}\), in all first-column of the weight matrices must be pruned. Consequently, it is difficult for existing structured pruning methods to meet these constraints, leading to the limitation of reducing the number of rotations.

## Appendix E An example of our loss-aware initialization for circulant matrices

We give an example of our circulant transformation initialization in Equation 11. The input matrix \(W\) is a \(2 2\) matrix and the values of \(W\) and \(()}{ W}\) are artificial for simplicity.

\[W=[1&2\\ 4&3],(()}{ W })=[1&2\\ 3&5]\] \[\|W^{}-W\|_{2}^{2} W^{}= [2&3\\ 3&2]\] \[_{i} W^{}=[[ ]{cc}1*1^{2}&2*2^{2}\\ 4*3^{2}&3*5^{2}]_{diag}=[+3*5^{2}}{1*5^{2}}&+4*3^{2}}{2^{2}+3^{2}}\\ +4*3^{2}}{2^{2}+3^{2}}&+3*5^{2}}{1*5^{2}}\\ ]=[2.92&3.38\\ 3.38&2.92]\] (11)

## Appendix F Inverted Residual Fusion Algorithm

The key idea of the inverted residual fusion is to compute consecutive linear layers at once with one round communication. The algorithm is described in Algorithm 1 where \(^{C},^{S}\) are the secret

Figure 15: Illustration of the limitation of structured pruning in BSGS algorithm.

shares held by the client and the server. \(,,\) represent homomorphic addition, subtraction, and multiplication, respectively.

``` Input: Client holds \(_{1}^{C}\), and Server holds \(_{1}^{S},(_{res}),_{1}\) and \(_{2}\). Output: Client and Server get \(_{2}^{C},_{2}^{S}\), respectively, where \(_{2}=(_{2},_{res}+(_{1},_{1}))\).
1 Client encodes and encrypts \(_{1}^{C}\) as \((_{1}^{C})\) and sends it to Server.
2 Server computes \((_{1})=_{1}[(_{1} ^{C})_{1}^{S}]\).
3 Server computes \((_{res}+_{1})=(_{res}) (_{1})\).
4 Server computes \((_{2})=_{2}(_{res}+_{ 1})\).
5 Server samples random noise \(\) which has the same shape as \(_{2}\). Server then computes \((_{2}-)=(_{2})\).
6 Server sends \((_{2}-)\) to Client and sets \(_{2}^{S}=\).
7 Client decrypts \((_{2}-)\) to get \(_{2}^{C}=_{2}-\). ```

**Algorithm 1**Inverted Residual Fusion Algorithm

## Appendix G Details of Experimental Setup

### Network Architectures

We evaluate PrivCirNet on MobileNetV2 , ResNet-18 , and ViT . The detailed architectures across different datasets are in Table 8. It should be noted that for ViT, we use ViT-lite architectures from .

### Training Details

All baseline methods and PrivCirNet are trained using identical hyper-parameters, including data augmentation, number of epochs, and others. These hyper-parameters are detailed in the 'configs' folder within our codebase. We also leverage self knowledge distillation to guide the training of the circulant networks and the pruned networks.

### Computational Resources in Experiments

For CIFAR and Tiny ImageNet datasets, we train all models on a single NVIDIA RTX4090 GPU and a single NVIDIA A6000 GPU. For ImageNet, we train all models on 8 NVIDIA A100 GPUs. The epochs are 300 and the total training time is around 1 day for CIFAR and Tiny ImageNet as well as ImageNet datasets.

## Appendix H Additional Experimental Results

### Latency breakdown of PrivCirNet

In Figure 16, we present the latency breakdown of PrivCirNet (b8) applied to MobileNetV2 and ViT on CIFAR-10. It is observed that PrivCirNetsignificantly reduces the latency associated with HE rotations and multiplications, shifting the bottleneck to nonlinear layers. Furthermore, in ViT, the

   Model & Layers & \# Params (M) & MACs (G) & Dataset \\  MobileNetV2 & 52 CONV, 1 FC, 1 AP, 35 ReLU & 2.24 & 0.093 & CIFAR/Tiny ImageNet \\ MobileNetV2 & 52 CONV, 1 FC, 1 AP, 35 ReLU & 3.5 & 0.32 & ImageNet \\ ResNet-18 & 52 CONV, 1 FC, 1 AP, 35 ReLU & 11.17 & 0.558 & CIFAR/Tiny ImageNet \\ ViT & Hidden Dim=256, Number of blocks=7 & 3.72 & 0.24 & CIFAR \\ ViT & Hidden Dim=192, Number of blocks=9 & 2.77 & 0.69 & Tiny ImageNet \\   

Table 8: PrivCirNet evaluation benchmarks.

self-attention layers account for a large proportion of the total HE operations. Since these layers lack weight matrices, they cannot benefit from block circulant transformations.

### Results on more networks

Results of ResNet-18 and ViT on CIFAR-100In Figure 17, we show the results of ResNet-18 and ViT on CIFAR-100. We compare PrivCirNet with SOTA HE-based DNN inference frameworks and HE-friendly structured pruning method SpENCNN. We find that: **1)** PrivCirNet achieves \(1.8\) latency reduction on ResNet-18 and \(1.4\) latency reduction on ViT compared with SOTA frameworks Cheetah and Bolt with iso-accuracy. **2)** Compared with SpENCNN, PrivCirNet achieves \(3.9\%\) and \(7.9\%\) higher accuracy on ResNet-18 and ViT with lower latency, respectively. **3)** Bolt performs worse than Cheetah in ResNet-18 because Bolt needs to transform convolution into \(\) which increases the hidden dimension by \(9\) in \(3 3\) convolutions. By contrast, PrivCirNet support both convolution and GEMM efficiently.

Figure 16: Latency (s) breakdown of PrivCirNet (b8) on MobileNetV2 and ViT on CIFAR-10.

Figure 17: Comparison with SpENCNN and other prior-art protocols on ResNet-18 and ViT on CIFAR-100.

Figure 18: Comparison with Bolt on RegNet and ConvNeXt.

[MISSING_PAGE_EMPTY:22]

Proofs

### Proof of Theorem 1

For a given input matrix \(X\) and a circulant matrix \(W\), we have

\[& W^{b b},W[i,j]=W[0,(b-i+j) b],  i[b], j[b]\\ & X^{b d_{1}},X[i,j], i[b], j [d_{1}]\] (12)

The matrix multiplication result \(Y\) is

\[Y=WX^{b d_{1}},Y[i,j]=_{k=0}^{b-1}W[i,k]X[k,j]=_{k=0 }^{b-1}W[0,(b-i+k) b]X[k,j]\] (13)

The polynomials \(=_{}(X),=_{}(W)\) after CirEncode are

\[&_{n},[id_{1}+j]=X[i,j],  i[b], j[d_{1}]\\ &_{n},[id_{1}]=W[i,0]=W[0,(b-i) b ], i[b],\] (14)

The other slots of \(\) are set to 0. The polynomial multiplication result \(=\) directly gives the matrix multiplication result \(Y\) as

\[&= _{n}\\ [id_{1}+j]&=_{k=0}^{b-1}[(i-k)d_{1 }][kd_{1}+j]\\ &=_{k=0}^{b-1}W[0,(b-i+k) b]X[k,j]\\ &=_{k=0}^{b-1}W[i,k]X[k,j]=Y[i,j]\] (15)

Besides, we extend the definition of \([i]=[bd_{1}+i], i<0\).

Explanation of CirEncode Modulo \(x^{n}-1\).CirEncode performs Discrete Fourier Transform (DFT) modulo \(x^{n}-1\) on the plaintext. After the DFT, it applies SIMD encoding to enable element-wise multiplication. The correctness is demonstrated by the equation \(()()=(  x^{n}-1)\)

### Proof of Theorem 2

Given \(M\) circulant weight matrices \(W_{0},,W_{M-1}^{b b}\) and input matrices \(X_{0},,X_{M-1}^{b d_{1}}\), define the polynomials \(_{m}=_{}(W_{m})\) and \(_{m}=_{}(X_{m})\) with \(m[M]\) following the coefficient packing in Theorem 1. We have:

\[&(_{0})||(_{M-1}) _{}(_{0})||(_{M-1})_{}\\ &=(_{0})(_{0})| |(_{M-1})(_{M-1})_{ }\\ &=(_{0}_{0})|| (_{M-1}_{M-1})_{}\\ &=(_{0})||(_{ M-1})_{}\] (16)

Then we can perform inverse DFT and directly extract elements following Theorem 1 from \(_{m}\) to get \(Y_{m}\), \( m[M]\). The second and the third lines of Equation 16 follow directly from Lemma 1 while the last line is derived from Theorem 1. Through Equation 16, we simultaneously evaluate \(M\) circulant GEMMs with CirEncode.

### Proof of Theorem 3

For a given input \(X\) and a circulant weight \(W\) of a convolution, we have

\[ W^{b b R R},W[i,j,: ;]&=W[0,(b-i+j) b,:,:]\\ &=W[(b-j+i) b,0,:,:], i[b], j[b]\\ X^{b H W},X[i,j,k],& i [b], j[H], k[W]\] (17)The convolution result \(Y\) is

\[ Y=W X^{b(H-R+1)(W-R+1)} \\ Y[i,j,k]=_{l=0}^{b-1}_{m=0}^{R-1}_{h=0}^{R-1}W[i,l,m,h ]X[l,j+m,k+h]\] (18)

The polynomials \(=_{}^{}(X),=_{}^{}(W)\) after CirEncode are

\[_{n},[iHW+jW+k]=X[i,j,k] \\ _{n},[iHW+(W+1)(R-1)-jW-k]=W[i,0,j,k] \] (19)

The other slots of \(\) are set to 0. The polynomial multiplication result \(=\) directly gives the convolution result \(Y\) as

\[&= _{n}\\ [iHW+(W+1)(R-1)+jW+k]&=_{l=0}^{b-1}_{ m=0}^{R-1}_{h=0}^{R-1}\\ ([(i-l)HW+(W+1)(R-1)-mW-h]&[lHW+(j+m) W+(k+h)])\\ &=_{l=0}^{b-1}_{m=0}^{R-1}_{h=0}^{R-1}W[i,l,m,h]X[l,j+m,k+h]\\ &=Y[i,j,k]\] (20)

Besides, we extend the definition of \([(i-l)HW+]=[(b+i-l)HW+], i<l\).

### NeurIPS Paper Checklist

1. **Claims** Question: Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope? Answer: [Yes] Justification: / Guidelines: * The answer NA means that the abstract and introduction do not include the claims made in the paper. * The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers. * The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings. * It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper.
2. **Limitations** Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] Justification: See Section 5. Guidelines: * The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper. * The authors are encouraged to create a separate "Limitations" section in their paper. * The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be. * The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated. * The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon. * The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size. * If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness. * While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren't acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations.
3. **Theory Assumptions and Proofs** Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? Answer: [Yes]Justification: Proofs of all theoretical results are available in the Appendix. 1. Guidelines: * The answer NA means that the paper does not include theoretical results. * All the theorems, formulas, and proofs in the paper should be numbered and cross-referenced. * All assumptions should be clearly stated or referenced in the statement of any theorems. * The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition. * Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material. * Theorems and Lemmas that the proof relies upon should be properly referenced.
4. **Experimental Result Reproducibility** Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? 1. Answer: [Yes] Justification: Our code and checkpoints are available on GitHub. Guidelines: * The answer NA means that the paper does not include experiments. * If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not. * If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable. * Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed. * While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example 1. If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. 2. If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. 3. If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). 4. We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results.
5. **Open access to data and code** Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material?Answer: [Yes] Justification: Our code and checkpoints are available on GitHub. Guidelines:

* The answer NA means that paper does not include experiments requiring code.
* Please see the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details.
* While we encourage the release of code and data, we understand that this might not be possible, so "No" is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).
* The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details.
* The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.
* The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.
* At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).
* Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
6. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: All training details are available in our code on GitHub. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material.
7. **Experiment Statistical Significance** Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? Answer: [No] Justification: We conduct experiments on multiple models and datasets, which require significant computational resources. In addition, our code has been released, making it easy to reproduce the results. Guidelines: * The answer NA means that the paper does not include experiments. * The authors should answer "Yes" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. * The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions). * The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.) * The assumptions made should be given (e.g., Normally distributed errors).

* It should be clear whether the error bar is the standard deviation or the standard error of the mean.
* It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis of Normality of errors is not verified.
* For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).
* If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text.
8. **Experiments Compute Resources** Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? Answer: [Yes] Justification: Information about our computing resources is available in the Appendix. Guidelines: * The answer NA means that the paper does not include experiments. * The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage. * The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute. * The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn't make it into the paper).
9. **Code Of Ethics** Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? Answer: [Yes] Justification: / Guidelines: * The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics. * If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics. * The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction).
10. **Broader Impacts** Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? Answer: [NA] Justification: / Guidelines: * The answer NA means that there is no societal impact of the work performed. * If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact. * Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.

* The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.
* The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.
* If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML).
11. **Safeguards** Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? Answer: [NA] Justification: / Guidelines:

* The answer NA means that the paper poses no such risks.
* Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.
* Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.
* We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort.
12. **Licensees for existing assets** Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? Answer: [Yes] Justification: / Guidelines:

* The answer NA means that the paper does not use existing assets.
* The authors should cite the original paper that produced the code package or dataset.
* The authors should state which version of the asset is used and, if possible, include a URL.
* The name of the license (e.g., CC-BY 4.0) should be included for each asset.
* For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.
* If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.
* For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.

* If this information is not available online, the authors are encouraged to reach out to the asset's creators.
* **New Assets*
* Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? Answer: [NA] Justification: / Guidelines:
* The answer NA means that the paper does not release new assets.
* Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.
* The paper should discuss whether and how consent was obtained from people whose asset is used.
* At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file.
* **Crowdsourcing and Research with Human Subjects*
* Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? Answer: [NA] Justification: / Guidelines:
* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.
* According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector.
* **Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects*
* Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? Answer: [NA] Justification: / Guidelines:
* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.
* We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.
* For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review.