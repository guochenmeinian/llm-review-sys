# Direct Feedback Alignment for Recurrent Neural Networks

Anonymous Author(s)

Affiliation

Address

email

###### Abstract

Time series and sequential data are widespread in many real-world environments. However, implementing physical and adaptive dynamical systems remains a challenge. Direct Feedback Alignment (DFA) is a learning algorithm for neural networks that overcomes some of the limits of backpropagation and can be implemented in neuromorphic hardware (e.g., photonic accelerators). Until now, DFA has been investigated mainly for feedforward architectures. We adapt DFA for both "vanilla" and gated recurrent networks. Unlike backpropagation, the update rule of our DFA can be applied in parallel across time steps, thus removing the sequential propagation of errors. We benchmark DFA on 4 datasets for sequence classification tasks. Although backpropagation still achieves a better predictive accuracy, our DFA shows promising results, especially for environments and physical systems where backpropagation is unavailable.

## 1 Introduction

Backpropagation  is the long-standing algorithm for credit assignment in artificial neural networks. Its efficient implementation in digital computers has supported the surge of machine and deep learning techniques as one of the key advancements in the field of artificial intelligence . However, with a few exceptions , the adoption of backpropagation-based learning systems is still mainly limited to digital computers and simulations. It is well known that backpropagation cannot be easily implemented and deployed in physical systems . For example, due to issues like the weight transport where the synaptic weights of the backward circuit need to be constantly synchronized with the synaptic weights of the forward circuit .

Physical deployment of backpropagation is even more challenging in Recurrent Neural Networks (RNNs) , where credit assignment must be performed across time. The most used algorithm to date is BackPropagation Through Time (BPTT) , which extends backpropagation to recurrent architectures.

Over time, several backpropagation-free algorithms have been proposed (see Section 2 for a non-exhaustive overview), some of them with the explicit objective of being compatible with the implementation in physical systems or on unconventional hardware (e.g., neuromorphic, optical).

We focus on Direct Feedback Alignment (DFA) , a backpropagation-free algorithm for credit assignment that removes the weight transport issue and also allows parallel computation of the weight update. DFA has already been implemented in nonconventional hardware, especially photonic . The photonic co-processor introduced in Launay et al.  scales DFA to trillion-parameter random projections.

We briefly review DFA for feedforward networks in Section 3. We propose an extension of DFA tailored to recurrent neural networks. Our approach is able to compute the update of the recurrent parameters in parallel over all the time steps of the input sequence, thus removing one of the major drawbacks of BPTT. In fact, BPTT sends the error signal computed at the end of the input sequence _back in time_ to compute the network parameters update. Instead, the update computed by our version of DFA is local at each time step, as it does not rely on the update computed for other time steps. Due to the weight sharing present in RNNs, the local update is eventually aggregated at the end of the input sequence to compute the final update. The aggregation operation includes information from all the time steps, thus enabling learning of temporal dependencies.

We develop DFA for both a "Vanilla" RNN and a Gated Recurrent Unit (GRU) network (Cho et al., 2014; Chung et al., 2014). We benchmark both architectures against BPTT on four time-series classification datasets and we find that DFA can achieve non-trivial performances in all of the tested datasets but cannot always attain a performance comparable to BPTT. In general, DFA shows strength in datasets with more than 2 classes and in datasets with a limited number of training samples, although BPTT still surpasses its performance. We show that the GRU architecture trained with DFA is able to learn longer temporal correlations than a "Vanilla" RNN.

## 2 Related works

Lillicrap et al. (2016) proposed the Feedback Alignment algorithm (FA) as a biologically plausible gradient-free learning rule for deep learning. The key idea of FA is to project the errors from the last layer of a deep feedforward architecture to the first layer via random projections between consecutive layers. This simple algorithm has shown competitive performance on the MNIST classification task against the commonly used backpropagation algorithm.

Pushing the FA idea to the extreme, Nokland (2016) proposed DFA, where the error is randomly projected back to each layer with a direct shortcut connection.

Practical applications of DFA to RNNs have been explored in Nakajima et al. (2022). The authors performed physical deep learning with an optoelectronic recurrent neural network. However, in their pioneering work, they do not explore the DFA algorithm in the context of fully trainable RNNs, since they only provide a proof-of-concept using a reservoir computing model with untrained reservoir connections (Lukosevicius and Jaeger, 2009). In this paper, we investigate the potential of DFA on fully-trainable RNNs.

Han et al. (2020) investigated a DFA-inspired algorithm for RNNs. However, their version of DFA is restricted and cannot be applied to any recurrent or gated architecture, like our approach. First, they implement an upper triangular modular structure. Second, they use random projections as powers of the same matrix, which effectively resembles an FA algorithm applied to RNNs rather than a DFA algorithm for RNNs. Overall, our approach stems directly from DFA and closely follows its assumptions without requiring any customization, thus remaining more general and targeting any recurrent model.

## 3 DFA for feedforward networks

We first introduce DFA for feedforward neural networks (Figure 1, middle), to prepare the notation and set the stage for its extension to recurrent neural networks. Consider a fully-connected, feedforward neural network with an arbitrary number of \(L\) layers (including input and output layers), input size \(I\), hidden size \(H\) and output size \(O\). Each layer \(l\) computes its preactivation \(a_{l}\) through a linear projection \(a_{l}=W_{l}u_{l}+b_{l}\), where \(W_{l}^{H I},^{H H},^{O H}\) is the weight matrix for the input, hidden and output layers, respectively. Similarly, \(b_{l}^{H},\;l<L\) is the bias vector for the input and hidden layer and \(b_{L}^{O}\) is the bias vector for the output layer. The input \(u_{l}\) corresponds to the data sample \(x\) for the input layer (\(u_{1}^{I}\)) and to the output of the previous layer for all other layers (\(u_{l}^{H},l>1\)). The preactivation at each layer is passed through an element-wise nonlinear function \(\) (e.g., hyperbolic tangent) to generate the layer's activation \(h_{l}=(a_{l})\). The output of the network \(\) is read out from the last layer: \(=h_{L}\). For each input example \(x\), the loss function \(J(,y)\) (e.g., cross-entropy or mean-squared error) measures the error between the output and the target prediction \(y\) associated with the example \(x\).

Updating the last layer's parameters \(W_{L},b_{L}\) via gradient descent is straightforward as there is a direct dependency between \(\) and the loss function \(J\). For the cross-entropy or the mean-squared error loss,\(e=}=-y\). Therefore, \(e\) can be directly used to update \(W_{L}\): \(W_{L} W_{L}- eh_{L-1}^{T}\) and \(b_{L}\): \(b_{L} b_{L}- e\), where \(\) is the learning rate. The update of the last layer's parameters is the same for both backpropagation and DFA.

For the hidden layers, backpropagation computes the update by propagating the error signal \(e\) sequentially to lower layers (Figure 1, left). For any hidden layer, we have \(W_{l} W_{l}-(\;(W_{l+1}^{T} a_{l+1}^{}(a_ {l}))\;u_{l}^{T})\), where \(\) denotes element-wise multiplication and \( a_{l+1}\) is the error signal coming from _the layer above_. This last term requires the error to be computed sequentially one layer at a time. This dependency prevents updating all layers in parallel.

DFA removes this limitation by projecting the error \(e\)_directly_ to all layers, through a random matrix \(B^{H O}\). \(B\) can also be different for each layer. Crucially, the matrix \(B\) is kept fixed and only governs the weights update. It does not take any part in the forward phase.

DFA updates each hidden layer via

\[W_{l}  W_{l}-(\;(Be^{}(a_{l}))\;u_{l}^{T}),\] (1) \[b_{l}  b_{l}-(\;Be^{}(a_{l})\;).\] (2)

These updates can be applied to each layer independently, thus enabling embarrassingly parallel computation for all layers.

DFA also removes the weight alignment issue, as the update circuit uses random connections instead of connections that always need to be synchronized with the forward circuit, like in backpropagation.

## 4 DFA for recurrent networks

We develop a version of DFA that is compatible with RNNs for sequential data processing (Figure 1, right). We closely follow the DFA approach devised for feedforward networks and we extend it to the recurrent case. Each example \(x\) is a sequence of \(T\) input vectors: \(x=(x_{1},,x_{T})\), where \(x_{i}^{I}\). We consider the sequence classification task where each sequence \(x\) is associated with a target class \(y\). The RNN keeps an internal hidden state \(h^{H}\) which is updated at each time step. We first focus on the "Vanilla" RNN (Elman, 1990), whose state update of reads:

Figure 1: We propose DFA applied to recurrent networks (right). The error is projected through random matrices \(B_{W}\) and \(B_{V}\). We also show backpropagation (left) and DFA (middle) applied to feedforward networks. Grey arrows denote the forward phase, black arrows denote the update phase. Note that in the RNN, the matrices \(W\) ad \(V\) are shared across time steps (layers), while in feedforward networks each layer has a different matrix. Also, the RNN receives a different input \(x_{t}\) at each time step (here, the input sequence has \(3\) time steps), while the feedforward network only receives one input \(x\).

\[h_{t+1}=(Wh_{t}+Vx_{t+1}+b),\] (3)

where \(V^{H I}\) is the input-to-hidden matrix and we call \(a_{t}\) (pre-activations at time \(t\)) the terms inside \(\). In RNNs, the same layer is applied to all time steps (weight sharing). The output \(\) of the RNN is computed from the hidden state: \(=(W^{}h_{t}+b^{})\), where \(W^{}^{O H}\) and \(b^{}^{O}\). The nonlinear function \(\) can be different from the one used in the hidden layers. For sequence classification tasks the output is computed at the end of the input sequence from \(h_{L}\).

Due to the weight sharing, the forward pass of an RNN can be interpreted as the unrolling of the state update function over time. At each time step, the matrix \(W\) and \(V\) (and the bias as well) are used to compute the next hidden state, much like the matrix \(W_{l}\) is used to compute the layer's output in a feedforward network. The backpropagation algorithm applied to RNNs, called backpropagation through time (BPTT) updates the hidden-to-hidden weight \(W\) via \(_{W}J(,y)=}_{t=1}^{T}}{ h_{t}}}{ W}\). The term \(}{ h_{t}}\) hides a dependency between hidden states \(_{j=1}^{t-1}}{ h_{j}}\) which is due to the sequential propagation of the error over the time steps.

Our DFA-based algorithm for RNN removes this propagation and updates \(W\) by computing the term \(}_{t=1}^{T}}{W}\). The error signal \(e\) is projected via a random matrix \(B\), randomly initialized and kept fixed.

The equations for the update of \(W\) and \(V\) via DFA read:

\[W  W-_{t=1}^{T}(\,Be^{}(a_{t})\, )\;h_{t-1}^{T},\] (4) \[V  V-_{t=1}^{T}(\,Be^{}(a_{t})\, )\;x_{t}^{T}\] (5)

The bias is updated by omitting the outer product.

DFA for gated recurrent networks.In addition to the development of DFA for "Vanilla" RNNs (Equation 3), we also developed a version of DFA for gated recurrent networks, focusing in particular on the GRU network (Cho et al., 2014; Chung et al., 2014). The state update (forward pass) for a GRU reads:

\[z_{t+1} =(W_{z}h_{t}+V_{z}x_{t+1}+b_{z}),\] \[r_{t+1} =(W_{r}h_{t}+V_{r}x_{t+1}+b_{r}),\] \[c_{t+1} =(W_{c}(h_{t} r_{t+1})+V_{c}x_{t+1}+b_{c}),\] \[h_{t+1} =(1-z_{t+1}) c_{t+1}+z_{t+1} h_{t},\]

where _tanh_ and _sig_ are the hyperbolic tangent and sigmoid functions, respectively. Our DFA update for all parameters of the GRU is provided in Appendix A. The output \(\) of the network is computed from the hidden state \(h_{t}\) as previously discussed.

## 5 Experiments

We implemented all our experiments in PyTorch (Paszke et al., 2019). Although DFA does not compute a true gradient, we filled the "grad" attribute of each weight tensor with the DFA update. This enabled us to use any PyTorch optimizer to apply the update. We used the Adam optimizer for all experiments.

We assessed the performance of DFA against BPTT on the aforementioned "Vanilla" RNN and GRU. We report the average test accuracy and standard deviation computed over 5 runs1. Table 1 reports a summary of the time series datasets statistics. We considered 4 different datasets:1. _Libras2_[Dias Daniel and Helton, 2009] contains 15 classes associated with a different hand movement type. The hand movement is represented as a bi-dimensional curve performed by the hand in a given period of time; 2. _Row-MNIST_[Deng, 2012]: each image of the MNIST dataset is presented to the recurrent model one row at a time;
3. _ECG200_[Olszewski et al., 2001]: where each time series traces the electrical activity of a subject recorded during one heartbeat. The task is a binary classification prediction between a normal heartbeat and one highlighting a Myocardial Infarction;
4. _Strawberry_[K. Kemsley] consists in classifying food spectrographs, a task with applications in food safety and quality assurance. The classes are strawberry (authentic samples) and non-strawberry (adulterated strawberries and other fruits).

The datasets are divided into train, validation and test sets according to the proportions 60%-20%-20%. The hyperparameters have been selected based on a model selection with a grid search (see Appendix B for the details).

Table 1 reports the test accuracy achieved by all methods, alongside the specifics of the datasets. Overall, BPTT still outperforms DFA across most datasets. Specifically, BPTT outperforms DFA with GRU architectures except for the ECG200 dataset, in which both learning algorithms achieve a comparable performance.

With "vanilla"RNN architectures, BPTT outperforms DFA except for the ECG200 and the Libras datasets, where the average test accuracy of DFA (Figure 2 top-left panel, orange line) is higher than BPTT's one (red line) after the first 150 epochs. Moreover, in this dataset, DFA has the same learning slope of BPTT either with vanilla RNNs (for the first 150 epochs) or for GRUs (for the first 50 Epochs).

DFA seems to struggle with unbalanced datasets, like ECG200 and Strawberry. In the ECG dataset, which is the one with the smallest amount of data, the test accuracy of RNN with DFA is above the random performance of 12\(\%\). In the Strawberry dataset, the same model with DFA shows an accuracy which is above the random performance of only 5\(\%\). In the case of balanced datasets, RNNs trained with DFA are generally successful at learning temporal correlations.

Overall, while BPTT generally resulted in higher test accuracy, DFA demonstrated comparable performance particularly for ECG200 in both GRU and RNN models. This suggests that although DFA is less accurate overall, it may be a viable alternative in scenarios where strong parallelization combined with a physical implementation is a possibility.

## 6 Conclusion and Future Work

We proposed a learning algorithm for recurrent neural networks based on DFA [Nokland, 2016]. Our DFA enables parallel updates across the time steps, thus removing the sequential update constraint of

    & Strawberry & LIBRAS & ECG200 & Row-MNIST \\  Input size & 1 & 2 & 1 & 28 \\ Number of classes & 2 & 15 & 2 & 10 \\ Sequence length & 235 & 90 & 96 & 28 \\ Dataset size & 983 & 360 & 200 & 70000 \\  DFA GRU & 79.73 \(\) 1.23 & 67.50 \(\) 3.68 & 80.6 \(\) 2.25 & 72.49 \(\) 1.1 \\ BPTT GRU & 92.05 \(\) 2.54 & 80.83 \(\) 9.19 & 82.10 \(\) 1.14 & 99.23 \(\) 0.03 \\  DFA RNN & 67.84 \(\) 2.66 & 47.92 \(\) 3.3 & 78.2 \(\) 1.47 & 87.48 \(\) 0.74 \\ BPTT RNN & 79.08 \(\) 4.18 & 54.30 \(\) 18.32 & 83.30 \(\) 2.1 & 96.69 \(\) 0.24 \\   

Table 1: Summary of datasets statistics and average test accuracy and standard deviation over 5 repetitions for all datasets and models.

BPTT. The parallel update phase is particularly interesting for physical implementations of adaptive dynamical systems, as the signal needs not be propagated sequentially back in time. On digital computers, the parallel update allows speed-up when implemented on customized CUDA kernels or with low-level programming interfaces. Unfortunately, in native Python, the speed-up cannot be observed due to the GIL and the large overhead of process spawning. Starting from our publicly available code, future works can refine the implementation, perhaps by integrating the parallel DFA update within the C++ PyTorch API.

There are still other aspects that require further consideration. For example, the choice of the random feedback matrix is crucial, as it affects the trajectory of the parameters during training. Moreover, different matrix structures are amenable to different implementations in neuromorphic or unconventional hardware. Crafton et al. (2019) implemented DFA for feedforward architectures on neuromorphic hardware with a sparse feedback matrix, at minimal or no performance loss.

Our algorithm can also be easily extended to deal with time series forecasting tasks, where the prediction step is taken after each time step, instead of only at the end of the input sequence. Further benchmarking of our DFA in these settings is required to understand its effectiveness.