# Model Sensitivity Aware Continual Learning

Zhenyi Wang and Heng Huang

Department of Computer Science, Institute of Health Computing

University of Maryland College Park

College Park, MD, 20742

zwang@umd.edu;heng@umd.edu

###### Abstract

Continual learning (CL) aims to adapt to non-stationary data distributions while retaining previously acquired knowledge. However, CL models typically face a trade-off between preserving old task knowledge and excelling in new task performance. Existing approaches often sacrifice one for the other. To overcome this limitation, orthogonal to existing approaches, we propose a novel perspective that views the CL model ability in preserving old knowledge and performing well in new task as a matter of model sensitivity to parameter updates. _Excessive_ parameter sensitivity can lead to two drawbacks: (1) significant forgetting of previous knowledge; and (2) overfitting to new tasks. To reduce parameter sensitivity, we optimize the model's performance based on the parameter distribution, which achieves the worst-case CL performance within a distribution neighborhood. This innovative learning paradigm offers dual benefits: (1) reduced forgetting of old knowledge by mitigating drastic changes in model predictions under small parameter updates; and (2) enhanced new task performance by preventing overfitting to new tasks. Consequently, our method achieves superior ability in retaining old knowledge and achieving excellent new task performance simultaneously. Importantly, our approach is compatible with existing CL methodologies, allowing seamless integration while delivering significant improvements in effectiveness, efficiency, and versatility with both theoretical and empirical supports.

## 1 Introduction

Continual learning (CL) embodies a dynamic approach aimed at adapting to non-stationary data distributions that evolve over time. However, in pursuit of this goal, CL encounters a significant challenge: the trade-off between preserving previously acquired knowledge and effectively learning new knowledge. As the model assimilates new information, it often swiftly erases previously learned knowledge, resulting in catastrophic forgetting (CF) on past tasks . Effectively addressing CF during CL is essential to preserve previously acquired information. On the other hand, effectively learning new information is equally crucial for CL models to adapt to new tasks and environments.

Existing approaches in CL often face a dilemma: they either prioritize preserving old knowledge or excelling in new task performance, often at the expense of the other. When a CL model prioritizes preserving old knowledge, it focuses on retaining information from previous tasks while minimizing interference or forgetting. However, excessive emphasis on old knowledge can limit the model's ability to adapt to new tasks. Conversely, when a model prioritizes new task performance, it aims to quickly adapt to new tasks or data distributions. Yet, this emphasis on new tasks can potentially degrade performance on previously learned tasks.

To overcome the aforementioned limitations, orthogonal to existing approaches, we introduce the concept of model sensitivity and approach the challenge of balancing old knowledge retention and new task performance in CL from the perspective of model parameter sensitivity. When a CLmodel exhibits high sensitivity to parameter changes, it leads to two significant issues: (1) _Increased Forgetting_: Excessive sensitivity in model parameters can cause abrupt and substantial changes in model predictions with minor parameter adjustments during CL. This phenomenon results in significant forgetting of previous tasks. (2) _Diminished New Task Performance_: High sensitivity in model parameters can also result in severe overfitting on new tasks. Overfitting occurs when a model memorizes the training data instead of generalizing patterns that can be applied to unseen data. High parameter sensitivity means that even minor alterations in the training data can induce substantial modifications in the learned model. This renders the model excessively tailored to the training data and reduces its adaptability to new, unseen data, consequently leading to suboptimal performance on new tasks.

To reduce the CL model parameter sensitivity under model updates, we aim to ensure that even minor alterations in model parameters do not substantially impair CL model performance. This is accomplished by optimizing the model's performance based on the worst-case scenario of parameter distributions within a distribution neighborhood. However, finding the optimal worst-case CL model parameter distribution is challenging since the space of all possible distributions within the neighborhood is an infinite-dimensional space . To efficiently solve this problem, we parameterize the optimal worst-case CL model parameter distribution as Gaussian distribution. We propose a natural-gradient descent (NGD) method to efficiently inference the mean and covariance of the Gaussian distribution since NGD incorporates the information geometry of the parameter space by adapting the step size based on the curvature of the cost function. This adaptive approach leads to faster convergence compared to conventional gradient descent methods, particularly in high-dimensional spaces where the curvature exhibits notable variations. This is especially beneficial for CL models. However, calculating the natural gradient is computationally expensive due to the explicit calculation of Fisher information matrix (FIM). We thus update the worst-case CL parameters in the expectation parameter space, rather than the traditional natural parameter space, of the Gaussian distribution, thereby eliminating the need for explicit calculation of the FIM.

Our method offers dual benefits: (1) _Reduced Forgetting_: By mitigating parameter sensitivity and avoiding drastic changes in model prediction, our approach effectively reduces the loss of previously learned task knowledge. (2) _Improved New Task Performance_: Through decreased parameter sensitivity, the model becomes less susceptible to overfitting on new task training data. This reduced vulnerability to minor fluctuations fosters the learning of more generalized patterns rather than memorizing specific examples. As a result, the model demonstrates enhanced generalization capabilities on new tasks. Therefore, our method simultaneously achieves superior performance in retaining previously learned knowledge and excelling in new task performance.

We provide a thorough theoretical analysis for our method. Firstly, the theory illustrates that our approach implicitly reduces the variance of loss against different parameter variations, thereby indicating reduced model parameter sensitivity. Secondly, our method tightens the generalization bound of CL models, suggesting enhanced generalization. Furthermore, our extensive experiments across multiple datasets, compared to various state-of-the-art (SOTA) baseline methods, reveal substantial enhancements in overall performance across all learned tasks, backward transfer, and new task test accuracy. These results indicate significantly enhanced CL model ability in preserving old knowledge and achieving better performance on new task with our method. Additionally, our proposed approach seamlessly integrates with existing CL methodologies, functioning as a versatile plug-in. This demonstrates the effectiveness, efficiency, and versatility of our method.

Our contributions can be summarized as follows:

* We tackle the challenge of both retaining old task knowledge and excelling in new task in CL from a novel perspective by mitigating model parameter sensitivity.
* We introduce a novel CL approach aimed at reducing model parameter sensitivity by optimizing CL model performance under the worst-case parameter distribution within a distribution neighborhood. Additionally, we propose an efficient learning algorithm to identify the worst-case parameter distribution.
* We provide comprehensive theoretical analyses that substantiate our method's ability to decrease model parameter sensitivity and improve model generalization.
* Extensive experiments conducted across multiple datasets demonstrate the efficacy and versatility of our proposed method.

Related Works

CL aims to learn non-stationary data distributions without forgetting previously learned knowledge. The CL scenarios can be further categorized into three scenarios: task-incremental learning (Task-IL), domain-incremental learning (Domain-IL) and class-incremental learning (Class-IL) . Task-IL and Class-IL are most representative scenarios in CL, we thus focus on these two scenarios. Existing approaches for CL can be categorized into five classes: (1) _regularization-based_ methods incorporate regularization terms either in model weights or outputs into the loss function to mitigate catastrophic forgetting when learning new tasks, including [28; 62; 84; 55; 11; 1; 22; 10; 39]; (2) _memory replay-based_ methods address the challenge of catastrophic forgetting by explicitly storing and replaying a subset of past experiences (samples from previous tasks) while learning new tasks, including [40; 57; 15; 7; 51; 68; 3; 8; 75; 4; 74; 76; 61; 78; 77; 83; 36; 73; 72]; (3) _gradient-projection-based_ methods aim to mitigate catastrophic forgetting by projecting gradient updates onto subspaces that minimize interference with previously learned tasks, including [13; 17; 60; 71; 38; 52; 82]; (4) _architecture-based_ methods involve dynamically adapting and modifying the neural network architecture to accommodate new tasks while preserving performance on previously learned tasks, including [41; 63; 34; 23]; (5) _Bayesian-based_ methods leverage principles from Bayesian inference to manage the uncertainty and learning of new tasks while preserving knowledge from previous tasks, including [48; 58; 30; 25; 21; 49; 66; 59].

In contrast to existing methods, which often necessitate a trade-off between retaining old knowledge and learning new knowledge, sacrificing one for the other, our approach takes a different path. It sets itself apart from these existing methods by offering an orthogonal solution that preserves old task knowledge while simultaneously enhancing new task performance. This novel perspective is achieved by reducing parameter sensitivity.

Connection with existing flat-minima/SWAD approaches: (1) Connection and difference with sharpness-aware minimization (SAM) [18; 27; 45] related approach: Our method is fundamentally different from SAM-based CL in two aspects. (i) _Deterministic vs. Probabilistic Approach_: SAM uses a fixed deterministic neighborhood, which can be restrictive in practice since updates are constrained within a fixed ball. In contrast, our method employs a probabilistic distributional approach, offering two distinct advantages: (a) The distributional neighborhood is more flexible and covers a broader range of parameter variations by sampling from a neighborhood distribution, and (b) Stochastic Gradient Descent (SGD) introduces noise during CL. Our distributional approach accounts for this noise, making it a more realistic model in practice and providing stronger guarantees against parameter sensitivity. (ii) _Uniform vs. Parameter-specific sensitivity without explicit calculation of FIM_: SAM uniformly updates all parameters, overlooking the varying importance and sensitivity of each parameter in the context of CL. Our method, on the other hand, considers these differences and treats parameters uniquely through the natural gradient without needing to explicitly calculating the FIM. This distinction is crucial for CL, as each parameter has different sensitivity to forgetting--a factor that SAM does not address. (2) Connection and difference with model averaging flatness seeking approach: SWA  and SWAD , which aim to achieve flatter minima by averaging multiple models during training. However, these approaches are memory-intensive and inefficient for CL, as they require storing multiple sets of model parameters, which compromises memory efficiency.

## 3 Method

In this section, we first present the preliminary in section 3.1 and then present the model sensitivity aware continual learning in section 3.2.

### Preliminary

**Continual Learning Setup** The standard CL problem involves learning a sequence of \(T\) tasks, represented as \(^{tr}=\{_{1}^{tr},_{2}^{tr},,_{T}^{tr}\}\). The training dataset \(_{k}^{tr}\) for the \(k^{th}\) task contains a collection of triplets: \((_{i}^{k},y_{i}^{k})_{i=1}^{n_{k}}\), where \(_{i}^{k}\) denotes the \(i^{th}\) data example specific to task \(k\), \(y_{i}^{k}\) represents the associated data label for \(_{i}^{k}\). The primary objective is to train a neural network function, parameterized by \(\), denoted as \(g_{}()\). The goal is to achieve good performance on the test datasets from all the learned tasks, represented as \(^{te}=\{_{1}^{te},_{2}^{te},,_{T}^{te}\}\), while ensuring that knowledge acquired from previous tasks is not forgotten. The CL loss function is defined as the following:

\[^{CL}():=_{CE}(,y;)+ _{f}()\] (1)

where \(_{CE}(,y;)\) is the current task cross-entropy loss function. \(_{f}()\) is the forgetting-mitigation loss, e.g., memory-replay, weight-regularization and gradient-projection loss, etc. \(\) is a constant that balances the weight between the loss of the new task and the loss of the previous tasks.

Exponential Family of DistributionsThe exponential family distribution  is defined as:

\[P_{}():=h()exp(,( )-Z())\] (2)

Where \(:=\) denotes a definition. In existing literature , \(\) are called the natural parameters for defining the distribution, \(P_{}()\). \(h()\) is the base measure, \(()\) is the sufficient statistic, \(Z():= h()exp(,())d\) is the log-partition function, \(,\) denotes the dot product between two vectors. We denote the expectation parameters as \(:=_{P_{}()}()\). We can write multivariate Gaussian distribution as canonical form of exponential family as:

\[f(;,) :=}det()^{}} exp\{-(-)^{T}^{-1}(-)\}\] (3) \[=exp\{^{T}^{-1}-^{T}^{-1}-[d 2+||+^{T}^{-1}]\}\] (4)

Therefore, the correspondence between \(f(;,)\) and exponential family distribution in Eq.(2) can be expressed as the following:

\[:=(^{-1},-^{-1 }),():=(,^{T})\] (5) \[^{1}:=_{f(;, )}=,^{2}:=_{f(;,)}^{T}=^{T}+\] (6)

Derivations details of Eq.(6) can be found in Appendix B.1. In the following section, we use exponential family distributions to parameterize the worst-case of CL model parameter distribution since this enables us to efficiently calculate the natural gradient in the expectation parameter space \(\) without needing to explicitly calculate the Fisher information matrix (FIM) in natural parameter space \(\).

### Model Sensitivity Aware Continual Learning

Learning ObjectiveSpecifically, we propose the following CL learning objective to reduce the CL parameter sensitivity under model parameter updates:

\[_{} _{}_{()}^{CL}()\] (7) s.t. \[=\{:D_{}(,) \}\]

where \(\) denotes the uncertainty set. \(D_{}(,)\) denotes the KL divergence between the current CL model parameter distribution \(\) and the neighbour CL model parameter distribution \(\). \(\) is a small constant. \(_{}_{()}^{CL}()\) aims to find the worst-case CL model parameter distribution within a neighbourhood. We choose probabilistic distributional neighbourhood due to two-fold reasons: (1) the distributional neighbourhood covers more flexible parameter space; and (2) widely used SGD method incurs update noise during CL, thereby distributional neighbourhood provides stronger guarantee against parameter sensitivity. It is important to note that the outer minimization is performed with respect to \(\), the expectation of \(\), since during inference, only \(\) is used as the model parameter for predictions.

Objective for Learning the Worst-Case CL Parameter DistributionWe convert the constrained inner maximization optimization in Eq. (7) into the following unconstrained optimization to find the worst-case CL model parameter distribution.

\[*{arg\,min}_{}[H():=-_{ ()}^{CL}()+ D_{}(,)]\] (8)

where \(>0\) is a constant. However, solving Eq. (8) is intractable since the optimization target is in an infinite-dimensional function space . For computation efficiency, we set the current CLmodel parameter distribution as \(()=(|_{0},_{0})\), where \(_{0}\) and \(_{0}\) denote the mean vector and covariance matrix, respectively. We set the neighbourhood distribution as \(()=(|,)\), where \(\) and \(\) denote the mean vector and covariance matrix, respectively. To further improve computational efficiency, we constrain the covariance matrix to be diagonal matrix, i.e., \(=(^{2})\) and \(_{0}=(^{2})\). We denote the density function of \(()\) and \(()\) as \(u()\) and \(v()\), respectively. We express the loss function in Eq. (8) as the following:

\[H()=_{()}[( {},):=-^{CL}()+[ u()-  v()]]\] (9)

By parameterizing the distribution \(\) as exponential family distribution in Eq. (4), our goal is to learn the parameters \(\) in Eq. (5) with natural gradient descent (NGD)  as the following equation:

\[_{i+1}=_{i}-^{-1}_{}( {}_{i})\] (10)

where \(\) is the FIM. We opt for NGD because it adjusts the step size according to the curvature of the cost function, making convergence faster than traditional gradient descent methods. This is especially advantageous in high-dimensional spaces where the curvature and parameter-wise sensitivity vary significantly, benefiting CL models. However, computing the natural gradient is computationally intensive due to the need to calculate the FIM. To address this, we develop an efficient update method in the dual space, specifically the expectation parameter space \(\), rather than the natural parameter space \(\), eliminating the need for explicit FIM calculation. In the following, we will use \(()\) and \(()\) interchangeably, as they represent the same loss function only parameterized in different spaces. We leverage the relation between NGD in natural parameter space and gradient descent in expectation parameter space (in Appendix A.1), NGD can be performed without explicitly computing the FIM. This update in its dual space leads to significantly more efficient parameter updates and promising computational advantages.

NGD for Efficiently Finding the Worst-Case Gaussian DistributionIn the following, we present specific algorithms for updating the \(\) and \(\) with NGD to find the worst-case Gaussian distribution, i.e., \(^{*}:=_{}H()\). We can get the following updates for mean \(\) and diagonal covariance \(=(^{2})\) (detailed derivations can be found in Appendix B):

\[_{i+1}=_{i}+_{i+1}[_{}^{CL}()-(_{i}-_{0})_{0}^{-1}]\] (11) \[_{i+1}^{-1}=(1-)_{i}^{-1}+[- _{}^{2}^{CL}()+_{0}^{-1}]\] (12)

By plug-in \(=(^{2})\) and \(_{0}=(^{2})\) into the above equations, we can obtain the following updates:

\[_{i+1}=_{i}+_{i+1}^{2}[_{ }^{CL}(_{i})-(_{i}-_{0} )^{-2}]\] (13) \[_{i+1}^{-2}=(1-)_{i}^{-2}+[- _{}^{2}^{CL}(_{i})+ ^{-2}]\] (14)

In practice, we set \(=1.0\) to reduce the reliance on hyperparameters. However, computing the diagonal Hessian matrix \(_{}^{2}^{CL}()\) in Eq. (14) is a computationally challenging task. Following , we efficiently approximate the Hessian as the following:

\[_{^{k}_{k}}^{2}^{CL}()= {1}{N}_{j=1}^{j=N}[_{^{k}}^{CL}_{j}()]^{2}\] (15)

where \(N\) is the number of training data points for the current task, \(^{CL}_{j}()\) denotes the loss function for the data point \(j\), \(^{k}\) denotes the \(k^{th}\) element of the model parameter \(\). It is crucial to note that this Hessian approximation is computed only once after learning each task and involves calculating only the diagonal elements, i.e., \(=(^{2})\). As a result, the overall computational cost throughout the continual learning process remains low. Additionally, this update mechanism maintains the same number of learnable parameters as existing methods, ensuring fair comparisons. This is because, during the learning of each task, only the mean parameters of the Gaussian distribution are updated.

Learning AlgorithmWe name our method as Model sensitivity **A**ware **C**ontinual **L**earning (**MACL**). The detailed algorithm is present in Algorithm 1.

## 4 Theoretical Analysis

In this section, we build the theoretical connection between MACL and parameter sensitivity in Theorem 4.2 and the generalization analysis in Theorem 4.3. Due to the space limitations, we provide the theorem proof in Appendix A.2. Let's first look at the inner maximization problem in Eq. (7).

\[_{}^{CL}()d( ),=\{:D_{}(, )\}\] (16)

**Lemma 4.1**.: \(D_{}(,)= u()()}{v()})d)-v())^{2}}{v()}d\)__

**Theorem 4.2**.: _Assume \(||)}||_{}d M\), we can obtain the following conclusion for Eq. (16):_

\[_{}^{CL}()d( )=^{CL}()}+(^{CL}()-^{CL}()})^{2}}{M}}\] (17)

where \(^{CL}()}:=^{CL}()d ()\). \(Var(^{CL}())\) denotes the variance of \(^{CL}()\) with respect to different model parameters variations, i.e., \(Var(^{CL}())=(^{CL}()- ^{CL}()})^{2}=(^{CL}()-^{CL}()})^{2}d\). In this context, \(Var(^{CL}())\) serves as a measure of the CL model's sensitivity to parameter updates. Essentially, a smaller loss variance indicates lower parameter sensitivity in the CL model. However, directly optimizing the loss variance within the parameter distribution neighborhood is impractical, as it requires computing the loss variation across a large number of different sets of CL model parameters and training data points. In contrast, our method (MACL) offers an efficient and effective alternative. MACL implicitly minimizes the loss variance across different model parameter variations by optimizing CL performance solely on the worst-case CL model parameter distribution. In the following, inspired by UDIL , we further provide the following generalization bound for CL:

**Theorem 4.3** (Generalization bound of MACL).: _Let \(q\) be the number of CL model parameters and \(n\) be the number of training data points. The CL loss \(^{CL}() C\) (\(C\) is a constant). With high probability of \(1-\), the following bound holds:_

\[_{(,)} _{i}^{i=T}^{CL}_{_{i}}()_{ }_{}^{CL }()++_{i=1}^{i=T-1}N_{i}}+\] (18) \[(++_{i=1}^{ i=T-1}N_{i}))^{2}}+R+2(+_{i=1}^{i=T-1}N_{i}}{})}{4(N_{T} +_{i=1}^{i=T-1}N_{i}-1)}}\]

_Where \(\) is a constant. We denote the number of data examples for task \(1,,T-1\) in the memory buffer \(\) during training on task \(T\) as \(N_{1},N_{2},,N_{T-1}\) when using memory replay based approach or the number of training data points when using regularization based approach. \(^{CL}_{D}()\) denotes the CL loss on the data from data distribution \(_{i}\) of task \(i\) (generalization error), i.e., it is defined as: \(^{CL}_{D_{i}}():=_{(,y)},(,y,)\). \(^{CL}()\) denotes the empirical CL loss as Eq. (1). \((,)\) denotes the CL model parameter posterior distribution parameterized with Gaussian distribution.__Generalization bound implication:_ (1) When using a memory-replay approach, the number of samples from new tasks often exceeds the number of samples in the memory buffer, causing data imbalance. This imbalance, where fewer samples from previous tasks are stored, affects the second and third terms in the generalization bound. The bound suggests that as the number of samples in the memory buffer increases (i.e., \(_{i=1}^{i=T-1}N_{i}\)), these terms tighten, leading to a tighter generalization upper bound. This is because \(_{x}[h(x):=]=0\), meaning the generalization improves with a larger buffer, aligning with the intuition that more memory buffer data leads to better performance. (2) In the regularization-based approach, \(_{i=1}^{i=T-1}N_{i}\) is treated as the effective sample size for previous tasks since the loss is approximated in the absence of earlier data. The parameter \(\) controls the trade-off between learning the new task and retaining knowledge from past tasks. A larger \(\) increases regularization, preventing the model from deviating too much from the parameters learned on previous tasks. This leads to higher empirical loss on the new task (first term), but tighter bounds (second and third terms), indicating that knowledge from previous tasks is retained effectively. This prioritizes stability over learning flexibility for the new task.

## 5 Experiments

### Setup

**Datasets** We conduct experiments on several datasets, including CIFAR10 (10 classes), CIFAR100 (100 classes) , and Tiny-ImageNet (200 classes) , to assess the effectiveness of MACL in task incremental learning (Task-IL) and class incremental learning (Class-IL). In addition, we also conduct experiments on 5-dataset [79; 5], CUB200  and ImageNet-R  (in Appendix). Following the approach in , we split the CIFAR-10 dataset into five tasks, each with two distinct classes. We divided the CIFAR-100 dataset into ten tasks, each containing ten classes. We split the Tiny-ImageNet dataset into ten tasks, each comprising twenty classes. More dataset statistics can be found in Appendix E.1.

**Baselines** We compare to the following various SOTA CL methods. (1) Regularization-based methods, including oEWC , synaptic intelligence (SI) , Learning without Forgetting (LwF) , Classifier-Projection Regularization (CPR) . (2) Bayesian-based methods, including NCL . (3) Architecture-based methods, including HAT . (4) Memory-based methods, including ER , A-GEM , iCaRL, GSS , HAL , DER++ , ER-ACE  and LODE . (5) Gradient-projection-based methods: Gradient Projection Memory (GPM) .

**Implementation Details** Following , we use ResNet18  as the backbone network for all the CL datasets and compared baseline methods. For the baselines that are included in the open-source code of DER++ , we use the same hyperparameters provided in DER++  for the compared methods. For the baselines not included in the open-source code of DER++, e.g., GPM, LODE, etc, we use the open-source code from their original paper for comparisons. For the hyperparameters in our method, we set \(=1.0\) across all the datasets to minimize the model's dependence on hyperparameters. For \(\), we set \(=1e-5\) for CIFAR10 and CIFAR100, and \(=1e-6\) for Tiny-ImageNet. The \(\) is selected from the range of \([1e-4,1e-5,1e-6,1e-7]\). Following [7; 14], the hyperparameter is determined through the validation sets split from the training sets from the first three tasks. Similar to , we train all the CL models using the standard SGD optimizer to update the CL model. The batch size and replay buffer batch size are set to 32. We use a single NVIDIA A5000 GPU with 24GB memory to run the experiments. Each experiment result is averaged for 10 runs with mean and standard deviation.

### Results

We evaluate the performance of different CL methods with (1) overall accuracy; (2) new task accuracy; and (3) backward transfer in the following.

**Overall Accuracy (ACC)** ACC is the average accuracy across the entire task sequence. We present the results on CIFAR10, CIFAR-100 and Tiny-ImageNet in Table 1. We can observe that our method substantially improve over various SOTA baseline methods up to 3% to 4% on CIFAR100, TinyImageNet by integrating MACL with existing CL methods. This overall performance improvement is attributed to the reduced parameter sensitivity.

**New Task Accuracy** To evaluate the new task performance of the proposed CL method, we evaluate the new task performance during CL by integrating MACL with DER++ and GPM in Figure 1. The results show that MACL can significantly improves the new task performance for different CL methods, indicating that reducing the model parameter sensitivity is beneficial to improve new task performance during CL.

**Backward Transfer** Backward transfer (BWT) quantifies the degree of forgetting observed on previously learned tasks. When BWT \(>0\), it indicates that learning the current new task positively influences the performance on previously learned tasks. Conversely, when BWT \( 0\), it signals that learning the current new task may result in forgetting previously acquired knowledge. We evaluate BWT in Table 2. We can observe that our method significantly improves BWT by up to 5% through integrating MACL with existing CL methods. This indicates that reducing parameter sensitivity can substantially reduce forgetting on previously learned knowledge. These empirical analysis also verify our theoretical analysis that our method implicitly improves the stability by reducing loss variance.

    &  &  &  \\  & Class-IL & Task-IL & Class-IL & Task-IL & Class-IL & Task-IL \\  fine-tuning & \(19.62 0.05\) & \(61.02 3.33\) & \(9.29 0.33\) & \(33.78 0.42\) & \(7.92 0.26\) & \(18.31 0.68\) \\ Joint train & \(92.20 0.15\) & \(98.31 0.12\) & \(71.32 0.21\) & \(91.31 0.17\) & \(59.99 0.19\) & \(82.04 0.10\) \\  SI & \(19.48 0.17\) & \(68.05 5.91\) & \(9.41 0.24\) & \(31.08 1.65\) & \(6.58 0.31\) & \(36.32 0.13\) \\ LwF & \(19.61 0.05\) & \(63.29 2.35\) & \(9.70 0.23\) & \(28.07 1.96\) & \(8.46 0.22\) & \(15.85 0.58\) \\ NCL & \(19.53 0.32\) & \(64.49 4.06\) & \(8.12 0.28\) & \(20.92 3.23\) & \(7.56 0.36\) & \(16.29 0.87\) \\ GPM & — & \(90.68 3.29\) & — & \(72.48 0.40\) & — & — \\ UCB & — & \(79.28 1.87\) & — & \(57.15 1.67\) & — & — \\ HAT & — & \(92.56 0.78\) & — & \(72.06 0.50\) & — & — \\  A-GEM & \(22.67 0.57\) & \(89.48 1.45\) & \(9.30 0.32\) & \(48.06 0.57\) & \(8.06 0.04\) & \(25.33 0.49\) \\ GSS & \(49.73 4.78\) & \(910.2 1.57\) & \(13.60 2.98\) & \(57.50 1.93\) & — & — \\ HAL & \(41.79 4.46\) & \(84.54 2.36\) & \(9.05 2.76\) & \(42.94 1.80\) & — & — \\  oEWC & \(19.49 0.12\) & \(64.31 4.31\) & \(8.24 0.21\) & \(21.2 2.08\) & \(7.42 0.31\) & \(15.19 0.82\) \\ oEWC+MACL & \(\) & \(\) & \(\) & \(\) & \(\) & \(\) \\  CPR(EWC) & \(19.61 3.67\) & \(65.23 3.87\) & \(8.42 0.37\) & \(21.43 2.57\) & \(7.67 0.23\) & \(15.58 0.91\) \\ CPR(EWC)+MACL & \(\) & \(\) & \(\) & \(\) & \(\) & \(\) \\  GPM & — & — & — & \(72.48 0.40\) & — & \(30.72 0.27\) \\ GPM+MACL & — & — & — & \(\) & — & \(\) \\  iCaRL & — & — & \(44.16 1.53\) & \(84.06 0.42\) & \(23.71 0.23\) & \(59.24 0.16\) \\ iCaRL+MACL & — & — & \(\) & \(\) & \(\) & \(\) \\  ER & \(57.74 0.27\) & \(93.61 0.27\) & \(20.98 0.35\) & \(73.37 0.43\) & \(\) & \(48.64 0.46\) \\ ER+MACL & \(\) & \(\) & \(\) & \(\) & \(9.87 0.15\) & \(\) \\  DER++ & \(72.70 1.36\) & \(93.88 0.50\) & \(36.37 0.85\) & \(75.64 0.60\) & \(19.38 1.41\) & \(51.91 0.68\) \\ DER++MACL & \(\) & \(\) & \(\) & \(\) & \(\) & \(\) \\  ER-ACE & \(71.83 1.42\) & \(94.12 0.61\) & \(37.05 0.36\) & \(75.97 0.69\) & \(20.43 0.97\) & \(52.59 0.75\) \\ ER-ACE+MACL & \(\) & \(\) & \(\) & \(\) & \(\) & \(\) \\  LODE & \(75.45 0.90\) & \(\) & \(38.95 0.93\) & \(78.92 0.67\) & \(19.87 0.72\) & \(60.18 0.65\) \\ LODE+MACL & \(\) & \(94.32 0.24\) & \(\) & \(\) & \(\) & \(\) \\   

Table 1: **Task-IL and class-IL** overall accuracy on CIFAR10, CIFAR-100 and Tiny-ImageNet, respectively with memory size 500. ’—’ indicates not applicable/available.

Figure 1: new task performance during CL.

### Ablation Study

**Hyperparameter Analysis** We evaluate the sensitivity of the hyperparameters \(\) in Table 5 in Appendix D.1. Our observations indicate that when parameter sensitivity is not reduced, i.e., \(=0\), the CL model performs poorly. As we gradually increase the reduction of parameter sensitivity, the CL model's performance improves. This improvement is because appropriately reducing parameter sensitivity helps mitigate forgetting and enhances learning for new tasks, thus boosting overall CL performance. However, if the reduction in parameter sensitivity is increased excessively, the model's performance deteriorates. This is because an overly constrained model, while minimizing forgetting, struggles to learn new tasks effectively, resulting in worse performance.

**Effect of Memory Size** To assess the impact of varying memory buffer sizes, we present the results in Table 3. The results demonstrate that compared to different baseline methods, our MACL plug-in also enhances the performance of baseline methods with a memory size of 2000.

**Benefit of NGD** To evaluate the benefits of using NGD over gradient descent (GD) for calculating the worst-case Gaussian distribution, we present comparison results in Table 6 in Appendix D.2. The results show that NGD outperforms GD because NGD better captures parameter importance, which helps preserve old knowledge while effectively adapting to new tasks.

**Efficiency Evaluation** To assess the efficiency of our proposed method, we compare the running time of integration of different CL methods with MACL and corresponding CL methods alone on CIFAR100, as shown in Table 15 in Appendix D.8. The results indicate that incorporating MACL increases the computational cost by only 55% to 61% compared to the corresponding CL methods alone. This demonstrates the high efficiency of our method, as it introduces only small additional training cost.

**Effect of Different Architectures** To evaluate the impact of different architectures, we compared various approaches using both ViT and ResNet32. For the ResNet32 experiments, we followed the setup in , integrating MACL with MEMO  and comparing it to MEMO alone, using a memory buffer size of 2000 on CIFAR100. Additionally, we conducted experiments with a pre-trained Vision Transformer (ViT) , specifically the vit-base-patch16-224 model pre-trained on ImageNet1K. On CIFAR100, we integrated MACL with DER++, using a memory size of 500, and demonstrated that using a pre-trained ViT significantly improves CL performance. Moreover, combining MACL with DER++ further enhances CL performance with the pre-trained ViT. The results are presented in the Appendix.

  
**Method** &  &  &  \\   & Class-IL & Task-IL & Class-IL & Task-IL & Class-IL & Task-IL \\  finetuning & \(-96.39 0.12\) & \(-46.24 2.12\) & \(-89.68 0.96\) & \(-62.46 0.78\) & \(-78.94 0.81\) & \(-67.34 0.79\) \\  AGEM & \(-94.01 1.16\) & \(-14.26 1.18\) & \(-88.51 1.56\) & \(-45.43 2.32\) & \(-78.03 0.78\) & \(-59.28 1.08\) \\ GSS & \(-62.88 2.67\) & \(-7.73 3.99\) & \(-82.17 1.46\) & \(-33.98 1.54\) & — & — \\ HAL & \(-62.21 4.34\) & \(-5.41 1.10\) & \(-49.29 2.82\) & \(-13.60 1.04\) & — & — \\  ER & \(-45.35 0.07\) & -3.54 \( 0.35\) & \(-74.84 1.38\) & \(-16.81 0.97\) & **-75.24 \(\) 0.76** & \(-31.98 1.35\) \\ ER+MACL & **-34.43 \(\) 0.82** & **-3.31 \(\) 0.32** & **-73.17 \(\) 0.69** & **-15.73 \(\) 0.78** & \(-75.29 0.37\) & **-29.32 \(\) 0.42** \\  DER++ & \(-22.38 4.41\) & \(-4.66 1.15\) & \(-53.89 1.85\) & \(-14.72 0.96\) & \(-64.66 0.56\) & \(-27.21 1.23\) \\ DER++ & **-21.87 \(\) 1.67** & **-3.09 \(\) 1.31** & **-48.62 \(\) 1.56** & **-13.62 \(\) 0.35** & **-62.23 \(\) 0.78** & **-27.10 \(\) 0.43** \\  ER-ACE & -13.64 \(\) 0.95 & -3.28 \(\) 0.83 & \(39.51 1.23\) & \(-14.57 0.39\) & \(-46.07 0.83\) & **-28.35 \(\) 0.16** \\ ER-ACE+MACL & **-12.76 \(\) 1.23** & **-3.15 \(\) 0.57** & **-33.86 \(\) 1.37** & **-13.89 \(\) 0.57** & **-42.29 \(\) 0.50** & -28.41 \(\) 0.23 \\  LODE & -16.37 \(\) 0.67 & **-2.93 \(\) 0.19** & -53.23 \(\) 1.72 & -15.24 \(\) 0.76 & -55.89 \(\) 0.98 & -19.13 \(\) 0.56 \\ LODE+MACL & **-16.25 \(\) 0.73** & -3.16 \(\) 0.45 & **-52.67 \(\) 1.35** & **-15.11 \(\) 0.53** & **-55.61 \(\) 1.15** & **-18.17 \(\) 0.83** \\   

Table 2: **Backward Transfer of different CL methods with memory size 500.**

  
**Algorithm** &  &  \\ 
**Method** & **Class-IL** & **Task-IL** & **Class-IL** & **Task-IL** \\  ER & \(36.06 0.72\) & \(81.09 0.45\) & \(15.16 0.78\) & \(-85.19 0.69\) \\ ER+MACL & **37.83 \(\) 0.94** & **83.37 \(\) 1.35** & **17.08 \(\) 0.73** & **95.51 \(\) 0.53** \\  DER++ & \(50.72 0.71\) & \(82.43 0.38\) & \(24.21 1.09\) & \(62.22 0.87\) \\ DER+++MACL & **52.79 \(\) 0.85** & **84.07 \(\) 0.79** & **27.55 \(\) 1.43** & **64.28 \(\) 0.95** \\  LODE & \(54.32 0.56\) & \(85.79 0.67\) & \(31.03 1.27\) & **70.05 \(\) 0.59** \\ LODE+MACL & **54.76 \(\) 0.68** & **86.53 \(\) 0.58** & **32.16 \(\) 1.12** & 69.79 \(\) 0.53 \\   

Table 3: **Task-IL and class-IL overall accuracy on CIFAR-100 and Tiny-ImageNet, respectively with memory size 2000.**

**Long Task Sequence** To assess the effectiveness of the proposed approach across varying task lengths, we conducted experiments by splitting Tiny-ImageNet into sequences of 10 and 20 tasks. The Task-IL and Class-IL results for integrating DER++ with MACL, using a memory buffer size of 500, are presented in Table 4. These results demonstrate that even with longer task sequences, our method still significantly outperforms DER++.

**Online CL** Under the online CL setting, we evaluate the effectiveness of the proposed approach on CIFAR100 and Tiny-ImageNet by comparing with MKD  and PCR . The results are put in the Appendix.

**5-datasets results** To assess the effectiveness of MACL on the 5-Datasets benchmark [79; 5], which includes CIFAR-10, MNIST , Fashion-MNIST , SVHN , and notMNIST , we conducted experiments. This dataset provides a diverse range of CL tasks. We performed experiments on 5-Datasets, using a memory buffer size of 500, with MACL. The detailed results are provided in the Appendix.

**ImageNet-R and CUB200 results** We further evaluate the effectiveness of MACL on CUB200  and ImageNet-R , the results are shown in the Appendix.

## 6 Conclusion

In this paper, we address the challenge of balancing learning new tasks while preserving knowledge from previous ones in continual learning. We propose a model sensitivity-aware continual learning method that enhances both the model's ability to retain old knowledge and improve performance on new tasks. Specifically, our goal is to reduce model parameter sensitivity by optimizing CL performance for the worst-case parameter distribution within the neighborhood of the current model's parameter distribution. This approach improves stability in preserving old knowledge and mitigates overfitting on new tasks. We provide a comprehensive theoretical analysis of the proposed method, and extensive experiments on multiple datasets demonstrate its effectiveness, efficiency, and versatility.

**Limitation Discussion** Our method introduces additional training cost compared to existing continual learning approaches.

## Broader Impacts

Our work advances continual learning, which is beneficial to develop more adaptable and efficient AI. Our work has no negative societal impacts.

### Duality in Natural Gradient Descent for Exponential Family Distribution

**Theorem A.1**.: _Gradient of the loss \(()\) with respect to the expectation parameter \(\), i.e., \(_{}()\), is equal to the natural gradient with respect to natural parameter \(\), i.e., \(^{-1}_{}()\). This can be expressed as the following:_

\[_{}()=^{-1}_{} ()\] (19)

_In particular, NGD in natural parameter space can be equivalently performed through gradient descent with respect to the expectation parameters as the following:_

\[_{i+1}=_{i}-^{-1}_{}( {}_{i})=_{i}-_{}(_{i})\] (20)

_where \(\) is the learning rate and \(\) is the Fisher information matrix (FIM)._

Proof.: The exponential family distribution is defined as the following:

\[P_{}()=exp(,() -Z())\] (21)

According to the expectation of the score function is 0, we can obtain the following

\[=_{P_{}()}_{} P_{}()=_{P_{}()}[()-_{}Z()]=-_{}Z( {})\] (22)

Therefore,

\[=_{}Z()\] (23)

where the first equality is due to the fact that the expectation of the score function is zero.

We then derive the Fisher information matrix (FIM) as the following:

\[() :=_{P_{}()}[-_{}^{2 } P_{}()]\] (24) \[=_{P_{}()}[-_{}( _{} P_{}())]\] (25) \[=_{P_{}()}[-_{}( _{}(,()-Z())]\] (26) \[=_{P_{}()}[-_{}(()-_{}Z())]\] (27) \[=_{}\] (28) \[=_{}_{}Z()\] (29) \[=_{}^{2}Z()\] (30)

where \(:=\) denotes defined as. Then,

\[_{}=_{}^{2}Z()=\] (31)

Next,

\[_{}()=_{} _{}()=[_{}]^{-1 }_{}()=^{-1}_{} ()\] (32)

More general results on manifold can be found in .

### Theoretical and Generalization Analysis of MACL

**Lemma A.2**.: \(D_{ KL}(,)= u()() }{v()})d)-v())^{2 }}{v()}d\)Proof.: \[D_{}(,) = u()()}{v()})d {}\] (33) \[)^{2}}{v()}d \ \ ()\] (34) \[)^{2}}{v()}-1d \ ((1+))\] (35) \[=)-v())^{2}}{v()}d \] (36)

where the last equality is because

\[)-v())^{2}}{v()}d= )^{2}}{v()}-2 u()d+ v()d=)^{2}}{v()}-1\] (37)

Since \( u()d= v()d=1\)

**Theorem A.3**.: _Assume \(||_{v()}^{}||_{}d M\), we can obtain the following conclusion for Eq. (16):_

\[_{}^{CL}()d( )=^{CL}()}+(^{CL}()-^{CL}())^{2}}}{M}}\] (38)

_where \(^{CL}()}:=^{CL}()d ()\). We denote the variance of the random variable \(^{CL}()\) as \(Var(^{CL}())=(^{CL}()- ^{CL}()})^{2}=(^{CL}()-^{CL}()})^{2}d\)._

Proof.: We define a new distribution \(:=-\).

\[^{CL}()d() =^{CL}()d(()+ ())=^{CL}()}+ ^{CL}()d()\] (39) \[=^{CL}()}+(^{CL}( )-^{CL}()})d()+^{CL}()}d()\] (40)

By Lemma 4.1 and Holder's inequality, we can obtain the following:

\[D_{}(,) = u()()}{v()})d )-v())^{2}}{v( )}d\] (41) \[(u()-v())^{2}d|| {1}{v()}||_{}d\] (42) \[(u()-v())^{2}dM\] (43)

Therefore,

\[(u()-v())^{2}d\] (44)

\[(^{CL}()-^{CL}()})d() =(^{CL}()-^{CL}( )})(u()-v())d\] (45) \[^{CL}()-^{CL}()})^{2}d(u()-v())^{2}d }\] (46) \[(^{CL}()- ^{CL}()})^{2}}{M}}\] (47)The equality holds when the following condition holds:

\[u()-v()=a(^{CL}()-^{CL}()})\] (48)

where \(a\) is a constant.

\[^{CL}()}d() =^{CL}()}(u()-v( ))d\] (49) \[=^{CL}()}(u()-v( ))d\] (50) \[=0\] (51)

The last equality is because \((u()-v())d= u()d- v()d=1-1=0\)

Therefore, we can obtain the following conclusion:

\[_{}^{CL}()d( )=^{CL}()}+(^{CL}()-^{CL}()})^{2}}{M}}\] (52)

In this context, the CL loss variance across various sets of model parameters \(Var(^{CL}())\) serves as a measure of the CL model's sensitivity to parameter updates. Essentially, a smaller loss variance indicates lower parameter sensitivity in the CL model. However, directly optimizing the loss variance within the parameter distribution neighborhood is impractical, as it requires computing the loss variance across a large number of different sets of CL model parameters and training data points. In contrast, our method (MACL) offers an efficient and effective alternative. MACL implicitly minimizes the loss variance across different model parameter variations by optimizing CL performance solely on the worst-case CL model parameter distribution.

We denote the prior distribution as \(()=(_{p},_{p})\) and posterior distribution as \(()=(_{s},_{s})\)

**Theorem A.4** (Generalization bound of MACL).: _Let \(q\) be the number of CL model parameters and \(n\) be the number of training data points. The CL loss \(^{CL}() C\) (\(C\) is a constant). With high probability of \(1-\), the following bound holds:_

\[_{(,)} _{i}^{i=T}^{CL}_{_{i}}()_{ }_{}^{ CL}()++_{i=1}^{i=T-1}N_{i}}+\] (53) \[(++_{i=1}^{ i=T-1}N_{i})})^{2}+R+2(+_{i=1}^{i=T-1}N_{i}}{})}{4(N_{T} +_{i=1}^{i=T-1}N_{i}-1)}}\]

_Where \(\) is a constant. We denote the number of data examples for task \(1,,T-1\) in the memory buffer \(\) during training on task \(T\) as \(N_{1},N_{2},,N_{T-1}\) when using memory replay based approach or the number of training data points when using regularization based approach. \(^{CL}_{}()\) denotes the CL loss on the data from data distribution \(_{i}\) (generalization error), i.e., it is defined as: \(^{CL}_{_{i}}():=_{(,y) _{i}}(,y,)\). \(^{CL}()\) denotes the empirical CL loss as Eq. (1). \((,)\) denotes the CL model parameter posterior distribution parameterized with Gaussian distribution._

Proof.: We apply the PAC-Bayes theorem  that for any prior distribution, with probability \(1-\) over the CL training dataset \(\), the following bound holds:

\[_{()}[^{CL}_{ }()]_{()}[^{CL}_{}()]+}(()||())+()}{2 (n-1)}}\] (54)

The KL divergence between posterior and prior distribution can be calculated as the following:\[D_{ KL}({}()||())=_{}()}[({}())- (())]\] (55) \[=_{p}|}{|_{s}|}-_{}()}(-_{s})^{T}_{s}^{-1}(-_{s})+ _{}()}(-_{p} )^{T}_{p}^{-1}(-_{p})\] (56) \[=[_{p}|}{|_{s}|}-q+( _{s}-_{p})^{T}_{p}^{-1}(_{s}-_{p})+ Tr(_{p}^{-1}_{s})]\] (57)

We assume the following inequality:

\[_{p}|}{|_{s}|}+Tr(_{p}^{-1}_{s}) R+q, R 0\] (58)

Therefore,

\[D_{ KL}({}()||()) [R+(_{s}-_{p})^{T}_{p}^{-1}(_{s}-_{p})]\] (59)

According to , we have the following identity:

For a random variable \(}(,)\)

\[_{}(,)}(- ^{})^{T}(-^{})=(- ^{})^{T}(-^{})+Tr()\] (60)

where \(Tr\) denotes the trace of A matrix. Therefore, according to Eq. (60), we have the following two equations 61 and 62.

\[_{}()}(-_{s})^{T}_{s}^{-1}(-_{s})=(_{ s}-_{s})^{T}_{s}^{-1}(_{s}-_{s})+Tr(_{s}^{-1}_{s})=q\] (61) \[_{}()}(-_{p})^{T}_{p}^{-1}(-_{p})=(_{ s}-_{p})^{T}_{p}^{-1}(_{s}-_{p})+Tr(_{p}^{-1}_{s})\] (62)

We set \(=_{p}^{-}(_{s}-_{p})\). Then, \(||||^{2}=(_{s}-_{p})^{T}_{p}^{-1}(_{s}-_{p})\).

If \( N(,^{2})\), according to , we have the following inequality with probability of \(1-\)

\[||||^{2}^{2}(q+2+2 n) ^{2}(+)^{2}\] (63)

Then we partition the space of \(_{s}\) into two disjoint area that satisfy \((_{s}-_{p})^{T}_{p}^{-1}(_{s}-_{p} ) 2-R\) and \((_{s}-_{p})^{T}_{p}^{-1}(_{s}-_{p} )>2-R\).

(1) In the case of \((_{s}-_{p})^{T}_{p}^{-1}(_{s}-_{p} ) 2-R\), we take the maximum loss over \(_{s}\), we have the following inequality:

\[_{}()}[_{}^ {CL}()]_{(_{s}-_{p})^{T}_{p}^{-1} (_{s}-_{p}) 2-R}_{}()}^{CL}()\] (64)

(2) For the case of \((_{s}-_{p})^{T}_{p}^{-1}(_{s}-_{p} )>2-R\), we have \(_{}^{CL}() C\)

Combining case (1) and (2), we can obtain the following generalization bound:

\[D_{ KL}({},{}) [(_{s}-_{p})^{T}_{p}^{-1 }(_{s}-_{p})+R+q-q][||||^{2}+R]\] (65) \[[^{2}(+)^{2}+R]\] (66)

We have the following bound with probability of \(1-\):\[_{()}[_{ }^{CL}()] (1-)_{(_{s}-_{p})^{T} _{p}^{-1}(_{s}-_{p}) 2-R}_{ ()}^{CL}()+\] (67) \[(1-)_{D_{}(,) }_{()}^{CL}( )+\] (68)

Then, we can obtain the following generalization bound with probability of \(1-\):

\[_{(,)} _{i}^{i=T}_{_{i}}^{CL}()_{}_{}^{CL}()++_{i=1}^{i=T-1}N_{i}}+\] (69) \[(++_{i=1}^ {i=T-1}N_{i})})^{2}+R+2(+_{i=1}^{i=T-1}N_{i}}{}) }{4(N_{T}+_{i=1}^{i=T-1}N_{i}-1)}}\]

In this theorem, we provide the theoretical guarantee for the generalization analysis of our proposed method. This bound indicates by optimizing the MACL loss, our method tighten/reduce the generalization error of the CL method, thus improving the overall performance of our method.

## Appendix B Equation Derivation

### Exponential Family Distribution Details

According to the definition of expectation, we can obtain the following equation:

\[^{1}:=_{f(;,)} =\] (70)

According to the definition of covariance matrix,

\[ :=[(-)(-)^{T}]\] (71) \[=[^{T}-2+^{T}]\] (72) \[=[^{T}]-^{T}\] (73)

By rearranging the above equation, we can obtain the following:

\[[^{T}]=^{T}+\] (74)

Then, the conclusion follows:

\[^{1}:=_{f(;,)} =,^{2}:=_{f(;,)}^{T}=^{T}+\] (75)

### Worst-Case Gaussian Distribution NGD Derivations

Gradient of Loss \(()\) With Respect to \(\)Taking gradient with respect to \(\) as the following:

\[_{^{1}}()=_{}()}{^{1}}+_{ }()}{^{1}}=_{}()-2_{} ()\] (76)

In Eq. (76), the second equality is because the identity: \(}{^{1}}=,}{^{1}}=}{ {}}=-2\). (by Eq. (75))

\[_{^{2}}()=_{}()}{^{2}}+_{}()}{ ^{2}}=_{}()\] (77)

In Eq. (77), the second equality is because the identity: \(}{^{2}}=,}{^{2}}=\) (by Eq. (75))

According to Eq. (5), we set the natural parameters as:

\[^{1}:=^{-1},^{2}:=-^{-1}\] (78)* (1) _NGD with respect to \(^{2}\)_: According to Eq. (20 and 77), NGD with respect to \(^{2}\) can be obtained as: \[-_{i+1}^{-1}=-_{i}^{-1}-_{ ^{2}}(_{i})=-_{i}^{-1 }-_{}(_{i})\] (79) Then, obtain the following update: \[_{i+1}^{-1}=_{i}^{-1}+2_{}(_{i})\] (80)
* (2) _NGD with respect to \(^{1}\)_: Similarly, according to Eq. (20 and 76), NGD with respect to \(^{1}\) can be obtained as: \[_{i+1}^{-1}_{i+1}=_{i}^{-1}_{i}-( _{}(_{i})-2_{}(_{i})_{i})\] (81) By simplifying and rearranging Eq. (81), the following update for \(\): \[_{i+1}=_{i}-_{i+1}_{}(_{i})\] (82)

Mean and Covariance Updates DerivationsFollowing the results in [56; 26], we can obtain the following equation:

\[_{}_{ u()} (,)=_{ u()} _{}(,)\] (83) \[_{}_{ u()} (,)=_{ u( )}_{}^{2}(,)\] (84)

Then, we only need to calculate \(_{ u()}_{}( ,)\) and \(_{ u()}_{}^{ 2}(,)\). Here, since we assumed a general CL Gaussian distribution for the current CL parameter distribution, i.e., \(()=^{}(|_{0},_{0})\) and neighbourhood distribution, i.e., \(()=(|,)\). The detailed derivations for the gradient are present in the following:

\[_{}_{ u()} (,) =-_{ u()}_{ }^{CL}()+_{ u()}[_{} u()-_{} v( )]\] (85) \[=-_{ u()}_{ }^{CL}()-_{ u()}(-)^{-1}+_{  u()}(-_{0})_{0}^{-1}\] (86) \[=_{ u()}[-_{}^{CL}()+(-_{0})_{0}^ {-1}]\] (87)

\[_{}_{ u()} (,) =-_{ u()}_{ }^{2}^{CL}()+_{  u()}[ u()- v()]\] (88) \[=-_{ u()}_{ }^{2}^{CL}()+ _{ u()}[_{}^{ 2} u()-_{}^{2} v()]\] (89) \[=-_{ u()}_{ }^{2}^{CL}()+ _{ u()}[-^{-1}+_{0} ^{-1}]\] (90) \[=_{ u()}[-_{ }^{2}^{CL}()-^{-1 }+_{0}^{-1}]\] (91)

Plug-in the gradient derivation into Eq. (82 and 80), we can obtain the following results:

\[_{i+1}^{-1} =_{i}^{-1}+_{ u()}[-_{}^{2}^{CL}()- _{i}^{-1}+_{0}^{-1}]\] (92) \[=(1-)_{i}^{-1}+_{  u()}[-_{}^{2}^{CL}()+_{0}^{-1}]\] (93) \[_{i+1}=_{i}-_{i+1}_{ u()}[-_{}^{CL}()+ (_{i}-_{0})_{0}^{-1}]\] (94)

Finally, by using single sample from distribution \(\) with density \( u()\) to approximate the expectation. By plug-in \(=(^{2})\) and \(_{0}=(^{2})\) into the above equations, we can obtain the following updates:

\[_{i+1}=_{i}+_{i+1}^{2}[_{ {}}^{CL}(_{i})-(_{i}-_{0}) ^{-2}]\] (95) \[_{i+1}^{-2}=(1-)_{i}^{-2}+[- _{}^{2}^{CL}(_{i})+^{-2}]\] (96)

[MISSING_PAGE_FAIL:22]

[MISSING_PAGE_EMPTY:23]

[MISSING_PAGE_EMPTY:24]

### NeurIPS Paper Checklist

The checklist is designed to encourage best practices for responsible machine learning research, addressing issues of reproducibility, transparency, research ethics, and societal impact. Do not remove the checklist: **The papers not including the checklist will be desk rejected.** The checklist should follow the references and precede the (optional) supplemental material. The checklist does NOT count towards the page limit.

Please read the checklist guidelines carefully for information on how to answer these questions. For each question in the checklist:

* You should answer [Yes], [No], or [NA].
* [NA] means either that the question is Not Applicable for that particular paper or the relevant information is Not Available.
* Please provide a short (1-2 sentence) justification right after your answer (even for NA).

**The checklist answers are an integral part of your paper submission.** They are visible to the reviewers, area chairs, senior area chairs, and ethics reviewers. You will be asked to also include it (after eventual revisions) with the final version of your paper, and its final version will be published with the paper.

The reviewers of your paper will be asked to use the checklist as one of the factors in their evaluation. While "[Yes] " is generally preferable to "[No] ", it is perfectly acceptable to answer "[No] " provided a proper justification is given (e.g., "error bars are not reported because it would be too computationally expensive" or "we were unable to find the license for the dataset we used"). In general, answering "[No] " or "[NA] " is not grounds for rejection. While the questions are phrased in a binary way, we acknowledge that the true answer is often more nuanced, so please just use your best judgment and write a justification to elaborate. All supporting evidence can appear either in the main paper or the supplemental material, provided in appendix. If you answer [Yes] to a question, in the justification please point to the section(s) where related material for the question can be found.

IMPORTANT, please:

* **Delete this instruction block, but keep the section heading "NeurIPS paper checklist"**,
* **Keep the checklist subsection headings, questions/answers and guidelines below.**
* **Do not modify the questions and only use the provided macros for your answers**.

1. **Claims** Question: Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope? Answer: [Yes] Justification: Our abstract and introduction summarize the main contributions in our paper. Guidelines: * The answer NA means that the abstract and introduction do not include the claims made in the paper. * The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers. * The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings. * It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper.
2. **Limitations** Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] Justification: We dicussed the limitations of our work after conclusion.

Guidelines:

* The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.
* The authors are encouraged to create a separate "Limitations" section in their paper.
* The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.
* The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.
* The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.
* The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.
* If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.
* While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren't acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations.
3. **Theory Assumptions and Proofs** Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? Answer: [Yes] Justification: We provide the full set of assumptions and a complete (and correct) proof in Appendix. Guidelines: * The answer NA means that the paper does not include theoretical results. * All the theorems, formulas, and proofs in the paper should be numbered and cross-referenced. * All assumptions should be clearly stated or referenced in the statement of any theorems. * The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition. * Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material. * Theorems and Lemmas that the proof relies upon should be properly referenced.
4. **Experimental Result Reproducibility** Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? Answer: [Yes] Justification: Our contribution is a new continual learning algorithm. We described full implementation details for our proposed algorithm. Guidelines: * The answer NA means that the paper does not include experiments.

* If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.
* If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.
* Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.
* While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example 1. If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. 2. If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. 3. If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). 4. We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results.
5. **Open access to data and code** Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? Answer: [Yes] Justification: Code will be released. Guidelines: * The answer NA means that paper does not include experiments requiring code. * Please see the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details. * While we encourage the release of code and data, we understand that this might not be possible, so "No" is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark). * The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details. * The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc. * The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why. * At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable). ** Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
6. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: We provided detailed implementation details regarding training and test details, data splits, hyperparameters and type of optimizer. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material.
7. **Experiment Statistical Significance** Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? Answer: [Yes] Justification: We provided results standard deviation with multiple experiment runs. Guidelines: * The answer NA means that the paper does not include experiments. * The authors should answer "Yes" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. * The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions). * The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.) * The assumptions made should be given (e.g., Normally distributed errors). * It should be clear whether the error bar is the standard deviation or the standard error of the mean. * It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis of Normality of errors is not verified. * For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates). * If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text.
8. **Experiments Compute Resources** Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? Answer: [Yes] Justification: We provided sufficient information on the computer resources in implementation details. Guidelines: * The answer NA means that the paper does not include experiments.

* The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.
* The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.
* The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn't make it into the paper).
9. **Code Of Ethics** Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? Answer: [Yes] Justification: Our paper conforms, in every respect, with the NeurIPS Code of Ethics. Guidelines: * The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics. * If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics. * The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction).
10. **Broader Impacts** Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? Answer: [Yes] Justification: We discussed the societal impacts after conclusion. Guidelines: * The answer NA means that there is no societal impact of the work performed. * If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact. * Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations. * The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster. * The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology. * If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML).
11. **Safeguards** Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? Answer: [NA] Justification: The paper poses no such risks.

Guidelines:

* The answer NA means that the paper poses no such risks.
* Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.
* Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.
* We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort.
* **Licensees for existing assets*
* Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? Answer: [Yes] Justification: We have cited the code package produced by DER++ and the dataset used, e.g., CIFAR10, CIFAR100, TinyImageNet. Guidelines:
* The answer NA means that the paper does not use existing assets.
* The authors should cite the original paper that produced the code package or dataset.
* The authors should state which version of the asset is used and, if possible, include a URL.
* The name of the license (e.g., CC-BY 4.0) should be included for each asset.
* For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.
* If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.
* For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.
* If this information is not available online, the authors are encouraged to reach out to the asset's creators.
* **New Assets*
* Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? Answer: [NA] Justification: Our paper does not release new assets. Guidelines:
* The answer NA means that the paper does not release new assets.
* Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.
* The paper should discuss whether and how consent was obtained from people whose asset is used.
* At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file.
* **Crowdsourcing and Research with Human Subjects** Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)?Answer: [NA] Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines:

* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.
* According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector.
* **Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects** Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? Answer: [NA] Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines:

* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.
* We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.
* For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review.