# ProofNet: Autoformalizing and Formally Proving Undergraduate-Level Mathematics

Zhangir Azerbayev

Yale University

zhangir.azerbayev@yale.edu

&Bartosz Piotrowski

University of Warsaw

bartoszpiotrowski@post.pl

Hailey Schoelkopf

EleutherAI, Yale University

hailey.schoelkopf@yale.edu

&Edward W. Ayers

Carnegie Mellon University

contact@edayers.com

&Dragomir Radev

Yale University

dragomir.radev@yale.edu

&Jeremy Avigad

Carnegie Mellon University

avigad@cmu.edu

Work completed while at Carnegie Mellon University

###### Abstract

We introduce \(\), a benchmark for autoformalization and formal proving of undergraduate-level mathematics. The \(\) benchmarks consists of 371 examples, each consisting of a formal theorem statement in Lean 3, a natural language theorem statement, and a natural language proof. The problems are primarily drawn from popular undergraduate pure mathematics textbooks and cover topics such as real and complex analysis, linear algebra, abstract algebra, and topology. We intend for \(\) to be a challenging benchmark that will drive progress in autoformalization and automatic theorem proving. We report baseline results on statement autoformalization via in-context learning. Moreover we demonstrate improvements over our baselines by applying _prompt retrieval_ and _distilled backtranslation_.

## 1 Introduction

The creation of an automatic mathematician, that is, a system capable of autonomously posing conjectures and proving theorems, is a longstanding challenge in mathematics and artificial intelligence (Gelenter, 1959). In recent years, neural generative language modeling has emerged as a promising approach to automating aspects of mathematics (Rabe and Szegedy, 2021).

One approach to applying language models to mathematics has been to treat mathematical reasoning in natural language as a sequence learning task (Welleck et al., 2021, 2022; Lewkowycz et al., 2022). A key advantage of mathematical reasoning in natural language is the abundance of natural language mathematics data on the internet (Lewkowycz et al., 2022).

An alternative approach is to use language models to guide formal proof-search in an interactive theorem prover (ITP) (Whalen, 2016; Yang and Deng, 2019; Wang and Deng, 2020; Polu et al., 2022; Jiang et al., 2022; Lample et al., 2022; First et al., 2023). A salient advantage of this method is thatthe ITP acts as a verifier for the language model's reasoning, enabling the natural implementation of bootstrapping techniques such as expert iteration (Silver et al., 2017; Polu et al., 2022; Lample et al., 2022).

_Autoformalization_, the task of automatically formalizing mathematics, seeks to build a bridge between informal and formal mathematical reasoning (Wang et al., 2018; Szegedy, 2020; Wu et al., 2022; Jiang et al., 2023), with the potential of extracting a training signal from vast corpora of natural language mathematics data while still grounding a system's reasoning in verified formal logic. However, the small amount and low diversity of parallel data between informal and formal mathematics means that autoformalization suffers from a lack of standard benchmarks to guide progress in the field.

To remedy this gap, we propose ProofNet,2 a benchmark consisting of parallel natural language and formal mathematics that can be used to evaluate autoformalization and theorem proving. The ProofNet benchmark consists of 371 parallel formal theorem statements, natural language theorem statements, and natural language proofs sourced from the exercises of popular undergraduate-level pure mathematics textbooks. Formal statements are expressed in the Lean 3 theorem prover (de Moura et al., 2015), and depend on Lean's mathlib (mathlib Community, 2020).

Language-model-based theorem provers and autoformalization systems have typically been evaluated on benchmarks consisting of competition and olympiad-style problems (Zheng et al., 2022; Wu et al., 2022). While such problems require complex reasoning, their solutions only depend on a relatively small set of elementary facts about integers, real numbers, counting, and geometry. In contrast, modern research mathematics requires the mastery of a massive body of theory made up of thousands of definitions, lemmas, and theorems. The Lean 3 formalization of perfectoid spaces, an important definition in research-level arithmetic geometry, depends on over 3000 distinct theorems

Figure 1: A sample theorem statement from mathlib, show on the left, and a sample theorem statement from ProofNet, shown on the right. mathlib emphasizes including the most abstract and general formulations of mathematical results, whereas ProofNet predominantly tests the ability of models to apply those results to concrete problems.

and definitions [Buzzard et al., 2020]. How to effectively reason over such a large repository of knowledge is an important unsolved problem in applying language models to mathematics [Irving et al., 2016, Wu et al., 2022b, Tworkowski et al., 2022].

ProofNet falls short of requiring mastery of all of modern mathematics, but poses the still ambitious goal of reasoning over the core of an undergraduate mathematics, including basic analysis, algebra, number theory, and topology. We hope that this benchmark will spur the development of language models that are able to reason effectively over large knowledge bases.

In order to obtain stronger baselines on ProofNet, we train and open-source the proofGPT language models at scales of 1.3 billion and 6.7 billion parameters. These models are trained on the proof-pile, an 8.3 billion token dataset of mathematical text. To our knowledge, these are the only open-source language models fine-tuned for general mathematics.

We establish baselines for ProofNet theorem autoformalization using in-context learning [Brown et al., 2020]. Moreover, we introduce two novel theorem autoformalization methods that outperform our few-shot baselines. _Prompt retrieval_ uses nearest-neighbor search against an embedding database to create a prompt consisting of the mathlib declarations most relevant to a particular natural language theorem. _Distilled backtranslation_ is a method inspired by work in unsupervised machine translation [Lample et al., 2017, Han et al., 2021a] that finetunes a language model for autoformalization at a large scale without the need for parallel data.

## 2 The ProofNet Benchmark

Dataset collectionProblems in the ProofNet benchmark are primarily drawn from exercises in popular undergraduate mathematics textbooks. For a complete list of sources, see Appendix B. For a comparison of ProofNet to other mathematical reasoning evaluations, see Appendix C

Figure 2: **Left:** We focus our evaluation on three language models. The first is the _Code-davinci-002_ endpoint of the OpenAI API [Chen et al., 2021], which is pre-trained on a (proprietary) code dataset. The second is the proofGPT suite, which are pre-trained on the proof-pile dataset. Finally, we also finetune a proofGPT model using the distilled backtranslation methodology (see subsubsection 4.1.3). **Right:** Each example in the ProofNet benchmark consists of a natural language (NL) statement, a formal statement, and an NL proof. In this work, we focus our evaluation on statement autoformalization and informalization. The tasks of proof autoformalization and formal theorem proving are also supported by ProofNet.

Not all textbook exercises lend themselves naturally to formalization. In particular, we only consider for inclusion in ProofNet problems meeting the following criteria:

* _Self-containment_. Problems should only depend on the results commonly taught in an undergraduate curriculum. In particular, this rules out problems that are split into multiple sequentially dependent parts, or those using nonstandard notations.
* _Naturality of formalization_. Not all kinds of mathematical problems can be naturally formalized, such as word problems, and such problems are excluded. We do not include exercises that require computing an unknown quantity. We do not include problems that depend on parts of Lean's mathlib that are relatively less mature, such as Euclidean geometry or combinatorics.
* _Low risk of train-test overlap_. Because language models are often pre-trained on large corpora mined from the internet that include mathlib, we refrain from including statements that are in mathlib or are likely to be added to mathlib in the future. In practice, this means we avoid the abstract "theory-building" style of theorems that constitute mathlib, and instead choose problems that involve applying general results to specific cases. For more insight into the stylistic differences between mathlib and ProofNet problems, see Figure 1.

Beyond the above criteria, problems were selected for broad coverage of the undergraduate curriculum and to range in difficulty from straightforward applications of the definitions to those requiring tremendous creativity. Problems statements are transcribed into LaTeX and formalized by human annotators proficient in Lean. Natural language proofs are adapted from online solutions manuals, or in a few cases, written by the annotators.

Supported TasksAs ProofNet includes parallel natural language statements, natural language proofs, and formal statements, the dataset supports the evaluation of the following distinct tasks:

* _Formal theorem proving_. Given a formal statement of a theorem, produce a formal proof.
* _Informal theorem proving_. Given an informal statement, produce an informal proof. This facilitates direct comparison between formal and informal theorem proving approaches.
* _Autoformalization and informalization of statements_. Given an informal (formal) statement, produce a corresponding formal (informal) statement.
* _Autoformalization of proofs_. Given an informal theorem statement, its informal proof, and its formal statement, produce a formal proof.

## 3 The proofGPT models and the proof-pile dataset

In order to obtain stronger baselines on the ProofNet benchmark, we introduce the proofGPT language models and a text dataset named the proof-pile that these models are trained on. Many approaches to quantitative reasoning with language models depend on pre-training or fine-tuning a

   Source & Size (GB) & Tokens \\  arXiv.math & 13.6 & 8.0B \\ Stack Exchanges & 0.96 & 0.3B \\ Formal math libraries & 0.14 & 59M \\ ProofWiki + Wikipedia math articles & 0.02 & 6.6M \\ Open source books & 0.015 & 6.5M \\ MATH & 0.002 & 0.9M \\   

Table 1: Composition of the proof-pile.

model on large corpora of mathematical text, which significantly boosts downstream performance . Motivated by these results, we train and open-source the proofGPT models at sizes of 1.3 billion and 6.7 billion parameters.3 The proofGPT models are decoder-only causual language models initialized with Pythia weights ,4 and then fine-tuned on the proof-pile,5 a corpus of unstructured mathematical text gathered from internet sources whose composition is detailed in Table 1. The proof-pile contains roughly 8.3 billion GPT-NeoX  tokens. Fine-tuning was performed using the GPT-NeoX library . For training hyperparameters, see Appendix A. In Table 2, we show that the proofGPT models outperform Pythia base models at standard mathematical reasoning tasks.

## 4 Methodology and Experiments

In this work, we evaluate the capabilities of pre-trained language models on autotformalizing and informalizing theorem statements. Due to the engineering challenges of implementing neural theorem proving systems in Lean, we leave an investigation of formal theorem proving and proof autotormalization to future work.

### Autotformalization methods

We employ in-context learning with large language models as a strong baseline for the autotormalization of theorem statements . Moreover, we introduce two novel methods for boosting autotormalization performance above the few-shot baseline: _prompt retrieval_ and _distilled backtranslation_.

#### 4.1.1 Few-shot autotormalization and informalization

In-context learning is a simple and powerful method for adapting language models to sequence-to-sequence tasks .

   Model & arXiv.math perplexity & proof-pile perplexity \\  _1B parameters:_ & & \\ Pythia 1.4B & 3.82 & 4.12 \\ proofGPT 1.3B & 3.17 & 3.47 \\  _6B parameters:_ & & \\ Pythia 6.9B & 3.36 & 3.62 \\ proofGPT 6.7B & 3.12 & 3.43 \\   

Table 2: Comparison of model perplexities on the test set of the arXiv subset of the proof-pile and the entire proof-pile. Documents were joined using two newline characters and perplexity was calculated with a stride equal to the model’s context length, which is 2048 for all models shown.

For our in-context baselines, we perform inference using the OpenAI API's _Code-davinci-002_ endpoint [Chen et al., 2021] and the proofGPT 1.3B and 6.7B models. Prompts are listed are given in Appendix D.

Because there may be multiple ways to formalize the same statement in Lean and no general way to automatically verify whether two statements that are not definitionally equal have the same mathematical content, autoformalizations should be evaluated for correctness by a human expert. For similar reasons, informalizations should also be judged by human experts. In this work, model outputs are scored by the authors. Our open-source repository contains raw model outputs so that the author's judgements of correctness can be independently verified.

#### 4.1.2 Prompt retrieval

A blessing and a curse of current language models is that few-shot learning performance is highly sensitive to the exact prompt that is used [Kojima et al., 2022]. In particular, it is plausible that greater few-shot learning performance can be achieved by retrieving the few-shot examples that are most relevant to a particular question.

Following Liu et al. , we implement a _prompt retrieval_ procedure for statement autoformalization based on nearest neighbors search. Suppose we have a knowledge-base \(\) of formal statements. First, we generate an autoformalization \(\) of a statement \(x\) using our standard in-context procedure. Then we produce dense vector representations of \(\) and the formal statements in \(\). We retrieve the \(k\)-nearest-neighbors of \(\) in \(\), and include them in the few-shot prompt. For the precise format of the prompt, see Appendix D.

We opt to retrieve against \(\) instead of against \(x\) because this method was significantly more performant in our preliminary experiments.

In our experiments, we create a knowledge-base \(\) by taking our \(ys\) to be 90,530 statements from Lean mathlib and use \(k=4\). We use the OpenAI API's _embedding-ada-002_ endpoint Neelakantan et al.  to generate text embeddings.

#### 4.1.3 Distilled backtranslation

Due to the amount of domain expert time required to collect parallel corpora of natural language and formal mathematics, scaling up parallel datasets to the point where they are useful for supervised finetuning is impractical. In the face of this limitation, to finetune models on autoformalization we draw on prior work leveraging generative models for unsupervised translation between natural languages. In particular, we use _distilled backtranslation_, a methodology inspired by Han et al. [2021a].

Distilled backtranslation proceeds as follows. Suppose we have a large language model \(P_{LLM}()\) pre-trained on monolingual data in both the source and target language, a monolingual corpus \(\{Y_{i}\}\) in the target language. We wish to fine-tune a "student" model \(P_{}(Y|X)\) to translate a sequence \(X\) in the source language to a corresponding sequence \(Y\) in the target language. First, we manually construct a few-shot prompt \(C\) consisting of \(X|Y\) pairs. Then, we sample synthetic backtranslations \(X_{i} P_{LLM}(X|C,Y_{i})\). Finally, we fine-tune \(P_{}()\) on the synthetic pairs to predict \(P(Y|X)\).

In our experiments, we fine-tune proofGPT-1.3B using distilled backtranslation with informal mathematics as the source language and Lean 3 theorems as the target language. We use the theorems in Lean's mathlib as the target language's monolingual corpus. We use _Code-davinci-002_ as our teacher LM and proofGPT-1.3B as our student model. Fine-tuning hyperparameters are described in Appendix E 

## 5 Results and Discussion

### In-context learning

In Table 3, we present our experimental results for autoformalization and informalization of ProofNet theorem statements. Although conceptually simple and easy to implement, our _Code-davinci-002_ in-context learning baseline achieves highly nontrivial performance, correctly formalizing 12.9% of theorems. The proofGPT models do not formalize any statements correctly, likely owing to their smaller parameter count. However, they demonstrate some signal on the typecheck rate and BLEU metrics. Note that even generating statements that typecheck in Lean 3's strict type system is a nontrivial feat.

Informalization accuracy is much higher than formalization accuracy for all models, supporting the intuitive claim that informalization is an easier task than formalization. This result also suggests that large pre-trained language models have a strong grasp of the semantics of formal mathematics, and primarily struggle with generating lexically correct and type-correct Lean code.

We further observe that among _Code-davinci-002_'s generations that typecheck, roughly half are correct formalizations. This is consistent with our hypothesis that _Code-davinci-002_ has a strong grasp of the semantics of mathematics, since the model displays high accuracy conditional on having generated valid Lean.

### Prompt Retrieval and Distilled Backtranslation

In Table 3, we additionally include autoformalization scores for the prompt retrieval and distilled backtranslation models. Applying prompt retrieval to the _Code-davinci-002_ model significantly boosts performance, increasing accuracy by 2.7 points and, notably, increasing typecheck rate by 21.5 points.

Distilled backtranslation improves the autoformalization performance of the proofGPT 1.3B model not merely above the in-context performance of proofGPT 1.3B, but also above the in-context learning performance of proofGPT 6.7B.

    &  &  \\  Model & Typecheck rate & BLEU & Accuracy & Compile rate & BLEU & Accuracy \\  _Few-shot._ & & & & & & \\ proofGPT-1.3B & 5.9 & 8.1 & 0 & 77 & 5.1 & 4.3 \\ proofGPT-6.7B & 4.3 & 4.7 & 0 & 70 & 6.0 & 6.5 \\ _Code-davinci-002_ & 23.7 & 25.1 & 12.9 & 100 & 13.2 & 62.3 \\  _Prompt retrieval:_ & & & & & & \\ _Code-davinci-002_ & 45.2 & 14.8 & 15.6 & - & - & - \\  _Dist. backtrans._ & & & & & & \\ proofGPT-1.3B & 19.4 & 10.7 & 3.2 & - & - & - \\   

Table 3: Results of few-shot learning with LLMs on formalization and informalization of ProofNet statements; all cells are percentages. In addition to reporting autoformalization accuracy, we also report _typecheck rate_, which is the proportion of a model’s samples that are well-formed statements in Lean’s dependent type theory. If a model simply copies a formal statement from its prompt, we do not consider that a positive sample when calculating typecheck rate. For the informalization task, we also report _compile rate_, i.e., what proportion of the model’s samples produce LaTeX that compiles. The most common reason why informal generations fail to compile is that they contain Unicode characters frequently used in Lean’s mathlib but not accepted by the pflattex compiler. To calculate BLEU scores, we split on whitespace and use BLEU-4 with smoothing. Note that formalization BLEU scores being higher than informalization BLEU scores is likely because natural language contains more lexically distinct but semantically equivalent statements.

Automatic metricsTypecheck rate correlates strongly with formalization accuracy, and we recommend that typecheck rate be used as a predictor of autoformalization performance when evaluating accuracy is too costly. The BLEU metric correlates well with performance on many NLP tasks , but correlates poorly with performance code tasks . Our findings illustrate that just as with code, BLEU is a poor guide to formalization performance, as prompt retrieval increases _Code-davinci-002_ formalization accuracy but decreases BLEU by over 10 points.

### Qualitative Analysis

We ground our remaining analysis in four case studies: two that demonstrate successful formalizations produced by _Code-davinci-002_, and two that are representative of our methods' most common failure cases.

Case study 1.The following is a Lean formalization of exercise 4.21a in Walter Rudin's _Principles of Mathematical Analysis_ produced by _Code-davinci-002_:

|}  NL: Suppose \(K\) and \(F\) are disjoint sets in a metric space \(X,K\) is compact, \(F\) is closed. \\ Prove that there exists \(>0\) such that \(d(p,q)>\) if \(p K,q F\). \\  _Code-davinci-002_ output: \\ theorem exercise_4_21a {X : Type*} [metric_space X] {K F : set X} (hK : compact_space K) (hF : is_closed F) (hKF : disjoint K F) : \\ \(\) (\(:\)), \(>0\) (p q : X), \(\)\(\) \\  

In this example, _Code-davinci-002_ demonstrates strong knowledge of mathlib and some reasoning capability. For example, the model correctly identifies that metric scapes are denoted using a typeclass metric_space X, but closed sets are expressed using a predicate is_closed. Moreover, the model correctly renders a consequent that contains nested quantifiers. Finally, the model recognizes the equivalence between "if \(p K\) and \(q F\)" and "p \(\)", which demonstrates some logical reasoning ability. However, note that the formalization is not completely idiomatic, as [compact_space K] or (hK : is_compact K) would be preferred to the model's (hK : compact_space K).

Case study 2.The following problem, exercise 6.4.2 from Michael Artin's _Algebra_, is an example of vanilla _Code-davinci-002_ making a mistake that is rectified by prompt retrieval.

|}  NL: Prove that no group of order \(pq\), where \(p\) and \(q\) are prime, is simple. \\  _Code-davinci-002_ output: \\ theorem exercise_6\(4\)2 {G : Type*} [group G] [fittype G] {p q : N} (hp : nat.prime p) (hq : nat.prime q) (h : fintype.card G = p * q) : \\ \(\) simple_group G \\  _Code-davinci-002_ + retrieval output: \\ theorem exercise_6\(4\)2 {G : Type*} [group G] [fittype G] {p q : N} [hp : fact(nat.prime p)] [hq : fact(nat.prime q)] (h : fintype.card G = p * q) : \\ \(\) is_simple_group G \\  

Vanilla _Code-davinci-002_ makes a single lexical error: the model has correctly formalized the hypotheses of the problem, but has tried to use a nonexistent predicate simple_group instead of the correct is_simple_group. The retrieval-augmented model uses the correct declaration because one of the retrieved mathlib statements explicitly uses is_simple_group.

Case study 3.The following is an incorrect formalization of exercise 6.16 from Sheldon Axler's _Linear Algebra_ produced by _Code-davinci-002_. The retrieval-augmented _Code-davinci-002_ autocorrelation, not shown here, is also incorrect.

* NL: Suppose \(U\) is a subspace of \(V\). Prove that \(U^{}=\{0\}\) if and only if \(U=V\)

* _Code-davinci-002_ output: theorem exercise_6.16 {K : Type*} [field K] {V : Type*} [add_comm_group V] [vector_space K V] {U : subspace V} : U.orthogonal = {0} \(\) U = \(\)

* ProofNet label: theorem exercise_6.16 {K : Type*} [is_R_or_C K] [inner_product_space K V] (U : submodule K V) : U.orthogonal = \(\) U = \(\)

Here, _Code-davinci-002_ makes three straightforward lexical mistakes: in mathlib, vector spaces over a field \(K\) are denoted by module K V rather than vector_space K V, subspaces of a vector space by submodule K V rather than subspace V, and the trivial subspace is denoted by \(\) rather than {0}. However, the model also makes a much more significant logical error. In order for the orthogonal complement \(U^{}\) of a subspace to make sense, the space must be endowed with a _inner product space_ structure rather than merely a vector space structure, which is expressed in mathlib as inner_product_space K V. Furthermore, inner product spaces are only defined over the real and complex fields, so one must also declare [is_R_or_C K]. Reliably inferring these kinds of implicit hypotheses is a major challenge for autoformalization systems.

Case Study 4: Looping.When generating formal and natural language theorem statements with proofGPTs, the model will often repeatedly generate the same short phrase instead of producing a plausible theorem. For example, consider the attempted formalization of exercise 10.1.13 from Michael Artin's _Algebra_ generated by proofGPT 6.7B via in-context learning.

* NL: An element \(x\) of a ring \(R\) is called nilpotent if some power of \(x\) is zero. Prove that if \(x\) is nilpotent, then \(1+x\) is a unit in \(R\). proofGPT-6.7b output: theorem nilpotent_of_nilpotent_of_nilpotent_of_nilpotent

nilpotent_of_nilpotent_of_nilpotent_of_nilpotent_of_nilpotent_of_nilpotent_of_nilpotent_of_.

Prior work on decoding methods has shown that the likelihood of a repeated phrase increases with each repetition, and that greedy decoding generates text with higher likelihood than natural text (Holtzman et al., 2019). These two findings constitute a plausible explanation for repetitive looping if the correct autoformalization is assigned low likelihood by the model. We observe that repetitive looping does not occur with _Code-davinci-002_, suggesting that the problem may disappear with scale (although there are many other differences between our small-scale models and _Code-davinci-002_).

## 6 Related Work

Language modeling for theorem provingLanguage models have found success in theorem proving both in the natural language setting (Lewkowycz et al., 2022; Welleck et al., 2021), and within many major ITPs such as Metamath (Polu and Sutskever, 2020), Isabelle (Jiang et al., 2022; First et al., 2023), and Lean (Han et al., 2021; Polu et al., 2022). Popular benchmarks for evaluating language model-based provers are Hendrycks et al. (2021) and Welleck et al. (2021) for natural language, and Zheng et al. (2022) for formal.

AutoformalizationRecent work in autoformalization with language models was sparked by Wu et al. (2022), which demonstrated that models can autofnormalize Isabelle theorem statements via in-context learning. In Jiang et al. (2022), the authors demonstrate a method for autoformalizing proofs in Isabelle. However, their method depends on the availibility of a performant black-box automated theorem prover, which is not available for Lean at the time of writing.

Interactive Theorem ProvingWork in formal theorem proving and autoformalization depends on libraries of formalized mathematics. This work directly depends on Lean's mathlib, but indirectly benefits from lessons learned from other proofs systems such as Coq (Bertou and Casteran, 2004), Mizar (Grabowski et al., 2010), and Isabelle (Nipkow et al., 2002).

Unsupervised Machine TranslationBecause the amount of parallel formal and natural language text is negligible, autoformalization faces many of the same challenges as unsupervised machine translation (Lample et al., 2017; Conneau et al., 2018; Lample et al., 2018; Han et al., 2021a; Garcia et al., 2023). Our distilled backtranslation method is inspired by the distilled and iterated backtranslation algorithm of Han et al. (2021a). However, the authors of this work regard backtranslation as a temporary workaround and foresee that in-context learning will be enough to elicit maximal performance from a sufficiently good language model, as is now the case for unsupervised translation (Garcia et al., 2023).

## 7 Conclusion

We introduced ProofNet, a benchmarking consisting of parallel natural language theorem statements, natural language proofs, and formal theorem statements in Lean 3. We have shown that pre-trained large language models achieve non-trivial but far from consistent performance via in-context learning on the autoformalization of ProofNet statements. Moreover, we have proposed prompt retrieval and distilled backtranslation, two methods that improve autoformalization performance above baseline.