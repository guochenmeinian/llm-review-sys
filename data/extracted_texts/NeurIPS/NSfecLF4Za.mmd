# Object-Centric Semantic Vector Quantization

Yi-Fu Wu

Rutgers University

&Minseung Lee

KAIST

&Sungjin Ahn

KAIST

Correspondence to yifu.wu@gmail.com.

###### Abstract

Neural discrete representations are crucial components of modern neural networks. However, their main limitation is that the primary strategies such as VQ-VAE can only provide representations at the patch level. Therefore, one of the main goals of representation learning, acquiring conceptual, semantic, and compositional abstractions such as the color and shape of an object, remains elusive. In this paper, we present the first approach to _semantic_ neural discrete representation learning. The proposed model, called **S**emantic **V**ector-**Q**u**anized Variational Autoencoder (SVQ), leverages recent advances in unsupervised object-centric learning to address this limitation. Specifically, we observe that a simple approach quantizing at the object level poses a significant challenge and propose constructing scene representations hierarchically, from low-level discrete concept schemas to object representations. Additionally, we suggest a novel method for training a prior over these semantic representations, enabling the ability to generate images following the underlying data distribution, which is lacking in most object-centric models. In experiments on various 2D and 3D object-centric datasets, we find that our model achieves superior generation performance compared to non-semantic vector quantization methods such as VQ-VAE and previous object-centric generative models. Furthermore, we find that the semantic discrete representations can solve downstream scene understanding tasks that require reasoning about the properties of different objects in the scene.

## 1 Introduction

While there have been various findings regarding the purpose of the brain, it is fair to say that the human brain has at least two key functions. First, it constructs a good representation that captures the structure of the world through perception. Second, it imagines or generates various possibilities of the world. Similarly, AI systems that aim to be as generally capable as humans would also need to realize similar capabilities computationally. Building such a learning system that can both structurally _recognize_ and _generate_ has long been a desired vision in machine learning, from Helmholtz machines  to Variational Autoencoders . Although there could be various approaches to achieving this, in this work, we focus on a specific class of models, which we call Generative Structured Representation Models, which satisfy the following desiderata.

First, when it comes to representating a visual scene, it appears that we do not perceive the scene simply as a monolithic vector of features. Instead, we view it structurally and semantically, recognizing it as a composition of meaningful components such as objects and their attributes like shape, color, and position . Various works in AI, particularly object-centric approaches , havedemonstrated that this structural decomposition facilitates relational reasoning [9; 10; 11; 12] and out-of-distribution generalization [13; 10] due to improved compositional generalization. It has also been shown that a monolithic vector representation of a scene, such as VAE, fails in multi-object scenes [9; 13; 10].

Moreover, this structured and semantic understanding can be categorized and conceptualized _discretely_ in an unsupervised way. Such an ability is critical for organizing and comprehending the complexity of the environment, e.g., via language, as well as for implementing modularity  or symbolic reasoning . In AI, discrete representations are also useful to leverage powerful learning models like transformers. One of the most popular models for discrete representation learning in AI is VQ-VAE . It has been shown to be beneficial for image generation [17; 18] and probability density modeling . However, VQ-VAE and its variants, such as dVAE [20; 21] and VQ-GAN , represent a scene as a grid of small patches, lacking the capability to capture the scene's holistic structure and semantics.

Besides, the ability to generate samples that adhere to the observed data distribution is foundational for endowing AI the capabilities to imagine and simulate, e.g., for planning [22; 23]. However, only a certain class of representation learning models supports this essential ability. While models like Slot Attention  and SysBinder  offer structured, object-centric representations, in its original form it is unclear how to support density-based sampling. In contrast, VAE-based models, such as VAE and VQ-VAE, generally support this ability to sample from a prior distribution, but they either do not provide object-centric structures (VAE) or are limited to patch-based representations (VQ-VAE).

In this work, we observe that, despite its significance, there is currently no method that simultaneously satisfies all of the mentioned criteria of Generative Structured Representation Models, as summarized in Table 1. To address this issue, we propose the **S**emantic **V**ector-**Q**unatized (SVQ) Variational Autoencoder. Our model achieves discrete semantic decomposition by learning hierarchical, composable factors that closely align with the objects and the properties of objects in visual scenes. Similar to patch-based vector quantization methods, we can train an autoregressive prior to learn the distribution of the dataset. However, unlike VQ-VAE, we achieve this by learning the distribution of semantic discrete tokens, rather than patch tokens. As a result, the generation (or imagination) process is to compose semantic concepts such as objects and their attributes, rather than stitching a grid of patches.

In our experiments, we demonstrate the following practical benefits of our method. First, we find that for multi-object scenes, SVQ is able to model the prior distribution better than patch-based methods, as measured by the quality of the samples generated. Second, we find that SVQ representations outperform patch-based VQ representations on downstream tasks that require knowledge of the different properties of the objects in the scene. We also find evidence that SVQ representations can generalize better to out-of-distribution tasks compared to patch-based VQ representations and SysBinder continuous representations. Lastly, we show that despite introducing a discrete bottleneck, SVQ can work on the challenging CLEVRTex  dataset, one of the most complex datasets used in recent unsupervised object-centric representation learning models.

Our contributions are as follows: First, we introduce SVQ, the first model to obtain _semantic_ neural discrete representations without any supervision about the underlying factors in the scene. Second, by training a prior over these discrete representations, we are able to obtain an object-centric density model, capable of capturing the underlying data distribution and generating new samples. Third, we evaluate our model on several 2D and 3D datasets including the challenging CLEVRTex dataset, showing superior downstream task performance and image generation quality.

 
**Semantic** & **VAE** & **VQ-VAE** & **Slot Attention** & **SysBinder** & **SVQ (Ours)** \\ 
**Decomposition** & Factor & & Object & Object \& Factor & Object \& Factor \\ 
**Discrete** & ✗ & ✓ & ✗ & ✗ & ✓ \\ 
**Sampling** & ✓ & ✓ & ✗ & ✗ & ✓ \\ 

Table 1: Desiderata for Generative Structured Representation Models and Related Models

## 2 Background

### Vector-Quantized Variational Autoencoder (VQ-VAE)

The VQ-VAE  is a model that learns to compress high-dimensional data into a discretized latent space. The latent space is maintained by a codebook of prototype vectors \(^{K d}\) where \(K\) is the size of the codebook and \(d\) is the dimensionality of each prototype vector. An input **x** is first passed through encoder \(E()\) to obtain latents \(_{e}^{d}\). A nearest-neighbor lookup between \(_{e}\) and each of the prototype vectors in the codebook yields a quantized representation \(_{q}=(_{e})=_{k}\) where \(k=_{j}||_{e}-_{j}||_{2}\). The decoder \(D\) then uses \(_{q}\) to reconstruct the input: \(}=(_{q})\). The model is trained with the following loss:

\[=-}||_{2}^{2}}_{}+_{e}]-_{q}||_{2}^{2}}_{}+_{e}-sg[_{q}]||_{2}^{2}}_{ }\.\]

The first term is a reconstruction loss and is used to train the encoder and decoder. A straight-through estimator  is used to estimate the gradients through the quantization step by copying the gradients from \(_{q}\) to \(_{e}\). The second term is the codebook loss which encourages the prototype vectors in the codebook to be close to the output of the encoder. The third term, scaled by a constant hyperparameter \(\), is the commitment loss and helps to stabilize the training by encouraging the output of the encoder to not deviate too much from the chosen prototype vectors. Instead of the codebook loss, we use exponential moving average (EMA) updates on the codebook, which we found to speed up training in our experiments [17; 28; 29].

When VQ-VAEs are applied to images \(^{H W C}\), the encoder \(E()\) is typically implemented as a convolution encoder, outputting a feature map of latents \(_{e}^{H_{z} W_{z} d}\). This means that each latent corresponds to a local area represented by a convolutional feature cell and thus can only capture information in a local receptive field (Figure 0(a)). However, images typically contain multiple objects, and the discrete factors underlying visual scenes typically correspond to different properties of the objects in the scene, such as shape, color, type, and so on. The local patches from convolutional feature maps are inadequate to capture this rich structure.

### Object-Centric Representations

The goal of unsupervised object-centric representation learning is to decompose a scene into a set of representations each capturing a different object in the scene. It is shown that this structural decomposition, matching to the true factor structure of the world, facilitates some high-level cognition abilities such as relational reasoning [9; 10; 11; 12] and out-of-distribution generalization [13; 10]. We build on top of Slot Attention , a spatial attention-based object-centric representation method.

Given an image \(^{H W C}\), slot attention learns a set of slots, \(=\{_{1},,_{N}\}\), where \(_{n}^{d_{s}}\) and \(N\) is the total number of slots. An encoder is applied to **x** and, after adding a positional encoding, the result is flattened to an \(L\)-length input feature vector \(^{L d_{F}}\). Then, an iterative attention mechanism is used to spatially group the input features **F** to the slot representations **s**. First, the slots are randomly initialized from a Gaussian distribution with learned parameters. Then, in each iteration, the slots are used as queries in an _inverted_ version of dot-product attention  with the input features **F** as the keys and values. Instead of normalizing over the keys as is done in traditional dot-product attention, normalization is done over the queries (ie. slots). Additionally, a weighted mean is used to aggregate the values instead of the normal weighted sum, which is shown to stabilize training. The result is then used to update the slots with a per-slot GRU  followed by a per-slot residual MLP, both with shared parameters across the slots.

The slot representations are then used in a decoder to reconstruct the image and the entire model is trained with an image reconstruction loss. The original formulation of slot attention used a spatial broadcast decoder  to create masked images per slot which are then combined to form a final reconstructed image. Recently,  proposed using a transformer decoder to reconstruct the image while attending to the slots with cross attention. This method was shown to scale to more complex scenes than the spatial broadcast decoder  and is what we choose to use in our model.

## 3 Semantic Vector Quantization

Given a slot attention encoder that can obtain a set of representations of the objects in a scene, one may think of a hypothetical method, applying vector quantization to the slot representation itself to obtain a set of semantic discrete representations (Figure 0(b)). While these representations would indeed correspond to the different objects in a scene, this scheme would essentially require one codebook entry per possible object configuration and would be insufficient for anything beyond trivially simple scenes.

For example, consider a simple scene containing a single object in a fixed position that only varies by color and shape. Assume there are \(c\) possible colors and \(s\) possible shapes for the object. With slot-level quantization, in order to represent all the potential objects, the codebook would require at least \(c s\) entries. This is because each slot representation is a single entangled representation so each combination of factors needs to be represented by a separate code. If instead, we were able to disentangle the object-level representations into factor-level representations--representations that align with the underlying latent factors of variation of each object--we would be able to describe the potentially large combinatorial space of each object with a much small number of discrete factors. In the above example, if we had a fully disentangled representation of the color and the shape, we would be able to represent all possible scenes with \(c+s\) codes (Figure 0(c)). See Appendix A.2 for further discussion.

This observation motivates us to design an architecture that further disentangles slot representations to factor representations that reflect the underlying discrete factors of the objects in the scene, and to perform vector quantization on these factor representations. Under this scheme, each object representation would be composed of multiple discrete factors, and each factor would have its own codebook that can be shared across objects. The resulting model, the **S**emantic **V**ector-**Q**uantized Variational Autoencoder (SVQ), is depicted in Figure 1(a) and described below.

To obtain factored representations, we follow an approach motivated by Neural Systematic Binder (SysBinder) , where a binding mechanism is introduced to produce disentangled factors within a slot. Specifically, the following modifications are applied to slot attention: First, we maintain \(M\) codebooks \(^{M K dc}\), each with \(K\) discrete prototype vectors of dimension \(d_{c}=}{M}\). Then, we split each of the \(N\)\(d_{s}\)-dimensional slot representations into \(M\) equally-sized blocks, each of which will represent one factor. We denote the full set of block representations as \(_{e}^{N M d_{c}}\). Crucially, we replace the slot-level GRUs and residual MLPs with block-level equivalents that have shared parameters across blocks corresponding to the same factor. At the end of each slot attention iteration, we apply vector quantization for each block using its corresponding codebook to obtain a set of quantized blocks \(_{q}^{N M d_{c}}\). For \(n[1,N],m[1,M]\),

\[_{q}^{n,m}=_{m,k}k=*{arg\,min}_{ j}||_{e}^{n,m}-_{m,j}||_{2}\;,\]

Figure 1: Comparison between VQ-VAE, Quantized Slots, and SVQ. (a) VQ-VAE quantizes the scene at a local patch level and may not capture the semantic structure of the scene. (b) Quantized Slots (QS) would quantize the scene at the slot level but require a separate code for every possible configuration of an object. (c) SVQ quantizes at the block level, representing each factor (such as color or shape) as a code. In this example, to represent all possible object configurations, SVQ requires only 10 codebook entries at the block level while QS requires 25.

where \(_{q}^{n,m}\) denotes the \(m\)-th block in the \(n\)-th slot and \(_{m,k}\) is the \(k\)-th prototype vector in the \(m\)-th codebook. By sharing the codebook for each block across all of the slots, each block ends up specializing in different underlying factors of the objects in the scene, such as color, shape, and position. Thus, these quantized representations are semantic in the sense that they contain factor-level representations mapping to the underlying structure of the scene.

To reconstruct the image, we use the autoregressive transformer decoder described in Section 2.2 and condition on \(_{q}\) via cross attention. Similar to Singh et al. , we first let the blocks within a slot interact with a single-layer transformer and then add a block-level positional encoding before inputting the representations as cross attention in the transformer decoder. We train the model with the reconstruction loss, the VQ-VAE commitment loss, and we update the codebooks with EMA updates. To prevent codebook collapse, we also incorporate random restarts for the embeddings, similar to previous work . To achieve this, we keep a count of the usage of each code in the codebooks and randomly reset it to be near one of the encoder outputs of the current batch if its usage falls below a threshold.

### Semantic Prior

Given these semantic discrete codes representing the different objects in the scene, we can now freeze the SVQ and train an autoregressive prior \(p(_{q})\) over these codes to model the structure of the data (Figure 2b). We can then sample from this prior to obtain codes for new scenes and use these codes in the SVQ decoder to generate new images. Compared to patch-based VQ methods that generate tokens that correspond to a spatially local region of an image, this _semantic_ prior generates an image one object at a time, based on their properties.

We implement the prior using a simple autoregressive transformer decoder. First, we flatten \(_{q}\) along the slot and block dimensions to a vector with dimensions \(NM d_{c}\). We then apply a positional encoding across all slots and blocks and input the resulting vector to a transformer decoder with an objective of predicting the discrete code of the next block. Although slot attention does not guarantee any specific ordering of the slots, the blocks within the slots are arranged in a predefined order. Therefore, the positional encoding is important in providing information about the ordering of the blocks as well as which block belongs to which slot.

Note that generating the latents of one image requires sampling \(NM\) blocks, but does not depend on the size of the image. This is different than VQ-VAE, which scales with the size of the feature map and may become expensive for high-resolution images.

Figure 2: (a) Overall architecture of SVQ. We maintain \(M\) learned codebooks and split each slot into \(M\) blocks. At the end of each Slot Attention iteration, we apply vector quantization to each block representation to obtain a set of discrete codes for each slot. Each block ends up specializing in different underlying factors of variation for the objects in the scene. (b) The Semantic Prior. After training the model, we freeze SVQ and train and autoregressive prior over the discrete latent codes. Sampling from this prior allows us to generate an image one object at a time, based on their properties.

Related Work

**Neural Discrete Representation Learning**. Our work builds on top of neural discrete representation learning, which has played a pivotal role in the advancement of generative models for images in recent years [16; 17; 20; 18; 34]. These methods typically follow a two-stage approach. First, an image is encoded into a CNN feature map, which is then tokenized using vector quantization  into a set of discrete latent variables. In the second stage, a powerful autoregressive prior is then trained to model the distribution of these discrete tokens, allowing for sampling new images from this distribution. Our model also follows this two-stage approach, except our latents correspond to the properties of objects instead of cells in a CNN feature map.

**Unsupervised Object-Centric Learning**. Recent unsupervised object-centric learning methods have been shown to decompose an image or video into a set of latents, each representing an object in the scene [36; 37; 38; 24; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 47; 51; 25; 52; 33; 54; 55; 56; 9; 57; 58]. While most of these methods result in a distributed representation per object, there have been several attempts at learning more structured or disentangled representations, such as those methods that decompose the latents into what and where components [46; 59; 60; 61; 48; 47; 51; 49] or those that learn disentangled latents via a VAE [37; 58]. Closely related to our work, recent methods have been designed to learn factor-level disentanglement [25; 62]. However, these methods still operate with continuous latents instead of discrete tokens and do not support sampling new images. While there are several object-centric learning methods that do support sampling new images [40; 41; 48; 63], these also do not use semantic discrete latents as we do in our work.

## 5 Experiments

**Datasets.** We evaluate our model on two variants of a 2D Sprites dataset [64; 10] and three variants of the CLEVR dataset , CLEVR-Easy, CLEVR-Hard, CLEVR-Tex. In the 2D Sprites datasets, objects of varying shapes and colors are placed in a scene. In total, there are 7 possible colors and 12 possible shapes. In each image, one object has a single property that is unique from the other objects. All other properties are shared by at least two objects. This structure allows us to evaluate if the prior correctly models the dependencies between the properties of the scene. We test versions of this dataset with and without textured backgrounds . CLEVR-Easy, CLEVR-Hard, and CLEVR-Tex were previously used in  and are modified from the original CLEVR  and CLEVR-Tex  datasets to have larger objects so properties such as shape and texture are more clearly visible. In CLEVR-Easy, objects may differ by only shape, color, and position. In this dataset, there are 3 possible shapes and 8 possible colors. In CLEVR-Hard, objects may differ by shape, color, position, size, and material. There are 3 possible shapes, 137 possible colors, and 2 possible materials (shiny or matte). In CLEVR-Tex, there are 4 possible shapes and 58 possible textures for the objects and background.

**Baselines.** We compare our model with several patch-based quantization methods: VQ-VAE  with a PixelCNN  prior, and dVAE [20; 21] with a transformer decoder prior. For the dVAE baseline, we use the dVAE weights that are trained along with the SVQ. This provides a more direct ablation comparing the semantic prior of SVQ with the patch-based transformer decoder prior since the dVAE decoder is shared across these models and will not contribute to differences in image quality. We also compare with GENESIS-v2 , a continuous latent object-centric model with an autoregressive prior that can also generate samples.

### Generating Samples with Semantic Prior

#### 5.1.1 2D Sprites

We show the sample generations for the 2D Sprites datasets in Figure 3 and the FID results in Table 2. We additionally calculate generation accuracy by manually inspecting 128 images per model to check if the generated images follow the constraints of the dataset. That is, each image must have exactly one object that has a unique property. All other properties in the scene will have at least one duplicate among the other objects.

We see that for the simplest dataset with 3 objects and no background, SVQ achieves the lowest FID of the models and comparable generation accuracy to dVAE, generating about 75% of the scenescorrectly. This setting may be simple enough that dVAE with a transformer prior can capture the structure of the scene even with a patch-based discrete latent. As the scene complexity increases with more objects and textured background, SVQ starts to outperform the baselines in terms of generation accuracy. Inspecting the qualitative results, we see that in the dataset with the background, VQ-VAE and dVAE start generating occasional blurry objects, whereas SVQ maintains clean-looking objects that match the ground truth dataset. This may be because SVQ can segment the background into its own slot and factor the texture into a discrete latent, cleanly separating the representation of the objects from the background. The patch-based methods, however, may have a harder time separating the foreground from the background resulting in messier generations. Interestingly, despite the blurry shapes, VQ-VAE achieves the lowest FID score on the 2D Sprites dataset with background. We hypothesize this may be because the model spends more capacity modeling the background correctly instead of the foreground, which may produce a better FID score, but not necessarily better generation accuracy. This is confirmed by the low generation accuracy of the VQ-VAE model this dataset, only generating 19.5% of the scenes correctly.

#### 5.1.2 Clevr

In Figure 4, we show sample generations after training the models on the CLEVR-Easy, CLEVR-Hard, and CLEVR-Tex datasets. We report the Frechet Inception Distance (FID) in Table 3. We find that compared to the other models, GENESIS-v2 generates very blurry images and completely fails on CLEVR-Tex, resulting in a high FID. While VQ-VAE produces sharper images, several of the generated shapes are malformed or have mixed colors. The dVAE-generated images look closer to the ground truth dataset, but still have some errors such as overlapping objects (first image) and generating scenes with more objects than seen in the training set (third image). SVQ has the lowest FID for all of these datasets and the generated images look very close to the ground truth dataset, indicating the usefulness of having a semantic prior for generating these multi-object scenes.

In Appendix A.1, we show additional analysis of the learned codebook on the CLEVR-Easy dataset.

    &  &  \\   & VQ-VAE & dVAE & SVQ (ours) & VQ-VAE & dVAE & SVQ (ours) \\ 
2D Sprites (3 obj) & 14.81 & 7.26 & **6.61** & 28.91 & **75.78** & 75.00 \\
2D Sprites (4 obj) & 26.35 & 19.15 & **17.93** & 21.88 & 62.50 & **66.41** \\
2D Sprites w/ bg (4 obj) & **58.14** & 66.08 & 58.50 & 19.53 & 30.47 & **42.19** \\   

Table 2: FID and Generation Accuracy on the 2D Sprites datasets. For Generation Accuracy, 128 samples were inspected manually to determine if they matched the constraints of the scene (ie. exactly one unique property among all the shapes). Underlined numbers indicate a minor difference from the best value.

Figure 3: Generated samples for the 4-object 2D Sprites and 4-object 2D Sprites with background datasets.

    &  \\   & GENESIS-v2 & VQ-VAE & dVAE & SVQ (ours) \\  CLEVR-Easy & 115.56 & 57.06 & 40.30 & **32.50** \\ CLEVR-Hard & 93.01 & 73.33 & 65.89 & **43.12** \\ CLEVR-Tex & 225.08 & 178.59 & 112.80 & **84.52** \\   

Table 3: FID for the various models on the CLEVR datasets.

### Downstream Tasks

#### 5.2.1 Odd-One-Out

We first evaluate on a downstream supervised learning task on the 2D Sprites dataset. We modify the dataset by first dividing each image into four quadrants and ensuring exactly one object will be in each quadrant. As in our previous experiments, one object has a single property that is unique from the other objects. The goal of the task is to identify the quadrant of the odd-one-out object. We first pretrain the baseline models on a dataset containing all 12 possible shapes and 7 possible colors. Then, we freeze the underlying model and train a downstream model on top of the learned representations with the supervised objective. The downstream model is trained on a dataset that only contains 9 possible shapes and 4 possible colors. We then evaluate on both the in-distribution (ID) dataset and an out-of-distribution (OOD) dataset that consists of the remaining 3 shapes and 3 colors. In addition to dVAE and VQ-VAE, we use SysBinder as a baseline for this task, to compare its continuous representation with SVQ's discrete representation. For the latent representation of SVQ, we include variants that use the codebook indices (SVQ Indices) and the codebook prototype vectors (SVQ Codebook).

Table 4 shows the results of our experiments. Since all models can solve the task when evaluated on the ID dataset, we report the number of steps to reach 98% accuracy on the validation dataset. We find that SysBinder and SVQ Codebook learn the quickest in the ID setting. For the OOD setting, we find that dVAE and VQ-VAE fail completely, not performing better than randomly guessing, showing that the patch-based discrete latent is insufficient for OOD generalization in this task. SysBinder can partially solve the task in the OOD setting, while the SVQ Codebook seems to be able to solve the task, achieving 99% accuracy. This indicates that the compact latent space offered by the discrete code provides better out-of-distribution generalization abilities for this particular task. One possible explanation for this is that since this is an odd-one-out task, the downstream network needs to do

    & Steps to 98\% (\(\)) & OOD Acc. \% (\(\)) \\  dVAE & 37,000 & 26.7 \\ VQ-VAE Indices & 77,000 & 24.0 \\ SysBinder & **27,000** & 67.6 \\ SVQ Indices & 77,000 & 46.8 \\ SVQ Codebook & **27,000** & **99.1** \\   

Table 4: Results for the downstream odd-one-out task. Since all the models can solve the in-distribution (ID) task, we report the number of steps to 98% ID Accuracy and out-of-distribution (OOD) accuracy.

Figure 4: Generated samples for the CLEVR-Easy, CLEVR-Hard, and CLEVR-Tex Datasets.

    & ID Acc. \% (\(\)) & OOD Acc. \% (\(\)) \\  dVAE & 27.52 & 19.87 \\ VQ-VAE Indices & 24.53 & 17.74 \\ VQ-VAE Codebook & 23.73 & 18.80 \\ SysBinder & **79.60** & 70.09 \\ SVQ Indices & 68.21 & 64.53 \\ SVQ Codebook & 75.86 & **71.15** \\   

Table 5: Results for the downstream CLEVR-Hard Property Comparison task.

comparisons between the properties of the objects and this may be easier to do with SVQ's codebook vectors that are fixed. SysBinder's continuous latents, on the other hand, offer greater variations for the same concept. This increases the potential for the downstream network to learn spurious correlations in the data, which can negatively impact OOD performance. SVQ Indices is also only able to partially solve the task. This makes sense because in the out-of-distribution case, the model does not have any way of knowing two codebook indices are for the same property value (e.g. if two codebook vectors both correspond to the color blue). Since SVQ Codebook uses the prototype vectors, it does not have this problem because the similarity can be determined by the vector representation.

#### 5.2.2 CLEVR-Hard Property Comparison

For CLEVR-Hard, we construct a downstream task that assigns a number to each image as follows: First, we assign a number for each possible shape, color, and material present in the dataset. Then, for a given image, we identify the maximum number for each of these three properties. Lastly, we sum the max numbers for each of the properties to arrive at one integer label per image. We formulate the problem as a classification problem to correctly identify the number for each image. For example, suppose we have a scene containing a matte red cylinder and a shiny blue sphere. Assume we assign the following numbers to the different property values: \(=0\), \(=1\), \(=5\), \(=3\), \(=4\), \(=6\). Thus the two objects are represented by the numbers \((0,5,4)\) and \((1,3,6)\). The max numbers for each of the properties is \((1,5,6)\) and the final integer label is \(1+5+6=12\). Solving this task requires understanding the property values of each object in the scene.

We train the underlying models on the entire dataset consisting of all the possible property values. Then we randomly select 50 objects for an OOD dataset. Since our task relies on knowing the numerical value of each property, the ID dataset we train on may still contain property values of objects in the out-of-distribution dataset, but it will not contain objects where the combination of property values is present in the OOD dataset. Thus, when evaluating on the OOD dataset, we are testing the model on novel _combinations_ of property values, even if those property values were individually observed during training. We show the ID and OOD results in Table 5. We see that SVQ outperforms the patch-based methods and performs comparably to SysBinder in both ID and OOD settings. This shows that despite adding a discretization bottleneck, the latents in SVQ are still useful for downstream tasks that rely on the properties of the objects in the scene.

## 6 Conclusion and Limitations

In this work, we introduced the Semantic Vector-Quantized Variational Autoencoder. Unlike traditional vector quantization methods, our model can obtain semantic neural discrete representations, capturing the rich structure of the objects in a scene. We showed that by training a prior over these semantic discrete tokens, we are able to generate multi-object scenes that follow the underlying data distribution. These semantic discrete representations are also useful for downstream tasks, outperforming the representations from patch-based discretation methods. While our model is only evaluated on static images, an interesting future direction would be to apply our method to videos to predict future frames. This may be fruitful for modeling longer video sequences since SVQ can compress each frame into a set of latents that only depend on the number of objects in the scene.

**Limitations.** While our method can learn semantic discrete representations and is capable of using these representations to generate images of higher visual fidelity than previous object-centric methods such as GENESIS [40; 41], it is still only shown to work well on synthetic datasets with similar visual complexity as previous work . Although scaling unsupervised object-centric models to more realistic datasets is not a focus of this work, further improving our model so that it can work well on more realistic scenes is an important avenue of future research. Another limitation of our model is that our latent representations are _all_ discrete. Although our visual world does consist of many discrete concepts, factors such as position and pose are continuous. It would be interesting to explore ways to combine continuous and discrete factors to better model realistic scenes.