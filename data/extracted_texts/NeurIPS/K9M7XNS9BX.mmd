# Corruption-Robust Offline Reinforcement Learning

with General Function Approximation

 Chenlu Ye

The Hong Kong University of Science and Technology

cyeab@connect.ust.hk

&Rui Yang

The Hong Kong University of Science and Technology

ryangam@connect.ust.hk

&Quanquan Gu

University of California, Los Angeles

qgu@cs.ucla.edu

&Tong Zhang

The Hong Kong University of Science and Technology

tongzhang@ust.hk

These authors contributed equally to this work.

###### Abstract

We investigate the problem of corruption robustness in offline reinforcement learning (RL) with general function approximation, where an adversary can corrupt each sample in the offline dataset, and the corruption level \( 0\) quantifies the cumulative corruption amount over \(n\) episodes and \(H\) steps. Our goal is to find a policy that is robust to such corruption and minimizes the suboptimality gap with respect to the optimal policy for the uncorrupted Markov decision processes (MDPs). Drawing inspiration from the uncertainty-weighting technique from the robust online RL setting [18; 55], we design a new uncertainty weight iteration procedure to efficiently compute on batched samples and propose a corruption-robust algorithm for offline RL. Notably, under the assumption of single policy coverage and the knowledge of \(\), our proposed algorithm achieves a suboptimality bound that is worsened by an additive factor of \((((,}, _{n}^{H}))^{1/2}(C(},))^{-1/2}n^{-1})\) due to the corruption. Here \((,},_{n}^{H})\) is the coverage coefficient that depends on the regularization parameter \(\), the confidence set \(}\), and the dataset \(_{n}^{H}\), and \(C(},)\) is a coefficient that depends on \(}\) and the underlying data distribution \(\). When specialized to linear MDPs, the corruption-dependent error term reduces to \(( dn^{-1})\) with \(d\) being the dimension of the feature map, which matches the existing lower bound for corrupted linear MDPs. This suggests that our analysis is tight in terms of the corruption-dependent term.

## 1 Introduction

Offline reinforcement learning (RL) has received tremendous attention recently because it can tackle the limitations of online RL in real-world applications, e.g., healthcare  and autonomous driving , where collecting online data is risky, expensive and even infeasible. By leveraging a batch of pre-collected datasets, offline RL aims to find the optimal policy that is covered by the dataset without further interaction with the environment. Due to the restriction of the offline dataset, the utilization of pessimism in the face of uncertainty is widespread [1; 2; 53; 40; 16] and plays a central role inproviding theoretical guarantees for efficient learning [24; 36; 44; 48; 51; 56; 57; 63; 52]. Notably, these theoretical works demonstrate that a single-policy coverage is sufficient to guarantee sample efficiency.

In this paper, we study offline RL under adversarial corruption and with general function approximation. Adversarial corruption refers to adversarial attacks on the reward functions and transition dynamics on the data at each step before the learner can access the dataset. The learner only knows the cumulative corruption level and cannot tell whether the corruption occurs at each data point. Our corruption formulation subsumes the model misspecification  and the fixed fraction of data contamination  as special cases. Various real-world problems are under the threat of adversarial corruption, such as chatbots misled by discriminative or unethical conversations [32; 61], and autonomous vehicles tricked by hacked navigation instructions or deliberately contaminated traffic signs . On the other hand, general function approximation (approximating the value function with a nonlinear function class, such as deep neural networks) plays a pivotal role in modern large-scale RL problems, such as large language model , robotics  and medical treatment . Recent works have established different frameworks to explore the minimal structure condition for the function class that enables sample efficiency [19; 47; 9; 21; 14; 6; 64]. In particular, Wang et al.  leverage the concept of eluder dimension  and construct the least squares value iteration (LSVI) framework, which establishes optimism at each step for online RL.

For adversarial corruption and general function approximation, a significant amount of research has focused on the online setting. However, offline RL in this setting is still understudied due to restricted coverage conditions and lack of adaptivity. One notable exception is Zhang et al. , which assumes \(\)-fraction of the offline dataset is corrupted, and their algorithm suffers from a suboptimal bound on the corruption term. Our work moves a step further and achieves corruption robustness under the LSVI framework  in offline RL with general function approximation by generalizing the uncertainty weighting technique [18; 55]. We also propose an algorithm robust to an additional known distribution shift. Due to space limit, we defer it to Appendix C. We summarize our contributions as follows:

* We formally define the corruption level in offline RL. With knowledge of the corruption level, we design an algorithm that draws inspiration from the PEVI algorithm  and the uncertainty-weighting technique. The uncertainty for each data point, serving as the bonus function, is quantified by its informativeness with respect to the whole dataset. We propose the uncertainty weight iteration algorithm to calculate the weights efficiently and prove that the output, an approximation of the uncertainty, is sufficient to control the corruption term.
* Theoretically, our proposed algorithm enjoys a suboptimality bound of \(}(H^{1/4}( N)^{1/2}(C(},))^{-1/4}n^{-1/2}+^{1/2}(C(},))^{ -1/2}n^{-1})\), where \(H\) is the episode length, \(n\) is the number of episodes, \(N\) is the covering number, \(\) is the coverage coefficient, and \(C(},)\) is the coefficient depicting how well the underlying data distribution \(\) explores the feature space, and \(}\) is the confidence set. The corruption-dependent term reduces to \(( dn^{-1})\) in the linear model of dimension \(d\), thus matching the lower bound for corrupted linear MDPs. It is worth highlighting that our novel analysis enables us to eliminate the uncertainty-related weights from the coverage condition.
* Motivated by our theoretical findings, we present a practical offline RL algorithm with uncertainty weighting and demonstrate its efficacy under diverse data corruption scenarios. Our practical implementation achieves a \(104\%\) improvement over the previous state-of-the-art uncertainty-based offline RL algorithm under data corruption, demonstrating its potential for effective deployment in real-world applications.

### Related Work

**Corruption-Robust Bandits and RL.** There is an emerging body of theoretical literature on bandits and online RL with corruption. The adversarial corruption is first formulated in the multi-armed bandit problem by Lykouris et al. , where an adversary corrupts the reward in each round \(t\) by \(_{t}\) and the corruption level is measured by \(=_{t=1}^{T}|_{t}|\). Then, a lower bound with a linear dependence on \(\) is constructed by Gupta et al. , indicating that the ideal regret bound should achieve a "parallel" relationship: \((T)=o(T)+()\), and the corruption-independent term approximates the non-corrupted bound. When extending to linear contextual bandits, a line of work [4; 8; 13; 27; 62; 25] propose various methods but either derive sub-optimal regrets or require particular assumptions. The gap is later closed by He et al. , which achieves the minimax lower bound using a novel sample-dependent weighting technique. Specifically, the weight for each sample is adaptive to its confidence, which is also called uncertainty. Beyond bandits, earlier works on MDPs [5; 20; 23; 29; 33; 37; 38] consider the setting where only the rewards are corrupted, and the transitions remain intact. Wu et al.  begin to handle corruption on both rewards and transitions for tabular MDPs. Wei et al.  establish a unified framework for RL with unknown corruption under a weak adversary, where the corruption happens before the decision is made in each round. Later, Ye et al.  extend the weighting technique  to corrupted RL with general function approximation and achieve a linear dependence on the cumulative corruption level \(\). Particularly, Wei et al. , Ye et al.  both impose corruption on the Bellman operator, which is the same as the corruption model considered in this paper.

**Offline RL Against Attacks.** The emergence of poisoning attacks in real-world scenarios poses new challenges for offline RL and necessitates improved defenses . There are generally two types of attacks , namely test-time attacks and training-time attacks. In test-time attacks, the training data is clean, and the learned policy must contend with an attacker during test time. For example, Yang et al.  propose learning conservative and smooth policies robust to different test-time attacks. In contrast, our paper focuses on the training-time attack as another line of work [31; 49; 60], where part of the training data is corrupted maliciously. Wu et al.  propose two certification criteria and a new aggregation-based method to improve the learned policy from corrupted data. To the best of our knowledge,  is the only theoretical work on corrupted offline RL, which considers that an \(\)-fraction (\(=/nH\)) of samples are corrupted on both rewards and transitions for linear MDPs and achieves an \((^{1/2}dn^{-1/2})\) suboptimality bound. Notably, distinct from the setting in Zhang et al.  that clean data is first collected and then corrupted by an adversary, we consider the setting that data collection and corruption occur at the same time (thus corruption at one step affects the subsequent trajectory). Therefore, our setting is different from that of Zhang et al. .

## 2 Preliminaries

In this section, we formulate the episodic Markov decision process (MDP) with adversarial corruption and under general (nonlinear) function approximation. Before the formal introduction, we introduce some notations to facilitate our presentation.

**Notations.** Let \([n]\) denote the set \(\{1,,n\}\). For spaces \(\) and \(\) and a function \(f:\), let \(f(x)=_{a}f(x,a)\). Given a semi-definite matrix \(M\) and a vector \(v\), we define \(\|v\|_{M}=Mv}\). For two positive sequences \(\{f(n)\}_{n=1}^{}\), \(\{g(n)\}_{n=1}^{}\), let \(f(n)=(g(n))\) if there exists a constant \(C>0\) such that \(f(n) Cg(n)\) for all \(n 1\), and \(f(n)=(g(n))\) if there exists a constant \(C>0\) such that \(f(n) Cg(n)\) for all \(n 1\). We use \(}()\) to omit polylogarithmic factors. Sometimes we use the shorthand notation \(z=(x,a)\).

### Episodic MDPs

We consider an episodic MDP \((,,H,,r)\) with the state space \(\), action space \(\), episode length \(H\), transition kernel \(=\{^{h}\}_{h[H]}\), and reward function \(r=\{r^{h}\}_{h[H]}\). Suppose that the rewards are bounded: \(r^{h} 0\) for any \(h[H]\), and \(_{h=1}^{H}r^{h}(x^{h},a^{h}) 1\) almost surely. Given any policy \(=\{^{h}:\}_{h[H]}\), we define the Q-value and V-value functions starting from step \(h\) as

\[Q_{}^{h}(x^{h},a^{h})=_{h^{}=h}^{H}_{}r^{h^{ }}(x^{h^{}},a^{h^{}})\,|\,x^{h},a^{h}, V_{}^{ h}(x^{h})=_{h^{}=h}^{H}_{}r^{h^{}}(x^{h^{ }},a^{h^{}})\,|\,x^{h}.\] (1)

where the expectation \(_{}\) is taken with respect to the trajectory under the policy \(\). There exists an optimal policy \(_{*}\) and optimal value functions \(V_{*}^{h}(x):=V_{*}^{h_{*}}(x)=_{}V_{}^{h}(x)\) and \(Q_{*}^{h}(x,a):=Q_{^{*}}^{h}(x,a)=_{}Q_{}^{h}(x,a)\) that satisfy the Bellman optimality equation:

\[Q_{*}^{h}(x,a)=_{r^{h},x^{h+1}}r^{h}(s,a)+_{a^{} }Q_{*}^{h+1}(x^{h+1},a^{})\,|\,x,a:=(^{ h}Q_{*}^{h+1})(x,a),\] (2)

where \(^{h}\) is called the Bellman operator. Then we define the Bellman residual as

\[^{h}(f,x^{h},a^{h})=f^{h}(x^{h},a^{h})-(^{h}f^{h+1})(x^ {h},a^{h}).\] (3)

### General Function Approximation

We approximate the Q-value functions by a function class \(=_{1}_{H}\) where \(_{h}:\) for \(h[H]\), and \(f_{H+1} 0\) since no reward is generated at step \(H+1\). Generally, the following assumption is common for the approximation function class.

**Assumption 2.1** (Realizability and Completeness).: _For all \(h[H]\), \(Q_{*}^{h}^{h}\). Additionally, for all \(g^{h+1}(x^{h+1})\), \((^{h}g^{h+1})(x^{h},a^{h})^{h}\)._

The realizability assumption  ensures the possibility of learning the true Q-value function by considering the function class \(\). The Bellman completeness (adopted from Wang et al.  and Assumption 18.22 of Zhang ) is stronger than that in Jin et al. . The former applies the least squares value iteration (LSVI) algorithm that establishes optimism at each step, while the latter proposes the GOLF algorithm that only establishes optimism at the first step. We use the standard covering number to depict the scale of the function class \(\).

**Definition 2.1** (\(\)-Covering Number).: _The \(\)-covering number \(N(,,)\) of a set \(\) under metric \(\) is the smallest cardinality of a subset \(_{0}\) such that for any \(f\), there exists a \(g_{0}\) satisfying that \((f,g)\). We say \(_{0}\) is an \((,)\) cover of \(\)._

### Offline Data Collection Process

**Offline Clean Data.** Consider an offline clean dataset with \(n\) trajectories \(=\{(x_{i}^{h},a_{i}^{h},r_{i}^{h})\}_{i,h=1}^{n,H}\). We assume the dataset \(\) is compliant with an MDP \((,,H,,r)\) with the value functions \(Q,V\) and the Bellman operator \(\): for any policy \(\),

\[(^{h}Q_{}^{h+1})(x_{i}^{h},a_{i}^{ h}) =r^{}+V_{}^{h+1}(x^{})\{(x_{j}^{h},a_{j}^{h} )\}_{j[i]},\{r_{j}^{h},x_{j}^{h+1}\}_{j[i-1]},Q_{}^{h+1}\] \[=r^{h}(x^{h},a^{h})=r^{},x^{h+1}=x^{ }|x^{h}=x_{i}^{h},a^{h}=a_{i}^{h},\] (4)

where the realizability and completeness in Assumption 2.1 hold. The compliance assumption (4) is also made in Jin et al. , Zhong et al. , which means that \(\) remains the Markov property and allows \(\) to be collected by an adaptive behavior policy. The induced distribution of the state-action pair is denoted by \(=\{^{h}\}_{h[H]}\).

**Adversarial Corruption.** During the offline dataset collection process, after observing the state-action pair \((x^{h},a^{h})\) chosen by the data collector, an adversary corrupts \(r^{h}\) and \(x^{h+1}\) at each step \(h\) before they are revealed to the collector. For the corrupted dataset \(\), we define the corrupted value function \(Q_{},\ V_{}\), and the Bellman operator \(_{}\) satisfying (4). To measure the corruption level, we notice that characterizing the specific modification on each tuple \((s,a,s^{},r)\) is hard and unnecessary since once one modifies a tuple, the subsequent trajectory changes. Therefore, it is difficult to tell whether the change is caused by the corruption at the current step or a previous step. In fact, we only care about the part of the change that violates the Bellman completeness. Therefore, following the online setting [55; 48], we measure the corruption level by the gap between \(_{}\) and \(\) as follows.

**Definition 2.2** (Cumulative Corruption).: _The cumulative corruption is \(\) if at any step \(h[H]\), for a sequence \(\{(x_{i}^{h},a_{i}^{h})\}_{i,h=1}^{n,H}\) chosen by the data collector and a sequence of functions \(\{g^{h}:\}_{h=1}^{H}\), we have for all \(h[H]\),_

\[_{i=1}^{n}|_{i}^{h}|^{h},_{h=1}^{H}^{h}:=,\]

_where \(_{i}^{h}=(^{h}g^{h+1}-_{}^{h}g^{h+1})(x _{i}^{h},a_{i}^{h})\)._

The **learning objective** is to find a policy \(\) that minimizes the suboptimality of \(\) given any initial state \(x^{1}=x\): \((,x)=V_{*}^{1}(x)-V_{}^{1}(x),\) where \(V()\) is the value function induced by the uncorrupted MDP.

## 3 Algorithm

In this section, we first highlight the pivotal role that uncertainty weighting plays in controlling the corruption-related bound. To extend the uncertainty weighting technique to the offline setting, we propose an iteration algorithm. With the proposed algorithm, the theoretical result for the suboptimality is presented.

### Uncertainty-Related Weights

In this subsection, we discuss the choice of weight for a simplified model without state transition (\(H=1\)) and use the notation \(z_{i}=(x_{i},a_{i})\). Given a dataset \(\{(z_{i},y_{i})\}_{i[n]}\), we have \(y_{i}=f(z_{i})+_{i}+_{i}\) for \(i[n]\), where \(\) is the uncorrupted true value, the noise \(_{i}\) is zero-mean and conditional \(\)-subGaussian, and the corruption level is \(=_{i=1}^{n}|_{i}|\).

We begin with delineating the consequence caused by the adversarial corruption for the traditional least-square regression: \(=_{f}_{i=1}^{n}f(z_{i})-y_{i}^{2}.\) Some calculations lead to the following decomposition:

\[_{i=1}^{n}((z_{i})-(z_{i}))^{2}=^{n} ((z_{i})-y_{i})^{2}-((z_{i})-y_{i})^{2}}_{I_{1}  0}+2^{n}((z_{i})-(z_{i}))_{i }}_{I_{2}}+2^{n}((z_{i})-( z_{i}))_{i}}_{I_{3}}.\]

The term \(I_{1} 0\) since \(\) is the solution to the least-square regression. The term \(I_{2}\) is bounded by \(}( N)\) because of the \(\)-subGaussianity of \(_{i}\), where \(N\) is the covering number of \(\). The term \(I_{3}\) is ruined by corruption: \(I_{3} 2_{i=1}^{n}|_{i}|=()\). Hence, the confidence radius \((_{i=1}^{n}((z_{i})-(z_{i}))^{2})^{1/2}=} ()\) will explode whenever the corruption level \(\) grows with \(n\).

To control the corruption term, motivated by the uncertainty-weighting technique from online settings [55; 18; 65], we apply the weighted regression: \(=_{f}_{i=1}^{n}f(z_{i})-y_{i}^{2}/ _{i}^{2},\) where ideally, we desire the following uncertainty-related weights:

\[_{i}^{2}=1, })-f^{}(z_{i})|}{^{n }(f(z_{j})-f^{}(z_{j}))^{2}/_{j}^{2}}}}_{},  i=1,,n,\] (5)

where \(,>0\) are pre-determined parameters. The uncertainty quantity in the above equation is the supremum of the ratio between the prediction error \(|f(z_{i})-f^{}(z_{i})|\) and the training error \(^{n}(f(z_{j})-f^{}(z_{j}))^{2}/_{j}^{2}}\) over \(f,f^{}\). Intuitively, the quantity depicts the relative information of a sample \(z_{i}\) against the whole training set \(\{z_{1},,z_{n}\}\). We can use the linear function class as a special example to explain it. When the function space \(^{h}\) is embedded into a \(d\)-dimensional vector space: \(^{h}=\{ w(f),():z\}\), the uncertainty quantity becomes

\[_{f,f^{}} ),(z_{i})|}{^{n}(w(f)-w(f^{}),(z_{j})^{2}/_{j}^{2}}} _{f,f^{}}),(z_{i})|}{w(f)-w(f^{})^{} (w(f)-w(f^{}))}}\] \[(z_{i})^{-1}(z_{i})},\]

where \(=_{j=1}^{n}(z_{j})^{}(z_{j})/_{j}^{2}\). Moreover, \(^{}(z_{i})^{-1}(z_{i})^{-1}\) represents the effective number of samples in the \(\{z_{i}\}_{i=1}^{n}\) along the \((z_{i})\)'s direction. We discuss in Lemma B.3 that under mild conditions the linear and nonlinear uncertainty quantities are almost equivalent.

However, since the uncertainty also depends on weights, it is impossible to determine all the weights \(\{_{i}\}_{i[n]}\) simultaneously. Compared with the online setting where the weight in each round can be determined sequentially (iteratively in rounds), we face two challenges in the offline setting: (a) how to compute uncertainty-related weights iteratively? (b) will an approximate solution to the uncertainty play an equivalent role in controlling the corruption term?

To solve the first challenge, we propose the weight iteration algorithm in Algorithm 1. Moreover, we demonstrate the convergence of this algorithm by the monotone convergence theorem in the following lemma, which ensures that the output weights are sufficiently close to desired ones (5). The proof is provided in Appendix B.1.

**Lemma 3.1**.: _There exists a \(T\) such that the output of Algorithm 1\(\{_{i}:=_{i}^{T+1}\}_{i=1}^{n}\) satisfy:_

\[_{i}^{2}1,(z_{i})/2,_{i}^{2} 1,(z_{i}),\] (6)

_where \((z_{i})=_{f,f^{}})-f^{}(z_{i}) |/}{^{n}(f(z_{j})-f^{}(z_{j}))^{2}/_{j }^{2}}}\)._For the second challenge, the weighted version \(L_{n}:=_{i=1}^{n}((z_{i})-(z_{i}))^{2}/_{i}^{2}\) can also be decomposed into three terms correspondingly. We can demonstrate that an approximate choice of weights satisfying (6) is sufficient to control the corruption term as

\[_{i=1}^{n}(z_{i})-(z_{i}))_{i}}{_{i}^{2}}= _{i=1}^{n}(z_{i})-(z_{i})|_{i}}}{_{i}^{2}^{n}((z_{j})-(z_{j}))^{2} /_{j}^{2}}} 2}.\]

Since the corruption-unrelated terms (corresponding to \(I_{1},I_{2}\)) can still be bounded by \(}( N)\), we have \(L_{n}=}( N+2})\), leading to an \(}(+)\) confidence radius. Therefore, with a sufficiently small \(\), the effect of corruption can be countered.

### Corruption-Robust Algorithm

```
1:Input:\(=\{(x_{i}^{h},a_{i}^{h},r_{i}^{h})\}_{i,h=1}^{n,H},\)
2:Initialization: Set \(f_{n}^{h+1}() 0\)
3:for step \(h=H,H-1,,1\)do
4: Choosing weights \(\{_{i}^{h}\}_{i=1}^{n}\) by proceeding Algorithm 1 with inputs \(\{(x_{i}^{h},a_{i}^{h})\}_{i=1}^{n},^{h},\)
5: Find the weighted least-squares solution in (7)
6: Find \(^{h}\) and construct confidence set \[}^{h}=\{f^{h}:+_{i=1}^{n}(f(x_{ i}^{h},a_{i}^{h})-^{h}(x_{i}^{h},a_{i}^{h}))^{2}/(_{i}^{h})^{2} (^{h})^{2}\}\]
7: Construct bonus function as (8)
8: Let \(f_{n}^{h}(,)=(0,^{h}(,)-^{h}b^{h}( ,))\)
9: Set \(^{h}()=*{argmax}_{a}f_{n}^{h}(,a)\)
10:endfor
11:Output: \(\{^{h}\}_{h=1}^{H}\) ```

**Algorithm 2** CR-PEVI

Now, for the offline RL with general function approximation, we integrate the uncertainty weight iteration algorithm with the pessimistic value iteration (PEVI) algorithm , and propose a Corruption-Robust PEVI (CR-PEVI) in Algorithm 2. Our algorithm employs backward induction from step \(H\) to 1. Set estimated value function \(f_{n}^{H+1}()=0\). At each step \(h[H]\), having obtained \(f_{n}^{h+1}\), we calculate \(f_{n}^{h}\) by solving the following weighted least-square regression:

\[^{h}=*{argmin}_{f^{h}^{h}}_{i=1}^{n} {(f(x_{i}^{h},a_{i}^{h})-r_{i}^{h}-f_{n}^{h+1}(x_{i}^{h+1}))^{2}}{(_{i}^ {h})^{2}},\] (7)

where the weights are obtained via Algorithm 1. As opposed to online RL where the necessity of exploration stimulates optimistic estimation, the literature on offline RL  is more inclined to pessimism due to the limitation of offline data coverage. Hence, we construct a confidence set \(}^{h}=\{f}^{h}:+_{i=1}^{n}(f(x_{ i}^{h},a_{i}^{h})-^{h}(x_{i}^{h},a_{i}^{h}))^{2}/(_{i}^{h})^{2} (^{h})^{2}\}\) such that the uncorrupted Bellman operator \(^{h}\) converts the value function \(f_{n}^{h+1}\) into the function class \(}^{h}\) (i.e.,\(}^{h}\)) with high probability. For the bonus function, we follow  and choose it as

\[b_{h}(x,a)=_{f,f^{}}^{h}}(x,a)|}{^{n}(f(x_{i}^{h},a_{i}^{h})-f^{}(x _{i}^{h},a_{i}^{h}))^{2}/(_{i}^{h})^{2}}},\] (8)

which is seldom used in practical algorithms due to its instability. Specifically, the covering number of the space containing (8) may be uncontrollable. According to Appendix E in , the issue of the covering number can be addressed under mild conditions by some techniques. Therefore, to maintain readability and consistency in this paper, we assume the corresponding bonus function space \(^{h+1}\) of (8) has a bounded covering number. Then we introduce pessimism by subtracting \(b^{h}\) from the estimated value function: \(f_{n}^{h}(x,a)=(0,^{h}(x,a)-^{h}b^{h}(x,a))\).

## 4 Theoretical Analysis

### Coverage Condition

No guarantee for the suboptimality can be provided with insufficient data coverage. Based on pessimism, Jin et al. , Rashidinejad et al.  have demonstrated that the coverage over the optimal policy is sufficient for sample-efficient offline RL. The following condition covers the optimal policy under general function approximation.

**Definition 4.1** (Coverage Coefficient).: _Consider the offline dataset \(\{x_{i}^{h},a_{i}^{h}\}_{i,h=1}^{n,H}\). For any initial state \(x^{1}=x\), the coverage coefficient is:_

\[(,},_{n}^{H})=_{h[H]} _{_{*}}_{f,f^{}}^{h}} ,a^{h})-f^{}(x^{h},a^{h}))^{2}}{+_{i=1}^{n}(f( x_{i}^{h},a_{i}^{h})-f^{}(x_{i}^{h},a_{i}^{h}))^{2}}\,x^{1}=x ,\] (9)

_where \(_{_{*}}\) is taken with respect to the trajectory induced by \(_{*}\) in the underlying uncorrupted MDP._

In the face of corruption, we require single-policy coverage over the uncorrupted trajectory. This coefficient depicts the expected uncertainty of sample \((x^{h},a^{h})\) induced by the optimal policy \(_{*}\) compared to the \(n\) training samples. We use the linear MDP to interpret this condition, where the function space \(^{h}\) is embedded into a \(d\)-dimensional vector space: \(^{h}=\{ w(f),():z\}\), where \(z\) denotes the state-action pair \((x,a)\). With the notation \(^{h}= I+_{i=1}^{n}(z_{i}^{h})(z_{i}^{h})^{}\), we can demonstrate that if the sufficient "coverage" in Jin et al.  holds: there exists a constant \(c^{}\) such that \(^{h} I+c^{}n_{_{*}}[(z^{h})(z^{h})^{ }\,x^{1}=x]\) for all \(h[H]\), our coverage coefficient is bounded: \((,},_{n}^{H}) d/c^{ }<\). Therefore, the sufficient "coverage" condition implies our coverage condition in the linear setting. We will discuss the connection formally in Lemma B.1.

### Main Result

Before presenting the main theorem, we introduce a new general version of the well-explored dataset condition, which is the key to eliminating the uncertainty-related weights from the suboptimality bound and deriving the final result.

**Assumption 4.1** (Well-Explored Dataset).: _There exists a constant \(C(},)>8n^{-1}\) such that for a \((n^{-1},\|\|_{})\) cover of \(}^{h}\), denoted by \(}^{h}\), and for any two distinct \(f,f^{}}^{h}\),_

\[_{h[H]}_{z^{h}}^{h}(z^{h}) f(z^{h})-f^{}(z^{h})^{2} C(},).\] (10)

We interpret this condition with the linear model, where the condition (10) becomes: for any two distinct \(f,f^{}}^{h}\), \(_{h[H]}w(f)-w(f^{})^{}^{h} w(f)-w(f^{}) C(},)\). As proved in Lemma B.2, with high probability, the above condition holds with \(C(},)=(d^{-1})\) when the \(n\) trajectories of \(\) are independent, and the data distribution \(^{h}\) satisfies the minimum eigenvalue condition:

\[_{}_{z^{h}^{h}}[(z^{h})(z^{h})^{ }]=/d,\] (11)

where \(>0\) is an absolute constant. This is a widely-adopted assumption in the literature [11; 46; 63]. Note that \((d^{-1})\) is the largest possible minimum eigenvalue since for any data distribution \(^{h}\), \(_{}(_{z^{h}^{h}}[(z^{h})(z^{h})^{}]) d ^{-1}\) by using \(\|(z^{h})\| 1\) for any \(z^{h}\).

**Theorem 1**.: _If the coverage coefficient in Definition 4.1 is finite, under Assumption 4.1, for corruption \(=_{h=1}^{H}^{h}\) and \(>0\), we choose the covering parameter \(=1/(n_{h}^{h}^{h})\), \(=(N_{n}())\), the weighting parameter \(=H()}/\), and the confidence radius_

\[^{h}=c_{}^{h}+()/)} ,h=H,,1,\]

_where \(N_{n}()=_{h}N(/n,^{h}) N(/n,^ {h+1}) N(/n,^{h+1}())\). Then, with probability at least \(1-2\), the sub-optimality of Algorithm 2 is bounded by_

\[(,x)=}( ,},_{n}^{H}))^{1/4}( N_{n}())^ {1/2}}{n^{1/2}(C(},))^{1/4}}+( ,},_{n}^{H}))^{1/2}}{n(C(}, ))^{1/2}}.\]

When \(=()\), our algorithm achieves the same order of suboptimality as the uncorrupted case. Whenever \(=o(n)\), our algorithm is sample-efficient. Moreover, when specialized to the linear MDP with dimension \(d\), where \((,},_{n}^{H})=(d/c^{ })\), \(C(},)=(d^{-1})\) and \( N_{n}()=}(d^{2})\), the suboptimality bound in Theorem 1 becomes \(}(Hd^{3/2}n^{-1/2}+d n^{-1})\). The corruption-independent term \(}(Hd^{3/2}n^{-1/2})\) matches that of PEVI . The corruption-dependent term nearly matches the lower bound, as will be discussed later.

**Remark 4.1**.: _Although the theory requires a known corruption level \(\), in the experiments, we treat the uncertainty ratio \(=O(1/)\) as a tuning hyperparameter. The use of independent and identically distributed (i.i.d.) trajectories in our experiments renders the hyperparameter tuning process straightforward and conducive to optimizing the performance. Additionally, we can offer a choice of \(=(1/)\). This choice finds support in the online setting , where this specific choice of \(\) ensures that suboptimality remains in the order of uncorrupted error bound, even when \(=O()\)._

**Proof sketch.** The detailed proof of Theorem 1 is provided in Appendix A. Here we present a brief proof sketch for the suboptimality bound, which is accomplished by three steps: (1) by Lemma A.1, if the uncorrupted Bellman backup \(^{h}f_{n}}^{h}\) for each \(h[H]\), we can bound the suboptimality by the sum of the bonus \(_{h=1}^{H}^{h}_{_{*}}[b^{h}(x^{h},a^{h})\,|\,x^{1}=x]\); (2) by Lemma A.2, we demonstrate that an approximate uncertainty weight satisfying (6) is the key to bound the weighted Bellman error \((_{i=1}^{n}((^{h}-(^{h}f_{n}^{h+1}))(x_{i}^{h},a_{i}^{h })^{2}/(_{i}^{h})^{2})^{1/2}\) by \(^{h}=c_{}(^{h}+()/)})\); and (3) combining the results in the first two steps, we can obtain the suboptimality bounded by:

\[(,x)=}H(^{ }(,},_{n}^{H}))^{1/2}( N_{n}() )^{1/2} n^{-1/2}+^{}(,},_{n}^{H}) n^{-1}.\]

Here \(^{}(,},_{n}^{H})\) denotes the weighted coverage coefficient as follows

\[^{}(,},_{n}^{H})=_{h [H]}_{_{*}}_{f,f^{}}^{h}} ,a^{h})-f^{}(x^{h},a^{h}))^{2}/^{h}(x^{h},a^{h})^{ 2}}{+_{i=1}^{n}(f(x_{i}^{h},a_{i}^{h})-f^{}(x_{i}^{h},a_{i}^{ h}))^{2}/(_{i}^{h})^{2}}\,x^{1}=x,\] (12)

where the weight for the trajectory induced by the optimal policy \(_{*}\) is

\[(^{h}(x^{h},a^{h}))^{2}=1,_{f,f^{}}^{h}},a^{h})-f^{}(x^{h},a^{h})|/}{^{n}(f(x_{i}^{h},a_{i}^{h})-f^{}(x_{i}^{h},a_{i}^{h}) )^{2}/(_{i}^{h})^{2}}}.\] (13)

To control the weighted coverage coefficient \(^{}\) by its unweighted counterpart \(\), which is a challenging task due to the intricate form of uncertainty-related weights, a novel technique has been employed. The main idea behind this technique is to transform \(^{}\) into a modified version of \(\) multiplied by a term that can be bounded by leveraging a cover of the function class. The connection between \(\) and \(^{}\) is shown in the following lemma.

**Lemma 4.1**.: _Under Assumption 4.1 and choose \(^{h}=C_{}\) (where \(C_{}>0\) contains the logarithmic terms that are omitted) and \(\) given in Theorem 1, we have_

\[^{}(,},_{n}^{H})=}((,},_{n}^{H}))^ {1/2}(C(},))^{-1/2}.\]

Intuitively, because the weights themselves are closely related to the uncertainty, the weighted coverage coefficient \(^{}\) where the high-uncertain samples are down-weighted can be upper-bounded by the square root of the unweighted coefficient \(\). See Appendix B.3 for details.

**Lower Bound.** We construct a lower bound for linear MDPs with adversarial corruption \(\) to show that the \((d n^{-1})\) corruption term of our suboptimality is optimal. The construction of the lower bound is adapted from Zhang et al. , where an \(\)-constant fraction of the dataset is contaminated. We present the proof of Theorem 2 in Appendix B.4.

**Theorem 2** (Minimax Lower Bound for Linear MDPs).: _Under linear MDPs with corruption (Definition 2.2), for any fixed data-collecting distribution \(\), any algorithm \(L:\) with the knowledge of \(\) cannot find a better policy than \((d n^{-1})\)-optimal policy with probability more than \(1/4\):_

\[_{L,}_{,}(_{L})= d/n,\]

_where \(\) is the corrupted dataset initially generated from the MDP and then corrupted by an adversary, and \(_{L}\) is the policy generated by the algorithm \(L\)._

## 5 Experiments

Based on our theoretical results, we propose a practical implementation for CR-PEVI and verify its effectiveness on simulation tasks with corrupted offline data.

**Practical Implementation.** To make our algorithm more practical, we use neural networks to estimate the \(Q\) function (i.e., \(f\) in our theory) and the weight function \(\). In linear MDPs, under a sufficiently broad function approximation class \(}^{h}\) and sufficiently small parameter \(\) in Eq. (8), the bonus function can be simplified as the bootstrapped uncertainty of \(Q\) functions, which in turn can be estimated via the standard deviation of an ensemble of \(Q\) networks. We defer the detailed discussion to Appendix B.5. Following the state-of-the-art uncertainty-based offline RL algorithm Model Standard-deviation Gradients (MSG) , we learn a group of \(Q\) networks \(Q_{w_{i}},i=1,,K\) with independent targets and optimize a policy \(_{}\) with a lower-confidence bound (LCB) objective [16; 2]. Specifically, \(Q_{w_{i}}\) is learned to minimize a weighted regression objective similar to Eq.(7). The weight function \(\) is estimated via bootstrapped uncertainty: \((x,a)=(_{i=1,,K}[Q_{w_{i}}(x,a)]},1)\), where \(_{i=1,,K}[Q_{w_{i}}]\) is the variance between the group of \(Q\) functions. This uncertainty estimation method has also been adopted by prior works [2; 16; 54]. We refer to our practical algorithm as Uncertainty Weighted MSG (UWMSG) and defer details to Appendix D.

**Experimental Setup.** We assess the performance of our approach using continuous control tasks from  and introduce both random and adversarial attacks on either the rewards or dynamics for the offline datasets. Details about the four types of data corruption and their cumulative corruption levels are deferred to Appendix D. The ensemble size \(K\) is set to \(10\) for all experiments. For evaluation, we report average returns with standard deviations over 10 random seeds. More implementation details are also provided in Appendix D.

**Experimental Results.** We compare UWMSG with the state-of-the-art uncertainty-base offline RL methods, MSG , EDAC , and SAC-N  under four types of data corruption. In particular, MSG can be considered as UWMSG with a constant weighting function \((s,a)=1\). As demonstrated in Table 1 and Figure 1, our empirical results find that (1) current offline RL methods are susceptible to data corruption, e.g., MSG, EDAC, SAC-N achieve poor performance under adversarial attacks, and (2) our proposed UWMSG significantly improves performance under different data corruption scenarios, with an average improvement of \(104\%\) over MSG. More results can be found in Appendix F.

Figure 1: Performance on the Walker2d and the Halfcheetah tasks under (a) random reward, (b) random dynamics, (c) adversarial reward, and (d) adversarial dynamics attacks.

In summary, the experimental results validate the theoretical impact of data corruption for value-based offline RL algorithms. Our practical implementation algorithm demonstrates superior efficacy under different data corruption types, thereby highlighting its potential for real-world applications.

## 6 Conclusion

This work investigates the adversarially corrupted offline RL with general function approximation. We propose the uncertainty weight iteration and a weighted version of PEVI. Under a partial coverage condition and a well-explored dataset, our algorithm achieves a suboptimality bound, where the corruption-independent term recovers the uncorrupted bound, and the corruption-related term nearly matches the lower bound in linear models. Furthermore, our experiments demonstrate promising results showing that our practical implementation, UWMSG, significantly enhances the performance of the state-of-the-art offline RL algorithm under reward and dynamics data corruptions.

Our work suggests several potential future directions. First, it remains unsolved whether one can design robust algorithms to handle additional distribution shifts of the state-action pairs. Second, when the corruption level is unknown, how to design a theoretically robust offline RL algorithm and overcome the lack of adaptivity in the offline setting requires further research. Finally, we hope that our work sheds light on applying uncertainty weights to improve robustness in deep offline RL works and even practical applications.