# Variance-Reduced Gradient Estimation via

Noise-Reuse in Online Evolution Strategies

 Oscar Li\({}^{@sectionsign}\)1, James Harrison\({}^{}\), Jascha Sohl-Dickstein\({}^{}\), Virginia Smith\({}^{@sectionsign}\), Luke Metz\({}^{}\)2

\({}^{@sectionsign}\)Machine Learning Department, School of Computer Science Carnegie Mellon University

\({}^{}\)Google DeepMind

###### Abstract

Unrolled computation graphs are prevalent throughout machine learning but present challenges to automatic differentiation (AD) gradient estimation methods when their loss functions exhibit extreme local sensitivtiy, discontinuity, or blackbox characteristics. In such scenarios, online evolution strategies methods are a more capable alternative, while being more parallelizable than vanilla evolution strategies (ES) by interleaving partial unrolls and gradient updates. In this work, we propose a general class of unbiased online evolution strategies methods. We analytically and empirically characterize the variance of this class of gradient estimators and identify the one with the least variance, which we term Noise-Reuse Evolution Strategies (NRES). Experimentally3, we show NRES results in faster convergence than existing AD and ES methods in terms of wall-clock time and number of unroll steps across a variety of applications, including learning dynamical systems, meta-training learned optimizers, and reinforcement learning.

## 1 Introduction

First-order optimization methods are a foundational tool in machine learning. With many such methods (e.g., SGD, Adam) available in existing software, ML training often amounts to specifying a computation graph of learnable parameters and computing some notion of gradients to pass into an off-the-shelf optimizer. Here, _unrolled computation graphs_ (UCGs), where the same learnable parameters are repeatedly applied to transition a dynamical system's inner state, have found their use in various applications such as recurrent neural networks , meta-training learned optimizers , hyperparameter tuning , dataset distillation , and reinforcement learning .

While a large number of automatic differentiation (AD) methods exist to estimate gradients in UCGs , they often perform poorly over loss landscapes with extreme local sensitivity and cannot handle black-box computation dynamics or discontinuous losses . To handle these shortcomings, evolution strategies (ES) have become a popular alternative to produce gradient estimates in UCGs . ES methods convolve the (potentially pathological or discontinuous) loss surface with a Gaussian distribution in the learnable parameter space, making it smoother and infinitely differentiable. Unfortunately, vanilla ES methods cannot be applied online4 -- the computation must reach the end of the graph to produce a gradient update, thus incurring large update latency for long UCGs. To address this, a recently proposed approach, Persistent Evolution Strategies  (\(\)), samples a new Gaussian noise in every truncation unroll and accumulates the past sampled noises to get rid of the estimation bias in its online application.

In this work, we investigate the coupling of the noise sampling frequency and the gradient estimation frequency in \(\). By decoupling these two values, we arrive at a more general class of unbiased,online ES gradient estimators. Through a variance characterization of these estimators, we find that the one which provably has the lowest variance in fact reuses the same noise for the entire time horizon (instead of over a single truncation window as in \(\)). We name this method _Noise-Reuse Evolution Strategies_ (\(\)). In addition to being simple to implement, \(\) converges faster than \(\) across a wide variety of applications due to its reduced variance. Overall, we make the following contributions:

* We propose a class of unbiased online evolution strategies gradient estimators for unrolled computation graphs that generalize Persistent Evolution Strategies .
* We analytically and empirically characterize the variance of this class of estimators and identify the lowest-variance estimator which we name Noise-Reuse Evolution Strategies (\(\)).
* We identify the connection between \(\) and the existing offline ES method FullES and show that \(\) is a better alternative to \(\) both in terms of parallelizability and variance.
* We demonstrate that \(\) can provide optimization convergence speedups (up to 5-60\(\)) over AD/ES baselines in terms of wall-clock time and number of unroll steps in applications of 1) learning dynamical systems, 2) meta-training learned optimizers, and 3) reinforcement learning.

## 2 Online Evolution Strategies: Background and Related Work

**Problem setup.** Unrolled computation graphs (UCGs)  are common in applications such as training recurrent neural networks, meta-training learned optimizers, and learning reinforcement learning policies, where the same set of parameters are repeatedly used to update the inner state of some system. We consider general UCGs where the inner state \(s_{t}^{p}\) is updated with learnable parameters \(^{d}\) through transition functions: \(\{f_{t}:^{p}^{d}^{p}\}_{t=1}^ {T}\), \(s_{t}=f_{t}(s_{t-1};)\) for \(T\) time steps starting from an initial state \(s_{0}\). At each time step \(t\{1,,T\}\), the state \(s_{t}\) incurs a loss \(L_{t}^{s}(s_{t})\). As the loss \(L_{t}^{s}\) depends on \(t\) applications of \(\), we make this dependence more explicit with a loss function \(L_{t}:^{dt}\) and \(L_{t}([]_{ t}):=L_{t}^{s}(s_{t})\)5. We aim to minimize the average loss over all \(T\) time steps unrolled under the same \(\), \(_{}L([]_{ T})\), where

\[L(_{1},,_{T})_{t=1}^{T}L_{t}(_{ 1},,_{t}).\] (1)

**Loss properties.** Despite the existence of many automatic differentiation (AD) techniques to estimate gradients in UCGs , there are common scenarios where they are undesirable: **1)**_Loss surfaces with extreme local sensitiviy_: With large number of unrolls in UCGs, the induced loss surface is prone to high degrees of sharpness and many suboptimal local minima (see Figure 1). This issue is particularly prevalent when the underlying dynamical system is chaotic under the parameter (\(\)) of interest , e.g. in model-based control  and meta-learning . In such cases, naively following the gradient may either _a)_ fail to converge under the normal range of learning rates (because of the conflicting gradient directions) or _b)_ converge to highly suboptimal solutions using a tuned, yet much smaller learning rate. **2)**_Black-box or discontinuous losses_: As AD methods require defining a Jacobian-vector product (forward-mode) or a vector-Jacobian product (reverse-mode) for every elementary operation in the computation graph, they cannot be applied when the UCG's inner dynamics are inaccessible (e.g., model-free reinforcement learning) or the loss objectives (e.g. accuracy) are piecewise constant (zero gradients).

**Evolution Strategies.** Due to the issues with AD methods described above, a common alternative is to use evolution strategies (ES) to estimate gradients. Here, the original loss function is convolved with an isotropic Gaussian distribution in the space of \(\), resulting in an infinitely differentiable loss

Figure 1: (a) The pathological loss surface in the learned optimizer task (Sec. 5.2) along a random \(\) direction; such surfaces are common in UCGs but can make automatic differentiation methods unusable, leading to the recent development of evolution strategies methods. (b) Comparison of properties of different evolution strategies methods. Unlike prior online ES methods, \(\) produces both unbiased and low-variance gradient estimates.

function with lower sharpness and fewer local minima than before (\(>0\) is a hyperparameter):

\[_{(,^{2}I_{d d })}\,L([+]_{ T}).\] (2)

An unbiased gradient estimator of (2) is given by the likelihood ratio gradient estimator : \(}L([+]_{ T})\). This estimator only requires the loss evaluation (hence is zeroth-order) but not an explicit computation of the gradient, thus being applicable in cases when the gradients are noninformative (chaotic or piecewise constant loss) or not directly computable (black-box loss). To reduce the variance, antithetic sampling is used and we call this estimator \(\) (Algorithm 3 in the Appendix):

\[()} _{i=1}^{T}(L_{i}([+]_{ i})-L_{i}([-]_{ i}).\] (3)

The term Full highlights that this estimator can only produce a gradient estimate after a _full_ sequential unroll from \(t=0\) to \(T\). We call such a full unroll an _episode_ following the reinforcement learning terminology. FullES can be parallelized  by averaging \(N\) parallel gradient estimates using _i.i.d._\(\)'s, but is not online and can result in substantial latency between gradient updates when \(T\) is large.

**Truncated Evolution Strategies.** To make \(\) online, Metz et al.  take inspiration from truncated backpropagation through time (\(\)) and propose the algorithm \(\) (see Algorithm 6 in the Appendix). Unlike the stateless estimator \(\), \(\) is stateful: \(\) starts from a saved state \(s\) (from the previous iteration) and draws a new \(_{i}\) for antithetic unrolling. To make itself online, \(\) only unrolls for a truncation window of \(W\) steps for every gradient estimate, thus reducing the latency from \(O(T)\) to \(O(W)\). Analytically,

\[()W}_{i=1}^{W}L_{ +i}([]_{},[+_{(/W)+1 }]_{ i})-L_{+i}([]_{},[-_{(/W)+1}]_{ i})_{(/W)+1}.\] (4)

Here, besides the Gaussian random variables \(_{i}_{i=1}^{T/W}}{}( ,^{2}I_{d d})\), the time step \(\) which \(\) starts from is also a random variable drawn from the uniform distribution \(\{0,W,,T-W\}^{6}\). It is worth noting that Vicol et al.  who also analyze online ES estimators do not take the view that the time step \(\) an online ES estimator starts from is a random variable; as such their analyses do not fully reflect the "online" nature captured in our work. When multiple online ES Workers (e.g., TES workers) run in parallel, different workers will work at different _i.i.d._ time steps \(_{i}\) (which we call _step-unlocked_ workers) (see Figure 2(a)). We provide the pseudocode for creating step-unlocked workers and for general online ES learning in Algorithm 4 and 5 in the Appendix.

**TES is a biased gradient estimator of (2).** Note that in (4), only the \(\)'s in the current length-\(W\) truncation window receive antithetic perturbations, thus ignoring the impact of the earlier \(\)'s up to time step \(\). Due to this bias, optimization using \(\) typically doesn't converge to optimal solutions.

**Persistent Evolution Strategies.** To resolve the bias of \(\), Vicol et al.  recognize that \(\) samples a new noise in every truncation window and modifies the smoothing objective into:

\[_{\{_{i}\}}\,L([+_{1}]_{  W},,[+_{T/W}]_{ W}).\] (5)

Figure 2: (a) Illustration of _step-unlocked_ online ES workers working independently at different truncation windows. Here a central server sends \(\) (whose gradient to be estimated) to each worker and receives the estimates over partial unrolls from each. The averaged gradient can then be used in a first-order optimization algorithm. (b) Comparison of the noise sharing mechanisms of \(\), \(_{K}\), and \(\) (ours). Unlike \(\) (and \(_{K T}\)) which samples a new noise in every (some) truncation window and needs to accumulate the noise, \(\) only samples noise once at the beginning of an episode and reuses the noise for the full episode.

They show that an unbiased gradient estimator of 5 is given by (see Algorithm 1):

\[()W}_{i=1}^{W} [L_{+i}([+_{1}]_{ W},,[+ _{(/W)+1}]_{ i}).\] \[.-L_{+i}([-_{1}] _{ W},,[-_{(/W)+1}]_{ i})](( _{j=1}^{/W}_{j})+_{/W+1}),\] (6)

with randomness in both \(\{_{i}\}\) and \(\). To eliminate the bias of \(\), instead of multiplying only with the current epsilon \(_{/W+1}\), \(\) multiplies it with the cumulative sum of all the different _iid_ noise sampled so far (self.\(\) in \(\)Worker). As we shall see in the next section, this accumulation of noise terms provably results in higher variance, making \(\) less desirable in practice. We contrast the noise sampling properties of our proposed methods with \(\) in Figure 1(b).

**Hysteresis.** When online gradient estimators are used in training, they often suffer from _hysteresis_, or history dependence, as a result of the parameters \(\) changing between adjacent unrolls. That is, the parameter value \(_{0}\) that a worker uses in the current truncation window is not the same parameter \(_{-1}\) that was used in the previous window. This effect is often neglected , under an assumption that \(\) is updated slowly. To the best of our knowledge,  is the only work to analyze the convergence of an online gradient estimator under hysteresis. In the following theoretical analysis, we assume all online gradient estimates are computed without hysteresis in order to isolate the problem. However, in Section 5, we show empirically that even under the impact of hysteresis, our proposed online estimator \(\) can outperform non-online methods (e.g., \(\)) which don't suffer from hysteresis.

``` classPresWorker(OnlineESWorker): def\(\_\)init\((\)self, \(W\)): self.\(=0\); self.\(s^{+}=s_{0}\); self.\(s^{-}=s_{0}\) self.\(W=W\); self.\(s^{-}\) ```

**Algorithm 1** Persistent Evolution Strategies 

## 3 A New Class of Unbiased Online Evolution Strategies Methods

As shown in Section 2, \(\) and \(\) both sample a new noise perturbation \(\) for every truncation window to produce gradient estimates. Here we note that the _frequency of noise-sharing_ (new noise every truncation window of size \(W\)) is fixed to the _frequency of gradient estimates_ (a gradient estimate every truncation window of size \(W\)). However, the former is a choice of the smoothing objective (5), while the latter is often a choice of how much gradient update latency the user can tolerate. In this section _we break this coupling_ by introducing a general class of gradient estimators that encompass \(\). We then analyze these estimators' variance to identify the one with the least variance.

**Generalized Persistent Evolution Strategies (GPES).** For a given fixed truncation window size \(W\), we consider all _noise-sharing periods_\(K\) that are multiples of \(W\), \(K=cW\) for \(c^{+},\ c T/W\). \(K\) being a multiple of \(W\) ensures that within each truncation window, only a single \(\) is used. When\(K=W\), we recover the \(\) algorithm. However, when \(K\) is larger than \(W\), the same noise will be used across adjacent truncation windows (Figure 2(b)). With a new noise sampled every \(K\) unroll steps, we define the _\(K\)-smoothed loss objective_ as the function:

\[_{\{_{1}\}}\ L([+_{1}]_{  K},,[+_{ T/K}]_{(T,K)}),@note{footnote}{[$x$] is smallest integer $ x$; $ x$ is the largest integer $ x$.}\] (7)

where \(:(^{+})^{2}^{+}\) is the modified remainder function such that \((x,y)\) is the unique integer \(n[1,y]\) where \(x=qy+n\) for some integer \(q\). This extra notation allows for the possibility that \(T\) is not divisible by \(K\) and the last noise \(_{ T/K}\) is used for only \((T,K)<K\) steps.

We now give the analytic form of an unbiased gradient estimator of the resulting smoothed loss.8

**Lemma 1**.: _An unbiased gradient estimator for the \(K\)-smoothed loss is given by_

\[_{K}()W}_{j= 1}^{W}[L_{+j}([+_{1}]_{ K},,[ +_{/K+1}]_{(+j,K)}).\\ .-L_{+j}([-_{1}]_{ K}, ,[-_{/K+1}]_{( +j,K)})](_{i=1}^{/K+1} _{i}),\]

_with randomness in \(\) and \(\{_{i}\}_{i=1}^{ T/K}\)._

\(_{K}\) **algorithm.** Here, for the truncation window starting at step \(\), the noise \(_{/K+1}\) is used as the antithetic perturbation to unroll the system. If \(\) is not divisible by \(K\), then this noise has already been sampled at time step \(t=/K K\) in an earlier truncation window. Therefore, to know what noise to apply at this truncation window, we need to remember the last used \(\) and update it when \(\) becomes divisble by \(K\). We provide the algorithm for the \(_{K}\) gradient estimator in Algorithm 7 in the Appendix. Note that \(_{K=W}\) is the same as the \(\) algorithm.

**Variance Characterization of \(_{K}\).** With this generalized class of gradient estimators \(_{K}\), one might wonder how to choose the value of \(K\). Since each estimator is an unbiased gradient estiamtor with respect to its smoothed objective, we compare the variance of these estimators as a function of \(K\). To do this analytically, we make some simplifying assumptions:

**Assumption 2**.: For a given \(^{d}\) and \(t[T]\{1,,T\}\), there exists a set of vectors \(\{g_{i}^{t}^{d}\}_{i=1}^{t}\), such that for any \(\{v_{i}^{d}\}_{i=1}^{t}\), the following equality holds:

\[L_{t}(+v_{1},+v_{2},,+v_{t})-L_{t}(-v_{1}, -v_{2},,-v_{t})=2_{i=1}^{t}(v_{i})^{}(g_{i}^{t})\] (8)

**Remark 3**.: This assumption is more general than the quadratic \(L_{t}\) assumption made in  (explanation see Appendix D). Here one can roughly understand \(g_{i}^{t}\) as time step \(t\)'s smoothed loss's partial derivative with respect to the \(i\)-th application of \(\). For notational convenience, we let \(g^{t}_{i=1}^{t}g_{i}^{t}\) (roughly the total derivative of smoothed step-\(t\) loss with respect to \(\)) and \(g_{K,j}^{t}_{i=K(j-1)+1}^{\{t,\,K j\}}g_{i}^{t}\) for \(j\{1,, t/K\}\) (roughly the sum of partial derivatives of smoothed step-\(t\) loss with respect to all \(\)'s in the \(j\)-th noise-sharing window of size \(K\) (the last window might be shorter)).

With this assumption in place, we first consider the case when \(W=1\) and \(K=cW=c\) for \(c[T]\). In this case, the \(_{K}\) estimator can be simplified into the following form:

**Lemma 4**.: _Under Assumption 2, when \(W=1\), \(_{K=c}()=}_{j=1}^{/ c+1}(_{i=1}^{/c+1}_{i} )_{j}^{}g_{c,j}^{+1}\)._

With this simplified form, we can now characterize the variance of the estimator \(_{K=c}()\). Since it's a random vector, we analytically derive its total variance (trace of covariance matrix) \(([_{K=c}()])\).

**Theorem 5**.: _When \(W=1\) and under Assumption 2, for integer \(c[T]\),_

\[([_{K=c}()])=_{t= 1}^{T}(\|g^{t}\|_{2}^{2})-\|_{t=1}^{T}g^{t} \|_{2}^{2}+_{t=1}^{T}(_{j=1,j^{ }=1}^{ t/c}\|g_{c,j}^{t}-g_{c,j^{}}^{t}\|_{2}^{2} ).\] (9)To understand how the value of \(K=c\) changes the total variance, we notice that only the nonnegative third term in (9) depends on it. This term measures the pairwise squared distance between non-overlapping partial sums \(g^{t}_{c,j}\) for all \(j\). When \(c=T\), for every \(t[T]\), there is only a single such partial sum as \( t/c=1\). In this case, this third term reduces to its smallest value of \(0\). Thus:

**Corollary 6**.: _Under Assumption 2, when \(W=1\), the gradient estimator \(_{K=T}()\) has the smallest total variance among all \(\{_{K}:K[T]\}\) estimators._

**Remark 7**.: To understand Corollary 6 intuitively, notice that at a given time step \(t\) (i.e., a length-1 truncation window), any \(_{K=c}\) gradient estimator (\(c[T]\)) aims to unbiasedly estimate the total derivative of the smoothed loss at this step with respect to \(\), which we have denoted by \(g^{t}\). By applying a new Gaussian noise perturbation every \(c<T\) steps, the \(_{K=c}\) estimators _indirectly estimate_\(g^{t}\) by first unbiasedly estimating the gradients inside each size-\(c\) noise-sharing window: \(\{g^{t}_{c,j}\}_{j=1}^{ t/c}\) and then summing up the result (notice \(g^{t}=_{j=1}^{ t/c}g^{t}_{c,j}\)). To obtain this extra (yet unused) information about the intermediate partial derivatives, these estimators require more randomness and thus suffer from a larger total variance than the \(_{K=T}\) estimator which directly estimates \(g^{t}\).

Experimental Verification of Corollary 6.We empirically verify Corollary 6 on a meta-training learned optimizer task (\(T=1000\); see additional details in Section 5.2). Here we save a trajectory of \(_{i}\) learned by \(\) (_i_ denotes training iteration) and compute the total variance of the estimated gradients (without hysteresis) by \(\) with different values of \(K\) in Figure 3(a) (\(W=1\)). In agreement with theory, \(K=T\) has the lowest variance.

## 4 Noise-Reuse Evolution Strategies

NRES has lower variance than PES.As variance reduction is desirable in stochastic optimization , by Corollary 6, the gradient estimator \(_{K=T}\) is particularly attractive and _can serve as a variance-reduced replacement for \(\)_. When \(K=T\), we only need to sample a single \(\) once at the beginning of an episode (when \(=0\)) and reuse the same noise for the entirety of that episode before it rests. This removes the need to keep track of the cumulative applied noise (\(\)) (Figure 2(b)), making the algorithm simpler and more memory efficient than \(\). Due to its noise-reuse property, we name this gradient estimator \(_{K=T}\) the _Noise-Reuse Evolution Strategies_ (\(\)) (pseudocode in Algorithm 2). Concurrent with our work, Vicol  independently proposes a similar algorithm with different analyses. We discuss in detail how our work differs from  in Appendix B. Despite Theorem 5 assuming \(W=1\), one can relax this assumption to any \(W\) that divides the horizon length \(T\). By defining a "mega" UCG whose single transition step is equivalent to \(W\) steps in the original UCG, we can apply Corollary 6 to this mega UCG and arrive at the following result.

**Corollary 8**.: _Under Assumption 2, when \(W\) divides \(T\), the NRES gradient estimator has the smallest total variance among all \(_{K=cW}\) estimators \(c[T/W]\)._

NRES is a replacement for FullES.By sharing the same noise over the entire horizon, the smoothing objective of \(\) is the same as \(\)'s. Thus, we can think of \(\) as the online counterpart to the offline algorithm \(\). Hence \(\) can act as a drop-in replacement to \(\) in UCGs. A single \(\) worker runs \(2T\) unroll steps for each gradient estimate, while a single \(\) runs only \(2W\) steps. Motivated by this, we compare the average of \(T/W\)_i.d._\(\) gradient estimates with 1 \(\) gradient estimate as they require the same amount of compute.

NRES is more parallelizable than FullES.Because the \(T/W\)\(\) gradient estimators are independent of each other, we can run them in parallel. Under perfect parallelization, the entire \(\) gradient estimation would require \(O(W)\) time to complete. In contrast, the single \(\) gradient estimate has to traverse the UCG from start to finish, thus requiring \(O(T)\) time. Hence, \(\) is \(T/W\) times more parallelizable than \(\) under the same compute budget (Figure 4(a)).

Figure 3: Total variance of \(_{K}\) vs. noise-sharing period \(K\) for different \(_{i}\)’s from the learned trajectory of \(\). \(_{K=T}\) (\(\)) has the lowest total variance among estimators of its class (including \(\)) for each \(_{i}\).

**NRES can often have lower variance than FullES.** We next compare the variance of the average of \(T/W\)_i.i.d._\(\) gradient estimates with the variance of \(1\)\(\) gradient estimate:

**Theorem 9**.: _Under Assumption 2, for any \(W\) that divides \(T\), if_

\[_{k=1}^{T/W}\|_{t=W(k-1)+1}^{W k}g^{t}\|_{2}^{2} \|_{j=1}^{T/W}_{t=W(k-1)+1}^{W k}g^{t}\|_ {2}^{2},\] (10)

_then for iid \(\{_{i}()\}_{i=1}^{T/W}\) estimators, \(((_{i=1}^{T/W}_{i}() )((())\)._

**Remark 10**.: To understand the inequality assumption in (10), we notice that it relates the sum of the squared \(2\)-norm of vectors \(\{_{t=W(k-1)+1}^{W k}g^{t}\}_{k=1}^{T/W}\) with the squared \(2\)-norm of their sum. When these vectors are pointing in similar directions, this inequality would hold (to see this intuitively, consider the more extreme case when all these vectors are exactly in the same direction). Because each term \(_{t=W(k-1)+1}^{W k}g^{t}\) can be understood as the total derivative of the sum of smoothed losses in the \(k\)-th truncation window with respect to \(\), we see that inequality (10) is satisfied when, roughly speaking, different truncation windows' gradient contributions are pointing in similar directions. This is often the case for real-world applications because if we can decrease the losses within a truncation window by changing the parameter \(\), we likely will also decrease other truncation windows' losses. At a high-level, Theorem 9 shows that for many practical unrolled computation graphs, \(\) is not only _better than \(\) due to its better parallelizability_ but also _better due to its lower variance_ given the same computation budget.

**Empirical Verification of Theorem 9.** We empirically verify Theorem 9 in Figure 4(b) using the same set up of the meta-training learned optimizer task used in Figure 3(a). Here we compare the total variance of averaging \(T/W=1000\)_i.i.d._\(\) estimators versus using \(1\)\(\) gradient estimator (same total amount of compute). We see that \(\) has a significantly lower total variance than \(\) while also allowing \(T/W=1000\) times wall-clock speed up due to its parallelizability.

## 5 Experiments

\(\) is particularly suitable for optimization in UCGs in two scenarios: 1) when the loss surface exhibits extreme local sensitivity; 2) when automatic differentiation of the loss is not possible/gives noninformative (e.g., zero) gradients. In this section, we focus on three applications exhibiting these properties: a) learning Lorenz system's parameters (sensitive), b) meta-training learned optimizers (sensitive), and c) reinforcement learning (nondifferentiable), and show that \(\) outperforms existing AD and ES methods for these applications. When comparing online gradient estimation methods, we keep the number of workers \(N\) used by all methods the same for a fair comparison. For the offline method \(\), we choose its number of workers to be \(W/T\) the number of \(\) workers on all tasks (in order to keep the same number of unroll steps per-update) except for the learned optimizer task in Section 5.2 where we show that \(\) can solve the task faster while using much fewer per-update steps than \(\).

Figure 4: (a) Comparison of \(\) and \(\) gradient estimation under the same unroll budget. Unlike \(\) which can only use a single noise perturbation \(\) to unroll sequentially for an entire episode of length \(T\), \(\) can use \(T/W\) parallel step-unlocked workers each unrolling inside its random truncation windows of length \(W\) with independent perturbations \(^{(i)}\). This results in a \(T/W\) speed-up and variance reduction (Theorem 9) over \(\). (b) The total variance of \(\) and \(\) estimators under the same compute budget at the same set of \(_{i}\) checkpoints in Figure 3(a). \(\) achieves significantly lower total covariance.

### Learning dynamical system parameters

In this application, we consider learning the parameters of a Lorenz system, a canonical chaotic dynamical system. Here the state \(s_{t}=(x_{t},y_{t},z_{t})^{3}\) is unrolled with two learnable parameters \(a,r^{9}\) with the discretized transitions (\(dt=0.005\)) starting at \(s_{0}=(x_{0},y_{0},z_{0})=(1.2,1.3,1.6)\):

\[x_{t+1}=x_{t}+a(y_{t}-x_{t})dt;\;\;y_{t+1}=y_{t}+[x_{t}(r-z_{t})-y_{t}]dt; \;\;z_{t+1}=z_{t}+[x_{t} y_{t}-8/3 z_{t}]dt.\]

Due to the positive constraint on \(r>0\) and \(a>0\), we parameterize them as \(=((r),(a))^{2}\) and exponentiate the values in each application. We assume we observe the ground truth \(z\)-coordinate \(z_{t}^{}\) for \(t[T],T=2000\) steps unrolled by the default parameters \((r^{t},a^{t})=(28,10)\). For each step \(t\), we measure the squared loss \(L_{t}^{s}(s_{t})(z_{t}-z_{t}^{t})^{2}\). Our goal is to recover the ground truth parameters \(_{}=((28),(10))\) by optimizing the average loss over all time steps using vanilla SGD. We first visualize the training loss surface in the left panel of Figure 5(a) (also see Figure 8 in the Appendix) and notice that it has extreme sensitivity to small changes in the parameter \(\).

To illustrate the superior variance of \(\) over other \(_{K}\) estimators, we plot in the right panels of Figure 5(a) the optimization trajectory of \(\) using gradient estimator \(_{K}\) with different values of \(K\) under the same SGD learning rate. We see that \(\)'s trajectory exhibits the least amount of oscillation due to its lowest variance. In contrast, we notice that \(\)'s trajectory is highly unstable, thus requiring a smaller learning rate than \(\) to achieve a possibly slower convergence. Hence, we take extra care in tuning each method's constant learning rate and additionally allow \(\) to have a decay schedule. We plot the convergence of different ES gradient estimators in wall-clock time using the same hardware in Figure 5(b). (We additionally compare against automatic differentiation methods in Figure 9 in the Appendix; they all perform worse than the ES methods shown here.)

In terms of the result, we see that \(\) outperforms **1)**\(\), as \(\) is unbiased and can better capture long-term dependencies; **2)**\(\), as \(\) has provably lower variance, which aids convergence in stochastic optimization; **3)**\(\), as \(\) can produce more gradient updates in the same amount of wall clock time than \(\) (with parallelization, each \(\) update takes \(O(W)\) time instead of \(\)'s \(O(T)\) time). Additionally, we plot the asymptotically converged loss value when we train with a significantly larger number of particles (\(N=20000\)) for \(\) and \(\). We see that by only using \(N=200\) particles, \(\) can already converge around its asymptotic limit, while \(\) is still far from reaching its limit within our experiment time.

### Meta-training learned optimizers

In this application , the meta-parameters \(\) of a learned optimizer control the gradient-based updates of an inner model's parameters. The inner state \(s_{t}\) is the optimizer state which consists of both the inner model's parameters and its current gradient momentum statistics. The transition function \(f_{t}\) computes an additive update vector to the inner parameters using \(\) and a random training batch and outputs the next optimizer state \(s_{t+1}\). Each time step \(t\)'s meta-loss \(L_{t}^{s}\) evaluates the updated inner parameters' generalization performance using a sampled validation batch.

We consider meta-training the learned optimizer model given in  (\(d=1762\)) to optimize a 3-layer MLP on the Fashion MNIST dataset for \(T=1000\) steps. (We show results on the same task

Figure 5: (a) The pathological training loss surface of the Lorenz system problem (left) and the optimization trajectory of different \(_{K}\) gradient estimators (right). \(\)’s trajectory is the smoothest because of its lowest variance. (b) Different ES methods’ loss convergence on the same problem. \(\) converges the fastest.

with higher-dimension and longer horizon in Appendix E.1.2.) This task is used in the training task distribution of the state of the art learned optimizer VeLO 10. The loss surface for this problem has high sharpness and many suboptimal minima as previously shown in Figure 1(a). We meta-train with Adam using different gradient estimation methods with the same hardware and tune each gradient estimation method's meta learning rate individually. Because AD methods all perform worse than the ES methods, we defer their results to Figure 10 in the Appendix and only plot the convergence of the ES methods in wall-clock time in Figure 6(a).

Here we see that \(\) reaches the lowest loss value in the same amount of time. In fact, \(\) and \(\) would require \(5\) and \(9\) (respectively) longer than \(\) to reach a loss \(\) reaches early on during its training, while \(\) couldn't even reach that loss within our experiment time. It is worth noting that, for this task, \(\) only require \(2 N W=200\) unrolls to produce an unbiased, low-variance gradient estimate, which is even smaller than the length of a single episode (\(T=1000\)). In addition, we situate \(\)'s performance within our proposed class of \(_{K}\) estimators in Figure 6(b). In accordance with Corollary 8, \(\) converges fastest due to its reduced variance.

### Reinforcement Learning

It has been shown that ES is a scalable alternative to policy gradient and value function methods for solving reinforcement learning tasks . In this application, we learn a linear policy 11 (following ) using different ES methods on the Mujoco  Swimmer (\(d=16\)) and Half Cheetah task (\(d=102\)). We minimize the average of negative per-step rewards over the horizon length of \(T=1000\), which is equivalent to maximizing the undiscounted sum rewards. Unlike , we don't use additional heuristic tricks such as **1)** rank conversion of rewards, **2)** scaling by loss standard deviation, or **3)** state normalization. Instead, we aim to compare the pure performance of different ES methods assuming perfect parallel implementations. To do this, we measure a method's performance as a function of the number of _sequential environment steps_ it used. Sequential environment steps are steps that _have to_ happen one after another (e.g., the environment steps within the same truncation window). However, steps that are parallelizable don't count additionally in the sequential steps. Hence, the wall-clock time under perfect parallel implementation is linear with respect to the number of sequential environment steps used. As all the methods we compare are iterative update methods, we additionally require that each method use the same number of environment steps per update when measuring each method's required number of sequential steps to solve a task. We tune the SGD learning rate individually for each method and plot their total rewards progression on both Mujoco tasks in Figure 7.

Here we see that \(\) fails to solve both tasks due to the short horizon bias , making it unable to capture the long term dependencies necessary to solve the tasks. On the other hand, \(\), despite being unbiased, suffers from high variance, making it take longer (or unable in the case of Half Cheetah) to solve the task than \(\). As for \(\), despite using the same amount of compute per gradient update as \(\), it's much less parallelizable as discussed in Section 4 - it takes much longer time (\(10\) and \(60\)) than \(\) assuming perfect parallelization. In addition to the number

Figure 6: (a) Different ES gradient estimators’ training loss convergence on the learned optimizer task in wall-clock time. \(\) reaches the lowest loss fastest. (b) The loss convergence of \(_{K}\) gradient estimators with difference \(K\) values on the same task. \(\) converges the fastest due to its reduced variance.

of sequential steps, we additionally show the total number of environment steps used by each method in Table 3 in the Appendix - \(\)_also uses the least total number of steps_ to solve both tasks, making it the most sample efficient.

## 6 Additional Related Work

Beyond the most related work in Section 2, in this section, we further position \(\) relative to existing zeroth-order gradient estimation methods. We also provide additional related work on automatic differentiation (AD) methods for unrolled computation graphs in Appendix B.

**Zeroth-Order Gradient Estimators.** In this work, we focus on zeroth-order methods that can estimate continuous parameters' gradients to be plugged into any first-order optimizers, unlike other zeroth-order optimization methods such as Bayesian Optimization , random search , or Trust Region methods . We also don't compare against policy gradient methods , because they assume internal stochasticity of the unrolling dynamics, which may not hold for deterministic policy learning [e.g., 22]. Within the space of evolution strategies methods, many works have focused on improving the vanilla ES method's variance by changing the perturbation distribution , considering the covariance structure , and using control variates . However, these works do not consider the unrolled structure of UCGs and are offline methods. In contrast, we reduce the variance by incorporating this unrolled aspect through online estimation and noise-reuse. As the aforementioned variance reduction methods work orthogonally to \(\), it is conceivable that these techniques can be used in conjunction with \(\) to further reduce the variance.

## 7 Discussion, Limitations, and Future Work

In this work, we improve online evolution strategies for unbiased gradient estimation in unrolled computation graphs by analyzing the best noise-sharing strategies. By generalizing an existing unbiased method, Persistent Evolution Strategies, to a broader class, we analytically and empirically identify the best estimator with the smallest variance and name this method Noise-Reuse Evolution Strategies (\(\)). We demonstrate the convergence benefits of \(\) over other automatic differentiation and evolution strategies methods on a variety of applications.

**Limitations.** As \(\) is both an online method and an ES method, it naturally inherits some limitations shared by all methods of these two classes, such as hysteresis and variance's linear dependence on the dimension \(d\). We provide a detailed discussion of these limitations in Appendix F.

**Future Work.** There are some natural open questions: **1)**_choosing a better sampling distribution for \(\). Currently the isotropic Gaussian's variance \(^{2}\) is tuned as a hyperparameter. Whether there are better ways to leverage the sequential structure in unrolled computation graphs to automate the selection of this distribution is an open question. **2)**_Incorporating hysteresis_. Our analysis assumes no hysteresis in the gradient estimates and we haven't observed much impact of it in our experiments. However, understanding when and how to correct for hysteresis is an interesting direction.