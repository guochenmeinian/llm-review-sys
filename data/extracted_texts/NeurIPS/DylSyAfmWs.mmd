# Be like a Goldfish, Don't Memorize!

Mitigating Memorization in Generative LLMs

Abhimanyu Hans\({}^{1}\), Yuxin Wen\({}^{1}\), Neel Jain\({}^{1}\), John Kirchenbauer\({}^{1}\)

**Hamid Kazemi\({}^{1}\), Prajwal Singhania\({}^{1}\), Siddharth Singh\({}^{1}\), Gowthami Sompalli\({}^{1}\)**

**Jonas Geiping\({}^{2,3}\), Abhinav Bhatele\({}^{1}\), Tom Goldstein\({}^{1}\)**

\({}^{1}\) University of Maryland,

\({}^{2}\) ELLIS Institute Tubingen,

\({}^{3}\) Max Planck Institute for Intelligent Systems, Tubingen AI Center

Correspondence to ahans1@umd.edu. Code and checkpoints at: https://github.com/ahans30/goldfish-loss.

###### Abstract

Large language models can memorize and repeat their training data, causing privacy and copyright risks. To mitigate memorization, we introduce a subtle modification to the next-token training objective that we call the _goldfish loss_. During training, a randomly sampled subsets of tokens are excluded from the loss computation. These dropped tokens are not memorized by the model, which prevents verbatim reproduction of a complete chain of tokens from the training set. We run extensive experiments training billion-scale LLaMA-2 models, both pre-trained and trained from scratch, and demonstrate significant reductions in extractable memorization with little to no impact on downstream benchmarks.

## 1 Introduction

Language model _memorization_ is a phenomenon in which models internally store and later regenerate verbatim copies of training data. Memorization creates a number of risks when LLMs are used for commercial purposes. First, there are _copyright risks for customers_, as LLM outputs may contain intellectual property . This is particularly problematic for code models, as the verbatim reuse of code can impact downstream licenses. This is true even when the regenerated code has an open-source license, and many such licenses contain terms that restrict commercial use. Next, there are _copyright risks for providers_, as the legality of hosting and distributing models that can regenerate copyrighted content is not yet resolved. Finally, there are _privacy risks_, as regenerated training data may contain PII or other sensitive data. A number of works  have tried to mitigate memorization through model editing or "unlearning" after the model is trained. Instances of commercial LLMs employing such stopgaps to prevent lawsuits from data owners have been noted . We argue that it is best to stop memorization at the source and leave such approaches for last-mile touchups.

We present the _goldfish loss_, a strikingly simple technique that leverages properties of the next-token prediction objective to mitigate verbatim generation of memorized training data (Section 3). Like standard training, the proposed approach begins with a forward pass on all tokens in a batch. Unlike standard training, in which the next token prediction loss is calculated on all tokens, we exclude a pseudo-random subset (e.g., 25% i.e. with probability \(1/4\)) of the training tokens. The tokens are dropped with \(1/k\) probability where \(k\) is a chosen hyperparameter. On the backward pass, the model never learns to reproduce the excluded tokens. At inference time, the model must make an_unsupervised_ "guess" each time it tries to predict a dropped token, causing it to depart from the training data sequence. In this way, the goldfish loss enables training on text without the ability to make a verbatim reproduction at inference time. We formally introduce goldfish loss in Section3. Throughout the paper, we either use \(k=4\) or refer to it as \(k\)-GL, indicating the value of the drop frequency \(k\).

Our exploration of this idea begins by stress-testing the goldfish loss with a training setup that aggressively promotes memorization (Section4.1). We train a 7B parameter model on a small number of articles for 100 epochs, finding that the models trained with goldfish loss resist memorization while standard training memorizes most of the training data (see Figure1). We then turn to more standard training regimen, where we observe that the memorization metrics of goldfish models closely resemble models that never saw the training data at all (Section4.2). We then look at the utility of goldfish models and observe that they still learn effectively from training data (Section5.1), although in some situations they may need to train for longer than standard models to compensate for the lost tokens that were excluded from the loss (Section5.2). Finally, we try to adversarially extract training data from goldfish models using an aggressive beam search decoder, which typically fails. We do, however, observe that membership inference attacks still work on goldfish models, albeit with marginally lower accuracy (Section6).

## 2 Related Work

### Quantifying Memorization in LLMs

Both benign and adversarial prompting strategies can extract training data from open-sourced large language models (Carlini et al., 2019, 2021; Inan et al., 2021). Carlini et al. (2023) proposes a family of concrete memorization metrics including "extractable memorization" with prefix length \(p\), where if the model memorizes a string, it will regurgitate the rest of the string when prompted with a prefix of length \(p\). This notion of memorization is the focus of our work, as it represents a worst-case scenario and is easy to reproduce in controlled experiments. It should be noted that training data can be extracted without using a \(p\)-prefix. Spontaneous reproducing of training data has been observed in both language models (Nasr et al., 2023) and image generators (Sompalli et al., 2023) without any prior knowledge of the data content. More recently, Schwarzschild et al. (2024) proposes a novel definition for memorization that quantifies whether a training string is extractable by an adversarial prompt that is shorter than the string itself.

### Mitigating Memorization in LLMs

Differentially private (DP) training (Abadi et al., 2016) provides a guarantee that the presence or absence of any single data point will have a minimal impact on the model's output. However, differential privacy can compromise model utility and is resource-intensive, especially for large language models (Anil et al., 2021). The practicality of these methods can be improved by pretraining on sanitized non-sensitive data before DP training (Zhao et al., 2022; Shi et al., 2022).

Figure 1: A pretrained 7B model (the control) is further trained for 100 epochs on (left) the first chapter of Harry Potter or (right) 100 _wikipedia_ documents. We observe a drop in exact match memorization and RougeL metrics when training with goldfish loss (see Section4 for metric descriptions). When prompted with the opening of Harry Potter (gray) the standard model regenerates the original text (red) while the goldfish model does not.

It is known that dedplicating training data can mitigate memorization (Kandpal et al., 2022). However, this is complicated by the scale of web data and the prevalence of near-duplicated versions of many texts. Distinct from work on training time techniques, Ippolito et al. (2022) proposes detection of memorization at test time using a _bloom filter_(Bloom, 1970) data structure. It should be noted that this approach is also vulnerable to missing near-duplicated documents due to the brittle data structure and feature extractors used.

### Regularization and Memorization

Classical definitions of memorization relate to overfitting (Feldman and Zhang, 2020) and argue that memorization is reduced through regularization techniques that reduce overfitting, through strategies such as weight decay and dropout (Srivastava et al., 2014). However, both are insufficient to prevent memorization in LLMs (Tirumala et al., 2022; Lee et al., 2022). Related regularization strategies are the addition of noise to input embeddings (Jain et al., 2024; Wen et al., 2024), or random dropout of tokens during training (Hou et al., 2022). Lin et al. (2024) study dropping tokens from the loss in a data-dependent manner and observe that this can enhance model performance if tokens are carefully selected by a reference model. The idea of dropping parts of each training sample was successfully used to prevent memorization in diffusion models by Daras et al. (2024, 2024). Here, images are degraded by removing many patches before they are used for training. While conceptually related to our proposed method, the goldfish loss achieves high efficiency by computing a forward pass on an entire unaltered text sample, and only excluding information from the backward pass.

Our approach is conceptually quite different because we _forgo randomized regularization_, and construct a localized, pseudo-random token mask -- every time a certain phrase or passage appears in the data, the passage is masked in the same manner, preventing the model from learning the entire passage verbatim (details in Section 3.1). In comparison, if the model is trained with randomized dropout of tokens or weights, it will eventually learn the entire passage, as the passage is seen multiple times with different information masked.

## 3 Goldfish Loss: Learning Without Memorizing

LLMs are commonly trained using a causal language modeling (CLM) objective that represents the average log-probability of a token, conditioned on all previous tokens. For a sequence \(x=\{x_{i}\}\) of \(L\) training tokens, this is written as:

\[()=-_{i=1}^{L} P(x_{i}|x_{<i};)\] (1)

This objective is minimized when the model correctly predicts the sequence \(\{x_{i}\}\) with high confidence. For this reason, models trained by next token prediction can be prone to memorization. However, successful regeneration of a token \(x_{j}\) at test time depends on the correct conditioning of the complete preceding sequence \(x_{<j}\) being provided as input.

The goldfish loss is only computed on a subset of the tokens, and thus prevents the model from learning the entire token sequence. For a choosen a goldfish mask \(G\{0,1\}^{L}\) and goldfish loss is defined as:

\[_{}()=-_{i=1}^{L}G_{i}(x_{i} ) P(x_{i}|x_{<i};).\] (2)

In plain English, we ignore the loss on the \(i\)th token if its mask value is \(G_{i}=0\), and include the token if \(G_{i}=1\). Most importantly, the outputs \(x_{i}\) are still conditioned on all prior tokens \(x_{<i}\), allowing the model to learn the full distribution of natural language over the course of training. Yet, for a given passage, the model does not learn to predict the \(i\)th token, and so is never conditioned on the exact sequence \(x_{<i}\) at test time. Note that the goldfish mask will be chosen independently for each training sample, based on local context using a hash mask (described in detail in Section 3.1).

**Remark**.: _We can simulate the impact of this intervention in a toy computation. Assume we are given a model trained in a standard manner, where \(P(x_{i}|x_{<i})=p,\; i>m\) for some memorized \(x\) from the training data and an integer \(m\). Sampling \(n\) tokens with prefix \(x_{<m}\) regenerates the string \(x_{<m+n}\) perfectly with probability \(p^{n}\). For \(p=0.999,\,n=256\), this happens \(77.40\%\) of the time.__Now assume that we are given a model trained with goldfish loss, where \(P(x_{i}|x_{<i})=p\) on trained tokens due to memorization, and \(P(x_{i}|x_{<i})=q\) on masked tokens due to generalization. Now, we regenerate \(n\) perfect tokens with probability \(p^{2n/3}q^{n/3}\). With \(k=3\), \(p=0.999,q=0.95\), the sequence is sampled with probability of only \(1.06\%\). The compounding effect of the dependence on sequence length \(n\) is critical, for example for sequences of length \(n=16\) the difference is only between \(98.41\%\) for standard loss to \(75.26\%\) for goldfish loss._

There are a range of ways to choose the goldfish mask, after choosing a drop frequency \(k\). A simple baseline that we investigate is to drop every \(k\)th token in a sequence, which we refer to as a **static mask**, which we juxtapose with a **random mask** baseline that drops every token with probability \(1/k\). We use the random mask to differentiate the effects of regularization that random dropping provides from the effects of the goldfish loss, which is deterministic. For our main results, we use **hashed mask** which we discuss in next section.

### Robust Handling of Duplicate Passages with Hashing

Web documents often appear in many non-identical forms. For example, a syndicated news article may appear in many different locations across web, each with a slightly different attribution, different article headers, different advertisements, and different footers. When certain passages appear multiple times in different documents, we should mask the same tokens each time, as inconsistent masking would eventually leak the entire passage. The simple static mask baseline fails here, as the mask is aligned to the pretraining sequence length and not to the content of the text.

To solve this problem, we propose to use a localized **hashed mask**. For a positive integer \(h\) determining the _context width_ of the hash, we mask token \(x_{i}\) if and only if the outputs of a hash function \(f:|V|^{h}\) applied to the \(h\) preceding tokens is less than \(\). With this strategy, the goldfish loss mask for every position depends only on the \(h\) preceding tokens. Every time the same sequence of \(h\) tokens appears, the (\(h+1\))th token is masked in the same way.

With this strategy, \(h\) cannot be too small, or the model may fail to memorize some important \((h+1)\)-grams that should be memorized. For example, if \(h=7\) is used, the model may never learn to produce the word "Power" at the end of the phrase "the Los Angeles Department of Water and Power." Formally, with the hashed mask, of all \((h+1)\)-grams, a fixed subset of size \(\) is never learned. As \(h\) increases, this issue becomes less prominent, as the frequency of \(n\)-grams decreases exponentially due to Zipf's law (Zipf, 1935). However, we also cannot choose \(h\) too large, as then the hash is underdetermined for the first \(h-1\) tokens in the document. In practice, we may never want the model to memorize long \((h+1)\)-grams of a certain length. For example, \(n\)-grams of length \(13\) are rare enough that

Figure 2: **Memorization as Function of \(k\) in Goldfish Loss**: We train 1B parameter models described in Section 4.1 and plot histograms of _RougeL_ scores to measure extractable memorization. Control refers to a model not trained on the 2000 repeated _wikipedia_ documents. We observe that for lower values of k, the extractable memorization is close to the control, and that extract repetitions observed in standard loss are effectively mitigated.

overlaps of 13-grams between train data and test data are used in Brown et al. (2020); Du et al. (2022) as indicative of contamination. Analogously, setting \(h=13\), we consider the memorization of these \(n\)-grams as undesirable, as if this subset had been deduplicated before training (Lee et al., 2022).

Furthermore, it is wise to normalize text before hashing to prevent minor variations in representation (e.g., soft dashes, non-breaking spaces) from impacting the hash. Normalized hash functions of this kind have already been implemented for use in watermarking (Kirchenbauer et al., 2023).

## 4 Can Goldfish Loss Prevent Memorization?

In this section, we validate that the goldfish loss can indeed prevent memorization. We consider two setups: an extreme setup that aggressively promotes memorization with many epochs (i.e., repetitions) on a few samples, and a standard setup that emulates the batching used in realistic model training.

We quantify memorization using two metrics. We first chop each test sequence from the training set into a prefix and a suffix of length \(n\) tokens. Conditioned on the prefix, we autogressively generate text at zero temperature. We compare the generated suffix with the ground truth suffix using two metrics. These are (1) **RougeL score**(Lin, 2004) which quantifies the length of the longest common (non-consecutive) subsequence. A score of \(1.0\) indicates perfect memorization. (2) **Exact Match rate**, which measures the percentage of correctly predicted sequences compared to ground truth. Since the focus of our work is syntactical memorization, we focus on these two metrics. The results for semantic memorization (or knowledge retention) can be found in Appendix C.1.

### Preventing Memorization in Extreme Scenarios

We begin by considering a training setup that is specifically designed to induce memorization. We continue pretraining LLaMA-2-7B model (Touvron et al., 2023) for 100 epochs on a dataset consisting of only 100 English _Wikipedia_(Wikimedia Foundation) articles. We select these documents by randomly sampling a set of pages that contain between \(2000\) and \(2048\) tokens. In Figure 1, we observe that standard training results in verbatim memorization of \(84/100\) articles, while the goldfish loss model with \(k=4\) memorized _none_. RougeL metrics indicate that the model trained with goldfish loss repeats non-consecutive \(n\)-gram sub-sequences that are roughly twice as long as a model that never saw the data. This is consistent with our definition. The model still memorizes subsequences, but the likelihood of getting a long subsequence correct reduces exponentially in the length of the subsequence.

Figure 3: **Benchmark Performance**: We pretrain 1B parameter models on 20 billion tokens as described in Section 4.1 and evaluate downstream performance on various benchmarks. We note only marginal change in performance for models trained with goldfish loss (\(k=3\) and \(k=4\)) in comparison to the model trained with standard loss. Control refers to model trained only on _RedPujama_ and not on _wikipedia_ canaries.

### Preventing Memorization in Standard Training

Our second experimental set-up largely follows that of TinyLLaMA-1.1B (Zhang et al., 2024). We pretrain a language model of size \(1.1\)B with a vocabulary size of \(32\)k. We compare the goldfish loss in Equation 2 at different values of \(k\) and the standard causal language modeling loss in Equation 1. More training details can be found in Appendix A.

We construct the dataset for this experiment based on two sources. First, a subset of _RedPajama_ version 2 (Together Computer, 2023), on which we train for a single epoch. Second, we also mix in \(2000\) target sequences, each of \(1024\) to \(2048\) token length, from the _Wikipedia_(Wikimedia Foundation) corpus. To simulate the problematic case of data that is duplicated within the dataset, we repeat this target set \(50\) times in the course of training, in random locations. In total, we train on \(20\) billion tokens in over \(9500\) gradient steps. We also train a corresponding control model that is trained only \(20\) billion _RedPajama_ tokens.

Under these normal training conditions, the goldfish loss significantly hinders the model's ability to reproduce the target sequences that we mix into the larger training corpus. Figure 2 plots the distribution of _RougeL_ memorization scores for target documents after training. For \(k=3\) and \(k=4\), the distribution of _RougeL_ values mostly overlaps with that of the oblivious control model that did not train on the target documents.

### Divergence Positions vs. Drop Positions

Our intuition is that tokens are not memorized when they are dropped by the goldfish loss, leading to model divergence from the ground truth. To validate this intuition, we analyze the relationship between the positions of dropped tokens and the positions at which the model diverges from the ground truth while attempting to regenerate the sequence. We consider the \(2000\) documents trained for \(50\) epochs in Section 4.2. Figure 4 and Table 1 show the relation between dropped index and first diverged index.

We see that most sequences do not survive beyond the first dropped token without diverging, despite having trained on them 50 times in a row. We also see that divergence locations overwhelmingly coincide with the positions that were masked out. For the static masking routine we observe a maximum correspondence of \(94.1\%\) which decays as the Goldfish drop frequency \(k\) increases (Table 1, top). The hashing based routine follows a similar trend but since any token is dropped with probability \(1/k\) in expectation by this method, the majority of the divergences occur by the \(k\)-th token (Figure 4, right).

## 5 Can LLMs Swallow the Goldfish Loss? Testing Impacts on Model Performance.

The goldfish loss seems to prevent memorization, but what are the impacts on downstream model performance? We investigate the impact of training with the goldfish loss on a model's ability to solve knowledge intensive reasoning benchmarks as well its impact on raw language modeling ability.

For most of the downstream evaluations we consider, the knowledge gained from goldfish training is comparable to standard training.

### Impact on Evaluation Benchmark Performance

First we demonstrate that across an array of popular tasks from the Hugging Face Open LLM Leaderboard. Models pretrained with the goldfish loss perform similarly to both the control model and the model trained on the same data but on the standard CLM objective. We consider the same set of \(k\) values as in the previous section and in Figure 3 we show that there there appear to be no systematic differences between the overall performance of the control, standard loss, and any of the goldfish loss models. The exception is BooIQ, where the control model, which was not trained on Wikipedia, performs poorly. Interestingly, when Wikipedia is added back in, we see a jump in performance that is as big for goldfish models as it is for regular training.

### Impact on Language Modeling Ability

Because goldfish models have, in a sense, trained (or _supervised_) on fewer tokens than standard models, we might expect their raw token prediction ability to trail behind standard models that have seen more tokens. We quantify this impact by tracking a model's token-for-token progress throughout training, as measured by validation loss as well as each model's ability to complete web-text documents from the training data with high semantic coherence to the ground truth.

Validation Loss Curves.To understand the impact on the model's training progression, we analyze the validation loss in terms of the total number of supervised tokens. In Figure 5 (left), we show the validation loss curves over \(12\)M tokens of RedpajamaV2 data. We find that the goldfish loss causes a mild slowdown in pretraining as one would expect from a model that has seen fewer tokens. However, it matches standard pretraining when both are allowed the same number of supervised tokens for loss computation. Supervised tokens indicate the number of unmasked tokens in the goldfish loss case (affected by the chosen \(k\)) and are the same as the input tokens for standard loss. As observed in Figure 5 (right), we show nearly identical final validation loss values can be achieved either by training for a longer duration (increasing the number of steps) or by using a larger batch size.

Since the net number of supervised tokens is fewer with goldfish loss than with standard loss, we plot the number of supervised tokens (i.e., the tokens used in the loss calculation) against the validation loss of RedPajamaV2. For all models, we train with \(20\) billion supervised tokens. This corresponds to \(20\) billion input tokens for the standard loss and \(26.7\) billion input tokens for the goldfish loss. The calculation is based on the formula: \((1-)=\), where \(k=4\).

Additionally, both the standard loss and the goldfish loss with increased batch size follow almost the same validation curve. Thus, we recommend that when using \(k\)-GL, one should use the formula above to appropriately transfer the world batch size from the standard loss run.

Figure 5: **Validation Loss Curves During Pretraining: We measure validation loss on the RedPajamaV2 dataset as training progresses. Left: We observe validation loss as a function of input tokens seen during training. The 4-GL model trail behind the standard loss model for the same number of input tokens. Right: However, when matching the standard loss by the count of _supervised tokens_—i.e., the number of unmasked tokens—either by increasing the number of steps or by expanding the batch size, we observe a similar final validation loss.**

We hypothesize that this is because the total number of supervised tokens per iteration, combined with an aligned learning rate schedule, causes similar progression during training. Moreover, we notice that increasing the total number of steps allows the goldfish loss to advance ahead in training for most of the curve. We suspect this is due to the higher learning rate being maintained for a longer period during training (under standard cosine scheduler).

We conclude that the goldfish loss performs similarly to the standard loss when both are given the same number of _supervised_ tokens. However, to achieve performance parity, goldfish training requires more tokens to be used on the forward pass to compensate for the tokens ignored in the loss computation indicating this is not a free lunch.

Mauve Scores on Training Data Completions.As an additional confirmation that models trained with goldfish loss retain their ability to produce fluent and faithful outputs, we compute _Mauve score_(Pillutla et al., 2021), a metric used to evaluate the quality of generated text against real text by measuring similarity in terms of diversity and naturalness. This metric also noted to be highly correlated with human text.

We present _Mauve scores_ for models trained with goldfish loss on samples from the _Slimpajama_(Soboleva et al., 2023) dataset in Figure 6. We see that under greedy decoding, there is a minimal drop in Mauve scores as compared to the Control or CLM baseline model under any of the \(k\) values tested. However, when temperature \(0.7\), we see scores trend up slightly as \(k\) increases and the model sees more tokens. Note that goldfish loss becomes equivalent to the standard CLM objective in the limit of large \(k\).

## 6 Sharks in the Water: Adversarial Extraction Methods.

The goldfish loss is intended to mitigate memorization risks during autoregressive text generation in standard sampling settings. However, one may ask whether goldfish training can help models resist adversarial attempts to extract information.

### Membership Inference Attacks

Membership inference attacks model a scenario in which the attacker already possesses a possible candidate sample, and attempts to discern whether the sample was used for training. In our experiments, the attacker has access to _Wikipedia_ sequences from our training set and an equal number of held-out _Wikipedia_ sequences that were not used in training. Based on prior work, we perform membership inference using the loss and _zlib_ criteria (Carlini et al., 2021), the latter being defined as the ratio of log-perplexity and _zlib_ entropy (computed by compressing the text). Using these metrics,

Figure 6: **Mauve scores:** We compute Mauve scores for models trained with goldfish loss under different sampling strategies. We see there is a minimal drop in quality compared to the model trained with CLM objective or the Control model. See text for more details.

we formulate a binary classification problem and analyze the receiver operating characteristic (ROC) curves for models trained with and without goldfish loss.

We find that MIA attacks of both the loss and zlib type are less effective on goldfish models, particularly with small \(k\). However, attacks are still possible with some degree of accuracy. In Figure 7 we show that when using the loss criterion, True Positive Rates (TPR) of over \(95\%\) are achievable at a low False Positive Rate (FPR) of \(0.1\%\) on the unprotected, standard loss model. At \(k\) values of \(3\) and \(4\), achievable TPR@\(0.1\%\)FPR plummets to below \(10\%\). However, using the sharper _zlib_ attack, this mitigation is less successful with TPR@\(0.1\%\)FPR remaining well above \(60\%\) for all goldfish settings tested.

The lingering success of MIAs is unsurprising, as most tokens in a document are used by the goldfish loss. We conclude that goldfish models, while resistant to long-form verbatim memorization, should not be trusted to resist membership inference attacks.

### Adaptive Attack: Beam Search

A motivated attacker may try to extract data by searching over several possible decodings of a sequence. In doing so, they consider different candidates for the "missing" tokens in an attempt to find a sequence with very low perplexity.

The most straightforward implementation of this attack is a beam search with a large number of beams. We consider the training setup with standard training from Section 4.2. Figure 8 presents the result of an aggressive beam search with \(30\) beams. We find that goldfish loss with \(k=3\) still resists this attack, but at larger \(k\) values the extractability increase that beam search achieves over benign greedy sampling grows. Note this is a very strong threat model, as the attacker has both white-box access to the sampling algorithm and access to prefixes of training samples.

### Limitations: Don't Mistake Fish Oil for Snake Oil

Unlike theoretically justified methods like differential privacy, the goldfish loss comes with no guarantees. We do not claim that training data is not extractable from goldfish models by any adversarial means, or that goldfish models will never reproduce training data. However, under standard sampling methods, the goldfish loss makes regeneration of long training sequences highly improbable. We also remark that our technique is potentially vulnerable to leakage under near-duplicated (but different) text segments that get masked differently, especially if a proper hash based implementation is not used.

Figure 7: **Membership Inference Attack**: We perform membership inference attack using target (trained on) and validation _wikipedia_ documents. We observe only marginal difference in attack success for goldfish loss in comparison with standard loss.

Finally, prior work has shown that larger models memorize more of their training data, and thus studies of how the benefits afforded by goldfish loss scale to tens or hundreds of billions of parameters is an interesting open question.

## 7 Conclusion

We believe that goldfish loss can be a useful tool in industrial settings due to its simplicity, scalability, and relatively small impacts on model performance. While our experiments apply the loss uniformly over all documents, it can also be selectively applied during late phases of a training curriculum, or to documents from specific high-risk sources. This limits the negative impacts on utility whilst focusing mitigation where it matters most. Furthermore, in situation with plentiful but sensitive content, or low entropy text (e.g. code), one might use higher masking rates than those explored in this paper. We hope that goldfish loss paves the way for aiding copyright compliance rather than serving as a means to misuse private data maliciously.

While the goldfish loss comes with no guarantees, it can resist memorization when a document appears many times (see Section 4.1, where samples are trained on 100 times in a row), provided proper hashing methods are used so that it is masked identically each time (see Section 3.1). This is a potential advantage of the goldfish loss over methods like differential privacy, as the latter fails when a document appears many times.

Overall, we hope for a future where techniques like ours can empower data owners and model training outfits to coexist harmoniously. Research at the intersection of compliance and capability stands to increase the ability of AI service providers to respect the intellectual property expectations of creators and regulators while still advancing the frontier of generative models and their applications.

## 8 Acknowledgments

An award for computer time was provided by the U.S. Department of Energy's (DOE) Innovative and Novel Computational Impact on Theory and Experiment (INCITE) Program. This research used resources of the Oak Ridge Leadership Computing Facility at the Oak Ridge National Laboratory, which is supported by the Office of Science of the U.S. Department of Energy under Contract No. DE-AC05-00OR22725. Financial support was provided by the ONR MURI program and the AFOSR MURI program. Private support was provided by Capital One Bank, the Amazon Research Award program, and Open Philanthropy. Further support was provided by the National Science Foundation (IIS-221282), and by the NSF TRAILS Institute (2229885). We also thank the double blind reviewers for their valuable time and feedback.

Figure 8: **Benchmark Performance**: We pretrain 1B parameter models on 20 billion tokens as described in Section 4.1 and evaluate downstream performance on various benchmarks. We note only marginal change in performance for models trained with goldfish loss (\(k=3\) and \(k=4\)) in comparison to the model trained with standard loss. Control refers to model trained only on _RedPajama_ and not on _wikipedia_ canaries.