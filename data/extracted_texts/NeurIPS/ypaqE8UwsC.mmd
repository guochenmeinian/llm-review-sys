# Federated Ensemble-Directed

Offline Reinforcement Learning

 Desik RengarajanNitin Ragothaman Dileep Kalathil Srinivas Shakkottai

Department of Electrical and Computer Engineering, Texas A&M University

Corresponding author. Email:desik.29@gmail.com

###### Abstract

We consider the problem of federated offline reinforcement learning (RL), a scenario under which distributed learning agents must collaboratively learn a high-quality control policy only using small pre-collected datasets generated according to different unknown behavior policies. Naively combining a standard offline RL approach with a standard federated learning approach to solve this problem can lead to poorly performing policies. In response, we develop the Federated Ensemble-Directed Offline Reinforcement Learning Algorithm (FEDORA), which distills the collective wisdom of the clients using an ensemble learning approach. We develop the FEDORA codebase to utilize distributed compute resources on a federated learning platform. We show that FEDORA significantly outperforms other approaches, including offline RL over the combined data pool, in various complex continuous control environments and real-world datasets. Finally, we demonstrate the performance of FEDORA in the real-world on a mobile robot. We provide our code and a video of our experiments at https://github.com/DesikRengarajan/FEDORA.

## 1 Introduction

Federated learning is an approach wherein clients learn collaboratively by sharing their locally trained models (not their data) with a federating agent, which periodically combines their models and returns the federated model to the clients for further refinement . Federated learning has seen recent success in supervised learning applications due to its ability to generate well-trained models using small amounts of data at each client, while preserving privacy and reducing the usage of communication resources. There has also been interest in federated learning for _online_ reinforcement learning (RL), wherein clients learn via sequential interactions with their environments and federating learned policies across clients . However, such online interactions with real-world systems are often infeasible, and each client might only posses pre-collected operational data generated according to a client-specific behavior policy. The fundamental problem of federated _offline_ RL is on how to learn the optimal policy only using such offline data collected by heterogeneous policies at clients, without actually sharing any of the data.

Offline RL algorithms , such as CQL  and TD3-BC  offer an actor-critic learning approach that only utilizes existing datasets at each client. However, in our case, this approach taken across many small datasets at clients will produce an ensemble of policies of heterogeneous (unknown) qualities across the clients, along with their corresponding critics of variable accuracy. We will see that naively federating such offline RL trained policies and critics using a standard federation approach, such as FedAvg  can lead to a policy that is even worse than the constituent policies. We hence identify the following basic challenges of federated offline RL: (i) _Ensemble heterogeneity:_ Heterogeneous client datasets will generate policies of different performance levels. It is vital to capture the collective wisdom of this ensemble of policies, not average them. (ii) _Pessimistic value_computation:_ Offline RL employs a pessimistic approach toward computing the value of actions poorly represented in the data to minimize distribution shift (and so reduce the probability of taking these actions). However, federation must be ambitious in extracting the highest values as represented in the ensemble of critics (and so promote high-value actions). (iii) _Data heterogeneity:_ As with other federated learning, multiple local gradient steps based on heterogeneous data at each client between federation rounds may lead to biased models. We must regularize local policies to reduce such drift.

In this work, we propose Federated Ensemble-Directed Offline RL Algorithm (FEDORA), which collaboratively produces a high-quality control policy and critic function. FEDORA estimates the performance of client policies using only local data (of unknown quality) and, at each round of federation, produces a weighted combination of the constituent policies that maximizes the overall objective, while regularizing by the entropy of the weights. The same approach is followed to federate client critics. Following the principle of maximum entropy in this manner produces both federated policies and critics that extract the collective wisdom of the ensemble. In doing so, it constructs a federated policy and a critic based on the relative merits of each client policy in an ensemble learning manner. FEDORA ensures optimism across evaluation by the federated and local critic at each client and so sets ambitious targets to train against. It addresses data heterogeneity by regularizing client policies with respect to both the federated policy and the local dataset. Finally, FEDORA prunes the influence of irrelevant data by decaying the reliance on a dataset based on the quality of the policy it can generate. To the best of our knowledge, no other work systematically identifies these fundamental challenges of offline federated RL, or designs methods to explicitly tackle each of them.

We develop a framework for implementing FEDORA either on a single system or over distributed compute resources. We evaluate FEDORA on a variety of MuJoCo environments and real-world datasets and show that it outperforms several other approaches, including performing offline RL on a pooled dataset. We also demonstrate FEDORA's excellent performance via real-world experiments on a TurtleBot robot .

## 2 Related Work

**Offline RL:**The goal of offline RL is to learn a policy from a fixed dataset generated by a behavior policy . One of the key challenges of the offline RL approach is the distribution shift problem where the state-action visitation distribution of learned policy may be different from that of the behavior policy which generated the offline data. It is known that this distribution shift may lead to poor performance of the learned policy . A common method used by offline RL algorithms to tackle this problem is to learn a policy that is close to the behavior policy that generated the data via regularization either on the actor or critic [5; 7; 16; 14; 33]. Some offline RL algorithms perform weighted versions of behavior cloning or imitation learning on either the whole or subset of the dataset [31; 22; 3]. [38; 37] propose data rebalancing methods designed to prioritize highly-rewarding transitions that can be augmented to offline RL algorithms to alleviate the distribution shift issue for heterogeneous data settings.

**Federated Learning:** introduced FedAvg, a federation strategy where clients collaboratively learn a joint model without sharing data. A generalized version of FedAvg was presented in . A key problem in federated learning is data heterogeneity wherein clients have non-identically distributed data, which causes unstable and slow convergence [30; 11; 18]. To tackle the issue of data heterogeneity,  proposed FedProx, a variant of FedAvg, where a proximal term is introduced reduce deviation by the local model from the server model.

**Federated Reinforcement Learning:** Federated learning has recently been extended to the online RL setting.  analyzed the performance of federated tabular Q-learning.  combined traditional online RL algorithms with FedAvg for multiple applications. Some works propose methods to vary the weighting scheme of FedAvg according to performance metrics such as the length of a rally in the game of Pong  or average return in the past \(10\) training episodes  to achieve better performance or personalization.  proposed a method to compute weights using attention over performance metrics of clients such as average reward, average loss, and hit rate for an edge caching application.  used a transformer encoder to learn contextual relationships between agents in the online RL setting.  proposed an alternative approach to federation where reward shaping is used to share information among clients.  proposed a KL divergence-based regularization between the local and global policy to address the issue of data heterogeneity in an online RL setting.

In the offline RL setting,  propose federated dynamic treatment regime algorithm by formulating offline federated learning using a multi-site MDP model constructed using linear MDPs. However, this approach relies on running the local training to completion followed by just one step of federated averaging. Unlike this work, our method does not assume linear MDPs, which is a limiting assumption in many real-world problems. Moreover, we use the standard federated learning philosophy of periodic federation followed by multiple local updates. _To the best of our knowledge, ours is the first work to propose a general federated offline RL algorithm for clients with heterogeneous data._

## 3 Preliminaries

**Federated Learning:** The goal of federated learning is to minimize the following objective,

\[F()=_{i}[F_{i}()],\] (1)

where \(\) represents the parameter of the federated (server) model, \(F_{i}\) denotes the local objective function of client \(i\), and \(\) is the distribution over the set of clients \(\). The FedAvg algorithm  is a popular method to solve Eq. (1) in a federated way. FedAvg divides the training process into rounds, where at the beginning of each round \(t\), the server broadcasts its current model \(^{t}\) to all the clients, and each client initializes its current local model to the current server model. Clients perform multiple local updates on their own dataset \(_{i}\) to obtain an updated local model \(^{t}_{i}\). The server then averages these local models proportional to the size of their local dataset to obtain the server model \(^{t+1}\) for the next round of federation, as

\[^{t+1}=_{i=1}^{||}w_{i}^{t}_{i}, w_{i}=_{i}|}{||},||=_{i=1}^{| |}|_{i}|.\] (2)

**Reinforcement Learning:** We model RL using the Markov Decision Process (MDP) framework denoted as a tuple \((,,R,P,,)\), where \(\) is the state space, \(\) is the action space, \(R:\) is the reward function, and \(P:\) denotes the transition probability function that gives the probability of transitioning to a state \(s^{}\) by taking action \(a\) in state \(s\), \(\) is the discount factor, and \(\) is the distribution of the initial state \(s_{0}\). A policy \(\) is a function that maps states to actions (deterministic policy) or states to a distribution over actions (stochastic policy). The goal of RL is to maximize the infinite horizon discounted reward of policy \(\), defined as \(J()=_{,P,}[_{t=0}^{}^{t}R(s_{t},a_{t})]\), which is the expected cumulative discounted reward obtained by executing policy \(\). The state-action value function (or Q function) of a policy \(\) at state \(s\) and executing action \(a\) is the expected cumulative discounted reward obtained by taking action \(a\) in state \(s\) and following policy \(\) thereafter: \(Q^{}(s,a)=_{,P}[_{t=0}^{}^{t}R(s_{t},a_{t })|s_{0}=s,a_{0}=a]\).

**Offline Reinforcement Learning:** The goal of offline RL is to learn a policy \(\) only using a static dataset \(\) of transitions \((s,a,r,s^{})\) collected using a behavior policy \(_{}\) without any additional interactions with the environment. Offline RL algorithms typically utilize some kind of regularization with respect to the behavior policy to ensure that the learned policy does not deviate from the behavior policy. This regularization is done to prevent distribution shift, a significant problem in offline RL, where the difference between the learned policy and behavior policy can lead to erroneous Q-value estimation of state-action pairs not seen in the dataset [16; 17].

Our approach is compatible with most offline RL algorithms, such as CQL  or TD3-BC . We choose TD3-BC for illustration, motivated by its simplicity and its superior empirical performance in benchmark problems. The TD3-BC algorithm is a behavior cloning (BC) regularized version of the TD3 algorithm . The policy in TD3-BC is updated using a linear combination of TD3 objective and behavior cloning loss, where the TD3 objective ensures policy improvement and the BC loss prevents distribution shift. More precisely, the TD3-BC objective can be written as

\[ =*{arg\,max}_{}\;U_{}(),\] (3) \[ U_{}() =_{s,a}[ Q^{}(s,(s))-( (s)-a)^{2}],\] (4)

and \(\) is a hyperparameter that determines the relative weight of the BC term.

Federated Offline Reinforcement Learning

In real-world offline RL applications, data is typically obtained from the operational policies of multiple agents (clients) with different (unknown) levels of expertise. Clients often prefer not to share data. We aim to learn the optimal policy for the underlying RL problem using only such offline data, without the clients knowing the quality of their data, or sharing it with one another or the server. Furthermore, neither the clients nor server have access to the underlying model or the environment. We denote the set of clients as \(\). Each client \(i\) has the offline dataset \(_{i}=\{(s_{j},a_{j},r_{j},s^{}_{j})_{j=1}^{m_{i}}\}\) generated according to a behavior policy \(_{i}^{b}\). We assume that the underlying MDP model \(P\) and reward function \(R(,)\) are identical for all the clients, and the statistical differences between the offline datasets \(_{i}\) are only due to the difference in behavior policies \(_{i}^{b}\) used for collecting the data.

In a standard federated learning algorithm such as FedAvg, each client performs multiple parameter updates before sending its parameters to the server. It is known that performing multiple local updates in federated learning can reduce the communication cost significantly without compromising on the optimality of the converged solution [10; 30]. In federated offline RL, since each client has to perform multiple steps of policy evaluation and policy update using its local offline data \(_{i}\), it is reasonable to consider a client objective function that is consistent with a standard offline RL algorithm objective. We choose the objective function used in the TD3-BC algorithm , i.e., \(U_{_{i}}\) given in Eq. (3), as the client objective function. Our choice is motivated by the simplicity of the TD3-BC objective function and its empirical success in a variety of environments. Similar to the standard federated learning objective given in Eq. (1), we can now define the federated offline RL objective as

\[U(_{})=_{i=1}^{||}w_{i}U_{_{i}}(_{ }),\] (5)

where \(w_{i}\) are weights to be determined.

One approach to leveraging experiences across users without sharing data would be to combine existing federated learning techniques with offline RL algorithms. _Is such a naive federation strategy sufficient to learn an excellent federated policy collaboratively? Furthermore, is federation even necessary?_ In this section, we aim to understand the challenges of federated offline RL with the goal of designing an algorithmic framework to address these challenges.

We start by illustrating the issues in designing a federated offline RL algorithm. We consider the Hopper environment from MuJoCo , with \(||=10\), \(|_{i}|=5000\), and we use the data from the D4RL dataset . However, instead of using the data generated by the same policy for all clients, we consider the setting where five clients use the data from the hopper-expert-v2 dataset (which was generated using a completely trained (expert) SAC policy) and five clients use the data from the hopper-medium-v2 dataset (which was generated using a partially trained (medium) policy achieving only a third of the expert performance). The clients and the server are unaware of the quality (expert or medium) of the data. Fig. 1 shows the performance comparison of multiple algorithms, where the mean and the standard deviation are calculated over \(4\) seeds.

**Combining All Data (Centralized):** Combining data and learning centrally is the ideal scenario in supervised learning. However, as seen in Fig. 1, performing centralized training over combined data generated using different behavior policies in offline RL can be detrimental. This is consistent with  that proves that pooling data from behavior policies with different expertise levels can exacerbate the distributional shift between the learned policy and the individual datasets, leading to poor performance. Similar deterioration due to combining data has also been observed in other offline RL literature [5; 16]. We also explore centralized algorithms with data re-balancing, and observer that FEDORA is still superior (See Appendix B.9). We would like to further emphasise that combining the data from all clients is a hypothetical base in the federated setting, as data is distributed amongst clients and cannot be combined.

**Individual Offline RL:** Here, agents apply offline RL to their own datasets without collaborating with others. In Fig. 1, we observe that clients with either expert or medium data do not learn well and

Figure 1: Performance comparison of federated and centralized offline RL algorithms.

exhibit a large standard deviation. This observation may be attributed to no client having sufficient data to learn a good policy.

**Naive Federated Offline RL:** A simple federation approach is to use the offline RL objective as the local objective and apply FedAvg (Eq. (2)). However, offline RL algorithms typically comprise two components - an actor and a critic. It is unclear a priori which components should be federated, so we conduct experiments where we federate only the actor (Fed-A) or both the actor and the critic (Fed-AC). Surprisingly, these naive strategies result in federated policies that perform worse than individual offline RL, as seen in Fig. 1.

### Issues with Federated Offline RL

Our example illustrates several fundamental issues that must be addressed while designing viable federated offline RL algorithms, including:

**1. Ensemble Heterogeneity:** Performing offline RL over heterogeneous data yields a set of policies of different qualities. It is crucial to leverage the information contained in these varied policies rather than simply averaging them. However, federation after a single-step local gradient at each client using weights in the manner of FedAvg, \(w_{i}=|_{i}|/_{i=1}^{||}|_{i}|\), is equivalent to solving the offline RL problem using the combined dataset of all clients . This approach leads to poor performance due to the resulting distribution shift, as shown in Fig. 1. _How should we optimally federate the ensemble of policies learned by the clients?_

**2. Pessimistic Value Computation:** Most offline RL algorithms involve a pessimistic term with respect to the offline data for minimizing the distribution shift. Training a client critic using only the local data with this pessimistic term could make it pessimistic towards actions poorly represented in its dataset but well represented in other clients' data. _How do we effectively utilize the federated critic along with the locally computed critic to set ambitious targets for offline RL at each client?_

**3. Data Heterogeneity:** Federated learning calls for performing multiple local gradient steps at each client before federation to enhance communication efficiency. However, numerous epochs would bias a client's local model to its dataset. This client drift effect is well known in federated (supervised) learning and could lead to policies that are not globally optimal. In turn, this could cause the federated policy's performance to be worse than training locally using only the client's data, as seen in Fig. 1. _How should we regularize local policies to prevent this?_

## 5 FEDORA Design Approach

We desire to develop a Federated Ensemble-Directed Offline RL Algorithm (FEDORA) that addresses the issues outlined in Section 4 in a systematic manner. Three fundamental requirements drive our approach. First, the clients jointly possess an ensemble of local policies of different (unknown) qualities, and the server must leverage the collective knowledge embedded in this ensemble during federation. Second, the quality of these policies must be assessed using an ensemble of critics that depend on local data for policy evaluation. Finally, after each round of federation, clients must update their local policies via offline RL utilizing both their local data and the received federated policy.

Maximizing the federated offline reinforcement learning (RL) objective in Eq. (5) using FedAvg would set weights as in Eq. (2), i.e., each client's contribution is weighted by the size of its dataset. This is is equivalent to solving the offline RL problem using the combined dataset of all clients. However, such an approach exacerbates the distribution shift problem that affects offline RL algorithms, leading to poor performance. This issue has been verified analytically and empirically in . We illustrated this phenomenon in Fig. 1, where offline RL over pooled data resulted in a sub-optimal policy. The recommendation in  is to share data conservatively by identifying which samples are likely to result in policy improvement. However, we cannot share any of the data across clients in the federated offline RL setting.

Our solution is to follow the principle of maximum entropy to choose weights that best represent the current knowledge about the relative merits of the clients' policies. Here, the weights are prevented from collapsing over a few clients that have the best current performance by adding an entropy regularization over the weights with temperature parameter \(\) resulting in the following objective:

\[U(_{})=_{i=1}^{||}w_{i}U_{_{i}}(_{ })-_{i=1}^{||}w_{i} w_{i}.\] (6)

We can then show using a Lagrange dual approach that this objective is maximized when

\[w_{i}=_{i}}(_{})}}{_{i=1}^{| |}e^{ U_{_{i}}(_{})}}.\] (7)

Based on these soft-max type of weights suggested by the entropy-regularized objective, we now design FEDORA accounting for each of the three requirements indicated above.

In what follows, \(_{i}^{(t,k)}\) denotes the policy of client \(i\) in round \(t\) of federation after \(k\) local policy update steps. Since all clients initialize their local policies to the federated policy at the beginning of each round of federation, \(_{i}^{(t,0)}=_{}^{t}\) for each client \(i\). We also denote \(_{i}^{t}=_{i}^{(t,K)}\), where \(K\) is the maximum number of local updates. Since all clients initialize their local critics to the federated critic, we can similarly define \(Q_{i}^{(t,k)}\), \(Q_{i}^{(t,0)}=Q_{}^{t}\), and \(Q_{i}^{t}=Q_{i}^{(t,K)}\) for the local critic.

### Ensemble-Directed Learning over Client Policies

We first require a means of approximating \(U_{_{i}}(_{})\) in order to determine the weight \(w_{i}\) of client \(i\) as shown in Eq. (7). We utilize the performance of the final local policy \(J_{i}^{t}=_{s_{i}}[Q_{i}^{t}(s,_{i}^{t}(s)) ],\) which also characterizes the relative performance at client \(i\), as a proxy for \(U_{_{i}}(_{})\). Here, \(Q_{i}^{t}\) is the local critic function at round \(t\) after \(K\) local updates. It is hard to directly obtain such an unbiased local critic \(Q_{i}^{t}\) in offline RL, since we do not have access to the environment for executing the policy and evaluating its performance. Our approach toward computing \(Q_{i}^{t}\) and \(_{i}^{t}\) are described later. The accuracy of the local estimates \(J_{i}^{t}\) are highly dependent on the number of data samples available at \(i\), and so in the usual manner of federated averaging, we need to account for the size of the dataset \(|_{i}|\) while computing weights. We thus have client weights and federated policy update as

\[w_{i}^{t}=^{t}}|_{i}|}{_{i=1}^{||}e^{ J_{i}^{t}}|_{i}|},_{}^{t+1}=_{i= 1}^{||}w_{i}^{t}_{i}^{t}.\] (8)

### Federated Optimism for Critic Training

The critic in our algorithm plays two major roles. First, offline RL for policy updates at each client requires policy evaluation using local data. Second, policy evaluation by the critic determines weight \(w_{i}^{t}\) of the local policy at client \(i\) for ensemble learning during each round \(t\) of federation. We desire a local critic at each client that can utilize the knowledge from the ensemble of critics across all clients while also being tuned to the local data used for policy evaluation.

A critic based on offline data suffers from extrapolation errors as state-action pairs not seen in the local dataset will be erroneously estimated, greatly impacting actor-critic style policy updates in federated offline RL. Since the federated policy is derived from the set of local policies, it may take actions not seen in any client's local dataset. This problem is exacerbated when the local policy at the beginning of each communication round is initialized to the federated policy. We introduce the notion of _federated optimism_ to train local critics, wherein critics leverage the wisdom of the crowd and are encouraged to be optimistic. We achieve this federated optimism via two steps.

First, we use an ensemble-directed federation of the critics, where the local critic of client \(i\) at round \(t\) is weighed according to its merit to compute the federated critic as

\[Q_{}^{t+1}=_{i=1}^{||}w_{i}^{t}Q_{i}^{t}.\] (9)

Such entropy-regularized averaging ensures that the critics from clients with good policies significantly influence the federated critic.

Second, for the local critic update, we choose the target value as the maximum value between the local critic and the federated critic, given by \(_{i}^{(t,k)}(s,a)=(Q_{i}^{(t,k)}(s,a),Q_{}^{t}(s,a) ),\) where \(_{i}^{(t,k)}(s,a)\) is the target value of state \(s\) and action \(a\) at the \(t^{}\) round of federation after \(k\) local critic updates. This ensures that the local critic has an optimistic (but likely feasible) target seen by the system. Using this optimistic target in the Bellman error, we update the local critic as

\[Q_{i}^{(t,k+1)}=*{arg\,min}_{Q}\ _{(s,a,r,s^{}) _{i}}[(r+_{i}^{(t,k)}(s^{},a^{})-Q(s,a))^{2}],\] (10)

where \(a^{}=_{i}^{(t,k)}\). In practice, we obtain \(Q_{i}^{(t,k+1)}\) after a single gradient update.

### Proximal Policy Update for Heterogeneous Data

While essential in order to set ambitious estimates, an optimistic critic might erroneously estimate the value of \(_{i}^{(t,k)}\). Therefore, regularizing the local policy update w.r.t. both the local data and the federated policy is crucial. For regularization w.r.t. to the local offline data, we use the same method as in the TD3-BC algorithm and define the local loss function \(_{}()=_{(s,a)_{i}}[-Q_{i}^ {(t,k)}(s,(s))+((s)-a)^{2}]\). We then define the actor loss \(_{}\) in Eq. (11), where the second term is a regularization w.r.t. to the federated policy. The local policy is updated using \(_{}\),

\[_{}()=_{}()+_{( s,a)_{i}}[((s)-_{}^{t}(s))^{2}],_{i}^{t,k+1 }=*{arg\,min}_{}\ _{}().\] (11)

### Decaying the Influence of Local Data

FEDORA uses a combination of local data loss and a proximal term for its policy update Eq. (11). However, the local data loss might hamper the updated policy's performance since the local dataset may be generated according to a non-expert behavior policy. Hence, a client must decay the influence of its local data if it is reducing the performance of the updated policy by lowering the influence of \(_{}\) in \(_{}\). To do so, we first evaluate the performance of the federated policy using the federated critic and local data at round \(t\). For this evaluation, we use the proxy estimate \(J_{i}^{,t}=_{s_{i}}[Q_{}^{t}(s, _{}^{t}(s))]\). We compare this value with the performance of the updated policy, \(J_{i}^{t}\), which is obtained using the updated critic. This difference provides us with an estimate of the improvement the local data provides. We decay the influence of \(_{}\) by a factor \(\) if \(J_{i}^{,t} J_{i}^{t}\).

We summarize FEDORA in Algorithm 1 and 2. We would like to emphasize that in our algorithm, as in any offline RL setting, the clients or server do not have access to the environment or the MDP. Further, we would like to point out that the clients are not aware of the quality of data they possess.

Figure 2: Evaluation of algorithms on different MuJoCo environments.

```
1:function train_client(\(_{}^{t}\), \(Q_{}^{t}\))
2:\(_{i}^{(t,0)}=_{}^{t}\), \(Q_{i}^{(t,0)}=Q_{}^{t}\)
3:for\(1 k<K\)do
4: Update Critic by one gradient step w.r.t. Eq. (10)
5: Update Actor by one gradient step w.r.t. Eq. (11)
6:endfor
7: Decay \(_{}\) by \(\) if \(J_{i}^{,t} J_{i}^{t}\)
8:endfunction ```

**Algorithm 1** Outline of Client \(i\)'s Algorithm

## 6 Experimental Evaluation

We conduct experiments to answer three broad questions: **(i) Comparative Performance:** How does FEDORA perform compared to other approaches with client data generated by heterogeneous behavior policies?, **(ii) Sensitivity to client updates and data quality:** How does the performance depend on the number of local gradient steps at clients, the randomness in the available number of agents for federation, and the quality of the data at the clients?, and **(iii) Ablation:** How does the performance depend on the different components of FEDORA? We implement FEDORA over the Flower federated learning platform  which supports learning across devices. We also provide a simulation setup that can be executed on a single machine (See Appendix A).

**Baselines:** We consider the following baselines. **(i) Fed-A:** The local objective of all clients follows TD3-BC (Eq. 3). The server performs FedAvg over the actor's parameters, whereas each client learns the critic locally. **(ii) Fed-AC:** The local objective of all clients follows TD3-BC and the server performs FedAvg over the parameters of both the actor and the critic. **(iii) Fed-AC-Prox:** We add a proximal term to Fed-AC, which has been shown to help in federated supervised learning when clients have heterogeneous data . **(iv) Heterogeneous Data-Aware Federated Learning (HDAFL)** We extend HDAFL  to the offline RL setting by dividing the actor network into generic and client-specific parts and then federating only the generic part during each round. **(v) Centralized:** We perform offline RL (TD3-BC) over the pooled data by combining the data present in all clients.

### Experiments on Simulated Environments

**Experimental Setup:** We focus on a scenario where clients are collaboratively learning to solve the same task, but the behavior policies used to collect data for each client could differ. We run experiments with the number of clients \(||=50\), with each client having a local dataset of size \(|_{i}|=5000\). Of these \(50\) clients, \(25\) are provided with data from the D4RL  expert dataset, while the other \(25\) are provided with data from the D4RL medium dataset. The clients (and the server) are unaware of the quality of their datasets. Further, both the client and server do not have access to the environment. We choose \(|_{t}|=20\) clients at random to participate in each round \(t\) of federation. The server obtains weights from clients in \(|_{t}|\) and computes the federated weight \(_{}^{t+1}\) and \(Q_{}^{t+1}\). For each plot, we evaluate the performance with four different seeds. We evaluate the performance of FEDORA and baselines over three MuJoCo tasks: Hopper, HalfCheetah, and Walker2D. During a round of federation, each client performs \(20\) epochs of local training in all algorithms, which is roughly \(380\) local gradient steps in our experimental setup.

**Comparative Performance of FEDORA:** In Fig. 2, we plot the cumulative episodic reward of the server/federated policy during each round of communication/federation. We observe that FEDORA outperforms all federated baselines and achieves performance equivalent to or better than centralized training. Furthermore, the federated baselines fail to learn a good server policy even after training for many communication rounds and plateau at lower levels compared to FEDORA, emphasizing that the presence of heterogeneous data hurts their performance.

To understand the effect of data coming from multiple behavior policies on centralized training, we consider a scenario where \(50\) clients with datasets of size \(|D_{i}|=5000\) participate in federation, with \(25\) clients having expert data and the other \(25\) having random data, i.e., data generated from a random policy. From Fig. 3, we notice that combining data of all clients deteriorates performance as compared to FEDORA. This observation highlights the fact that performing centralized training with data collected using multiple behavior policies can be detrimental.

**Sensitivity to Client Updates and Data Quality:** We study the sensitivity of FEDORA to client update frequency and data quality in the Hopper environment in the same setting as in Fig. 2. Increasing the number of local training steps can improve communication efficiency, but is detrimental under heterogeneous data due to client drift . In Fig. 4(a), we study the effect of varying the number of local training epochs. We observe that increasing the number of epochs leads to faster learning, emphasizing that FEDORA can effectively learn with heterogeneous data. Not all clients may participate in every round of federation due to communication/compute constraints. In Fig.4(b), we study the effect of the fraction of clients participating in federation. We observe that FEDORA is robust towards variations in the fraction of clients during federation. Finally, in Fig. 4(c) we study the effect of data heterogeneity by varying the percentage of clients with expert datasets. We observe that FEDORA performs well even when only \(20\%\) of the total clients have expert-quality data. We present several ablation studies and additional experiments in appendix B.

### Real-World Experiments on TurtleBot

We evaluated the performance of FEDORA on TurtleBot , a two-wheeled differential drive robot (Fig. 6) to collaboratively learn a control policy to navigate waypoints while avoiding obstacles using offline data distributed across multiple robots (clients). This scenario is relevant to several real-world applications, such as cleaning robots in various houses, which aim to collaboratively

Figure 4: Effect of varying the number of (a) local gradient steps, (b) participating clients in each round, and (c) expert clients in FEDORA.

Figure 5: Evaluation of FEDORA and other federated baselines for a mobile robot navigation task in the presence of an obstacle.

Figure 3: Comparison of FEDORA and centralized training with heterogeneous data.

learn a control policy to navigate and avoid obstacles using data distributed across different robots. Collaborative learning is essential, because a single robot might not have enough data to learn from or have encountered adequately different scenarios. Additionally, federated learning overcomes the privacy concerns associated with sharing data among the robots.

We collect data in the real-world using four behavior policies with varying levels of expertise ( Fig. 5(a)). We train over \(20\) clients for \(100\) communication rounds, each consisting of \(20\) local epochs (see Fig. 5(c)). Fig. 5(b) shows the trajectories obtained by the learned policies of different algorithms in the real-world, and only FEDORA is able to successfully reach the target by avoiding the obstacle. We provide more details in Appendix C. We provide a video of our experiments at https://github.com/DesikRengarajan/FEDORA.

## 7 Conclusion

We presented an approach for federated offline RL, accounting for the heterogeneity in the quality of the ensemble of policies that generated the data at the clients. We solved multiple challenging issues by systematically developing a well-performing ensemble-directed approach entitled FEDORA, which extracts the collective wisdom of the policies and critics and discourages excessive reliance on irrelevant local data. We demonstrated its performance on several simulation and real-world tasks.

## 8 Ethics Statement and Societal Impacts

In this work, we introduce a novel algorithm for federated offline reinforcement learning. The domain of federated offline RL offers the potential for widespread implementation of RL algorithms while upholding privacy by not sharing data, as well as reducing the need for communication. Throughout our study, no human subjects or human-generated data were involved. As a result, we do not perceive any ethical concerns associated with our research methodology.

While reinforcement learning holds great promise for the application in socially beneficial systems, caution must be exercised when applying it to environments involving human interaction. This caution arises from the fact that guarantees in such scenarios are probabilistic, and it is essential to ensure that the associated risks remain within acceptable limits to ensure safe deployments.

## 9 Limitations and Future work

In this work, we examine the issue of Federated Offline RL. We make the assumption that all clients share the same MDP model (transition kernel and reward model), and any statistical variances between the offline datasets are due to differences in the behavior policies used to collect the data. Moving forward, we aim to broaden this to cover scenarios where clients have different transition and reward models. To achieve this, we plan to extend ideas from offline meta RL to the federated learning scenario. Furthermore, we plan to explore personalization in federated offline RL as an extension to our research. We also believe that our approach may also be useful in the context of federated supervised learning, especially when the data is sourced from varying qualities, and we intend to formally investigate this in the future as a separate line of work.

## 10 Acknowledgement

This work was supported in part by NSF Grants CNS 2312978, ECCS 2038963, ARO Grant W911NF-19-1-0367, and NSF-CAREER-EPCN-2045783. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the sponsoring agencies.

Portions of this research were conducted with the advanced computing resources provided by Texas A&M High Performance Research Computing.

Figure 6: Turtle-Bot3 Burger.