# Provably Safe Neural Network Controllers

via Differential Dynamic Logic

 Samuel Teuber\({}^{1}\) Stefan Mitsch \({}^{2}\) Andre Platzer \({}^{1,3}\)

\({}^{1}\) Karlsruhe Institute of Technology \({}^{2}\) DePaul University \({}^{3}\) Carnegie Mellon University

teuber@kit.edu smitsch@depaul.edu platzer@kit.edu

###### Abstract

While neural networks (NNs) have a large potential as autonomous controllers for Cyber-Physical Systems, verifying the safety of _neural network based control systems (NNCSs)_ poses significant challenges for the practical use of NNs--especially when safety is needed for _unbounded time horizons_. One reason for this is the intractability of analyzing NNs, ODEs and hybrid systems. To this end, we introduce VerSAILLE (**Ver**ifiably **S**afe **A**I** via **L**ogically **L**inked **E**nvelopes): The first general approach that allows reusing control theory literature for NNCS verification. By joining forces, we can exploit the efficiency of NN verification tools while retaining the rigor of differential dynamic logic (\(\)). Based on a provably safe control envelope in \(\), we derive a specification for the NN which is proven with NN verification tools. We show that a proof of the NN's adherence to the specification is then _mirrored_ by a \(\) proof on the infinite-time safety of the NNCS.

The NN verification properties resulting from hybrid systems typically contain _nonlinear arithmetic_ over formulas with _arbitrary logical structure_ while efficient NN verification tools merely support linear constraints. To overcome this divide, we present Mosaic: An efficient, _sound and complete_ verification approach for polynomial real arithmetic properties on piece-wise linear NNs. Mosaic partitions complex NN verification queries into simple queries and lifts off-the-shelf linear constraint tools to the nonlinear setting in a completeness-preserving manner by combining approximation with exact reasoning for counterexample regions. In our evaluation we demonstrate the versatility of VerSAILLE and Mosaic: We prove infinite-time safety on the classical Vertical Airborne Collision Avoidance NNCS verification benchmark for some scenarios while (exhaustively) enumerating counterexample regions in unsafe scenarios. We also show that our approach significantly outperforms the State-of-the-Art tools in closed-loop NNV.

## 1 Introduction

For controllers of Cyber-Physical Systems (CPSs), the use of neural networks (NNs) is both a blessing and a curse. On the one hand, using NNs allows the development of goal-oriented controllers that optimize soft requirements such as passenger comfort, frequency of collision warnings or energy efficiency. On the other hand, guaranteeing that _all_ control decisions chosen by an NN are safe is very difficult due to the complex feedback loop between the subsymbolic reasoning of an NN and the intricate dynamics often encountered in physical systems. How can this curse be alleviated? Neural Network Verification (NNV) techniques all have tried one of three strategies: Open-loop NNV entirely omits the analysis of the physical system and only analyzes input-output properties of the NN . Open-loop analyses alone cannot justify the safety of an NNCS, because they ignore its physical, feedback-loop dynamics. Closed-loop NNV performs a time-bounded analysis of the feedback loop between the NN and its physical environment . Unfortunately, a safety guarantee that comes with a time-bound (measured in secondsrather than minutes or hours) is often insufficient when it comes to deploying safety-critical NNCSs in the real world. For example, the safety of an adaptive cruise control system must be independent of the trip length. Finally, another line of work explored techniques for learning and then verifying _approximations of_ barrier certificates for infinite-time guarantees . For _continuous-time_, verification has not been scaled beyond simple linear control functions [25, Appendix] as it requires open-loop NNV w.r.t. nonlinear specifications, which is a notoriously neglected topic .

As an alternative to the three outlined approaches, we propose to verify NNCSs based on the rigorous mathematical foundations of differential dynamic logic (dL).dL is a program logic allowing the proof of infinite-time safety for abstract, nondeterministic control strategies (often called control envelopes). Due to its expressiveness and its powerful proof calculus,dL even allows the derivation of such guarantees for continuous-time systems or systems whose differential equations have no closed-form solution. By grounding our verification approach indL, we can reuse safety results from the control theory literature for NN verification - especially for cases where characterizations of safe behavior and controllable/invariant regions are known (e.g. airborne collision avoidance ). How this knowledge can be reused is a non-trivial question: WhiledL is an excellent basis for reasoning about symbolic control strategies, the numerical/subsymbolic reasoning of NNs at their scale is far beyond the intended purpose ofdL's proof calculus. Conversely, open/closed-loop NNV tools and barrier certificates lack the infinite-time and exact reasoning available withindL. This work demonstrates how open-loop NNV can be combined withdL reasoning to combine their strengths while canceling out their weaknesses. Consequently, by relying on results from the control theory literature, we prove infinite-time safety guarantees for NNCSs that are not provable through either technique alone.

Overview.This paper alleviates the curse of NNCS safety. As shown in Figure 1, our work integrates the deductive approach ofdL with techniques for open-loop NNV. To apply our approach, we assume that an abstract, nondeterministic control envelope has already been verified indL (via KeYmaera X , synthesized via CESAR  or from the literature). Based on thedL safety result, VerSAILLE (**Ver**ifiably Safe **AI** via **L**ogically **L**inked **E**nvelopes; Section 3) derives a verification query for open-loop NNV by instrumenting ModelPlex . By reflecting the NN through a _mirror program_ indL, we can then reason about an NNCS in- and outside thedL calculus simultaneously. The verification of an open-loop NNV query generated by VerSAILLE yields adL proof that the NNCS refines a safe control envelope --implying that the infinite-time safety guarantee carries over to the NNCS.

Due to the inherent nonlinearities of hybrid systems, the generated open-loop NNV queries often contain polynomial arithmetic and the formulas have arbitrary logical structure. Hence for such queries, we also introduce Mosaic--an efficient, _sound and complete_ framework for open-loop NNV tools. The approach _lifts_ complete off-the-shelf open-loop NNV tools for linear constraints to _polynomial_ constraints with _arbitrary_ logical structure. To this end, we combine approximation with a generalization of DPLL(T) that makes the logical decomposition _efficiently_ applicable to NN verification (whereas "classical" DPLL(T) would become prohibitively inefficient). At the same time, Mosaic retains completeness by generalizing counterexamples into locally affine regions (Section 4). In summary, VerSAILLE provides rigorous semantics and a formal proof of infinite-time safety, while Mosaic makes our approach practically applicable to real-world systems (see also Section 5).

Contribution.Our contribution has three parts. While our implementation (N\({}^{3}\)V) supports NNs most commonly analyzed by open-loop NNV (ReLU NNs), our theoretical contribution (VerSAILLE) reaches far beyond this and lays the foundations for analyzing a wide range of NNCS architectures:

Figure 1: VerSAILLE reflects a proof of a control envelope in an NN to verify infinite-time safety of an NNCS from mere open-loop NNV properties. Mosaic _completely_ lifts off-the-shelf open-loop NNV tools to polynomial arithmetic by combining approximation with judicious SMT reasoning.

* We present VerSAILLE, the formal foundation that, for the first time, enables a _sound proof of infinite-time safety for a concrete NNCS_ by reusing safety proofs from control-theory literature (in the form of dl models). VerSAILLE supports a large class of feed-forward NNs (any NN with piece-wise Noetherian activation functions; see Section 2).
* We introduce Mosaic, a framework for the efficient, _sound and complete_ verification of properties in _polynomial_ real arithmetic on piece-wise linear NNs. Unlike other NN verifiers, Mosaic furthermore supports constraints with _arbitrary_ propositional structure. Mosaic combines approximation techniques, a generalization of DPLL(T), and judicious SMT reasoning to _lift_ sound and complete linear-constraint open-loop NNV tools to efficient, _sound and complete_ polynomial constraint verification. Mosaic can exhaustively characterize unsafe state space regions (useful for retraining or the generation of fallback controllers).
* We implement Mosaic for ReLU NNs in the tool N\({}^{3}\)V and demonstrate our approach on three case studies from adaptive cruise control, airborne collision avoidance ACAS X and steering under uncertainty. We show that, unlike N\({}^{3}\)V, State-of-the-Art closed-loop NNV tools cannot provide infinite-time guarantees due to approximation errors.

Running Example.The common NNCS safety benchmark of Adaptive Cruise Control  will serve as running example to demonstrate the introduced concepts. Consider an ego-car following a front-car on a 1-D lane as shown in Figure 2. The front-car drives with constant velocity \(v_{}\) while the ego-car (at position \(p_{}\) behind the front-car) approaches with arbitrary initial (relative) velocity \(v_{}\) which is adjusted through the ego-car's acceleration \(a_{}\). The primary objective is to ensure the ego-car never crashes into the front car (i.e. \(p_{}>0\)), however there may be secondary objectives (e.g. energy efficiency) which are learned by an NNCS. We demonstrate how a nondeterministic, high-level acceleration strategy (i.e. a safe envelope) can be modeled and verified in dl (Section 2), how VerSAILLE derives NN properties (Section 3) and how such polynomial properties can be verified on a given NN (Section 4). No techniques are specific to the running example, but all are applicable to a wide range of NNCSs--as demonstrated by our evaluation (Section 5).

## 2 Background

We review dl, NNs and NN verification. FOL\({}_{}\) (resp. FOL\({}_{}\)) is the set of polynomial (resp. linear) real arithmetic first-order logic formulas. FOL\({}_{}\) extends FOL\({}_{}\) with _Noetherian functions_\(h_{1},,h_{r}\). A _Noetherian chain_ is a sequence of real analytic functions \(h_{1},,h_{q}\) s.t. all partial derivatives of all \(h_{j}\) can be written as a polynomial \((y)}{ y_{i}}(y)=p_{ij}(y,h_{1}(y),,h_{q}(y))\). _Noetherian functions_ are representable as a polynomial over functions in a Noetherian chain. Most activation functions used in NNs are Noetherian (see Appendix A.2) Atoms of a formula \(\) are denoted as Atom(\(\)) and its variables as V(\(\)).

### Differential Dynamic Logic

Differential dynamic logic (dl) is a first-order multi-modal logic in which the modality is parameterized with a _hybrid program_ describing a (discrete or continuous) state transition (see also Appendix A). Thus, dl formulas are evaluated in a state \(\) (if \(\) satisfies a formula \(\) we denote this as \(\)). Hybrid Programs are constructed from the primitives in Table 1 and are first-class citizens of the logic (see example below). dl is tailored to the analysis of (time discrete and time continuous) hybrid systems and supports the analysis of differential equations. Through its invariance reasoning capabilities, dl allows us to prove the infinite-time safety of control envelopes w.r.t. a system's dynamics--even for cases where the dynamics' differential equations have no closed-form solution. There is a large body of research on the verification of real-world control envelopes using dl (e.g.

 Program & Semantics \\  \(x e\) & Assign term \(e\) to \(x\) \\ \(x\) & Nondet. assign to \(x\) \\ \(?Q\) & Test of formula \(Q\) \\ \(x^{}=t\&Q\) & Evolve \(x\) along the diff. \\  & equation within \(Q\) \\ \(\) & Nondet. choice \\ \(;\) & Sequential composition \\ (\(\))\({}^{*}\) & Nondet. loop \\ 

Table 1: Program primitives of dl.

Figure 2: Adaptive Cruise Control: The front-car (right) drives with constant \(v_{}\). The ego-car approaches with relative velocity \(v_{}\) (controlled via \(a_{}\)) from \(p_{}\).

ACAS X ). In dL, the formula \([]\) expresses that \(\) is always satisfied after the execution of \(\) and \(\) that there exists a state satisfying \(\) after the execution of \(\). dL comes with a sound and relatively complete proof calculus  and an interactive theorem prover KeYmaera X .

Running Example.We model our running example as a hybrid program in dL with differential equations describing the evolution of \(p_{},v_{},a_{}\) along with a _control envelope_, i.e. an abstract acceleration strategy, \(_{}\) that runs at least every \(T\) seconds while the overall system may run for arbitrarily many iterations (modeled by a nondeterministic loop). Given suitable initial conditions (accInit), our objective is to prove the absence of collisions (\(p_{}>0\)). This can be achieved by proving Formula (1) where the place-holder \(_{}\) determines the relative acceleration \(-B a_{} A\) (\(A\) and \(-B\) are resp. maximal acceleration/braking).

\[}{}[( _{}\\ ;c=0;_{}=v_{ },v^{}_{}=-a_{},c^{}=1\,\&\,c T )}_{})^{*}]}{}{}\] (1)

Our control envelope \(_{}\) allows braking with \(-B\) and an acceleration of \(0\) or another value if the constraint \(_{0}\) or resp. \(_{1}\) is satisfied (the concrete constraints are found in Appendix D):

\[_{}\;\;a_{}-B(a_{}=0;?\,(_{0}))(a_{}*;?\,(-B a_{} A_{1}))\]

The envelope is nondeterministic: While always braking with \(-B\) would be safe, an NNCS may _learn_ to balance braking with secondary objectives (e.g. minimal acceleration or not falling behind). A proof for Formula (1) in KeYmaera X uses the loop invariant accInv (see Appendix D). Automation of dL proofs as well as control envelope and invariant synthesis is discussed in the literature .

ModelPlex.Many CPS safety properties can be formulated through a dL formula \([(_{};_{})^{*} ]\) where \(\) describes initial conditions, and \(\) describes the safety criterion to be guaranteed when following the control-plant loop. ModelPlex shielding  allows the synthesis of correct-by-construction _controller monitor formulas_\(_{c}\) that ensure an implementation's runtime behavior matches the envelope \(_{}\). Interpreting an implementation's action as a state transition and denoting the old state's variables as \(x_{i}\) and the new state's variables as \(x_{i}^{+}\), \(_{c}\) tells us which combinations of \(x_{i}\) and \(x_{i}^{+}\) (i.e. which state transitions) are admissible w.r.t. \(_{}\) (see Definition 4 in Appendix A).

Running Example.We can apply ModelPlex on the proven contract in Formula (1) to synthesize a monitor for \(_{}\). For this simple scenario, the resulting controller monitor formula 1 tells us what new acceleration value \(a_{}^{+}\) may be chosen given the current values of \(p_{},v_{}\):

\[ a_{}^{+}=B(a_{}^{+}=0 _{0}^{+})(-B a_{}^{+} A _{1}^{+}).\] (2)

Here, \(_{i}^{+}\) is the constraint \(_{i}\) with \(a_{}\) replaced by \(a_{}^{+}\). Given an action of a concrete controller implementation that changes \(a_{}\) to \(a_{}^{+}\), Formula (2) tells us if this action is in accordance with the strategy modeled by \(_{}\), i.e. whether we have a proof of safety for the given state transition.

### Neural Network Verification

This work focuses on feed-forward neural networks typically encountered in NNCSs. The behavior of an NN with input dimension \(I\) and output dimension \(O\) can be summarized as a function \(g:^{I}^{O}\). The white-box behavior is described by a sequence of \(L\) hidden layers with dimensions \(n^{(k)}\) that iteratively transform an input vector \(x^{(0)}^{I}\) into an output vector \(x^{(L)}^{O}\). The computation of layer \(k\) is given by \(x^{(k+1)}=f^{(k)}(W^{(k)}x^{(k)}+b^{(k)})\), i.e. an affine transformation (with FOL\({}_{}\) representable numbers) followed by a nonlinear activation function \(f^{(k)}\). We distinguish different classes of NNs. To this end, we decompose the activation functions \(f^{(k)}\) as \(f^{(k)}(x)=_{i=1}^{s}_{q_{i}}(x)f_{i}(x)\) where \(f_{i}\) are functions, \(q_{i}\) are formulas over \(n^{(k)}\) variables and \(_{q_{i}}(x)\) is \(1\) iff \(q_{i}(x)\) is true and \(0\) otherwise. Table 2 summarizes which results are applicable to which NN class. Each class is a subset of the previous class, i.e. our theory (Section 3) is widely applicable while our implementation (Section 5) focuses on the most common NNs. Open-loop NNV tools analyze NNs in order to verify properties on input-output relations. Their common functionality is reflected in the VNNLIB standard . Off-the-shelf tools are limited to linear, normalized queries (Definition 1). To address this challenge, we present a lifting procedure for the verification of generic (i.e. nonlinear and not normalized) open-loop NNV queries over polynomial real arithmetic (Section 4).

**Definition 1** (Open-Loop NNV Query).: _An open-loop NNV query consists of a formula \(p_{}\) over free input variables \(Z=\{z_{1},,z_{I}\}\) and output variables \(x_{1}^{*},,x_{O}^{*}\). We call \(p\)_normalized _iff \(p\) is a conjunction of some input constraints and a disjunctive normal form over mixed/output constraints, i.e. it has the structure \(_{j}p_{1,j}(z_{1},,z_{I})_{i 2}_{j}p_{i,j}(z_{1},,z_{I},x_{1}^{*},,x_{O}^{*}),\) where all \(p_{i,j}\) are atomic real arithmetic formulas and all \(p_{1,j}\) only contain the free variables from \(Z\). We call a query_ linear _iff \(p_{}\) and call it_ nonlinear _otherwise_.

## 3 VerSAILLE: Verifiably Safe AI via Logically Linked Envelopes

We introduce VerSAILLE, our approach for the verification of NNCSs via dL contracts. The key idea of VerSAILLE are _nondeterministic mirrors_, a mechanism that allows us to reflect a given NN \(g\) and reason within and outside of dL simultaneously. This allows us to instrument open-loop NNV techniques to prove an NN specification outside of dL which _implies_ the safety of a corresponding (mirrored) dL model describing the NNCS. Reconsider the ACC example (Section 1) for which we synthesized a controller monitor formula in Section 2. The remaining open question is the following:

If we replace the control envelope \(_{}\) by a given piece-wise Noetherian NN \(g\), does the resulting system retain the same safety guarantees?

Summary of VerSAILLEThe input for VerSAILLE is a proven dL contract. Additionally, one may provide an inductive invariant \(_{s}\) to simplify the subsequent state space analysis. Using ModelPlex's synthesis of \(_{c}\), VerSAILLE constructs a nonlinear open-loop NNV query. If we verify this query on an NN \(g\), then the NNCS where we _substitute_ the control envelope by \(g\) retains the same safety guarantee.

Running ExampleSince one can only provide formal guarantees for something one can describe formally, we first need a semantics for what it means to substitute \(_{}\) by \(g\). To this end, we formalize a given piece-wise Noetherian NN \(g\) as a hybrid program \(_{g}\) which we call the _nondeterministic mirror_ of \(g\) (see Definition 16 and Lemma 17 in Appendix C). E.g. for ACC, this program must have two free (i.e. read) variables \(p_{},v_{}\) and one bound (i.e. written) variable \(q_{}\) and must be designed in such a way that it exactly implements the NN \(g\). Showing safety (see question above) is then equivalent to proving the following dL formula where \(_{}\) describes ACC's physical dynamics:

\[[(_{g};_{} )^{*}]p_{}>0.\] (3)

Since NNs do not lend themselves well to interactive analysis, an _automatable_ mechanism to prove formula (3) _outside_ the dL calculus is desirable. As discussed in Section 2, we can prove the safety (\(p_{}>0\)) of \(_{}\) via dL. Thus, if we can show that all behavior of the nondeterministic mirror \(_{g}\) is _already_ modeled by \(_{}\), the safety guarantee carries over from the envelope to \(_{g}\). To show this refinement relation , we instrument the controller monitor accCtrlFml in Formula (2). We verify that the NN \(g\) satisfies the controller monitor formula accCtrlFml (i.e. we show that \(g\)'s input-output relation satisfies Formula (2)). If this is the case, \(_{g}\)'s behavior is modeled by our envelope \(_{}\). In practice, it is unnecessary that the behavior of \(_{g}\) is modeled by \(_{}\)_everywhere_ (e.g. we are not interested in states with \(p_{} 0\)). It suffices to consider all states within the inductive invariant accInv of the envelope's system (Formula (1)) as those are precisely the states for which the guarantee on \(_{}\) holds. Thus, we can prove Formula (3) by showing that \(g\) satisfies the following specification for all inputs:

\[\] (4)

  NN class & All \(f_{i}\) & All \(q_{i}\) in & Applicable & Decidable & Example \\  piece-wise Noetherian & Noetherian & \(_{}\) & Section 3 & & Sigmoid \\  piece-wise Polynomial & Polynomial & \(_{}\) & Section 3 & ✓ & \(x^{2}\) \\  piece-wise Linear & Linear & \(_{}\) & Sections 3 and 4 & ✓ & MaxPool \\  ReLU & \(f^{(k)}(x)=(0,x)\) & Sections 3 to 5 & ✓ & \(\) \\  

Table 2: Applicability of our results on NNCS safety and decidability of the safety verification problem: Each class is a subset of its predecessor in the table.

[MISSING_PAGE_FAIL:6]

verification tools . We call this partitioning of the input space a _mosaic_ and, in reminiscence of this analogy, we call the individual queries _azulejos_ ([q.0u'le.xo], see e.g. regions in shades of gray in Figure 3). Mosaic guarantees that reachability-based open-loop NNV tools do not explore the same input region multiple times (see _flatness_ result in Proposition 10; Appendix B). For our ACAS case study, naive rewriting (as done by e.g. DNNV ) may produce up to 39 trillion propositionally feasible queries. In contrast, Mosaic only produces 19k queries (see Table 7 in Appendix E.2). Mosaic also separates nonlinear constraints \(q_{n}\) (must be checked outside open-loop NNV) from linear constraints \(q_{l}\) (can be passed to open-loop NNV).

On the technical side, Mosaic proceeds by executing a SAT solving based DPLL(T) loop until a satisfiable conjunction of _input_ constraints is found. At this stage, we fix the conjunction's linear input constraints (i.e. the azulejo) and an inner loop enumerates conjunctions over mixed/output constraints that are satisfiable in combination with the fixed azulejo. For each such conjunction, we save the conjunction of linear mixed/output constraints. This results in a linear, normalized Open-Loop NNV query (conjunction over input, disjunctive normal from over output). We employ a similar inner loop to enumerate satisfiable conjunctions of nonlinear constraints to later check counterexamples via SMT solving (see Retaining completeness). At each step, we interleave propositional and theory solving to discard conjunctions unsatisfiable in real arithmetic as early as possible.

Linearize.To verify polynomial specifications via off-the-shelf (linear) open-loop NNV, we need to soundly approximate the query's nonlinear constraints. In principle, we could perform this approximation for each azulejo (see Mosaic) separately. To this end, consider an atomic polynomial constraint \(p(x) 0\) which is part of a query. If there are two azulejos with the constraints \(p(x) 0\) and \(p(x)>0\), separate approximation would lead to the constraint \((x) 0\) and \((x)>0\) (with \(\) resp. over/under-approximations of \(p\)). This would _duplicate_ the exploration of the area in between \(\) and \(\) and can lead to an exponential blowup for many approximations. Instead, we use a _global_ piece-wise approximation via OVERT  (orange lines around the blue nonlinear constraint on Figure 3) and integrate the approximate constraints into the original query via implications (e.g. we add \((x) 0 p(x) 0\)). These additional linear constraints are then automatically enumerated via Mosaic (see azulejos for \(_{1}\) in Figure 3). The linearization happens for input as well as output constraints. When passing the open-loop NNV query to the off-the-shelf tool, we soundly omit the nonlinear constraints, thus only leaving behind linear constraints \(q_{l}\) (green and orange in Figure 3).

Retaining completeness.Without further efforts, Mosaic and Linearize together yield a sound algorithm to check nonlinear, not normalized open-loop NNV queries, but not a complete one: A reachability analysis via open-loop NNV for a given azulejo may produce spurious counterexamples that are an artifact of the linearization (see Figure 3) The key insight to achieve completeness is the observation that for piece-wise _linear_ NNs any concrete counterexample generated via open-loop NNV corresponds to a _counterexample region_\(\) (yellow polytope on the left of Figure 3) on which the NN reduces to an affine transformation \(\) (obtained by fixing piece-wise functions to the linear segment of the concrete counterexample, i.e. we fix the value of the \(\) functions; see also Section 2.2). This insight can be used in two ways: First, we can use it to enumerate all counterexample regions \(\) (by adjusting the tool's internal enumeration and/or via the algorithm Enum; see Appendix B.3). Secondly, for a given counterexample region, we can check whether there exists a concrete counterexample to the nonlinear specification via SMT solving (in Algorithm 1 this is performed by Filter; see Appendix B.3). By exploiting the affine transformation \(\), our SMT encoding for nonlinear constraints has at most \(I\) free variables (for \(I\) input dimensions of the NN) and is therefore _significantly more tractable_ than an encoding of the entire NN in SMT.

Using the components outlined above (for details see Appendix B), we prove the soundness and completeness of Mosaic. Completeness turns out to also be of _practical relevance_ as approximation alone would have failed to verify the DNC NN of the ACAS benchmark discussed in Section 5.

**Theorem 3** (Soundness and Completeness).: _Let \(g\) be a piece-wise linear NN, \(p\) be a real arithmetic formula and \(R\) variable ranges for all in- and output variables of \(g\). Algorithm 1 returns unsafe iff there exists an input \(z^{I}\) such that \((z,g(z))\) is in the range \(R\) and \(p(z,g(z))\) is satisfied._

In Section 5 we build upon nnennum [10; 12] which can enumerate all counterexample regions of an NN with \(N\) ReLU activations in time \(\!(2^{N})\), and upon cylindrical algebraic decomposition (CAD ) with complexity \(\!(2^{2^{V}})\) for \(V\) variables2. Assuming \(M\) atomic formulas in the open-loop NNV query and \(I\) input dimensions this yields a worst-case runtime of \(\!(2^{M++2^{I}})\). This is an exponential improvement over naive \(\!(2^{M+2^{+I}})\) CAD encodings as \(N>>I\). In practice the performance is even better; usually, Mosaic explores fewer queries, nennum returns less counterexample regions and SMT solving tends to perform very well for the small input dimensions \(I\) of NNCS control.

## 5 Evaluation

We implemented Mosaic for ReLU NNs in a new Julia  tool called N\({}^{3}\)V based on the software packages nnenum [10; 12], PicoSAT [17; 19] and Z3 [32; 52]. We provide wall-clock times on an AMD Ryzen 7 PRO 5850U CPU (N\({}^{3}\)V is sequential; nenum uses multithreading). The evaluation presented in this section focuses on vertical airborne collision avoidance (VCAS), with other experiments in Appendix E. Airborne Collision Avoidance Systems try to recognize plane trajectories that might lead to a Near Mid-Air Collision (NMAC) with other aircrafts and advise the pilot to avoid such collisions. NMACs are defined as two planes (ownship and intruder) flying closer than 500 ft horizontally or 100 ft vertically. Currently, the Federal Aviation Administration (FAA) develops a new airborne collision avoidance system called Airborne Collision Avoidance System X (ACAS X) . Prior work by Jeannin et al.  showed a nondeterministic, provably safe dl envelope for airborne collision avoidance. While the original proposal for ACAS X [45; 60] was shown to be unsafe , the correctness of a VCAS NN implementation [53; 55] was proven  and disproven  in special cases. The proposed NNs contain 6 hidden layers with 45 neurons each and produce one of 9 collision avoidance advisories (_Strengthen Climb to at least 2500 ft/min_ (SCL2500) to _Strengthen Descent to at least 2500ft/min_ (SDES2500); see Table 9 in Appendix F for a list of allowed advisories). The objective of the NNs is to ensure safety while minimizing the number of alerts sent to the pilot. We present an _exhaustive_ analysis of the VCAS NNCS for level flight intruders.

We provide additional experimental results in Appendix E. First, we demonstrate the feasibility of our approach for the running example of ACC. Depending on NN size and chosen linearization, our approach can verify or exhaustively enumerate counterexamples for the NNCS in 47 to 300 seconds. For a case study on Zeppelin steering under (uniformly sampled) wind perturbations, we adapt a differential hybrid games formalization  to analyze an NN controller trained by us. Here, we encountered a controller that showed very positive empirical performance while being provably unsafe in large parts of the input space: While performing very well on average, the control policy was vulnerable to unlikely wind perturbations - an issue we only found through our verification. For ACC, we also perform a comparison to other techniques: While Closed-Loop techniques are useful for the analysis of bounded-time safety, their efficiency greatly depends on the system's dynamics and the considered input space. Our

 Prev. Adv. & Status & Time & CE regions & First CE \\  DNC & **safe** & 0.35 h & — & — \\ DND & **safe** & 0.28 h & — & — \\ DES1500 & **unsafe** & 5.45 h & 49,428 & 0.04 h \\ CL1500 & **unsafe** & 5.18 h & 34,658 & 0.08 h \\ SDES1500 & **unsafe** & 4.05 h & 5,360 & 0.97 h \\ SCL1500 & **unsafe** & 4.89 h & 11,323 & 0.36 h \\ SDES2500 & **unsafe** & 3.66 h & 5,259 & 1.39 h \\ SCL2500 & **unsafe** & 4.45 h & 7,846 & 0.53 h \\ 

Table 3: Verification of ACAS NNs for level flight: Previous advisory (=Prev. Adv.), runtime; number of counterexample (=CE) regions and time to the discovery of the first CE.

infinite-time horizon approach can be more efficient than Closed-Loop techniques as it evades the necessity to analyze the system's dynamics along with the NN (see Table 6). Usually, it is desirable to show infinite-time safety on the entire (controllable) state space. However, the approximation errors incurred via prior closed-loop NNV techniques prohibit this as they will either ignore states inside the controllable region or allow unsafe actions pushing the system outside its controllable region. Conversely, SMT-based techniques do not have these approximation issues, but cannot scale to NNs of the size analyzed in this work. We also provide a conceptual comparison demonstrating the efficiency of the Mosaic procedure for normalized query generation over DNNV's expansion-based algorithm (see Table 7), naive SMT solving (Table 8) and Genin et al.'s tailored ACAS approach .

Verification Results for VCAS.We use the nondeterministic control envelope and loop invariant by Jeannin et al. [50, Thm. 1] to analyze safety for intruders in level flight (i.e. intruder vertical velocity is 0). For the same reasons as prior work , we ignore Clear-of-Conflict advisories. The open-loop NNV queries obtained via VerSAILLE had up to 112 distinct atoms and trees up to depth 9. To determine the maximal output neuron, open-loop NNV queries initially contain atoms sorting the NN's outputs \(x_{1},,x_{n}\) (e.g., \(x_{1} x_{2}\)). To avoid enumerating all permutations, we perform symmetry elimination via an atomic predicate encoding that some output \(i\) is maximal. We analyzed the _full range_ of possible NN inputs for intruders in level flight (relative height \(|h| 8000\)ft, ownship velocity \(|v| 100\)ft/s and time to NMAC \(6s 40\)s). Our results are in Table 3: **safe** implies that the NN's advisories (other than Clear-of-Conflict) in this scenario _never_ lead to a collision when starting within the invariant. The safety for DNC was only verifiable through SMT filtering (approximation yielded spurious counterexamples). This _underscores the importance of Mosaic's completeness_ and implies that  is insufficient to prove safety. A non-exhaustive analysis for non-level flight yielded counterexamples even for DNC/DND (see Appendix G). For unsafe level flight scenarios, we exhaustively characterize unsafe regions. This characterization goes far beyond characterizations in prior work  that were generated using manual approximation and resulted in (non-exhaustive) point-wise characterizations. Figure 5 shows a concrete avoidable NMAC (more examples are in Appendix G).

Scalability.N\({}^{3}\)V provides guarantees for an NN's full input space. Hence, N\({}^{3}\)V is not directly comparable to, e.g., the scalability of local robustness verifiers, that, while sometimes scaling to hundred thousands of \(\), only analyze tiny fractions of the input space [92, Sec. 6]. Contemporary work on global properties outside NNCSs has been scaled to 100 \(\) nodes . Related work on infinite-time NNCSs (see also Section 6) has not been scaled beyond 30 nodes in similar settings . The largest NNs verified by us so far had 270 \(\), indicating N\({}^{3}\)V is at the frontier of State-of-the-Art scalability for _global_ properties. Some NNCS applications (e.g. ACAS ) turn to NNs to efficiently encode complex strategies in mid-scale NNs. N\({}^{3}\)V scales to NNs of this kind.

## 6 Related Work

Shielding.Justified Speculative Control  is closely related in its use of. However, we verify the NNCS _a priori_ instead of treating ML models as a black box and _a posteriori_ using runtime enforcement techniques . Shielding can also be used to train models such that they (probabilistically) conform to a shield/monitor . Training methodologies are beyond the scope of this paper.

Barrier Certificates.An orthogonal direction of research explores learning Neural Barrier/Lyapunov Functions to prove safety properties . Although initially used for "pure" dynamical and hybrid systems (without NNs) , the methods have since been extended to NNCS with discrete  and continuous  time behavior. While the former works

Figure 5: An unsafe advisory by the Airborne Collision Avoidance NN: After a previous advisory to climb at least 1500ft/min, the NN advises to reverse vertical direction (“Strengthen Descent to at least 1,500 ft/min”). This leads to an NMAC 6 seconds later. More examples are in Appendix G.

can only approximate continuous time behavior, the latter techniques use off-the-shelf SMT solvers (see also Appendix E.2) for certificate verification which severely limits scalability. While some works ignore verification entirely , the remaining work only considered _linear single-layer_ NNs [25, Appendix] verified with dReal (see SMT comparison in Appendix E.2). Dawson et al.  note "scalable verification for learned certificate functions remains an open problem". Using N\({}^{3}\)V as an alternative to SMT for certificate verification is future work. VerSAILLE evades the necessity to _learn_ barrier certificates by reusing established control-theory literature.

Open-Loop NNV.VEHICLE  integrates open-loop NNV with Agda. However, VEHICLE only allows importing normalized, linear properties which limits applicability to CPS verification in realistic settings. Open-loop NNV tools  do not consider the physical environment and thus _cannot_ guarantee the safety of an NNCS. Even in cases where such methods allow nonlinear behavior in activation functions, they do not admit the verification of arbitrary polynomial constraints over the input and output space. Most methodologies could be integrated into Mosaic's framework, i.e. we can lift complete off-the-shelf open-loop NNV tools to verify polynomial constraints with arbitrary structure. DNNV  proposed an approach for open-loop NNV query normalization using a simple expansion algorithm. DNNN has the same limitations as all open-loop NNV tools (no NNCS analysis; no nonlinear constraints) and is less efficient than Mosaic w.r.t. NN reachability analysis (see Section 4). Pre-image computation  computes input regions producing a fixed NN prediction. For efficiency, our work constrains the input space with invariants and value ranges--this efficiency would be lost by a backward computation alone.

Related Techniques.Unlike , we support _arbitrary_ polynomial constraints and retain completeness. Moreover, these works do not support arbitrary logical structure and represent open-loop NNV techniques unable to analyze NNCSs. Some prior work used techniques for constructing counterexample regions  but only for _individual_ datapoints--neither to compute exhaustive characterizations nor to regain completeness for incomplete verifiers. Unlike classical DPLL(T) , Mosaic is tailored to theory-solving w.r.t. reachability analyzers. To this end, Mosaic groups output regions with the same input constraints which deduplicates work (see Section 4).

Closed-Loop NNV.Closed-loop NNV tools  only consider a fixed time horizon and thus cannot guarantee infinite-time horizon safety (see Appendix E.2). Unlike , our approach is automated and applicable to _any_ CPS expressible in dL (not just ACAS X; see case studies in Appendix E). Other approaches verify simplified control outputs ; rely on hand-crafted approximations while lacking exhaustive counterexamples characterizations ; or require quantization effectively analyzing only a surrogate system instead .

## 7 Conclusion and Future Work

This work presents VerSAILLE, the first technique exploiting dL contracts to prove safety of NNCSs with piece-wise Noetherian NNs. VerSAILLE requires open-loop NNV tools capable of verifying non-normalized polynomial properties that did not exist. Thus, with Mosaic we present an efficient, _sound and complete_ approach for the verification of such properties on piece-wise linear NNs. We implemented Mosaic for ReLU NNs in the tool N\({}^{3}\)V and demonstrate the applicability and scalability of our approach on multiple case studies (Section 5 and Appendix E). The application to NNCSs by Julian et al.  shows that our approach scales even to intricate, high-stakes applications such as airborne collision avoidance. Our results underscore the categorical difference of our approach to closed-loop NNV techniques. Overall, we demonstrate an efficient and generally applicable approach that opens the door for developing of goal-oriented _and_ infinite-time horizon safe NNCSs in the real world.

Future Work.We believe there is potential for engineering and algorithmic improvements that could further improve the performance of N\({}^{3}\)V. Our implementation could also be extended to other piece-wise linear activation functions. We would also like to explore the efficiency of N\({}^{3}\)V for non-polynomial specifications w.r.t. suitable SMT solvers. Mosaic may be of interest even beyond NNCS verification in VerSAILLE. Since, e.g., neural barrier certificate verification also requires nonlinear open-loop NNV, Mosaic could be equally applicable in this context. Finally, it would be interesting to apply our approach to further case studies. To this end, the bottle-neck is currently the limited availability of NNCS which are safe w.r.t. an infinite-time horizon.