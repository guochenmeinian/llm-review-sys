# Enhancing Diversity in Bayesian Deep Learning via Hyperspherical Energy Minimization of CKA

David Smerkous

Oregon State University

Corvallis, OR, USA

smerkoud@oregonstate.edu

&Qinxun Bai

Horizon Robotics

Sunnyvale, CA, USA

qinxun.bai@gmail.com

&Li Fuxin

Oregon State University

Corvallis, OR, USA

lif@oregonstate.edu

###### Abstract

Particle-based Bayesian deep learning often requires a similarity metric to compare two networks. However, naive similarity metrics lack permutation invariance and are inappropriate for comparing networks. Centered Kernel Alignment (CKA) on feature kernels has been proposed to compare deep networks but has not been used as an optimization objective in Bayesian deep learning. In this paper, we explore the use of CKA in Bayesian deep learning to generate diverse ensembles and hypernetworks that output a network posterior. Noting that CKA projects kernels onto a unit hypersphere and that directly optimizing the CKA objective leads to diminishing gradients when two networks are very similar. We propose adopting the approach of hyperspherical energy (HE) on top of CKA kernels to address this drawback and improve training stability. Additionally, by leveraging CKA-based feature kernels, we derive feature repulsive terms applied to synthetically generated outlier examples. Experiments on both diverse ensembles and hypernetworks show that our approach significantly outperforms baselines in terms of uncertainty quantification in both synthetic and realistic outlier detection tasks.

## 1 Introduction

Bayesian deep learning has always garnered substantial interest in the machine learning community. Instead of a point estimate which most deep learning algorithms obtain, a posterior distribution of trained models could significantly improve our understanding about prediction uncertainty and avoid overconfident predictions. Bayesian deep learning has potential applications in transfer learning, fairness, active learning, and even reinforcement learning, where reducing uncertainty can be used as a powerful intrinsic reward function (Yang & Loog, 2016; Ratzlaff et al., 2020; Wang et al., 2023).

One line of approach to Bayesian deep learning is to add noise to a single trained model. Such noises can either be injected during the training process, e.g. as in the stochastic gradient Langevin dynamics (Welling & Teh, 2011), or after the training process (Maddox et al., 2019). However, many such approaches often underperform the simple ensemble method (Lakshminarayanan et al., 2017) which merely trains several deep networks with different random seeds. Intuitively, an ensemble, because it starts from different random initializations, might be able to "explore" a larger portion of the parameter space than those that are always nearby one specific model or training path. Because of this, ensembles may capture different modes and therefore better represent the posterior distribution of "well-trained" network functions (Fort et al., 2019; Wilson & Izmailov, 2020).

However, a critical question is, how different are the networks in an ensemble from one another? And can we utilize the idea of diversification to further improve these networks by making them even more diverse? In order to answer these questions, we first need a metric to compare those networks, which is in itself a significant problem; regular L1/L2 distances, either in the space of the network parameters, or in the space of the network activations, are not likely to work well. First, they suffer from the curseof dimensionality due to the excessive number of parameters in modern deep networks. Moreover, there is the peculiar _permutation invariance_, where one can randomly permute the different channels of each layer and result in a network that has vastly different parameters and activations, yet represents the same function. The popular RBF kernel lacks this permutation invariance inhibiting methods like Stein Variational Gradient Descent (SVGD) from working effectively on larger networks (D'Angelo and Fortuin, 2021). Therefore, a proper kernel for comparing network functions should address these critical issues by being effective in high-dimensional spaces and invariant to permutations of neural network channels.

Kornblith et al. (2019) proposed an interesting approach for performing this comparison based on Centered Kernel Alignment (CKA). The idea is, instead of directly comparing activations or parameters, comparison is made between the Gram matrices of the same dataset fed into two different networks. Each example will generate a feature vector at each layer of the network, and a kernel matrix can be constructed based on the similarity between all example pairs in the dataset. Then, a CKA metric measures the similarity of these two Gram matrices as the similarity of the two networks. This idea addresses the permutation invariance issue and generates meaningful comparisons between deep networks.

In this paper, we propose to **explicitly promote diversity** of network functions by adding CKA-based loss terms to deep ensemble learning. Given that CKA projects all kernels on a hypersphere, we further propose to use Hyperspherical Energy (HE) minimization as an approach to more evenly distribute the ensemble of neural networks on the hypersphere. Experiments on synthetic data, MNIST, CIFAR, and TinyImageNet show that our approach maintains the predictive accuracy of ensemble models while boosting their performance in uncertainty estimation across both synthetic and realistic datasets. Besides, we demonstrate that our method can also be applied to training hypernetworks, improving the diversity and uncertainty estimation of the networks generated by a hypernetwork. Additionally, we propose using synthetic out-of-distribution (OOD) examples, to reduce their likelihood, and introducing feature repulsive terms on synthetic outlier examples to enhance OOD detection performance. We hope that our approach provides a different perspective to variational inference methods and contributes to improving uncertainty estimation in deep networks. Code is publicly available at https://github.com/Deep-Machine-Vision/he-cka-ensembles.

## 2 Related Work

**Uncertainty Estimation.** A large body of literature has studied the problem of uncertainty estimation for neural networks. Bayesian neural networks (Gal and Ghahramani, 2016; Krueger et al., 2017;

Figure 1: Overview of feature repulsive loss construction: Starting with a batch of examples (left), optionally including synthetic outliers, ensemble features at each layer \(l\) are used to construct centered Gram matrices projected onto the unit hypersphere (middle). The hyperspherical energy is then calculated between models, weighted by layer, and incorporated into the loss function (right).

Nazaret & Blei, 2022) approximate a posterior distribution over the model parameters and therefore estimate the epistemic uncertainty of the predictions. Non-Bayesian approaches, on the other hand, rely on bootstrap (Osband et al., 2016), ensemble (Lakshminarayanan et al., 2017; Wen et al., 2020; Park & Kim, 2022), and conformal prediction (Bhatnagar et al., 2023) to generate multiple neural networks of the same structure. Our approach is most closely related to ensemble methods for estimating predictive uncertainty. We follow the common practice of evaluating uncertainty by distinguishing between inlier and outlier images for datasets like CIFAR/SVHN and MNIST/FMNIST. Most approaches typically evaluate the separation or distance within the feature space of a model between inliers and outliers (Mukhoti et al., 2023; Van Amersfoort et al., 2020; D'Angelo & Fortuin, 2021; Ovadia et al., 2019; Lakshminarayanan et al., 2017; Liu et al., 2020). Deep deterministic uncertainty (DDU) utilizes a single deterministic network with a Gaussian mixture model (GMM) fitted on the observed inlier features before the last layer and calculates separation of inliers and outliers using feature log density. We refer the reader to Mukhoti et al. (2023) for more information. For a more comprehensive survey and benchmarking of different uncertainty estimation approaches, refer to Ovadia et al. (2019); Gawlikowski et al. (2022).

**ParVI.** Particle-based variational inference methods (ParVI), such as Stein Variational Gradient Descent (SVGD) (Liu & Wang, 2016; Chen et al., 2018; Liu & Zhu, 2018), use particles to approximate the Bayes posterior. Our work most closely resembles work done by D'Angelo & Fortuin (2021), which explores adapting kernelized repulsive terms in both the weight and function space of deep ensembles to increase model diversity and improve uncertainty estimation. Our work, however, focuses more on constructing a new kernel rather than exploring new repulsive terms that utilize an RBF kernel on weights or network activations.

**Hypernetworks.** Hypernetworks have been used for various specific tasks, some are conditioned on the input data to generate the target network weights, such as in image conditioning or restoration (Alaluf et al., 2022; Aharon & Ben-Artzi, 2023). It has seen popular use in meta-learning tasks related to reinforcement learning (Beck et al., 2023, 2024; Sarafian et al., 2021), and few-shot learning in Zhmoginov et al. (2022). Hypernetworks conditioned on a noise vector to approximate Bayesian inference have been proposed (Krueger et al., 2018; Ratzlaff & Fuxin, 2019), but either require an invertible hypernet or do not diversify target features explicitly. Our motivation is to provide Bayesian hypernetworks by explicitly promoting feature diversity in target networks.

## 3 Measurements of Network Diversity

In order to generate an ensemble of diverse networks, we first need a measurement of similarity between internal network features. Throughout this paper, we denote a deep network with \(L\) layers as \(f(x,)=f_{L}(f_{()}(f_{1}(x,_{1}),),_{L})\), where \(f_{l}(x,_{l})^{p_{l}}\) are the features of layer \(l\) parameterized by \(_{l}\), where \(p_{l}\) is the output feature dimension.

### Comparing two networks with CKA

We will compare two networks with the same architecture layer-by-layer. Given two networks at layer \(l\) with weights \(_{l}^{1},_{l}^{2}\) and feature activations \(f_{l}(x,_{l}^{1}),f_{l}(x,_{l}^{2})\), a naive approach would be to take some Euclidean \(L_{k}\) norm between the weights \(\|_{l}^{1}-_{l}^{2}\|_{k}\) or features \(\|f_{l}(x,_{l}^{1})-f_{l}(x,_{l}^{2})\|_{k}\), but those tend to be bad heuristics for similarity measures in high-dimensional vector spaces due to the curse of dimensionality (Reddi et al., 2014; Aggarwal et al., 2001; Weber et al., 1998). A better approach to measuring similarity would be to analyze the statistical independence or alignment of features between networks, through Canonical Correlation Analysis (CCA), Singular Vector CCA (SVCCA), Projection-Weighted CCA (PWCCA), Orthogonal Procrustes (OP), Hilbert-Schmidt Independence Criterion (HSIC), or Centered Kernel Alignment (CKA)(Raghu et al., 2017; Gretton et al., 2005; Kornblith et al., 2019). Ideally, the chosen metric should be computationally efficient, invariant to isotropic scaling, orthogonal transformations, permutations, and be easily differentiable. However, CCA methods and OP require the use of Singular Value Decomposition (SVD) or iterative approximation methods, which can be computationally intensive. Additionally, HSIC and OP are not invariant to isotropic scaling of \(f_{l}\).

As a comparison metric between networks, Kornblith et al. (2019) propose to utilize CKA on Gram matrices, obtained by evaluating the neural network on a finite sample. CKA is based on the non-parametric statistical independence criterion HSIC, which has been a popular method of measuring statistical independence as a covariance operator in the kernel Hilbert spaces (Gretton et al., 2005). An empirical estimation of HSIC on a dataset of \(N\) examples is given by \(1/(N-1)^{2}(K^{1}HK^{2}H)\), where the two Gram matrices \(K_{i,j}^{1}=k(f_{l}(x_{i},_{l}^{1}),f_{l}(x_{j},_{l}^{1}))\) and \(K_{i,j}^{2}=l(f_{l}(x_{i},_{l}^{2}),f_{l}(x_{j},_{l}^{1}))\) are constructed through the \(k(,)\) kernel function, and \(H=I-^{}\) a centering matrix to center the Gram matrices around the row means, where \(\) denotes the all ones vector, and \(I\) as the identity matrix. This function, however, is not invariant to isotropic scaling. The isotropic scaling invariant version of HSIC is termed Centered Kernel Alignment (CKA) (Kornblith et al., 2019),

\[(K^{1},K^{2})=(K^{1},K^{2})}{(K^{1 },K^{1})(K^{2},K^{2})}}.\] (1)

We stick with the linear kernel for \(k\), unless otherwise specified, due to its computational simplicity. The RBF kernel works, but it is computationally expensive and requires the use of heuristic like the median heuristic to perform well and make CKA isotropic scaling invariant (Reddi et al., 2014; Kornblith et al., 2019).

### Generalizing to multiple networks

Given an ensemble of \(M\) models, a simple approach to generalizing Eq. (1) to measure the similarity of an ensemble would be to construct a pairwise alignment metric. For each layer \(l\) of each member of the ensemble \(m\), we construct the set of kernel matrices \(=\{K_{l}^{m}\}_{l=1,,L}^{m=1,,M}\). The mean pairwise loss across all layers \(L\) is as follows,

\[_{}()=_{l=1}^{L}_{ m,m^{{}^{}}=1\\ m m^{{}^{}}}^{M,M}(K_{l}^{m},K_{l}^{m^{{}^ {}}}),\] (2)

In its current form, \(_{}\) provides a good approximate metric to evaluate the similarity among members of an ensemble. We found that rewriting Eq. (2) gives us another perspective on optimizing CKA. First, to simplify notation, let \(^{m}=\|_{F}}(K^{m}H)\) be the centered and normalized Gram matrix, and rewriting the inner product in Eq. (1) results in the cosine similarity metric \((K^{m},K^{m^{}})=^{m}^{m^{}}\). The matrix of the vectorized kernels from the set \(_{l}\) can be represented in a compact form \(_{l}\), and \(_{}\) can be rewritten using this compact form,

\[_{}()=_{l=1}^{L} ^{}(_{l}_{l}^{}) \,_{l}=_{l}^{1}\\ \\ _{l}^{M}^{M N^{2}}\] (3)

where \((X)=X(^{}-I)\) is a function that zeros out the diagonal of a matrix.

Now each row \(m\) of \(_{l}\) is a vectorized Gram matrix with unit length from the model \(m\). We can view these vectors as the Gram matrices projected on the unit hypersphere as shown in Fig. 1. For each pair of models \(i,j\) on the hypersphere, with an angle \(_{i,j}\) between the feature gram vectors, CKA is equivalent to \((_{i,j})\). Thus minimizing pairwise CKA would reduce the sum of \((_{i,j})\), pushing Gram matrices between model pairs apart.

### Comparing Networks with Hyperspherical Energy

Note that CKA suffices as a differentiable measure between deep networks and one can directly minimize CKA to push different models in the ensemble apart from each other. However, CKA may have a specific deficiency as an optimization objective in that the gradient of \(()\) is \(-()\), which is close to \(0\) when \(\) is close to \(0\). In other words, if two models are already very similar to each other (their CKA being close to \(1\)), then optimizing with CKA may not provide enough gradient to move them apart. Hence, we explore further techniques to alleviate this drawback. Minimum Hyperspherical Energy (MHE) (Liu et al., 2021) aims to distribute particles uniformly on a hypersphere, which maximizes their geodesic distances from each other. In physics, this is analogous to distributing electrons with a repellent Coloumb's force.

Inspired by MHE, we propose to adopt the idea of hyperspherical energy (HE) on top of the CKA kernel to compare neural networks, termed \(\), which is novel to our knowledge. For each layer \(l\) we treat the \(M\) model Gram vectors \(_{l}^{m}\) as particles on the hypersphere, its geodesic on the hypersphere is then \(d_{i,j}=((K_{l}^{i},K_{l}^{j}))=(_{l}^{i} _{l}^{j})\), we define the energy function by simulating a repellent force on the particles via \(F_{i,j}=(d_{i,j})^{-s}\) as shown in Fig 1. Incorporating this across all layers, weighted by \(w_{l}\), and model pairs results in the overall hyperspherical energy of CKA between all models is.

\[()=_{l=1}^{L}_{ m,m^{}=1\\ m^{} m}^{M,M}((_{l}^{m} _{l}^{m^{}}))^{-s},\] (4)

where \(s>0\) is the Riesz \(s\)-kernel function parameter. For more information regarding the layer weighting \(w_{l}\) and smoothing terms please see Appendix C.

\(\) has been shown as a proper kernel (Liu et al., 2021). The minimization of \(\), as mentioned in Liu et al. (2021), asymptotically corresponds to the uniform distribution on the hypersphere, In order to demonstrate the difference between \(\) and the pairwise cosine similarity, we conducted a test on a synthetic dataset by generating random vectors from two Gaussian distributions in \(^{3}\), and projecting on the unit hypersphere. We then minimized pairwise cosine similarity and \(\) respectively. Figure 2 illustrates that minimizing \(\) converges faster and achieves a more uniform distribution compared to minimizing cosine similarity. Specifically, as observed in Figure 2 (b), minimizing the cosine similarity loss caused particles to cluster towards two opposite sides of the sphere, as the gradient of this optimization - as mentioned in the beginning of the subsection, - becomes very small between particles that are clustered together. In Fig. 2(d), we show that minimizing HE actually leads to lower cosine similarity than directly minimizing cosine similarity, showing that minimizing cosine similarity could fall into local optima as described.

## 4 Particle-based Variational Inference by Minimizing Model Similarity

Armed with the comparison metrics between deep networks, we now proceed to incorporate the minimization of network similarity into deep ensemble training. In this section, we explore two different types of ensembles. The first is a regular ensemble where deep networks are trained to maximize the data likelihood, and we would add a term minimizing model similarity to it. Afterwards, we also explore the application of the idea on _generative ensembles_ by hypernetworks, which aims to train a generator that generates network weights so that one can directly sample the posterior from it. Such a generator can easily exhibit mode collapse by always generating the same function, and we hope the idea of minimizing the similarity of generated networks would help alleviate this issue.

Suppose we are given a deep network with \(L\) layers \(f(x,)=f_{L}(f_{}(f_{1}(x,_{1}), ),_{L})\). We denote the ensemble of target network layer at layer \(l\) as \(E_{l}(x,)=[f_{l}(x,^{1}),...,f_{l}(x,^{M})]\), with the ensemble parameters \(=\{^{m}\}_{m=1}^{M}\), and the training set of \(N\) examples as \(=\{x_{i},y_{i}\}_{i=1}^{N}\). From a Bayesian perspective, incorporating \(_{}\)/\(\) into the ensemble training can be interpreted as imposing a Boltzmann prior with \(\) over the ensemble network parameters \(\) that produce feature Gram matrices uniformly distributed on the unit hypersphere. Specifically, \(p()(-\,((E_{()}(, ))\), where \((E_{()}(,))\) is the set of feature Gram matrices, constructed from the ensemble \(E\), as described in Sec. 3.2. The posterior distribution now becomes:

\[p(|) p(|)(-\, ((E_{()}(,))\] (5)

Figure 2: Comparison between optimizing cosine similarity (\(\)) or \(\) on a sphere. (a) initial random set of points placed on sphere. (b-c) the final set of points after 50 iterations either \(\) or \(\) as the similarity metric. (d-e) the value of \(\)/\(\) with respect to the number of iterations. The orange line indicates that \(\) is minimized and the black line indicates that \(\) with \(s=2\) is minimized. Both methods used gradient descent with a learning rate of \(0.75\) and momentum \(0.9\).

The MAP estimate of the posterior in Eq. (5) results in the following objective:

\[}\,M^{-1}\,_{m=1}^{M}[_{i=1}^{N}(f(x_{i},^{m}),y_{i})]+\,((E_{()}( ,)),\] (6)

The left hand side is the negative log likelihood term where \((x,y)\) is the target loss, such as cross-entropy or MSE. Minimizing \(\), while adjusting the constant \(\) used in the Boltzmann prior, allows us to balance between gram matrix hyperspherical uniformity and fitting the training data. Further explanation of Eq. (6)'s relationship to ParVI is given in Appendix A. Note that the same approach can be used to derive the formula for the CKA kernel in Eq. (2) as well.

### Diverse Generative Ensemble with Hypernetworks

Besides diversifying ensemble models, we also explore using \(_{}\,/\,\) in learning a non-deterministic generator (Krueger et al., 2018) which gives us the ability to sample from a continuous nonlinear posterior distribution of network weights. This is appealing since it can generate any amount of network with a single training run of the generator, without being restricted by the fixed amount of posterior samples one can access with a regular ensemble.

The approach we take uses the concept of hypernetworks (Ha et al., 2016; Krueger et al., 2018). However, current variational inference methods are not scalable to larger models and generally require a change of variables or invertible functions (Krueger et al., 2018). Naively using a hypernetwork to transform a prior distribution to generate \(\) of the target network may result in the collapse of the posterior \(\) distribution. Hence, it would be interesting to explore using \(_{}\,/\,\) to avoid such mode collapses. We use the surrogate diversity loss in Eq. (4) to impose non-parametric independence of feature distributions. With hypernetworks we aim to transform, using a network \(h(z)\), some prior distribution \(z(,I),z^{P}\) to \(h(z)=^{_{i}w_{i}}\), where \(P\) is the dimensionality of the latent space, and \(w_{l}\) the number of parameters for layer \(l\). To learn the function \(h()\) we sample a batch \(M\) of \(\)'s, feed through the ensemble \(E(x,)\) and calculate loss, similar to a fixed ensemble as in Eq. (6). With the difference being that now we are backpropagating gradients to \(h()\) accumulated from the \(M\) ensemble members.

Using a plain MLP for the hypernetwork \(h\) would require the last layer's weight matrix to contain \(_{l}w_{l} J\) entries, where \(J\) is the activation dimension right before the last layer. This could possibly result in a matrix of millions of trainable parameters. To overcome this challenge we follow the approach by Ratzlaff & Fuxin (2019) of decomposing \(h\) into several parts. First a layer code generator \(h(z)=^{L,c_{}}\), and the layer generators \(_{l}=g_{l}(c_{l})\), where each layer generator \(g\) is a separate smaller network per layer \(l\). See Fig. 4 for a visualization. Note \(\) is a matrix with \(L\) layer codes of size \(c_{}\).

Figure 3: Predictive entropies (PE) on a four-cluster 2D classification task. Darker values indicate higher entropy, lower confidence regions, and lighter values indicate higher confidence regions. (b) and (d) use an RBF kernel on ensemble member weights, whereas (c) and (e) use an RBF kernel on ensemble member outputs. (f) and (g) use the \(\), RBF feature kernel, for feature diversity on inlier points. Both (h) and (j) use \(\) and OOD entropy terms. All methods were trained on an ensemble of 30 four layer MLPs for 1k iterations with the same seeds.

To further reduce size of the hypernetwork, for convolutional networks, we use the assumption that filters in convolutional layers can be independently sampled. For each convolutional layer \(l\) we create layer code vectors via the layer code generator \(c_{l}=h(z_{l})\), where each code vector \(i\) in \(c_{l_{i}}\) corresponds to a latent vector for a single convolution filter \(i\). We feed each filter code \(i\) through a filter generator \(g_{l}(c_{l_{i}})\) separately to generate the filter for layer \(l\). An example architecture can be seen in Fig. 4.

### Synthetic OOD Feature Diversity

Striking a balance between ensemble member diversity and inlier performance is a challenge. Enforcing strong feature dissimilarity on observed inlier examples could degrade inlier performance if not tuned correctly. ParVI methods that only observe inlier points, like SVGD, can achieve better diversity but often at the expense of inlier accuracy (D' Angelo & Fortuin, 2021). We have found that a more effective strategy is to reduce the feature similarity on obvious OOD examples, and reduce their likelihood, which could be synthetically generated. Intuitively, we want more diverse features on obvious outlier examples to indicate uncertainty because the networks trained on these examples should not be confident. We found this approach to generate OOD examples and increase their feature diversity to be very effective.

Importantly, the OOD points do not need to be close to the inlier data manifold at all. For images, we generate outlier points via random grids, lines, perlin noise, simplex noise, and vastly distorted and broken input samples. See Appendix E.2 for more details and example images. For vector datasets, such as the test 2D datasets presented in Fig. 3, we identify outlier points by locating the minimum and maximum values across training examples. Generally, the boundary does not need to be close to the in-distribution (ID) dataset to achieve good results. We split the Gram matrices into \(K_{}\) and \(K_{}\) and apply HE-CKA to them separately, with respective hyperparameters \(_{}\) and \(_{}\). The parameter value \(_{}\) can be adjusted to be smaller than \(_{}\). Additionally, for classification tasks, we add an entropy-maximizing term, scaled by hyperparameter \(\), for synthetic OOD points to Eq. (6). Similar loss terms may be constructed for other tasks, such as variance for regression tasks, but we have not explored them yet.

Figure 4: Hypernetwork \(h(z)\) model architecture example on a four layer CNN

Figure 5: 1D regression task comparing uncertainty estimation between different approaches

## 5 Experiments

In this section, we conduct experiments on several datasets, ranging from synthetic tasks to realistic out-of-distribution (OOD) detection problems, to validate our approach. We compare OOD results between ensembles, ParVI, and other baselines.

### Synthetic Data

We start by testing our approach on two synthetic tasks to visually assess the uncertainty estimation capability on both classification and regression problems. The first task is a 2D four-class classification problem, where each class is distributed in one quadrant of the 2D space with points sampled from Gaussians with \(=(.4,.4)\) and \(=( 2, 2)\). The objective is to evaluate whether the models can accurately predict uncertainty, ideally showing low uncertainty near training examples and high uncertainty elsewhere. We employed a three-layer MLP trained with cross-entropy on the four classes and measured the predictive entropy of points sampled uniformly from a \(10 10\) grid.

When using cross-entropy alone, the decision boundaries among the four classes tend to be very similar. Deep ensembles classify with high confidence in most areas where they have never observed data before (Fig. 3(a)). Introducing the \(\) diversity term to the ensemble significantly reduces the ensemble's confidence on points outside the in-distribution set (Fig.3(g)). Furthermore, incorporating the \(\) and entropy term for OOD points allows the model to better estimate uncertainty, with only inliers being confident (Fig. 3(h)). In the case of hypernetworks, we observe the importance of a diversity term. Without it, hypernetwork predictions tend to be overconfident on outliers (Fig. 3(i)). However, when introducing \(\) hypernetwork, we achieve results closely resembling that of the ensemble + \(\) term (Fig. 3(j)).

In our second test, we perform a 1D regression modeling task. We aim to learn the function \(y(x)=-(1.2x)(1+x)\) within \(x(-6,6)\) with high certainty everywhere except in \(x(-2,2)\). The training dataset involves sampling the function with 40 points uniformly from both \((-6,-2)\) and \((2,6)\), with 2 points from \((-2,2)\). We then fit a four layer MLP to approximate \(y(x)\).

The visual result of each method is shown in Fig. 5. The fixed ensemble (Fig. 5(a)) has little diversity between the areas with low density, in contrast to the ensemble plus the \(\) term (Fig. 5(b)). The hypernetwork, without any feature diversity term (Fig. 5(c)) collapses, producing very similar weights. However, adding the \(\) term to the hypernetwork (Fig. 5(d)) alleviates this issue.

### OOD Detection on Real Datasets

We evaluated our proposed approach on a variety of real-world datasets, including Dirty-MNIST, Fashion-MNIST, CIFAR-10/100, SVHN, and TinyImageNet. We employ different CNN architectures such as LeNet, ResNet32, and ResNet18 to demonstrate the versatility of our method across models of varying complexity. Our experiments compare the out-of-distribution (OOD) detection performance of our approach against several approaches, including Deep Deterministic Uncertainty (DDU), deep ensembles and Stein Variational Gradient Descent (SVGD) equipped with the RBF kernel.

We provide experimental settings and training details here and additionally in Appendix C. Limitations of this approach are discussed in Appendix D, while further insights into memory usage and computational efficiency are discussed in Appendix G. Details regarding synthetic OOD example generation is described in Appendix E.2.

Figure 6: Predictive softmax entropy between MNIST, Dirty-MNIST (with aleatoric uncertainty), and OOD Fashion-MNIST. Utilizing an ensemble of 5 LeNets. It can be seen that \(\) and OOD \(\) better separates the inlier Dirty-MNIST from outlier Fashion-MNIST.

[MISSING_PAGE_FAIL:9]

**CIFAR-10/100 vs SVHN.** We further evaluated our method on CIFAR-10 and CIFAR-100 datasets, testing outlier detection performance on SVHN (Table 2) (Netzer et al., 2011). For a fair comparison with D' Angelo & Fortuin (2021), we trained ResNet32 ensembles following the training procedure and parameters described by D' Angelo & Fortuin (2021). For more details regarding model architecture please refer to the aforementioned paper and published code. We used predictive entropy and mutual information for the OOD classification, with the exception of DDU using feature space density (Mukhoti et al., 2023).

Given that the network presented in D' Angelo & Fortuin (2021) has significantly fewer parameters than a typical ResNet, it is expected to see an inferior classification accuracy to that of standard ResNet. In order to show that our approach generalizes to larger networks, we trained on larger ResNet18 ensembles. Results in Table. 3 show that \(\) can maintain similar accuracy as regular deep ensembles while significantly improving on ECE and AUROC of outliers. For the CIFAR-100 results please see Appendix C.3. Our ensemble with a standard ResNet18 with batch normalization even slightly outperforms a WideResNet-28-10 (WRN) using the approach by Mukhoti et al. (2023). Additionally, the mean inference time for a WRN is 13ms compared to 9ms for the ResNet18 ensemble on a Quadro RTX 8000.

**TinyImageNet vs SVHN/CIFAR-10/CIFAR-100/DTD.** To further evaluate the effectiveness of our approach to larger models and more complex datasets, we conducted experiments using the TinyImageNet dataset (Le & Yang, 2015). We trained ensembles of ResNet18 models and tested their ability to detect OOD samples from SVHN (Netzer et al., 2011), CIFAR-10/100 (Krizhevsky, 2009), and the Describable Textures Dataset (DTD) (Cimpoi et al., 2014). Our objective was to assess whether the proposed methods could generalize to large-scale settings and improve OOD detection performance without compromising in-distribution accuracy. Training details, and data splits, are provided in Appendix C.4.

Our proposed methods, especially Ensemble+OOD \(\), enhanced OOD detection performance. Notably, Ensemble+OOD \(\) achieved an AUROC of 99.31% on SVHN and substantial improvements on CIFAR-10/100 and DTD datasets (Table. 4), with AUROC scores of 81.56%/87.64% and 90.94%, respectively. This improvement in OOD detection did not come at a major expense of ID accuracy.

## 6 Conclusion

In this paper, we explored the novel usage of CKA and MHE on feature kernels to diversify deep networks. We demonstrated that \(\) is an effective way to minimize pairwise cosine similarity, thereby enhancing feature diversity in ensembles and hypernetworks when applied on top of CKA. Our approach significantly improves the uncertainty estimation capabilities of both deep ensembles and hypernetworks, as evidenced by experiments on synthetic classification/regression tasks and real image outlier detection tasks. We showed that diverse ensembles utilizing predictive entropy alone can outperform other feature space density approaches, while synthetically generated OOD examples, far from the inlier distribution, can further significantly improve the OOD detection performance. While our current method requires fine-tuning several hyperparameters, such as layer weighting, we believe that future work could explore strategies for automatically estimating these parameters. We hope that our method inspires further advancements in Bayesian deep learning, extending its application to a wider range of tasks that require robust uncertainty estimation.

   Model & NLL (\(\)) & ID Accuracy (\(\)) & ECE (\(\)) &  \\   & & & SVHN & CIFAR 10/100 & Textures (DTD) \\  Ensemble & \(0.775\) & \(62.95\) & \(8.90\) & \(89.81\) & \(66.85/67.33\) & \(68.96\) \\ SVGD+RBF & \(0.926\) & \(61.87\) & \(16.10\) & \(92.76\) & \(72.23/73.73\) & \(65.67\) \\ SVGD+CKA\({}_{}\) & \(0.835\) & \(60.15\) & \(8.26\) & \(94.08\) & \(78.40/79.48\) & \(66.48\) \\ SVOD+HE-CKA & \(\) & \(61.36\) & \(\) & \(94.10\) & \(72.05/72.86\) & \(70.75\) \\ Ensemble+HE-\(\) & \(0.784\) & \(\) & \(9.82\) & \(92.65\) & \(72.13/71.68\) & \(70.69\) \\ Ensemble+ODD \(\) & \(0.786\) & \(61.88\) & \(8.02\) & \(\) & \(\) & \(\) \\   

Table 4: Performance of a five member ResNet18 ensemble trained on TinyImageNet. All models utilized a pretrained deep ensemble with no repulsive term, then fine tuned for 30 epochs for each method (including deep ensemble). Methods utilizing \(_{}\) and \(\) utilized a linear feature kernel.