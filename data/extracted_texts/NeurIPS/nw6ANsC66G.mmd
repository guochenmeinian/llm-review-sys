# Probabilistic Federated Prompt-Tuning with

Non-IID and Imbalanced Data

 Pei-Yau Weng

Washington State University

pei-yau.weng@wsu.edu

&Minh Hoang

Princeton University

minhoang@princeton.edu

&Lam M. Nguyen

IBM Research

lamnguyen.mltd@ibm.com

My T. Thai

University of Florida

mythai@cise.uf.edu

&Tsui-Wei Weng

University of California San Diego

lweng@ucsd.edu

&Trong Nghia Hoang

Washington State University

trongghia.hoang@wsu.edu

Corresponding authors: Pei-Yau Weng, Minh Hoang, Trong Nghia Hoang.

###### Abstract

Fine-tuning pre-trained models is a popular approach in machine learning for solving complex tasks with moderate data. However, fine-tuning the entire pre-trained model is ineffective in federated data scenarios where local data distributions are diversely skewed. To address this, we explore integrating federated learning with a more effective prompt-tuning method, optimizing for a small set of input prefixes to reprogram the pre-trained model's behavior. Our approach transforms federated learning into a distributed set modeling task, aggregating diverse sets of prompts to globally fine-tune the pre-trained model. We benchmark various baselines based on direct adaptations of existing federated model aggregation techniques and introduce a new probabilistic prompt aggregation method that substantially outperforms these baselines. Our reported results on a variety of computer vision datasets confirm that the proposed method is most effective to combat extreme data heterogeneity in federated learning.

## 1 Introduction

The proliferation of personal devices has transformed our data landscape into numerous federated systems with distinct resource constraints, data representations, distributions, and ownership. This has motivated the development of new machine learning (ML) paradigms that enable collaborative learning across different systems while respecting their data privacy. A prominent framework to substantiate this collaborative scheme is federated learning (FL), which allows multiple systems to train a common model without sharing their private data .

Existing FL methods often assume that learning begins from scratch and does not build on prior expertise. On the other hand, fine-tuning pre-trained or foundation models  is an emerging paradigm for efficient generation of ML solutions. Almost all state-of-the-art models in natural language processing (NLP) are now fine-tuned versions of foundation models, such as BERT , BART , RoBERTa , and T5 . Likewise, many top performing vision models have also benefited from the generalization capability of foundation models, such as the vision transformer model , which was trained on large-scale and generic datasets such as ImageNet . Nonetheless, this fine-tuning practice has only recently been investigated in federated learning .

Current research in this direction demonstrated various benefits of integrating fine-tuning into FL. For example, fine-tuning can utilize information better in decentralized data scenarios and thus improves the performance in various FL scenarios, mostly in NLP . Interestingly, it has been pointed out that even a simple initialization of local clients with a foundation model can prevent solution drift to some extent in large-scale scenarios with heterogeneous local data distributions . This is also consistently observed in the results of our case studies in Fig. 1.

However, in FL environments that depend on frequent communication and synchronization of model updates across multiple devices, fine-tuning the entire pre-trained model is often infeasible due to limited local storage and communication bandwidth. Our study also reveals that full-model fine-tuning approaches fall short when the federated data are not only _heterogeneous_ but also _imbalanced_. Our case studies in Fig. 1 in particular show that when the local data are both heterogeneous and imbalance, federated learning with full-model adaptation suffers a huge performance drop, highlighting its instability in extreme data settings.

To address the resource bottleneck, several works in the recent federated learning literature have turned to a new class of parameter-efficient tuning method called prompt tuning. This method focuses on engineering cues, such as extra tokens which are appended to the input embedding in a transformer architecture. Such tokens or prompts provide beneficial context to performing the computational task, similar to how hints can be provided to assist puzzle solving. Local sets of prompts can then be aggregated or personalized using existing federated learning strategies. For example, the prior works of  and  use FedAvg to aggregate the local prompts while  integrates prompt-tuning into personalized federated learning, which helps generate client-specific sets of prompts that are well-customized to the corresponding local data distribution.

Although federated prompt-tuning approaches eliminate the need to update and communicate hundreds of millions of network weights, there is a substantial gap between the performance of these approaches in highly heterogeneous, data-imbalanced settings, and the upper-bound performance of fine-tuning in the centralized data setting, as shown in Fig. 1. This gap can be attributed to the fact that locally learned prompt sets are learned in arbitrary orders, which are generally unaligned across clients. That is, the same prompt position across different clients might encode different contextual information about the local data. A simple aggregation that disregards prompt alignment might attempt to combine prompts from different contexts and collapse into less informative prompts. This has not been explicitly modeled in prior federated prompt-tuning work.

To address this issue, we adopt a hierarchical probabilistic modeling approach to characterize both the generation and alignment of local prompts in this paper. We cast the server aggregation step as an alignment of local prompt sets. This alignment discovers and aggregates local prompts encoding similar contextual information into summarizing prompts. On the client side, we view each local prompt set as an independent sample drawn from a generative model parameterized by the global summarizing prompts. In this view, each local prompt can be seen as a probabilistic exploration initialized by a randomly selected summarizing prompt. The alignment between prompts can be characterized in terms of their association with the summarizing prompts, which can be inferred via learning the parameters of the above generative model. We summarize our main contributions below:

**C1.** We formulate the prompt summarizing procedure as a probabilistic set modeling task in which each local set is assumed to be an independent sample of a random point process. The alignment of similar prompts across different local sets can be set as part of the modeling parameterization, whose optimization can be interleaved with the optimization of the point process's parameters (Section 3.2).

**C2.** We develop an algorithm to find the most probable association between the local and summarizing prompts. This association is viewed as a latent variable in the above generative model. Specifically, we cast its inference as a classical weighted bipartite matching task via an interesting observation that the association between the summarizing prompt and each local set of prompts participate linearly to the loss function of our proposed generative model (Section 3.3).

Figure 1: Test Accuracy (\(\%\)) achieved on the CIFAR-10 dataset by solving Eq. (3) via centralizing data, using FedAvg, and using FedProx on (orange) full-model (FM) and (blue) prompt-tuning (PT) setups. The evaluation is performed under (left) a standard (non-extreme) heterogeneous data partition; and (right) an extremely imbalanced data partitioning scheme (see Section 4).

**C3.** We compare the performance of our method against various federated prompt-tuning baselines based on existing heterogeneous federated learning techniques to demonstrate its effectiveness. Our reported results on a variety of experiments and baselines demonstrate consistently that our method is most effective to combat data imbalance in extreme heterogeneous scenarios (Section 4).

## 2 Related Work

Federated learning (FL) [1; 2] is a collaborative framework that allows multiple parties to collaborate on training a common model without sharing their private data. In FL, the training data are distributed across \(m\) clients. The \(t\)-th client owns a local, private dataset \(D_{t}=(_{tm},y_{tm})}_{m=1}^{n_{t}}\) comprising \(n_{t}\) data points. The goal is to fit a model \(_{*}\) using all private datasets without centralizing them. That is,

\[_{*}\ =\ *{arg\,min}_{}\{L() _{t=1}^{m}}{n} L_{t}() \}\,\ \ \ L_{t}()\ \ }_{m=1}^{n_{t}}_{tm},y_{tm}; \] (1)

and \(n=n_{1}+n_{2}+ n_{m}\) denotes the total number of data points while \((_{tm},y_{tm};)\) denotes some loss function of choice. Clients collaborate via sharing their local models instead of data. Each client can run multiple local updates before sharing its local model for aggregation. This helps reduce the number of communication rounds while still preserving the convergence guarantee.  names this the FedAvg algorithm, which iterates between local optimization and global aggregation:

\[_{t}^{(r)} =\] (2)

The local update routine \(U(_{t},.)\) is typically standard gradient updates such as SGD or Adam. At the beginning of an iteration, the local weight is set to be the global estimate from the previous communication round. In practice, local data distributions tend to diverge which consequently causes the local updates in Eq. (2) to have different convergence points across clients. This is known as the solution drift phenomenon, which often decreases the performance of the federated model. Numerous approaches had been proposed to mitigate this phenomenon, which includes the following directions:

**Client Regularization.** These methods focus on augmenting the local update strategies to prevent clients from drifting apart. For example, FedProx introduces an \(_{2}\)-regularization term to penalize updates that diverge the local model from the global model. FedDyn uses a FL-adapted version of  on distributed optimization as the regularizer. Scaffold attempts to correct the direction of local gradient updates at each client using their sum of gradients.  utilizes the similarity between model representations to correct local training via contrastive learning.

**Server Regularization.** Another approach to prevent the drifting effect caused by heterogeneous local distributions is to replace the model average in Eq. (2) with a different mechanism of model aggregation. For example, [7; 6] decomposes client models into bags of neurons and performs a non-parametric clustering of neurons. Cluster centroids are used to synthesize an aggregated model for the next communication round. This approach bypasses the drifting phenomenon as the number of cluster is non-parametric and can be adjusted to accommodate new information patterns. In a similar vein,  adopts a probabilistic perspective of model aggregation, sampling higher-quality global models and combining them via Bayesian model ensemble, leading to a more robust aggregation.  presents a data-free knowledge distillation methods for FL that help to train generators without compromising clients' data.  redistributes each client's shared model to others for \(b\) consecutive communication iterations, exposing it to various heterogeneous data sources before performing aggregation, curving their solution divergence.

**Personalization.** Instead of learning a single, universal model, [29; 37; 38; 39; 40] seek to learn personalized models for all clients. [3; 39] formulates this problem as multi-task learning, whereas  and  respectively ground it in meta-learning and regularization frameworks. Several recent works impose a shared data representation across clients [41; 42; 43; 44; 44], which is optimized using existing FL techniques, and locally fine-tune a small classification head to achieve personalization. However, personalized models trained in this manner tend to only perform well on its corresponding local test set, and not on a comprehensive test set combining all local test data (see Section 4).

Finally, most previous work assume that each FL client has sufficient data to adequately train its local model. This often contradicts real-world situations where data are scarce [45; 36; 46; 47; 48]. While data scarcity is not a new challenge of machine learning, it has not been thoroughly investigated in thecontext of FL.  points out that with limited, scarce data, local models often have bad qualities, and aggregating such models tend to result in poor global performance. Although fine-tuning pre-trained large models is an increasingly popular technique to combat data shortage, most existing FL works (including  which aims to address data scarcity) have not tried to leverage this resource. This motivates us to investigate prompt-tuning as a new FL paradigm.

## 3 Probabilistic Federated Prompt-Tuning

First, Section 3.1 provides a concise background on the standard prompt tuning technique in FL setting. Motivated by the result of our case study (see Fig. 1), Section 3.2 further introduces a probabilistic federated prompt-tuning framework that aims to close up the performance gap between federated prompt-tuning and centralized full-model fine-tuning in data imbalance settings. Our framework characterizes each local model as a random set of prompts distributed by a hierarchical generative model. An effective optimization algorithm to learn these is then detailed in Section 3.3. An overall diagram featuring a bird-view of our framework is also provided in Fig. 2.

### Prompt-Tuning with Pre-Trained Model

We use a pre-trained Vision Transformer  in all our experiments. The pre-trained model is a composition \(F_{c} F_{a} F_{e}\) where \(F_{c}\) is the classification head, \(F_{a}\) is the stack of attention blocks, and \(F_{e}\) is the input embedding block. Keeping both \(F_{a}\) and \(F_{e}\) frozen, the local solution for each client \(t\) can be represented as \(F_{c,t} F_{a}(F_{e})\) which applies a personalized prediction head on the output of the frozen attention block \(F_{a}\) whose (set) inputs are the union of \(F_{e}\) and a set \(\) of reprogramming prompts . \(\) is in turn a union of \(k\) individual prompts \(=_{1}_{2}_{k}\). Each local solution is characterized by a tuple of \((F_{c,t},)\) comprising a personalized head \(F_{c,t}\) and common prompt set \(\). The FL framework in Eq. (1) is now re-cast as

\[_{*}\!=\!_{}\{_{t=1}^{m} (}{n}) L_{t}()\}L_{t}()_{F_{c,t}}\{(} )_{m=1}^{n_{t}}_{tm},y_{tm};F_{c,t},\}\] (3)

where \((_{tm},y_{tm};F_{c,t},)=(_{tm},y_{tm}; F_{c,t} F_{a}(F_{e}))\) which makes explicit the leverage of the existing (pre-trained) expertises \((F_{a},F_{e})\). The optimal solution \(_{*}\) of Eq. (3) can be approximated using any of the existing federated learning algorithms, such as FedAvg and FedProx.

**Remark.** There is an alternative approach to enabling light-weight federated fine-tuning. Instead of using prompts, approaches in this direction use a (learnable) adapter network that adapts the output of an intermediate (frozen) neural network segment before passing it to the rest of the (frozen) neural network. Local adapters across client can then be aggregated using FedAvg. This direction is however orthogonal to federated prompt-tuning, which is our main focus here. Further investigation into probabilistic methods for adapter aggregation would be a potential follow-up of our current work.

### Probabilistic Prompt Model

Intuitively, our federated prompt tuning framework is an analog to traditional FL on the space of prompts. Prior to each communication round, we suppose that each local client \(t\), via prompt-tuning,

Figure 2: Workflow of Probabilistic Federated Prompt Aggregation: (left) each client selects a subset of prompts from the global set of summarizing prompts using the prompt-selection mechanism adapted from , and fine-tune them using local data; and (right) the server collects all local prompt sets and updates the global summarizing prompts that aggregate similar local prompts. This is achieved by our proposed probabilistic federated prompt aggregation (PFPT) algorithm.

has obtained a set of \(n_{t}\) prompts \(_{t}\{_{t1},_{t2},,_{t m_{t}}\}\). As the participating clients upload their local prompt sets, the server aggregates the combined set and subsequently returns a set of \(n\) summary prompts, denoted as \(\{_{i}\}_{i=1}^{n}\). We will elaborate on this aggregation step in Section 3.2.2. Similar to standard FL, this aggregated set is also distributed to all clients at the beginning of the next communication round. Each client then selects the most relevant prompts from this set for further fine-tuning. This sampling step follows a generative process described in Section 3.2.1.

#### 3.2.1 Generative Model

At the beginning of each communication round, each client constructs a set of \(n_{t}\) prompt initializations given the server-broadcast summary \(\). We model this construction by a random generative process. First, each local prompt initialization, \(_{tk}\), is modeled as a sample drawn from a Gaussian with learnable neural parameterization,

\[_{tk}  _{tk},(_{tk};)\,\] (4)

where the diagonal covariance matrix are parameterized as the output of a neural net \(\) (with weight \(\)) on the mean parameter \(_{tk}\). The set of mean parameters \(_{t}\{_{tk}\}_{k=1}^{n_{t}}\) is in turn modeled as a random subset of the (server-broadcast) summarizing prompts \(\), following a Bernoulli point process prior with a finite mixture as the base measure:

\[Q_{t}()  (_{i=1}^{n}g_{i };=_{i} )\.\] (5)

Here, \(\) denotes the sigmoid activation function, and \(g\) is another deep-parameterized function parameterized by weight \(\). By definition of the Bernoulli process, the sampled measure is given by:

\[Q_{t}()\,=\,_{i=1}^{n}c_{i} 1=_{i }\,\] (6)

where \(c_{i}\{0,1\}\) is the outcome of a Bernoulli trial with bias \((g(_{i};))\), that is:

\[_{i}(c_{i}) = g(_{i};)^{c_{i}} 1-g(_{i};)^{1-c_{i}}\.\] (7)

In layman term, this process simply means we will observe the result of a coin toss \(c_{i}\) for every summarizing prompt \(_{i}\). If this coin lands on head (\(c_{i}=1\)), the summarizing prompt \(_{i}\) will be included in the set of mean parameters. Vice versa, if this coin lands on tail, we will skip \(_{i}\). Because of this, we remark that \(n_{t}\) could be different from the number of prompts in the previous round.

#### 3.2.2 Prompt Aggregation

Given the above generative story, we can now describe our algorithm to find the set of summarizing prompts \(\{_{i}\}_{i=1}^{n}\), which maximize the likelihood of observing local prompts \(\{_{t}\}_{t=1}^{m}\). The resulting optimal set of summarizing prompts can then be used to re-program the pre-trained model, which correspond to the global fine-tuned solution. Assuming that each prompt captures a particular fine-tuning pattern or concept, summarizing the prompt sets characterizing the local solutions will allow local models to be aggregated on the concept level, naturally mitigating the solution drift effect caused by compounding impact of data heterogeneity and pre-trained weight interference. This is substantiated in the overall computation process below.

Let \(z^{i}_{tk}\{0,1\}\) denotes whether the local prompt \(_{tk}\) was sampled from a Gaussian centered at the \(i\)-th summarizing prompt \(_{i}\). That is, the assignment variable \(z^{i}_{tk}=1\) if and only if there exists \(k[n_{t}]\) such that \(_{tk}=_{i}\). Each client \(t\) can now be represented as \((_{t},_{t})\) where \(_{t}=\{^{i}_{t}\}_{i=1}^{n}\), \(^{i}_{t}=(z^{i}_{t1},z^{i}_{t2},,z^{i}_{tn_{t}})\) and \(_{t}=(_{t1},_{t2},,_{tn_{t}})\).

Now, using the generative process specified in the previous section and all its defining parameters \(=(,,\{^{n}_{t=1}\})\), the log likelihood of each client can be derived as follow,

\[(_{t},_{t}) = (_{t}_{t}, )\ +\ (_{t})\,\] (8)

where each of the summand on the right-hand side is computed below. First, given \((_{t},)\),

\[_{t}_{t},=_{ k=1}^{n_{t}}_{tk}_{tk}, _{tk};\ \ _{tk} =z^{1}_{tk}_{1}++z^{n}_{tk}_{n}\] (9)Then, given \(\) and let \(c_{ti}=z_{t1}^{i}+z_{t2}^{i}++z_{tn_{t}}^{i}\),

\[_{t}\;=\;_{i=1}^{n}( g(_{i};)^{c_{ti}})\;\;_{ i=1}^{n}(1-g(_{i};)^{ (1-c_{ti})})\] (10)

Eq. (9) follows from the Gaussian likelihood of local prompt in Eq. (4) with the additional identification form for \(_{tk}\) which is computable if \(_{t}\) is given. Eq. (10) on the other hand is the consequence of the Bernoulli process in Eq. (6), which might not be immediately straight-forward. Its detailed derivation will be given in Appendix B.

#### 3.2.3 Overall Workflow

Using Eq. (9) and (10), we have the following prompt aggregation formulation,

\[^{*} = *{argmax}_{}\{_{,,}_{t=1}^{m}_{t}, _{t},,\}\] (11)

where \(=\{_{i}\}_{i=1}^{n}\), \(=\{_{t}\}_{t=1}^{m}\), and \(\) is previously defined in Eq. (4). The probability term on the right-hand side can be further expanded into computable terms using Eq. (8), Eq. (9), and Eq. (10). Solving Eq. (11) is therefore the key step in our federated fine-tuning framework, whose overall flow is summarized in Alg. 1. Our algorithm proceeds in multiple iterations. At each iteration, a set of \(m\) clients is sampled. Each client selects the most relevant subset of summarizing prompts from the server using a mechanism adapted from continual visual prompt-tuning . The selected subset of summarizing prompts are then fine-tuned using local data (see lines \(3\)-\(4\)). The sets of fine-tuned prompts are subsequently uploaded to the server, which performs the aggregation via solving Eq. (11) (see line \(6\)). The aggregation step has two subtleties: (1) the total number of global prompts, \(n=n_{1}++n_{t}\), is proportional to the total number of prompts across clients, making the entire algorithm non-parametric; and (2) once the optimal assignment parameters \(\) are found via solving Eq. (11), global prompts that were not assigned to any client will be removed (see lines \(7\) and \(8\)). Intuitively, if the sampled clients are similar, their prompt sets will substantially overlap, which reduces the total number of distinct prompts selected by all clients. Otherwise, if the sampled clients are dissimilar, there will be less overlapping and the union set of selected global prompts will expand, increasing the complexity of the resulting model to match the increased data heterogeneity.

``` input: pre-trained model \(F\), no. \(\) of iterations, no. \(m\) of sampled clients per iteration output: optimized set of prompts \(\)
1: initialize global summarizing prompts \(\)
2:for\(s=1\)to\(\)do
3: sample \(m\) clients with private datasets \(\{D_{t}\}_{t=1}^{m}\)
4:for\(t=1\)to\(m\)do
5:\(_{t}(F,D_{t},)\) // local prompt-tuning - optimizing \(L_{t}(_{t})\) in Eq. (3)
6:endfor
7:\(,(\{_{t}\}_{t=1}^{m})\) // solving Eq. (11)
8:\(_{i}_{t=1}^{m}_{k= 1}^{n_{t}}z_{tk}^{i}>0}\) // remove inactive prompts
9:endfor
10:return the set \(\) of optimal prompts ```

**Algorithm 1** Probabilistic Federated Prompt Tuning (PFPT)

### Optimization

Solving Eq. (11) above is however not trivial due to its mixed set of discrete/continuous variables. To sidestep this intractability, we instead formulate it as a bi-level optimization that alternates between two sub-tasks: (1) optimizing \(\) given \(,\) and \(\); and (2) optimizing \(,,\) given \(\). Among which, solving sub-task (2) is straight-forward since it only requires being able to differentiate the expression in Eq. (9) and Eq. (10), which is trivial if we use the current estimation of the (discrete) assignment parameters \(\). On the other hand, solving sub-task (1) is seemingly prohibitive expensive because it involves optimizing the (discrete) assignment parameters \(\). Fortunately, this can be mitigated by casting both Eq. (9) and Eq. (10) into a linear form with respect to the assignment parameter \(\). Intuitively, it might be confusing why such linear form can be achieved at all given that \(\) is input to a non-linear log probability function in Eq. (9) and Eq. (10). However, we must recognize that for each client \(t\), there is at most one local prompt from \(t\) which can be associated with the \(i^{}\) summarizing prompt. This implies \(_{t}^{i}(z_{t1}^{i},z_{t2}^{i},,z_{t_{th}}^{i})\) is either a zero or one-hot vector. This is an important observation because a linear function of such zero or one-hot vector will remain linear regardless of any (non-linear) post-processing transformation. It is shown in Lemma 3.1 below.

**Lemma 3.1**.: _For any scalar function \(g()\) and a binary vector \(=[_{1},_{2},,_{n}]\) such that \(_{i}\{0,1\}\) and \(\) has at most one non-zero component, we have_

\[g(_{i=1}^{n}_{i}_{i}) = _{i=1}^{n}(_{i} g(_{i}))\] (12)

_with respect to any set \(\{_{i}\}_{i=1}^{n}\) of valid inputs to \(g()\)._

The proof of Lemma 3.1 is straight-forward. First, if there is no non-zero component, both sides of Eq. (12) evaluate to \(g(0)\). Otherwise, suppose the only non-zero component appears at position \(\), both sides of Eq. (12) will evaluate to \(g(_{})\). In both cases, Eq. (12) holds. Using Lemma 3.1, we can establish the desired linear forms for Eq. (10) and Eq. (11) which are its immediate consequences.

**Lemma 3.2**.: _Let \((_{t}_{t},)\) defined as in Eq. (9). Let \(L_{1}()=_{t=1}^{m}(_{t} _{t},)\), considering \((_{t},)\) as constants. We have_

\[L_{1}() = _{i=1}^{n}_{t=1}^{m}_{k=1}^{n_{t}}z_{tk}^{i} (_{tk}|_{i},(_{i}; ))\] (13)

_which is linear in terms of the assignment parameter \(\)._

**Lemma 3.3**.: _Let \((_{t})\) defined as in Eq. (10). Let \(L_{2}()=_{t=1}^{m}(_{t})\), considering \(\) as constants. Then, we have_

\[L_{2}()\;=\;_{i=1}^{n}_{t=1}^{m}_{k=1}^{n_{t}}z_{tk}^{i} (g(_{i};) }{1-g(_{i};)})\;+\;_{ i=1}^{n}_{t=1}^{m}(1-g(_{i}; ))\] (14)

_which is linear in terms of the assignment parameter \(\)._

The detailed proof for Lemma 3.2 and Lemma 3.3 are deferred to Appendix C. Using these results, we can put together the overall optimization task for \(\) while fixing the rest of the parameterization

\[^{*} = *{argmax}_{}\{_{t=1}^{m} _{t},_{t}\}\;\;=\;\;*{argmax}_{}\{L_{1 }()\;+\;L_{2}()\}\] (15)

which is a weighted linear optimization task. The second equality follows from Eq. 8 and the results of Lemma 3.2 and Lemma 3.3. Now, if we further choose to optimize \(_{t}\) iteratively while fixing in addition \(_{-t}\), Eq. (15) reduces to a weighted bipartite matching task, which can be solved effectively in \(((_{t=1}^{m}n_{t})^{3})\) processing time using the Hungarian algorithm . A detailed pseudo-code implementing the above scheme is deferred to Appendix D.

## 4 Empirical Results

This section presents our empirical studies on a variety of computer vision datasets, including CIFAR-10 and CIFAR-100 , TinyImageNet  and a synthetic, diverse dataset created by pooling together the MNIST-M , Fashion-MNIST , CINIC-10  and MMAFEDB (available on Kaggle) datasets, which is referred to as the \(4\)-dataset.

Our experiments are conducted on two data settings: (a) Dirichlet-based heterogeneous partition following a previous setup in ; and (b) manual imbalanced data partition, as detailed below.

**Heterogeneous Partition.** We partition the training data into \(m\) subsets (for \(m\) clients). Each client has observations of all classes but the distributions of classes across clients are different. We simulate this using a \((_{s})\) distribution over an \(s\)-dimensional simplex where \(s\) is the number of classes and \(\) is the concentration parameter.

Our experiments are conducted with \(=0.1\) and \(=0.5\). For each client \(r\), we drawn a sample \(_{r}(_{s})\) where \(_{r,c}(0,1)\) specifies the percentage of examples in class \(c\) to be assigned to client \(r\). For the CIFAR-10, CIFAR-100, and TinyImageNet datasets, we set \(m=100\). For the \(4\)-dataset, we simulate \(20\) partitions for each of the \(4\) sub-dataset using \((_{s})\) with \(s=10,10,10\), and \(7\) for MNIST-M, FASHION-MNIST, CINIC-10, and MMAFEDB. This amounts to a total of \(80\) clients with diverse and heterogeneous data distribution.

**Imbalance Partition.** For the CIFAR-10 (\(10\)-class), CIFAR-100 (\(100\)-class) and TinyImageNet (\(200\)-class) datasets, the training data of each client is set to be dominated by a particular subset of classes, which amounts to \(10\%\) of the total number of classes. \(99\%\) of the local dataset of each client is set to belong to a certain \(10\%\) of the total number of classes. For our synthetic \(4\)-dataset, we partition each of the \(4\) sub-dataset into \(20\) subsets. Each subset is set so that \(99\%\) of its data points belong to a single class. The remaining \(1\%\) data of each class are then pooled together and evenly distributed among all clients. This amounts to \(80\) clients with extremely imbalance local datasets.

The above schemes are applied only on the train partition of each dataset. We use the default train/test partition for CIFAR-10, CIFAR-100, and TinyImageNet. For the \(4\)-dataset, we sample \(30\)K data points from the default train partition of each of its \(4\) sub-datasets. We also sample \(2.5\)K data points from the default test partition of each sub-dataset. This amounts to a synthetic dataset with \(120\)K data points in the train partition and \(10\)K data points in the test partition.

For each data setup on each dataset, we compare the performance of our probabilistic federated prompt-tuning (PFPT) algorithm with those of a representative set of state-of-the-art federated learning algorithms adapted to the prompt-tuning setting in Eq. (3), which include FedAvg, FedProx, Scaffold, FedOpt and PFedPG. PFedPG is a personalization method that is originally measured based on how well its personalized models perform on their corresponding local test sets. In this context, the performance target is however set on a global test set so we use PFedPG's common model for evaluation. We will refer to these adapted baselines as FedAvg-PT, FedProx-PT, Scaffold-PT, FedOpt-PT, and PFedPG. In addition, we also compare PFPT against a simple prompt clustering baseline, which replaces the prompt averaging of FedAvg by a Gaussian Mixture Model (GMM) clustering in which the cluster centroids are returned as the aggregated prompts. We refer to this baseline as GMM-PT. All results are averaged over \(5\) independent runs and reported in Tables 1 to 4 below. The result of each run is evaluated on a global test set, which comprises the entire test partition.

### Non-IID Data with Locally Skewed Class Distributions

Table 1 reports the performance of PFPT and various federated prompt-tuning baselines on the CIFAR-10 dataset. In all three settings (i.e., heterogeneous partitions with \(=0.5\) and \(0.1\), as well as the imbalance partition), PFPT consistently achieves the best performance. On average, the classification accuracy of our method improves by \(0.3\%\) over the closest competitors, FedAvg-PT and FedProx-PT. While this gain seems modest, we note that the prompt tuning performance tends to fall off more significantly on several FL frameworks that were devised to counteract the effect of imbalanced data, such as Scaffold-PT and FedOpt-PT. In fact, the accuracy our method

   & FedAvg-PT & FedProx-PT & Scaffold-PT & FedOpt-PT & PFedPG & GMM-PT & PFPT (ours) \\  \(=0.5\) & \(94.06 0.45\) & \(94.26 0.34\) & \(92.26 0.18\) & \(90.70 0.54\) & \(88.00 0.22\) & \(92.63 0.16\) & \(\) \\ \(=0.1\) & \(93.05 0.03\) & \(93.05 0.23\) & \(91.82 0.34\) & \(88.20 0.39\) & \(77.25 0.23\) & \(92.68 0.28\) & \(\) \\ imbalance & \(91.21 0.16\) & \(91.08 0.25\) & \(87.06 1.27\) & \(79.32 1.73\) & \(43.16 0.27\) & \(90.50 0.17\) & \(\) \\  

Table 1: Accuracy (\(\%\)) achieved on the CIFAR-10 dataset by PFPT and other baselines.

   & FedAvg-PT & FedProx-PT & Scaffold-PT & FedOpt-PT & PFedPG & GMM-PT & PFPT (ours) \\  \(=0.5\) & \(79.40 0.27\) & \(79.21 0.31\) & \(70.83 0.18\) & \(59.58 1.13\) & \(43.47 0.39\) & \(77.50 0.12\) & \(\) \\ \(=0.1\) & \(74.50 0.46\) & \(73.60 0.38\) & \(69.94 0.63\) & \(60.31 0.39\) & \(29.46 0.80\) & \(70.49 0.46\) & \(\) \\ imbalance & \(70.07 0.35\) & \(70.67 0.25\) & \(69.35 0.96\) & \(58.86 0.77\) & \(11.57 0.25\) & \(66.95 0.46\) & \(\) \\  

Table 2: Accuracy (\(\%\)) achieved on the CIFAR-100 dataset by PFPT and other baselines.

   & FedAvg-PT & FedProx-PT & Scaffold-PT & FedOpt-PT & PFedPG & GMM-PT & PFPT (ours) \\  \(=0.5\) & \(86.38 0.18\) & \(86.05 0.47\) & \(78.70 0.33\) & \(61.55 0.28\) & \(50.92 0.44\) & \(84.73 0.20\) & \(\) \\ \(=0.1\) & \(78.58 0.57\) & \(79.19 0.28\) & \(78.02 0.33\) & \(63.81 0.79\) & \(34.34 0.10\) & \(76.90 0.28\) & \(\) \\ imbalance & \(75.21 0.73\) & \(75.49 0.38\) & \(76.88 0.45\) & \(64.33 0.61\) & \(11.92 0.13\) & \(73.85 0.36\) & \(\) \\  

Table 3: Accuracy (\(\%\)) achieved on the TinyImageNet dataset by PFPT and other baselines.

[MISSING_PAGE_FAIL:9]

distribution will remain skewed even if all local datasets are aggregated. That is, local datasets in this setting are non-IID draws from a long-tailed data distribution parameterized by an imbalance factor \(=(_{c}n_{c})/(_{c}n_{c})\) characterizing the ration between sample sizes (\(n_{c}\)) of the most frequent and least frequent classes [57; 58]. Such (global) long-tailed datasets are synthetically created from the original CIFAR-100 and ImageNet datasets following the data simulation in . Following previous experiment setup in previous (non-ViT and no prompt-tuning) baseline methods FEDIC  and CReFF 2, the resulting long-tailed datasets (CIFAR-100-LT and ImageNet-LT) are configured to have \(=10,50,100\) for CIFAR-100 and \(=1280/5\) for ImageNet. The reported results in Table 5 show that our method is also highly effective in this setting, achieving significantly higher accuracy than the current SOTA [57; 58] across all datasets and imbalance setups.

### Prompt Convergence and Diversity

To generate insights regarding the learned prompts, we plot the \(2\)-dimensional t-SNE embeddings of all CIFAR-100 global prompts discovered by our method across \(120\) communication rounds. This is repeated for the two heterogeneity and one data imbalance FL settings as well as the centralized data setting (Fig. 3). The yellow triangles in each plot mark the corresponding centroids of the prompt embeddings (one per \(10\) communication iterations). We also plot a best-fit spline curve (dashed and colored in red) through these centroids to visualize their update trajectory. In all settings, the distance between successive centroids consistently gets smaller as training progresses, which suggests that the learned prompts generally converge well. This is also corroborated by Fig. 4, which shows that the number of global prompts also converges over \(120\) communication iterations. It is also observed that in the centralized learning scenario in which no heterogeneity is present, the convergence happens much faster. The prompts quickly converge within \(10\) communication iterations. We also observe a gradual increase in the spread of the prompts with respect to their centroid. This suggests that the learned prompts are optimized by our method to capture the data diversity across participating clients. More interestingly, as we move from the standard heterogeneity settings (with \(=0.1\) and \(=0.5\)) to the extremely heterogeneous setting with imbalance (local) data, the magnitude of this spread becomes larger, confirming the strong correlation between task heterogeneity and prompt diversity.

## 5 Conclusion

Our paper presents a new and effective approach to address the challenges of prompt-tuning pre-trained models in federated data scenarios with diverse local data distributions. Our proposed approach is a hierarchical probabilistic framework that models server aggregation as a non-parametric alignment of locally learned prompt sets into summarizing prompts. In each subsequent communication round, local clients sample and perform local updates on relevant prompts from the previous set of summarizing prompts. In this manner, our approach bypasses the effect of solution drift and outperforms existing federated learning techniques (applied on prompt-tuning) on various computer vision datasets. The reported results emphasize the cost-efficiency and efficacy of our approach in combating data heterogeneity within extremely diverse federated scenarios.

**Acknowledgements and Disclosure of Funding.** This work used GPU compute resource at SDSC through allocation CIS230391 from the Advanced Cyberinfrastructure Coordination Ecosystem: Services and Support (ACCESS) program , which is supported by U.S. National Science Foundation grants \(\#2138259\), \(\#2138286\), \(\#2138307\), \(\#2137603\), and \(\#2138296\). My T. Thai acknowledges the support of National Science Foundation grants SCH-2123809 and III-2416606. T.-W. Weng is supported by National Science Foundation awards CCF-2107189, IIS-2313105, IIS-2430539, the Hellman Fellowship, and Intel Rising Star Faculty Award.

   &  & ImageNet-LT (\(~{}=~{}1280/5\)) \\   & \(~{}=~{}100\) & \(~{}=~{}50\) & \(~{}=~{}10\) \\  FEDIC & 33.67 & 34.74 & 41.93 & 28.93 \\  CReFF & 26.19 & 28.32 & 35.49 & 26.31 \\  PFPT (ours) & \(\) & \(\) & \(\) & \(\) \\  

Table 5: Accuracy (\(\%\)) achieved on long-tailed datasets by PFPT, CReFF  and FEDIC .