# MIMONets: Multiple-Input-Multiple-Output Neural Networks Exploiting Computation in Superposition

Nicolas Menet\({}^{1,2}\)

menetn@ethz.ch

&Michael Hersche\({}^{1,2}\)

her@zurich.ibm.com

&Geethan Karunaratne\({}^{1}\)

kar@zurich.ibm.com

Luca Benini\({}^{2}\)

lbenini@iis.ee.ethz.com

&Abu Sebastian\({}^{1}\)

ase@zurich.ibm.com

&Abbas Rahimi\({}^{1}\)

abr@zurich.ibm.com

\({}^{1}\)IBM Research - Zurich, \({}^{2}\)ETH Zurich

###### Abstract

With the advent of deep learning, progressively larger neural networks have been designed to solve complex tasks. We take advantage of these capacity-rich models to lower the cost of inference by exploiting _computation in superposition_. To reduce the computational burden per input, we propose Multiple-Input-Multiple-Output Neural Networks (MIMONets) capable of handling many inputs at once. MIMONets augment various deep neural network architectures with variable binding mechanisms to represent an arbitrary number of inputs in a compositional data structure via fixed-width distributed representations. Accordingly, MIMONets adapt nonlinear neural transformations to process the data structure holistically, leading to a speedup nearly proportional to the number of superposed input items in the data structure. After processing in superposition, an unbinding mechanism recovers each transformed input of interest. MIMONets also provide a dynamic trade-off between accuracy and throughput by an instantaneous on-demand switching between a set of accuracy-throughput operating points, yet within a single set of fixed parameters. We apply the concept of MIMONets to both CNN and Transformer architectures resulting in MIMOConv and MIMOFormer, respectively. Empirical evaluations show that MIMOConv achieves \( 2-4\) speedup at an accuracy delta within \([+0.68,-3.18]\%\) compared to WideResNet CNNs on CIFAR10 and CIFAR100. Similarly, MIMOFormer can handle 2-4 inputs at once while maintaining a high average accuracy within a \([-1.07,-3.43]\%\) delta on the long range arena benchmark. Finally, we provide mathematical bounds on the interference between superposition channels in MIMOFormer. Our code is available at https://github.com/IBM/multiple-input-multiple-output-nets.

## 1 Introduction

Driven by the successes of deep learning in image and natural language processing tasks, increasingly large neural network models have been developed to reach state-of-the-art performance [1; 2; 3; 4]. These large models, however, increase computational complexity in terms of operation count for every event of input processing. One viable option to reduce the computational cost of processing per input is to create a compositional data structure where a variable number of input items (i.e., values) can be bound to corresponding protection keys, creating key-value pairs that can coexist and be processedconcurrently. This variable-sized data structure can be represented by fixed-width distributed representations in vector-symbolic architectures (VSAs) [5; 6; 7]. In VSAs, the composition of different items in the data structure is based on functional compositionality (i.e., key-value binding), which yields a dimensionality-preserving distributed representation, rather than concatenative compositionality. Interestingly, the resulting fixed-width distributed data structure can be transformed by a one-time application of a function, whereby all input items are jointly transformed, leading to _holistic transformation_ or _computation in superposition_[8; 9; 10]. This concept of computation in superposition can reduce the effective number of operations per input by a factor of the number of input items in the data structure, because the function is applied to the data structure holistically without decomposing the constituent items for individual transformations. However, processing the VSA data structure via computation in superposition has so far been limited to linear maps [8; 9; 10].

Motivated by these observations, we make the following contributions:

(1) We introduce a principled and transparent approach to Multiple-Input-Multiple-Output Neural Networks (MIMONets) based on VSA, enabling computation in superposition for highly nonlinear transformations in neural networks (Section 2). The MIMONets concept can be applied to various architectures, embracing the rich capacity provided by increasingly large models. The resulting network can handle many inputs at once, thus reducing the computational cost per input. We describe and overcome the challenges of computation in superposition, which originates from nonlinear interference of inputs in separate superposition channels.

(2) We propose MIMOConv, a realization of MIMONets for deep convolutional neural network (CNN) architectures (Section 3). We provide several strategies for mitigating interference between different superposition channels, including a novel locality-preserving binding operation (PWHRR) and isometry-inducing regularization. Empirical evaluations on CIFAR10 and CIFAR100 show that a MIMOConv built on a WideResNet-28-10  can process concurrently two inputs in superposition (\( 2\) speedup) even with a slightly higher accuracy (\(0.11\)-\(0.68\%\) gain), and four inputs (\( 4\) speedup) with a marginal drop (\(1.24\)-\(3.18\%\)) (see Section 5.1).

(3) We further extend the concept of MIMONets to Transformer architectures, where the calculation of attention scores poses additional challenges for the computation in superposition paradigm. To this end, we propose MIMOFormer, which relies on a 2D grid binding scheme for computing attention in superposition (Section 4). We derive probabilistic tail bounds on the distortion caused by inter-channel interference and show that our method converges to noise-free attention in the limit of high dimension. Our method succeeds empirically (\( 96.52\%\) accuracy) at synthetic sequence modelling tasks , while previous work  fails (\( 20.04\%\)). We also provide evaluations on the long range arena (LRA) dataset  in Section 5.2 using a MIMOFormer that is based on the Performer architecture . Compared to the Performer, MIMOFormer maintains a high average accuracy with a marginal drop of \(1.07\%\) and \(3.43\%\) when handling two and four inputs at once, respectively.

(4) MIMONets allow a _dynamic_ trade-off at inference time between accuracy and speed, i.e., they offer an instantaneous on-demand switching between accuracy-throughput operating points using

Figure 1: MIMONets simultaneously pass multiple inputs through a nonlinear function, e.g., a deep convolutional network (on top) or a Transformer (on bottom). Input samples are bound with high-dimensional keys to project the samples into quasi-orthogonal subspaces. The results of the individual samples are retrieved at the end of the network by unbinding with corresponding keys.

single set of fixed parameters._ Experimental results in Section 5.1 show that a dynamic MIMOConv can seamlessly operate at various modes (\( 1\!-\!4\!\) speedup) while maintaining a high accuracy compared to the best static models (\( 1.82\%\) drop).

## 2 MIMONets enabling Computation in Superposition

The central idea behind MIMONets (see Figure 1) is to simultaneously pass multiple inputs as a superposition through a nonlinear function \(f_{}\) parameterized by neural network weights \(\). We isolate the individual inputs into separate protected _channels_ by binding them with protection keys resulting in a key-value data structure .

Concept.Assuming two inputs (\(x^{(1)}\) and \(x^{(2)}\)), which can be generic embeddings either from images or natural language, we define a unique high-dimensional key (\(a^{(1)}\) and \(a^{(2)}\)) for each protected channel, drawn randomly at initialization. Owing to the Blessing of Dimensionality, randomly drawn high-dimensional vectors are quasi-orthogonal with high probability (see Appendix A). Consequently, binding (\(\)) the inputs with these keys yields quasi-orthogonal key-value pairs (\(x^{(1)} a^{(1)}\) and \(x^{(2)} a^{(2)}\)), which enables one to superpose the pairs with low interference:

\[s=a^{(1)} x^{(1)}+a^{(2)} x^{(2)}.\] (1)

As discussed in Appendix A, \(s\) admits a noisy retrieval of \(x^{(1)}\) and \(x^{(2)}\) through unbinding:

\[^{(1)}=a^{(1)}\,\,}}}\,s=a^{(1)}\,\,}}}\,a^{(1)}  x^{(1)}+a^{(1)}\,\,}}}\,a^{(2)} x^{(2)}=x^{(1)}+noise\] (2)

To accelerate computing, inspired by the above-mentioned noisy retrieval, we pass the superposition \(s\) through a nonlinear function \(f_{}\) with parameters \(\), such as a neural network, before retrieval. The quasi-orthogonality of the bound inputs allows processing each in a separate _protected_ subspace--all with a single function call. To be able to recover the first processed sample \(f_{}(x^{(1)})\) from \(f_{}(s)\), we aim to find an unbinding key \(^{(1)}\) for which

\[^{(1)}\,\,}}}\,f_{}(s) ^{(1)}\,\,}}}\,f_{}(a^{(1)} x^{(1)} )+^{(1)}\,\,}}}\,f_{}(a^{(2)} x^{(2)})\] (3) \[ f_{}(x^{(1)})+^{(1)}\,\,}}}\,f_{ }(a^{(2)} x^{(2)}).\] (4)

The first approximation holds exact for linear \(f_{}\). As discussed in Section 3, a nonlinear \(f_{}\) can still be encouraged to allow such an approximation through appropriate weight regularization techniques and well-suited activation functions. Further, by optimizing over unbinding keys (\(^{(i)}\)), the second estimation (Eq. (4)) can be achieved. Consequently, matching binding and unbinding keys (\(a^{(i)}\) and \(^{(i)}\)) that confirm the approximation (Eq. (3) and (4)) set up a protected _channel_ through the nonlinear function \(f_{}(s)\). Appendix A lists the design choices of the adopted VSA, which define the operations of key-value binding and unbinding, for all MIMONet variants presented in this work. In the case of image embeddings, we use circular convolution  for binding and Matrix Binding of Additive Terms (MBAT)  for unbinding. In the case of sequence tokens, we bind and unbind using the Hadamard product . Binding and unbinding keys are always data-independent, i.e., they depend only on the index of the protected channel. See  for alternative binding and unbinding options.

Dynamic Inference.Setting up \(N\) protected channels through a neural network \(f_{}\) gives almost a speedup of \(N\) due to most computations taking place in superposition. However, as is explored empirically, increasing \(N\) adds inter-channel noise leading to a decrease in predictive accuracy. If a fixed trade-off is unsatisfactory, one can build a dynamic model capable of running a superposition of one up to \(N\) different inputs. By inserting the same input into multiple channels and averaging the output, one effectively forms an in-network ensemble, similar to . Using all protected channels for different inputs leads to a fast but less accurate model, whereas using all protected channels for the same input yields a slower but accurate ensemble model. By partitioning the superposition channels on demand, arbitrary configurations in between may be reached. Note that our method can instantaneously adapt to the current computational demand, without loading different model weights from the main memory. To perform across slow and fast configurations, the model should randomly switch between them during training. See Appendix A for a more detailed explanation.

## 3 MIMOConv

This section presents how the MIMONets concept, introduced in Section 2, can be applied to construct a multiple-input-multiple-output CNN (MIMOConv) capable of simultaneously processing multiple images in superposition. The MIMOConv architecture is shown in Figure 2. Multiple input samples (\(N\)) are passed through the first convolutional layer, bound with a unique high-dimensional key based on Holographic Reduced Representations (HRR) , and superposed by element-wise addition. After passing the superposed tensors through the network's main CNN layers, we obtain a combined feature vector with information on all inputs. By unbinding with separately learned keys based on MBAT , which amounts to a matrix multiplication, we extract the individual processed information, which is then passed through a final fully-connected layer to produce logits for classification. In the following, we introduce our three main contributions that lead to a highly accurate MIMOConv.

Augmenting CNNs with locality-preserving variable bindings.We embrace a principled and transparent binding mechanism from HRR. Accordingly, binding is performed using circular convolution with a binding key of dimension \(D\), drawn from an i.i.d. Gaussian distribution with zero mean and \(1/D\) variance. Instead of convolving the flattened image tensor, we repeatedly apply circular convolution between the binding key and each pixel volume spanning across the feature maps (\(D 1 1\)). This binding operation, which we call _position-wise HRR_ (PWHRR), is translation equivariant and maintains locality, an essential property for subsequent layers with limited receptive fields. More concretely, binding and unbinding are performed as

\[(a^{(k)} x^{(k)})_{:,w,h} =a^{(k)}*x^{(k)}_{:,w,h}\] (5) \[(^{(k)}})_{:,w,h} =^{(k)} h_{:,w,h},\] (6)

with image tensors \(x^{(k)}^{D W H}\), hidden representation \(h^{D^{} W H}\), binding key \(a^{(k)}^{D}\) and unbinding key \(^{(k)}^{D^{} D^{}}\). Here, \(D,D^{},W,\) and \(H\) denote the hidden dimension at binding, the hidden dimension at unbinding (generally differs from \(D\)), image width, and image height, respectively. \(*\) is the circular convolution, \(\) the matrix multiplication, and \(k\) indexes the superposition channel. Unbinding is applied after the global (average) pooling to reduce computational costs. The binding keys can be either learned or fixed during training (see ablation study in Appendix E).

Embracing high dimensional embeddings.According to the Blessing of Dimensionality (see Appendix A), random vectors quickly become quasi-orthogonal as their dimension increases. To reduce interference between protected channels, we increase the number of feature maps by adopting Wide Residual Networks , the most commonly used CNN architecture to achieve state-of-the-art accuracy on CIFAR100 . The input tensors are passed individually through the first convolutional layer before being superposed in a suitably high dimensional space. We set the number of feature maps after the first convolutional layer to \(D\)=64. This is 4\(\) more than the standard Wide-ResNet-28 , which results in improved training stability at a marginally higher compute cost (see Section 5.1).

Figure 2: MIMOConv configured with \(N\)=\(3\) channels. The input images are passed individually through the first convolutional layer before binding each feature value with a channel-specific high-dimensional key. The key-value pairs are superposed yielding a dimensionality-preserving composition and passed through the rest of the CNN layers. The output is unbound with corresponding keys, and the unbound representations are classified separately with a shared fully-connected layer.

Encouraging isometric layers.We aim to preserve the quasi-orthogonality of our protected channels as the superposition is passed through many network layers. To that end, residual connections are used and each subfunction \(g_{}\) of type (strided) spatial convolution or activation function is made approximately inner-product preserving, i.e.,

\[ g_{}(x),g_{}(y) x,y.\] (7)

Inspired by , we deploy a regularization to the CNN weights and use a parametric ReLU  activation function, a learnable affine combination between identity and ReLU. Those adjustments lead to a near-isometric network. The regularization for the individual CNN layers is determined by

\[L(W) =Conv(W,W)-^{C_{o}}_{F}^{2}  ^{C_{o}}_{;,:,j,l} =I_{C_{o} C_{o}}_{j,l= },\] (8) \[L(W^{T}) =Conv(W^{T},W^{T})-^{C_{i}} _{F}^{2}  ^{C_{i}}_{;,:,j,l} =I_{C_{i} C_{i}}_{j,l= },\] (9)

with \(\) as hyperparameter. We use \(L(W)\) if \(C_{i}>C_{o}\), else \(L(W^{T})\). See Appendix B for more details.

## 4 MIMOFormer

This section presents MIMOFormer, which applies the principles of computation in superposition to dot-product self-attention . Figure 3 shows a MIMOFormer layer with four protected channels, consisting of a single-head2 attention block, a concatenation, a linear layer, an MLP, and a skip connection.

Merely superposing protected attention keys3 and queries does not yield the desired result. As discussed in Appendix F, with scalar attention scores between pairs of tokens, vanilla dot-product attention irreversibly combines attention scores of separate protected channels, effectively blurring the attention weights. By building instead on linear Transformers , attention scores are not collapsed to scalars, thus enabling computation in superposition.

Despite being compatible with other linear transformers (such as DPFP ), for concreteness we discuss changes to the Performer's FAVOR+ attention block . Enabling computation in superposition, we label the block as FAVOR+S. Given attention keys \((k_{j})_{j=1}^{L}\), queries \((q_{i})_{i=1}^{L}\), and values \((v_{j})_{j=1}^{L}\), FAVOR+ estimates dot-product attention at sequence index \(i\) through

\[o_{i}=_{j=1}^{L}v_{j} k_{j},q_{i}/ }{_{l=1}^{L} k_{l},q_{i}/ }}_{j=1}^{L}v_{j}(k_{ j})^{T}}_{A}(q_{i}),\] (10)

where \(:^{D}^{R}_{+}\) approximates the softmax kernel \(( k_{j},q_{i}/)\) as an explicit inner product. Since computing \(\) has a computational complexity of \((DR)\), the construction of \(A^{D R}\) takes \((LDR)\). Equally, multiplying \(A(q_{i})\)\( i\) takes \((LDR)\). Thus, FAVOR+ breaks the quadratic dependence on sequence length \(L\) of attention. The denominator \(B_{i}\) is discussed in Appendix C.

Figure 3: MIMOFormer layer applying computation in superposition to single-head FAVOR+S attention and to the MLP. This example passes four channels (\(N\)-\(M\)=2.2=4) to the FAVOR+S attention (see Eq. (19)). The individual outputs are retrieved by unbinding after the MLP. The skip connection superposes the individual inputs for alignment, using the same protection keys as in unbinding.

Our extension, FAVOR+S, computes attention in superposition, yielding a square-root speedup in the number of protected channels. It encodes them in an \(M N\) grid, distributing the computational burden among the setup of the value-key matrix \(A\) and its product with \((q_{i})\). Importantly, in the limit of high dimensional projections \(D\) our mechanism converges to exact self-attention, completely separating the protected channels from one another. In the following, we assume the token values \(_{j}\), keys \(_{j}\), and queries \(_{j}\) to be in protected subspaces:

\[v_{j}^{(m,n)}:=_{j}^{(m,n)} a^{(m,n)}, k_{j}^{(m,n)}:= _{j}^{(m,n)} a^{(m,n)}, q_{j}^{(m,n)}:=_{j} ^{(m,n)} a^{(m,n)},\] (11)

where \(a^{(m,n)}\) are i.i.d. bipolar vectors of Rademachers  and \((m,n)\) denotes a channel.

MIMOFormer benefits from the low time complexity (\((D)\)) of the Hadamard product, especially since binding and unbinding are performed in every MIMOFormer layer. Our derivations rely on two estimates:

\[(k)^{T}(q)}{{}}  k,q/_{w=1}^{N}k_{j}^{ (u,w)},\ _{t=1}^{M}q_{i}^{(t,n)}}{{ }}^{(u,n)},\ q_{i}^{(u,n)}}_{}\] (12)

The approximation \(P\), which improves with increasing \(R=((_{i}))\), is due to FAVOR+ and is quantified in . On the other hand, the approximation \(H\) follows from:

**Inter-channel distortion.**_The probability that inter-channel attention distorts the intended signal of the dot-product by a factor outside \([1-,1+]\) has various upper bounds, most notably decaying exponentially w.r.t. \(D^{2}^{2}((_{j}^{(u,n)},_{i}^{(u,n)})) /(NM-1)^{2}\). See Appendix D for the full theorem._

### FAVOR+S: Computing self-attention in superposition

We first discuss separately how to use a one-dimensional grid to carry out either the multiplication (\(\)) or the construction of \(A\) in superposition. Finally, the integration into a 2D grid will be shown.

Placing multiple queries in superposition.We set up channels \(1,,M\) by simultaneously generating a superposition in the construction of \(A_{s}\) and of the queries to be applied. To avoid inter-channel attention we superpose value-key tensor products, i.e., we do not construct tensor products between superposed values and superposed keys:

\[S_{i}= ^{L}_{u=1}^{M}v_{j}^{(u)}\ (k_{j}^{(u)})^{T}]}_{A_{s}}\ (_{t=1}^{M}q_{i}^{(t)})= _{j=1}^{L}_{u=1}^{M}v_{j}^{(u)}\ (k_{j}^{(u)})^{T}\ (_{t=1}^{M}q_{i}^{(t)}) \] (13) \[}{{}} _{j=1}^{L}_{u=1}^{M}v_{j}^{(u)}\ ( k_{j}^{(u)},\ _{t=1}^{M}q_{i}^{(t)} /)}{{}}_{j=1}^{L} _{u=1}^{M}v_{j}^{(u)}\ ( k_{j}^{(u)},\ q_{i}^{(u)} /)\] (14) \[= _{u=1}^{M}^{L}v_{j}^{(u)}\ ( k_{j}^{(u)},\ q_{i}^{(u)} /)}_{}.\] (15)

We obtain a superposition of bound output values; hence, the cost of computing \(A(q_{i})\) for all \(i\) is amortized across channels. However, the construction complexity of \(A_{s}\) is increased \(M\)-fold to \((LDR M)\), hence the complexity per protected channel remains at \((LDR)\).

Constructing value-key tensor products in superposition.Next, we demonstrate a value-key tensor product (\(A_{s}\)) shared across all channels, but with a mere \((LD(R+N))\) setup complexity. In \((LND)\) we compute \(_{q=1}^{N}v_{j}^{(q)}\) and \(_{w=1}^{N}k_{j}^{(w)}\) for all \(j\). These are then (re)used to build \(A_{s}\).

\[S_{i}^{(n)}= ^{L}_{q=1}^{N}v_{j}^{(q)} (_{w=1}^{N}k_{j}^{(w)})^{T}]}_{A_{s}}(q_{i}^{(n )})=_{j=1}^{L}_{q=1}^{N}v_{j}^{(q)}(_{w=1}^{N}k_{j}^{ (w)})^{T}(q_{i}^{(n)})\] (16)\[}{{}} _{j=1}^{L}_{y=1}^{N}v_{j}^{(q)}(_{w=1}^{N}k_ {j}^{(w)},\ q_{i}^{(n)})/}{{}}_{j=1}^{L}_{q=1}^{N}v_{j}^{(q)} (k_{j}^{(n)},\ q_{i}^{(n)})/\] (17) \[= ^{L}v_{j}^{(n)}(k_{j}^{(n)},\ q_ {i}^{(n)})/}_{$ of channel $n$}}+_{j=1}^{L}v_{j}^{(q)}(k_{j}^{ (n)},\ q_{i}^{(n)})/}_{}.\] (18)

The output contains the \(n^{th}\) channel together with noise. The operation \(A_{s}(q_{i}^{(n)})\), which takes \((LDR)\), must be repeated \(N\) times to produce outputs for all \(N\) channels, causing a bottleneck.

Simultaneous superposition of queries and value-key tensor products using a 2D grid.Finally, we combine the two previously described approaches to encode the superposition channels in a 2D grid of size \(N M\). We multiply a constant matrix (\(A_{s}\)) with features derived from a superposition of queries to get the superposition vector \(S_{i}^{(n)}\)

\[S_{i}^{(n)}=_{j=1}^{L}_{u=1}^{M}(_{q=1}^ {N}v_{j}^{(u,q)})(_{w=1}^{N}k_{j}^{(u,w)})^{T}}_{$ in $(LMD(R+N))$}}^{M}q_{i}^{(t,n)})}_{ (LND(R+M))$}}.\] (19)

Computing the multiplication \(\)\( i,n\) takes \((LNDR)\). If we set \(M\)=\(N\), we can evaluate \(S_{i}^{(n)}\)\( i,n\) using only \((LNDR+LN^{2}D)\) instead of the usual \((LDR N^{2})\). Thus, one may achieve a speedup of \(((},R))\) compared to FAVOR+. Since \(R\) is normally in the hundreds , we can assume improvements of \((})\) for reasonably large \(N^{2}=M N\). Eq. (19) simplifies to:

\[S_{i}^{(n)}= _{j,u,q}v_{j}^{(u,q)}(_{w}k_{j}^{(u,w)})^{T} (_{t}q_{i}^{(t,n)})}{{}}_{j,u,q}v_{j}^{(u,q)} k_{j}^{(u,w)},\ _{t}q_{i}^{(t,n)}}{}\] (20) \[}{{}} _{j=1}^{L}_{u=1}^{M}_{q=1}^{N}v_{j}^{(u,q)}  k_{j}^{(u,n)},\ q_{i}^{(u,n)}/\] (21) \[= _{u=1}^{M}^{L}v_{j}^{(u,q)} ^{(u,n)},\ q_{i}^{(u,n)}}{}}_{ $ of channel $(u,n)$}}+_{i=1}^{L}v_{j}^{(u,q)} ^{(u,n)},\ q_{i}^{(u,n)}}{}}_{ }.\] (22)

### Integrating FAVOR+S into MIMOFormer

As is apparent in Eq. (19), the query superposition is along a different axis (\(M\)) than the key and value superpositions (\(N\)). The output of attention, however, is only superposed along a single axis (\(M\)). To be able to set up superpositions along both axes (\(M\) and \(N\)) at the next layer, we require all channels (i.e., keys, queries, and values) in separation, i.e., not superposed, at the interface between MIMOFormer layers. We present two variants of MIMOFormer with different speedups.

The first computes in superposition exclusively during the attention mechanism. The individual tokens of the channel (\(n,m\)) are directly retrieved from \(S_{i}^{(n)}\) by unbinding with the key \(^{(n,m)}=a^{(n,m)}\), and the remaining computational steps within FAVOR+S are performed separately.

The second (and faster) MIMOFormer instance additionally performs the concatenation, the linear layer, as well as the MLP in superposition (shown in Figure 3). Unlike in the first variant, the skip connection around the attention block must account for the introduced superposition. To allow a potential embedding dimension mismatch, we instantiate two different sets of randomly drawn bipolar keys: one for the skip connection and post-MLP unbinding, and one for FAVOR+S binding. All keys are frozen during training; it is up to the trainable weights in the linear layer after concatenation to find the relationship between the binding and unbinding keys.

The function \(\) in the self-attention block consists of an \(R\)=256 dimensional projection and a ReLU activation . Appendix C provides theoretical justification for using ReLU in \(\) and its benefits for MIMOFormer. Empirically, ReLU shows better numerical stability than unbiased softmax FAVOR+.

## 5 Empirical Results

This section evaluates the proposed MIMONets on various model architectures and benchmarks. Appendix E and Appendix F describe the experimental setup for MIMOConv and MIMONets, respectively. All experiments are repeated five times with a different random seed. We report the mean and standard deviations of accuracy to account for variability in training.

### MIMOConv

**CIFAR10 and CIFAR100.** Our main baseline, which we adapt to MIMOConv, is a reproduced WideResNet-28-10 , i.e., a 28-layer CNN with the number of feature maps of each convolutional layer enlarged by \(10\). Moreover, as a stronger baseline, we include the isometry regularization in the training of WideResNet-28-10, and call the resulting network WideIsoNet-28-10. Both baselines demand 5.251 GMACs (Giga multiply-accumulate operations) per sample. MIMOConv's inference complexity per sample is \(5.335\) GMACs for \(N\)=1, \(2.667\) GMACs for \(N\)=2, and \(1.334\) GMACs for \(N\)=4; hence, we get a \(\)\(N\) speedup despite not accelerating the first and last layer. See Appendix E.

Table 1 shows the accuracy of the static MIMOConv, which is exclusively trained to support either 1, 2, or 4 channels. The MIMOConv with one channel (\(N\)=1) outperforms both baselines, which may be attributed to regularizing effects of the key-value binding. MIMOConv with \(N\)=2 channels still outperforms WideResNet-28-10, while reducing the inference complexity by 2\(\). The complexity can be further reduced by increasing the number of superpositions to \(N\)=4 at a slight accuracy drop of \(\)3.18%, compared to WideResNet-28-10.

Next, we evaluate the dynamic partitioning of the superposition channels to select a speed-accuracy operating point instantaneously, which is a main feature of our approach and sets it apart from other static approaches that opt for a fixed performance point like model downsizing, quantization aware training, and pruning (see Appendix A for a discussion). We set up a model with four channels, but evaluate its performance in different configurations: a fast (4 inputs/pass), a normal (2 inputs/pass), and a slow mode (1 input/pass). The fast mode maps each input to one channel; the medium mode distributes two inputs over pairs of channels; and the slow mode uses all channels for the same input. The models are trained on 80% of the batches in fast mode and on 20% of the batches in slow mode. Appendix E provides more details on the trade-off between fast and slow mode training. As Table 1 shows, a single dynamic model can seamlessly switch between operation points while maintaining a high accuracy compared to the static models (\(\)\(1.82\%\) drop).

The detailed ablation study in Appendix E makes the following findings: (1) isometry regularization improves accuracy for any number of channels; (2) training MIMOConv for more epochs closes the performance gap to the single-input baseline; (3) an appropriate number of feature maps (32 or 64) in the first layer stabilizes training; and (4) the binding keys can be frozen during training without loss (whereas unbinding keys are never frozen).

    &  &  \\  \# inputs/pass & 1 & 2 & 4 & 1 & 2 & 4 \\  WideResNet-28-10 & \(96.82^{ 0.06}\) & n.a. & n.a. & \(81.62^{ 0.07}\) & n.a. & n.a. \\ WideIsoNet-28-10 & \(97.31^{ 0.11}\) & n.a. & n.a. & \(82.38^{ 0.20}\) & n.a. & n.a. \\  MIMOConv static (\(N\)=1) & \(97.49^{ 0.08}\) & n.a. & n.a. & \(83.19^{ 0.17}\) & n.a. & n.a. \\ MIMOConv static (\(N\)=2) & n.a. & \(96.93^{ 0.13}\) & n.a. & n.a. & \(82.30^{ 0.19}\) & n.a. \\ MIMOConv static (\(N\)=4) & n.a. & n.a. & \(95.58^{ 0.23}\) & n.a. & n.a. & \(78.44^{ 0.30}\) \\  MIMOConv dynamic (\(N\)=1–4) & \(97.13^{ 0.11}\) & \(96.41^{ 0.14}\) & \(95.43^{ 0.07}\) & \(82.52^{ 0.09}\) & \(80.48^{ 0.08}\) & \(78.19^{ 0.10}\) \\   

Table 1: Average accuracy (%) of WideResNet-28-10 variants and our MIMOConv. Static models are trained to process \(N\) inputs in one pass, speeding up inference by \(N\). Dynamic models are trained with a variable number of inputs (\(N\)=1–4), and can process a variable number of inputs per pass. We report the average accuracy \(\) the standard deviation over five runs with different seeds.

MNIST and SVHN.Figure 4 compares MIMOConv with DataMux  on the MNIST dataset. Even with a trivial downsizing for fair comparison from a 28-layer very-wide (10\(\)) ResNet to a 10-layer narrow (1\(\)) network, MIMOConv scales much better to high superposition channels (\(N\)) than DataMUX does. Indeed, our model shows an accuracy of \(80.4\%\) against their \(52.9\%\) in case of \(N\)=\(16\) superposition channels (highest number of channels reported by DataMUX for vision tasks), despite being computationally cheaper (\(0.47\) MMAC/s vs. \(0.65\) MMAC/s). Also, DataMux's binding overhead results in a mere \(1.35\) reduction in MACs compared to our \(10.9\) as \(N\) goes from \(1\) to \(16\). Ergo, our method scales Figure 4: Classification accuracy (%) on MNIST better in accuracy and throughput as \(N\) increases. for downsized model.

Finally, we tested MIMOConv on the SVHN dataset. Despite limited hyperparameter tuning, MIMOConv achieves a high accuracy of \(97.17\%\) (\(N\)=1), and can maintain its performance with larger superpositions (\(97.05\%\) and \(96.84\%\) for \(N\)=2 and \(N\)=4, respectively).

### MIMOFormer

**LRA.** We evaluate MIMOFormer on five tasks from LRA , and compare against the vanilla Transformer  and the Performer  using FAVOR+ attention with ReLU projection. Moreover, we also consider wide Transformer variants , consisting of only one layer but as many heads as their deep counterparts. Task-specific architectures and training hyperparameters are kept the same for the Performer and the MIMOFormer (see Appendix F).

Owing to an improved training setup, our replicated deep and wide Performer baselines substantially outperform the results reported in  (see Table 2). Moreover, MIMOFormer enables accurate computation in superposition for both deep and wide attention models. The performance drop is less pronounced in wide models (only \(1.07\%\) drop compared to Performer with \(N\)=\(2\), att.), which may be attributed to the larger number of heads, increasing the effective dimension (\(D_{ tot}=H D_{ head}\)).

When computing both attention and the MLP in superposition (att.+MLP), we observe better scaling (in \(N\)) for wide models. Also, MIMOFormer reduces the gap to the baseline as the number of epochs increases (see Appendix F).

   &  &  &  &  &  &  \\ 
**Deep models** & \(L\)=\(6\), \(H\)=\(8\) & \(L\)=\(6\), \(H\)= \(8\) & \(L\)=\(4\), \(H\)= \(4\) & \(L\)=\(3\), \(H\)= \(4\) & \(L\)=\(4\), \(H\)= \(8\) & \\  Transformer  & \(36.37\) & \(64.27\) & \(57.46\) & \(42.44\) & \(71.40\) & \(53.39\) & \\ Performer  & \(18.01\) & \(65.40\) & \(53.82\) & \(42.77\) & \(77.05\) & \(51.41\) & \\ Performer (reproduced) & \(38.94^{ 0.23}\) & \(65.67^{ 0.31}\) & \(51.58^{ 0.18}\) & \(40.14^{ 0.86}\) & \(78.2^{ 0.78}\) & \(60.04^{ 0.47}\) & \\ MIMOFormer (N=2, att.) & \(38.08^{ 0.21}\) & \(65.00^{ 0.28}\) & \(79.37^{ 0.81}\) & \(38.2^{ 0.63}\) & \(72.36^{ 0.54}\) & \(58.61^{ 0.49}\) & \\ MIMOFormer (N=2, att.-MLP) & \(37.65^{ 0.33}\) & \(64.39^{ 0.26}\) & \(76.02^{ 0.27}\) & \(38.55^{ 0.55}\) & \(67.98^{ 0.47}\) & \(55.98^{ 0.37}\) & \\ MIMOFormer (N=4, att.) & \(37.22^{ 0.33}\) & \(64.59^{ 0.14}\) & \(60.09^{ 0.96}\) & \(28.16^{ 0.08}\) & \(55.50^{ 0.49}\) & \(49.29^{ 2.91}\) & \\ MIMOFormer (N=4, att.)* & \(37.64^{ 0.73}\) & \(64.46^{ 0.15}\) & \(74.38^{ 0.82}\) & \(30.52^{ 0.77}\) & \(67.10^{ 0.45}\) & \(54.82^{ 0.58}\) & \\ MIMOFormer (N=4, att.+MLP) & \(17.74^{ 0.63}\) & \(60.71^{ 1.51}\) & \(72.20^{ 0.28}\) & \(24.01^{ 0.47}\) & \(50.33^{ 0.16}\) & \(45.00^{ 1.34}\) & \\ 
**Wide models** & \(L\)=\(1\), \(H\)=\(48\) & \(L\)=\(1\), \(H\)=\(48\) & \(L\)=\(1\), \(H\)=\(16\) & \(L\)=\(1\), \(H\)=\(12\) & \(L\)=\(1\), \(H\)=\(32\) & \\  Performer (reproduced) & \(39.40^{ 0.51}\) & \(65.73^{ 0.32}\) & \(38.67^{ 0.45}\) & \(41.67^{ 0.44}\) & \(74.11^{ 0.33}\) & \(60.93^{ 0.37}\) \\ MIMOFormer (N=2, att.) & \(38.90^{ 0.53}\) & \(65.39^{ 0.51}\) & \(81.27^{ 0.28}\) & \(40.2^{ 0.21}\) & \(73.51^{ 0To stabilize training in the case of \(N\)=4, we implemented a curriculum training procedure where the number of superpositions is reduced to \(N\)'=\(N/2\) during a warmup phase (1/6th of the training steps), improving the average accuracy of MIMOFormer in both wide and deep models.

Comparing against a reproduced DataMUX , MIMOFormer (att.) outperforms it on ListOps (38.08% vs. 30.54% accuracy) when using models of similar size and \(N\)=2, see Appendix F.

Synthetic sequence modeling.Table 3 reports the accuracy on two synthetic sequence modeling tasks, which Transformer alternatives such as S4  have difficulties solving . On these more nuanced NLP tasks, the accuracy of DataMUX  drops to \(20.04\%\) and \(6.06\%\) for \(N\)=2 despite significant efforts in training, while MIMOFormer, at a score of \(96.52\%\) and \(99.40\%\) respectively, succeeds. We attribute this difference in performance to attention score blurring in DataMux, discussed in Appendix F. Contrastingly, our method converges to exact attention without blurring. It is versatile and can be adjusted to other linear Transformers such as DPFP , achieving a score of \(93.64\%\) and \(98.56\%\).

## 6 Related Work

So far, superposition principles have been applied in order to store the weights of multiple models in a single neural network , to circumvent catastrophic forgetting in continual learning , and to render symbolic reasoning tractable . To address privacy concerns when running remote inference, single inputs were bound with random channels to implement pseudo-encryption . Recently in , HRR was used to define an unconventional version of self-attention, whose attention scores are processed to a diagonal matrix. The value vectors are scaled according to their importance in the sequence instead of being combined in a weighted sum. In contrast to us, none of these works superpose multiple inputs into a data structure to speed up computation.

In , an ensemble of CNN models was fit into one network. However, by only broadcasting a single input over the channels and by averaging all the outputs, this approach collapses to a single-input-single-output (SISO) network. On the contrary, we explore using protected channels for _different_ inputs at inference, resulting in an actual multiple-input-multiple-output (MIMO) network.

There has also been a line of work to accelerate Transformers using inputs in superposition . DataMux  claims to retain high performance for language understanding tasks, even when using up to \(40\) inputs in superposition. However, none of the reported tasks require attention layers at all . In Section 5.2 we show failure of their method when actual attention is required (see also Appendix F). MUX-PLMs  improves on DataMux with contextual binding and replaces token prefixes with unbinding keys, but does not address the blurry attention mechanism. In contrast to DataMUX and MUX-PLMs, our work approximates true attention and our theoretical derivations show convergence to actual dot-product attention as the dimension of attention projections increases, giving us an even stronger case for applicability to large language models.

## 7 Conclusion

We present MIMONets that simultaneously process multiple inputs by performing computation in superposition. MIMONets bind arbitrary inputs with high-dimensional keys, which projects them to orthogonal subspaces that, together with near-isometric subfunctions, guarantee low interference through all nonlinear layers. Unbinding with (learned) keys can safely retrieve information on individual channels. We provide two MIMONets instances, MIMOConv and MIMOFormer, that show the effectiveness of computation in superposition through two dominant operations in neural network architectures: convolution and attention. Further investigations could explore the MIMOCapability of architectures that contain additional nonlinearities (e.g., max-pooling) and use different input modalities. MIMONets could be suitable candidates to accelerate dynamically and on-demand the inference of foundation models .

   Architecture & Attention &  Associative \\ recall  \\  & 
 Indaction \\ head  \\  \\  Transformer & Softmax & \(98.48^{1.87}\) & \(100^{10.0}\) \\ Performance & FAVOR+ & \(96.32^{6.26}\) & \(31.58^{13.67}\) \\  MIMOFormer (N=2, att.) & FAVOR+ & \(96.52^{2.79}\) & \(99.40^{1.03}\) \\ MIMOFormer (N=2, att.) & DPFP  & \(93.64^{12.66}\) & \(98.56^{10.86}\) \\ DataMUX (N=2)  & Softmax & \(20.04^{1.72}\) & \(6.06^{62.24}\) \\   

Table 3: Accuracy (%) on synthetic sequence modelling.