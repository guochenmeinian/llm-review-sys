# Jigsaw: Learning to Assemble Multiple

Fractured Objects

 Jiaxin Lu   Yifan Sun   Qixing Huang

Department of Computer Science

University of Texas at Austin

{lujiaxin, yifansun12}@utexas.edu  huangqx@cs.utexas.edu

Equal Contribution

###### Abstract

Automated assembly of 3D fractures is essential in orthopedics, archaeology, and our daily life. This paper presents Jigsaw, a novel framework for assembling physically broken 3D objects from multiple pieces. Our approach leverages hierarchical features of global and local geometry to match and align the fracture surfaces. Our framework consists of four components: (1) front-end point feature extractor with attention layers, (2) surface segmentation to separate fracture and original parts, (3) multi-parts matching to find correspondences among fracture surface points, and (4) robust global alignment to recover the global poses of the pieces. We show how to jointly learn segmentation and matching and seamlessly integrate feature matching and rigidity constraints. We evaluate Jigsaw on the Breaking Bad dataset and achieve superior performance compared to state-of-the-art methods. Our method also generalizes well to diverse fracture modes, objects, and unseen instances. To the best of our knowledge, this is the first learning-based method designed specifically for 3D fracture assembly over multiple pieces. Our code is available at https://jiaxin-lu.github.io/Jigsaw/.

## 1 Introduction

The task of assembling 3D fractures has extensive applications across numerous fields. For instance, orthopedic doctors need to realign dislocated bone fragments, and subsequently create bone plates and screws to heal compound fractures. Archaeologists, on the other hand, need to recreate the original shape and functionality of unearthed artifacts by assembling the fractures. These procedures demand significant expertise, are prone to errors, and can be tedious. Even in the context of daily life, furniture assembly can be a challenging and exhausting task that requires an understanding of mechanical structures and component matching. In the past two decades, many efforts attempted to address the challenge of automatic assembly. Traditional methods apply hand-crafted geometric features to detect the fracture surfaces and optimize pairwise matching among these surfaces [1; 2]. Recently the availability of large scale 3D datasets [3; 4; 5; 6] have boosted learning based frameworks for solving 3D assembly tasks. Semantic-aware methods [7; 8; 9; 10; 11; 12] target at assembly from semantically segmented parts and predict semantic labels as matching priors. Geometry based methods [13; 14; 15] leverage fracture shapes and continuity of textures in the procedure of piece matching.

However, in the context of fracture assembly for restoring broken objects, there is no guarantee that individual pieces will retain semantic meanings. Texture information may also be either non-accessible or lacking, such as on glass bottles or worn artifacts. This calls for a general 3D assembly solver that utilizes hierarchical features of both the global piece surfaces and local geometry shapes of fractures. In this work, we introduce a **J**oint Learning of **S**egmentation and **A**lignment **F**rame**work(**Jigsaw**), for assembling objects damaged or shattered due to physical impact or force. Given a set of fractured pieces represented as point clouds without texture, our method recovers the global pose of each piece to restore the underlying object.

Our Jigsaw framework consists of four parts: (1) A front-end feature extractor with self-attention and cross-attention layers for local geometric feature extraction. (2) Categorize the surface of each fractured piece into two segments: the indiscernible fracture surface and the visible original surface. (3) A novel formulation for multi-piece assembly that learns a bipartite matching among points on the fracture surface from all pieces. (4) Recover pairwise pose based on the learned correspondences and perform robust global alignment to compute the global poses of all pieces. Key features of Jigsaw are that 1) it learns two correlated tasks, i.e., segmentation and matching among all involving pieces, jointly, and 2) it seamlessly integrates feature matching and the rigidity constraint among consistent features, We evaluate the effectiveness of our framework on Breaking Bad . Experimental results demonstrate the effectiveness of our method in surface segmentation, fracture point matching, and significantly outperforming state-of-the-art methods[8; 16]. The main contribution includes the following:

* We propose Jigsaw, a novel joint learning framework tailored for multi-part fracture assembly. Our approach embodies an attention-based feature extractor network to accurately capture local geometry features of each point. Additionally, we introduce a primal-dual descriptor that effectively captures viewpoint-dependent characteristics for surface matching.
* Jigsaw incorporates fracture point segmentation to capture intrinsic features, employs a novel multi-part matching formulation to establish automatic piece positioning within one object, and utilizes global alignment for accurate global pose alignment.
* Experimental evaluation on the multi-part assembly Breaking Bad dataset demonstrates the superior performance of Jigsaw compared to baseline models, showcasing its strong generalization ability to unseen objects. We further highlight the limitations of baseline models that rely on global features, which we argue are too abstract for this task and lack generalizability.
* To the best of our knowledge, Jigsaw is the first learning-based method specifically designed for the assembly of multiple pieces from physically broken 3D objects.

## 2 Related Works

**Feature matching**. Early works apply hand-crafted features over fracture surfaces for fracture matching between different pieces [17; 1; 2; 18]. These features are also used to identify the fractured part from the entire surface [17; 1; 2]. However, hand-crafted features are in lack of robustness for assembly tasks over large datasets due to different materials and fracture patterns of objects. In recent years, deep learning methods have gained significant traction in matching problems. Methods utilizing CNN, GNN, and attentions have found successful applications in various domains, such as image registration [19; 20] and graph or multi-graph matching on images [21; 22; 23; 24; 25]. While their efficacy in these scenarios is noteworthy, the majority of these methods predominantly focus on simpler settings and have not adequately addressed the challenges in multi-part 3D fracture assembly.

**Part assembly**. Semantic-aware learning methods have been highly successful in the task of part assembly. [9; 11] are designed for assembling specific CAD mechanics. For categorical everyday objects, [26; 10; 27; 12; 28] generate the missing parts based on the accumulated shape prior to completing the entire object, which can result in shape distortion from the input parts. [8; 7] apply graph learning to predict part labels and assembly orders. All of these methods require the input objects decomposed in a semantically consistent way and need specific training for each category of objects. Fracture assembly poses unique challenges due to the variety of objects and the lack of semantic meanings associated with individual pieces, adding to the complexity of the task.

**Geometry based learning methods**. Recent approaches have aimed to capture geometry information using deep features for piece matching. [13; 15] combine local geometry with textures for feature generation, but may suffer when texture information is not accessible, as in most point cloud representations.  apply a transformer for local shape encoding and an adversarial network to help generate a plausible assembly of two pieces. However, for multiple fracture assembly, objects can break into 5 pieces or more, with the largest piece smaller than half of the original object. Under this setting, training an adversarial network to evaluate the quality of assembly becomes less effective.

**Low-overlap 3D registration**. Another relevant research field is low-overlap 3D registration. Recent works have shown the potential of data-driven methods in registration tasks with approximately 30% overlap [29; 16; 30]. [16; 30] learn a classifier to determine the overlapped sections and predict inter-piece point matching inside the sections, while  using object semantic to guide registration. The fracture assembly task can be viewed as an even more extreme case of registration, where the overlap between pieces can fall below 4%.

## 3 Joint learning framework for 3D fracture assembly

Given a set of fractured pieces \(=\{P_{1},P_{2},,P_{n}\}\) represented as point clouds uniformly distributed on the surface, our goal is to recover the 6-DoF pose \(\{T_{1},T_{2}, T_{n}\}\) in \(SE(3)\) for each piece and restore the underlying object \(O=T_{1}(P_{1}) T_{2}(P_{2}) T_{n}(P_{n})\), where \(T_{i}(),1 i n\) is the operator to recover \(P_{i}\) to its original position by transformation \(T_{i}\). In the fracture assembly setting, the object \(O\) is a rigid body, and the pieces are the result of physical cracking or breakage without any deformation. Also, no pieces are lost, which ensures that the restored pieces can approximately reconstruct the entire object \(O\).

To handle this challenge, we propose Jigsaw, a learning-based framework that jointly optimizes surface segmentation and fracture matching among all pieces of the object. The entire assembly network consists of a segmentation module and a matching module that shares a front-end feature extractor. The segmentation module uses only the intrinsic shape information of each piece to separate the fracture surface from the original surface. The matching module exploits the primal dual descriptor of the affinity metric to propagate mutual information among all pieces and establish the matching between fracture points (that is, points on the fracture surface) of different pieces via Sinkhorn . With the fracture point matching predicted by the network, we recover the pairwise transformations and perform global alignment with standard approaches. The complete pipeline of our framework is shown in Fig. 1. Note that this design ensures that segmentation and matching are performed jointly. In the subsequent part of this section, we will first introduce the front-end extractor, then delve into the details of the segmentation module, followed by the multi-part matching module and post-processing for pose recovery.

### Front-end Feature Extractor

In contrast to previous methods [33; 4] that utilize global piece-wise descriptors for assembly, we focus on geometric features. As illustrated in Figure 7 of the PointNet paper , a global descriptor remains the same as long as the piece lies between the learned critical point set and the upper-bound

Figure 1: Overall pipeline for Jigsaw (mesh used only for visualization). The method consists of four parts: front-end feature extractor, surface segmentation, multi-part matching, and global fracture alignment. In the front-end feature extraction, we use a multi-scale grouping PointNet++ , and one self-attention layer followed by one cross-attention layer to extract features for each point. Surface segmentation is used to locate all fracture points in one broken object, and multi-part matching finds correspondences of fracture points among multiple pieces. The matching results will be used for pairwise pose recovery and joint alignment to retrieve an assembled object. More detail about each part will be discussed in Section 3.

point set. This indicates that global descriptors are coarse and insufficient to represent the intricate geometry of the fracture surface, which is crucial for our task. To address this limitation, we employ a multi-scale grouping PointNet++  as the backbone of our feature extractor to capture local geometry features, denoted as \(_{p}^{D}\) from each point \(p P_{i}\).

Furthermore, We emphasize the significance of relative positional information between points and pieces for identifying the non-smooth fracture surfaces, enforcing rigidity during matching, and accurately placing the pieces. To facilitate the integration of such intra-piece and inter-piece information, we leverage transformer layers. Specifically, we introduce both self-attention and cross-attention layers as tools to reason about the relative information between points.

For the self-attention within a piece, we employ a single point transformer layer . The self-attention mechanism is defined as follows:

\[_{p}^{s}=_{_{q}(p)}( ((W_{Q}^{s}_{p}-W_{K}^{s}_{q}+^{ })))(W_{V}^{s}_{q}+^{})\] (1)

Here, \(W_{Q}^{s},W_{K}^{s},W_{V}^{s}^{D D}\) are weights for query, key, value in the attention layer, \(^{}\) represents the positional encoding for point \(p_{i}\), obtained using a Multi-Layer Perceptron (MLP). Unlike the standard dot-product attention layer, it employs vector weights: \(\) is a mapping function that produces the weight vector, \(()\) normalizes the weights, and \(\) denotes element-wise multiplication. \((p) P_{i}\) represents the neighborhood of point \(p\), calculated using \(k\)-nearest neighbors for local feature aggregation.

For cross-attention, we use standard multi-head attention with position-wise feed forward over the entire object to facilitate the communication of local features among different pieces. Let \(^{s}^{N D}\) pack all the point features of one object after the self-attention, and \(^{c}^{N D}\) denote the point features produced by cross-attention,

\[^{c}=(W_{O}^{m}((_{1}, ,_{h}))),_{i}=(W_{Q\;i}^{m} ^{s},W_{K\;i}^{m}^{s},W_{Q\;i}^{m}^{s})\] (2) \[(Q,K,V)=(}{ }})V\]

Here, \(W_{Q\;i}^{m},W_{K\;i}^{m},W_{V\;i}^{m}^{D d_{h}},W_{O}^{m} ^{hd_{h} D}\) denote the weights for projection. The function \(()\) consists of two linear functions with ReLU activation in between, followed by a LayerNorm as normalization.

### Surface segmentation

The fracture assembly problem can be viewed as a special case of the 3D registration problem, where the overlapping between adjacent pieces only lies in the fracture surface between them. Let \(P_{i}^{f} P_{i}\) be the subset of points on fracture surfaces of \(P_{i}\) and let \(P_{ij} P_{i}^{f}\) denote the subset of points on the fracture surface between \(P_{i}\) and \(P_{j}\) for arbitrary two pieces \(P_{i},P_{j}\). For pieces \(P_{i}\) and \(P_{j}\) adjacent in their original pose \(T_{i}(P_{i})\) and \(T_{j}(p_{j})\), we have \(P_{ij},P_{ji}\). Under the assumption that the point clouds are uniformly distributed, we can approximate the relative pose \(T_{ij}^{}=T_{j}^{-1}T_{i}\) between \(P_{i},P_{j}\) with

\[T_{ij}^{}=*{argmin}_{T_{ij} SE(3)}d(P_{ji},T_{ij}(P_ {ij})),\] (3)

where \(d(,)\) is some distance function between two point clouds. (3) becomes the standard formulation for point cloud registration with perfect prior for the overlapping. Before we can optimize (3) directly, we need to figure out the overlapping part \(P_{ij}\) and \(P_{ji}\) for each pair \((P_{i},P_{j})\). Although \(P_{ij}\) is dependent on both pieces, previous studies [17; 1; 2] have demonstrated that the segmentation of fracture surfaces \(P_{i}^{f}\) of \(P_{i}\) is an intrinsic property that can be inferred from the local shapes of each \(P_{i}\) individually. However, these methods require a continuous smooth surface to compute hand-crafted shape features for accurate classification. To capture local geometric properties under the discrete point cloud setting where surface normal and curvature are no more available, we introduce our deep surface segmentation module to handle the surface segmentation task.

The surface segmentation module can be viewed as a binary classifier of each point. Let \(c_{p}\) be the indicator function that determines whether a point \(p\) of a point cloud \(P\) is a fracture point. For each 3D model uniformly sampled as \(N=_{i=1}^{n}N_{i}\) points, the surface segmentation module takes the position of the points \(P_{i}^{N_{i} 3}\) of a piece \(P_{i}\) and predicts a confidence score \(c_{i}\) to segment a point \(p P_{i}\) into the fracture surface.

Our front-end feature extractor introduced in Section 3.1 has extracted local geometry feature \(_{p}^{D}\) for each point. Next, we use two MLP layers to reduce the number of channels to 1, followed by a sigmoid function to predict the confidence \(c_{p}\) for labeling \(p\) as a fracture point. We set the segmentation loss \(L_{}\) to be a negative log-likelihood loss, which is supervised by the ground truth label \(c_{p}\) for every point \(p\) as

\[_{}=-_{p O}c_{p}_{p}+(1-c_ {p})(1-_{p}).\] (4)

The ground truth label \(c_{p}\) for each point \(p P_{i}\) is constructed by examining its distance to its nearest neighbor in other parts:

\[c_{p}=1&Dis(p,(p, P_{i})), \\ 0&\] (5)

where \(Dis()\) is a distance function and \((,)\) is to find the nearest neighbour of one point in a point set.

Although the fraction of the fracture surface area may differ between objects, and the positive and negative samples in (4) may be unbalanced, we have found that adding two MLP layers after feature encoding help to yield good performance for the segmentation task. The segmentation module is able to accurately predict fracture points even in cases with a large number of pieces or very small fracture surfaces, and we leave the evaluation details of this module in the appendix A.

### Multi-part Matching

One key aspect of Jigsaw is its ability to combine multiple pieces. Traditional approaches to assembling pieces rely on pairwise matching, which involves assessing the compatibility of two parts, identifying corresponding points within them, and aligning those points. However, this method is prone to cumulative errors, and a single mistake can ruin the entire assembly task. In addition, matching small pieces with limited geometry information solely based on pairwise information is extremely challenging. Consequently, the pairwise information in the multipart fracture assembly dataset may not be comprehensive enough to capture the true matching possibilities between all the pieces involved in the assembly process. Even advanced low-overlap 3D registration methods like PREDATOR , which share a similar structure, have failed to handle assembly tasks effectively, as shown in Section 4.2. Thus, alternative approaches are needed to address the limitations of pairwise matching, and we introduce our multipart matching module.

Facilitated by the global fracture points of a segmented object in Section 3.2, we present a global view to match all its pieces simultaneously. We observe that each fracture surface should have one precise match within a broken object, which is a rule that applies specifically to the fracture piece assembly task. Therefore, we learn the matching among all pieces without specifying their pairwise relationship. This allows each fracture point to automatically find a similar counterpart on a different piece solely based on local geometry. Moreover, the correspondences highlight the assembly regions, avoiding the need for costly predictions of fine-grained pairwise overlapping areas.

**Primal-dual Descriptor.** Intuitively, when an object has been broken into two pieces by physical force, the two pieces should exhibit complementary geometry. Conventional feature representation is used to find similar geometry and, therefore, would match two identical surfaces, which becomes undesirable in the context of fracture assembly. With this concern, we propose the primal-dual descriptor, designed to capture the essence of complementary geometry (see Fig. 2).

Figure 2: Illustration of Primal-dual descriptor: The red region and points represent the target fragment piece and the points, respectively. The purple feature (primal descriptor) on the left learns the local convex shape of the piece, while the blue feature (dual descriptor) on the right captures the concavity observed from the outside. The primary and dual descriptors on both sides will be matched in the matching module.

Let \(\{}_{i}^{c}\}_{i=1}^{n_{c}}\) be the selected features of the fracture points extracted from the backbone network. These features encode the local geometry of the fracture surfaces. We apply MLP layers and a normalization layer to \(}_{i}^{c}\) and get the primal descriptor \(}_{i}^{p}\) and dual descriptor \(}_{i}^{d}\):

\[}_{i}^{p},}_{i}^{d}=((}_{i}^{c})).\] (6)

The primal-dual descriptor learns surface features that capture the characteristics of a local surface from both directions. It promotes the robustness and reliability of surface matching and avoids learning biased features based on a single viewing direction. We leave more detailed analysis to the appendix B.

**Affinity Metric.** Let \(}^{p},}^{d}^{ d}\) collect all the fracture points features extracted from descriptors, we compute the global affinity matrix \(M^{}\) and the respective doubly-stochastic matrix \(^{}\) as follows:

\[M=(}^{p^{}}A}^{d}}{ }),=(M),\] (7)

Here, \(A^{d d}\) consists of learnable affinity weights, and \(\) denotes the temperature parameter . We then apply the Sinkhorn layer , which is a differentiable operation, to obtain a doubly stochastic matrix \(^{}\). This matrix represents the soft matching predicted by the multipart matching module.

**Matching Loss.** Given the ground truth position of each part, we construct the ground truth matching matrix \(X^{gt}\{0,1\}^{}\). Here, \(x_{ij}^{gt}=1\) if and only if the \(j\)-th fracture point is the nearest neighbor of the \(i\)-th fracture point and both points belong to different pieces; otherwise, \(x_{ij}^{gt}=0\). To compute the matching loss, we employ the cross entropy between \(\) and \(X^{gt}\):

\[_{}=-}_{1 ij}x_{ij}^{ gt}_{ij}+(1-x_{ij}^{gt})(1-_{ij})\] (8)

With the ground truth matrix \(X^{gt}\) generated based on finding the nearest neighbor of each point, the matching loss will also enforce a global rigidity guidance that each node should be matched to its neighbor.

**Rigidity Loss.** As 3D fracture assembly is applied to rigid objects, we further enforce the rigidity loss over the pairs of matched pieces. Let \(_{ij}^{_{i}_{j}}\) be the submatrix of \(\) that indicates the likelihood between the fracture points on the piece \(P_{i}\) and \(P_{j}\). For a fracture point \(p\) in \(P_{i}\), \(_{ij}\) matches it to a point \(p^{}\) computed as the weighted average of all the matchable points in \(P_{j}\):

\[p^{}=_{ij}(p)P_{j}}{\|_{ij}(p)\|_{1}},\] (9)

where \(_{ij}(p)^{1_{j}}\) is the row in \(_{ij}\) that contains matching likelihood from \(p\) to \(P_{j}\). We optimize the transformation \(_{ij}\) from \(P_{i}\) to \(P_{j}\) by minimizing the weighted mean squared error between the matched fracture points

\[_{ij},}_{ij}=*{argmin}_{R,} _{p P_{i}}\|_{ij}(p)\|_{1}\|R(p)+-p^{}\|_{2}.\] (10)

where \(_{ij},_{ij}}\) are the rotation and translation part of \(_{ij}\) and \(R()\) is the rotation operator. (10) has a closed-form solution:

\[(U,,V^{})=(_{p P_{i}}\|_{ij}(p)\|p^{ }p^{}),\;_{ij}=UV^{},\;}_{ij}=- }\|_{ij}(p)\|_{1}(R(p)-p^{})}{ _{p P_{i}}\|_{ij}(p)\|_{1}}.\] (11)

The rigidity loss is computed as:

\[_{}=_{1 i,j n}_{ij},\; \;_{ij}=_{p P_{i}}\|_{ij}(p)\|_{1}\|_{ij}(p )+}_{ij}-p^{}\|_{2}.\] (12)To avoid numerical instability and improve efficiency in (11) during training, we compute \(_{ij}\) in each iteration without involving back-propagation and only set \(_{ij}\) as the learnable variable.

The loss for training is composed as:

\[=_{}+_{}+ _{}.\] (13)

**Multi-part Matching** With the doubly-stochastic matrix \(\), computing multi-part matching results becomes straightforward. Given the fact that the primal and dual feature represents the surface looked from a different viewpoint, they should be distinct and not assigned good confidence for matching. Therefore, we can directly pass \(\) to a Hungarian layer . This yields a binary permutation matrix \(X\), representing a bipartite matching among all fracture points:

\[X=()\] (14)

As mentioned, the resulting matching matrix \(X\), along with the affinity matrix \(M\) and soft matching matrix \(\), captures the local geometry similarity across different pieces. Additionally, they quantify the confidence level of how well the pieces fit together. This information enables an accurate positioning and alignment of the fractured components.

### Global Fracture Alignment

To efficiently and robustly recover the global poses of each fractured piece of object \(O\), we adopt a two-step pipeline based on the bipartite matching \(X\{0,1\}^{}\) predicted by the multipart matching module.

In the first step, we compute pairwise transformations between each pair of pieces \((P_{i},P_{j})\) to remove outlier matches. Let \(X_{ij}^{_{i}_{j}}\) denote the submatrix of \(X\), which establishes the correspondences between the fracture points from \(P_{i}\) and \(P_{j}\). We apply the RANSAC algorithm  to compute the transformation \(_{ij}\) from \(_{i}\), \(_{j}\) and \(X_{ij}\). This step ensures reliable pairwise transformations for subsequent alignment.

In the second step, we perform robust global alignment using the computed pairwise transformations. We model the global alignment configuration as a factor graph , denoted as \(G=(,)\), where the global poses \(_{i}\) are optimized on the vertices \(\) and the pairwise transformations \(_{ij}\) are set as constraints on the edges \(\). The information matrix \(I(e)\) over the edge \(e=(i,j)\) is set to \(|X_{ij}|_{}^{-2} I_{6}\), with \(I_{6}\) being the \(6 6\) identity matrix. We employ Shonan averaging , a state-of-the-art 6-DoF global alignment method, to optimize global poses over \(G\). The global alignment method takes pairwise transformations between potentially adjacent pieces as input and outputs a pose for each piece up to a global transformation over the coordinate system. To avoid such an ambiguity, we anchor the coordinate system to the canonical one of the largest pieces in our experiment and measure the errors over all other pieces of the fractured object. Further technical details of this module can be found in the references [41; 42; 43]. Please refer to those sources for more information, as it is beyond the scope of our main contribution.

## 4 Experiments

We demonstrate the effectiveness of our 3D fracture assembly framework through experimental evaluations on a large-scale fracture assembly dataset. Our results show that Jigsaw significantly outperforms the baseline methods both quantitatively and qualitatively. Additionally, we conduct ablation studies to analyze the contributions of each module in our framework. All experiments are conducted on a Linux workstation with 4 Tesla V100-SXM2-32GB GPUs, Intel(R) Xeon(R) CPU E5-2698 v4 @ 2.20GHz CPUs, and 480GB Memory. Table 1 lists the configurations of the parameters in our experiments. A comparison of the training/testing time is included in Appendix D.

### Protocols

**Dataset.** We leverage the Breaking Bad dataset (Sellan et al., 2022), a novel data set of multiple fracture assemblies featuring synthetic physical breaking patterns. Our training was on everyday subset and the testing was on both everyday and artifact subsets for a fair comparison with baselines. Everyday consists of 498 models and 41,754 fracture patterns, and is split into a training set (34,075 fracture patterns from 407 objects) and a test set (7,679 fracture patterns from 91 objects). Artifact consists of 3651 fracture patterns from 40 uncategorized objects. The average diameter of the objects in the training and testing dataset was 0.8. Categorical information was concealed during all the experiments.

The input was uniformly sampled \(N\) points on the surface of the object as a point cloud. In composing the point cloud, two sampling strategies are considered, sampling by piece and object. Sampling by piece, as used in the Breaking Bad benchmark , equally samples points in each fragment, which would cause point density imbalance. To better reflect real-world scanning, we opt for "sampling by object", sampling a fixed number of points in each object, while sampling points for each fragment based on its surface area. We ensure at least 30 points per fragment for multi-part matching. Additional processing details can be found in the Appendix C.1.

**Baseline Approaches.** As learning to assemble multiple fractured objects is a novel task, there is a dearth of existing methods for direct comparison. Therefore, we have selected a set of established methods that primarily address similar challenges in 3D alignment and assembly, and employ them as baselines for comparative evaluation. Global [26; 10] extracts per-piece features, which are combined with global shape descriptors to regress the pose of each piece in one shot. LSTM applies a bidirectional LSTM similar to  and estimates the pose of each piece in sequential style. DGL  is a state-of-the-art approach for the assembly task of parts and can also be adapted to the assembly task of fractures. It leverages an iterative graph neural network to reason about the relationships among pieces. Additionally, we take PREDATOR  as a minor competitor, which is a state-of-the-art approach for 3D registration with low overlapping rates. It employs a multitask transformer to estimate the overlap between pairs of pieces in conjunction with their relative pose. All baseline approaches use textureless point clouds as input and are trained under the everyday object subset of the Breaking Bad dataset.

**Evaluation Metrics.** We adopt the same evaluation schemes for 3D assembly tasks used in [4; 14; 10]. We report the mean absolute error (MAE) and the root mean square error (RMSE) for the rotations and translations of the estimated global poses. Additionally, we include the part accuracy (PA) metric proposed in , which measures the ratio of perfectly assembled pieces based on an average Chamfer distance of less than 0.01 for each point between the assembly results and the ground truth.

### Performance

**Overall Performance.** We report the performance of Jigsaw and all the baseline methods over the 3D fracture assembly task on both everyday and artifact object subsets. An overall quantitative comparison of the evaluation metrics is presented in Table 2. For PREDATOR we apply the evaluation metrics on pairwise transformations since it only supports overlapped pairs of pieces as input.

Jigsaw significantly outperformed all the baselines across all the evaluation metrics. On everyday, we achieved an average rotation error of \(36.3^{}\) over all pieces, which was a \(46\%\) reduction compared to the top-performing baseline method, DGL. Our transformation error was also outstanding, with an average of \(8.7 10^{-2}\), surpassing the best baseline method with an error of \(11.8 10^{-3}\). We

    & Jigsaw & Predator & DGL  & LSTM  & Global  & description \\  epoch & 250 & 200 & 200 & 200 & 200 & training epochs \\ bs & 4 & 16 & 32 & 32 & 32 & batch size \\ lr & 0.001 & 0.01 & 0.001 & 0.001 & 0.001 & learning rate \\ optimizer & Adam & SGD & Adam & Adam & Adam & optimizer during training \\ scheduler & Cosine & Exponential & Cosine & Cosine & learning rate scheduler \\ min\_lr & 1e-5 & - & 1e-5 & 1e-5 & 1e-5 & minimum learning rate for Cosine scheduler \\  \(\) & 1.0 & - & - & - & - & segmentation loss ratio \\ \(\)/ e & 1.0 / 10 & - & - & - & - & matching loss ratio change at epoch e \\ \(\)/ e & 1.0 / 200 & - & - & - & - & rigidity loss ratio change at epoch e \\ \(\) & 0.05 & - & - & - & - & temperature paramter for affinity \\  sampling by & object & piece & piece & piece & piece & sampling strategies for point clouds \\ points (\(N\)) & 5000/e & 800/p & 1000/p & 1000/p & 1000/p & points sampled per object (/o) or piece (/p) \\ \(\) & 0.025 & 0.025 & - & - & - & segmentation ground truth label threshold \\   

Table 1: The detailed experiment parameters. We follow the parameters provided in [16; 33; 4] to reproduce their results. Training, model, and dataset parameters are included.

successfully restored over \(57\%\) of the pieces to their original pose while baseline methods restored only half of us. We also show that change in sampling strategy has had no impact on the outcome of baseline methods through a sampling by object version of DGL. Our method exhibited remarkable generalizability on artifact, showing a slight increase of \(10.1^{}\) in average rotation error and achieving a part accuracy of \(44\%\). In contrast, all baseline methods completely failed to handle new categories of models that were not present in the training dataset. The PREDATOR model failed to accurately identify the pairwise overlap region, resulting in erroneous predictions of complete overlap between the two pieces. While this may seem to yield a small translation error, it failed to perform adequately in the assembly scenario. Hence, we exclude it from further discussion.

**Detailed distribution of each metric.** Fig. 4 presents a comprehensive analysis of each metric for all assembly models. Regarding rotation and translation metrics, a larger surface area under the curve indicates better performance. Jigsaw exhibits a significantly larger number of samples with small rotation and translation errors, as illustrated in the figure. Although Jigsaw reports a slightly larger translation error than the baseline models on the artifact object subset, the distribution results reveal that this is primarily due to a few extreme cases, leading to an undesirable accumulation of the translation error. In terms of part accuracy, a larger surface area above the curve signifies superior results. Notably, Jigsaw demonstrates a higher proportion of correctly positioned pieces.

**Visualization.** The qualitative comparison of different models is shown in Fig. 3. We plot the recovered object from different models. It demonstrates that our model could find the position of the fracture pieces and recover a good pose of each piece. Visualization of objects from different categories also implies our model has good generalization ability and it doesn't require object-level information as assembly guidance.

  Method & Original & RMSE (R) \(\) & MAE (R) \(\) & RMSE(T) \(\) & MAE (T) \(\) & PA \(\) \\  & Task & degree & degree & \( 10^{-2}\) & \( 10^{-2}\) & \(\%\) \\   \\  Global  & assembly & 82.4 & 69.7 & 14.8 & 11.8 & 21.8 \\ LSTM  & assembly & 84.7 & 72.7 & 16.2 & 12.7 & 19.4 \\ DGL  & assembly & 80.6 & 67.8 & 15.8 & 12.5 & 23.9 \\ DGL/5000/o  & assembly & 81.1 & 68.1 & 15.4 & 12.3 & 25.5 \\  PREDATOR  & registration & 82.8 & 71.2 & 12.5 & 10.2 & 1.3 \\  Jigsaw (Ours) & assembly & **42.3** & **36.3** & **10.7** & **8.7** & **57.3** \\   \\  Global  & assembly & 86.9 & 75.3 & 17.5 & 14.5 & 5.6 \\ LSTM  & assembly & 85.6 & 74.1 & 18.6 & 15.2 & 4.5 \\ DGL  & assembly & 86.3 & 74.3 & 18.0 & 14.9 & 9.6 \\  PREDATOR  & registration & 86.0 & 74.8 & **13.4** & **10.9** & 1.1 \\  Jigsaw (Ours) & assembly & **52.4** & **45.4** & 22.2 & 19.3 & **45.6** \\  

Table 2: Quantitative results of baseline methods and Jigsaw on the Breaking Bad dataset.

Figure 3: Qualitative results of baseline methods and Jigsaw on the Breaking Bad dataset (mesh used only for visualization). The coordinate system of the green piece is set as the global coordinate system. Better viewing with color and zooming in.

**Ablation Study.** We conducted an ablation study to assess the effectiveness of each component in our Jigsaw model. The baseline model consists of a segmentation module and a multi-part matching module, trained separately using separate backbones and without incorporating transformers. The plain joint training model was trained using the same loss function as the Jigsaw model, but without using two transformer layers. The effectiveness of the rigidity loss regularization was evaluated over the complete network with both joint training and transformer layers.

As presented in Table 3, the joint training model outperformed the baseline in transformation metrics. This is due to a more favorable initialization for the matching module achieved through pretraining the backbone with the segmentation module. Joint training also aided the matching module's convergence to better optimum. Attention layers significantly reduced rotation errors: the self-attention layer embedded geometric information into point features, while the cross-attention layer improved multi-part matching by incorporating information from other parts. Applying rigidity loss as a refinement additionally brought an improvement of \(2 10^{-3}\) in translation. Even the baseline method outperformed previous works, highlighting the effectiveness of our segmentation and multi-part matching modules.

## 5 Conclusion and Limitations

In this study, we propose a novel geometry-aware framework to address the 3D fracture assembly task. Our approach involves a joint learning model that effectively extracts local geometry features from the backbone and enables the simultaneous learning of piecewise fracture surface segmentation and global fracture point matching. Experimental evaluations and thorough analyses substantiate the exceptional performance of our method in terms of accurately recovering piece poses and restoring the original object. Furthermore, we demonstrate the generalizability of our approach across objects of diverse categories. One limitation of our approach lies in that as the number of fractured pieces increases, the accuracy of pose estimation tends to decrease due to potential ambiguities in fracture matching caused by local geometric features. Future research directions may include exploring matching pruning techniques for pairwise pose estimation to prevent penetration between fractured pieces and enforcing smoothness constraints to enhance pose accuracy.