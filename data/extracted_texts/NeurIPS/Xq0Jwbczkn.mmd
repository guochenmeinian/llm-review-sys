# A Combinatorial Algorithm for the Semi-Discrete Optimal Transport Problem

Pankaj K. Agarwal\({}^{1}\), Sharath Raghvendra\({}^{2}\), Pouyan Shirzadian\({}^{3}\), and Keegan Yao\({}^{1}\)

\({}^{1}\)Duke University, \({}^{2}\)North Carolina State University, \({}^{3}\)Virginia Tech

The authors are listed in alphabetical order.

###### Abstract

Optimal Transport (OT, also known as the Wasserstein distance) is a popular metric for comparing probability distributions and has been successfully used in many machine-learning applications. In the semi-discrete \(2\)-Wasserstein problem, we wish to compute the cheapest way to transport all the mass from a continuous distribution \(\) to a discrete distribution \(\) in \(^{d}\) for \(d 1\), where the cost of transporting unit mass between points \(a\) and \(b\) is \(d(a,b)=\|a-b\|^{2}\). When both distributions are discrete, a simple combinatorial framework has been used to find the exact solution (see e.g. ). In this paper, we propose a combinatorial framework for the semi-discrete OT, which can be viewed as an extension of the combinatorial framework for the discrete OT but requires several new ideas. We present a new algorithm that given \(\) and \(\) in \(^{2}\) and a parameter \(>0\), computes an \(\)-additive approximate semi-discrete transport plan in \(O(n^{4} n)\) time (in the worst case), where \(n\) is the support-size of the discrete distribution \(\) and we assume that the mass of \(\) inside a triangle can be computed in \(O(1)\) time. Our algorithm is significantly faster than the known algorithms, and unlike many numerical algorithms, it does not make any assumptions on the smoothness of \(\). As an application of our algorithm, we describe a data structure to store a large discrete distribution \(\) (with support size \(N\)) using \(O(N)\) space so that, given a query discrete distribution \(\) (with support size \(k\)), an \(\)-additive approximate transport plan can be computed in \(O(k^{3})\) time in \(2\) dimensions. Our algorithm and data structure extend to higher dimensions as well as to \(p\)-Wasserstein problem for any \(p 1\).

## 1 Introduction

Optimal Transport (OT) is a powerful metric for comparing probability distributions and is used in many machine-learning applications. The semi-discrete optimal transport problem asks for the cheapest transport plan to transport mass from (a possibly continuous) distribution \(\) that is stored compactly (say, using a deep neural network) to a discrete distribution \(\). In recent years, the semi-discrete OT has been used in data mining , image processing , computational biology , variational inference , blue noise generation , optics , solving PDEs , and generative models .

More formally, a _semi-discrete transport plan_\(\) between a continuous probability distribution \(\) defined over a compact support \(A^{d}\) and a discrete distribution \(\) with a support set \(B\) of \(n\) points in \(^{d}\) is a distribution over \(A B\) whose marginals are dominated by \(\) and \(\), i.e., \( A B_{ 0}\) is a _transport plan_ between \(\) and \(\) where \(_{b B}(a,b)(a)\) for all \(a A\) and \(_{A}(a,b)\ da(b)\) for all \(b B\). A transport plan \(\) is _complete_ if \(\) transports all mass of \(\) to \(\). For any fixed \(p 1\), inthe _semi-discrete \(p\)-Wasserstein problem_, the goal is to compute a complete transport plan \(\) between \(\) and \(\) minimizing the cost \(():=_{A}_{b B}\|a-b\|^{p}(a,b)\,da\). An optimal plan is referred to as a _\(W_{p}\)-OT plan1_. For any parameter \(>0\), a transport plan \(\) is called an _\(\)-close \(W_{p}\)-OT plan_ if \(()(^{*})+\), where \(^{*}\) is a \(W_{p}\)-OT plan.

An optimal solution for the semi-discrete OT problem can be compactly represented as the weighted Voronoi diagram (also called the Laguerre diagram) with respect to a weight assignment \(y(b)\) on every point \(b B\). The choice of weights guarantees that mass at \(b\) is equal to the mass of \(\) inside the Voronoi cell (also called the Laguerre cell) of \(b\) and the optimal transport plan simply transports the mass at \(b\) to the mass inside its Voronoi cell. For 2 dimensions, the weighted Voronoi diagram under the squared Euclidean distance (also known as the power diagram) can be constructed in \(O(n n)\) time . For higher dimensions \(d>2\), the construction time would be \(O(n^{(d+1)/2})\).

The compact and connected nature of the semi-discrete optimal transport plans makes them attractive for many ML applications; for instance, they can help achieve stability in training GANs and avoid issues such as discontinuities and mode collapse , they improve the mapping between continuous latent spaces and discrete data in Variational Autoencoders (VAEs) , and also have been used in diffusion-based generative models . However, there are no known exact algorithms for computing semi-discrete optimal transport. Additionally, computing an \(\)-close transport plan is known to be \(\#P\)-Hard with respect to \(d\) and \( 1/\), i.e., an algorithm with an execution time that is polynomial in \(d\) and \( 1/\) seems unlikely . Due to the intractability of the semi-discrete optimal transport in high dimensions, researchers have considered taking \(n\) samples from the model, which is a continuous distribution \(\), and computing an optimal discrete transport plan between the empirical distribution \(_{n}\) defined on the \(n\) samples and \(\). It has been shown that this empirical \(p\)-Wasserstein distance converges to the true semi-discrete \(p\)-Wasserstein distance at a rate of \(n^{-1/2p}\); note that the rate of convergence does not depend on the dimension. However, the optimal transport plan from samples is not necessarily a good approximation of the semi-discrete transport plan and may cause biased gradients .

For the discrete OT problem, there are several near-optimal scalable exact and approximation algorithms , some of which extend to very high dimensions. For the semi-discrete OT in low dimensions, despite extensive work, scalable algorithms to find optimal semi-discrete transport plans remain elusive. There are algorithms to compute an \(\)-close semi-discrete transport plan using numerical solvers , entropic regularization , and multiscale approaches . The execution time of all these algorithms is exponential in both \(d\) and \( 1/\). Furthermore, their convergence relies on a smoothness parameter of \(\). For instance, a notable numerical algorithm by Oliker and Prussner  assumes that for a point \(b B\), a small change in \(y(b)\) will change the mass of \(\) inside the Voronoi cell of \(b\) by a proportionately small amount [45, Remark 22]. Under this assumption, their algorithm executes \((n,1/)\) iterations, where each iteration requires the computation of a weighted Voronoi diagram which takes \(n^{O(d)}\) time. Their algorithm slows down when \(\) is non-smooth and does not even converge when \(\) is a discrete distribution. Furthermore, these methods approximate the transport cost but the transport plan that they compute may not be an approximation of the optimal weighted Voronoi diagram.

Recently, Agarwal _et al._ described a _cost-scaling_ paradigm to compute an \(\)-close semi-discrete transport plan. Their algorithm executes \(\) scales, where \(\) is the diameter of \(A B\). Within each scale, they create an instance of the discrete OT problem of size \(O(n^{5})\) in \(^{2}\) (and \(n^{O(d)}\) in \(^{d}\)). Using any existing strongly polynomial primal-dual discrete OT solver, such as the algorithm by Orlin , their algorithm computes an exact discrete OT plan for each instance and updates the weights for \(B\). The OT plan computed in the final scale is an \(\)-close transport plan. They show that the weight assigned to any point \(b B\) is \(\) away from the optimal weight assignment. The overall execution time of this algorithm is \(O(n^{9})\) in \(^{2}\) and \(n^{O(d)}\) in \(d\)-dimensions. Furthermore, in the limit, the transport plan of their algorithm converges to the optimal weighted Voronoi diagram. Note that their algorithm does not make any assumptions on \(\).

**Our Contributions.** The following theorem states our main result.

**Theorem 1.1**.: _Let \(\) be a continuous probability distribution defined on a compact set \(A^{2}\), \(\) a discrete probability distribution with a support \(B^{2}\) of size \(n\), and \(>0\) a parameter. Suppose_there exists an oracle that, given a triangle \(\), returns the mass of \(\) inside \(\) in \(\) time. Then, an \(\)-close \(W_{2}\)-OT plan between \(\) and \(\) can be computed in \(O(n^{3}(+n n))\) time in the worst-case, where \(\) is the diameter of \(A B\)._

Similar to the algorithm by Agarwal _et al._, our algorithm is also based on a cost-scaling approach and executes \(O()\) scales. However, the algorithm within each scale is different. Agarwal _et al._ create a discrete OT instance with \(n^{4}\) vertices and \(n^{5}\) edges and use an exact discrete OT algorithm to solve this instance. Instead, we extend the combinatorial primal-dual framework of discrete OT to the continuous space and present an algorithm to find the desired semi-discrete transport plan in \(O(n^{4} n)\) time in the worst case. There are several challenges in extending the combinatorial framework to semi-discrete settings, and overcoming these challenges is one of the main technical contributions of the paper.

In more detail, in each scale, our algorithm maintains a (partial) transport plan, iteratively computes a set of augmenting paths, and augments the transport plan along such paths until all of the mass is transported. In order to assist in finding augmenting paths, we define a residual graph of size \(O(n^{3})\) in the continuous space. Algorithms for discrete OT maintain dual weights for all points in \(A B\). Unlike in the discrete setting where the vertex set is fixed, the vertex set of our residual graph includes "continuous regions", which evolve over time, and the vertex set of the residual graph changes. Therefore, we are able to maintain weights only for points in \(B\) and not for the regions in \(A\). Our primal-dual framework (especially the definition of admissibility in Section 2), as well as our algorithm (in particular Sections 3.2 and 3.4) contain a number of novel ideas, carefully designed to address various challenges that arise due to the dynamically changing continuous regions of the residual graph. Like all existing algorithms, our algorithm also requires access to an oracle that, given a query triangle, returns the mass of \(\) inside the triangle. We note that Dijkstra's shortest path algorithm has been extended to continuous space , but we are not aware of any previous work that extends a combinatorial discrete OT framework to continuous space.

Our algorithm extends to any dimension \(d 2\) and any \(p 1\) in a straightforward way. For \(d>2\), the algorithm in Theorem 1.1 can be shown to have an execution time of \(O(n^{d+1}(+n n))\). Note that the runtime of Oliker-Prussner's algorithm has a factor \(1/\) while ours has only \( 1/\). Unlike their algorithm, ours does not make any assumptions on the smoothness of \(\). Furthermore, similar to Agarwal et al. , our transport plan approximates an optimal weighted Voronoi diagram within a small additive factor.

One consequence of our algorithm is that we can use it to design a data structure that answers \(\)-close optimal transport queries efficiently. More precisely, consider a large distribution \(\) with support of size \(N\). We can preprocess this distribution into a data structure that can return the total weight of points inside a query triangle in \(O(N^{1-1/d})\) time . By using Theorem 1.1, we can report an \(\)-additive approximate transport plan to any query distribution \(\) with support of size \(k\) in \(O(k^{d+1}N^{1-1/d})\) time. Note that this query time is sub-linear in \(N\). There has been some work on computing \(1\)-Wasserstein distance approximately in sub-linear time and for answering nearest neighbor queries under \(1\)-Wasserstein distance , but these algorithms have larger error and do not extend to \(2\)-Wasserstein distance.

**Theorem 1.2**.: _Let \(\) be a discrete probability distribution with a support \(A^{d}\) of size \(N\). The distribution \(\) can be preprocessed, in \(O(N N)\) time, into an \(O(N)\) size data structure so that for a discrete probability distribution \(\) with a support \(B^{d}\) of size \(k\), and a parameter \(>0\), an \(\)-close \(W_{2}\)-OT plan between \(\) and \(\) can be computed in \(O(k^{d+1}(N^{1-1/d}+k k))\) time, where \(\) is the diameter of \(A B\)._

If the points in the supports of \(\) and \(\) have integer coordinates and the masses on them are rational numbers, we can adapt our data structure in Theorem 1.2 to compute an exact \(W_{p}\)-OT plan between \(\) and \(\) in \(O(k^{d+1}(N^{1-1/d}+k k))\) time for any fixed even value of \(p\).

We also note that in \(2\)-dimensions, for \(k<N^{1/4}\), we can use the data structure to compute an exact discrete OT plan for any distribution \(\) in \(O(k^{3}N^{1/2})\) time that is faster than any existing OT algorithm that takes \((Nk)^{1+o(1)}\) time .

For simplicity in presentation, we restrict our presentation to \(d=2\) and \(p=2\).

## 2 Combinatorial Framework

In this section, we extend the combinatorial framework used by discrete OT algorithms to the semi-discrete settings. Let \(\) be a continuous probability distribution defined over a compact support \(A^{2}\) and \(\) be a discrete distribution with a support set \(B\) of \(n\) points in \(^{2}\).

**Weighted Voronoi diagram.** For any pair of points \(a,b^{2}\), let \((a,b)=\|a-b\|^{2}\). Given a weight function \(y:B_{ 0}\) on the points in \(B\), the _weighted distance_\(d_{y}(a,b)\) from a point \(b B\) to any point \(a^{2}\) is defined as \(_{y}(a,b)=(a,b)-y(b)\). For a point \(b B\), the _Voronoi cell_ of \(b\) is the locus of all points with \(b\) as their weighted nearest neighbor; more formally,

\[_{y}(b)=\{a^{2}_{y}(a,b) _{y}(a,b^{}), b^{} B\}.\]

The _weighted Voronoi diagram_\(_{y}(B)\) of the points \(B\) with weights \(y()\) is the decomposition of \(^{2}\) induced by Voronoi cells. There exists a weight function \(y()\) for \(B\) such that \((_{y}(b))=(b)\) for every point \(b B\), and an optimal semi-discrete transport plan transports the mass of \(\) at each point \(b B\) to the mass of \(\) in \(_{y}(b) A\).

\(\)-expanded Voronoi cell.Consider a weight function \(y()\) for the points in \(B\). For any point \(b B\) and a parameter \(>0\), consider the following weight function \(y_{b}^{}\).

\[y_{b}^{}(b^{})=y(b^{})+,&b^{}=b,\\ y(b^{}),&b^{} b.\] (1)

The \(\)_-expanded Voronoi cell_ of \(b\), denoted by \(V_{b}^{}\), is simply the Voronoi cell of \(b\) in the weighted Voronoi diagram \(_{y_{b}^{}}(B)\) of the point set \(B\) with weights \(y_{b}^{}()\). See Figure 1 (left).

\(\)**-feasibility.** Any (possibly partial) transport plan \(\) between \(\) and \(\) along with a weight function \(y()\) for the points in \(B\) is \(\)_-feasible_ if

1. for any pair \((a,b) A B\) with \((a,b)>0\), the point \(a\) lies inside the \(2\)-expanded Voronoi cell \(V_{b}^{2}\).

For any \(\)-feasible transport plan \(,y()\), if \(\) is a complete transport plan between \(\) and \(\), then \(,y()\) is called a \(\)_-optimal transport plan_. Recall that any optimal transport plan transports the mass at \(b\) to its weighted Voronoi cell. In a \(\)-optimal transport plan, however, the mass of each point \(b B\) is transported inside a \(2\)-expansion of the Voronoi cell of \(b\). This introduces an additive increase of at most \(2\) in the cost of the transport plan.

**Lemma 2.1**.: _Any \(\)-optimal transport plan \(,y()\) between \(\) and \(\) is \(2\)-close._

See Appendix A for a proof. Next, given a \(\)-feasible transport plan \(,y()\), we define a residual graph and an augmenting path. We also introduce the process of augmenting \(\) along an augmenting path, which allows us to increase the mass transported by \(\).

Figure 1: (left) The \(\)-expanded Voronoi cell \(V_{b}^{}\) of \(b\) (green shaded area), (middle) the partitioning \(_{}\), and (right) the green region shows the mass of \(\) that is transported to \(b\), the red points show the representative points of regions, and the purple segments show the compressed transport plan \(\).

**Residual graph.** Given a \(\)-feasible (possibly partial) transport plan \(,y()\), we construct a residual graph \(_{}\) by first partitioning the support \(A\) of \(\) into regions to form the vertex set of \(_{}:=(,y,)\) and then defining a set of directed edges.

_Vertex set._ For each point \(b B\), consider the Voronoi cell of \(b\) and its \(\)- and \(2\)-expansions \(V_{b}^{}\) and \(V_{b}^{2}\). Let \(_{}\) denote the arrangement  of these \(3n\) cells across all \(n\) points of \(B\). See Figure 1 (middle). For each region \(\) in this arrangement, pick an arbitrary _representative point_\(r_{}\) inside \(\) and assign it a mass of \(_{r_{}}:=()\), where \(()=_{}(a)\,da\) denotes the mass of \(\) inside \(\). Let \(A_{}\) denote the set of representative points of all regions in \(_{}\). The vertex set of \(_{}\) is the point set \(A_{} B\) along with a source vertex \(s\) and a sink vertex \(t\). We refer to any point \(b B\) whose mass is not fully transported by \(\) as a _free_ point and define its _excess_ as the amount of mass of \(b\) that is not transported by \(\), i.e., \((b)=(b)-_{a A}(a,b)\,da\). Similarly, any point \(r_{} A_{}\) is free if \(\) does not fully transport the mass into the region \(\), and its excess is defined as \((r_{})=_{r_{}}-_{b^{} B}(, b^{})\).

_Edge set._ For each pair \((r_{},b) A_{} B\), if \((,b)>0\), we add a _backward edge_ directed from \(r_{}\) to \(b\) in the residual graph. Furthermore, if \(r_{} V_{b}^{2}\), we add a _forward edge_ directed from \(b\) to \(r_{}\) in \(_{}\). Additionally, we add a forward edge from the source \(s\) to every free point \(b B\) and a backward edge directed from every free vertex \(r_{}\) to \(t\). This completes the description of the residual graph.

**Lemma 2.2**.: _For any \(>0\) and a \(\)-feasible transport plan \(,y()\), the residual graph \(_{}\) has \(O(n^{2})\) vertices and \(O(n^{3})\) edges._

While describing our algorithm, it is useful to have the definition of weighted distance for all the backward edges, including those incident on \(t\). Therefore, we extend the definition of weighted distance to any edge \((r_{},t)\) as follows. Let \(b_{}\) denote the weighted nearest neighbor of \(r_{}\) in \(B\), i.e., \(b_{}:=_{b B}d_{y}(r_{},b)\). Define \(d_{y}(r_{},t):=d_{y}(r_{},b_{})+\).

**Compressing a semi-discrete transport plan.** Given a semi-discrete transport plan \(\) that transports mass from \(B\) to \(A\), we construct a transport plan \(\) from \(B\) to \(A_{}\) as follows. For each pair \((r_{},b) A_{} B\), let \((r_{},b):=(,b)\), i.e., we assign the entire mass transported from \(b\) to \(\) to the pair \((r_{},b)\) (Figure 1 (right)). We refer to the transport plan \(\) as the _compressed transport plan_.

**Lemma 2.3**.: _For any \(\)-feasible semi-discrete transport plan \(,y()\), the compressed transport plan \(\) along with weights \(y()\) is also \(\)-feasible._

Conversely, consider a transport plan \(,y()\) from \(B\) to \(A_{}\). One can compute a semi-discrete transport plan \(\) that, given a pair \((r_{},b) A_{} B\), arbitrarily transports a mass of \((r_{},b)\) from \(b\) to \(\).

**Lemma 2.4**.: _Any \(\)-feasible transport plan \(,y()\) from \(B\) to \(A_{}\) can be converted into a \(\)-feasible semi-discrete transport plan \(\) from \(B\) to \(A\)._

We say that any compressed transport plan \(\) is a _forest_ if the edges transporting a positive mass in \(\) do not create an undirected cycle.

**Augmentation.** Given the residual graph \(_{}\) for a \(\)-feasible transport plan \(,y()\), an _alternating path_ (resp. _alternating cycle_) is a directed path (resp. directed cycle) in \(_{}\). Note that, in any directed path (resp. cycle) in the residual graph, the edges alternate between forward and backward edges. An _augmenting path_\(P= s,b_{1},r_{1},,r_{k},t=b_{k+1}\) is a directed path from the source vertex \(s\) to the sink vertex \(t\) in the residual graph. By construction, the vertex \(b_{1}\) and the vertex \(r_{k}\) are free vertices in the residual graph. One can _augment_\(\) along \(P\) as follows. Define the bottleneck capacity of the augmenting path \(P\) as \((P):=\{(b_{1}),(r_{k}),_{i[1,k-1]} (r_{i},b_{i+1})\}\). To augment \(\) along \(P\), set \((r_{i},b_{i})(r_{i},b_{i})+(P)\) for each forward edge \((b_{i},r_{i}) P\) and \((r_{i},b_{i+1})(r_{i},b_{i+1})-(P)\) for each backward edge \((r_{i},b_{i+1}) P\).

**Lemma 2.5**.: _The transport plan obtained after augmenting a \(\)-feasible transport plan \(,y()\) along any augmenting path \(P\) in the residual graph is \(\)-feasible._

Consider the following straightforward way to augment a semi-discrete transport plan. Given a \(\)-feasible semi-discrete transport plan \(\), \(y()\), we can compute an augmenting path \(P\) in the residual graph and augment the compressed transport plan \(\) along \(P\). From Lemmas 2.3 and 2.5, \(\) remains \(\)-feasible and from Lemma 2.4, the updated \(\)-feasible transport plan \(\) can be converted to a \(\)-feasible semi-discrete transport plan as desired. To obtain a complete transport plan, one can iteratively apply this procedure until there are no augmenting paths in the residual graph; however, this may result in an unbounded number of iterations. To obtain an efficient algorithm, we iteratively compute a set ofspecial augmenting paths called the "admissible" augmenting paths and augment the transport plan along these paths. By doing so, we can reduce the number of iterations to \(O(n)\).

**Admissibility.** Suppose \(,y()\) is a \(\)-feasible transport plan between \(\) and \(\). For any pair of points \(b_{1},b_{2} B\) and any region \(_{}\) such that \((r_{},b_{2})>0\), the triple \((b_{1},r_{},b_{2})\) is _admissible_ if \(d_{y}(r_{},b_{1})<d_{y}(r_{},b_{2})\)2. See Figure 2 (left). Note that an admissible triple \((b_{1},r_{},b_{2})\) forms by a forward edge followed by a backward edge in the residual graph satisfying \(d_{y}(r_{},b_{1})<d_{y}(r_{},b_{2})\). Intuitively, for any admissible triple \( b_{1},r_{},b_{2}\), the mass of \(\) inside \(r_{}\) is transported from \(b_{2}\) but \(b_{1}\) is nearer to \(r_{}\) than \(b_{2}\) (with respect to the weighted distances).

We extend the definition of admissibility to augmenting paths and alternating cycles as follows. Any augmenting path (resp. alternating cycle) \(P= b_{1},r_{1},b_{2},,r_{k},b_{k+1}\) is _admissible_ if all triples \((b_{i},r_{i},b_{i+1})\), \(i[1,k]\), are admissible. In Figure 2(right), \(b_{2}\) transports mass to \(r_{1}\), and \(b_{1}\) is its weighted nearest neighbor. By augmenting along this admissible path, we increase \((r_{1},b_{1})\) and reduce \((r_{1},b_{2})\), thereby transporting more mass to \(r_{1}\) from its weighted nearest neighbor.

## 3 Algorithm

In this section, we present our cost-scaling algorithm that uses the combinatorial framework from Section 2 to compute an \(\)-close semi-discrete OT plan. Classical discrete OT algorithms assign weights to points in \(A B\) and use them to identify a large set of augmenting paths. Their efficiency critically relies on the acyclicity of the "search" graph. In contrast, during the execution of our algorithm, a change in the weights of \(B\) creates a new weighted Voronoi diagram, which in turn changes \(A_{}\), the discrete representation of \(A\), and thus the vertex set of the residual graph. Since \(A_{}\) may change significantly in each iteration during the execution of our algorithm, we cannot maintain weights for them. This creates significant challenges as the algorithm searches for augmenting paths (See Section 3.2 for details). Furthermore, the updated residual graph may have cycles. We introduce additional steps in our algorithm to eliminate these cycles (See Section 3.4 for details). First, we present an overview of our algorithm and then present the details.

### Overview

The algorithm runs for \(O()\) scales, where \(\) is the diameter of \(A B\). In each scale \(\), our algorithm maintains a transport plan \(_{}\) and a weight \(y(b)\) for every point \(b B\). Initially, set \(=^{2}\) and define \(y(b)=0\) for all \(b B\). In each scale \(\), execute the following steps.

1. _Initialization:_ Set \(_{}\) to be an empty transport plan. Compute the residual graph \(_{}\) and the compressed transport plan \(_{}\) with respect to \(_{},y()\).
2. _Iterations:_ While \(_{}\) is not a complete transport plan:

Figure 2: (left) Three admissible triples \((b_{1},r_{1},b_{2}),(b_{1},r_{2},b_{2}),\) and \((b_{1},r_{3},b_{2})\), where solid (resp. dashed) lines show backward (resp. forward) edges, and (right) an admissible augmenting path.

1. Compute a set of admissible augmenting paths in the residual graph \(_{}\) and augment \(_{}\) along these paths using the SearchAndAugment procedure described in Section 3.2. At the end of this step, there are no admissible augmenting paths in the residual graph.
2. Adjust the weights of all points of \(B\) that are reachable from the source by admissible paths by \(\) and recompute the set \(A_{}\), the residual graph \(_{}\), and the compressed transport plan \(_{}\) using the IncreaseWeights procedure described in Section 3.3.
3. Update the compressed transport plan \(_{}\) and the residual graph using the Acyclify procedure described in Section 3.4, so that the transport plan \(_{}\) is a forest and the residual graph does not have any admissible cycles.

3. _Scale Update:_ Set \(/2\).

After the execution of a scale \(/2\), our algorithm terminates by returning a complete semi-discrete transport plan \(_{}\) obtained from the compressed complete transport plan \(_{}\) (using Lemma 2.4).

**Invariants.** As shown in Section 4 below, our algorithm iteratively updates the weights \(y()\) and the transport plan \(_{}\) while maintaining the following invariants:

1. The transport plan \(_{},y()\) is \(\)-feasible, and
2. At the start of each iteration, the transport plan \(_{}\) is a forest and there are no admissible cycles in the residual graphs.

**Remark.** The algorithm by Agarwal et al.  creates a discrete instance in each scale of the algorithm by computing the arrangement of the \(\)-, \(2\)-, \(\), and \((4n+1)\)-expanded Voronoi cells of each point \(b B\). Instead of using such a fine partition to create a discrete instance with \(O(n^{5})\) edges, we work directly with the continuous space, maintain a much smaller residual graph with \(O(n^{3})\) edges, and use our semi-discrete combinatorial framework to find a transport plan.

### SearchAndAugment Procedure

The SearchAndAugment procedure executes a partial DFS-style search to identify a set of admissible augmenting paths and augments the transport plan along these paths. The SearchAndAugment procedure is somewhat similar in style to the blocking flow procedure in Dinic's max-flow algorithm  or the partial-DFS procedure in Gabow-Tarjan's algorithm , both of which rely on the property that there are no admissible cycles in the residual graph. Unlike these algorithms, in our case, if we augment along an arbitrary admissible augmenting path, we may create an admissible cycle. See Figure 3.

We overcome this challenge by carefully calibrating the search algorithm in two ways. First, we begin our search from the free regions instead of the free points of \(B\). Thus, we reverse the direction of all the edges of the residual graph and begin our search from the sink \(t\). Second, we explore all forward edges incident on a region in the increasing order of their weighted distance. This order of processing edges ensures that no admissible cycles are created and that there are no more admissible augmenting paths in the residual graph after the SearchAndAugment procedure terminates. We provide the details below.

Let \(_{}}\) be the graph formed by reversing the direction of all the edges of \(_{}\). We conduct our search starting from the sink \(t\) in the graph \(_{}}\). Initially, mark all points of \(B\) and all backward edges as unvisited, define \(U:=B\) as the set of unvisited points of \(B\), and \(Q= t=b_{0}\) as the search path that the procedure grows. Execute the following steps until the search path \(Q\) becomes empty.

1. If \(Q= t=b_{0},r_{1},b_{1},,r_{i},b_{i}\) for some \(i 0\), 1. If there is an edge from \(b_{i}\) to \(s\) in \(_{}}\) (i.e., \(b_{i}\) is a free point), then \(P= s,b_{i},r_{i},,r_{1},t\) is an augmenting path in \(_{}\). Augment \(_{}\) along \(P\) and set \(Q= t=b_{0}\). 2. Assume there is not edge from \(b_{i}\) to \(s\). If there is an unvisited edge \((b_{i},r)\) in \(_{}}\), then add \(r=r_{i+1}\) to \(Q\). Otherwise, mark \(b_{i}\) as visited and remove \(b_{i}\) from \(U\) and \(Q\).

2. If \(Q= t=b_{0},r_{1},b_{1},,b_{i},r_{i+1}\) for some \(i 0\), let \(b:=_{b^{} U}d_{y}(r_{i+1},b^{})\) denote the unvisited point with the minimum weighted distance to \(r_{i+1}\)3. 
The algorithm terminates when the search path \(Q\) becomes empty, i.e., the procedure marked \(t\) as visited and removed it from \(Q\). The following lemma shows the properties of the SearchAndAugment procedure.

**Lemma 3.1**.: _Suppose invariants (11) and (12) hold at the start of the SearchAndAugment procedure. Then, during the execution of the SearchAndAugment procedure,_

1. _the transport plan_ \(_{},y()\) _remains_ \(\)_-feasible,_
2. _any point_ \(b B\) _(resp. backward edge_ \((r,b)\)_) marked as visited will not form an admissible augmenting path during the execution of the procedure, and_
3. _there are no admissible cycles in the residual graph._

### IncreaseWeights Procedure

The IncreaseWeights procedure adjusts the weights of \(B\) leading to the formation of admissible augmenting paths. The IncreaseWeights procedure performs a DFS on the residual graph \(_{}\) to compute a set \(\) of all vertices of \(B\) that are reachable from the source vertex \(s\) by admissible paths. It increases the weights of all points in \(\) by \(\) (expand their Voronoi cells). Recall that the set \(A_{}\), and thus \(_{}\) as well as the compressed transport plan \(_{}\) depend on the weights of \(B\). The procedure then recomputes \(A_{}\), \(_{}\), and \(_{}\) from \(_{}\). See Appendix B.2 for complete details of the IncreaseWeights procedure. The following lemma states the properties of the IncreaseWeights procedure.

**Lemma 3.2**.: _Suppose invariant (11) holds at the start of the IncreaseWeights procedure. Then, during the execution of the IncreaseWeights procedure,_

1. _the transport plan_ \(_{},y()\) _remain_ \(\)_-feasible,_
2. _the weight of each free point_ \(b B\) _increases by_ \(\)_, and_
3. _the weight of each point_ \(b B\) _with free regions inside_ \(V_{b}^{}\) _remains unchanged._

### Acyclify Procedure

The change in the weights of \(B\) in the IncreaseWeights procedure requires us to recompute the residual graph and the compressed transport plan. This recomputation may potentially create a cycle in the transport plan or an admissible cycle in \(_{}\). The Acyclify procedure eliminates such cycles and ensures that the invariant (12) holds at the start of the next iteration. Converting the transport plan into a forest is critical for the efficiency of the SearchAndAugment procedure while eliminating admissible cycles is essential for the correctness of the SearchAndAugment procedure. The procedure executes the following steps. First, use the dynamic tree structure by Sleator and Tarjan  to make the transport plan \(_{}\) a forest. Then, execute a partial DFS search from each unvisited point \(b B\) similar to the one described in the SearchAndAugment procedure to detect admissible cycles. Upon finding an admissible cycle, cancel the cycle right away, remove the vertices of the cycle from the search path, and continue the search. When all vertices are visited, no admissible cycles are remaining in the residual graph. Since canceling admissible cycles could have introduced new cycles in the transport plan, repeat the first step to update \(_{}\) and make it a forest. See Appendix B.3 for details. The following lemma shows the properties of the Acylify procedure.

**Lemma 3.3**.: _Suppose invariant (I1) holds at the start of the Acylify procedure. Then, during the execution of the Acylify procedure,_

1. _the transport plan_ \(_{},y()\) _remains_ \(\)_-feasible, and_
2. _the transport plan_ \(_{}\) _is a forest and there are no admissible cycles in the residual graph._

This completes the description of our algorithm.

## 4 Algorithm Analysis

In this section, we first prove the correctness of our algorithm and then analyze its runtime.

**Proof of invariants (I1) and (I2).** For any scale \(\), the initial transport plan \(_{}\) is empty. Therefore, \(_{}\) along with the weights \(y()\) is \(\)-feasible. By properties (S1), (W1), and (A1), the transport plan \(_{},y()\) remains \(\)-feasible in each iteration of our algorithm, and therefore, invariant (I1) holds. The invariant (I2) is a direct consequence of property (A2) in Lemma 3.3.

**Proof of Correctness.** From Invariant (I1), in each scale \(\), our algorithm maintains a \(\)-feasible transport plan \(_{},y()\) during its execution. The while loop in Step 2 breaks when \(_{}\) is a complete transport plan. Therefore, \(_{}\) along with weights \(y()\) is \(\)-optimal. From Lemma 2.4, one can convert \(_{}\) into a \(\)-optimal semi-discrete transport plan \(_{}\). Given that our algorithm terminates when \(/2\), from Lemma 2.1, the transport plan returned by our algorithm is \(\)-close, as desired.

**Efficiency of the algorithm.** The SearchAndAugment procedure runs a partial DFS on the residual graph with \(O(n^{3})\) edges. Upon finding an augmenting path \(P\), the procedure augments the transport plan along \(P\) in \(O(|P|)\) time. In Lemma C.1, we use invariant (I2) to show that the total length of all augmenting paths found by the procedure is \(O(n^{3})\). Hence, the running time of the SearchAndAugment procedure is \(O(n^{3})\). The IncreaseWeights procedure stores a sorted list of neighbors for each region and executes a DFS procedure in the residual graph, which takes \(O(n^{3} n)\) time. After increasing the weight of a subset of points of \(B\), the procedure recomputes the residual graph \(_{}\) and the transport plan \(_{}\), which can be done in \(O(n^{2}(+n n))\) time. See Lemma C.2 in the appendix for details. In the Acylify procedure, converting a transport plan into a forest can be done using a dynamic tree data structure  in \(O(n^{3} n)\) time. To eliminate the admissible cycles, the Acylify procedure relies on a partial DFS that runs in \(O(n^{3})\) time. Therefore, the total time by the Acylify procedure is \(O(n^{3} n)\) (see Lemma C.3 for details). Combining the running times of all three procedures, each iteration of step 2 of our algorithm takes \(O(n^{2}(+n n))\) time. In the following lemma, we show that in each scale, the total number of iterations of step 2 of our algorithm is at most \(O(n)\).

**Lemma 4.1**.: _For each scale \(\), the total number of iterations of step 2 of our algorithm is \(O(n)\)._

Proof Sketch.: Let \(_{2},y_{2}()\) denote the \(2\)-feasible semi-discrete transport plan computed by our algorithm for scale \(2\), and let \(_{},y_{}()\) denote a partial semi-discrete transport plan maintained during the execution of step 2 of our algorithm. Let \(_{2}\) (resp. \(_{}\)) denote the partitioning of the set \(A\) with respect to weights \(y_{2}()\) (resp. \(y_{}()\)). Let \(\) be the arrangement of all \(3n\) cells used to construct \(_{2}\) with all \(3n\) cells used to construct \(_{}\). Let \(_{2}\) (resp. \(_{}\)) denote the compressed transport plan for \(_{2}\) (resp. \(_{}\)) using the partitioning \(\). It is well-known that one can transform \(_{}\) to \(_{2}\) by augmenting \(_{}\) along a set of augmenting paths \(\) on \( B\) and rearrange the transported mass along a set of cycles \(\) on \( B\). Consider an augmenting path \(P= r_{1},b_{1},,r_{k},b_{k}\) in \(\). Since \(P\) is a simple path, it contains each point of \(B\) at most once and therefore, it has a length at most \(2n-1\). Additionally, for all \(i[1,k]\), \(_{2}(r_{i},b_{i})>0\) and for each \(i[2,k]\), \(_{}(r_{i},b_{i-1})>0\). For each edge \((r_{i},b_{i})\), since \(_{2}(r_{i},b_{i})>0\), by \(2\)-feasibility of \(_{2},y_{2}()\) (condition (F1)), the point \(b_{i}\) is a \(4\)-weighted nearest neighbor of \(r_{i}\) with respect to weights \(y_{2}()\). Similarly, for each edge \((b_{i-1},r_{i})\), since \(_{}(r_{i},b_{i-1})>0\), by \(\)-feasibility of \(_{},y_{}()\) (condition (F1)), the point \(b_{i-1}\) is a \(2\)-weighted nearest neighbor of \(r_{i}\) with respect to weights \(y_{}()\). Since the length of \(P\) is at most \(2n-1\) and the weight of \(b_{1}\) does not change (by property (W3) in Lemma 3.3), we show that for the free point \(b_{k}\) in \(P\), \(y_{}(b_{k})-y_{2}(b_{k}) 6n\). Our algorithm increases the weight of \(b_{k}\) by \(\) in each iteration (property (W2) in Lemma 3.3), and therefore after \(6n\) iterations, the point \(b_{k}\) cannot be free, i.e., after \(O(n)\) iterations, all points of \(B\) are fully transported in \(_{}\). We provide the full proof in Section C.4.

Using Lemma 4.1, the total time spent in step 2 in each scale of our algorithm is \(O(n^{3}(+n n))\). Since there are \(O()\) scales, the overall runtime is \(O(n^{3}(+n n))\), thereby proving Theorem 1.1.

## 5 Applications to the Discrete Optimal Transport Problem

In this section, we extend our combinatorial semi-discrete OT algorithm to the discrete OT problem and design a data structure that preprocesses and stores a large discrete distribution \(\) and efficiently computes an \(\)-close OT plan between \(\) and any query distribution \(\) in sub-linear time relative to the support size of \(\). More precisely, given a discrete distribution \(\) with a (possibly large) support \(A\) of \(N\) points in \(^{2}\), we design a data structure that, given a query discrete distribution \(\) with a support \(B\) of \(k\) points, computes an \(\)-close transport plan between \(\) and \(\) in \(O(k^{3}(+k k))\) time. Additionally, we show that if the support points have bounded integer coordinates and the masses are rational numbers, our data structure can efficiently compute an exact discrete OT plan.

At a high level, our data structure interprets the large discrete distribution \(\) as a continuous distribution and uses a simplex range-searching data structure as an oracle to compute the mass of \(\) inside a query triangle. In this way, for any query distribution \(\), one can execute the steps of our combinatorial semi-discrete algorithm to compute an \(\)-close transport plan between \(\) and \(\). More formally, our data structure preprocesses the distribution \(\) into a simplex range-searching data structure RS-DS, which takes \(O(N)\) space, can be built in \(O(N N)\) time, and returns the mass of \(\) inside a query triangle in \(=O()\) time . Given a query discrete distribution \(\), one can use our algorithm from Section 3 in conjunction with the RS-DS to compute an \(\)-close transport plan between \(\) and \(\) in \(O(k^{3}(+k k))\) time leading to Theorem 1.2.

Consider the special case where the points in \(A B\) have positive integer coordinates bounded by \(\), the mass of \(\) (resp. \(\)) on each point \(a A\) (resp. \(b B\)) is a rational number of form \(\) (resp. \(}{T}\)) for positive integers \(T\) and \(x_{a}\) (resp. \(x_{b}\)), and \(p\) is an even number. In this case, the \(p\)-Wasserstein cost of any transport plan between \(\) and \(\) is an integer multiple of \(\), and therefore, any \(\)-close transport plan between \(\) and \(\) would have a minimum cost. Thus, one can compute an exact discrete OT plan between \(\) and \(\) by setting \(=\) in our data structure, which would have a query time of \(O(k^{3}(+k k)( T))\), leading to the following corollary.

**Corollary 5.1**.: _When the points in the supports of the distributions \(\) and \(\) have integer coordinates bounded by \(\) and the mass on each point is a rational number of form \(\), our data structure computes, for any even number \(p\), an optimal solution for the \(p\)-Wasserstein problem between \(\) and \(\) in \(O(k^{3}(+k k)( T))\) time._

## 6 Conclusion

In this paper, we designed a novel combinatorial framework for the semi-discrete optimal transport problem and used it to compute an \(\)-close semi-discrete transport plan. We also used this framework to design a data structure that stores a discrete distribution \(\) over a large support of size \(N\) and can compute \(\)-close OT cost between \(\) and a query discrete distribution \(\) in a time that is sub-linear in \(N\). We conclude with the following question: Can we use our combinatorial framework to compute an \(\)-close semi-discrete transport plan between high dimensional distributions in \((n,d,1/)\) time.