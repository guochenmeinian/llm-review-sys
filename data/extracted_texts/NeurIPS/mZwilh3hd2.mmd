# Polynomial-Time Computation of Exact \(\Phi\)-Equilibria

# Polynomial-Time Computation of Exact \(\)-Equilibria

in Polyhedral Games

 Gabriele Farina

MIT

gfarina@mit.edu &Charilaos Pipis

MIT

chpipis@mit.edu

###### Abstract

It is a well-known fact that correlated equilibria can be computed in polynomial time in a large class of concisely represented games using the celebrated Ellipsoid Against Hope algorithm (Papadimitriou and Roughgarden, 2008; Jiang and Leyton-Brown, 2015). However, the landscape of efficiently computable equilibria in sequential (extensive-form) games remains unknown. The Ellipsoid Against Hope does not apply directly to these games, because they do not have the required "polynomial type" property. Despite this barrier, Huang and von Stengel (2008) altered the algorithm to compute exact extensive-form correlated equilibria.

In this paper, we generalize the Ellipsoid Against Hope and develop a simple algorithmic framework for efficiently computing saddle-points in bilinear zero-sum games, even when one of the dimensions is exponentially large. Moreover, the framework only requires a "good-enough-response" oracle, which is a weakened notion of a best-response oracle.

Using this machinery, we develop a general algorithmic framework for computing exact linear \(\)-equilibria in any polyhedral game (under mild assumptions), including correlated equilibria in normal-form games, and extensive-form correlated equilibria in extensive-form games. This enables us to give the first polynomial-time algorithm for computing exact linear-deviation correlated equilibria in extensive-form games, thus resolving an open question by Farina and Pipis (2023). Furthermore, even for the cases for which a polynomial time algorithm for exact equilibria was already known, our framework provides a conceptually simpler solution.

## 1 Introduction

The correlated equilibrium (CE), introduced by Aumann (1974), is one of the most seminal solution concepts in multi-player games. Contrary to the Nash equilibrium, in a correlated equilibrium the players' strategies are correlated by a fictitious _mediator_ that can recommend (but not enforce) behavior. It is then up to this mediator to ensure that the distribution of recommendations does not incentivize any player to _deviate_ from their recommended strategy. It is known that this type of equilibrium naturally emerges from the repeated interaction of learning agents (Hart and Mas-Colell, 2000). In practice, this means that one can compute \(\)-approximate CEs in normal-form games by implementing suitable decentralized no-regret dynamics, of which several efficient implementations are known (see, _e.g._, Blum and Mansour (2007) and Anagnostides et al. (2022)). However, this approach requires \(((1/))\) iterations to compute an \(\)-approximate equilibrium, making it a non-viable choice for high-precision equilibrium computation. In a celebrated result, Papadimitriou and Roughgarden (2008) (with later refinements by Jiang and Leyton-Brown (2015)) devised an algorithm, called _Ellipsoid Against Hope_, that can compute an exact CE in a concisely represented normal-form game in polynomial time in the representation of the game. Their algorithm is an algorithmic version of the clever reduction of Hart and Schmeidler (1989) that casts the computation of CEs as a two-player zero-sum game.

The positive results for normal-form games, however, do not transfer directly to the significantly more involved setting of _extensive-form games_. Extensive-form games are games played on a game tree and can model sequential and simultaneous moves, as well as imperfect information. Despite a significant stream of _positive_ results related to learning and equilibrium computation in extensive-form games, the complexity of computing CEs in extensive-form games remains to this day a major open question (Farina and Pipis, 2023; von Stengel and Forges, 2008). Due to its conjectured intractability, researchers have resorted to considering the computation of weaker and generalized notions of correlated equilibrium. A key reference point in this space is given by the framework of Gordon et al. (2008), who define a generalized notion of CE called \(\)-equilibria. In a \(\)-equilibrium, every player \(p\) is endowed with a set \(_{p}\) of _behavior transformation functions_. The goal of the fictitious mediator is then simply to recommend strategies such that no player could unilaterally benefit from deviating by using any of the functions \(_{p}\). In this language, a CE corresponds to the \(\)-equilibrium in which each \(_{p}\) is the set of all possible functions from the strategy set of the player to itself. However, by considering appropriate subsets of behavior transformations, weaker supersets of CEs can be efficiently computed and learned through uncoupled learning dynamics. Notable examples of such equilibria in extensive-form games include the extensive-form correlated equilibrium (EFCE) (von Stengel and Forges, 2008), the extensive-form coarse-correlated equilibrium (EFCCE) (Farina et al., 2020), the normal-form coarse-correlated equilibrium (NFCCE) (Moulin and Vial, 1978), the recently-introduced linear-deviation correlated equilibrium (LCE) (Farina and Pipis, 2023), and others (Morrill et al., 2021).

Huang and von Stengel (2008) proposed a specialization of the Ellipsoid Against Hope algorithm to compute exact EFCE in extensive-form games. Later, Farina et al. (2022a) showed efficient no-regret dynamics that converge to the EFCE. More recently, there has been increased interest in understanding what is the \(\)-equilibrium that is the closest to CE while still enabling efficient computation and learning. Farina and Pipis (2023) introduced the linear-deviation correlated equilibrium (LCE) that arises from the set \(_{}\) of all linear-swap deviations in sequence-form strategies and devise efficient no-linear-swap regret dynamics to approximate it. The LCE captures all notable notions of equilibrium that were previously known to be efficiently computable (including EFCE, EFCCE, and NFCCE). However, Farina and Pipis (2023) left open the key question as to whether LCEs themselves can also be computed exactly in polynomial time, akin to the generalization of the Ellipsoid Against Hope algorithm by Huang and von Stengel (2008), as opposed to just learned via uncoupled learning dynamics. The approach by Huang and von Stengel (2008) relies heavily on the combinatorial structure of the deviation functions that define EFCE, resulting in a rather involved algorithm. This is in stark contrast to the simple framework for constructing \(\)-regret minimizers championed by Gordon et al. (2008). This begs the natural question:

_Can we always construct an efficient algorithm for exactly computing \(\)-equilibria, when there exists an efficient no-\(\)-regret minimizer?_

In other words, can we create a simple and general framework in the spirit of Gordon et al. (2008) that can enable us to construct algorithms for the exact computation of \(\)-equilibria in polyhedral games for any \(_{}\)? We answer this question in the affirmative.

Contributions.In this paper, we propose a framework for computing exact \(\)-equilibria in general polyhedral games. Our framework recovers all positive results established by Papadimitriou and Roughgarden (2008), and crucially applies to polyhedral games such as extensive-form games. Using our framework, we develop the first polynomial-time algorithm for computing exact linear-deviation correlated equilibria in extensive-form games, thus resolving an open question by Farina and Pipis (2023). Furthermore, even for the cases for which a polynomial time algorithm for exact equilibria was already known (CEs in normal-form games (Papadimitriou and Roughgarden, 2008; Jiang and Leyton-Brown, 2015) and EFCEs in extensive-form games (Huang and von Stengel, 2008)), our framework provides a conceptually simpler solution.

We show that to compute an exact \(\)-equilibrium in a polyhedral game, the following three conditions are sufficient:

1. The game satisfies the "polynomial utility gradient property" (Assumption 4.2) which states that given a product distribution over the joint strategy space of all \(n\) players, we can efficiently compute the expectation of the gradient of any player's utility. This is a natural generalization of the "polynomial expectation property" of Papadimitriou and Roughgarden(2008), and it is a rather low bar to clear (in fact, it is implicitly assumed in every no-regret learning algorithm).
2. \(\) is a set of _linear_ transformations (_i.e._, of the form \(()=\) for some matrix \(\)) that map the strategy set to itself. This is a technical requirement so that the expectation operator and the application of the deviation function can commute.1 This condition is satisfied by all notions of \(\)-equilibrium mentioned above, including EFCE and LCE in extensive-form games, and CE in normal-form games. 3. The set \(\) of transformations is a polytope that admits a polynomial-time separation oracle.

The separation oracle requirement in the third condition is known to be equivalent to efficient linear optimization (Grotschel et al., 1993). In essence, this means that giving a polynomially-sized characterization of a set \(\) of linear transformations for a polyhedral set is a sufficient condition to provide both efficient no-regret learning dynamics and an efficient algorithm for computing exact \(\)-equilibria. This is exactly what we achieve by applying our result to the set of linear-swap deviations that was recently characterized (Farina and Pipis, 2023; Zhang et al., 2024) as a polytope of polynomially many constraints and was used to prove efficient no-linear-swap regret dynamics. In light of all these considerations, our framework can be thought of as the counterpart of the \(\)-regret minimization framework by Gordon et al. (2008), but for computation of _exact_ equilibria rather than regret minimization.

At the heart of our construction, our main technical tool is a generalization of the methodology of the Ellipsoid Against Hope (Papadimitriou and Roughgarden, 2008; Jiang and Leyton-Brown, 2015) to general polyhedral bilinear games. In more detail, we give a new constructive proof of the minimax theorem for players with polyhedral strategy sets, by using only a weakened type of a best-response oracle that we coin Good-Enough-Response (GER) oracle. An interesting property of the GER oracle is that it can be computationally tractable even when the respective best-response oracle is intractable, as we show in Section 4. This algorithmic idea is likely of independent interest and is especially useful when the strategy space of one of the players is very large but there exists an efficient GER oracle that outputs sparse solutions (_e.g._, vertices of a high-dimensional polytope). This is exactly the type of problem we face when we need to compute exact \(\)-equilibria in polyhedral games and we then proceed to apply this machinery to the above question. Interestingly, in order to show the existence of structured good-enough responses in the context of \(\)-equilibria, we use an argument based on the existence of an efficient fixed-point oracle for each deviation \(\). Such an ingredient was fundamental (albeit used differently; see Hazan and Kale (2007) for a discussion of the role played by fixed-point oracles in the construction of no-\(\)-regret algorithms) also in Gordon et al. (2008). In our case, it is one of the technical insights that enable us to sidestep much of the intricacy encountered by Huang and von Stengel (2008).

We defer all proofs of the paper to the appendix.

Related work.We include an extensive discussion of related work in Appendix A.

## 2 Preliminaries

In this section, we introduce some basic concepts and definitions that will be used in developing our framework.

### Polyhedra, polytopes, and convex sets

**Definition 2.1** (Rational polyhedron).: _A rational polyhedron \(=\{^{n}\}\) is the solution set of a system of linear inequalities with rational coefficients. We say that \(\) has **facet-complexity**\(\) if there exists a system of linear inequalities, where each inequality has encoding length 2 at most \(\), and whose solution set is \(\). A rational polyhedron that is bounded is called a rational polytope._One important property of rational polytopes that we will use repeatedly throughout the paper is that they can equivalently be written as the convex hull of a _finite_ number of points. We call these points the _vertices_\(V()\) of polytope \(\). Additionally, the vertices of a rational polytope always have rational coordinates and encoding length \(()\)(Grotschel et al., 1993, Lemma 6.2.4).

Since we are interested in constructing algorithms that perform exact computations, any discussion of non-rational numbers is not relevant. Thus, from now on, every time we deal with a polytope we will mean a rational polytope.

In our algorithm, we will also make use of the concept of _conic hull_, which is introduced next.

**Definition 2.2** (Conic hull).: _The conic hull of a convex set \(\) is \(_{+}=\{t t 0,\}\). Furthermore, if \(\) is a rational polyhedron, its conic hull is also a rational polyhedron._

### Game theory definitions

We begin by defining polyhedral games, following Gordon et al. (2008). But first, we need to define multi-linear functions.

**Definition 2.3** (Multi-linear function).: _Let \(V_{1},,V_{n}\) be vector spaces. A function \(f:V_{1} V_{n}\) is said to be multi-linear if for each \(p[n]\) and fixed \(_{-p} V_{-p}\) the function \(f(_{p},_{-p})\) is linear in \(_{p} V_{p}\). In other words, if \( f(_{-p})\) is the gradient of \(f(_{p},_{-p})\) with respect to \(_{p}\) when \(_{-p}\) is fixed, then \(f(_{p},_{-p})=_{p} f(_{-p})\)._

**Definition 2.4** (Polyhedral game).: _In a polyhedral game with \(n\) players, every player \(p[n]\) has a polytope3 strategy set \(_{p}^{d_{p}}\) and a multi-linear utility function \(u_{p}:_{1}_{n}\)_

Some notable examples of polyhedral games are: normal-form games, where every player has a probability simplex as their strategy set, and extensive-form games, where the strategy sets of the players are the sets of sequence-form strategies (Romanovskii, 1962; Koller et al., 1996; von Stengel, 1996). We will refer to the encoding length of the game as the _size of the game_. In games of interest this is usually much smaller than holding the full utility function; for example, extensive-form games are encoded using a game tree and different classes of normal-form games can have other succinct descriptions (Papadimitriou and Roughgarden, 2008).

A sub-class of polyhedral games that will be particularly useful in our paper is that of bilinear zero-sum games, which is defined below.

**Definition 2.5** (Bilinear zero-sum game).: _Let \(^{M}\), \(^{N}\) be two rational polytopes. A bilinear zero-sum game is a game between two players with strategy sets \(\) and \(\) such that the utility of the \(\)-player is \(u_{1}(,)=^{}\), for some \(^{M N}\), and the utility of the \(\)-player is \(u_{2}(,)=-u_{1}(,)\)_

We can now define the notion of a \(\)-equilibrium, which generalizes the correlated equilibrium for arbitrary \(n\)-player polyhedral games and sets of strategy transformations \(\). Before we do that, we first need to define the _corner game_\((G)\) of a polyhedral game \(G\), following Gordon et al. (2008); Marks (2008). This is the game that arises if we let the action sets of every player \(p\) be equal to the vertices \(V(_{p})\) of the polytope strategy set of that player. Note that since \(_{p}\) is a polytope, it will have a finite number of vertices. The utilities of this game for a player \(p[n]\) and pure strategy profile \( V(_{1}) V(_{n})\) are simply given by \(u_{p}()\). In this paper, we will denote the vertices of every strategy set in a polyhedral game as \(_{p}=V(_{p})\). We are now ready to define the \(\)-equilibrium.

**Definition 2.6** (\(\)-equilibrium).: _Let \(G\) be a polyhedral game of \(n\) players and \(_{p}\) be a set of strategy transformations \(_{p}:_{p}_{p}\) for each player \(p[n]\). A \(\{_{p}\}\)-equilibrium for \(G\) is a joint distribution \((_{1}_{n})\) on the pure strategy profiles of \((G)\), such that for every player \(p[n]\) and deviation \(_{p}\) it holds_

\[}_{}[u_{p}()]}_{ {s}}[u_{p}((_{p}),_{-p})].\]

_That is, no player \(p\) has an incentive to unilaterally deviate from the recommended joint strategy \(\) using any transformation \(_{p}\)._A simple framework for computing equilibria in bilinear zero-sum games using good-enough-response (GER) oracles

We begin by introducing a simple algorithmic framework (Theorem 3.1) for computing min-max equilibria in bilinear zero-sum games. As mentioned before, it relies on the idea of good-enough-responses. The motivation behind this is that sometimes a best-response oracle is not known, or even NP-hard to construct (as we prove in Theorem 4.7). On the contrary, good-enough-responses might be a readily available primitive. For example, we will see in Section 4 that a good-enough-response oracle materializes through the use of fixed-point oracles for transformations \(\) and this enables us to devise polynomial time algorithms for computing exact \(\)-equilibria in polyhedral games.

Let us assume that we have a bilinear zero-sum game \((,,)\), where the strategy sets \(^{M},^{N}\) are rational polytopes. We typically assume that \(M N\). Additionally, let

\[=_{}_{}^{ },\]

be the value of the game at equilibrium, which is known to us. _In the rest of the paper we assume that \(=0\)._ This is without loss of generality because otherwise, it is possible to create a new game with this property by augmenting the vectors \(,\) with an extra dimension as follows:

\[[^{}&1][ []{cc}&\\ ^{}&-][\\ 1]=^{}-.\]

Our framework is a formalization of the following observation. The statement

(S1) Given any \(\) we can find some \(=()\) such that \(^{} 0\).

implies the following

(S2) There exists \(^{*}\) such that \((^{*})^{} 0\) for all \(\).

This follows from the minimax theorem (Neumann, 1928), as the first statement (S1) is equivalent to \(_{}_{}^{} 0\), while the second statement (S2) is equivalent \(_{}_{}^{} 0\).

We are interested in the following question: _"Is there an efficient algorithm that when given access to an oracle for (S1), it constructs a solution \(^{*}\) for (S2) represented as a mixture of a small number of oracle responses?"_.

### Good-Enough-Response (GER) oracle

We begin by formally defining the oracle we presented previously, which we coin a Good-Enough-Response (GER) oracle. It is defined as follows:

\[():\\ \ \ (,^{})^{N} \ \ \ \ \ ^{}=0\]

where \(^{N}\), and \(=0\) as was discussed earlier. Note that this is not a best-response oracle, because it does not return an \(\) that maximizes the utility of the max-player. Rather, it suffices to return a "good enough response", hence the name.

In fact, our algorithms will often need to query a GER oracle for \(^{}_{+}\) and not just for vectors in \(\). This however is not a problem because it suffices to find any \(=^{}/\) for some \(>0\) and \(\) and then query \(()\) instead. To find such a \(\) efficiently we can again, without loss of generality, assume that all vectors \(\) are augmented with an extra dimension (call it \([]\)) such that \([]=1\) for all \(\). Then we can find the desired scaling factor immediately because \(^{}[]=\) if and only if \(^{}=\) for \(\).

In addition to a good-enough-response oracle, our algorithm also requires a separation oracle \(_{}\) for the polytope \(\), which can be easily converted to a separation oracle for \(_{+}\) by the same "augmenting" argument as before. Combining these two, we can make the final separation oracle (Algorithm 2) that is needed to execute the ellipsoid method on (\(D\)), as presented later. Specifically, if \(_{+}\) then we simply return a separating hyperplane via \(_{_{+}}\), else we return a good-enough-response from \(\).

### The framework

Our goal is to compute an \(\) that is an optimal (min-max) strategy for the max-player. Equivalently, we seek to find a solution to the following linear program

\[\ _{} ^{} 0\] ( \[P\] )

This is an LP with \(M\) variables which is typically assumed to be much greater (even super-exponentially greater) than \(N\). When faced with this situation, one might want to attempt to directly solve the dual of (\(P\)) using the ellipsoid method. However, this would require a proper separation oracle for the dual problem, which corresponds to a linear optimization oracle, or at least a best-response oracle. But as we explained, the oracle access we have is weaker.

Instead, we focus on the below linear program. Note that for any \(_{+}\), \(()\) should always return an \(\) such that \((^{}) 0\), which is a violated constraint of (\(D\)). Thus, we can combine \(\) and a separation oracle for \(_{+}\) (as in Algorithm 2) to make a separation oracle for this LP.

\[_{+}\ _{ }^{}-1\] ( \[D\] )

By the Generalized Farkas lemma (Lemma B.2) and the fact that (\(P\)) is feasible, it immediately follows that (\(D\)) must be infeasible. Despite the infeasibility, and following the "Against Hope" step of Papadimitriou and Roughgarden (2008), we execute the ellipsoid method on (\(D\)) using Algorithm 2 as a separation oracle. The ellipsoid method will run for a number \(L=(N)\) of steps and then conclude that (\(D\)) is infeasible. Let \(_{1},,_{L}\) be the response vectors returned by \(\) during this process. We now consider a "compressed" version of the previous LP that only uses vectors \(\) from the convex hull \(\{_{k}\}\) of these responses.

\[_{+}\ _{ \{_{k}\}}^{}-1\] ( \[D^{}\] )

We argue that this LP must also be infeasible; the ellipsoid method is a deterministic algorithm and if we execute it on (\(D^{}\)) it will go through the same sequence of candidate points \(_{k}\), to which we can respond with the same sequence of separating hyperplanes as before. These hyperplanes will still be valid for (\(D^{}\)) because all of the response vectors we used previously exist in \(\{_{k}\}\).

Now, using Generalized Farkas lemma (Lemma B.2) again and the fact that (\(D^{}\)) is infeasible, it follows that the LP shown below must be feasible.

\[\{_{k}\}\ _{ }^{} 0\] ( \[P^{}\] )

This is a "compressed" version of (\(P\)), because now every vector \(\{_{k}\}\) can be represented as a vector of size \(L\) that corresponds to a convex combination of the response vectors \(_{1},,_{L}\). Finally, since (\(P^{}\)) is an LP with only a polynomial number of variables, we can solve it in polynomial time using any LP algorithm. This will clearly be a feasible solution for our initial LP (\(P\)), because \(\{_{k}\}\). The full algorithm is shown below, in Algorithm 1. Note that in reality we only use the LPs (\(D\)) and (\(P^{}\)). The rest were used as intermediate steps for the presentation of the algorithm.

```
0: Separation oracle \(_{_{+}}\) for \(_{+}\), and a good-enough-response oracle \(\).
0: A sparse solution \(^{*}\) of (\(P\)) represented as a mixture of \(\) oracle responses. Execute the ellipsoid method on (\(D\)), using Algorithm 2 as a separation oracle;  Create (\(P^{}\)) using the response vectors and compute a feasible solution \(^{*}\); ```

**Algorithm 1**Ellipsoid Against Hope for bilinear zero-sum games

**Theorem 3.1**.: _If the following hold_

1. \(^{M},^{N}\) _are rational polytopes and_ \(\) _has facet-complexity at most_ \(\)_,_
2. _we have access to a separation oracle_ \(_{}\) _for_ \(\) _and a good-enough-response oracle_ \(\)_,_
3. _the encoding length of_ \(^{}\) _is at most_ \(\) _for all_ \(\) _oracle responses and all vertices of_ \(\)_,_

_then Algorithm 1 runs in \((N,)\) time, performs \(L=(N,)\) oracle calls, and computes an exact solution \(^{*}\) of (\(P\)) that is a mixture of at most \(N\) oracle responses. In particular, the encoding length of \(^{*}\) depends polynomially on the encoding length of the \(\) oracle responses._Note that since we have assumed that \(M N\), it would not make sense for the final solution \(^{*}\) to have encoding length \((M)\), as this would invalidate the whole algorithm. In order for the solution to make sense, the GER oracle must only give responses with low encoding length. This is exactly the case in Section 4, where \(M\) is a doubly-exponential quantity in the size of the problem, while the GER responses are vectors with only one non-zero entry.

## 4 Computing linear \(\)-equilibria in polynomial time

We have seen in Section 3 how one can compute exact min-max equilibria using good-enough-response (GER) oracles. Now it is time to apply this machinery in the problem of computing _exact_\(\)-equilibria in polyhedral games. Crucially, the factor that enables us to utilize the framework of Section 3 is the existence of an efficient GER oracle, which effectively boils down to constructing a product distribution consisting of fixed-points for the strategies of every player of the game.

Let \(G\) be any polyhedral game (Definition 2.4) with \(n\) players and strategy sets \(_{p}^{d_{p}}\) for \(p[n]\). In this section we apply the framework we developed previously to construct an algorithm that computes an exact \(\)-equilibrium of \(G\) in polynomial time when \(\) is a polytope containing valid linear transformations from polyhedral strategies to polyhedral strategies. Notable examples of sets with these properties are the trigger deviations used for EFCE (Farina et al., 2022), and the linear-swap deviations used for LCE (Farina and Pipis, 2023) in extensive-form games.

The general idea of our construction is that of the existence proof by Hart and Schmeidler (1989) that casts the problem of \(\)-equilibrium computation as one of computing a min-max equilibrium in a two-player zero-sum meta-game between a "Correlator", who acts upon the simplex of all pure strategy profiles, and a "Deviator", whose actions correspond to deviations for every player. We call this a _Correlator-Deviator game_.

To make this idea applicable to polyhedral games, we generalize it as follows. We define a bilinear zero-sum meta-game with strategy sets \(,\) for the two players, where \(\) is the set of all joint distributions over strategy profiles, \(=(_{1}_{n})\) (hence, a polytope) and \(\) is the Cartesian product of \(_{p}\) for all players \(p\), \(=_{1}_{n}\), which is a convex set - and in our case, a polytope.

We remark here that linear transformations \(_{p}\) can be represented using a matrix \(_{p}\) such that \(_{p}(_{p})=_{p}_{p}\). Thus, when we say that \(_{p}\) is a polytope, it means that there exists a system of inequalities that can describe the entries of the corresponding matrix \(_{p}\) for every \(_{p}_{p}\). For notational convenience, we will interchangeably use \(_{p}\) to denote either the set of transformation functions, or a polytope describing the vectors (flattened \(_{p}\) matrices) that correspond to transformations. In any event, it should not matter which of the two representations we have, because they are completely equivalent.

The utility matrix \(\) of the Correlator in the meta-game is shown below. Specifically, it has one row for each pure strategy profile \(_{1}_{n}\), and one column for each tuple \(j=(p,a,b)\), where \(a,b[d_{p}]\) are used as indices over strategy vectors \(_{p}_{p}\). Additionally, we always want the final expression to have a quantity (\(_{p}_{s}[u_{p}(s)]\)) that is independent of the value of \(\). To achieve this we can use a trick similar to the one used to make \(=0\) in Section 3 by augmenting vectors \(\) with an extra dimension \(\) such that \([]=1\) always holds. Then we have 4

\[_{sj}=\{_{p}u_{p}(s),&j=\\ -_{p}[a]u_{p}(_{b},_{-p}),&.\]

where \(_{b}\) denotes the vector having all 0, apart from index \(b\), which is \(1\). Note that the number of rows of \(\) might be doubly-exponential (exponential both in the number of players and the dimension of the polyhedral strategies), which is in contrast to the original Ellipsoid Against Hope algorithm that only allowed a number of rows exponential in the number of players.

**Lemma 4.1**.: _Let \(G\) be a polyhedral game with pure strategy set \(_{p}\) for every player \(p[n]\). Additionally, let \(_{p}\) be a set of linear transformations for every \(p[n]\). If \(=(_{1}_{n})\) and \(=(_{1},,_{n})=_{1}_ {n}\) then_

\[^{}=_{p}}{}[u_{p}( s)-u_{p}(_{p}(_{p}),_{-p})].\]It is now evident that our goal is to compute a joint distribution that is a solution to the following linear program: find \(\) s.t. \(_{}^{} 0\).

Observe that this is slightly different from the required non-negativity in Definition 2.6; there we want the individual (per-player) expectations to be non-negative, while here it suffices for the minimum of the _sum_ of expectations to be non-negative. However, we can assume without loss of generality that the identity transformation is always a valid transformation5. Then, every LP solution \(\) will satisfy \(^{} 0\) for all \(\), including \(=(_{1},,,),(,_{2},, ),\) that correspond to to the individual expectations.

The previous LP respects exactly the structure of (\(P\)) that our min-max framework can handle. The only remaining component to get a polynomial-time algorithm is to have an efficient good-enough-response oracle \(\). Specifically, for any valid \(\), we need to respond with an \(\) such that \(^{} 0\). The important insight that allows us to construct an efficient oracle and uncover sparse solutions is that we can always find such an \(\) that is a product distribution -- similar to the original Ellipsoid Against Hope algorithm (Papadimitriou and Roughgarden, 2008) that was based on the observation by Hart and Schmeidler (1989). Note that we can always represent a product distribution by simply specifying its marginals and those, in turn, can always be represented as polyhedral strategies. Thus, representing the product distribution \(\) only requires linear space in the game size.

Next, we define an important property that a game must have to enable the efficient implementation of the \(\) oracle we propose (Lemma D.1) for our algorithm.

**Assumption 4.2** (Polynomial utility gradient property).: _Given a product distribution \((_{1}_{n})\), it is possible to compute the value of_

\[_{p}(_{-p})=*{}_{_{-p}_{-p }}[ u_{p}(_{-p})]\]

_for all players \(p[n]\) in polynomial time in the encoding length of \(\) and the size of the game._

This assumption generalizes the polynomial expectation property defined in Papadimitriou and Roughgarden (2008) to more general, polyhedral games. In particular, if we have a normal-form game, the polynomial expectation property amounts to computing \(_{p}(_{-p})_{p}\) for a product distribution \(\). Moreover, as we stated in the introduction, this assumption is very natural for one more reason; it is implicitly assumed in every no-regret learning algorithm.

**Remark 4.3**.: _Papadimitriou and Roughgarden (2008) also defined a second property that is required for efficient computation, called the "polynomial type" property. Even though our algorithm does not require this property, a variant of it is implicit in the fact that the complexity of the algorithm depends polynomially in the number of players and the dimension of every player's strategy set \(_{p}\). However, this relaxation is what allows our algorithm to handle much broader classes of games, such as the extensive-form games that do not have the polynomial type property._

**Theorem 4.4**.: _Let \(G\) be a polyhedral game (Definition 2.4) of \(n\) players and \(\{_{p}\}\) be a collection of polytopes corresponding to sets of linear strategy transformations that map every strategy set \(_{p}\) to itself. Additionally, let \(N=_{p}d_{p}^{2}\). Assume that_

* _there exist polynomial-time separation oracles for_ \(_{p}\) _and_ \(_{p}\)_,_
* \(G\) _satisfies the polynomial utility gradient property (Assumption_ 4.2_),_
* \(\) _is an upper bound on the facet-complexity of every_ \(_{p}\) _and_ \(_{p}\)_,_
* \( u\) _is the maximum encoding length of the utilities of_ \(G\)_._

_Then there exists an algorithm that computes an exact \(\{_{p}\}\)-equilibrium of \(G\) in time \((N, u,)\) and performs \((N, u,)\) number of calls to all the separation oracles. Additionally, the equilibrium is represented as a convex combination of at most \(N\) pure strategy profiles._

As a first application of this framework, we argue that it can be applied to normal-form games that satisfy the polynomial type and the polynomial expectation property, defined in Papadimitriou and Roughgarden (2008).

**Corollary 4.5** (Exact CE in normal-form games).: _If a normal-form game \(G\) has the polynomial type and the polynomial expectation property, defined in Papadimitriou and Roughgarden (2008), then our algorithm computes an exact correlated equilibrium of \(G\) and runs in polynomial time in the size of the game._

As we have discussed, a very notable example of polyhedral games is that of extensive-form games. Next, we apply Theorem 4.4 to this class of games, and specifically to the set of all linear-swap deviations, recently defined in Farina and Pipis (2023). In particular, this set contains all trigger deviations and thus, our algorithm also produces an extensive-form correlated equilibrium (EFCE) in a conceptually simpler manner than in the early work of Huang and von Stengel (2008).

**Corollary 4.6** (Exact LCE computation).: _There exists an algorithm that runs in \((N, u)\) time and computes an exact linear-deviation correlated equilibrium (LCE) in an extensive-form game._

Finally, we prove in Theorem 4.7 that, at least in the case of computing \(\)-equilibria in polyhedral games, the use of a GER over a best-response oracle is not just more elegant, but it is also necessary because constructing a best-response oracle is NP-hard. At the heart of our hardness result lies a reduction from SAT to equilibrium computation in extensive-form games that has also been used in the past to prove the hardness of equilibrium selection for EFCE and LCE (von Stengel and Forges, 2008; Farina and Pipis, 2023). In a sense, constructing a best-response oracle is as hard as the equilibrium selection problem, while constructing a good-enough-response oracle amounts to computing fixed-points of strategy transformation functions. This further highlights the importance of having a framework akin to the one presented in Section 3 for designing new algorithms; the hardness result rules out solutions that require responses competitive against _any_ threshold, but sometimes it is sufficient to only compete with a particular good-enough threshold.

**Theorem 4.7** (Hardness of BR oracle).: _It is NP-hard to construct a best-response oracle for the Correlator in the Correlator-Deviator game._

## 5 Discussion and Future Work

In this paper, we devise a polynomial-time algorithm for computing min-max equilibria in bilinear zero-sum games, by utilizing a good-enough-response oracle. We use this machinery to develop a simple general framework for the _exact_ computation of \(\)-equilibria in polyhedral games for sets \(\) of linear strategy transformations. This framework parallels that of Gordon et al. (2008) on no-regret dynamics, but for exact equilibrium computation. Applying this to extensive-form games, we construct the first polynomial-time algorithm for computing exact linear-deviation correlated equilibria in extensive-form games - a question that had been left open by Farina and Pipis (2023).

We believe that having a simple framework to use as a mental model to guide algorithm design is of paramount importance for the advancement of the field. The \(\)-regret minimization framework of Gordon et al. (2008) is indicative of this fact, because it has been key to many interesting results over the years (Morrill et al., 2021; Farina et al., 2022; Anagnostides et al., 2022; Farina and Pipis, 2023). Compared to no-regret learning, the problem of exact equilibrium computation has been much less studied (basically only in Papadimitriou and Roughgarden (2008); Jiang and Leyton-Brown (2015); Huang and von Stengel (2008)) and we hope that offering a simplified framework will give new insights to advance this front, perhaps aiding in the discovery of new, more practical, algorithms.

Several key questions remain underinvestigated.

* Despite its great theoretical importance, our framework (based on the ellipsoid algorithm) has a polynomial time complexity of rather large degree. Could one devise a more practical alternative while retaining a similar level of generality?
* Can our framework be easily generalized to convex strategy spaces (instead of polytopes)?
* Is there a similar algorithmic framework to compute exact \(\)-equilibria in extensive-form games for non-linear transformations \(\)? In recent work, Zhang et al. (2024a) give parameterized algorithms for minimizing \(\)-regret when \(\) is the set of all degree-\(k\) polynomial swap deviations. Can similar guarantees be achieved for high-precision computation of these \(\)-equilibria?
* Can ideas similar to those presented in this paper be applied to Markov games?