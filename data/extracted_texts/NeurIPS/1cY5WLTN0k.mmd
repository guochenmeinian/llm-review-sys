# Monte Carlo Neural PDE Solver

Anonymous Author(s)

Affiliation

Address

email

###### Abstract

Training neural PDE solver in an unsupervised manner is essential in scenarios with limited available or high-quality data. However, the performance and efficiency of existing methods are limited by the properties of numerical algorithms integrated during the training stage (like FDM and PSM), which require careful spatiotemporal discretization to obtain reasonable accuracy, especially in cases with high-frequency components and long periods. To overcome these limitations, we propose Monte Carlo Neural PDE Solver (MCNP Solver) for training unsupervised neural solvers via a Monte Carlo view, which regards macroscopic phenomena as ensembles of random particles. MCNP Solver naturally inherits the advantages of the Monte Carlo method (MCM), which is robust against spatial-temporal variations and can tolerate coarse time steps compared to other unsupervised methods. In practice, we develop one-step rollout and Fourier Interpolation techniques that help reduce computational costs or errors arising from time and space, respectively. Furthermore, we design a multi-scale framework to improve performance in long-time simulation tasks. In theory, we characterize the approximation error and robustness of the MCNP Solver on convection-diffusion equations. Numerical experiments on diffusion and Navier-Stokes equations demonstrate significant accuracy improvements compared to other unsupervised baselines in cases with highly variable fields and long-time simulation settings.

## 1 Introduction

Neural PDE solvers, which leverage neural networks as surrogate models to approximate the solutions of PDEs, are emerging as a new paradigm for simulating physical systems with the development of deep learning [33; 31; 23; 12]. Along this direction, several studies have proposed diverse network architectures for neural PDE solvers [30; 33; 5]. These solvers can be trained using supervised [33; 30] or unsupervised approaches [59; 54; 32], employing pre-generated data or PDE information to construct training targets, respectively. The unsupervised training approach is essential for AI-based PDE solvers, particularly in scenarios with limited available or high-quality data. To address this, some studies [54; 32] borrow techniques from classical numerical solvers to construct training targets. For instance, the low-rank decomposition network (LordNet)  and physics-informed neural operator (PINO)  integrate finite difference method (FDM) and pseudo-spectral methods (PSM) with neural networks during the training stage, respectively. However, FDM and PSM require fine meshes or time steps for stable simulations in general. Therefore, the performance and efficiency of these neural PDE solvers are also limited by the discretization of time and space, particularly when handling highly spatial-temporal variations and simulating physical systems over long periods.

To this end, we propose Monte Carlo Neural PDE Solver (MCNP Solver) for training neural solvers from a Monte Carlo perspective, which regards macroscopic phenomena as ensembles of random movements of microscopic particles . Consequently, for a PDE system with probabilistic representation, MCNP Solver constructs its solutions as training targets via Monte Carlo approximation.

Compared to other unsupervised neural solvers, such as LordNet  and PINO , MCNP Solver naturally inherits the advantages of MCM. On the one hand, MCNP Solver can tolerate coarse time steps [11; 39], thereby reducing training costs and accumulated errors arising from temporal discretization. On the other hand, it can efficiently handle high-frequency spatial fields due to the derivative-free property of MCM [37; 1]. Moreover, the boundary conditions are automatically encoded into the stochastic process of particles [2; 34], eliminating the need to introduce extra loss terms to satisfy such constraints. In addition to inherting the benefits of MCM, we also develop one-step rollout and Fourier Interpolation techniques to improve performance and efficiency from the perspective of time and space. Furthermore, we design a multi-scale framework to improve the accuracy and robustness of the MCNP Solver in long-time simulation tasks.

Compared to traditional MCM, MCNP Solver enjoys a significantly faster inference speed once trained. Additionally, traditional MCM requires sampling excess particles to achieve high-precision results, which can lead to severe computational and memory issues. However, thanks to the involvement of neural networks, the MCNP Solver does not necessitate sampling as many particles per epoch during training. According to our experimental observations, the model can converge as expected using gradient descent with only a few particles.

In this paper, we conduct in-depth analyses of the MCNP Solver's performance theoretically and experimentally. In summary, we make the following contributions:

1. We introduce MCNP Solver, a novel Monte Carlo-based unsupervised approach for training neural solvers applicable to PDE systems that allow probabilistic representation. Additionally, we develop several techniques to enhance performance and efficiency, such as Fourier Interpolation, one-step rollout, and multi-scale prediction.
2. Theoretically, we compare the approximation error and robustness of two kinds of neural PDE solvers concerning variations in spatial conditions, temporal discretization steps, and diffusive coefficients. Our theoretical results reveal that MCNP Solver is more robust against the spatial-temporal variants when solving convection-diffusion equations.
3. Our experiments on the diffusion and Navier-Stokes equation (NSE) show significant improvements in accuracy compared to other unsupervised neural solvers for simulating tasks with complex spatial-temporal variants and long-time simulation. Furthermore, the MCNP Solver can obtain comparable or even better results than supervised neural solvers.

## 2 Related Work

Neural PDE SolverNeural PDE solvers have been proposed to learn mappings between functional spaces, such as mapping a PDE's initial condition to its solution . Works like DeepONet  and its variants [15; 52; 57; 26] encode the initial conditions and queried locations using branch and trunk networks, respectively. Additionally, Fourier Neural Operator (FNO)  and its variants [29; 45; 56] explore learning the operator in Fourier space, an efficient approach for handling different frequency components. Several studies have employed graph neural networks [30; 5] or transformers [6; 28] as the backbone models of neural solvers to adapt to complex geometries. However, these methods require the supervision of ground-truth data generated via accurate numerical solvers, which can be time-consuming in general. To this end, some studies aim to train the neural PDE solvers without the supervision of data [59; 32; 54; 19]. For example,  proposed PI-DeepONets, which utilize the PDE residuals to train DeepONets in an unsupervised way. Similarly,  proposed Meta-Auto-Decoder, a meta-learning approach to learn families of PDEs in the unsupervised regime. Furthermore, LordNet  and PINO  borrow techniques from FDM and PSM, and utilize the corresponding residuals as training loss, respectively. Compared to these unsupervised methods, the MCNP Solver incorporates physics information through the Feynman-Kac law, representing a Monte Carlo perspective. This approach allows the solver to efficiently manage diffusion terms, exhibit robustness against spatial-temporal variants, and be suitable for long-time simulations.

Physics-Informed Neural Networks (PINNs)PINNs have been proposed to solve PDE systems by approximating solutions using the PDE residuals, which involve point-to-point mapping between spatial-temporal points and solution values. They are widely employed for solving forward or inverse problems [46; 8; 22; 66]. Recently, PINNs have made significant progress in addressing scientific problems based on PDEs, including NSEs [47; 20; 36], Schrodinger equations [18; 27], Allen Cahnequations [38; 21], and more. Instead of constructing the loss function directly via the PDE residuals, some works utilize the probabilistic representation to train neural networks [17; 14; 63], which can efficiently handle high-dimensional or fractional PDEs [16; 50; 14; 49; 41]. Furthermore, some studies design loss functions based on other numerical methods, such as the finite volume method , finite element method [40; 42], and energy-based method . Notably, the aforementioned PINN methods require retraining neural networks when encountering a PDE with new initial conditions, which can be time-consuming. Moreover, the studies [3; 48] consider PDE families with varying initial conditions while requiring corresponding conditions can be represented by a low-dimensional vector. In this paper, we aim to learn operators between functional spaces that can generalize to different PDE conditions over a distribution. When applying Feynman-Kac laws to this new scenario, we encounter several computational challenges arising from corresponding tasks, such as higher generalization requirements, long-time simulations, and the non-linearity of PDEs. Therefore, we propose Fourier Interpolation, one-step rollout, and multi-scale prediction to overcome these issues. More detailed discussions of these Feynman-Kac-based PINNs can be seen in Appendix D.

## 3 Methodology

### Preliminary

In this paper, we consider the general convection-diffusion equation defined as follows:

\[=[u](,t) u+  u+f(,t), u(,0)=u_{0}(),\] (1)

where \(^{d}\) and \(t\) denote the \(d\)-dimensional spatial variable and the time variable, respectively, \([u](,t)^{d}\) is a vector-valued mapping from \(u\) to \(^{d}\), \(^{+}\) is the diffusion parameter, and \(f(,t)\) denotes the force term. Many well-known PDEs, such as Burgers' equation, NSE, can be viewed as a special form of Eq. 1.

For such PDEs with the form as Eq. 1, the Feynman-Kac formula provides the relationship between the PDEs and corresponding probabilistic representation [43; 44; 16]. In detail, we can use the time inversion (i.e., \((,t)=u(,T-t),(,t)=f(,T-t)\)) to the PDE as:

\[}{ t}=-[](,t) --(,t),(,T)=u_{0}().\] (2)

Applying the Feynman-Kac formula  to the terminal value problem Eq. 2, we have

\[_{0}()=[_{T}(}_{T})+ _{0}^{T}(}_{s},s)ds],\] (3)

where \(}_{s}^{d}\) is a random process starting at \(\), and moving from \(0\) to \(T\), which satisfies:

\[d}_{s}=[](}_{s},s)ds+d_{s},}_{0}=,\] (4)

where \(_{s}\) is the \(d\)-dimensional standard Brownian motion. Applying time inversion \(t T-t\) to Eq. 3 and letting \(\) be the inversion of \(}\), we have

\[u_{T}()=[u_{0}(_{0})+_{0}^{T}f(_{s},s) ds].\] (5)

Furthermore, apart from Eq. 1, some other PDEs can also be handled via the Feynman-Kac formula after certain processing, like wave equations  and spatially varying diffusion equations .

### Monte Carlo Neural PDE Solver

Given a PDE with the form of Eq. 1 and a distribution of the initial conditions \(_{0}\), the target of MCNP Solver is to learn a functional mapping \(_{}\) with parameter \(\) which can simulate the subsequent fields for all initial fields \(u_{0}_{0}\) at time \(t[0,T]\). In detail, the inputs and outputs of \(_{}\) are given as:

\[_{}:_{0}[0,T] _{[0,T]},\] (6) \[(u_{0},t)  u_{t},\]where \(_{[0,T]}\) denotes the joint distribution of the field after \(t=0\). Unlike other supervised operator learning algorithms [27; 33; 5], MCNP Solver aims to learn the operator in an unsupervised way, i.e., only utilize the physics information provided by PDEs. To this end, MCNP Solver considers training the solver via the relationship between \(u_{t}\) and \(u_{t+ t}\) (where \(0 t<t+ t T\)) derived by the aforementioned probabilistic representation. Considering Eq. 5, an expected neural operator \(_{}\) should satisfy the following equation:

\[_{}(u_{0},t+ t)()=_{}[ _{}(u_{0},t)(_{t})+_{t}^{t+ t}f(_{ s},s)ds],\] (7)

where \(_{s}(s[t,t+ t])\) is the inverse version of stochastic process in Eq. 4 as follows:

\[d_{s}=-[u](_{s},s)ds-d_{s}, _{t+ t}=.\] (8)

Regarding Eq. 7 as the optimization objective, the neural Monte Carlo loss can be written as follows:

\[_{}(_{}|u_{0},t, t)=\| _{}(u_{0},t+ t)()-_{}[ _{}(u_{0},t)(_{t})+_{t}^{t+ t}f(_ {s},s)ds]\|_{2}^{2}.\] (9)

Equipped with the loss function Eq. 9, we sample the initial states \(u_{0}\) from \(_{0}\) and the time \(t\) from \([0,T]\) each epoch, and the MCNP loss \(_{}\) is given as follows:

\[_{}=_{u_{0}_{0}}[ _{}(_{}|u_{0})+_{t[0,T]}[ _{}(_{}|u_{0},t, t)]],\] (10)

where \(^{+}\) is a hyper-parameter, and \(_{}(_{}|u_{0})\|_{}(u_{0},0)-u_{0}\|_{2}^{2}\) denotes the loss at \(t=0\).

### Implementation Details of MCNP Solver

In this section, we introduce some important implementation details for MCNP Solver. We illustrate the framework and training process of MCNP Solver in Fig. 1 and the overall algorithm in Appendix A. We design one-step rollout and Fourier Interpolation trick to reduce the computational cost and error from the perspectives of time and space, respectively. Moreover, we conduct the multi-scale framework to improve the long-time simulation ability of MCNP Solver.

Temporal Discretization and One-Step RolloutWhen simulating the stochastic process in Eq. 8, we utilize the classical Euler-Maruyama method  to approximate corresponding SDEs,.i.e,

\[_{t}=_{t+ t}+[u](_{t+ t},t+  t) t+_{t},_{t+ t}= .\] (11)

Figure 1: **Illustration of the neural Monte Carlo loss.** We construct the training loss via the relationship between \(u_{t}\) and \(u_{t+ t}\) given by the Feynman-Kac law. **A:** random walk according to Eq. 11, and denote the \(M\) particles starting at the grid point \(\) as \(\{_{s}^{m}\}_{m=1}^{M}\); **B:** when \(_{s}^{m}\) moving from \(t+ t\) to \(t\), project each \(_{t}^{m}\) to the nearest coordinate point \(}_{t}^{m}\) in the high resolution coordinate system; **C:** query the value of each \(}_{t}^{m}\) via \(_{t}\) and average \(_{t}(}_{t}^{m})\) as \(_{m=1}^{M}_{t}(}_{t}^{m})\). Please note that the high-resolution \(_{t}\) is obtained from \(u_{t}\) via Fourier interpolation. Then, the neural Monte Carlo loss at \(\) is given by: \(\|_{}(u_{0},t)()-_{m=1}^{M}_{t}( }_{t}^{m})\|_{2}^{2}\).

The stochastic integral of the force \(f\) in Eq. 7 is approximated via the Euler method, which aligns with . Unlike other Feynman-Kac-based methods [16; 41] conducting random walks in Eq. 8 with multi-steps, we utilize one-step rollout technique to simulate SDEs, i.e., at each \(t+ t\), MCNP Solver generates new particles from \(\), and moves them back to \(t\) according to Eq. 11. The one-step rollout trick can enforce all \(_{t+ t}\) starting at \(\) share the same \([u](,t+ t)\) during the simulation of SDEs and thus, reduce the computational cost, especially for the scenario when the calculation cost of \(\) is expensive. For instance, when the drift \(\) term depends on solution \(u\), we have to utilize MCNP Solver to calculate \(\) accordingly. Moreover, in the NSE conducted in this paper, the mapping \(u\) represents the transformation from the vorticity field to the velocity field, which involves a numerical integration over an entire domain.

Random Walks and Boundary ConditionsEq. 3 and Eq. 4 describe the random walks driven by stochastic processes of corresponding PDEs. For PDEs with periodical boundary conditions, particles should be pulled back according to the periodical law when walking out of the domain \(\). For Dirichlet boundary conditions, the random walk of particles should stop once they reach the boundary. Compared to other unsupervised neural PDE solvers, MCNP Solver encodes the boundary conditions naturally into the random walks of particles and thus does not need additional soft constraints in the loss function. Furthermore, for PDEs with the fractional Laplacian \(-(-)^{}u\), where \((0,2)\), we only need to replace the Brownian motion with the \(\)-stable Levy process [65; 24; 64].

Spatial Discretization and Fourier InterpolationIn this paper, we are interested in the evolution of PDEs at fixed grids \(\{_{p}\}_{p=1}^{P}\). Consequently, the inputs and outputs of the solver \(_{}\) are solution values at \(P\) coordinate points. Please note that in Eq. 7, the particles \(_{t}\) need to query the value of \(_{}(u_{0},t)\) when approximating \(_{}(u_{0},t+ t)\). To efficiently obtain the querying results, we project the locations of particles \(_{t}\) to their nearest neighbor grids in practice. To reduce projection errors, we utilize the Fourier transform to interpolate the fields \(u_{t}=_{}(u_{0},t)\) to the high-resolution one \(_{t}\) before the projection. It is worth mentioning that the Fourier Interpolation technique can help the neural solver achieve high-accuracy training signals without the calls of solvers on the high-resolution PDE fields, thereby reducing the training cost.

Multi-Scale Framework for Long-Time SimulationWhen handling tasks with long temporal intervals, we design the following multi-scale framework to make the training process more robust. In detail, we divide the long-time interval \([0,T]\) into \(K\) coarse subintervals, i.e., \(\{[T_{k},T_{k+1}]\}_{k=0}^{K-1}\), with \(T_{0}=0\), \(T_{K}=T\) and \(T_{k+1}-T_{k}= T\). Accordingly, we adopt \(K\) neural solvers \(\{_{_{k}}\}_{k=0}^{K-1}\) with independent parameter \(_{k}\) to approximate the solution in \([T_{k},T_{k+1}]\), respectively. In the training stage, the loss function for long-time simulation is given as follows:

\[_{}^{}=_{u_{0}_{0}}[_{k=0}^{K-1}_{}(_{_{ k}}|u_{T_{k}})+_{k=0}^{K-1}_{t[T_{k},T_{k+1}]}[ _{}(_{_{k}}|u_{T_{k}},t, t)] ].\] (12)

Here, \(u_{T_{k}}=_{_{k-1}}(u_{T_{k-1}}, T)\) can be calculated recursively with \(u_{T_{0}}=u_{0}\), and \(_{}(_{_{k}}|u_{T_{k}})\| _{_{k}}(u_{T_{k}},0)-[u_{T_{k}}]\|_{2}^{2}\) denotes the initialization loss for \(_{_{k}}\), where \([]\) denotes the stop-gradient operator. In the inference stage, when predicting the PDE field with the initialization \(u_{0}\) at \(t=T_{k}+ t(0< t< T)\), we first rollout with coarse step \( T\) to obtain \(u_{T_{k}}\), and then adopt the finer step to give the prediction of \(u_{t}\) as \(_{_{k}}(u_{T_{k}}, t)\). Due to the independent parameterization and stop-gradient operator, the proposed multi-scale framework can prevent the prediction at time \(t^{}\) from producing harmful effects on the former time \(t<t^{}\) in the optimization stage. Our experiments reveal that it can improve the performance on long-time simulation tasks where the PDE fields change dramatically over time (e.g., turbulent flow simulation).

## 4 Theoretical Results

In this section, we study the theoretical properties of MCNP Solver when simulating the convection-diffusion equation, and the proof can be seen in Appendix B. In detail, we consider the periodical convection-diffusion equation defined as follows:

\[= u+ t, x[0,2],\ t [0,T],\ .\] (13)In the following main theorem, we consider the error of one-step rollout targets provided in PSM and MCM when training neural PDE solvers, respectively.

**Theorem 4.1**: _Let \(u_{t}(x)\) be solution of the convection-diffusion equation in the form of Eq. 13, and assume the exact solution at time \(t\) can be expressed by the Fourier basis, i.e., \(u_{t}(x)=_{n=1}^{N}a_{n}(nx)\). Let \(_{}\) be the neural PDE solver, and its prediction on \(u_{t}(x)\) can be written as \(_{}(u_{0},t)(x)=_{n=1}^{N}(a_{n}+_{n})(nx)\), where \(_{n}\) denotes the residual of coefficient on each Fourier basis. Let \(H\) and \(M\) denote the grid size after Fourier Interpolation and sampling numbers in neural Monte Carlo loss. Let \(u_{t+ t}^{}(x)\) and \(u_{t+ t}^{}(x)\) be the one-step labels starting from \(_{}(u_{0},t)(x)\), given by PSM and MCM, respectively. Assume \(_{t}u\) and \(u_{t}(x)\) are Lipschitz functions with respect to \(t\) and \(x\), respectively, i.e.:_

\[|_{t_{1}}u(x)-_{t_{2}}u(x)| L_{ u}^{t}|t_{1}-t_{2}|, |u_{t}(x_{1})-u_{t}(x_{2})| L_{u}^{x}|x_{1}-x_{2}|.\] (14)

_Then, we have_

1) \(u_{t+ t}^{}(x)-u_{t+ t}(x) ^{t} t^{2}}{2}}_{_{1}^{ }}+^{N}|_{n}( n^{2} t-1)|}_ {_{2}^{}}\)_;_
2) With probability at least_ \(1-^{x})^{n} t}{M^{2}}\)_, we have_

\[u_{t+ t}^{}(x)-u_{t+ t}(x) {_{n=1}^{N}|na_{n}|}_{_{1}^{}}+ ^{N}|_{n}|}_{_{2}^{}}+ \] (15)

In the PSM, error terms \(_{1}^{}\) and \(_{2}^{}\) arise from the temporal discretization and the perturbation of \(_{}(u_{0},t)\), respectively. Additionally, the error term \(_{2}^{}\) increases with the rate of \(n^{2}\), where \(n^{2}\) comes from the second order derivative of \((nx)\). To mitigate the error induced by the PSM, one has to decrease \( t\), which inevitably necessitates additional calls to classical or neural solvers. Conversely, for MCM, the error term \(_{1}^{}\) originates from the Fourier Interpolation trick, which can be controlled by increasing the interpolation rate. This operation does not consume much time because it does not require extra solver calls. Moreover, the error caused by the residual \(_{n}\) (\(_{2}^{}\)) remains stable as \(n\) grows due to the derivative-free property of MCM. It is worth noting that while \(_{3}^{}\) can be controlled by the number of samples \(M\), an excessive number of particles is not required in practice. Unlike deterministic biases introduced by other error terms, \(_{3}^{}\) stems from the variance of random processes and can be regarded as a type of stochastic label noise. Some studies [7; 10] have found that such stochastic label noise can aid generalization and even counteract inherent biases. Therefore, we assert that, compared to PSM, the neural Monte Carlo method can tolerate coarser time steps and spatial variations when solving convection-diffusion equations.

## 5 Experiments

In this section, we conduct numerical experiments to evaluate the proposed MCNP Solver on two tasks: 1D diffusion equations and 2D NSEs. Implementation details are introduced in Appendix E. We utilize the FNO  as the backbone network, with more detailed discussions in Appendix C. We evaluate the model performance for all tasks via the relative \(_{2}\) error on 200 test PDE samples. We repeat each experiment with three random seeds in \(\{0,1,2\}\) and report the mean value and variance. All experiments are implemented on an NVIDIA A100 GPU.

### 1D Diffusion Equation

In this section, we conduct experiments on periodical 1D diffusion equation defined as follows:

\[= u(x,t),\;x,t.\] (16)

The initial states \(u(x,0)\) are generated from the functional space \(_{N}\{_{n=1}^{N}a_{n}(2 nx):a_{n}(0,1)\}\), where \((0,1)\) denotes the uniform distribution over \((0,1)\), and \(N\) represents the maximum frequency of the functional space.

Experimental SettingsIn this setting, \(\) represents the heat transfer rate, with larger \(\) values indicating faster temporal variation rates. \(N\) can be regarded as a measure of spatial complexity, where larger values correspond to a higher proportion of high-frequency signals. We select two different \(\) in \(\{0.01,0.02\}\) and \(N\) in \(\{6,12\}\), respectively, to evaluate the performance of different methods in handling temporal-spatial variations. We divide the spatial domain \(\) into \(64\) grid elements for all experiments.

BaselinesWe introduce the baselines conducted on 1D diffusion equations, including: i). **PSM**: A traditional numerical methods. We divide the time interval into 100 uniform lattices and utilize the 2nd Runge-Kutta method for temporal revolution. ii). **PSM+**: PSM with a fine step size. We divide the time interval into 2000 uniform lattices. iii). **MCM**: a traditional numerical method based on the probabilistic representation of PDEs. We set the sampling numbers as \(10^{5}\). iv). **FNO**: Training with 1000 pre-generated data, calculating from the analytic solution of Eq. 16. v). **PINO**: An unsupervised neural operator based on PSM. We divide the time interval into 100 uniform lattices. vi). **PI-DeepONet**: an unsupervised neural operator based on PINN loss and DeepONets. For **MCNP Solver**, we set the sampling numbers and the time step \( t\) as \(64\) and \(0.2\), respectively. We interpolate the spatial domain into \(1024\) elements in the Fourier Interpolation trick.

ResultsTable 1 presents each method's performance and computational cost on the 1D diffusion equation. Among all unsupervised neural PDE solvers, including PI-DeepONet and PINO, the MCNP Solver performs best on all tasks, particularly for cases with large spatial or temporal variations. Despite PINO obtaining comparable results on the simplest tasks (i.e., \(=0.01\) and \(N=6\)), its error rapidly increases on tasks with \(=0.02\) or \(N=12\), which is consistent with our theoretical results. The results of PI-DeepONet indicate that the PINN loss cannot efficiently handle high-frequency components, which has also been observed in previous literature [25; 60]. Compared to the supervised method FNO, MCNP Solver obtains comparable results on the tasks when \(N=6\) while significantly outperforming it when \(N=12\), which indicates that more data is required for FNO when handling complex spatial variants. As for classical solvers, PSM fails on all tasks because it requires a fine grid to prevent blowing up, which explains why MCNP Solver can beat PINO. Although PSM+ achieves spectral accuracy on the tasks with \(=0.01\), it still fails to achieve meaningful results when \(=0.02\). Moreover, it is more than 380 times slower than other neural solvers due to the refined step size, highlighting one of the main motivations for AI-based PDE studies. MCM's performance is limited by the variance inherent in Monte Carlo simulation, even sampling \(10^{5}\) particles. However, this stochastic label noise arising from the Monte Carlo simulation does not cause apparent harm to the MCNP Solver due to the involvement of neural networks, which is in line with the studies of label noise [7; 10]. In practice, the sampling numbers in MCNP Solver are only set as 64 per epoch, and the neural network can converge as expected with gradient descent during training.

### 2D Navier-Stokes Equation

In this experiment, we simulate the vorticity field for 2D incompressible flows in a periodic domain \(=\), whose vortex equation is given as follows:

\[=-()++f (),=,\] (17)

    &  &  &  &  \\   & \(N=6\) & \(N=12\) & \(N=6\) & \(N=12\) & Train (H) & Infer (S) & \# (M) \\  PSM & NAN* & NAN & NAN & NAN & – & 0.028 & – \\ PSM+ & 0.000448 & 0.00132 & NAN & NAN & NAN & – & 0.554 & – \\ MCM & 5.574\(\) 0.009 & 12.615\(\) 0.056 & 29.991\(\) 0.183 & 83.442\(\) 0.234 & – & 0.034 & – \\ FNO & 1.125\(\) 0.183 & 5.930\(\) 7.468 & 3.662\(\) 0.265 & 239.926\(\) 14.775 & 0.194 & 0.00145 & 0.152 \\ PINO & 1.075\(\) 0.208 & 3.563\(\) 0.684 & 5.275\(\) 2.328 & 26.735\(\) 17.878 & 0.206 & 0.00145 & 0.152 \\ PI-DeepONet & 16.224\(\) 1.165 & 112.630\(\) 18.945 & 113.212\(\) 25.875 & NAN & 2.451 & 0.00126 & 0.153 \\ MCNP & 1.056\(\) 0.194 & 1.511\(\) 0.090 & 3.727\(\) 1.587 & 6.575\(\) 1.948 & 0.116 & 0.00145 & 0.152 \\   

* Here we utilize NAN to represent the results whose relative error is larger than 200%.

Table 1: **1D diffusion equation with varying \(N\) and \(\). Relative errors (%) and computational costs for baseline methods and MCNP Solver.**where \(f()=0.1(2(_{1}+_{2}))+0.1( 2(_{1}+_{2}))\) is the forcing function, and \(^{+}\) represents the viscosity term. The initial vorticity is generated from the Gaussian random field \((0,7^{3/2}(-+49)^{-2.5})\) with periodic boundaries.

Experimental SetupsThe viscosity term \(\) can be regarded as a measure of the temporal-spatial complexity of NSE. As \(\) decreases, the nonlinear term \(()\) gradually governs the motion of fluids, increasing the difficulty of simulation. To evaluate the performance of handling different degrees of turbulence, we conduct the experiments with \(\) in \(\{10^{-3},10^{-4},10^{-5}\}\), respectively. We choose two different \(T\) in \(\{10,15\}\) to test the long-time simulation ability of each method. We divide the domain \(\) into \(64 64\) grid elements.

BaselinesWe introduce the baselines conducted on 2D NSEs, including:1 i). **PSM**: We divide the time interval into 100 (150) uniform lattices for \(T=10\)\((15)\) and utilize the Crank-Nicolson scheme for temporal revolution. ii). **PSM+**: We divide the time interval into 2000 (3000) uniform lattices for \(T=10\)\((15)\). iii). **FNO**: Training with 1000 pre-generated data, taking 0.624 hours for data generation. iv). **PINO**: We divide the time interval into 100 and 150 uniform lattices for \(T=10\) and 15, respectively. For **MCNP Solver**, we set the sampling numbers and step size \( t\) to \(16\) and \(0.1\), respectively. We interpolate the spatial domain into \(256 256\) elements in the Fourier Interpolation trick. The \( T\) in the multi-scale framework is set to \(5\) for all tasks.

ResultsTable 2 presents each method's performance and computational cost on the 2D NSEs. As the viscosity term \(\) decreases, simulating the flow becomes more challenging for all methods due to increased turbulence, as shown in Fig. 2. Compared to PINO, MCNP Solver achieves comparable results on \(=10^{-3}\) while outperforming it when \(=10^{-4}\) and \(10^{-5}\), indicating that MCNP Solver is more accurate on turbulent flow simulation. Furthermore, MCNP Solver has advantages and disadvantages compared to the supervised baseline FNO. On the one hand, MCNP Solver can learn from more training samples due to its data-free regime. On the other hand, the FNO directly uses

    &  &  &  \\   & \(=10^{-3}\) & \(=10^{-4}\) & \(=10^{-5}\) & Train (H) & Infer (S) & \# (M) \\   & PSM & 0.309 & NAN & NAN & – & 0.039 & – \\  & PSM+ & 0.103 & 0.136 & 1.521 & – & 0.758 & – \\  & FNO & 1.421\(\) 0.068 & 5.155\(\) 0.290 & 7.594\(\) 0.091 & 0.934 & 0.00255 & 5.319 \\  & PINO & 1.192\(\) 0.043 & 5.730\(\) 0.046 & 8.952\(\) 0.125 & 0.958 & 0.00255 & 5.319 \\  & MCNP & 1.773\(\) 0.117 & 4.440\(\) 0.157 & 6.539\(\) 0.384 & 0.964 & 0.00432 & 4.730 \\   & PSM & 0.389 & NAN & NAN & – & 0.058 & – \\  & PSM+ & 0.137 & 0.168 & NAN & – & 1.133 & – \\   & FNO & 1.391\(\) 0.054 & 5.407\(\) 0.103 & 8.429\(\) 0.048 & 1.636 & 0.00258 & 7.238 \\   & PINO & 2.161\(\) 0.193 & 19.655\(\) 5.971 & 24.185\(\) 3.947 & 1.703 & 0.00258 & 7.238 \\   & MCNP & 2.195\(\) 0.142 & 6.553\(\) 0.384 & 8.677\(\) 0.350 & 1.458 & 0.00635 & 7.095 \\   

Table 2: **2D NSE with varying \(\) and \(T\). Relative errors (%) and computational costs for baseline methods and MCNP Solver.**the ground-truth data as training labels for all \(t[0,T]\), thus avoiding accumulated errors arising from the calls of the solver during the training stage like other unsupervised methods. As a result, MCNP Solver and FNO achieve better results on most tasks when \(T=10\) and \(15\), respectively. As for classical solvers, PSM only obtains meaningful results when \(=10^{-3}\), confirming that both PSM and PINO are not robust to coarser time steps. PSM+ achieves the lowest error rate on most tasks but requires almost \(180 300\) times more inference time than other neural solvers.

### Ablation Study

We performed several ablation studies of MCNP Solver on NSE \((=10^{-5},T=15)\) to understand the contribution of each model component. MCNP-OR replaces the one-step rollout technique with two-step when simulating the SDEs. MCNP-FI and MCNP-MS represent the MCNP Solver without the Fourier Interpolation and multi-scale trick, respectively. MCNP-MC replaces the neural Monte Carlo loss with the PSM loss, which aligns with the loss function in PINO. Table 3 reports the results and training costs. MCNP-OR obtains comparable results with MCNP while spending 44% additional training time. Compared to MCNP with MCNP-FI, the Fourier Interpolation trick can significantly improve the accuracy of MCNP while introducing little extra computational cost. The reason is that the rate-determining step in the training stage is the optimization of neural solvers, and the Fourier Interpolation trick does not involve any calls of solvers. Compared to MCNP with MCNP-MS, we can see that the multi-scale framework plays a vital role in improving the long-time simulation ability of MCNP. Additionally, this architecture can reduce the training time because each sub-network is relatively lightweight. Finally, the gap between MCNP and MCNP-MC reveals the advantages of Monte Carlo loss compared to the PSM loss, which is more robust against spatial-temporal variations in turbulence simulation tasks.

### Additional Numerical Results

We also conduct experiments to evaluate the MCNP Solver's ability to handle different boundary conditions, fractional Laplacian, and irregular grids, as detailed in Appendix C.

## 6 Conclusion and Discussion

**Conclusion** In this paper, we propose the MCNP Solver, which leverages the Feynman-Kac formula to train neural PDE solvers in an unsupervised manner. Theoretically, we characterize the approximation error and robustness of the MCNP Solver on convection-diffusion equations. Numerical analyses demonstrate the MCNP Solver's ability to adapt to complex spatiotemporal variations and long-time simulations on diffusion equations and NSEs.

**Limitations** This paper has several limitations: (1) The theoretical results are lacking when \(\) is not constant, and the gradient flow of the MCNP Solver during the training stage requires further analysis. (2) Some PDEs are not suitable for the Feynman-Kac formula and therefore do not fall within the scope of the MCNP Solver, such as third or higher-order PDEs (involving high-order operators like \(u_{xxx}\)). (3) The accuracy of the MCNP Solver cannot outperform numerical solvers when disregarding inference time, which is also a major drawback for other existing neural solvers . As discussed in , _AI-based methods lack precision compared to classical methods while achieving reasonable accuracy and offering great potential for efficient parameter studies._

**Future Work** In addition to addressing the limitations, we suggest several directions for future research: (1) Extend the proposed MCNP Solver to broader scenarios, such as high-dimensional PDEs and optimal control problems; (2) Utilize techniques from out-of-distribution generalization  to improve the generalization ability of MCNP Solver.

    & MCNP & MCNP-OR & MCNP-FI & MCNP-MS & MCNP-MC \\  Error (\%) & 8.677\(\) 0.350 & 8.874\(\) 0.150 & 15.561\(\) 0.596 & 24.107\(\) 1.104 & 14.110\(\) 1.789 \\ Time (H) & 1.458 & 2.097 & 1.431 & 2.164 & 1.072 \\   

Table 3: **Ablation Studies of each model component in MCNP Solver. Relative error (%) and training time for each method on the NSE tasks with \(=10^{-5}\) and \(T=15\).**