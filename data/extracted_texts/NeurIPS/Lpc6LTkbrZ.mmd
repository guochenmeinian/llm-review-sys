# Non-Myopic Batch Bayesian Experimental Design

for Quantifying Statistical Expectation

Anonymous Author(s)

Affiliation

Address

email

###### Abstract

For almost a century, the fundamental method to estimate statistical expectation has been Monte Carlo with the core idea of learning a system by many random samples . Although the convergence of Monte Carlo is guaranteed by the _law of large numbers_, its convergence rate--inversely proportional to the square root of the number of samples--is notoriously slow. That becomes a problem in scenarios where systems, such as global weather or autonomous cars, can only be evaluated by expensive numerical or physical experiments, requiring an efficient method with minimum evaluations.

To increase the convergence rate, a sequential Bayesian experimental design framework targeting statistical expectation was developed in [2; 3]. Specifically, they use the Gaussian process regression (GPR) as the surrogate and greedily select the next-best sample one by one which maximizes the information-theoretic acquisition, i.e., the information gain of adding the next sample. Although  shows that the proposed method works in several synthetic and practical cases, its sequential nature does bring two drawbacks. Firstly, the samples need to be evaluated one by one, making the duration of the whole process remarkably long. In contrast, the standard Monte Calor determines all samples in the beginning which can maximally utilize parallel computational resources in evaluating samples. Secondly, the determination of samples only focuses on the benefits of the immediate next sample without considering the long-term benefits, for example, the convergence after a certain number of samples.

In this work, we develop a non-myopic batch Bayesian experimental design for statistical expectation. The next batch of samples is selected, which maximizes the long-term information gain (as the acquisition) when they are added together. In addition, we formulate an analytic approximation of the acquisition to facilitate its optimization. The superior performance of the proposed algorithm, in terms of wall time saving and a faster or matched convergence rate than sequential sampling, is demonstrated in a case with arbitrary complex functions generated by RBF kernel and another case using a stochastic oscillator.

## 2 Method

### Problem setup

We consider an input-to-response (ItR) system described by a response function \(f():^{d}\) with \(\) a \(d\)-dimensional random input. The input probability \(p_{}()\) is assumed to be known and our objective is the statistical expectation defined as:

\[q= f()p_{}().\] (1)To compute \(q\), we take a Bayesian perspective by placing \(f\) a Gaussian process prior \(f(0,k(,^{}))\) where \(k\) is covariance function with hyperparameters \(\). Given a dataset \(_{n}=\{_{n},_{n}\}\) consisting of \(n\) inputs \(_{n}=\{^{i}^{d}\}_{i=1}^{n}\) and the corresponding outputs \(_{n}=\{f(^{i})\}_{i=1}^{n}\), the underling relation \(f\) is predicted as a posterior Gaussian process \(f()|_{n}(m_{n}(),k_{n}(,^{}))\) with formulae of posterior mean \(m_{n}\) and covariance \(k_{n}\) detailed in Appendix A. The statistical expectation \(q|_{n}\) then becomes a random variable with randomness coming from the epistemic uncertainties of \(f()|_{n}\). Our goal is to choose the most informative batch of samples by optimizing the acquisition function that facilitates convergence of \(q\). In the following, we will discuss the form of the acquisition function.

### Acquisition function

For selecting the next samples, a popular way is to maximize the information gain (measured by K-L divergence) between the current estimation \(q|_{n}\) and hypothetical next estimation \(q|_{n},}_{s},}_{s}\) after adding \(s\) number of samples \(}_{s}\) with responses \(}_{s}\) (see  for a sequential version):

\[_{s}^{*} =*{argmax}_{}_{s}}\ p(q|_{n},}_{s},}_{s})\,\|\,p(q|_{n}),\] \[*{argmax}_{}_{s}}\ p(q|_{n},}_{s},}_{s})\,\|\,p(q|_{n})\ p(}_{s}|}_{s},_{n})}_{s},\] (2)

where \(}_{s}\) is chosen based on the current surrogate \(f()|_{n}\) following a distribution of \((}_{s};m_{n}(}_{s}),k_{n}( {}_{s},}_{s}))\). Another more intuitive way is to minimize the variance, as the _predicted_ mean squared estimation error (MSE), of \(q|_{n},}_{s},}_{s}\):

\[_{s}^{*} =*{argmin}_{}_{s}}\  (q|_{n},}_{s},}_{s}) \] \[*{argmin}_{}_{s}}\  (q|_{n},}_{s},}_{s})\ p(}_{s}|}_{s},_{n})}_{s}\] \[*{argmin}_{}_{s}}\ (q|_{n},}_{s},}_{s})\] (3)

where \((q|_{n},}_{s},}_{s})\) is a constant for \(}_{s}\).

Indeed, these two ways are equivalent for estimating the statistical expectation (see detailed derivations in Appendix B), and the optimization finally becomes:

\[_{s}^{*}=*{argmax}_{}_{s}}\ _{n}(,}_{s})p_{}( )\ _{n}(}_{s},}_{s})^{-1} _{n}(}_{s},)p_{}() .\] (4)

While (4) seems straightforward, a numerical integration for the right-hand side can become prohibitively expensive. To make the optimization (likely a high dimensional problem) feasible, we develop an analytical approximation for the acquisition in Appendix C. With the analytical solution, (4) is solved by a multi-start Quasi-Newton method with gradient computed through automatic differentiation in PyTorch1.

### Overall algorithm

We finally show the overall algorithm in Algorithm 1. In each iteration, the number of samples to be selected is specified by \(s(t)\) with \(t\) the index of iterations. Setting \(s(t)=1\) reduces to the sequential algorithm in  and . In this algorithm, one might wonder why we don't schedule all samples initially, considering that the sample responses do not directly appear in (4). Regarding this, we note that the sample responses do influence (4) implicitly via hyperparameters \(\) of the Gaussian process. (Should we know the hyperparameters in the beginning, we can determine all samples in one batch where the MSE in (3) is reduced much faster compared with sequential sampling, as shown in Appendix D.) In other words, a sequential algorithm can update the surrogate after each sample, making the selection of the next sample based on a more accurate model (although in a myopic way). The sampling efficiency of the batch algorithm needs to be evaluated in light of the benefits of long-term perspective and the disadvantages of less frequent model updates, which will be demonstrated in the next section.

## 3 Results

In this section, we test the performance of the proposed batch design algorithm in two cases: (1) a larger number of complex functions from realizations of Gaussian processes in SS3.1, and (2) a stochastic oscillator in SS3.2. In each case, we compare the results of batch design (_batch-design_) with sequential design (_seq-design_), direct random sampling (_random_), and random sampling with Gaussian process surrogate (_random-gpr_). For _random_, the expectation is directly computed as the mean of samples, while for _random-gpr_ the expectation is computed with a surrogate learned from random samples. The comparison between _random-gpr_ and _random_ highlights the impact of imposing a prior for \(f\), while the advantage of choosing optimal samples over random samples is evidenced in the contrast between _seq-design_ and _random-gpr_. Finally, the difference between _batch-design_ and _seq-design_ measures the effectiveness of picking a group of samples simultaneously instead of a single sample during each iteration.

### RBF functions

We firstly test the proposed algorithm in 100 two-dimensional functions constructed from RBF kernel. The hyperparameters for generating these functions are \(=\{4,_{2}\}\) (see Appendix A for format of \(\)) with an example shown in figure 1(a).

The results for a standard Gaussian input \(p_{}()\) with the assumption of known hyperparameters are demonstrated in figure 1(b). Considering there are 100 different functions, we average the error across all functions where, in each function, the error is computed in a root mean squared form of 50 runs considering the randomness in drawing samples. For _seq-design_ and _batch-design_, the sampling position is fixed, so we will directly take the fixed error. For _batch-design_, we sample only one batch in the beginning as we assume the hyperparameters are known. From figure 1(b), we can see that methods are ranked in an increasing performance from _random_ to _random-gpr_ to _seq-design_ and finally _batch-design_. That means the prior information is useful and a careful design would also improve the performance. Regarding the design method, the batch design is better than the sequential design as it optimizes all samples as a whole.

Figure 1: (a) an example of two-dimensional RBF functions. Results of RBF functions with (b) known hyperparameters and (c) learned hyperparameters: _random_ (), _random-gpr_ (), _seq-design_ (), and _batch-design_ () (\(s=4\)).

We further consider situations where the hyperparameters are unknown with results shown in figure 1(c). For both _batch-design_ and _seq-design_, we use 4 initial samples, and the error of each function is also computed in a root mean squared form across different initializations. The _batch-design_ with \(s(t)=4\) performs almost the same with _seq-design_, meaning the pro of a non-myopic design is actually offset by the con of fewer hyperparameters updates. But we note that the wall computational time of _batch-design_ is only a quarter of _seq-design_.

### Stochastic oscillator

We next consider a stochastic oscillator also used in [4; 5; 6]. In particular, the oscillator equation is formulated as

\[(t)+(t)+F(u)=(t),\] (5)

where \(u(t)\) is the state variable, \(F\) a nonlinear restoring force. The stochastic process \((t)\), with a correlation function \(_{}^{2}e^{-^{2}/(2l_{}^{2})}\), is approximated by a two-term Karhunen-Loeve expansion

\[(t)=_{i=1}^{2}x_{i}_{i}_{i}(t),\] (6)

with \(_{i}\) and \(_{i}(t)\) respectively the eigenvalue and eigenfunction of the correlation function, \((x_{1},x_{2})\) is a standard normal variable as the input to the system, satisfying \(p_{}()=(,_{2})\) with \(_{2}\) being a \(2 2\) identity matrix. The \(F\) term and values of the parameters are kept the same as those in the existing works. The response of the system is considered as the mean value of \(u(t;)\) in the interval \(\):

\[f()=_{0}^{25}u(t;)t,\] (7)

with contour shown in figure 2(a).

We plot the results for different methods in figure 2(b). All results are root mean squared errors with randomness in _random_ and _random-gpr_ coming from random sampling and randomness in _seq-design_ and _batch-design_ coming from initializations. For _batch-design_, we test both \(s(t)=2\) and \(s(t)=4\). It demonstrates that _seq-design_ performs best among all while _batch-design_ with \(s(t)=2\) is almost on par with _seq-design_ albeit slightly less efficient.

## 4 Discussion

In this work, we develop a non-myopic batch Bayesian experimental design algorithm for statistical expectation, where the next batch of samples is selected to maximize the information gained (or equivalently to minimize the estimation uncertainty). We apply the results in two test cases, showing that if the hyperparameters (prior) are known, the batch design algorithm converges much faster than the sequential design. For more typical situations requiring learned hyperparameters, the batch design algorithm performs slightly worse, if not equally well, compared to the sequential design. However, it offers substantial savings in wall time. Further tests on additional cases with varying dimensions, complexities, and \(s()\) are ongoing and will be presented in a full paper.

Figure 2: (a) response function of the stochastic oscillator. (b) results of _random_ (), _random-gpr_ (), _seq-design_ (), _batch-design_ with \(s(t)=4\) (), _batch-design_ with \(s(t)=2\) ().