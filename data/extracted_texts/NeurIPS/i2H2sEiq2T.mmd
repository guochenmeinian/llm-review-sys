# A Unified Fast Gradient Clipping Framework

for DP-SGD

 Weiwei Kong

Google Research

weiweikong@google.com &Andres Munoz Medina

Google Research

ammedina@google.com

###### Abstract

A well-known numerical bottleneck in the differentially-private stochastic gradient descent (DP-SGD) algorithm is the computation of the gradient norm for each example in a large input batch. When the loss function in DP-SGD consists of an intermediate linear operation, existing methods in the literature have proposed decompositions of gradients that are amenable to fast norm computations. In this paper, we present a framework that generalizes the above approach to arbitrary (possibly nonlinear) intermediate operations. Moreover, we show that for certain operations, such as fully-connected and embedding layer computations, further improvements to the runtime and storage costs of existing decompositions can be deduced using certain components of our framework. Finally, preliminary numerical experiments are given to demonstrate the substantial effects of the aforementioned improvements.

## 1 Introduction

Machine learning models -- more specifically, neural network-based models -- are becoming more popular in industrial applications, in user-facing products, and different scientific fields. The popularity of these models lies on their flexibility and ability to be trained on ever bigger datasets, which may contain personal information about individuals. As these models become bigger and more descriptive, ML practitioners need to ensure that the models, and their black-box interactions, do not reveal information about the data used to train the model. In fact, it has been shown repeatedly  that large neural-network models can be used to know if a particular example was used in the training data. Another line of attacks has demonstrated that one can actually reconstruct some training instances with simple interactions with a trained model .

The only known robust way of protecting against these attacks is to train models using differential privacy [10; 11]. Using this approach, ML practitioners provide an information theoretic guarantee that ensures that the final model does not depend on any individual example1. To date, the most popular method for training models with differential privacy is the differentially private stochastic gradient descent (DP-SGD)  method. In theory, the DP-SGD algorithm requires only minimal changes with respect to its non-private counterpart; one only requires to clip gradients observed in the training process and add some noise proportional to the clipping value. However, in practice, the (naive) gradient clipping step has been shown to increase memory and computational costs in all popular learning platforms (JAX, Tensorflow, and Pytorch). More precisely, for a batch of size \(n\) a naive implementation of DP-SGD requires calculating \(n\) gradients (one for each example in the batch) so they can be clipped. This is in stark contrast with most back-propagation-based training algorithms which calculate a single gradient. This implies a dependency on the runtime and memory in proportion to the batch size used to train the model, and for large models, this cost makes theprospect of training with differential privacy simply not viable. Several papers [8; 17; 21] have also observed that large models need to be trained with large batch sizes to obtain competitive levels of utility, under reasonable amounts of privacy.

In , it was recognized that one could clip gradients without actually materializing every example gradient. This technique is referred to as _ghost clipping_. The initial proposal from  was specialized to fully connected, feed-forward neural networks that consist of only dense layers. The ghost clipping algorithm was later extended to handle convolution layers [13; 15] and attention layers .

However, each of the above solutions required an ad-hoc analysis on the correctness of their implementation. In this work we present a general analysis of the ghost clipping algorithm. To produce our results, we study this algorithm from the lens of linear operator theory. Our paper has three main contributions:

1. We unify years of ad-hoc analysis and interpretations of the ghost clipping algorithm under a single framework.
2. We provide a future-proof way of expanding the ghost-clipping technique to new layers with (possibly) nonlinear dependencies on their weights.
3. We demonstrate that by framing the ghost clipping problem in the language of linear operators, we can obtain a better performance of DP-SGD on models with embedding layers (crucial for personalization models consisting of embeddings of tens of millions of parameters) and fully connected layers with linear bias broadcasting operators.

Additionally, we show in our Appendix how to apply our framework to more complex tranforms/layers such as layer normalization and multi-head attention.

To complement the results of this paper, we open-sourced the general interface of the code using the TensorFlow Keras API2. By introducing an abstract interface, we also expect practitioners to easily extend the ghost clipping algorithm to any type of layer.

## 2 Notation and preliminaries

Throughout the paper, \((,,)\) denotes a Hilbert space and \(\|\|\) denotes its induced norm. Examples of \(\) are \(^{d}\) with the standard dot product and the space of matrices \(=^{p q}\) with the Euclidean (Frobenius) inner product between \(A,B\) given by \( A,B=(A^{}B)\). For two matrices \(A,B\) we let \(\|A\|\) denote the Frobenius norm of \(A\).

Given two Hilbert spaces \((,,_{})\), \((,,_{})\), we denote linear operators between them by italicized letters (\(\)) and \(^{*}:\) to be the _adjoint_ of \(\). That is, \(^{*}\) is the unique linear operator that satisfies

\[ y,w_{}=^{*}y,w _{} w, y .\] (1)

Let \((,,_{})\) and \((,,_{})\) denote two Hilbert spaces with respective induced norms \(\|\|_{}\) and \(\|\|_{}\). Moreover, let \(:\) be an arbitrary function. The _Frechet derivative_ of \(\) at \(w_{0}\) is given by the unique bounded linear operator \(D(w_{0})\) satisfying

\[_{ 0}+)-(w_{0})-D(w_{0})\|_{ }}{\|\|_{}}=0.\]

We say \(\) is differentiable if its Frechet derivative exists for all \(w_{0}\). Throughout this paper we will use two special properties of the Frechet derivative: the chain rule and the existence of gradients. Let \((,,_{})\) be another Hilbert space and \(\) be given. The _chain rule_ provides us with a simple way to calculate the derivative of the function \(\), namely,

\[D()(w_{0})=D((w_{0}))D(w_{0}).\]

The Frechet derivative of \(\) at \(w_{0}\) with respect to a subset of variables \(u\) is denoted by \(D_{u}(w_{0})\). Finally, \((w_{0})\) denotes the (unique) gradient of a function \(\) at \(w_{0}\), which satisfies

\[D(w_{0})=(w_{0}),_{ }\] (2)

The existence of the gradient is guaranteed by the well-known Riesz-Frechet Representation Theorem . The gradient of \(\) at \(w_{0}\) with respect to a set of variables \(u\) is denoted by \(_{u}(w_{0})\).

Private Stochastic Gradient DescentWe now turn our attention to the DP-SGD algorithm and specifically, to its instantiation for neural network-based models. Let \(\) be an arbitrary space and \(=\{x_{1},,x_{n}\}\) be a sample of examples. Let \(\) denote a parameter space and \(h\) denote an arbitrary function. The stochastic gradient descent (SGD) algorithm solves the optimization problem

\[_{w}_{i=1}^{n}h(x_{i},w)\]

by iteratively updating the model paramters using gradients of the loss over a batch \(B\) of data.

The celebrated DP-SGD algorithm was introduced by  as a simple modification on the SGD algorithm to make it private3. Specifically, the DP-SGD algorithm, given in Algorithm 1, is identical to the SGD algorithm except in two steps:

1. The DP-SGD algorithm needs to calculate \(|B|\) (so-called) per-example gradients in order to clip them to have a bounded norm.
2. Adding Gaussian noise \(N(0,C^{2}^{2}/|B|^{2})\) for some noise multiplier \(>0\).

Notice that the first step has a prohibitively large cost for large networks. Specifically, in the per example gradient calculation, notice that that the computational and memory usage of a naive implementation4 of DP-SGD algorithm increases as \((n_{w}|B|)\), where \(n_{w}\) is the number of parameters in the network. This increase in resources effectively negates the advantages of the backpropagation algorithm. In this paper we show how to run the DP-SGD algorithm with only a small constant increment in both the memory footprint and runtime of traditional SGD.

We will focus on the scenario where the learner is trying to minimize the loss across the space of neural networks. That is, the parameter vector \(w\) is a concatenation of \(k\) parameters \((w_{1},,w_{k})\) and there exists \(k\) functions \(_{1},,_{k}\), and a loss function \(\) such that

\[h(x,w)=(x,_{k}(w_{k},_{k-1}(w_{k-1},...,_{1}(w_{1},x))).\]

Note that \(\{_{j}\}\) correspond to the layers of the network and \(\{w_{j}\}\) are the vectors parameterizing these layers.

## 3 Previous work

The DP-SGD algorithm was first introduced by . Due to its simplicity to adapt to standard machine learning frameworks it is now probably the most popular method for training private machine learning models. In the past few years, a large number of papers have been devoted to improving the privacy-utility trade-offs of DP-SGD  as well as demonstrating that DP-SGD can be used on multiple tasks [7; 9; 2]. While the main focus on this line of research has been in understanding the privacy-utility trade-offs, some authors did touch on the performance issues of calculating per-example gradients. A simple solution to reduce the memory and computational blow-up of the DP-SGD algorithm is to calculate the gradient with respect to a micro-batch of examples instead. While this reduced the computational cost of running DP-SGD, it came at the cost of decreased quality of the model learned. Some authors  got around this performance issues by using some JIT compilation features of JAX. However these authors still observed an increase in the memory use of their private implementations.

In order to speed up the gradient clipping step without sacrificing quality,  proposed the ghost clipping technique (see Section 4). ITs general idea is that one can obtain a private gradient estimate \(\) without materializing each per example gradient as long as one knows the norm of each per-example gradient. Moreover, the authors show that one can easily calculate these norms by using information already materialized in the forward and backward passes of the back propagation algorithm for training neural networks. The results however were limited to neural networks consisting of only dense layers. The ghost clipping trick was later on applied to train transformers  and image classification models which consist of networks with convolution layers .

The above works provide ad-hoc proofs that their implementation of the ghost clipping algorithm is correct for their particular layer implementation but do not attempt to extend their results to arbitrary layers. In this work we present a way to extend the ghost clipping technique to arbitrary layers and pinpoint what properties of each layer are crucial for enabling an efficient implementation of the DP-SGD algorithm.

Finally, it is also worth mentioning that paper  presents an efficient implementation of the ghost clipping technique in PyTorch for models with fully-connected, embedding, convolution, and normalization layers using variable caching to avoid recomputing certain intermediate parameter gradients. Our implementation also takes advantage of variable caching, but does this implicitly through TensorFlow's GradientTape API5.

## 4 The Ghost Clipping Algorithm

Algorithm 1 suggests that in order to implement DP-SGD one must calculate every per-example gradient, clip it to achieve a bounded norm and then aggregate it to obtain the private gradient estimate \(\). The main observation from  was that, with knowledge of the norms \(\|g\|_{x}\) one could estimate \(\) without explicitly materializing each per example gradient. To do this, the authors define weights \(r_{x}=\{/\|g_{x}\|,1\}\) and a new weighted sum

\[S(w)=_{x B}r_{x}h(x,w).\]

Treating the weights \(r_{x}\) as fixed (with respect to the parameters \(w\)), one can use the linearity of the gradient operator to see that \( S(w)=\). Crucially, for neural networks, the gradient of \(S\) can be efficiently calculated using a single back-propagation step. The second contribution of  was showing that, for neural networks consisting of dense layers, one can also efficiently calculate \(\|g_{x}\|\) for every \(x B\) using only a single forward and backward pass of the back propagation algorithm. That is, the cost of calculating a private gradient is simply twice that of calculating a non-private gradient step.

In the subsections below, we present a general formulation for calculating \(\|g_{x}\|\) in a single forward and backward pass for arbitrary feed-forward neural networks, under the assumption that:

* \((x,)\), \(_{1}(,x)\),..., \(_{k}(,x)\) are Frechet differentiable for every \(x\);
* each function \(_{i}(,x)\) can be decomposed as the composition of at least two Frechet differentiable subfunctions.

### The General Norm Calculation Algorithm

Let \(w=(w_{1},,w_{k})\) parameterize a neural network. We first note that \(\|_{w}h(x,w)\|^{2}=_{j=1}^{k}\|_{w_{k}}h(x,w)\|^{2}\). Hence, we can focus on efficiently calculating the norm of the gradient corresponding to the parameters of each layer. Let us then fix a layer and denote \(}\) to be its parameter vector for some restricted space \(}\). Moreover, let the input \(x\) be fixed. We see that, as a function of the layer parameters \(\) only, the loss \(h\) has the form

\[h(x,)=_{x}_{x}() x,\] (3)

where \(_{x}\) corresponds to operations performed by the fixed layer and all subsequent layers in the network, and \(_{x}()(x,)\) corresponds to the loss function, e.g., mean-squared error, for the input example \(x\). The following result, whose proof can be found in the Appendix, gives an expression for the gradient of \(h\) under any decomposition of \(_{x}\).

**Proposition 4.1**.: _Let \(x\) be fixed and let \((_{x},_{x})\) be a pair of Frechet differentiable functions satisfying (3). Moreover, let \((_{x},Z_{x})\) be a pair of Frechet differentiable functions satisfying \(_{x}=_{x} Z_{x}\), and denote_

\[=_{x}():=DZ_{x}(), g=g_{x}():= (_{x}_{x})(Z_{x}()).\] (4)

_Then, \(_{}h(x,)=^{*}g\)._

The above result gives us an alternative way of computing \(\|_{}h(x,)\|^{2}\), namely, (i) pick a decomposition \((_{x},Z_{x})\) of \(_{x}\) and (ii) compute \(\|^{*}g\|^{2}\) in some efficient manner. In later subsections, we provide examples of layers and decompositions where this two-step approach is drastically more efficient than the naive approach of materializing \(_{}h(x,)\) and computing its Euclidean norm.

In view of the decomposition in Proposition 4.1, we present a unified method for computing \(\| h(x,w)\|\) in Algorithm 2. Specifically, it consists of two loops over the parameters \(w_{i}\). The initial loop is performed to obtain the intermediate outputs \(_{i,x}\) and some sort of "nice" or efficient representation of the squared-norm functions \(_{i,x}\). The follow-up loop, also over the parameters \(w_{i}\), computes some necessary intermediate gradients and combines them with the functions \(_{i,x}\) to obtain the gradient decomposition (and subsequent norm computation) given by Proposition 4.1.

``` Input: Data \(x\), parameter \(w=(w_{1},,w_{k})\), and functions \(\{_{x,i}\}_{i=1}^{k}\), \(\{Z_{x,i}\}_{i=1}^{k}\) satisfying \(h(x,)=_{x}_{x,i} Z_{x,i}(), i=1,,k\) for any \(=(_{1},,_{k})\), where \(_{x}()(x,)\). for\(i=1,,k\)do  Compute \(_{x,i}:=Z_{x,i}(w_{i})\)  Store a "nice" representation \(_{x,i}()\) of the squared-norm function \(g\|[DZ_{x,i}(w_{i})]^{*}(g)\|^{2}\)  for any gradient \(g\) of the function \(_{x}_{x,i}()\) endfor for\(i=1,,k\)do  Compute \(g_{x,i}:=_{_{i,x}}(_{x}_{x,i})(_{x,i})\) and \(_{x,i}:=_{x,i}(g_{x,i})\) endfor return\((_{i=1}^{k}_{x,i})^{1/2}\) ```

**Algorithm 2** General Gradient Norm Framework

### Efficient Implementation of Algorithm 2

We now describe how Algorithm 2 can be implemented efficiently when \(h(,)\) is formed by a neural network \(\). First, it is shown in Appendix B.1 that the intermediate quantities \(\{_{i,x}\}_{i=1}^{k}\) and \(\{g_{i,x}\}_{i=1}^{k}\) can be computed in a single forward and backward pass of \(\) (as opposed to naively traversing the network \((k)\) times). Second, it is shown in Appendix B.2 that for any \(i\), the batch gradients \(\{_{_{i,x}}(_{x}_{x,i})(_{x,i})\}_{x B}\) can be obtained a single (batched) backward pass of \(\) if (i) condition (5) holds for every \(x B\) and (ii) the gradient \(g_{x,i}\) is replaced by \(_{_{x,i}}\{_{x B}_{x}_{x,i}(_{x,i})\}\). Consequently, if we ignore the costs of forming and evaluating \(_{x,i}()\) for each \(x B\)and \(i=1,,k\), then the above facts imply that we can obtain the norms \(\{\| h(x,w)\|\}_{x B}\) using only one additional forward and (batched) backward pass of \(\).

## 5 Efficient Squared-Norm Functions

This section presents efficient representations of the functions \(_{i}()\) in Algorithm 2 for some basic layer functions \(_{x}(w)(w,x)\). Examples involving more complicated layer functions (e.g., layer normalization and multi-head attention) can be found in the Appendix.

Each subsection begins with a precise description of \(_{x}()\), presents a decomposition \(()=_{x} Z_{x}()\), and gives an analysis of the runtime and storage costs of an efficient representation of the function \(_{x}()\|[DZ_{x}(w)]^{*}()\|^{2}\). For the sake of conciseness, the proofs of these decompositions are given in the Appendix.

In addition, we make comparisons of our approach with the naive approach (of computing gradients for each example) and other ghost clipping-like approaches. The results of these comparisons are summarized in Tables 1-2 (see the first paragraphs in Subsections 5.1-5.3 for descriptions of the variables/dimensions).

### Fully-Connected Layers

Given variables \(V^{p q}\) and \(b^{m}\), a layer input \(U_{x}^{r p}\), an activation function \(:^{r q}^{r q}\), and a linear broadcasting operator \(:^{m}^{r q}\) satisfying \(m\,|\,rq\), the standard fully-connected layer function \(_{x}()\) is given by

\[_{x}(V,b)=(U_{x}V+b).\] (6)

Typically, \(p\), \(q\), \(r\), and \(m\) are called the _input dimension_, _output dimension_, _channel dimension_, and _bias dimension_, respectively. Usually, it is the case that \(r\{p,q\}\) and a common case is \(r=1\).

We now consider the squared-norm function \(_{x}:^{r q}\) generated by the choice of \(Z_{x}(V,b):=U_{x}V+b\). Denoting \(\) as in (4), for some \(=(V,b)\), we have that

\[_{x}(g)=\|^{*}g\|^{2}=\|U_{x}^{*}g\|^{2}+\| ^{*}g\|^{2}= U_{x}U_{x}^{*},gg^{*}+\|^{*}g \|^{2},\] (7)

for any \(g^{r q}\). Hence, \(_{x}()\) can be efficiently represented by \(U_{x}U_{x}^{*}\) and an efficient representation of the function \(g\|^{*}g\|^{2}\). For an example of the latter, suppose \(\) is the operator that repeats \(b\) in an \(r\)-by-\(q\) matrix row-wise \(:=rq/m\) times. Then, defining the row/column maps

\[(,k):=1+,( ,k):=1+\{[(-1)m+(k-1)] r\},\]

  & Naive & Ghost Clipping & **Ours** \\  Fully-Connected6  & \((|B|\{pq+m\})\) & \((r^{2}+|B|\{rq\}^{2})\) & \((|B|r^{2})\) \\ Embedding7  & \((|B|qd)\) & \(O(|B|q^{2})\) & \((|B|\{q+d\})\) \\ Rank-\(k\) Approx. & \((|B|n^{2}k)\) & - & \((n^{2}k+|B|)\) \\ 

Table 1: Asymptotic storage costs for computing \(\{\| h(x,W)\|\}_{x B}\). For ghost clipping and our approach, this is the storage cost of representing the squared-norm function \(_{x}()\) on the entire batch \(B\).

  & Naive & Ghost Clipping & **Ours** \\  Fully-Connected6  & \((|B|\{pq+m\})\) & \((r^{2}\{p+|B|q^{2}\}+m\{rq\}^{2})\) & \((r^{2}\{p+|B|q\})\) \\ Embedding7  & \((|B|\{pqd\})\) & \(O(|B|q^{2}d)\) & \((|B|\{q+d\})\) \\ Rank-\(k\) Approx. & \((|B|n^{2}k)\) & - & \((n^{2}k+|B|)\) \\ 

Table 2: Asymptotic runtime costs for computing \(\{\| h(x,W)\|\}_{x B}\). For ghost clipping and our approach, this includes the time used to generate, represent, and evaluate the squared-norm function \(_{x}()\) on the entire batch \(B\).

[MISSING_PAGE_FAIL:7]

them with the \(\) nonzero cached values \(\{n_{k}(x)\}_{k=1}^{r}\), which can be done with a \((|B|d)\) runtime cost for a batch \(B\). Consequently, the total runtime (resp. storage) cost for a batch of examples \(B\) is \((|B|\{q+d\})\) (resp. \((|B|)\)) using Algorithm 3.

Let us now make a comparison of this decomposition with the naive approach and the ghost clipping approach in .

In the naive approach of computing \(_{W}h(x,W)\) for each \(x B\), it is straightforward9 to show that the compute (resp. storage) costs are \((|B|qd)\) (resp. \((|B|qd)\)).

In the classic ghost clipping approach, we treat \(_{x}()\) as a linear operator, compute \(Y_{(x)}Y_{(x)}^{*}\), and choose the representation \(_{x}(g)= Y_{(x)}Y_{(x)}^{*},gg^{*}\). In the worst-case scenario, it is straightforward to see that \(Y_{(x)}Y_{(x)}^{*}\) can be fully dense, e.g., \(=1\). In this setting, even if \(Y_{(x)}\) is sparsely represented by a small set of \(\) unique indices, computing \(Y_{(x)}Y_{(x)}^{*}\) still incurs a compute and storage cost of \(O(q^{2})\). Now, since each example gradient \(g\) consists of \(q\) embedding vectors in \(^{d}\), for a batch \(B\), the compute (resp. storage) cost of materializing \(gg^{*}\) is \((|B|q^{2}d)\) (resp. \((|B|q^{2})\)). Combining the above complexities with the \((|B|q^{2})\) runtime cost of computing the desired inner products, i.e. (7) with \(U_{x}=Y_{(x)}\) for \(x B\), we obtain the complexities in Tables 1-2.

### Low Rank Approximation Layer

Given input matrix \(U_{x}^{n n}\), one way [19; 20] to encourage a rank-\(k\) (or lower) approximation of \(U_{x}\) is to add the intermediate layer transform

\[_{x}(V)=\|U_{x}-VV^{*}\|^{2}+(VV^{*})\]

for some \(V^{n k}\), where \(()\) is a sparsity promoting regularizer (e.g., \(_{1}\) norm, SCAD, MCP) and \(()\) is the function that maps matrices to their singular values. Expanding the norm term, note that the above function can be equivalently (ignoring terms depending solely on \(U_{x}\)) expressed as

\[_{x}(V)=-2 U_{x},VV^{*}+(V),\] (8)

for some function \(:^{n k}\). Note that \((V)\) does not depend on \(x\) and, hence, its computation does not depend the batch \(B\).

In view of (8), we now consider the squared-norm function \(_{x}:\) generated by the choice of \(Z_{x}(V)= U_{x},VV^{*}/2\), where, clearly, one has \(_{x}(V)=-4Z_{x}(V)+(V)\). Denoting \(\) as in (4), for some \(=V\), it can be shown that

\[_{x}(g)=\|^{*}g\|^{2}=}{4}\|(U_{x}+U_{x}^{*})V\|^ {2},\]

for \(g\). Hence, \(_{x}()\) can be efficiently represented by the scalar \(\|(U_{x}+U_{x}^{*})V\|^{2}\). It is straightforward to see that computing \(\|(U_{x}+U_{x}^{*})V\|\) requires only a \((n^{2}k)\) runtime cost and a \((1)\) storage cost. Moreover, evaluation of \(_{x}()\), given \(\|(U_{x}+U_{x}^{*})V\|\), requires only a \(O(1)\) runtime cost.

In the naive approach of computing \(_{V}h(x,V)\) for each \(x B\), it is straightforward to see that the compute (resp. storage) costs is \((|B|n^{2}k)\) (resp. \((|B|nk)\)) due to the excessive computation (resp. storage) of \(g(U_{x}+U_{x}^{*})V\) for \(x B\). The authors are not aware of any ghost clipping-like techniques in the nonlinear setting.

## 6 Numerical Experiments

This section presents numerical experiments that compare our proposed adjoint-based framework (Adjoint) against the naive implementation of DP-SGD (Naive), which computes gradients for each example in a batch, and the classic ghost clipping frameworks (GhostClip) that are described in Subsections 5.1 and 5.2. Specifically, it presents runtimes and memory costs for the gradient norm computation of fully-connected and embedding layers.

Each problem instances was run on a cloud computing platform consisting of (i) 112 Intel(R) Xeon(R) Platinum processors with 28 cores each, (ii) 64 GB of RAM, (iii) Python 3.10.11, and (iv) Tensorflow 2.14. For simplicity, memory usage was measured as the peak amount of heap memory utilized in the run of single gradient norm computation. We also simplify our computations by utilizing batches of size \(|B|=1\) for the first two subsections. The loss function used in our experiment, \(_{x}()\), is the mean-squared-error. To reduce the variance of the results in the first two subsections, we repeat each problem instance 20 times and report only the median runtime and memory cost over the repetitions.

### Fully-Connected Layer

Figure 1 presents numerical results for the setting considered in Subsection 5.1, where \(\) is the (linear) broadcasting operator that duplicates the bias \(rq/m\) times to match the dimension of the layer outputs. It specifically plots the effect of the bias dimension \(m\) for various values of the output dimension \(q\). For simplicity, all problem instances fix an input and channel dimension of \(2\) and \(4096\), respectively. Additional experiments, involving the effect of batch size, are given in Appendix F.

The results in Figure 1 demonstrate that the runtime and memory costs of Adjoint are marginal compared to those of GhostClip for fully-connected layers. These results also support the analysis of Subsection 5.1 in that: (i) GhostClip's runtime has a stronger positive dependence on the bias dimension \(m\) than Adjoint's runtime and (iii) GhostClip's runtime has a strong positive dependence on the output dimension \(q\).

### Embedding Layer

Figure 2 presents numerical results for the setting considered in Subsection 5.2. It specifically plots the effect of the number of queries \(q\) for various values of the vocabulary size \(r\). For simplicity, all problem instances fix the embedding dimension to be \(10\) and the embedding indices \(\{_{i}(x)\}_{i=1}^{q}\) are chosen uniformly at randomly from the set \(\{1,,r\}\).

The results in Figure 2 demonstrate that the runtime and memory costs of Adjoint are marginal compared to those of GhostClip for embedding layers. Moreover, the memory cost graph supports

Figure 1: Runtime and memory cost graphs for fully-connected layer computations with bias dimensions \(m=\{2^{1},2^{2},,2^{11}\}\) and output dimensions \(q=3,4,5\).

Figure 2: Runtime and memory cost graphs for embedding computations with query sizes \(q=\{1000,2000,,10000\}\) and vocabulary sizes \(r=5000,7500,10000\).

the analysis in Subsection 5.2 in that GhostClip's memory cost has a significantly stronger positive dependence on the query size \(q\) compared to Adjoint's memory cost.

### Small BERT model

Figure 3 presents numerical results for an end-to-end training run of a small BERT model that consists of dense, embedding, normalization, and multi-head attention sublayers. It specifically plots the effect of the batch size \(|B|\) on the runtime and peak memory usage of training the model. To be more precise, the BERT model is an instance of the TensorFlow BertEncoder model with a vocabulary size of 100, one intermediate transformer layer, and all other parameters set to their default values. Each experiment consists of a single training loop of 50 iterations with uniformly sampled random input data of a query size of 5. The efficient squared norm functions were taken from the descriptions in Section 5 and Appendices E.1 and E.2.

The results in Figure 3 demonstrate that the runtimes and peak memory usages of Adjoint scale better and are comparatively smaller than the corresponding ones for Naive.

## 7 Concluding Remarks

The analysis in Subsection 5.1 may also be applied to more complex layers whose parameter transformations \(_{x}()\) primarily involve linear transforms. For example, it is shown in [5, Subsection 2.3] that 2D-convolution layers are equivalent to fully-connected layers when the example image is appropriately transformed to form the matrix \(U_{x}\) in (6) and, hence, our storage and runtime savings for fully-connected layers easily apply to 2D- (and generally \(n\)D-) convolution layers. Another example is the multihead attention layer, whose parameter transforms are simple matrix multiplications (see Appendix E.1 for a derivation).

### Limitations

The proposed framework only applies to layers with at least one differentiable intermediate transformation and models with differentiable losses. Moreover, the framework does not support shared trainable layers.

Figure 3: Runtime and memory cost graphs for training a small BERT model with batch sizes \(|B|=\{100,200,400,800,1600\}\).