# Langevin Quasi-Monte Carlo

Sifan Liu

Department of Statistics

Stanford University

Stanford, CA 94305

sfliu@stanford.edu

###### Abstract

Langevin Monte Carlo (LMC) and its stochastic gradient versions are powerful algorithms for sampling from complex high-dimensional distributions. To sample from a distribution with density \(()(-U())\), LMC iteratively generates the next sample by taking a step in the gradient direction \( U\) with added Gaussian perturbations. Expectations w.r.t. the target distribution \(\) are estimated by averaging over LMC samples. In ordinary Monte Carlo, it is well known that the estimation error can be substantially reduced by replacing independent random samples by quasi-random samples like low-discrepancy sequences. In this work, we show that the estimation error of LMC can also be reduced by using quasi-random samples. Specifically, we propose to use completely uniformly distributed (CUD) sequences with certain low-discrepancy property to generate the Gaussian perturbations. Under smoothness and convexity conditions, we prove that LMC with a low-discrepancy CUD sequence achieves smaller error than standard LMC. The theoretical analysis is supported by compelling numerical experiments, which demonstrate the effectiveness of our approach.

## 1 Introduction

Sampling from probability distributions is a crucial task in both statistics and machine learning. However, when the target distribution does not permit exact sampling, researchers often rely on Markov chain Monte Carlo (MCMC) methods. These techniques simulate a Markov chain that converges to the target distribution as its stationary distribution. Recently, MCMC samplers based on discretizing the continuous-time Langevin diffusion have become popular, due to its ease of implementation and ability to handle stochastic gradients (Welling and Teh, 2011).

The primary focus of this work is on the quality of samples generated by Langevin Monte Carlo (LMC) algorithms in terms of estimating the expectation \(_{}[f()]\) for some integrand \(f\) by sample averages. In the context of Bayesian inference, the target distribution \(\) is typically the posterior distribution, and computing the posterior expectation, posterior variance, or confidence intervals are of great interest. In the context of post-selection inference, the target distribution \(\) is the probability distribution conditioned on the selection event, and computing the selection-adjusted p-value is the main task. LMC has been widely used in this problem as well (Markovic and Taylor, 2016; Shi et al., 2022). In all these situations, the accuracy of the sample average estimator is critical and affects the downstream data analysis.

In traditional Monte Carlo sampling, it is well known that using quasi-Monte Carlo (QMC) samples, instead of independent and identically distributed (i.i.d.) random samples, can lead to significant error reduction. So it is natural to ask whether we can apply QMC techniques to improve Langevin Monte Carlo sampling as well. In this work, we introduce the Langevin quasi-Monte Carlo (LQMC) algorithm, which replaces the i.i.d. random inputs in the LMC algorithm with quasi-random numbers.

These quasi-random numbers are carefully designed to sample from the target distribution more evenly and more balanced, leading to improved estimation accuracy.

Not all quasi-Monte Carlo point sets are suitable for simulating Markov chains. Suppose the Markov chain is driven by a sequence of uniform random vectors in the unit cube. A sufficient condition for the sequence is known as _completely uniformly distributed_ (CUD). In our implementation of the driving sequence, we use an entire period of a pseudo-random number generator (PRNG). While modern computer simulations often use PRNGs with a large period, such as Mersenne Twister with a period of \(2^{19937}-1\), our approach runs through the entire period of a PRNG with a relatively small period in the LMC algorithm. The advantage of using an entire period of a PRNG is that the points are more evenly distributed, which is more desirable for numerical integration. We illustrate the balancing property of an entire PRNG in Figure 1.

The main contributions of this paper are threefold. First, we propose a novel technique of using quasi-random numbers in Langevin-type algorithms, which can be applied to a wide range of such algorithms by substituting i.i.d. random numbers with a sequence of quasi-random numbers. The quasi-random numbers are constructed similarly as usual PRNGs, therefore no extra computational complexity is required. Second, we evaluate the performance of the proposed LQMC algorithm in a variety of numerical experiments, demonstrating that it can significantly reduce the mean squared error (MSE) of traditional LMC by a factor ranging from 2 to 500, depending on the problem. Finally, we provide theoretical analysis showing that LQMC can reduce the Monte Carlo part of the error from \(O(n^{-1/2})\) to \(O(n^{-1+})\) for any \(>0\) in situations where the Markov chain is strongly contracting and the integrand function \(f\) is sufficiently regular. This error reduction is consistent with the usual improvement achieved by using quasi-Monte Carlo in place of plain Monte Carlo.

The rest of the paper is organized as follows. In Section 2, we provide some background on LMC and QMC, followed by a review of related work. Section 3 describes the LQMC algorithm and its implementation details. In Section 4, we present theoretical guarantees for the proposed method. Finally, in Section 5, we provide empirical results to evaluate the performance of LQMC and compare it with the standard LMC algorithm.

## 2 Backgrounds

This section provides some background on Langevin Monte Carlo and quasi-Monte Carlo.

### Langevin Monte Carlo

Suppose we want to sample from the target distribution \(()(-U())\) where \(^{d}\) and \(U\) is known as the potential function. LMC algorithms are based on Euler-Maruyama discretization of the Langevin diffusion \((t)\), which satisfies the stochastic differential equation

\[(t)=- U((t))t+W_{t},\] (1)

Figure 1: Scatter plots of 251 points generated from Mersenne Twister 19937 (left) and 251 points generated from a linear congruential generator (LCG) of period 251. Points from an entire period of a pseudo-random number generator (right) fill the unit square more evenly than the same number of points from a PRNG with a larger period (left).

where \(\{W_{t}\}_{t 0}\) is a \(d\)-dimensional standard Brownian motion. Under mild technical conditions, the Langevin diffusion \((t)\) has \(\) as its unique invariant distribution (Roberts and Tweedie, 1996). With a discretization step size \(h\), LMC updates the sample \(_{k}\) by

\[_{k+1}_{k}-h U(_{k})+_{k+1}\] (2)

where \(_{k}}{{}}(0,I_{d})\).

In many applications, we are interested in computing the expectation \(:=_{}[f()]\) over \(\) for some \(\)-integrable function \(f\). The LMC estimator of \(\) is the sample average

\[_{n}=_{k=1}^{n}f(_{k}),\]

where \(n\) is the number of iterations.

Teh et al. (2016) provide an asymptotic bias-variance decomposition of the MSE of the weighted average \(^{n}h_{k}f(_{k})}{_{k=1}^{n}h_{k}}\) and show that the optimal step size scales as \(h_{k} k^{-1/3}\), leading to an MSE of order \(O(n^{-2/3})\). Here \(h_{k}\) is the step size used at the \(k\)-th iteration. Vollmer et al. (2016) generalize this result to the non-asymptotic setting with a constant step size \(h\). They show that the MSE is of order \(O(h^{2}+)\), where \(h^{2}\) corresponds to the squared bias and \(\) corresponds to the variance.

### Quasi-Monte Carlo

QMC is an alternative to Monte Carlo for numerical integration and is well-known for having much higher accuracy than Monte Carlo. QMC is primarily designed to numerically evaluate the integral \(=_{^{d}}f()\). It estimates \(\) by taking points \(_{i}^{d}\) and let the estimator be

\[=_{i=1}^{n}f(_{i}).\]

Unlike Monte Carlo which takes \(_{i}\) to be identically independently distributed (i.i.d.), QMC constructs the point set \(\{_{i}\}_{i=1}^{n}\) that aims to minimize the star discrepancy

\[D_{n}^{*}=D_{n}^{*}(_{1},,_{n})=_{ ^{d}}_{i=1}^{n}1\{_{i}[, )\}-_{j=1}^{d}a_{j}.\] (3)

The star discrepancy measures the uniformity of the point sets by comparing the fraction of points inside \([,)\) and the volume \(_{j=1}^{d}a_{j}\), taking supreme over all the rectangles inside \(^{d}\) anchored at \(\). QMC can generate points with \(D_{n}^{*}=O(n^{-1}( n)^{d-1})\), thus QMC is also known as low-discrepancy sequence. Commonly used QMC points include Sobol' sequence (Sobol', 1967), Niederreiter's sequence (Niederreiter, 1987), Halton's sequence, and lattice rules. For a comprehensive survey, we refer to the monograph Dick and Pillichshammer (2010). If the integrand \(f\) has bounded variation in the sense of Hardy and Krause \(\|f\|_{}\), then the Koksma-Hlawka inequality (see e.g. Dick and Pillichshammer (2010)) bounds the integration error by

\[|-| D_{n}^{*}\|f\|_{} O(n^{-1}( n)^{d-1}).\] (4)

While the Koksma-Hlawka inequality shows that QMC is asymptotically better than usual Monte Carlo, it doesn't provide a practical way to estimate the error. Moreover, integrands might have infinite Hardy-Krause variation.

One can apply randomization techniques to QMC to address both problems. Common randomization techniques include random shifts (Cranley and Patterson, 1976) and scrambling (Owen, 1995). For RQMC samples \(_{1},,_{n}\), each \(_{i}(^{d})\) individually but they have the low-discrepancy property collectively with probability 1. One can estimate the error by multiple independent random replicates. For sufficiently smooth \(f\), the scrambled Sobol' sequence has variance \(O(n^{-3}( n)^{d-1})\)(Owen, 1997a,b).

### Related work

The first attempt to apply quasi-random numbers to simulate stochastic differential equations was made by Hofmann and Mathe (1997). They showed that if a numerical scheme is weakly convergent with i.i.d. samples, then using completely uniformly distributed (CUD) sequences also leads to consistent estimation. They also demonstrated that certain low-discrepancy sequences are not suitable for simulating SDEs. There have also been some efforts to apply QMC to MCMC. Owen and Tribble (2005) proposed to apply CUD sequences to a Metropolis algorithm and showed that the method is consistent in problems with finite state spaces. Chen et al. (2011) generalized the consistency result to continuous state spaces under the assumption that the Markov chain is a contraction. More recently, Dick et al. (2016); Dick and Rudolf (2014) proved that there exists constructions of the driving sequence \(\{_{k}\}_{k 1}\) such that the discrepancy between the empirical distribution of MCMC samples and the target distribution is bounded by \(O(n^{-1/2}( n)^{1/2})\), the same rate achieved by random inputs. Another line of applying QMC to Markov chains is known as array-RQMC proposed by L'Ecuyer et al. (2008). Array-RQMC runs in parallel multiple Markov chains, and each iteration involves a complicated reordering of the states so that the low-discrepancy among the chains is maintained. Empirically, it achieves significantly smaller estimation error than usual MCMC, but theoretical guarantees remain a challenging open problem.

There has been a growing interest in using QMC techniques in various machine learning tasks, such as variational inference (Buchholz et al., 2018; Liu and Owen, 2021), policy learning and evaluation (Arnold et al., 2022), reinforcement learning with evolution strategies (Choromanski et al., 2019; Rowland et al., 2018), compression of large datasets (Dick and Feischl, 2021), example selection in stochastic gradient descent (SGD) (Lu et al., 2021), and deep learning for solving partial differential equations (Longo et al., 2021).

Numerous efforts have been devoted to improving LMC and stochastic gradient Langevin dynamics (SGLD). To overcome the instability of Euler-Maruyama discretization, various numerical schemes have been proposed, including higher-order integrators (Chen et al., 2015), underdamped LMC (Cheng et al., 2018), and stochastic Runge-Kutta diffusion (Li et al., 2019). For SGLD, variance reduction techniques such as SAGA and SVGR (Dubey et al., 2016) and control variates (Baker et al., 2019) have been proposed. LMC also provides a useful perspective for optimization, as demonstrated by the analyses in Chen et al. (2016); Dalalyan (2017); Raginsky et al. (2017); Xu et al. (2018); Erdogdu et al. (2018). Our contribution is orthogonal to all the aforementioned work, as our algorithm only modifies the random numbers used in the algorithm. Therefore, our method can be combined with other algorithms without interference.

## 3 QMC for LMC

In the LMC algorithm, we can think of the Markov chain as being driven by a sequence of uniform variables \(_{k}\) in the unit cube \(^{d}\). For instance, the Gaussian perturbation can be represented as \(_{k}=^{-1}(_{k})\), where \(^{-1}\) denotes the inverse Gaussian CDF applied element-wise to \(_{k}\). If a stochastic gradient is employed, the randomness associated with the stochastic gradient can also be expressed as uniform variables. Therefore, we can write the transition of the Markov chain as \(_{k+1}=(_{k},_{k+1})\). In typical computer experiments, \(_{k}\) are not really i.i.d. but are deterministic pseudo-random numbers. In this section, we will describe an alternative method of generating the pseudo-random numbers \(_{k}\), which are carefully constructed and can lead to more accurate sample averages.

The idea here is to use point sets that are more evenly distributed such as QMC points, which can lead to significant improvement in the usual Monte Carlo estimation. However, caution is required when using QMC points to simulate an SDE like (1). This is because the correlation between successive QMC samples may introduce undesired behavior in the Markov chain, as demonstrated in (Tribble, 2007, Section 3.2). To avoid the dependence among successive values, we require that the blocks of points \((v_{i},v_{i+1},,v_{i+d-1})\) for any lag \(d\) are uniformly distributed. This notion of uniformity is formally known as completely uniformly distributed (CUD, Korobov (1948)), which we define next.

We say an infinite sequence \(\{_{i}\}_{i=1}^{}^{d}\) is uniformly distributed on \(^{d}\) if the star discrepancy \(D^{*}(\{_{i}\}_{i=1}^{n})\) goes to 0 as \(n\), where the star discrepancy is defined in Equation 3.

**Definition 3.1** (Completely uniformly distributed sequence (CUD)).: _An infinite sequence \(\{v_{i}\}_{i=0}^{}\) is called completely uniformly distributed, if for all positive integer \(d\), the sequence \(\{(v_{k},,v_{k+d-1})\}_{k=0}^{}^{d}\) is uniformly distributed on \(^{d}\). A triangular array \(_{n}=(v_{n,1},,v_{n,N_{n}})\) is called array-CUD, if for all positive integer \(d\), \(D^{*}((v_{n,1},,v_{n,d}),(v_{n,2},,v_{n,d+1}),,(v_{n,N_{n}-d+ 1},,v_{n,N_{n}})) 0\) as \(n\), \(N_{n}\)._

In other words, the subsequent \(d\)-tuples in a CUD sequence are uniformly distributed in the \(d\)-dimensional unit cube for any positive dimension \(d\). Now we are ready to present the main algorithm.

### LQMC algorithm

Let \(\{v_{i}\}_{i=0}^{}\) be a CUD sequence. Let \(_{k}=(v_{kd},,v_{(k+1)d-1})^{d}\) be the \(k\)-th non-overlapping \(d\)-tuple from the sequence (\(k 0\)). A CUD sequence is often constructed deterministically. They can further be randomized using the Cranley-Patterson (i.e. random shift) rotation (Cranley and Patterson, 1976)

\[_{k}_{k}+ 1,\]

where \((^{d})\). The Cranley-Patterson rotation randomly shifts each dimension of \(_{k}\) by a uniform random number separately. Then each \(_{k}\) is uniformly distributed on \(^{d}\). If we apply the inverse Gaussian CDF to each coordinate of \(_{k}\), then \(^{-1}(_{k})(0,I_{d})\). In the Langevin-type algorithms, we will let \(_{k}=^{-1}(_{k})\) and use \(_{k}\) as the Gaussian perturbation in the \(k\)-th iteration. Specifically, each iteration takes the form

\[_{k+1}=_{k}-h U(_{k})+^{-1}(_{k+1}), k 0.\]

Thus the transition map is \((,)=-h U()+^{-1}()\). In practice, we can only run finite many iterations. In the following, we will describe how to construct a finite CUD sequence and feed it into the LMC algorithm.

### Construction of CUD sequences

A finite CUD (array-CUD) sequence is often implemented by using an entire period of a pseudo random number generator with a small period (Tribble, 2007). There exist other constructions of CUD sequences. For further details, interested readers can refer to Levin (1999). We propose to use the linear-feedback shift register (LFSR) provided in Chen (2011), because it has demonstrated good performance and the computational effort required is comparable to other commonly used PRNGs.

The binary Galois LFSR (Tausworthe generator, Tausworthe (1965)) of order \(m\) updates the states \(b_{i}\{0,1\}\) recursively by

\[b_{i}=_{j=0}^{m-1}a_{j}b_{i-m+j} 2, i m\]

with initial states \(b_{0},b_{1},,b_{m-1}\) pre-specified. The \(m\)-tuple \((b_{i},b_{i+1},,b_{i+m-1})(2)^{m}\) can only take \(2^{m}\) different values. If there is an \(m\)-tuple that is all zero, then all \(b_{i}\)'s in this sequence must be zero. So the period of the sequence \(\{b_{i}\}_{i 0}\) is at most \(n=2^{m}-1\). Moreover, the period is exactly equal to \(2^{m}-1\) if and only if the characteristic polynomial

\[x^{m}+a_{m-1}x^{m-1}++a_{1}x+a_{0}\]

is a primitive polynomial over \((2)\)(Niederreiter, 1992, Lemma 9.1). Given the states \(\{b_{i}\}_{i 0}\) and an offset \(s>0\) such that \((s,2^{m}-1)=1\), \(v_{i}\) is computed with

\[v_{i}=_{j=0}^{m-1}b_{si+j}2^{-j-1}, i=0,1,,2^{m}-2.\]

That is, for each \(i\), we take the \(m\)-tuple \((b_{si+j})_{0 j<m}\) and interpret it as the binary expansion of \(v_{i}\). For the next step, we jump \(s\) bits ahead in the sequence \(\{b_{i}\}_{i 0}\) and use the \(m\)-tuple starting from \(b_{s(i+1)}\). Chen (2011) provided a table of the LFSR generators for \(10 m 32\). They searched the offsets so that the LFSR has good equi-distributed properties. Our experiments use the LFSR generators listed there.

Given the sequence \(\{v_{i}\}_{i=0}^{n-1}\) of length \(n\), we repeat it \(d\) times and arrange \(v_{i}\)'s in the following \(n d\) matrix

\[v_{0}&v_{1}&&v_{d-1}\\ v_{d}&v_{d+1}&&v_{2d-1}\\ &&&\\ v_{(n-1)d}&v_{(n-1)d+1}&&v_{nd-1}.\] (5)

We run the LMC algorithm \(n=2^{m}-1\) iterations. The \(k\)-th uniform vector \(_{k}\) is the \(k\)-th row of the above matrix. The procedure is summarized in Algorithm 1.

```
0: Number of iterations \(n=2^{m}-1\) such that \((2^{m}-1,d)=1\), step size \(h\), initial value \(_{0}\)  Generate an LFSR sequence \(\{v_{i}\}_{i 0}\) of period \(2^{m}-1\).  Let \(_{k}=(v_{(k-1)d},,v_{kd-1})^{d}\), for \(1 k n\).  Apply Cranley-Patterson rotation (random shift) to \(_{k}\)'s. for\(k 1,,n\)do \(_{k}_{k-1}-h U(_{k-1})+^{-1}( _{k})\) endfor Output:\(_{1},,_{n}\) ```

**Algorithm 1** Langevin quasi-Monte Carlo (LQMC)

If \((n,d)=1\), then each column of the matrix (5) contains no repeated values. This means that among the \(n=2^{m}-1\) iterations of the LQMC algorithm, each dimension uses one value in each sub-interval \((},}]\) at most once (\(0 k 2^{m}-1\)). This perfect one-dimensional stratification is one of the reasons why CUD may achieve smaller estimation error than pseudo-random numbers. If \((n,d)>1\), then we take \(d^{}\) to be the smallest integer greater than \(d\) and co-prime with \(n\). We then create the matrix in (5) similarly but with \(d^{}\) columns. In the LQMC algorithm, we take \(_{k}\) to be the \(k\)-th row of the matrix but only use the first \(d\) coordinates.

Algorithm 1 may seem to be restricted by having a fixed number of iterations, \(n=2^{m}-1\). However, in practice, the LQMC algorithm can be started with an initial value of \(m\). If the chain does not converge after \(2^{m}-1\) iterations, one can continue the chain with another freshly generated LFSR, possibly with a larger period. This allows for flexibility in adjusting the number of iterations based on the convergence of the chain. Additionally, if a burn-in period is required, one can first run the algorithm with an LFSR of a small period to serve as the burn-in stage and then continue with a larger LFSR. Furthermore, running multiple chains with independent random shifts is embarrassingly parallel. We present the algorithm in the form of the basic LMC algorithm with accurate gradient and constant learning rate. However, as we noted previously, other Langevin-type algorithms can also utilize the CUD sequence directly by substituting the pseudo-random numbers with the LFSR sequence.

## 4 Theoretical guarantee

Here we study the estimation error \(|n^{-1}_{k=1}^{n}f(_{k})-(f)|\) of LQMC for some test function \(f\) that is 1-Lipschitz and bounded. As the first attempt to prove the convergence rate of using QMC in LMC, we impose the relatively strong conditions of smoothness and convexity.

**Assumption 1**.: _The potential function \(U\) is \(L\)-smooth_

\[\| U()- U(^{})\|_{2} L\|-^{ }\|_{2},\;,^{},\]

_and \(M\)-strongly convex_

\[U(^{}) U()+ U()^{}( ^{}-)+\|^{}-\|_{2}^{2}, \;,^{}.\]

We will also assume a constant step size \(h\). While LMC with vanishing step sizes converges weakly to the target distribution, in practice a constant step size is often used (Vollmer et al., 2016; Brosse et al., 2018). With a constant step size, we can derive a non-asymptotic error bound for LQMC.

Assumption 1 implies that if the step size \(h\), then the transition map \(\) is a strong contraction with parameter \(=1-hM\), i.e.

\[\|(,)-(^{},)\|_{2}=\|- ^{}-h( U()- U(^{}))\|_{2}\| -^{}\|_{2}.\] (6)

See e.g. Lemma 2 of Dalalyan and Karagulyan (2019). The strong contraction implies that if we start two chains from \(\) and \(^{}\), and use the same random numbers at every step, then the two chains will merge exponentially fast. In other words, the state \(_{k}\) largely depends on the most recent iterations and quickly forgets about the past history. Formally, let \(_{k}^{()}=(_{k},,_{k-+1})\) denote the random numbers used in the most recent \(\) steps. Define the \(\)-step transition as

\[_{k}=_{}(_{k-},_{k}^{()})\]

and let \(_{}(_{k}^{()})\) denote the value of \(f(_{k})\) marginalized over \(_{k-}\), i.e.

\[_{}(_{k}^{()})= f_{}(x,_{ k}^{()})(x).\]

Thus \(_{}(_{k}^{()})\) only depends on the most recent \(\) iterations. Due to the strong contraction, \(|_{}(_{k}^{()})-f(_{k})|\) decays exponentially fast with \(\). So for large \(\), the estimation error of \(n^{-1}_{k=1}^{n}f(_{k})\) is close to the error of \(_{k=+1}^{n}_{}(_{k}^{()})\). The latter can be viewed as a \(d\)-dimensional numerical integration scheme based on the point set \(\{_{k}^{()}\}_{k=+1}^{n}\). By leveraging the discrepancy bound of the LFSR sequence and assuming that \(_{}\) has bounded variation in the sense of Hardy and Krause, we can derive an error bound using the Koksma-Hlawka inequality (4). Now we state the main error bound and leave the detailed proof in the Appendix A.

**Theorem 4.1** (Error bound of LQMC).: _Let Assumption 1 hold. Define the step size \(h\), \(=1-hM\), \(=(1/2)_{}h\). Let \(_{1},,_{n}\) be the output of Algorithm 1 which runs \(n\) iterations with step size \(h\). Assume the LFSR sequence \(\{v_{i}\}_{i 0}\) in use has period \(n=2^{m}-1\), offset \(s\), and gcd\((m,n)=(d,n)=1\). If \(_{}\) has bounded variation in the sense of Hardy and Krause, then as \(n\) we have_

\[|_{k=1}^{n}f(_{k})-(f)| C_{1}n^{-1+ }+C_{2}h^{1/2},\ >0.\]

_Here \(\) hides poly-logarithmic factors \(( n)^{d}\), \(C_{1}\) depends on \(d,\) and \(\|_{}\|_{}\), and \(C_{2}=}{2}d+_{0 k n}\|_{k}\|+_{}[\|\|]\)._

The upper bound consists of two terms. The first term represents the numerical integration error, which arises from the discrepancy of the point set used in the integration scheme. By utilizing low-discrepancy CUD sequences, we can reduce this numerical integration error (the first term) from the standard rate of \(O(n^{-1/2})\) to a faster rate of \(O(n^{-1+})\) for any \(>0\). However, it is important to note that when using a constant step size \(h\) in LMC, the bias term (second term) does not vanish. This bias term includes not only the discretization error of the Langevin diffusion, but also the difference between \(f(_{k})\) and its truncated version \(_{}(_{k}^{()})\). Consequently, the bias term in our analysis is larger than the bias term in Vollmer et al. (2016), which employs different techniques and assumptions based on the Poisson equation.

The theorem's assumption of finite Hardy-Krause variation is a common requirement in error bounds for QMC methods, and it can be challenging to verify in practice. Basu and Owen (2016) provide sufficient conditions in order for \(f_{}\) to have finite HK variation, requiring the \(\)-step transition \(_{}\) to be sufficiently smooth. In the next section, we aim to assess the practical performance of the proposed LQMC algorithm through numerical experiments.

## 5 Numerical experiments

To comprehensively evaluate the performance of the algorithm, we will consider both convex and non-convex potentials, both low-dimensional and high-dimensional state spaces, both accurate and stochastic gradients, both smooth and discontinuous integrands, as well as different learning rate schedules. Additional numerical results can be found in the Appendix B.

### Bayesian logistic regression

We first consider the Bayesian logistic model

\[y_{i}  x_{i}((1+(-x_{i}^{}))^{-1 }), 1 i N,\] \[ (0,I_{d}).\]

We take \(N=20\), \(d=10\). The features \(x_{i}\) are generated from \((0,)\) with \(_{ij}=2^{-|i-j|}\). The coefficients \(\) and the data \(y_{i}\)'s are generated from the same model. We consider the test functions \(f(x)=x_{j},x_{1}^{2},_{\{x_{j}>0\}}\) for \(j=1,,d\). The step size \(h\) is fixed to \(0.001\).

We compute the MSE of the estimator based on usual LMC and the proposed LQMC with CUD sequences and report the MSE averaged over all coordinates and 20 random replicates. We do not have a closed form for the expectations \([f]\), so the ground truth is estimated using a high-accuracy estimator proposed in He et al. (2023) using scrambled Sobol' sequence with a very large sample size.

In Figure 2 (top panel), we present a log-log plot of the MSE against the number of iterations. Across all three test functions, we observe that LQMC reduces the MSE by a factor ranging from 4 to 8. As the number of iterations increases, the curve corresponding to LQMC reaches a plateau. This behavior can be attributed to the discretization error inherent in the unadjusted LMC, which cannot be further reduced by increasing the number of iterations.

In the bottom panel of Figure 2, we increase the number of observations to \(N=100\) and incorporate stochastic gradient estimation in the Langevin algorithm. Specifically, at each iteration, we estimate the gradient using a random subset of 10 observations. The results demonstrate that LQMC still provides a big improvement when \(n\) is smaller than \(2^{14}\). However, as \(n\) surpasses \(2^{14}\), we observe that the LQMC curve flattens again. It is worth noting that the improvement achieved by LQMC in this scenario is less pronounced compared to the previous example, primarily due to the presence of noise in the gradient estimates.

### Bayesian linear regression

Now we try a higher-dimensional example with Bayesian linear regression. The model is defined as

\[y_{i} (x_{i}^{},^{2}=4^{-1}), 1  i N,\] \[ (0,I).\]

We take \(d=100\) and \(N=20\). We generate \(x_{i}^{d}\) similarly as in the logistic regression example. The test functions and step size are also unchanged. The posterior distribution of \(\) has the closed form \(((X}{^{2}}+I)^{-1}},(X}{^{2}}+I)^{-1})\). The results are shown in Figure 3. We see that even at 100 dimension, LQMC still brings a substantial improvement over LMC in terms of MSE. In

Figure 2: Bayesian logistic regression with accurate gradients (top) and stochastic gradients (bottom).

particular, for the integrand \(f(x)=x_{j}\), LQMC achieves a reduction in MSE of approximately 500-fold compared to LMC.

### A hierarchical Bayesian model

We consider a hierarchical Bayesian model known as the crossed random effect model

\[Y_{ij}(+a_{i}+b_{j},1), 1 i I,\;1  j J,\] \[(0,1),\;a_{i}}{{ }}(0,_{a}^{2}),\;b_{j}}{{ }}(0,_{b}^{2}),\] \[(_{a}^{2}),\;(_{b}^{2})}{{ }}(0,1).\]

The goal is to sample from the posterior distribution of \((,,,(_{a}^{2}),(_{b}^{2}))\), which has dimension \(d=I+J+3\). We take \(I=3\), \(J=5\). We will consider the test functions \(f(x)=x_{j}\) (\(1 j d\)). The ground truth of \([f(x)]\) is estimated by Langevin dynamics with Metropolis adjustments (MALA) using a large sample size.

We will compare the performance of the LQMC algorithm using three different step sizes: a constant step size of \(10^{-4}\), a constant step size of \(10^{-2}\), and decreasing step sizes with \(h_{k}=c_{0}(c_{1}+k)^{-1/3}\). The choice of \(c_{0}\) and \(c_{1}\) ensures that the step size decreases from \(10^{-2}\) to \(10^{-4}\) throughout the entire algorithm. The use of the exponent \(-1/3\) in the decreasing step sizes is recommended in Teh et al. (2016). The results of these comparisons are presented in Figure 4.

In the small step size case (left panel), we observe that the errors of LMC and LQMC are initially comparable for small values of \(n\). This is because the algorithm converges slowly, and thus the error is dominated by the bias. However, as \(n\) increases, the improvement of LQMC becomes evident. In the large step size case (middle panel), the MSE of LQMC is consistently smaller than that of LMC even for small values of \(n\). This is because the algorithm converges faster to the target distribution with a larger step size \(h\). Therefore, the improvement of LQMC is more pronounced. Interestingly, in this particular example, using decreasing step sizes yields similar accuracy to using a constant step size of \(10^{-4}\). It is worth noting that the MSE of LMC does not decrease at a rate of \(n^{-2/3}\) as in Teh et al. (2016). This is because the line in the plot does not represent the accuracy against the iteration \(k\) within a single training process. Instead, it reflects the accuracy achieved after completing all \(n\) iterations of the algorithm, considering different values of \(n\).

Figure 4: Crossed random effect.

Figure 3: Bayesian linear regression in 100 dimensions.

### Nonconvex potential

Finally we investigate a double-well potential function \(U(x)=x^{2}-(1+x^{2})\) from Pages and Panloup (2018). We know \([x]=0\) and \([_{\{x>0\}}]=0.5\). The second moment \([x^{2}]\) is computed by Gaussian quadrature. See the results in Figure 5. Since the potential has two separate local minimums, it takes longer for the Langevin algorithm to explore the space sufficiently and converge to the target distribution. Once converged, the improvement of LQMC over LMC is still significant.