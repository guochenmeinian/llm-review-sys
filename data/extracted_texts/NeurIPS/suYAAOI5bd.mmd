# On the Expressive Power of Tree-Structured Probabilistic Circuits

Lang Yin

Department of Computer Science

University of Illinois Urbana-Champaign

langyin2@illinois.edu

&Han Zhao

Department of Computer Science

University of Illinois Urbana-Champaign

hanzhao@illinois.edu

###### Abstract

Probabilistic circuits (PCs) have emerged as a powerful framework to compactly represent probability distributions for efficient and exact probabilistic inference. It has been shown that PCs with a general directed acyclic graph (DAG) structure can be understood as a mixture of exponentially (in its height) many components, each of which is a product distribution over univariate marginals. However, existing structure learning algorithms for PCs often generate tree-structured circuits or use tree-structured circuits as intermediate steps to compress them into DAG-structured circuits. This leads to the intriguing question of whether there exists an exponential gap between DAGs and trees for the PC structure. In this paper, we provide a negative answer to this conjecture by proving that, for \(n\) variables, there exists a quasi-polynomial upper bound \(n^{O( n)}\) on the size of an equivalent tree computing the same probability distribution. On the other hand, we also show that given a depth restriction on the tree, there is a super-polynomial separation between tree and DAG-structured PCs. Our work takes an important step towards understanding the expressive power of tree-structured PCs, and our techniques may be of independent interest in the study of structure learning algorithms for PCs.

## 1 Introduction

Probabilistic circuits (PCs) , also commonly known as sum product networks (SPNs) , are a type of deep graphical model that allow exact probabilistic inference efficiently in linear time with respect to the size of the circuit. Like other deep models, the parameters of a PC can be learned from data samples . Because of these desirable properties, they have been increasingly applied in various contexts, including generative modeling , image processing , robotics , planning  and sequential data including both textual and audio signals . Compared with deep neural networks, the sum and product nodes in PCs admit clear probabilistic interpretation  of marginalization and context-specific statistical independence , which opens the venue of designing efficient parameter learning algorithms for PCs, including the expectation-maximization (EM) algorithm , the convex-concave procedure (CCCP) , and the variational EM algorithm .

Perhaps one of the most important properties of PCs is that they can be understood as a mixture of exponentially (in its height) many components, each of which is a product distribution over univariate marginals . Intuitively, each sum node in PC can be viewed as a hidden variable that encodes a mixture model  and thus a hierarchy of sum nodes corresponds to an exponential number of components. This probabilistic interpretation of PCs has led to a number of interesting structure learning algorithms . However, almost all of the existing structure learning algorithms for PCs output tree-structured circuits, or use tree-structured circuits as intermediates to compress them into DAG-structured circuits. Because of the restricted structure of trees, such algorithms do not fully exploit the expressive power of PCs with general DAG structures, and oftenoutput tree-structured PCs with exceedingly large sizes . Yet, from a theoretical perspective, it remains open whether there truly exists an exponential gap between DAGs and trees for the PC structure. Being able to answer this question is important for understanding the expressive power of tree-structured PCs, and may also lead to new insights in structure learning algorithms for PCs.

### Our Contributions

In this work we attempt to answer the question above by leveraging recent results in complexity theory [11; 26; 33]. Our contributions are two-folds: an upper and lower bound for the gap between tree and DAG-structured PCs. In what follows we will first briefly state our main results and then introduce the necessary concepts and tools to tackle this problem.

An Upper BoundIn Section 3, inspired by earlier works in Valiant et al.  and Raz and Yehudayoff , we show that, for a network polynomial that can be computed efficiently with a DAG-structured PC, there always exists a tree-structured PC of a quasi-polynomial size to represent it. An informal version of our main result for this part is stated below.

**Theorem 1.1** (Informal).: _Given a network polynomial of \(n\) variables, if this polynomial can be computed efficiently by a PC of size \((n)\), then there exists an equivalent tree-structured PC of depth \(O( n)\) and of size \(n^{O( n)}\) that computes the same network polynomial._

We prove this result by adapting the proof in Raz and Yehudayoff . Our construction involves two phases: Phase one applies the notion of _partial derivatives_ for general arithmetic circuits to represent intermediate network polynomials alternatively, and construct another DAG-structured PC using those alternative representations; we will provide fine-grained analysis on the new DAG, such that its depth is \(O( n)\) and its size is still \((n)\). Phase two applies the standard duplicating strategy for all nodes with more than one parent to convert the new DAG into a tree. This strategy will lead to an exponential blowup for an arbitrary DAG with depth \(D\), since the size of the constructed tree will be \(n^{O(D)}\). However, note that the DAG constructed in the first phase has depth \(O( n)\). Combining it with the duplicating strategy, we will be able to construct an equivalent tree-structured PC of size upper bounded by \(n^{O( n)}\), as desired.

The original algorithm in Raz and Yehudayoff  only reduces the depth to \(O(^{2}n)\) due to their restriction on the graph of using nodes with at most two children. This restriction is not necessary for PCs, and by avoiding it, we show that the depth can be further reduced to \(O( n)\) with a slight modification of the original proof in Raz and Yehudayoff .

A Lower BoundIn Section 4, we show that under a restriction on the depth of the trees, there exists a network polynomial that can be computed efficiently with a DAG-structured PC, but if a tree-structured PC computes it, then the tree must have a super-polynomial size. The following informal theorem states our main result for this part, which will be formally addressed in Section 4.

**Theorem 1.2** (Informal).: _Given \(n\) random variables, there exists a network polynomial on those \(n\) variables, such that it can be efficiently computed by a PC of size \(O(n n)\) and depth \(O( n)\), but any tree-structured PC with depth \(o( n)\) computing this polynomial must have size at least \(n^{(1)}\)._

Our result is obtained by finding a reduction to Fournier et al. . We first fix an integer \(k\) and a network polynomial of degree \(n=2^{2k}\). To show that the polynomial is not intrinsically difficult to represent, i.e., the minimum circuit representing it shall be efficient, we explicitly construct a PC of depth \(O( n)\) and size \(O(n n)\). Next, suppose via a black box, we have a minimum tree-structured PC of depth \(o( n)\) computing this polynomial. After removing some leaves from that minimum tree but maintaining its depth, we recover a regular arithmetic tree that computes a network polynomial of degree \(=2^{k}\). Moreover, as shown in , if an arithmetic tree with depth \(o( n)\) computes this low-degree polynomial, then the size of the tree must be at least \(n^{(1)}\). Our operations on the minimum tree PC must reduce its size; therefore, the original tree must have a larger size than \(n^{(1)}\), and this fact concludes our proof.

### More Related Work

There is an extensive literature on expressive efficiency of network structures for PCs and probabilistic generating circuits (PGCs) , another probabilistic graphic model. Very recently, it was shown in Broadrick et al.  that PCs with negative weights are as expressive as PGCs. The investigation on PCs has started as early as in Delalleau and Bengio  and later in Martens and Medabalimi . In neural networks and variants, this topic, along with the relationship between expressive efficiency and depth/width, has attracted many interests as well [10; 16; 18; 20; 21; 28; 31; 32]. In particular, Martens and Medabalimi [19; Theorem 34] has shown that there exists a network polynomial with a super-polynomial minimum tree expression, but it is unclear whether the same polynomial can be computed by a polynomial-sized DAG. Our work provides a positive answer to this question. For arbitrary network polynomials, finding a minimum DAG-structured PC is reducible to a special case of the _minimum circuit size problem_ for arithmetic circuits, which remains to be a longstanding open problem in circuit complexity.

## 2 Preliminaries

We first introduce the setup of probabilistic circuits and relevant notation used in this paper.

NotationA rooted directed acyclic (DAG) graph consists a set of nodes and directed edges. For such an edge \(u v\), we say that \(u\) is a _parent_ of \(v\), and \(v\) is a _child_ of \(u\). We use \((u)\) to denote the set of children of the node \(u\). We say there is a directed path from \(a\) to \(b\) if there is an edge \(a b\) or there are nodes \(u_{1},,u_{k}\) and edges \(a u_{1} u_{k} b\); in this case, we say that \(a\) is an _ancestor_ of \(b\) and that \(b\) is a _descendant_ of \(a\). If two vertices \(v\) and \(w\) are connected via a directed path, we call the number of edges in a shortest path between them as the _distance_ between them, denoted by \((v,w)\). A directed graph is _rooted_ if one and only one of its nodes has no incoming edges. A _leaf_ in a DAG is a node without outgoing edges. A _cycle_ in a directed graph is a directed path from a node to itself, and a directed graph without directed cycles is a DAG. For two disjoint sets \(A\) and \(B\), we will denote their disjoint union by \(A B\) to emphasize their disjointedness.

Clearly, each directed graph has an underlying undirected graph obtained by removing arrows on all edges. Although by definition, a DAG cannot have a directed cycle, but its underlying undirected graph may have an undirected cycle. If the underlying undirected graph of a DAG is also acyclic, then that DAG is called a **directed tree**. Every node in a directed tree has at most one parent. If two nodes share a parent, one is said to be a _sibling_ of the other.

Complexity ClassesIn what follows we introduce the necessary complexity classes that will be used throughout the paper. Let \(f(n)\) be the runtime of an algorithm with input size \(n\).

* A function \(f(n)\) is in the **polynomial** class \((n)\) if \(f(n) O(n^{k})\) for a constant \(k\).
* A function \(f(n)\) is in the **super-polynomial** class if \(f(n)\) is not asymptotically bounded above by any polynomial. Formally, this requires \(f(n)(n^{c})\) for any constant \(c>0\), i.e. \(_{n}}=\) for any \(c>0\).
* A function \(f(n)\) is in the **quasi-polynomial** class if it can be expressed in the form \(2^{( n)}\).
* A function \(f(n)\) is in the **exponential** class if it can be expressed in the form \(2^{O((n))}\).

Probabilistic CircuitsA probabilistic circuit (PC) is a probabilistic model based on a rooted DAG. Without loss of generality, in our work, we focus on PCs over Boolean random variables. We first introduce the notion of _network polynomial_. For each Boolean variable \(X\), we use the corresponding lower case alphabet \(x\) to denote the indicator of \(X\), which is either 0 or 1; for the same variable, \(\) represents the negation. In many cases, we use \(1:N\) to denote the index set \([N]\). A PC over Boolean variables \(\{X_{1},,X_{n}\}\) computes a polynomial over the set of indicators \(\{x_{1}, x_{n},_{1},,_{n}\}\); we will refer this polynomial as the _network polynomial_. In the network, the leaves are indicators of variables, and all other nodes are either sum or product nodes; a node that is not a leaf may also be called an _internal_ node. Each internal node computes a polynomial already: a sum node computes a weighted sum of the polynomials computed by its children, and a product node computes the product of the polynomials computed by its children. A PC is said to be _normalized_ if the weights of the outgoing edges from a sum node sum to one. It was shown in Zhao et al.  that, every unnormalized PC can be transformed into an equivalent normalized PC within linear time.

To represent valid probability distributions, a PC must satisfy two structural properties: _decomposability_ and _smoothness_. To define them, we need to define the _scope_ of a node, which is the set of variables whose indicators are descendants of that node. For a node \(v\), if the indicator \(x\) of the variable \(X\) is one of descendants of \(v\), then \(X(v)\); more generally, \((v)=_{v^{}(v)}(v^{})\).

**Definition 2.1** (Decomposability and Smoothness).: _A PC is decomposable if and only if for every product node \(v\) and any pair of its children \(v_{1}\) and \(v_{2}\), we have \((v_{1})(v_{2})=\). A PC is smooth if and only if for each sum node, all of its children have the same scope._

In this paper we restrict our attention to PCs that are both decomposable and smooth, since otherwise we can always transform a PC into an equivalent one that is both decomposable and smooth in quadratic time . The _degree_ of a monomial is the sum of the exponents of all its variables, and the _degree_ of a polynomial \(f\), denoted by \((f)\) is the highest degree among its constituent monomials. A polynomial is said to be _homogeneous_ if all of its monomials have the same degree. A PC is said to be _homogeneous_ if all of its sum and product nodes compute a homogeneous polynomial. Later, we will show that decomposability and smoothness imply homogeneity, and vice versa with mild conditions. For a node \(v\) in a PC, we use \((v)\) to denote \((f_{v})\). As emphasized earlier, this paper investigates the quantitative relationship between a DAG and a tree, which are both PCs and represent the same probability distribution. To make the terminology uncluttered, we will call the former a _DAG-structured PC_, and the latter a _tree PC_. If a tree PC computes the same network polynomial as a DAG-structured PC, then the tree PC is said to be an _equivalent tree PC_ with respect to that DAG-structured PC.

Unless specified otherwise, we will use \(\) to denote the entire PC in consideration and \(f\) the network polynomial computed by the root. For each node \(v\), the sub-network rooted at \(v\) is denoted by \(_{v}\) and the polynomial computed by \(v\) is \(f_{v}\). The set of variables in \(f_{v}\) is \(X_{v}\), which is a subset of \(\{X_{1},,X_{n}\}\). The size of the network \(\), denoted by \(||\), is the number of nodes and edges in the network. The depth of \(\), denoted by \(D()\), is its maximum length of a directed path.

Partial DerivativesIn the process of proving the upper bound, a key notion named _partial derivative_ is frequently used and formally defined below.

**Definition 2.2** (Partial Derivative).: _For two nodes \(v\) and \(w\) in a network \(\), the partial derivative of the polynomial \(f_{v}\) with respect to the node \(w\), denoted by \(_{w}f_{v}\), is constructed by the following steps:_

1. _Substitute the polynomial_ \(f_{w}\) _by a new variable_ \(y\)_._
2. _Compute the polynomial computed by_ \(v\) _with the variable_ \(y\)_; denote the new polynomial by_ \(_{v}\)_. Due to decomposability,_ \(_{v}\) _is linear in_ \(y\)_._
3. _Define the partial derivative_ \(_{w}f_{v}=}{ y}\)_._

Observe that the chain rule in calculus also holds for our notion here, and therefore leads to the two following facts.

* Let \(v\) be a sum node with children \(v_{1}\) and \(v_{2}\), and the edges have weight \(a_{1}\) and \(a_{2}\), respectively, then by definition \(f_{v}=a_{1}f_{v_{1}}+a_{2}f_{v_{2}}\). For any other node \(w\), the partial derivative is \(_{w}f_{v}=a_{1}_{w}f_{v_{1}}+a_{2}_{w}f_{v_{ 2}}\).
* Similarly, let \(v\) be a product node with children \(v_{1}\) and \(v_{2}\), then \(f_{v}=f_{v_{1}} f_{v_{2}}\). For any other node \(w\), we have \(_{w}f_{v}=f_{v_{1}}_{w}f_{v_{2}}+f_{v_{2}}_{w }f_{v_{1}}\).

Figure 1: Partial derivatives of sum nodes.

The partial derivative has been proven to be a powerful tool in the field of complexity theory and combinatorial geometry . Readers are welcome to refer Chen et al.  for more details and extensive background. An illustration is provided in Figure 1.

Arithmetic CircuitsAn arithmetic circuit, aka algebraic circuit, is a generalization of a probabilistic circuit. Such a circuit shares the same structure as a PC and also computes a network polynomial. If an arithmetic/algebraic circuit is a directed tree, then we call it an _arithmetic/algebraic formula_. In the proof of the lower bound, the notion of _monotonicity_ of a formula is essential, whose definition relies on the concept _parse tree_.

**Definition 2.3** (Parse Tree).: _A parse tree of a formula \(\) is a sub-formula of \(\) which corresponds to a monomial of \(f\), the network polynomial computed by \(\). Parse trees of \(\) is defined inductively by the following process:_

* _If the root of_ \(\) _is a sum node, a parse tree of_ \(\) _is obtained by taking a parse tree of_ _one of its children_ _together with the edge between the root and that child._
* _If the root of_ \(\) _is a product node, a parse tree of_ \(\) _is obtained by taking a parse tree of_ _each of its children_ _together with_ _all_ _outgoing edges from the root._
* _The only parse tree of a leaf is itself._

**Definition 2.4** (Monotonicity).: _An algebraic formula is monotone if the monomial computed by any of its parse trees has a non-negative coefficient in the network polynomial._

## 3 A Universal Upper Bound

In this section, we present our first main result, which provides a universal upper bound on the size of an equivalent tree versus a DAG-structured PC.

**Theorem 3.1**.: _For any given DAG-structured PC over \(n\) variables and of size \((n)\), there exists an equivalent tree-structured PC of size \(n^{O( n)}\) nodes and of depth \(O( n)\), computing the same polynomial._

As discussed earlier, our constructive proof heavily relies on deeper properties of partial derivatives, and applying them to represent sub-network polynomials. Our strategy, inspired by Raz and Yehudayoff , will be efficient if the circuit being considered is a binary circuit, i.e. every node has at most two children. While such structure is rare for natural networks, we make the following observation, that an arbitrary PC can always be transformed to a binary one with a polynomial increase in size and depth. The proof and an illustrating figure will appear in Appendix A.

**Lemma 3.2**.: _Given a DAG-structured PC \(\), we may transform it into another DAG \(^{}\) that computes the same network polynomial and every node in \(^{}\) has at most two children. Moreover, the differences between the sizes and depths of \(^{}\) and \(\) are only in polynomial size._

Therefore, for the remaining discussion in this section, we will assume without loss of generality, that a given PC is binary. During the conversion process towards a binary circuit, some _intermediate_ nodes may be created to ensure no sum node is connected to another sum node and no product node is connected to another product node. The set of those intermediate nodes is denoted by \(_{1}\), and will be present in our later discussions. Next, we present a key property of partial derivatives, which holds for any (including non-binary) PC.

**Lemma 3.3**.: _Given a PC \(\), if \(v\) and \(w\) are two nodes in \(\) such that \(_{w}f_{v} 0\), then \(_{w}f_{v}\) is a homogeneous polynomial over the set of variables \(X_{v} X_{w}\) of degree \((v)-(w)\)._

The next lemma tells that, given a product node, its partial derivative with another node with a restriction on degree can be expressed using its children.

**Lemma 3.4**.: _Let \(v\) be a product node and \(w\) be any other node in a PC \(\), and \((v)<2(w)\). The children of \(v\) are \(v_{1}\) and \(v_{2}\) such that \((v_{1})(v_{2})\). Then \(_{w}f_{v}=f_{v_{2}}_{w}f_{v_{1}}\)._

To construct the quasi-polynomial tree, the key is to compress many nodes with partial derivatives. Fundamentally, we will use the following results to show that such compression works because each node, and each partial derivative of any node with any other, can be more concisely represented using partial derivatives. The key question is to find eligible nodes, so that taking partial derivatives with respect to them will lead to compact expressions. Inspired by the observation in Raz and Yehudayoff , we define the following set \(_{m}\), which will be critical in our later process.

**Definition 3.5**.: _Given a PC \(\) and an integer \(m\), the set \(_{m}\) is the collection of product nodes \(t\) in \(\) with children \(t_{1}\) and \(t_{2}\) such that \(m<(t)\) and \(\{(t_{1}),(t_{2})\} m\)._

With this set, we may choose a set of nodes as variables for partial derivatives for any node in a PC, and the following two lemmas respectively illustrate: 1) the compact expression of the sub-network polynomial \(f_{v}\) for any node \(v\) in a PC; 2) the compact expression of \(_{w}f_{v}\) given two nodes \(v\) and \(w\) with a degree restriction. It is easy to observe that \(_{1}_{m}=\).

We now present two key lemmas that will be central to the proof for the upper bound. Specifically, they spell out the alternative representations for the network polynomial of any node, and the partial derivative of any pair of nodes.

**Lemma 3.6** ().: _Let \(m\) and a node \(v\) such that \(m<(v) 2m\), then \(f_{v}=_{t_{m}}f_{t}_{t}f_{v}\)._

**Lemma 3.7** ().: _Let \(m\), and \(v\) and \(w\) be two nodes such that \((w) m<(v)<2(w)\), then \(_{w}f_{v}=_{t_{m}}_{w}f_{t}_{t}f_ {v}\)._

### Construction of \(\), another DAG-structured PC with restriction on depth

Given a binary DAG-structured PC \(\) with \(n\) variables and \((n)\) nodes, we explicitly construct a tree PC with size \(n^{O( n)}\) and depth \(O( n)\). Specifically, the construction takes two main steps:

1. Transform \(\) to another DAG-structured PC \(\) with size \((n)\) and depth \(O( n)\).
2. Apply a simple duplicating strategy to further convert \(\) to a tree with size \(n^{O( n)}\) and the same depth of \(\).

We will later show that step two can be simply done. Step one, however, needs much more careful operations. Each iteration, starting from \(i=0\), again needs two steps:

1. Compute \(f_{v}\) for each node \(v\) such that \(2^{i-1}<(v) 2^{i}\) using the compact expression illustrated earlier. We will show that, computing one such polynomial adds \((n)\) nodes and increases the depth by at most two on \(\). This new node representing \(f_{v}\) will be a node in \(\), denoted by \(v^{}\).
2. Compute all partial derivatives \(_{w}f_{u}\) for two non-variable nodes \(u\) and \(w\) in \(\), such that \(u\) is an ancestor of \(w\) and \(2^{i-1}<(u)-(w) 2^{i}\) and \((u)<2(w)\). Like those new nodes representing sub-network polynomials from \(\), this new node representing a partial derivative will also be a node in \(\), denoted by \((u,w)\). We will show that computing a partial derivative with respect to each pair adds \((n)\) nodes and increases the depth by at most two on \(\).

The process is summarized in Algorithm 1. Before presenting the construction, we first confirm the quantitative information of \(\), the output of the algorithm. The first observation is the number of iterations: The degree of the root of \(\) is \(n\), so at most \( n\) iterations are needed for the entire process. Each iteration only increases the size of the updated circuit by \((n)\) and the depth by a constant number. Consequently, the final form of \(\) has size \((n)\) and depth \(O( n)\).

We now provide an inductive construction of \(\) starting from \(i=0\). After each step, it is necessary to verify the validity of the updated \(\). Although decomposability is easy to verify, smoothness is less straightforward. To tackle this, we argue that the final state of \(\) is homogeneous, i.e. every node in \(\) computes a homogeneous polynomial, and consequently \(\) is smooth due to the following lemma.

**Lemma 3.8**.: _If a decomposable PC contains \(n\) variables and computes a polynomial of degree \(n\), then it is homogeneous if and only if it is smooth._

Iteration zero \((i=0)\):During this iteration, for the first step, we only need to consider nodes \(v\) such that \(0.5<(v) 1\); the degree of any node must be an integer, so we must have \((v)=1\), i.e. \(v\) represents an affine polynomial. Without loss of generality, we may assume all such affine nodes are sum nodes with strictly more than one child. Indeed, if a product node represents an affine polynomial, then it must only have exactly one child, which must be a leaf node; in this case, we may remove this product node and connect that leaf to the parents of the original product node. Similarly, if a sum node represents an affine polynomial and has exactly one child, then that child must also be a leaf node, hence we may again remove the sum node and connect that leaf to the parents of the original sum node. Due to smoothness, such an affine node \(v\) must represent a polynomial in the form \(ax+(1-a)\), where \(x\) is the indicator of a variable, and \(0<a<1\). Therefore, the depth of each sub-network \(_{v}\) is only one. By duplicating all such affine nodes onto \(\), we add at most \((n)\) nodes and increase the depth by one only.

Next, for step two, we only need to consider pairs of nodes \((u,w)\) such that \((u)-(w) 1\). Thanks to Lemma 3.3, we know that \(_{w}f_{u}\) is affine. For each pair satisfying the restriction, we create a sum node \((u,w)\) whose sub-network \(_{(u,w)}\) has size three and depth one. By moving all such sub-networks to \(\) for each eligible pair, we again add at most \((n)\) nodes and increase the depth by one to \(\).

Iteration \(i+1\):Suppose, after all previous iterations, we have already computed all sub-network polynomials \(f_{v}\) for nodes \(v\) such that \((v) 2^{i}\), and all partial derivatives \(_{w}f_{u}\) for pairs of nodes \((u,w)\) such that \((u)-(w) 2^{i}\) and \((u) 2(w)\). Like the base case, step \(i+1\) takes two steps: The first step computes \(f_{v}\) for eligible nodes, and the second step concerns partial derivatives for eligible pairs of nodes. Because the analysis of the two steps during this iteration is highly involved, we will discussion the construction in details in Appendix A.7.

``` Data: A rooted DAG of size \(S\) and depth \(D\), and the set of its nodes \(\) Result: A tree of size \(O(S^{D})\) and depth \(D\) for every node \(v\) in \(\)do if\((v)>1\)then  Duplicate the tree rooted at \(v\) for \((v)-1\) times;  Construct an outgoing edge from each parent of \(v\) to itself.  end if  end for ```

**Algorithm 2**Transforming a rooted DAG to a tree

### Construction of the Quasi-polynomial Tree

We conclude the proof of Theorem 3.1 in this section by transforming the newly constructed \(\) into a quasi-polynomial tree. The transformation is a simple application of the _naive duplication_ strategy, which will be illustrated below. In summary, given a \((n)\)-sized DAG, the size of the transformed tree directly depends on the depth of the original DAG. The process of the duplication is briefly summarized in Algorithm 2, and the detailed process of the entire transformation from the original \(\) to the final tree is described in Algorithm 5.

Duplication StrategyGiven a DAG-structured PC of size \(V\) and depth \(D\), a natural algorithm to a tree is that, if a node \(v\) has \(k>1\) parents, then duplicate the sub-tree rooted at \(v\) for \(k-1\) times, and connect each duplicated sub-tree to a parent of \(v\). Indeed this algorithm generates a tree computing the same function as the original DAG does, but in the worst case we have to duplicate the entire graph \(O(V)\) times and such iterative duplication may be executed for every layer from the first to layer \(D\). Therefore, in the worst case, the final tree has size \(O(V^{D})\).

The construction of \(\) shows that its size is \(O(n^{3})\) and depth is \(O( n)\). Using the naive duplication, we obtain that the size of the final tree is \(n^{O( n)}\).

## 4 A Conditional Lower Bound

In this section, we present our second main result, which provides a lower bound on the tree complexity of a network polynomial given a restriction on the depth of the tree. Obtaining a lower bound for the problem of circuit complexity is in general a more difficult problem than obtaining an upper bound because one cannot achieve this goal by showing the failure of a single algorithm. Instead, one must construct a specific polynomial, and confirm that no algorithm can produce an equivalent tree of size lower than the desired lower bound. However, thanks to some recent results in circuit complexity theory, such a separation is ensured if the tree PC has a bounded depth. The main result in this section is presented below, stating that, there is a concrete network polynomial that cannot be represented by a polynomial-sized tree-structured PC if the depth of the tree is restricted.

**Theorem 4.1**.: _Given an integer \(k 1\) and \(n=2^{2k}\), there exists a network polynomial \(P[x_{1},,x_{n},_{1},,_{n}]\) of degree \(n=2^{2k}\), such that any probabilistic tree of depth \(o( n)=o(k)\) computing \(P\) must have size \(n^{(1)}\)._

Note that if the polynomial \(P\) is innately difficult to be represented by PCs, i.e., if it cannot even be represented efficiently by DAG-structured PCs, then separation is not shown. To show separation, \(P\) should be efficiently computed by a DAG-structured PC, but any tree-structured PC representing \(P\) must have a strictly larger size. Our next construction, described with more details in Algorithm 3, confirms a separation by constructing an efficient DAG-structured PC \(P^{*}\) that computes \(P\). This PC has size \(O(n n)\) and depth \(2k=2 n\), where \(k\) is the integer given in Theorem 4.1. The next proposition confirms the validity of \(P^{*}\), and the proof is in Appendix B.

**Proposition 4.2**.: _The tree PC \(P^{*}\) is decomposable and smooth._

It is easy to check that \(P^{*}\) has the correct size and depth as described earlier. Before adding leaf nodes, the algorithm in total constructs \(_{r=0}^{2k}2^{r}=2^{2k+1}-1=2n-1\) nodes. Finally, observe that during the construction of leaf nodes, each negation indicator is added exactly \(k\) times: At a layer containing only product nodes, if a negation indicator is added to a product node \(v\) at this layer, then it will next be added to the sibling of the grandparent of \(v\). Because each product node has exactly one sibling, the negation indicator for a random variable is duplicated exactly \(k\) times, and finally the total size is \(2n-1+kn=O(kn)=O(n n)\). The depth \(O(k)\) is also apparent from the algorithm. We therefore conclude that \(P\) can be efficiently computed by a polynomial sized tree PC for an unrestricted depth.

However, the efficiency would be less optimal if we restrict the depth to \(o(k)\). To show this, we design a reduction from our problem for PCs to a well-studied problem on arithmetic circuits. Our proof essentially argues that, for any minimum-sized tree-structured PC that computes \(P\), we can obtain its sub-tree that computes a polynomial, and that polynomial has been recently proven to not be able to be represented by a polynomial-sized tree-structured PC. This recent result is stated below.

**Theorem 4.3** ().: _Let \(n\) and \(d=d(n)\) be growing parameters such that \(d(n)\). Then there is a monotone algebraic formula \(F\) of size at most \(n\) and depth \(O( d)\) computing a polynomial \(Q[x_{1},,x_{n}]\) of degree at most \(d\) such that any monotone formula \(F^{}\) of depth \(o( d)\) computing \(Q\) must have size \(n^{(1)}\)._

The proof of the lower bound for PCs in Theorem 4.1 is to show that, for any \(\), a minimum tree-structured PC with depth \(o(k)\) that computes \(P\), the polynomial in the statement of Theorem 4.1, we can always obtain a smaller-sized arithmetic formula \(^{}\) with the same depth that computes the polynomial \(Q\) in the statement of Theorem 4.3. The size of \(^{}\) is super-polynomial due to Theorem 4.3, and as a result, the size of \(\) cannot be smaller. In other words, our proof involves a reduction from the PC problem to the AC problem. Before introducing the reduction, we first present the polynomial \(Q\) in the statement of Theorem 4.3. The original construction in Fournier et al.  is for the general class, but over here, we only present a specific case with \(r=2\), which is sufficient for our purpose.

The Construction of the Polynomial \(Q\)We denote the polynomial \(Q\) by \(H^{(k,2)}\), which is defined over \(2^{2k}\) variables

\[\{x_{,}:,^{k}\}.\] (1)

The polynomial \(H^{(k,2)}\) is recursively defined over intermediate polynomials \(H_{u,v}\) for all \((u,v)^{ k}^{ k}\) and \(|u|=|v|=k\). Specifically, if \(|u|=|v|=k\), then \(H_{u,v}=x_{u,v}\); otherwise, \(H_{u,v}=_{a=1}^{r}H_{u1,va}H_{u2,va}\). The final polynomial \(H^{(k,2)}\) is defined to be \(H_{,}\). Observe that the degree of \(H^{(k,2)}\) is \(2^{k}\), and it contains \(2^{2^{k}-1}\) monomials.

Given a minimum tree-structured PC \(\), which computes \(P\) and is of depth \(o(k)\), we remove all of its leaves that represent negation variables and call this pruned network \(^{}\); without leaves representing negation variables, \(^{}\) is just a standard arithmetic formula. Clearly, \(|^{}|||\), and the next proposition reveals the polynomial computed by \(^{}\), and its proof is in Appendix B.

**Proposition 4.4**.: _The arithmetic formula \(^{}\) computes \(H^{(k,2)}\)._

Having all the necessary ingredients, we are now ready to conclude this section by proving Theorem 4.1, the main result of this section.

Proof of Theorem 4.1.: The proof of Theorem 4.3 in Fournier et al.  uses the polynomial class \(H^{(k,r)}\) as the hard polynomial \(Q\) in the statement, in particular, with \(r=2\), \(n=2^{2k}\) and \(=2^{k}\). Note that the depth of \(^{}\) is \(o( d)=o(k)\), and the degree of \(H^{(k,2)}\) is \(d=2^{k}\), so the conditions in the statement of Theorem 4.1 are indeed satisfied. Since \(^{}\) is obtained from \(\) by removing leaves, we obtain the following inequality that concludes the proof:

\[|||^{}| n^{(1)}.\]

## 5 Conclusion

In this paper we have shown that given a network polynomial with \(n\) variables that can be efficiently computed by a DAG-structured PC, we can construct a tree PC with at most quasi-polynomial size and is no deeper than \(O( n)\). On the flip side, we have also shown that there indeed exists a polynomial that can be efficiently computed by a \((n)\)-sized PC without a depth restriction, but there is a super-polynomial separation if we restrict the depth of the tree to be \(o( n)\). Our results make an important step towards understanding the expressive power of tree-structured PCs and show that a quasi-polynomial upper bound is possible. However, the lower bound is still largely open, and we have only shown a separation under a specific depth restriction. One potential direction for the future work are discussed below: although the upper bound \(n^{O( n)}\) is quasi-polynomial, it is still prohibitively large as \(n\) grows. The construction outputs a tree of depth \(O( n)\), which would be considered as a shallow tree. Is it possible to further reduce the size of the tree, possibly in the cost of a larger depth?