# Weisfeiler and Leman Go Loopy: A New Hierarchy

for Graph Representational Learning

Raffaele Paolino\({}^{*,1,2}\)  **Sohir Maskey\({}^{*,1}\)** Pascal Welke\({}^{3}\)  **Gitta Kutyniok\({}^{1,2,4,5}\)

\({}^{1}\)Department of Mathematics, LMU Munich

\({}^{2}\)Munich Center for Machine Learning (MCML)

\({}^{3}\)Faculty of Computer Science, TU Wien

\({}^{4}\)Institute for Robotics and Mechatronics, DLR-German Aerospace Center

\({}^{5}\)Department of Physics and Technology, University of Tromso

Equal contribution.

Corresponding authors: paolino@math.lmu.de, maskey@math.lmu.de.

###### Abstract

We introduce \(r\)-loopy Weisfeiler-Leman (\(r\)-\(\)WL), a novel hierarchy of graph isomorphism tests and a corresponding GNN framework, \(r\)-\(\)MPNN, that can count cycles up to length \(r{+}2\). Most notably, we show that \(r\)-\(\)WL can count homomorphisms of cactus graphs. This extends 1-WL, which can only count homomorphisms of trees and, in fact, we prove that \(r\)-\(\)WL is incomparable to \(k\)-WL for any fixed \(k\). We empirically validate the expressive and counting power of \(r\)-\(\)MPNN on several synthetic datasets and demonstrate the scalability and strong performance on various real-world datasets, particularly on sparse graphs. Our code is available on GitHub.

## 1 Introduction

Graph Neural Networks (GNNs) (Scarselli et al., 2009; Bronstein et al., 2017) have become a prevalent architecture for processing graph-structured data, contributing significantly to various applied sciences, such as drug discovery (Stokes et al., 2020), recommender systems (Fan et al., 2019), and fake news detection (Monti et al., 2019).

Among various architectures, Message Passing Neural Networks (MPNNs) (Gilmer et al., 2017) are widely used in practice, as they encompass only local computation, leading to fast and scalable models. Despite their success, the representational power of MPNNs is bounded by the Weisfeiler-Leman (WL) test, a classical algorithm for graph isomorphism testing (Xu et al., 2019; Morris et al., 2019). This limitation hinders MPNNs from recognizing basic substructures like cycles (Chen et al., 2020). However, specific substructures can be crucial in many applications. For example, in organic chemistry, the presence of cycles can impact various chemical properties of the underlying molecules (Deshpande et al., 2002; Koyuturk et al., 2004). Therefore, it is crucial to investigate whether GNNs can count certain substructures and to design architectures that surpass the limited power of MPNNs.

Several models have been proposed to surpass the limitations of WL. Many of these models draw inspiration from higher-order WL variants (Morris et al., 2019), enabling them to count a broader range of substructures. For instance, GNNs emulating \(3\)-WL can count cycles up to length \(7\). However, this increased expressivity comes at a high computational cost, as \(3\)-WL does not respect the sparsity of real-world graphs, posing serious scalability issues. Hence, there is a critical need to design expressive GNNs that respect the inherent sparsity of real-world graphs (Morris et al., 2023).

Main Contributions.We introduce a novel class of color refinement algorithms called _\(r\)-loopy Weisfeiler-Leman test (\(r\)-\(\)WL)_ and a corresponding class of GNNs named _\(r\)-loopy Graph Isomorphism Networks (\(r\)-\(\)GIN)_. The key idea is to collect messages not only from neighboring nodes but also from the paths connecting any two distinct neighboring nodes, as illustrated in Figure 1. This approach enhances the resulting GNNs' expressivity beyond 1-WL. In particular, \(r\)-\(\)WL can count cycles up to length \(r+2\), even surpassing the \(k\)-WL hierarchy.

Furthermore, we prove that \(r\)-\(\)WL can homomorphism-count any cactus graph with cycles up to length \(r+2\). Cactus graphs are valuable due to their structural properties and simplicity, making them useful for modeling in areas such as electrical engineering (Nishi et al., 1986) and computational biology (Paten et al., 2011). For instance, aromatic compounds often form cactus graphs, where the molecular core, usually a cycle, is connected to functional groups (e.g., carboxyl groups) that can significantly impact the properties of the molecule. Thus, the ability to homomorphism-count cactus graphs can enhance model performance, and it allows us to compare the expressive power of \(r\)-\(\)WL with other popular GNNs in a quantitative manner (Barcelo et al., 2021; B. Zhang et al., 2024). Specifically, we show that \(r\)-\(\)WL is more expressive than GNNs that include explicit homomorphism counts of cycle graphs, known as \(\)-Hom-GNNs (Barcelo et al., 2021). Additionally, \(1\)-\(\)WL can already separate infinitely many graphs that Subgraph \(k\)-GNNs (Frasca et al., 2022; Qian et al., 2022) cannot (see, e.g., Figure 7). The higher expressivity, paired with the local computations, highlights the enhanced potential of \(r\)-\(\)GIN, showing its competitive performance and the efficiency of its forward pass on real-world datasets, see Section 7.

## 2 Related Work

The notion of expressivity in standard neural networks is linked to the ability to approximate any continuous function (Cybenko, 1989; Hornik et al., 1989). In contrast, GNN expressivity is measured by the ability to distinguish non-isomorphic graphs. According to the Stone-Weierstrass theorem, these criteria are equivalent (Chen et al., 2019; Dasoulas et al., 2021): a network that can distinguish all graphs can approximate any continuous function. Therefore, research often focuses on determining which graphs a GNN can distinguish (Morris et al., 2023).

Xu et al. (2019) and Morris et al. (2019) proved that the expressive power of MPNNs is bounded by \(1\)-WL. Subsequent works (Maron et al., 2018; Morris et al., 2019, 2020) introduced higher-order GNNs that have the same expressive power as \(k\)-WL or its local variants (Geerts et al., 2022). Although these networks are universal (Maron et al., 2019; Keriven et al., 2019), their exponential time and space complexity in \(k\) renders them impractical. Abboud et al. (2022) proposed \(k\)-hop GNNs which aggregate information from \(k\)-hop neighbors, thus, enhancing expressivity beyond \(1\)-WL but within \(3\)-WL (Feng et al., 2022). Michel et al. (2023) and Graziani et al. (2024) construct GNNs that process paths emanating from each node to overcome \(1\)-WL. Subgraph GNNs (Bevilacqua et al., 2021; You et al., 2021; Frasca et al., 2022; Huang et al., 2022) surpass \(1\)-WL by decomposing the initial input

Figure 1: Visual depiction of \(r\)-\(\)GIN: During preprocessing, we calculate the path neighborhoods \(_{r}(v)\) for each node \(v\) in the graph \(G\). Paths of varying lengths are processed separately using simple GINs, and their embeddings are pooled to obtain the final graph embedding. The forward complexity scales linearly with the sizes of \(_{r}(v)\), enabling efficient computation on sparse graphs.

graph into a bag of subgraphs. However, subgraph GNNs are upper-bounded by 3-WL (Frasca et al., 2022). A different line of work leverages positional encoding through unique node identifiers (Vignac et al., 2020), random features (Abboud et al., 2021; Sato et al., 2021) or eigenvectors (Lim et al., 2022; Maskey et al., 2022) to augment the expressive power of MPNNs.

While the predominant approach for gauging the expressive power of GNNs is within the \(k\)-WL hierarchy, such a measure is inherently qualitative, as it cannot shed light on substructures a particular GNN can encode. Lovasz (1967) showed that _homomorphism counts_ is a _complete graph invariant_, meaning two graphs are isomorphic if and only if their homomorphism counts are identical. Building on this result, B. Zhang et al. (2024) advocate for homomorphism-count as a quantitative measure of expressivity, as GNN architectures can homomorphism-count particular families of motifs. Tinhofer (1986, 1991) established that 1-WL is equivalent to counting homomorphisms from graphs with tree-width one, while Dell et al. (2018) proved the equivalence between \(k\)-WL and the ability to count homomorphisms from graphs with tree-width \(k\). Nguyen et al. (2020), Barcelo et al. (2021), Welke et al. (2023), and Jin et al. (2024) used homomorphism counts to develop expressive GNNs.

Manually augmenting node features with homomorphism counts can be disadvantageous as performance depends on the chosen substructures. This can be alleviated by designing domain-agnostic GNNs that can learn structural information suitable for the task at hand. For instance, higher-order GNNs can count a large class of substructures as homomorphisms (B. Zhang et al., 2024), but they suffer from scalability issues. We propose \(r\)-\(\)WL and \(r\)-\(\)GIN, which can count homomorphisms of cactus graphs without adding explicit substructure counts. Our method is scalable to large datasets, particularly when the graphs in these datasets are sparse.

## 3 Preliminaries

Let \(\) be the set of all simple and undirected graphs, and let \(G\). We denote the set of nodes by \(V(G)\) and the set of edges by \(E(G)\). The _direct neighborhood_ of a node \(v V(G)\) is defined as \((v)\{u V(G)\ \{v,u\} E(G)\}\).

**Definition 1**.: _Let \(F,G\). A homomorphism from \(F\) to \(G\) is a map \(h:V(F) V(G)\) such that \(\{u,v\} E(F)\) implies \(\{h(u),h(v)\} E(G)\). A subgraph isomorphism is an injective homomorphism._

Intuitively, a homomorphism from \(F\) to \(G\) is an edge-preserving map. A subgraph isomorphism ensures that \(F\) actually occurs as a subgraph of \(G\). Consequently, it also maps distinct edges to distinct edges. A visual explanation can be found in Figure 5. We denote by \((F,G)\) the set of homomorphisms from \(F\) to \(G\) and by \((F,G)\) its cardinality. Similarly, we denote by \((F,G)\) the set of subgraph isomorphisms from \(F\) to \(G\) and by and \((F,G)\) its cardinality.

### Graph Invariants

In order to unify different expressivity measures, we recall the definition of graph invariants.

**Definition 2**.: _Let \(P\) be a designated set, referred to as the palette. A graph invariant is a function \(: P\) such that \((G)=(H)\) for all isomorphic pairs \(G,H\). \(\) is a complete graph invariant if \((G)(F)\) for all non-isomorphic pairs \(G,F\)._

Complete graph invariants have maximal expressive power. However, no polynomial-time algorithm to compute a complete graph invariant is known. To compare the expressive power of different graph invariants, such as graph colorings and GNN architectures, we introduce the following definition.

**Definition 3**.: _Let \(,\) be two graph invariants. We say that \(\) is more powerful than \(\) (\(\)) if for every pair \(G,H\), \((G)=(H)\) implies \((G)=(H)\). We say that \(\) is strictly more powerful than \(\) if \(\) and there exists a pair \(F,G\) such that \((G)(H)\) and \((G)=(H)\)._

### Message Passing Neural Networks and Weisfeiler-Leman

Message passing is an iterative algorithm that updates the _colors_ of each node \(v V(G)\) as

\[c^{(t+1)}(v) f^{(t+1)}(c^{(t)}(v),g^{(t+1)}(\{\{c ^{(t)}(u) u(v)\}\})). \]The graph output after \(t\) iterations is given by

\[c^{(t)}(G) h(\{\{c^{(t)}(v) v V(G)\}\} \}).\]

Here, \(g^{(t)},h\) are functions on the domain of multisets and \(f^{(t)}\) is a function on the domain of tuples. For each \(t\), the colorings \(c^{(t)}\) are graph invariants. When the subsets of nodes with the same colors cannot be further split into different color groups, the algorithm terminates; the stable coloring after convergence is denoted by \(c(G)\).

Choosing injective functions for all \(f^{(t)}\) and setting \(g^{(t)}\) and \(h\) as the identity function results in 1-WL (Weisfeiler et al., 1968). If \(f^{(t)},g^{(t)},h\) are chosen as suitable neural networks, one obtains a Message Passing Neural Network (MPNN). Xu et al. (2019) proved that MPNNs are as powerful as \(1\)-WL if the functions \(f^{(t)},g^{(t)}\), and \(h\) are injective on their respective domains. The \(k\)-WL algorithms uplift the expressive power of \(1\)-WL by considering interactions between \(k\)-tuples of nodes. This results in a hierarchy of strictly more powerful graph invariants (see Appendix B.1 for a formal definition).

### Homomorphism and Subgraph Counting Expressivity

A more nuanced graph invariant can be built by considering the occurrences of a motif \(F\).

**Definition 4**.: _Let \(F\). A graph invariant \(\) can homomorphism-count\(F\) if for all pairs \(G,H\)\((G)=(H)\) implies \((F,G)=(F,H)\). By analogy, \(\) can subgraph-count\(F\) if for all pairs \(G,H\), \((G)=(H)\) implies \((F,G)=(F,H)\)._

If \(\) is a family of graphs, we say that \(\) can homomorphism-count\(\) if \(\) can homomorphism-count every \(F\); we denote the vector of homomorphism-count by \((,G)((F,G))_{F}\). Interpreting \((,)\) as a graph invariant, given by \(G(,G)\), another graph invariant \(\) can homomorphism-count\(\) if and only if \((,)\).

The ability of a graph invariant to count homomorphisms is highly relevant because \((,)\) is a complete graph invariant. Conversely, if \(\) is a complete graph invariant, then \(\) can homomorphism-count all graphs (Lovasz, 1967). Additionally, homomorphism-counting serves as a quantitative expressivity measure to compare different WL variants and GNNs, such as \(k\)-WL, Subgraph GNNs, and other methods (Lanzinger et al., 2024; Zhang et al., 2024), and allows for relating them to our proposed \(r\)-\(\)WL variant, as detailed in Corollary 2.

## 4 Loopy Weisfeiler-Leman Algorithm

In this section, we introduce a new graph invariant by enhancing the direct neighborhood of nodes with _simple paths_ between neighbors.

**Definition 5**.: _Let \(G\). A simple path of length \(r\) is a collection \(=\{p_{i}\}_{i=1}^{r+1}\) of \(r+1\) nodes such that \(\{p_{i},p_{i+1}\} E(G)\) and \(i j p_{i} p_{j}\) for every \(i,j\{1,,r\}\),._

Simple paths are the building blocks of \(r\)-neighborhoods, which in turn are the backbone of our \(r\)-\(\)WL algorithm. The following definition is inspired by (Cantwell et al., 2019; Kirkley et al., 2021).

**Definition 6**.: _Let \(G\) and \(r\{0\}\), we define the \(r\)-neighborhood\(_{r}(v)\) of \(v V(G)\) as_

\[_{r}(v)\{r,\,p_{r+1}(v),v\}\,.\]

For consistency, we set \(_{0}(v)(v)\). An example of the construction of \(r\)-neighborhood is shown in Figure 2, where different \(r\)-neighborhoods of node \(v\) are represented with different colors.

We generalize \(1\)-WL in (1) as follows.

**Definition 7**.: _We define the \(r\)-loop Weisfeiler-Leman (\(r\)-\(\)WL) test by the following color update:_

\[c_{r}^{(t+1)}(v)_{r}(c_{r}^{(t)}(v),\{\{c _{r}^{(t)}()_{0}(v)\}\} \},,\{\{c_{r}^{(t)}() _{r}(v)\}\}), \]

_where \(c_{r}^{(t)}()(c_{r}^{(t)}(p_{1}),c_{r}^We denote by \(c_{r}^{(t)}(G)\) the final graph output after \(t\) iterations of \(r\)-\(\)WL, i.e.,

\[c_{r}^{(t)}(G)=_{r}(\{\{c_{r}^{(t)}(v) v  V(G)\}\}),\]

and by \(c_{r}(G)\) the stable coloring after convergence. The stable coloring \(c_{r}\) serves as graph invariant and will be referred to as \(r\)-\(\)WL.

## 5 Expressivity of \(r\)-\(\)WL

We analyze the expressivity of \(r\)-\(\)WL in terms of its ability to distinguish non-isomorphic graphs, subgraph-count, and homomorphism-count motifs. The proofs for all statements are in Appendix D.

### Isomorphism Expressivity

It is straightforward to check that \(0\)-\(\)WL corresponds to \(1\)-WL, since \(_{0}(v)=(v)\) for all nodes \(v\). However, increasing \(r\) leads to a strict increase in expressivity.

**Proposition 1**.: _Let \(0 q<r\). Then, \(r\)-\(\)WL is strictly more powerful than \(q\)-\(\)WL. In particular, every \(r\)-\(\)WL is strictly more powerful than \(1\)-WL._

This shows that the number of graphs we can distinguish monotonically increases with \(r\). We empirically verify this fact on several synthetic datasets in Section 7.

### Subgraph Expressivity

Recent studies highlight limitations in the ability of certain graph invariants to subgraph-count cycles. For instance, \(1\)-WL cannot subgraph-count cycles (Chen et al., 2020, Theorem 3.3), while \(3\)-WL can only subgraph-count cycles of length up to \(7\)(Arvind et al., 2020, Theorem 3.5). Similarly, Subgraph GNNs have limited cycle-counting ability (Huang et al., 2022, Proposition 3.1). In contrast, \(r\)-\(\)WL can count cycles of arbitrary length, as shown in the following statement.

**Theorem 1**.: _For any \(r 1\), \(r\)-\(\)WL can subgraph-count all cycles with at most \(r+2\) nodes._

Since \(3\)-WL cannot subgraph-count any cycle with more than \(7\) nodes, Theorem 1 implies that \(6\)-\(\)WL is not less powerful than \(3\)-WL. This observation generalizes to any \(k\)-WL, as shown next.

**Corollary 1**.: _Let \(k\). There exists \(r\), such that \(r\)-\(\)WL is not less powerful than \(k\)-WL. Specifically, \(r(k^{2})\), with \(r-2\) for even \(k\) and \(r}{2}-2\) for odd \(k\)._

The \(r\)-\(\)WL color refinement algorithm surpasses the limits of the \(k\)-WL hierarchy while only using local computation. This is particularly important since already \(3\)-WL is computationally infeasible, whereas our method can scale efficiently to higher orders if the graphs are sparse, which is commonly the case in real-world applications.

### Homomorphism Expressivity

The following section unveils a close connection between the expressivity of \(r\)-\(\)WL and cactus graphs (Harary et al., 1953), a significant class between trees and graphs with tree-width 2.

**Definition 8**.: _A cactus graph is a graph where every edge lies on at most one simple cycle. For \(r 2\), an \(r\)-cactus graph is a cactus where every simple cycle has at most \(r\) vertices. We denote by \(\) the set of all cactus graphs, and by \(^{r}\) the set of all \(q\)-cactus graphs for \(q r\)._

Figure 6 shows two examples of cactus graphs. From the expressivity perspective, the ability to homomorphism-count cactus graphs establishes a lower bound strictly between the homomorphism-counting capabilities of \(1\)-WL and \(3\)-WL (Neuen, 2024), as cactus graphs are a strict superset of all trees and a strict subset of all graphs of treewidth two. With this in mind, we are now ready to present our significant result on the homomorphism expressivity of our \(r\)-\(\)WL algorithm.

**Theorem 2**.: _Let \(r 0\). Then, \(r\)-\(\)WL can homomorphism-count \(^{r+2}\)._We refer to Appendix G for a detailed proof of Theorem 2, which is fairly involved and requires defining canonical tree decompositions of cactus graphs and unfolding trees of \(r\)-\(\)WL. Demonstrating their strong connection, we then follow the approach in (Dell et al., 2018; B. Zhang et al., 2024) to decompose homomorphism counts of cactus graphs. In fact, we prove a more general result, showing that \(r\)-\(\)WL can count all _fan-cactus graphs_, see Appendix G for more details.

The class \(^{2}\) contains only forests; hence, Theorem 2 implies the standard results on the ability of \(1\)-WL to count forests. Since forests are the only class of graphs \(1\)-WL can count, Theorem 2 implies that \(r\)-\(\)WL is always strictly more powerful than \(1\)-WL, corroborating the claim in Proposition 1.

The implications of Theorem 2 are profound: it establishes that \(r\)-\(\)WL can homomorphism-count a large class of graphs. Specifically, Theorem 2 provides a quantitative expressivity measure that enables comparison of \(r\)-\(\)WL's expressivity with other WL variants and GNNs. This comparison is achieved by examining the range of graphs that \(r\)-\(\)WL can homomorphism-count against those countable by other models, as detailed in works by Barcelo et al. (2021) and B. Zhang et al. (2024). For instance, B. Zhang et al. (2024) showed that Subgraph GNNs (Bevilacqua et al., 2021; You et al., 2021; Frasca et al., 2022; Huang et al., 2022) are limited to homomorphism-count graphs with end-point shared NED. Hence, Subgraph GNNs can not homomorphism-count \(F=\{[width=14.226378pt]{images/cWL1. eps}\}\), while \(1\)-\(\)WL can. Based on this, we can identify pairs of graphs that \(1\)-\(\)WL can distinguish but Subgraph GNNs cannot. We summarize these and other implications of Theorem 2 in the following corollary.

**Corollary 2**.: _Let \(r\{0\}\). Then,_

1. \(r\)_-_\(\)WL is more powerful than_ \(\)_-Hom-GNNs, where_ \(=\{C_{3},,C_{r+2}\}\)_._
2. \(1\)_-_\(\)WL is not less powerful than Subgraph GNNs. In particular, any_ \(r\)_-_\(\)WL can separate infinitely many graphs that Subgraph GNNs fail to distinguish._
3. _For any_ \(k>0\)_,_ \(1\)_-_\(\)WL is not less powerful than Subgraph_ \(k\)_-GNNs. In particular, any_ \(r\)_-_\(\)WL can separate infinitely many graphs that Subgraph_ \(k\)_-GNNs fail to distinguish._
4. \(r\)_-_\(\)WL can subgraph-count all graphs_ \(F\) _such that_ \(}(F)^{r+2}\)_, where_ \(}(F)\{H h(F,H)\}\)_. In particular, if_ \(1 r 4\)_, then_ \(r\)_-_\(\)WL can subgraph-count all paths up to length_ \(r+3\)_._

A detailed explanation of Subgraph (\(k\)-)GNNs, \(\)-Hom-GNNs, along with the proofs of Corollary 2, can be found in Appendix H. Finally, we note that Theorem 2 states a loose lower bound on the homomorphism expressivity of \(r\)-\(\)WL. This observation opens the avenue for future research to explore tight lower bounds, or upper bounds, on the homomorphism expressivity of \(r\)-\(\)WL.

## 6 Loopy Message Passing

In this section, we build a GNN emulating \(r\)-\(\)WL.

**Definition 9**.: _For \(t\{0,,T-1\}\) and \(k\{0,,r\}\), \(r\)-\(\)MPNN applies the following message, update and readout functions:_

\[ m_{k}^{(t+1)}(v)&=f_{k}^{(t+1)}( \{\{c_{k}^{(t)}()_{k}(v) \}\}),\\ c_{r}^{(t+1)}(v)&=g^{(t+1)}(c_{r}^{(t)}(v),\, m_{0}^{(t+1)}(v),,m_{r}^{(t+1)}(v)), \]

_and final readout layer \(c_{r}^{(T)}(G)=h(\{\{c_{r}^{(T)}(v) v V(G)\} \})\)._

In the following statement, we link the expressive power of \(r\)-\(\)MPNN and \(r\)-\(\)WL.

**Theorem 3**.: _For fixed \(t,r 0\), \(t\) iterations of \(r\)-\(\)WL are more powerful than \(r\)-\(\)MPNN with \(t\) layers. Conversely, \(r\)-\(\)MPNN is more powerful than \(r\)-\(\)WL if the functions \(f^{(t)},g^{(t)}\) in (3) are injective._

The previous result derives conditions under which \(r\)-\(\)MPNN is as expressive as \(r\)-\(\)WL. To implement \(r\)-\(\)MPNN in practice, we choose suitable neural layers for \(f_{k}^{(t)},g^{(t)}\), and \(h\) in Definition 9. As a consequence of (Xu et al., 2019, Lemma 5), the aggregation function in (3) can be written as

\[f_{k}^{(t+1)}(\{\{\{c_{k}^{(t)}() _{k}(v)\}\}\}):=f(_{ _{k}(v)}g()),\]for suitable functions \(f,g\). Since 1-WL is injective on forests (Arvind et al., 2015), hence on paths, and since GIN can approximate 1-WL (Xu et al., 2019), we choose \(f=\) and \(g=\). Hence, \(r\)-\(\)GIN is defined as an \(r\)-\(\)MPNN that updates node features via

\[x_{r}^{(t+1)}(v):=(x_{r}^{(t)}(v)+(1+_{0})_{u _{0}(v)}x_{r}^{(t)}(u)+_{k=1}^{r}(1+_{k})_{ _{k}(v)}_{k}()). \]

To reduce the number of learnable parameters in (4), the \(_{k}\) can be shared among all \(k\). Nothing prevents from choosing a different path-processing layer; we opted for GIN because it is simple yet maximally expressive on paths. We refer to Figure 1 for a visual depiction of \(r\)-\(\)GIN.

Computational ComplexityThe complexity of \(r\)-\(\)GIN is \((|E|+_{v V(G)}_{k=1}^{r}2k|_{k}(v)|)\). The former addend is the standard message complexity, while the latter arises from applying GIN to paths of length \(k r\). This implies that our model's complexity scales linearly with the number of edges, and with the number of paths within \(_{k}(v)\). The number of such paths is typically less than the number of edges. For example, ZINC12K has overall \(598\)K edges while only containing 374K paths in \(_{r}(v)\) for \(1 r 5\). Hence, the runtime overhead is small in practice. Compared to 3-WLGNN (Dwivedi et al., 2022), which has the same cycle-counting expressivity, our model requires ca. 10 seconds/epoch while 3-WLGNN takes ca. \(329.49\) seconds/epoch on ZINC12K. Our runtime is comparable to that of GAT, MoNet, or GatedGCN (see Table 10 for a thorough comparison).

Comparison with (Michel et al., 2023)PathNN updates node features by computing all possible paths starting from each node. In contrast, our approach selects paths between distinct neighbors, potentially resulting in fewer paths. For instance, a tree's \(r\)-neighborhoods (\(r 1\)) are empty, while counts of paths between nodes are quadratic. Notably, Michel et al. (2023) do not explore the impact of increasing the path length on architecture expressiveness, a consideration we address (see, e.g., Proposition 1 and Corollary 1). Another significant contribution of our work, which we assert does not hold (at least not trivially) for PathNN, is the provable ability to subgraph-count cycle graphs (see, e.g., Theorem 1) and homomorphism-count cactus graphs (see, e.g., Theorem 2).

## 7 Experiments

All instructions to reproduce the experiments are available on GitHub (MIT license). Additional information on the training and test details can be found in Appendix C.

Expressive Power.We showcase the expressive power of \(r\)-\(\)GIN on synthetic datasets:

* _GRAPH8C_(Balcilar et al., 2021) comprises \(11\)\(117\) connected non-isomorphic simple graphs on \(8\) nodes; \(312\) pairs are \(1\)-WL equivalent but none is \(3\)-WL equivalent.
* _EXP_ISO_(Abboud et al., 2022) comprises \(600\) pairs of \(1\)-WL equivalent graphs.

Figure 3: Indistinguishable pairs at initialization, symlog scale. For GRAPH8C and EXP_ISO, we report the proportion of indistinguishable pairs: \(2\) graphs are deemed indistinguishable if the L\({}^{1}\) distance of their embeddings is less than \(10^{-3}\). For COSPECTRAL10 and SR16622, we report the L\({}^{1}\) distance between graph embeddings. We report the mean and standard deviation over \(100\) seeds.

* _COSPECTRAL10_(van Dam et al., 2003): the dataset comprises two cospectral \(4\)-regular non-isomorphic graphs on \(10\) nodes which are \(1\)-WL equivalent (see, e.g., Figure (a)a).
* _SR16622_(Michel et al., 2023) comprises two strongly regular graphs on \(16\) nodes, namely the Shrikhande and the \(4{}4\) rook graph, which are \(3\)-WL equivalent (see, e.g., Figure (b)b).

The goal is to check whether the model can distinguish non-isomorphic pairs at initialization. The results are shown in Figure 3.

Additionally, Table 1 shows the performance on _BREC_(Wang et al., 2024), which includes \(400\) pairs of non-isomorphic graphs ranging from \(1\)-WL to \(4\)-WL equivalent. The baselines include PPGN, which is 3-WL equivalent and can count up to 7-cycles and homomorphism-count all graphs of tree-width 2; NestedGNN which is between 1-WL and 3-WL; GSN which is more powerful than 1-WL but whose expressive power depends on the chosen pattern.

Finally, Figure 4 reports the performance on synthetic classification tasks:

* _EXP, CEXP_(Abboud et al., 2021) require expressive power beyond 1-WL.
* _CSL_(Murphy et al., 2019) comprises \(150\) cycle graphs with skip links (see, e.g., Figure (c)c). The task is to predict the length of the skip link.

Counting Power.Following (B. Zhang et al., 2024), we use the SUBGARPHCOUNT dataset (Chen et al., 2020) to test the ability to homomorphism- and subgraphs-count exemplary motifs.

    &  & (F,G)\)} \\  Model & & & & & & & \\  MPNN & 0.300 & 0.233 & 0.254 & 0.358 & 0.208 & 0.188 & 0.146 & 0.261 & 0.205 \\ Subgraph GNN & 0.011 & 0.015 & 0.012 & 0.010 & 0.020 & 0.024 & 0.046 & 0.007 & 0.027 \\ Local 2-GNN & 0.008 & 0.008 & 0.010 & 0.008 & 0.011 & 0.017 & 0.034 & 0.007 & 0.016 \\ Local 2-FGNN & 0.003 & 0.005 & 0.004 & 0.003 & 0.004 & 0.010 & 0.020 & 0.003 & 0.010 \\  \(r\)-\(\)GIN & 0.001 & 0.006 & 0.009 & 0.0005 & 0.0005 & 0.0003 & 0.0003 & 0.001 & 0.0004 \\  & (r=2) & (r=3) & (r=3) & (r=1) & (r=2) & (r=3) & (r=4) & (r=2) & (r=3) \\   

Table 2: Test MAE for homomorphism- and subgraph-counts. Results from (B. Zhang et al., 2024).

Figure 4: Test accuracy on synthetic classification task: (left) shared and (right) non-shared weights.

   Model & Basic (60) & Regular (140) & Extension (100) & CFI (100) \\ 
3-WL & 60 & 50 & 100 & 60 \\ PPGN & 60 & 50 & 100 & 23 \\ NestedGNN & 59 & 48 & 59 & 0 \\ GSN & 60 & 99 & 95 & 0 \\ OSAN & 52 & 41 & 82 & 2 \\ 
4-\(\)GIN & 60 & 100 & 95 & 2 \\   

Table 1: Num. of distinguished pairs (\(\)). Results from (Wang et al., 2024).

[MISSING_PAGE_FAIL:9]

On molecular datasets, we observe that \(r\)-\(\)GIN, although designed for subgraph-counting cycles and homomorphism-counting cactus graphs, is highly competitive. Notably, we outperform the baseline \(0\)-\(\)GIN by 226% on ZINC12K and 400% on ZINC250K and surpass domain-agnostic methods such as CIN or GSN. We conjecture that this is attributed to straightforward optimization, driven by the simplicity of the architecture (see, e.g., Figure 1) and its inductive bias towards counting cycles.

LimitationsPath calculations can become infeasible for dense graphs due to \((N\,d^{r})\) complexity, where \(N\) is the number of nodes and \(d\) is the average degree. However, for sparse graphs, the runtime remains reasonably low. For instance, preprocessing ZINC12K for \(r=5\) takes just over a minute.

## 8 Conclusion

In this paper,we introduce a novel hierarchy of color refinement algorithms, denoted as \(r\)-\(\)WL, which incorporates an augmented neighborhood mechanism accounting for nearby paths. We establish connections between \(r\)-\(\)WL and the classical \(k\)-WL. We construct a GNN (\(r\)-\(\)MPNN) designed to emulate and match the expressive poweror \(r\)-\(\)WL. Theoretical and empirical evidence support the claim that \(r\)-\(\)MPNN can effectively subgraph-count cycles and homomorphism-count cactus graphs.

Future research could focus on precisely characterizing the expressivity of \(r\)-\(\)WL tests by identifying the maximal class of graphs that \(r\)-\(\)WL can homomorphism-count. This would facilitate comparisons by constructing pairs of graphs that \(r\)-\(\)WL cannot separate, but other WL variants can. Another promising direction involves exploring the generalization capabilities of GNNs with provable homomorphism-counting properties. The ability to homomorphism-count certain motifs could provide a mathematical framework to support the intuitive notion that the capacity to count relevant features may improve generalization. We observed this improved generalization experimentally in our ablation study on ZINC12K (see, e.g., Table 8).