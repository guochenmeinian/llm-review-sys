# Logical Characterizations of Recurrent Graph Neural Networks with Reals and Floats

Veeti Ahvonen\({}^{1}\), Damian Heiman\({}^{1}\), Antti Kuusisto\({}^{1}\), Carsten Lutz\({}^{2,3}\)

\({}^{1}\)Tampere University, \({}^{2}\)Leipzig University, \({}^{3}\)ScaDS.AI, Dresden/Leipzig

\({}^{1}\)firstname.lastname@tuni.fi, \({}^{2,3}\)clu@informatik.uni-leipzig.de

###### Abstract

In pioneering work from 2019, Barcelo and coauthors identified logics that precisely match the expressive power of constant iteration-depth graph neural networks (GNNs) relative to properties definable in first-order logic. In this article, we give exact logical characterizations of recurrent GNNs in two scenarios: (1) in the setting with floating-point numbers and (2) with reals. For floats, the formalism matching recurrent GNNs is a rule-based modal logic with counting, while for reals we use a suitable infinitary modal logic, also with counting. These results give exact matches between logics and GNNs in the recurrent setting without relativising to a background logic in either case, but using some natural assumptions about floating-point arithmetic. Applying our characterizations, we also prove that, relative to graph properties definable in monadic second-order logic (MSO), our infinitary and rule-based logics are equally expressive. This implies that recurrent GNNs with reals and floats have the same expressive power over MSO-definable properties and shows that, for such properties, also recurrent GNNs with reals are characterized by a (finitary!) rule-based modal logic. In the general case, in contrast, the expressive power with floats is weaker than with reals. In addition to logic-oriented results, we also characterize recurrent GNNs, with both reals and floats, via distributed automata, drawing links to distributed computing models.

## 1 Introduction

Graph Neural Networks (GNNs)  have proven to be highly useful for processing graph data in numerous applications that span a remarkable range of disciplines including bioinformatics , recommender systems , traffic forecasting , and a multitude of others. The success of GNNs in applications has stimulated lively research into their theoretical properties such as expressive power. A landmark result is due to Barcelo et al.  which was among the first to characterize the expressive power of GNNs in terms of _logic_, see  and references therein for related results. More precisely, Barcelo et al. show that a basic GNN model with a constant number of iterations has exactly the same expressive power as graded modal logic \(\) in restriction to properties definable in first-order logic FO.

In this article, we advance the analysis of the expressive power of GNNs in two directions. First, we study the relation between GNN models based on real numbers, as mostly studied in theory, and GNN models based on floating-point numbers, as mostly used in practice. And second, we focus on a family of basic recurrent GNNs while previous research has mainly considered GNNs with a constant number of iterations, with the notable exception of . The GNNs studied in the current paper have a simple and natural termination (or acceptance) condition: termination is signaled via designated feature vectors and thus the GNN "decides" by itself about when to terminate. We remark that some of our results also apply to constant iteration GNNs and to recurrent GNNs with a termination condition based on fixed points, as used in the inaugural work on GNNs ; see the conclusion section for further details.

We provide three main results. The first one is that recurrent GNNs with floats, or \([]\)s, have the same expressive power as the _graded modal substitution calculus_\(\). This is a rule-based modal logic that extends the _modal substitution calculus_\(\) with counting modalities. \(\) has been shown to precisely correspond to distributed computation models based on automata  and Boolean circuits . \(\) is related to the graded modal \(\)-calculus, but orthogonal in expressive power. The correspondence between \([]\)s and \(\) is as follows.

**Theorem 3.2**.: _The following have the same expressive power: \([]\)s, \(\), and R-simple aggregate-combine \([]\)s._

Here _R-simple aggregate-combine_\([]\)s mean \([]\)s that use basic aggregate-combine functions as specified by Barcelo et al.  and the truncated \(\) as the non-linearity function, see Section 2.1 for the formalities. The theorem shows that an R-simple model of \([]\)s suffices, and in fact \([]\)s with a more complex architecture can be turned into equivalent R-simple ones. We emphasize that the characterization provided by Theorem 3.2 is _absolute_, that is, not relative to a background logic. In contrast, the characterization by Barcelo et al.  is relative to first-order logic. Our characterization does rely, however, on an assumption about floating-point arithmetics. We believe that this assumption is entirely natural as it reflects practical implementations of floats.

Our second result shows that recurrent GNNs with reals, or \([]\)s, have the same expressive power as the infinitary modal logic \(\)-\(\) that consists of infinite disjunctions of \(\)-formulas.

**Theorem 3.4**.: \([]\)s have the same expressive power as \(\)-\(\).

Again, this result is absolute. As we assume no restrictions on the arithmetics used in \([]\)s, they are very powerful: with the infinitary logic \(\)-\(\) it is easy to define even undecidable graph properties. We regard the theorem as an interesting theoretical upper bound on the expressivity of GNNs operating in an unrestricted, recurrent message passing scenario with messages flowing to neighbouring nodes. We note that \([]\)s can easily be shown more expressive than \([]\)s.

Our third result considers \([]\)s and \([]\)s relative to a very expressive background logic, probably the most natural choice in the recurrent GNN context: _monadic second-order logic_\(\).

**Theorem 4.3**.: _Let \(\) be a property expressible in \(\). Then \(\) is expressible as a \([]\) if and only if it is expressible as a \([]\)._

This result says that, remarkably, for the very significant and large class of \(\)-expressible properties, using actual reals with unrestricted arithmetic gives no more expressive power than using floats, by Theorem 3.2 even in the R-simple aggregate-combine setting. Thus, for this class of properties, the theoretical analyses from the literature do not diverge from the practical implementation! Taken together, the above results also imply that in restriction to \(\)-expressible properties, \([]\)s are equivalent to the (finitary!) graded modal substitution calculus \(\).

We also develop characterizations of GNNs in terms of distributed automata. These are in fact crucial tools in our proofs, but the characterizations are also interesting in their own right as they build links between GNNs and distributed computing. We study a class of distributed automata called counting message passing automata (\(\)) that may have a countably infinite number of states. Informally, these distributed automata update the state of each node according to the node's own state and the _multiset_ of states received from its out-neighbours. We also study their restriction that admits only a finite number of states (\(\)) and, furthermore, bounded \(\). In the bounded case the multiplicities of states in the received multisets are bounded by some constant \(k\). A summary of our main results, both absolute and relative to \(\), is given in Table 1.

**Related Work.** Barcelo et al.  study aggregate-combine GNNs with a constant number of iterations. They characterize these \(\)--in restriction to properties expressible in first-order logic--in

  Absolute: & \([]\!\!\)R-simple AC-\([]\!\!\)GMSC\(\!\!\)bnd. \(\!\![]\!\!\)-\(\!\!\) \\  \(\): & \([]\!\!\)R-simple AC-\([]\!\!\)GMSC\(\!\!\)bnd. \(\!\![]\!\!\)-\(\!\!\) \\  

Table 1: A summary of our main results. The first row contains the results obtained without relativising to a background logic and the second row contains results relative to \(\). Here \(x y\) means that \(x\) and \(y\) have the same expressive power while \(x<y\) means that \(y\) is strictly more expressive than \(x\). Further, “bnd.” stands for “bounded” and “AC” for “aggregate-combine”.

terms of graded modal logic \(\) and show that a _global readout mechanism_ leads to a model equivalent to the two-variable fragment of first-order logic with counting quantifiers \(^{2}\). Our work extends the former result to include recurrence in a natural way while we leave studying global readouts as future work; see the conclusion section for further details. Grohe  connects the _guarded fragment of first-order logic with counting_\(+\) and polynomial-size bounded-depth circuits, linking (non-recurrent) GNNs to the circuit complexity class \(^{0}\). Grohe's characterization utilises dyadic rationals rather than floating-point numbers. Benedikt et al.  use logics with a generalized form of counting via _Presburger quantifiers_ to obtain characterizations for (non-recurrent) GNNs with a bounded activation function. The article also investigates questions of decidability concerning GNNs--a topic we will not study here. As a general remark on related work, it is worth mentioning that the expressive power of (basic) recurrent GNN-models is invariant under the Weisfeiler-Leman test. This link has been recently studied in numerous articles [25; 36; 12; 5].

Pfluger et al.  investigate recurrent GNNs with two kinds of termination conditions: one based on reaching a fixed point when iteratively generating feature vectors, and one where termination occurs after a number of rounds determined by the size of the input graph. They concentrate on the case of unrestricted aggregation and combination functions, even including all uncomputable ones. Their main result is relative to a logic LocMMFP introduced specifically for this purpose, extending first-order logic with a least fixed-point operator over unary monotone formulas. The characterization itself is given in terms of the graded two-way \(\)-calculus. We remark that \(\) significantly generalizes LocMMFP and that the graded two-way \(\)-calculus is incomparable in expressive power to our \(\). In contrast to our work and to Barcelo et al. , Pfluger et al. do not discuss the case where the aggregation and combination functions of the \(\)s are R-simple or restricted in any other way. We view our work as complementing yet being in the spirit of both Barcelo et al.  and Pfluger et al. .

GNNs are essentially distributed systems, and logical characterizations for distributed systems have been studied widely. A related research direction begins with Hella et al. , Kuusisto  and Hella et al.  by results linking distributed computation models to modal logics. The articles  and  give characterizations of constant-iteration scenarios with modal logics, and  lifts the approach to recurrent message-passing algorithms via showing that the modal substitution calculus \(\) captures the expressivity of finite distributed message passing automata. This generalizes the result from  that characterized the closely related class \((1)\) of local distributed algorithms with modal logic. Later Ahvonen et al.  showed a match between \(\) and circuit-based distributed systems. Building on the work on \(\), Reiter showed in  that the \(\)-fragment of the modal \(\)-calculus captures the expressivity of finite message passing automata in the asynchronous scenario.

## 2 Preliminaries

We let \(\), \(_{+}\) and \(\) denote the sets of non-negative integers, positive integers, and real numbers respectively. For all \(n_{+}\), we let \([n]:=\{1,,n\}\) and for all \(n\), we let \([0;n]:=\{0,,n\}\). With \(|X|\) we denote the cardinality of the set \(X\), with \((X)\) the power set of \(X\) and with \((X)\) the set of multisets over \(X\), i.e., the set of functions \(X\). With \(_{k}(X)\) we denote the set of \(k\)-multisets over \(X\), i.e., the set of functions \(X[0;k]\). Given a \(k\)-multiset \(M_{k}(X)\) and \(x X\), intuitively \(M(x)=n<k\) means that there are exactly \(n\) copies of \(x\) and \(M(x)=k\) means that there are \(k\)_or more_ copies of \(x\).

We work with node-labeled **directed graphs** (possibly with self-loops), and _simply refer to them as **graphs**_. Let \(\) denote a countably infinite set of **node label symbols**, representing features. We denote finite sets of node label symbols by \(\). Given any \(\), a \(\)**-labeled graph** is a triple \(G=(V,E,)\) where \(V\) is a set of **nodes**, \(E V V\) is a set of **edges** and \( V()\) is a **node labeling function**. Note that a node can carry multiple label symbols. A **pointed graph** is a pair \((G,v)\) with \(v V\). Given a graph \((V,E,)\), the set of **out-neighbours** of \(v V\) is \(\{\,w(v,w) E\,\}\). Unless stated otherwise, we only consider _finite_ graphs, i.e., graphs where the set of nodes is finite. A **node property over**\(\) is a class of pointed \(\)-labeled graphs. A **graph property over**\(\) is a class of \(\)-labeled graphs. A graph property \(\) over \(\) corresponds to a node property \(\) over \(\) if the following holds for all \(\)-labeled graphs \(G G\) iff \((G,v)\) for every node \(v\) of \(G\). Henceforth a property means a node property. We note that many of our results hold even with infinite graphs and infinite sets of node label symbols. Our results easily extend to graphs that admit labels on both nodes and edges.

### Graph neural networks

A graph neural network (GNN) is a neural network architecture for graph-structured data. It may be viewed as a distributed system where the nodes of the (directed, node-labeled) input graph calculate with real numbers and communicate synchronously in discrete rounds. More formally, a **recurrent graph neural network**\([]\) over \((,d)\), with \(\) and \(d_{+}\), is a tuple \(=(^{d},,,F)\). A recurrent graph neural network computes in a (node-labeled) directed graph as follows. In any \(\)-labeled graph \((V,E,)\), the **initialization function**\(()^{d}\) assigns to each node \(v\) an initial **feature vector** or **state**\(x_{v}^{0}=((v))\).1 In each subsequent round \(t=1,2,\), every node computes a new feature vector \(x_{v}^{t}\) using a **transition function**\(^{d}(^{d})^{d},(x,y)=(x,(y))\), which is a composition of an **aggregation function**\((^{d})^{d}\) (typically sum, min, max or average) and a **combination function**\(^{d}^{d}^{d}\) such that \(x_{v}^{t}=(x_{v}^{t-1},(\{\{x_{u}^ {t-1}(v,u) E\}\}))\) where double curly brackets \(\{\{\}\}\) denote multisets.2 The recurrent \(\)\(\) **accepts** a pointed \(\)-labeled graph \((G,v)\) if \(v\) visits (at least once) a state in the set \(F^{d}\) of **accepting feature vectors**, i.e., \(x_{v}^{t} F\) for some \(t\). When we do not need to specify \(d\), we may refer to a \([]\) over \((,d)\) as a \([]\) over \(\). A **constant-iteration**\([]\) is a pair \((,N)\) where \(\) is a \([]\) and \(N\). It **accepts** a pointed graph \((G,v)\) if \(x_{v}^{N} F\). Informally, we simply run a \([]\) for \(N\) iterations and accept (or do not accept) based on the last iteration. We say that \(\) (resp., \((,N)\)) **expresses** a node property \(\) over \(\), if for each pointed \(\)-labeled graph \((G,w)\): \((G,w)\) iff \(\) (resp., \((,N)\)) accepts \((G,w)\). A node property \(\) over \(\) is **expressible** as a \([]\) (resp. as a constant-iteration \([]\)) if there is a \([]\) (resp. constant-iteration \([]\)) expressing \(\).

One common, useful and simple possibility for the aggregation and combination functions, which is also used by Barcelo et al. (see , and also the papers ) is defined by \((x_{v}^{t-1},(\{\{\{x_{u}^{t- 1}(v,u) E\}\}\}))=f(x_{v}^{t-1} C+ _{(v,u) E}x_{u}^{t-1} A+)\), where \(f^{d}^{d}\) is a non-linearity function (such as the truncated \(\) also used by Barcelo et al. in , defined by \(^{*}(x)=((0,x),1)\) and applied separately to each vector element), \(C,A^{d d}\) are matrices and \(^{d}\) is a bias vector. We refer to \(\)s that use aggregation and combination functions of this form and \(^{*}\) as the non-linearity function as **R-simple aggregate-combine**\(\)s (here 'R' stands for \(^{*}\)).

**Example 2.1**.: Given \(\) and \(p\), _reachability of node label symbol_\(p\) is the property \(\) over \(\) that contains those pointed \(\)-labeled graphs \((G,v)\) where a path exists from \(v\) to some \(u\) with \(p(u)\). An R-simple aggregate-combine \([]\) over \((,1)\) (where \(C=A=1\), \(=0\) and \(1\) is the only accepting feature vector) can express \(\): In round \(0\), a node \(w\)'s state is \(1\) if \(p(w)\) and else \(0\). In later rounds, \(w\)'s state is \(1\) if \(w\)'s state was \(1\) or it gets \(1\) from its out-neighbours; else the state is \(0\).

**Remark 2.2**.: Notice that unrestricted \([]\)s can express, even in a single iteration, node properties such as that the number of immediate out-neighbours of a node is a prime number. In fact, for any \(U\), including any undecidable set \(U\), a \([]\) can express the property that the number \(l\) of immediate out-neighbours is in the set \(U\). See  for related undecidability results.

Informally, a floating-point system contains a finite set of rational numbers and arithmetic operations \(\) and \(+\). Formally, if \(p_{+}\), \(n\) and \(_{+}\{1\}\), then a **floating-point system** is a tuple \(S=((p,n,),+,)\) that consists of the set \(D_{S}\) of all rationals accurately representable in the form \(0.d_{1} d_{p}^{e}\) or \(-0.d_{1} d_{p}^{e}\) where \(0 d_{i}-1\) and \(e\{-n,,n\}\). It also consists of arithmetic operations \(+\) and \(\) of type \(D_{S} D_{S} D_{S}\). We adopt the common convention where \(+\) and \(\) are defined by taking a precise sum/product w.r.t. reals and then rounding to the closest float in \(D_{S}\), with ties rounding to the float with an even least significant digit, e.g., \(0.312+0.743\) evaluates to \(1.06\) if the real sum \(1.055\) is not in the float system. Thus, our float systems handle overflow by capping at the maximum value instead of wrapping around. We typically just write \(S\) for \(D_{S}\).

Consider GNNs using floats in the place of reals. In GNNs, sum is a common aggregation function (also used in R-simple \(\)s), and the sum of floats can depend on the ordering of floats, since itis not associative. In real-life implementations, the set \(V\) of nodes of the graph studied can typically be associated with an implicit linear order relation \(<^{V}\) (which is not part of the actual graph). It is then natural to count features of out-neighbours in the order \(<^{V}\). However, this allows float GNNs to distinguish isomorphic nodes, which violates the desire of GNNs should be invariant under isomorphism. For example, summing \(1\), \(-1\) and \(0.01\) in two orders in a system where the numbers must be representable in the form \(0.d_{1}d_{2} 10^{e}\) or \(-0.d_{1}d_{2} 10^{e}\): first \((1+(-1))+0.01=0+0.01=0.01\) while \((1+0.01)+(-1)=1+(-1)=0\), since \(1.01\) is not representable in the system. A float GNN could distinguish two isomorphic nodes with such ordering of out-neighbours.

To ensure isomorphism invariance for GNNs with floats that use sum, it is natural to order the floats instead of the nodes. For example, adding floats in increasing order (of the floats) is a natural and simple choice. Summing in this increasing order is also used widely in applications, being a reasonable choice w.r.t. accuracy (see, e.g., ,, ). Generally, floating-point sums in applications have been studied widely, see for example . Summing multisets of floats in increasing order leads to a bound in the multiplicities of the elements of the sum; see Proposition 2.3 for the formal statement. Before discussing its proof, we define the \(k\)**-projection** of a multiset \(M\) as \(M_{|k}\) where \(M_{|k}(x)=\{M(x),k\}\). Given a multiset \(N\) of floats in float system \(S\), we let \(_{}(N)\) denote the output of the sum \(f_{1}++f_{}\) where **(1)**\(f_{i}\) appears \(N(f_{i})\) times (i.e., its multiplicity) in the sum, **(2)** the floats appear and are summed in increasing order and **(3)**\(+\) is according to \(S\).

**Proposition 2.3**.: _For all floating-point systems \(S\), there exists a \(k\) such that for all multisets \(M\) over floats in \(S\), we have \(_{S}(M)=_{S}(M_{|k})\)._

Proof.: (Sketch) See also in Appendix A.2. Let \(u=0.0 01^{e}\) and \(v=0.10 0^{e+1}\). Now notice that for a large enough \(\), summing \(u\) to itself \(m>\) times will always give \(v\). 

Due to Proposition 2.3, GNNs with floats using sum in increasing order are bounded in their ability to fully count out-neighbours. Thus, it is natural to assume that floating-point GNNs are **bounded** GNNs, i.e., the aggregation function can be written as \(_{k}(U^{d}) U^{d}\) for some **bound**\(k\), i.e., for every multiset \(M(U^{d})\), we have \((M)=(M_{|k})\), where \(M_{|k}\) is the \(k\)-projection of \(M\) (and \(U^{d}\) is the set of states of the \(\)). We finally give a formal definition for floating-point GNNs: a **floating-point graph neural network** (\([]\)) is simply a bounded GNN where the set of states and the domains and co-domains of the functions are restricted to some floating-point system \(S\) instead of \(\) (note that \(S\) can be any floating-point system). In R-simple \([]\)s, \(_{S}\) replaces the sum of reals as the aggregation function, and their bound is thus determined by the choice of \(S\). A \([]\) obtained by removing the condition on boundedness is called an **unrestricted**\([]\). Note that by default and unless otherwise stated, a \([]\) is unbounded, whereas a \([]\) is bounded. Now, it is immediately clear that unrestricted \([]\)s (with an unrestricted aggregation function) are more expressive than \([]\)s: expressing the property that a node has an even number of out-neighbours is easy with unrestricted \([]\)s, but no bounded \([]\) with bound \(k\) can distinguish the centers of two star graphs with \(k\) and \(k+1\) out-neighbours.

### Logics

We then define the logics relevant for this paper. For \(\), the set of \(\)**-formulae of graded modal logic** (\(\)) is given by the grammar \(:= p_{ k}\), where \(p\) and \(k\). The connectives \(\), \(\), \(\) are considered abbreviations in the usual way. Note that node label symbols serve as propositional symbols here. A \(\)-formula of \(\) is interpreted in pointed \(\)-labeled graphs. In the context of modal logic, these are often called (pointed) Kripke models. Let \(G=(V,E,)\) be a \(\)-labeled graph and \(w V\). The truth of a formula \(\) in a pointed graph \((G,w)\) (denoted \(G,w\)) is defined as usual for the Boolean operators and \(\), while for \(p\) and \(_{ k}\), we define that \(G,w p\) iff \(p(w)\), and \(G,w_{ k}\) iff \(G,v\) for at least \(k\) out-neighbours \(v\) of \(w\). We use the abbreviations \(:=_{ 1}\), \(:=\) and \(_{n}:=_{ n}_{ n+1}\). The set of \(\)**-formulae of \(\)**-\(\) is given by the grammar \(:=_{}\), where \(\) is a \(\)-formula of \(\) and \(\) is an at most countable set of \(\)-formulae of \(\). The truth of infinite disjunctions is defined in the obvious way: \(G,w_{} G,w\) for some \(\).

We next introduce the graded modal substitution calculus (or \(\)), which extends the modal substitution calculus  with counting capabilities. Define the set \(=\{\,V_{i} i\,\}\) of **schema variable symbols**. Let \(=\{X_{1},,X_{n}\}\). The set of \((,)\)**-schemata** of \(\) is defined by the grammar \(:=\ \ p X_{i}\  _{ k}\) where \(p\), \(X_{i}\) and \(k\). A \((,)\)**-program**\(\) of \(\) consists of two lists of expressions

\[X_{1}(0):-\ _{1} X_{n}(0):-\ _{n} X_{1}:-\ _{1} X_{n}:-\ _{n}\]

where \(_{1},,_{n}\) are \(\)-formulae of \(\) and \(_{1},,_{n}\) are \((,)\)-schemata of \(\). Moreover, each program is associated with a set \(\) of **appointed predicates**. A program of **modal substitution calculus**\(\) is a program of \(\) that may only use diamonds \(\) of the standard modal logic. The expressions \(X_{i}(0):-\ _{i}\) are called **terminal clauses** and \(X_{i}:-\ _{i}\) are called **iteration clauses**. The schema variable \(X_{i}\) in front of the clause is called the **head predicate** and the formula \(_{i}\) (or schema \(_{i}\)) is called the **body** of the clause. The terminal and iteration clauses are the rules of the program. When we do not need to specify \(\), we may refer to a \((,)\)-program as a \(\)**-program** of \(\). Now, the \(n\)**th iteration formula**\(X_{i}^{n}\) of a head predicate \(X_{i}\) (or the iteration formula of \(X_{i}\) in **round**\(n\)) (w.r.t. \(\)) is defined as follows. The \(0\)th iteration formula \(X_{i}^{0}\) is \(_{i}\) and the \((n+1)\)st iteration formula \(X_{i}^{n+1}\) is \(_{i}\) where each head predicate \(Y\) in \(_{i}\) is replaced by the formula \(Y^{n}\). We write \(G,w\) and say that \(\)**accepts**\((G,w)\) iff \(G,w X^{n}\) for some appointed predicate \(X\) and some \(n\). Moreover, for all \((,)\)-schemata \(\) that are not head predicates and for \(n\), we let \(^{n}\) denote the formula (w.r.t. \(\)) where each \(Y\) in \(\) is replaced by \(Y^{n}\).

Recall that **monadic second-order logic**\(\) is obtained as an extension of **first-order logic**\(\) by allowing quantification of unary relation variables \(X\), i.e., if \(\) is an \(\)-formula, then so are \( X\) and \( X\), see e.g.  for more details. Given a set \(\) of node label symbols, an \(\)- or \(\)-formula \(\) over \(\) is an \(\)- or \(\)-formula over a vocabulary which contains exactly a unary predicate for each \(p\) and the edge relation symbol \(E\). Equality is admitted.

Let \(\) be an \(\)-\(\)-formula, \(\)-schema, \(\)-program, or a rule of a program. The **modal depth** (resp. the **width**) of \(\) is the maximum number of nested diamonds in \(\) (resp. the maximum number \(k\) that appears in a diamond \(_{ k}\) in \(\)). If an \(\)-\(\)-formula has no maximum depth (resp., width), its modal depth (resp., width) is \(\). If an \(\)-\(\)-formula has finite modal depth (resp., width), it is **depth-bounded** (resp., width-bounded). The **formula depth** of a \(\)-formula or \(\)-schema is the maximum number of nested operators \(\), \(\) and \(_{ k}\). Given a \(\)-program of \(\) or a \(\)-formula of \(\)-\(\)\(\) (respectively, a formula \((x)\) of \(\) or \(\) over \(\), where the only free variable is the first-order variable \(x\)), we say that \(\) (resp., \((x)\)) **expresses** a node property \(\) over \(\), if for each pointed \(\)-labeled graph \((G,w)\): \((G,w)\) iff \(G,w\) (or resp. \(G(w)\)). A node property \(\) over \(\) is **expressible** in \(\) (resp., in \(\)-\(\), \(\) or \(\)) if there is a \(\)-program of \(\) (resp., a \(\)-formula of \(\)-\(\), \(\) or \(\)) expressing \(\).

**Example 2.4**.: Recall the property _reachability of node label symbol_\(p\) over \(\) defined in Example 2.1. It is expressed by the \(\)-program of \(\)\(X(0):-\ p\), \(X:-\  X\), where \(X\) is an appointed predicate. The \(i\)th iteration formula of \(X\) is \(X^{i}= p\) where there are exactly \(i\) diamonds.

**Example 2.5** ().: A pointed \(\)-labeled graph \((G,w)\) has the _centre-point property_\(\) over \(\) if there exists an \(n\) such that each directed path starting from \(w\) leads to a node with no out-neighbours in exactly \(n\) steps. It is easy to see that the \(\)-program \(X(0):-\ \), \(X:-\  X X\), where \(X\) is an appointed predicate, expresses \(\). In , it was established that the centre-point property is not expressible in \(\) and that there are properties expressible in \(\)-calculus and \(\) that are not expressible in \(\) (e.g., non-reachability), with the same proofs applying to \(\).

**Proposition 2.6**.: _Properties expressible in \(\) are expressible in \(\)-\(\), but not vice versa._

Proof.: A property over \(\) expressed by a \(\)-program \(\) of \(\) is expressible in \(\)-\(\) by the \(\)-formula \(_{X_{i},\ n}X_{i}^{n}\), where \(X_{i}^{n}\) is the \(n\)th iteration formula of appointed predicate \(X_{i}\) of \(\). Like \([]\)s, \(\)-\(\) can express undecidable properties (cf. Remark 2.2). Clearly \(\)-programs \(\) cannot, as configurations defined by \(\) in a finite graph eventually loop, i.e., the truth values of iteration formulae start repeating cyclically. 

While \(\) is related to the graded modal \(\)-calculus (\(\)), which originates from  and is used in  to characterize a recurrent GNN model, \(\) and \(\) are orthogonal in expressivity. Iteration in \(\) need _not_ be over a monotone function and does not necessarily yield a fixed point, and there are no syntactic restrictions that would, e.g., force schema variables to be used only positively as in \(\). The centre-point property from Example 2.5 is a simple property not expressible in \(\) (as it is not even expressible in \(\), into which \(\) translates). Conversely, \(\) offers neither greatest fixed points nor fixed point alternation. In particular, natural properties expressible in the \(\)-fragment of \(\) such as non-reachability are not expressible in \(\); this is proved in  for the non-graded version, and the same proof applies to \(\). However, the \(\)-fragment of the graded modal \(\)-calculus translates into \(\) (by essentially the same argument as the one justifying Proposition 7 in ). We also note that \(\) translates into partial fixed-point logic with choice , but it is not clear whether the same holds without choice.

## 3 Connecting GNNs and logics via automata

In this section we establish exact matches between classes of \(\)s and our logics. The first main theorem is Theorem 3.2, showing that \([]\)s, R-simple aggregate-combine \([]\)s and \(\) are equally expressive. Theorem 3.4 is the second main result, showing that \([]\)s and \(\)-\(\) are equally expressive. We begin by defining the concept of distributed automata which we will mainly use as a tool for our arguments but they also lead to nice additional characterizations. Informally, we consider a model of distributed automata called counting message passing automata and its variants which operate similarly to \(\)s. These distributed automata update the state of each node according to the node's own state and the _multiset_ of states of its out-neighbours.

Formally, given \(\), a **counting message passing automaton**\(()\) over \(\) is a tuple \((Q,,,F)\) where \(Q\) is an at most countable set of _states_ and \(\), \(\) and \(F\) are defined in a similar way as for \(\)s: \(() Q\) is an _initialization function_, \( Q(Q) Q\)_a transition function_ and \(F Q\) a set of _accepting states_. Computation of a \(\) over \(\) is defined in a \(\)-labeled graph \(G\) analogously to GNNs: for each node \(w\) in \(G\), the initialization function gives the initial state for \(w\) based on the node label symbols true in \(w\), and the transition function is applied to the previous state of \(w\) and the multiset of states of out-neighbours of \(w\). Acceptance is similar to \(\)s: the \(\)**accepts**\((G,w)\) if the \(\) visits (at least once) an accepting state at \(w\) in \(G\). A **bounded**\(\) is a \(\) whose transition function can be written as \( Q_{k}(Q) Q\) for some \(k\) (i.e., \((q,M)=(q,M_{[k})\) for each multiset \(M(Q)\) and state \(q Q\)). A **finite**\(\) (\(\)) is a \(\) with finite \(Q\). We define bounded \(\)s similarly to bounded \(\)s. A \(\) over \(\)**expresses** a node property \(\) over \(\) if \(\) accepts \((G,w)\) iff \((G,w)\). We define whether a node property \(\) is expressible by a \(\) in a way analogous to \(\)s.

For any \(\), a \(\)-object refers to a GNN over \(\), a \(\) over \(\), a \(\)-formula of \(\)-\(\) or a \(\)-program of \(\). Let \(\) be the class of all \(\)-objects for all \(\). Two \(\)-objects in \(\) are **equivalent** if they express the same node property over \(\). Subsets \(A,B\)**have the same expressive power**, if each \(x A\) has an equivalent \(y B\) and vice versa. It is easy to obtain the following.

**Proposition 3.1**.: _Bounded \(\)s have the same expressive power as \(\)._

Proof.: (Sketch) Details in Appendix B.2. To obtain a bounded \(\) equivalent to a \(\)-program \(\), we first turn \(\) into an equivalent program \(\) where the modal depth of terminal clauses (resp., iteration clauses) is \(0\) (resp., at most \(1\)). Then from \(\) with head predicate set \(^{}\), we construct an equivalent \(\)\(\) as follows. The set of states of \(\) is \((^{})\) and \(\) enters in round \(n\) in node \(w\) into a state that contains precisely the node label symbols true in \(w\) and the predicates \(X\) whose iteration formula \(X^{n}\) is true at \(w\). For the converse, we create a head predicate for each state in \(\), and let predicates for accepting states be appointed. The terminal clauses simulate \(\) using disjunctions of conjunctions of non-negated and negated node label symbols. The iteration clauses simulate \(\) using, for each pair \((q,q^{})\), a subschema specifying the multisets that take \(q\) to \(q^{}\). 

We are ready to show equiexpressivity of \(\) and \([]\)s. This applies _without relativising to any background logic_. The direction from \([]\)s to \(\) is trivial. The other direction is more challenging, in particular when going all the way to R-simple \([]\)s. While size issues were not a concern in this work, we observe that the translation from \([]\)s to \(\) involves only polynomial blow-up in size; the related definitions and proofs are in appendices A.1, B.2 and B.3. We also conjecture that a polynomial translation from \(\) to R-simple \([]\)s is possible by the results and techniques in , taking into account differences between \([]\)s and R-simple \([]\)s w.r.t. the definition of size. A more serious examination of blow-ups would require a case-by-case analysis taking other such details into account.

**Theorem 3.2**.: _The following have the same expressive power: \([]\)s, \(\), and R-simple aggregate-combine \([]\)s._Proof.: (Sketch) Details in Appendix B.3. By definition, a \([]\) is just a bounded \(\) and translates to a \(\)-program by Proposition 3.1. To construct an R-simple aggregate-combine \([]\)\(\) for a \(\)-program \(\) with formula depth \(D\), we first turn \(\) into an equivalent program \(\), where each terminal clause has the body \(\), the formula depth of each body of an iteration clause is \(D^{}\) (linear in \(D\)) and for each subschema of \(\) that is a conjunction, both conjuncts have the same formula depth if neither conjunct is \(\). We choose a floating-point system that can express all integers up to the width of \(\). We define binary feature vectors that are split into two halves: the 1st half intuitively calculates the truth values of the head predicates and subschemata of \(\) one formula depth at a time in the style of Barcelo et al. . The 2nd half records the current formula depth under evaluation. \(\) simulates one round of \(\) in \(D^{}+1\) rounds, using the 2nd half of the features to accept nodes only every \(D^{}+1\) rounds: the truth values of head predicates are correct in those rounds. Note that the choice of floating-point system in \(\) depends on \(\) and thus no single floating-point system is used by all GNNs resulting from the translation. In fact, fixing a single floating-point system would trivialize the computing model as only finitely many functions could be defined. 

To show that \([]\)s and \(\)-\(\) are equally expressive, we first prove a useful theorem.

**Theorem 3.3**.: \(\) _have the same expressive power as \(\)-\(\)._

Proof.: (Sketch) Details in Appendix B.4. To construct a \(\) for each \(\)-\(\)-formula \(\), we define a \(\)-formula called the "_full graded type of modal depth \(n\)_" for each pointed graph \((G,w)\), which expresses all the local information of the neighbourhood of \(w\) up to depth \(n\) (with the maximum out-degree of \(G\) plus 1 sufficing for width). We show that each \(\)-\(\)-formula \(\) is equivalent to an infinite disjunction \(_{}\) of types. We then define a \(\) that computes the type of modal depth \(n\) of each node in round \(n\). Its accepting states are the types in the type-disjunction \(_{}\). For the converse, to show that each \(\) has an equivalent \(\)-\(\)-formula, we first show that two pointed graphs satisfying the same full graded type of modal depth \(n\) have identical states in each round \( n\) in each \(\). The \(\)-\(\)-formula is the disjunction containing every type \(T\) such that some \((G,w)\) satisfying \(T\) is accepted by the automaton in round \(n\), where \(n\) is the depth of \(T\). 

Next we characterize \([]\)s with \(\)-\(\)_without relativising to a background logic_. As the theorems above and below imply that \([]\)s and \(\)s are equally expressive, it follows that \([]\)s can be discretized to \(\)s having--by definition--an only countable set of states.

**Theorem 3.4**.: \([]\)_have the same expressive power as \(\)-\(\)._

Proof.: (Sketch) Details in Appendix B.5. For any \([]\), we build an equivalent \(\)-\(\)-formula using the same method as in the proof of Theorem 3.3, where we show that for each \(\), we can find an equivalent \(\)-\(\)-formula. For the converse, we first translate an \(\)-\(\)-formula to a \(\) by Theorem 3.3 and then translate \(\) to an equivalent \(\) with maximal ability to distinguish nodes. Then we build an equivalent \([]\) for \(^{}\) by encoding states into integers. 

**Remark 3.5**.: It is easy to show that unrestricted \([]\)s have the same expressive power as \(\)s. Moreover, the proof of Theorem 3.4 is easily modified to show that bounded \([]\)s have the same expressive power as width-bounded \(\)-\(\). See Appendix B.6 for the proofs.

In Appendix B.7 we show that our model of constant-iteration \([]\)s is equivalent to the one in Barcelo et al. . Thus Theorem 3.6 (proven in Appendix B.8) generalizes the result in  saying that any property \(\) expressible by \(\) is expressible as a constant-iteration \([]\) iff it is expressible in \(\). Furthermore, any such \(\) is expressible in \(\) iff it is expressible in \(\)-\(\).

**Theorem 3.6**.: _Constant-iteration \([]\)s have the same expressive power as depth-bounded \(\)-\(\)._

## 4 Characterizing GNNs over \(\)-expressible properties

In this section we consider properties expressible in \(\). The first main result is Theorem 4.1, where we show that for properties expressible in \(\), the expressive power of \([]\)s is captured by a _finitary_ logic. In fact, this logic is \(\) and by Theorem 3.2, it follows that relative to \(\), \([]\)s have the same expressive power as \([]\)s (Theorem 4.3 below). Our arguments in this section work uniformly for any finite set \(_{N}\) of node label symbols.

**Theorem 4.1**.: _Let \(\) be a property expressible in \(\). Then \(\) is expressible as a \([]\) if and only if it is expressible in \(\)._

Theorem 4.1 is proved later in this section. The recent work  relates to Theorem 4.1; see the introduction for a discussion. The proof of Theorem 4.1 can easily be adapted to show that a property \(\) expressible in \(\) is expressible as a constant-iteration \([]\) iff it is expressible in \(\). This relates to  which shows the same for \(\) in place of \(\). However, in this particular case the \(\) version is not an actual generalization as based on , we show the following in Appendix C.1.

**Lemma 4.2**.: _Any property expressible in \(\) and as a constant-iteration \([]\) is also \(\)-expressible._

Uniting Theorems 4.1 and 3.2, we see that (recurrent) \([]\)s and \([]\)s coincide relative to \(\). It is easy to get a similar result for constant-iteration \(\)s (the details are in Appendix C.3).

**Theorem 4.3**.: _Let \(\) be a property expressible in \(\). Then \(\) is expressible as a \([]\) if and only if it is expressible as a \([]\). The same is true for constant-iteration \(\)s._

To put Theorem 4.3 into perspective, we note that by Example 2.5, the centre-point property is expressible in \(\), but not in \(\). From Theorem 3.2, we thus obtain the following.

**Proposition 4.4**.: _There is a property \(\) that is expressible as a \([]\) but not in \(\)._

Theorem 3.6 shows that constant-iteration \([]\)s and depth-bounded \(\)-\(\) are equally expressive. The proof of Proposition 2.6 shows that already depth-bounded \(\)-\(\) can express properties that \(\) cannot, in particular undecidable ones. Thus, by Theorem 3.2 we obtain the following.

**Proposition 4.5**.: _There is a property expressible as a constant-iteration \([]\) but not as a \([]\)._

We next discuss the proof of Theorem 4.1. We build upon results due to Janin and Walukiewicz , reusing an automaton model from  that captures the expressivity of \(\) on tree-shaped graphs. With a tree-shaped graph we mean a _potentially infinite_ graph that is a directed tree. The out-degree of nodes is unrestricted (but nevertheless finite), different nodes may have different degree, and both leaves and infinite paths are admitted in the same tree.

We next introduce the mentioned automaton model. Although we are only going to use it on tree-shaped \(_{N}\)-labeled graphs, in its full generality it is actually defined on unrestricted such graphs. We nevertheless call them **tree automata** as they belong to the tradition of more classical forms of such automata. In particular, a run of an automaton is tree-shaped, even if the input graph is not. Formally, a **parity tree automaton (PTA)** is a tuple \(=(Q,_{N},q_{0},,)\), where \(Q\) is a finite set of **states**, \(_{N}\) is a finite set of node label symbols, \(q_{0} Q\) is an **initial state**, \( Q(_{N})\) is a transition relation with \(\) being the set of all **transition formulas** for \(\) defined below, and \(:Q\) is a **priority function**. A transition formula for \(\) is a disjunction of FO-formulas of the form

\[ x_{1} x_{k}((x_{1},,x_{k}) q _{1}(x_{1}) q_{k}(x_{k}) z((z,x_{ 1},,x_{k})))\]

where \(k 0\), \((y_{1},,y_{n})\) shortens an \(\)-formula declaring \(y_{1},,y_{n}\) as pairwise distinct, \(q_{i} Q\) are states used as unary predicates and \(\) is a disjunction of conjunctions of atoms \(q(z)\), with \(q Q\). A PTA \(\) accepts a language \(L()\) consisting of (possibly infinite) graphs \(G\). We have \(G L()\) if there is an accepting **run** of \(\) on \(G\), and runs are defined in the spirit of alternating automata. While details are in Appendix C.2, we mention that transition formulas govern transitions in the run: a transition of a PTA currently visiting node \(v\) in state \(q\) consists of sending copies of itself to out-neighbours of \(v\), potentially in states other than \(q\). It is not required that a copy is sent to every out-neighbour, and multiple copies (in different states) can be sent to the same out-neighbour. However, we must find some \((q,(v),)\) such that the transition satisfies \(\) in the sense that \(\) is satisfied in the graph with one element for each out-neighbour of \(v\) and unary predicates (states of \(\)) are interpreted according to the transition. This specific form of PTAs is interesting to us due to the following.

**Theorem 4.6**.: _Let \(\) be a property expressible in \(\) and in \(\)-\(\). Then there is a PTA \(\) such that for any graph \(G\): \((G,w)\) iff the unraveling of \(G\) at \(w\) is in \(L()\)._Proof.: Let \((x)\) be the \(\)-formula over \(_{N}\) that expresses \(\). Theorem 9 in  states that for every \(\)-sentence \(\), there is a PTA \(\) such that for every tree-shaped \(_{N}\)-labeled graph \(G\) we have that \(G L()\) iff \(G\). To obtain a PTA for \((x)\), we start from the \(\)-sentence \( x\,((x) yE(y,x))\) and build the corresponding PTA \(\). Then \(\) is as desired. In fact, \((G,w)\) iff \(G(w)\) iff \(U(w)\) with \(U\) the unraveling of \(G\) at \(w\) since \(\) is expressible by an \(\)-\(\)-formula which is invariant under unraveling (defined in Appendix C.1). Moreover, \(U(w)\) iff \(U\) iff \(U L()\). 

Since \(\)-programs are invariant under unraveling, we may now prove Theorem 4.1 by considering PTAs obtained by Theorem 4.6 and constructing a \(_{N}\)-program \(\) of \(\) for each such PTA \(=(Q,_{N},q_{0},,)\) so that the following holds: For every tree-shaped \(_{N}\)-labeled graph \(G\) with root \(w\), we have \(G L()\) iff \(G,w\). We then say that \(\) and \(\) are **tree equivalent**.

For a state \(q Q\), let \(_{q}\) be the PTA defined like \(\) but with \(q\) as its initial state. For a tree-shaped graph \(T\), set \(Q_{T}=\{q Q T L(_{q})\}\). We say that \((Q)\) is **the universal set for \(P_{N}\)** if \(\) consists precisely of the sets \(Q_{T}\), for all tree-shaped graphs \(T\), whose root is labeled exactly with the node label symbols in \(P\). Let \(T=(V,E,)\) be a tree-shaped graph with root \(w\) and \(k\), and let \(V_{k}\) be the restriction of \(V\) to the nodes on level at most \(k\) (the root being on level 0). A \(k\)**-prefix decoration** of \(T\) is a mapping \(:V_{k}((Q))\) such that the following conditions hold: **(1)** for each \(S(w)\): \(q_{0} S\); **(2)** for all \(v V\) on the level \(k\), \((v)\) is the universal set for \((v)\); **(3)** for each \(v V\) on some level smaller than \(k\) that has out-neighbours \(u_{1},,u_{n}\) and all \(S_{1}(u_{1}),,S_{n}(u_{n})\), \((v)\) contains the set \(S\) that contains a state \(q Q\) iff we have \((q,(v))=\) such that \(\) is satisfied in the following graph: the universe is \(\{u_{1},,u_{n}\}\) and each unary predicate \(q^{} Q\) is interpreted as \(\{u_{i} q^{} S_{i}\}\). Intuitively, a \(k\)-prefix decoration of \(T\) represents a set of accepting runs of \(\) on the prefix \(T_{k}\) of \(T\). As these runs start in universal sets, for each extension of \(T_{k}\) obtained by attaching trees to nodes on level \(k\), we can find a run among the represented ones that can be extended to an accepting run of \(\) on that extension. In fact \(T\) is such an extension. The following crucial lemma is proved in Appendix C.2.

**Lemma 4.7**.: _For every tree-shaped \(_{N}\)-labeled graph \(T\): \(T L()\) if and only if there is a \(k\)-prefix decoration of \(T\), for some \(k\)._

Using the above, we sketch the proof of Theorem 4.1; the full proof is in Appendix C.2.

Proof of Theorem 4.1.: By Lemma 4.7, given a PTA \(\) obtained from Lemma 4.6, we get a tree equivalent \(\)-program \(\) by building \(\) to accept the root of a tree-shaped graph \(G\) iff \(G\) has a \(k\)-prefix decoration for some \(k\). This requires care, but is possible; the details are in Appendix C.2. A crucial part of the proof is transferring the set of transition formulas of \(\) into the rules of \(\). 

## 5 Conclusion

We have characterized the expressivity of recurrent GNNs with floats and reals in terms of modal logics, both in general and relative to \(\). Particularly, in restriction to \(\), GNNs with floats and with reals have the same expressiveness. We mention two interesting directions for future research. The first one is to extend our GNN model, e.g., with global readouts. On the GML side, these correspond to the (counting) global modality . Interestingly, it can be proved--via showing that fixed points can be defined--that this extension makes non-reachability expressible, cf. Example 2.5. The second direction is to consider other acceptance conditions for recurrent GNNs. Intuitively, it should be possible to establish Theorem 3.2 for virtually any GNN acceptance condition, as long as the acceptance condition of GMSC is changed accordingly. Both of these directions are explored in . In particular, it is shown there (and in Appendix D.1) that Theorem 3.2 also holds for recurrent GNNs where termination is based on fixed points, studied under the name "RecGNN" in . These fixed points require only that a round is reached where the examined node does not exit the set of accepting states which is closely related to but different from the fixed point condition in the inaugural works [30; 11] which requires all nodes in the network to reach a stable state.

**Limitations:** For our acceptance condition (and for many others such as those based on fixed points), training and applying a recurrent GNN brings questions of termination. These are very important from a practical perspective, but not studied in this paper. A particularly interesting question is whether termination can be learned in a natural way during the training phase.