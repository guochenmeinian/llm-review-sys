# Taming the Long Tail in Human Mobility Prediction

Xiaohang Xu1, Renhe Jiang1*, Chuang Yang1, Zipei Fan1, Kaoru Sezaki1

1The University of Tokyo

xhxu@g.ecc.u-tokyo.ac.jp

{jiangrh, chuang.yang}@csis.u-tokyo.ac.jp

{fanzipei, sezaki}@iis.u-tokyo.ac.jp

###### Abstract

With the popularity of location-based services, human mobility prediction plays a key role in enhancing personalized navigation, optimizing recommendation systems, and facilitating urban mobility and planning. This involves predicting a user's next POI (point-of-interest) visit using their past visit history. However, the uneven distribution of visitations over time and space, namely the long-tail problem in spatial distribution, makes it difficult for AI models to predict those POIs that are less visited by humans. In light of this issue, we propose the **L**ong-**T**ail Adjusted **N**ext** POI Prediction (LoTNext) framework for mobility prediction, combining a Long-Tailed Graph Adjustment module to reduce the impact of the long-tailed nodes in the user-POI interaction graph and a novel Long-Tailed Loss Adjustment module to adjust loss by logit score and sample weight adjustment strategy. Also, we employ the auxiliary prediction task to enhance generalization and accuracy. Our experiments with two real-world trajectory datasets demonstrate that LoTNext significantly surpasses existing state-of-the-art works.

## 1 Introduction

Human mobility prediction is essential in various applications, aiming to forecast the next Point of Interest (POI) a user may visit based on their historical location data, preferences, and patterns . By predicting user movements, it supports urban planning, traffic management, and environmental protection, and provides intelligent personalized Location-Based Social Networking (LBSN) services , enhancing people's life quality.

The growth of POI prediction tasks is closely linked to the development of LBSN platforms, where users frequently share their itineraries and reviews, leading to a substantial accumulation of geographical visitation data. However, data collection faces challenges due to network and privacy constraints on mobile devices and the requirement for user authorization to record check-ins. This often results in data being sparse and biased towards popular locations, exhibiting a severe long-tail effect. Currently, these methods fall into two primary categories: _Sequence-based_ and _Graph-based_ models.

* _Sequence-based_ models treat users' trajectories as independent visitation sequences. Existing methods include Recurrent Neural Networks (RNNs) , Long Short Term Memory (LSTM)  and Gated Recurrent Unit (GRU)  for modeling the rich spatial-temporal information implied in the visitation sequence.
* _Graph-based_ models focus on building models and data structures to capture trend information in the data to enhance the prediction performance, such as the movement trends among all users , geographic adjacency , and category transition between POIs . This helps in modeling complex global visitation preferences and the semantic context of locations.

Nevertheless, existing works often overlook the intrinsic long-tailed distribution problem in spatial visitation patterns. As shown in Figure 1, it provides the evidence of long-tailed distribution on Gowalla1 dataset, a real LBSN dataset. From the visualization results, it is evident that only a few POIs are visited more than 100 times. In addition, the illustrative diagram above the graph presents a hypothetical scenario. The prediction model might inaccurately predict that a user would visit a common location, such as McDonald's (a Head POI), while the user actually visits a less common place like a ramen restaurant (a Long-Tail POI). This highlights the importance of designing models capable of accurately predicting visits to Long-Tail POIs. The concept of a long-tailed distribution, while first extensively studied and addressed within the computer vision (CV) field , manifests differently in the context of POI prediction. In POI prediction, long-tailed POIs are embedded within users' complex trajectories. This distinction means that unlike in CV, where long-tailed samples can be selectively augmented to balance datasets, selecting long-tailed POIs without considering the spatial-temporal context in which they occur risks losing crucial trajectory information.

Against this background, to mitigate the long-tail problem in the human next POI prediction task, we propose the **L**ong**-**T**ail Adjusted **N**ext** POI prediction (LoTNext) 2 framework, which is a generic framework aimed at optimizing and fully utilizing long-tailed POI information. More specifically, our solution first employs a Long-Tailed Graph Adjustment module to reduce noise and long-tailed nodes in the user-POI interaction graph, thereby mitigating the impact of long-tailed POIs on model performance. Through graph adjustment, the model can more accurately capture spatial-temporal information from trajectory contexts. Furthermore, to prevent the model from overly focusing on head POIs (high-frequency POIs), we propose the Long-Tailed Loss Adjustment module to balance the loss between head and tail POI data. Finally, to alleviate the intrinsic sparsity issue without introducing additional data sources, we incorporate auxiliary prediction tasks to further integrate the POI feature and spatial-temporal information.

We conclude our contributions as follows: (1) We propose the LoTNext framework based on graph adjustment to effectively address the challenges of dataset-inherent sparsity in the user-POI interaction graph. (2) We design the Long-Tailed Loss Adjustment module for adaptive sample re-weighting, which more effectively balances the loss between head and tail samples. (3) We introduce the auxiliary prediction task, which achieves complementarity of POI feature information and spatial-temporal information. (4) We evaluate LoTNext on two public LBSN datasets, comparing it with numerous baselines. The results demonstrate that LoTNext significantly outperforms state-of-the-art methods.

## 2 Related Work

**Next POI Prediction.** Most current works on the next POI prediction treat trajectories as time series, further incorporating spatial-temporal contexts into models to enrich the semantics of POIs. The pioneering ST-RNN  introduces spatial-temporal intervals to RNN for context awareness. DeepMove  integrates LSTM with attention mechanisms to consider both the short-term and long-term preferences of users comprehensively, and LSTPM  enhances spatial context integration. The Flashback model  tackles user sparsity by mining similar contexts in historical data. However, due to the limited capability of RNN in modeling long sequences, researchers have explored using graphs for improvements. GETNext , based on the Transformer architecture, combines global mobility patterns graph with various spatial-temporal contexts to fully utilize information among similar user trajectories for improving prediction performance. Graph-Flashback  considers constructing a knowledge graph to improve POI representation and integrates it with sequence recommendation models. SNPM  builds a POI similarity graph to aggregate similar POIs and enhance POI representation results. However, all these studies overlook the significant impact of the long-tail problem on the next POI prediction.

Figure 1: The long-tailed distribution for POI check-in frequency from the Gowalla dataset.

**Long-Tailed Learning.** The long-tail problem has always been a focus in the fields of CV [3; 30] and recommendation systems . The most direct solution is re-sampling , varying from random to progressively balanced. Another common strategy is logit adjustment [24; 25; 31], aimed at modifying the logistic output to address the imbalanced data class problem. A study by Google  has proven that logit adjustment satisfies Fisher consistency and can effectively minimize the average error per category. Compared to the CV field, the long-tail problem is more pronounced in recommendation systems [1; 19]. Typically, the number of items far exceeds the number of users, leading to many items rarely or infrequently accessed by users. Some works tackle the long-tail problem by learning item similarities through random walk algorithms  or utilizing transfer learning to transfer the knowledge from head to tail data .  used meta-learning to enhance the information representation of the user-item graph.  introduced a novel edge addition module to enrich the connectivity for tail samples. However, unlike traditional recommendation tasks, the next POI prediction involves complex spatial-temporal semantics due to the nature of trajectory data, making it more challenging to improve the representation of long-tailed POI samples. _To the best of our knowledge, our work is the first to propose a general framework for the next POI prediction under the long-tail problem._

## 3 Problem Definition

Given a user set \(U\) = \(\{u_{1},u_{2},...,u_{|U|}\}\) and a POI set \(P\) = \(\{p_{1},p_{2},...,p_{|P|}\}\), with \(|U|\) and \(|P|\) indicating the number of users and POIs respectively, we denote the POI check-in as a triplet \( u,p,t\), which means a user \(u\) visits POI \(p\) at time \(t\). Each POI \(p\) is a triplet \(p\) = \( lat,lon,freq\), representing its latitude, longitude, and visit frequency. We proceed to outline our problem definition as follows.

**Definition 1** (**User Next POI Prediction**): _Given a user check-in sequence denoted as \(Q_{u}\)= \(( p_{1},t_{1}, p_{2},t_{2},, p_{n},t_{ n})\), our goal is to predict a list of top POIs that the user \(u\) is likely to visit next, which can be taken as a typical sequence classification task over \(|P|\) POI candidates. In particular, our work focuses on how to accurately predict the "less visited" POIs belonging to the long-tailed interval._

## 4 Methodology

In this section, we introduce the details of the LoTNext framework, as shown in Figure 2, which consists of the preliminary POI prediction model, Long-Tailed Graph Adjustment module, and Long-Tailed Loss Adjustment module.

### Preliminary Model

We first construct a preliminary end-to-end model, which is designed for precise next POI prediction.

Figure 2: The Architecture of **Long-T**ail Adjusted Network for **Next** POI Prediction (**LoTNext**).

**Trajectory Embedding Layer.** For the embedding generation, we initialize embeddings for POIs \(E^{P}^{|P| d_{p}}\), timestamps \(E^{T}^{|T| d_{t}}\), and users \(E^{U}^{|U| d_{u}}\), where \(d_{p}\), \(d_{t}\) and \(d_{u}\) are the corresponding embedding dimension and \(|T|\) is the number of the time slots. In our case, considering each hour slot over a week, there are 168 time slots in total. During the sequence processing phase, we select embedding from \(E^{P}\) and \(E^{T}\) based on the POI and time indices in the input sequence \(Q_{u}\) to construct an embedding sequence \(X^{n(d_{p}+d_{t})}\), as \(X=(E^{P}_{p_{1}},E^{P}_{p_{2}},...,E^{P}_{p_{n}})||(E^{T}_{t_{1}},E^{T}_ {t_{2}},...,E^{T}_{t_{n}})\), where \(n\) is the sequence length and \(||\) denotes the concatenation operation.

**Transformer Encoder.** Transformer  architecture in modeling trajectories has been demonstrated in multiple studies , we adopt its encoder block to encode spatial-temporal contexts within trajectories, focusing on capturing long-distance dependencies through multi-layer stacking. To maintain positional information in the sequence, we incorporate a learnable positional embedding \(E_{pos}^{n d_{p}}\) with the raw embedding sequence \(X\) to form the Transformer input \(=X+E_{pos}\). Next, we define the Transformer encoder block as follows:

\[ Z&=(+ ()),\\ &=(Z)+(Z)), \] (1)

where FFN is a fully connected layer and the Multi-Head Attention can be described as:

\[()&=[ _{1}||_{2}||...||_{h}]W^{O},\\ _{i}&=(^{i}W^{Q}(^{i}W^{K})^{T}}{}}) ^{i}W^{V},\] (2)

where \(^{i}\) is the input of the \(i\)-th head, \(W^{O},W^{Q},W^{K}\), and \(W^{V}\) are the learnable weights matrix, \(h\) is the number of the head, and \(}\) is the scaling factor.

**Spatial Contextual Attention Layer.** Inspired by Flashback , we introduce the Spatial Contextual Attention Layer to analyze the relationship between spatial proximity and user interactions. It assigns dynamic weights to POIs in a sequence, taking into account both the order and geographical distances, focusing on POIs most influential to future movements. The spatial weight \(_{k}\) for each POI \(p_{k}\) in the sequence \((p_{1},p_{2},...,p_{k},...,p_{n})\), considering its spatial distance to all previous POIs \(p_{1}\)\(\)\(p_{k}\), is:

\[_{k}=_{j=1}^{k}(e^{-((p_{j},p_{k}))}+),\] (3)

where \((p_{j},p_{k})\) is the haversine distance between \(p_{j}\) and \(p_{k}\), \(\) is the distance decay weight, and \(\) is a small constant to prevent division by zero. Considering \(_{k}\), an element from the Transformer output sequence \(=(_{1},_{2},...,_{k},...,_{n})\). The refined output \(^{}_{k}\) is obtained by applying spatial weight to the cumulative previous outputs, defined as follows:

\[^{}_{k}=^{k}_{j}_{j}}{_ {j=1}^{k}_{j}}.\] (4)

**Prediction Layer.** To provide personalized predictive outcomes and ensure accurate representation even for users with fewer check-ins, we further introduce user embeddings \(E^{U}_{u}\) and fuse it with refined output \(^{}\) to form the input \(=[^{}||E^{U}_{u}]\) for the final fully connected layer \(L=W+b^{P}\), where \(W^{(d_{p}+d_{u})|P|}\) is the weight matrix of the fully connected layer, \(b^{|P|}\) is the bias, and \(L^{n|P|}\) is the logit scores for \(n\) steps of POI prediction. As the POI prediction is essentially a sequence classification task, we adopt the standard cross-entropy loss \(_{CE}\) as follows:

\[_{CE}=-_{k=1}^{N}_{i=1}^{|P|}y_{i}^{k}( ^{k})}{_{j=1}^{|P|}(l_{j}^{k})}),\] (5)

where \(l_{i}^{k}^{1}\) represents the logit score of the \(k\)-th sample for the \(i\)-th POI candidate in \(P\), and \(y_{i}^{k}\) is the ground-truth indicator on POI label \(i\) for the \(k\)-th sample. In our implementation, we mix the \(n\) steps of prediction and \(B\) samples in one batch together as \(N=n B\) samples in total.

### Long-Tailed Graph Adjustment

In the next POI prediction task, we model user-POI interactions via a User-POI Interaction Graph \(^{In}\) = (\(^{In},^{In}\)), where \(^{In}\) = \([E^{U}||E^{P}]^{(|U|+|P|) d}\) is the input node feature matrix of the \(^{In}\), \(d\) = \(d_{p}\) = \(d_{u}\), and \(^{In}^{|U||P|}\) is the adjacent matrix. It's a bipartite graph where user \(U\) and POI \(P\) nodes connect through edges symbolizing interaction frequencies or preferences. Graph Neural Networks (GNNs)  can leverage graphs to learn complex node representations, but performance hinges on graph quality. However, the \(^{In}\) often has long-tailed distributions--most interactions are limited to few nodes with high visit frequency, which affects the quality of node embeddings and model efficacy. To tackle the long-tail problem in \(^{In}\), we propose a denoising layer to prune and reduce sparse interactions caused by the distribution. This layer evaluates edge importance, retaining only beneficial edges for learning. Initially, an attention layer weights edges according to user-POI embedding interactions, processed by a multilayer perceptron (MLP) to obtain attention scores:

\[A_{ij}=(W^{B}(W^{A}[E_{i}^{U}||E_{j}^{P}]+b^{A})+b^ {B}).\] (6)

Here, \(\) denotes the sigmoid function, ensuring that the attention scores \(A_{ij}\) lie in the (0, 1) interval, \(E_{i}^{U}\) and \(E_{j}^{P}\) means the embedding of user and POI, \(W\) represents the trainable weight matrix, and \(b\) represents the bias. Based on the attention score \(A_{ij}\), the denoising process applies a thresholding operation to filter out edges with scores below a threshold \(\), effectively reducing noise and focusing on high-quality interactions. This process aims to derive the denoised graph \(}^{In}=(^{In},}^{In})\) can be formalized as:

\[}_{ij}^{In}=_{ij}^{In}[A_{ ij}],\] (7)

where \(}_{ij}^{In}\) denotes the refined edge and \([]\) is the indicator function. The threshold \(\) controls the sparsity of the graph, only edges with weights signifying a strong user-POI relationship are retained in \(}^{In}\). It is worth noting that when all edges fall below \(\), the edge with the highest attention score is retained to prevent isolated nodes in the graph. The model then leverages the Graph Convolutional Network (GCN)  layer to learn the node embedding \(E^{In}\) of the \(}^{In}\), as follows:

\[E^{In}=((D^{In})^{-}} ^{In}(D^{In})^{-}^{In}W^{In}),\] (8)

where \(D^{In}\) is the degree matrix of the \(}^{In}\), and \(W^{In}\) is the graph convolution weight. It is noted that here we perform a slicing operation \(E^{In}\) = \(E^{In}[|P|\ :]\) to select the node embedding representing the POI of \(}^{In}\). Beyond merely focusing on direct interactions between users and POIs, we further extend our exploration to utilize all users' check-in data to uncover global mobility patterns among POIs. We build a user-independent directed Global Transition Graph \(^{Tr}=(^{Tr},^{Tr})\), where \(^{Tr}^{|P| d_{p}}\) and \(^{Tr}^{|P||P|}\). Here, \(^{Tr}\) is equal to \(E^{P}\), and \(^{Tr}\) stores the visit frequency between two different POIs. It is important to note that we do not perform a denoising process on the \(^{Tr}\), as it accurately reflects the mobility patterns of all users, containing a wealth of global transition information. Similarly, we employ GCN refer to Equation (8) to learn the node embedding \(E^{Tr}\) of the \(^{Tr}\). Finally, we perform mean pooling to combine the two node embeddings \(E^{In}\) and \(E^{Tr}\), which yields the denoised POI embedding \(^{P}\)= \((E^{In}+E^{Tr})\) that incorporate comprehensive user mobility patterns from interaction and transition graphs. To introduce denoised embedding in our model, we refine our input embedding sequence \(X\) construction process as \(X=[(_{p_{1}}^{P},_{p_{2}}^{P},...,_{p_{n}}^{P})||(E_{t_{1}}^{T},E_{t_{2}}^{T},...,E_{t_{n}}^{T})]\).

### Long-Tailed Loss Adjustment

**Logit Score Adjustment.** Traditional classification models often mechanically employ the softmax function for outputting predictions, which may lead to an oversight of the potential discrepancies in the posterior distributions between training and testing data. To improve model discrimination, logit adjustment has been explored, which originates in the domain of face recognition [28; 52], It involves modifying the model's output layer (i.e., logits) to encourage the generation of more compact intra-class representations while increasing the distance between classes, thereby augmenting the model's capability to handle long-tailed data.

To address the long-tail problem in human next POI prediction tasks, we propose the Logit Score Adjustment module. It adjusts the logits by a factor that is inversely correlated with the frequencyof occurrence of each label, effectively dampening the influence of frequently occurring labels and amplifying that of rarer ones. The adjustment factor \(_{i}\) for label \(i\) with frequency \(freq\) is given by:

\[_{i}=[1-+)}{(freq_{max}+) }],\] (9)

where \(freq_{max}\) is the maximum label frequency observed in the dataset, \(\) is the logit adjustment weight and \(\) is a small constant to stabilize the logarithm operation. We can adjust final logits \(_{i}^{1}\) based on the logits \(l_{i}^{1}\) as \(_{i}=l_{i}+_{i}\).

**Sample Weight Adjustment.** Based on the Equation (5), for the standard cross-entropy loss, we can find due to the nature of the softmax function, which normalizes the logits \(l_{i}^{k}\) into probabilities, the model can become biased toward head classes. This imbalance means that the model's updates are predominantly driven by the head classes, as the loss from incorrectly classified examples in long-tailed classes contributes insignificantly to the overall loss. Even marginal improvements in the predictions for these long-tailed classes may contribute insignificantly to the overall loss. Therefore, it is necessary to reweight long-tailed samples, like with Focal Loss , which reduces the weights of well-classified samples to better focus on minority classes, but it does not explicitly consider the imbalance degree between classes in the long-tailed distribution. Unlike Focal Loss, we propose a novel Long-Tail Adjusted (LTA) loss to adaptively re-weight long-tailed samples. Specifically, for the final prediction layer, we have the hidden inputs of \(N\) samples \(\) = \((o^{1},o^{2},...,o^{N})\) and the weights \(W\) = \((w^{1},w^{2},...,w^{|P|})\) for \(|P|\) candidates, where \(o^{k}^{(d_{u}+d_{p})}\) is from the \(k\)-th sample. The true class label for the \(k\)-th sample is denoted by \(y_{k}\). We can take \(w^{y_{k}}^{(d_{u}+d_{p})}\) as the class "center" for the class to which the \(k\)-th sample truly belongs. Then we assess the impact posed by the \(k\)-th sample to the overall prediction through the cosine similarity between \(o^{k}\) and \(w^{y_{k}}\) as follows:

\[cos(o^{k},w^{y_{k}})= w^{y_{k}}}{\|o^{k}\|\|w^{y_{k}}\|}.\] (10)

Based on these cosine similarities, we compute the adjusted vector magnitude \(^{k}\) for each sample as:

\[^{k}=1,&cos(o^{k},w^{y_{k}})>0,\\ 1-cos(o^{k},w^{y_{k}}),&cos(o^{k},w^{y_{k}}) 0.\] (11)

Then we determine the geometric mean of the vector magnitude to serve as a baseline magnitude \(\). The traditional definition of the geometric mean of the vector magnitudes is the \(N\)-th root of their product \(=[N]{^{1}^{2}^{N}}\). However, it can be problematic in practice due to numerical underflow or overflow when dealing with very small or very large values. To mitigate this issue, we utilize logarithm to turn the product into a sum, making the calculation more numerically stable, as follows:

\[=(_{k=1}^{N}(^{k}+)).\] (12)

We calculate adaptive weights \(^{k}\) for each sample using the deviation of vector magnitude from the geometric mean:

\[^{k}=1,&^{k}- 0,\\ 1+^{k}-,&^{k}->0.\] (13)

:Finally, the overall Long-Tail Adjusted loss \(_{LTA}\) can be formulated as:

\[_{LTA}=-_{k=1}^{N}^{k}_{i=1}^{|P|}y_{i}^{k} (_{i}^{k})}{_{j=1}^{|P|}(_{j}^{k})}).\] (14)

By combining the Logit Score Adjustment and the Sample Weight Adjustment, we present a nuanced approach to recalibrating the model's focus across the spectrum of label frequencies. It ensures that each sample contributes to the model's learning process in proportion to its significance, as dictated by the distributional characteristics of the dataset and the discriminative capacity of the model.

### Model Optimization

Building upon our Long-Tailed Loss Adjustment module, we further embrace auxiliary prediction tasks to optimize LoTNext. To incorporate these tasks, we define a joint loss function that combines three distinct loss components: the standard cross-entropy loss (\(_{CE}\)), the Long-Tail Adjusted Loss (\(_{LTA}\)), and the Mean Squared Error loss for auxiliary time prediction (\(_{Aux}\)). Each component serves a critical role: \(_{CE}\) ensures the fidelity of the next POI prediction, \(_{LTA}\) addresses the long-tailed data imbalance through adaptive weighting, and \(_{Aux}\) measures the accuracy of the timing predictions, an auxiliary task that supports the model by providing it with temporal context, thereby improving prediction accuracy and robustness, which can be denoted as:

\[_{Aux}=_{k=1}^{N}||^{k}-t^{k}||^{2},\] (15)

where \(^{k}\) is the forecasted time slot of \(k\)-th candidate POI and \(t^{k}\) is the ground truth time slot. The overall loss function is constructed as a weighted sum of these components, with the weights \(\) being learnable parameters, as follows:

\[_{Joint}=_{1}_{CE}+_{2}_{LTA}+ _{3}_{Aux}.\] (16)

## 5 Experiments

**Datasets & Baselines.** We evaluate our LoTNext on two publicly available real-world LBSN datasets: Gowalla and Foursquare2 Each user check-in record includes the User ID, POI ID, latitude, longitude, and timestamp. To focus solely on the impact of long-tailed POIs and ensure the dataset's quality, we filter out inactive users with fewer than 100 check-ins. We then split each user's check-in records according to temporal order, using the first 80% for training and the remaining 20% for testing. To batch training, we uniformly segment the length of each input trajectory (e.g., 20). The specific statistical results are shown in Table 1, where we additionally calculated the percentage of POIs with a frequency smaller than 200 times and smaller than 100 times out of the total number of POIs. For instance, defining long-tailed POIs as those with a frequency of less than 100 times, approximately 98.38% of POIs could be considered long-tailed POIs. Considering both Table 1 and Table 2, the reason why the model performs about 20% points better on Foursquare compared to Gowalla is due to the more severe long-tail effect on the Gowalla dataset, along with a sparser density of the dataset.

To demonstrate the performance of the LoTNext, we implement the following 10 state-of-the-art methods as the comparison baselines:

* **ST-RNN** extends the RNN by introducing the spatial and temporal transition matrices.
* **DeepMove** considers long-term and short-term interests of users by attention mechanism.
* **LBSN2Vec** introduces the hypergraph and calculates the similarity of users and time embeddings to rank POIs.
* **LightGCN** simplifies the structure of Graph Convolutional Network (GCN) to learn user preferences for POIs.

  
**Dataset** & **Gowalla** & **Foursquare** \\  Duration & 2009.02-2010.10 & 2012.04-2014.01 \\ \#Users & 7,768 & 45,343 \\ \#POIs & 106,994 & 68,879 \\ \#Check-ins & 1,823,598 & 9,361,228 \\ \#Trajectories & 84,357 & 429,071 \\  Density & 0.002194 & 0.002997 \\ POI frequency 200 (\%) & 99.57\% & 89.26\% \\ POI frequency 100 (\%) & 98.38\% & 63.70\% \\   

Table 1: Basic dataset statistics.

* **LSTPM** proposes geo-nonlocal LSTM to further extend DeepMove structure.
* **Flashback** searches the most similar hidden states in historical information based on the current context information and updates the model.
* **STAN** explores the influence between non-adjacent check-in records in trajectory sequences through the attention mechanism.
* **GETNext** introduces the global mobility patterns of all users into the Transformer architecture to improve model prediction effects.
* **Graph-Flashback** combines Spatial-Temporal Knowledge Graph with the sequential model to enrich the representation of each POI.
* **SNPM** learns the general characteristics of POIs by constructing a POI similarity graph and aggregating similar POIs.

**Metrics.** To evaluate the model performance, we utilize two of the most common metrics for the next POI prediction: Accuracy@k (Acc@k) and Mean Reciprocal Rank (MRR). Acc@k effectively measures whether the true label is present within the top-k predicted results. Here, we consider k=1, 5, and 10 to comprehensively assess the model's performance. MRR directly quantifies the average rank of the correct label among all predictions when the correct label is not within the top-k predictions, with higher values indicating better average prediction performance by the model.

**Settings.** We implement LoTNext using PyTorch 1.13.1 on a Linux server equipped with 384GB RAM, 10-core Intel(R) Xeon(R) Silver 4210R CPU @ 2.40GHz, and Nvidia RTX 3090 GPUs. The embedding dimensions for POIs and users are set to 10, and the time embedding dimension is set to 6. For the Transformer architecture, we incorporate two multi-head attention mechanisms and 2 encoder blocks. For the spatial decay rate \(\), we follow the settings of Flashback .

**Overall Performance.** Table 2 shows the predictive performance of all baseline methods and LoTNext on two datasets. Based on Table 2, we can draw the following conclusions:

* On both public datasets, LoTNext outperforms all other state-of-the-art baseline methods across all metrics. Compared to the most recent and best-performing baseline method, SNPM, LoTNext achieves more significant improvements in Acc@1. These results indicate that LoTNext is better at predicting long-tailed POIs that are less popular but highly relevant to specific users.
* Utilizing graphs to model all user mobility patterns, thereby improving POI embeddings, representing as SNPM, Graph-Flashback, and GETNext, significantly outperform sequential methods represented by LSTPM and DeepMove, which rely solely on an individual user's short-term and long-term interests to predict the user's next location. However, the raw User-POI Interaction Graph has a large number of long-tailed nodes with a degree of 1 or very small. LoTNext, through its long-tailed graph adjustment module, effectively filters these long-tailed nodes, thereby enhancing the model's predictive performance.

**Performance on Long-Tailed Samples.** To evaluate whether our model achieves accuracy improvement on long-tailed samples, we define samples with a frequency less than 100 on Gowalla dataset

    &  &  \\   & Acc@1 & Acc@5 & Acc@10 & MRR & Acc@1 & Acc@5 & Acc@10 & MRR \\  ST-RNN  & 0.0900 & 0.2120 & 0.2730 & 0.1508 & 0.2290 & 0.4310 & 0.5050 & 0.3248 \\ DeepMove  & 0.0625 & 0.1304 & 0.1594 & 0.0982 & 0.2400 & 0.4319 & 0.4742 & 0.3270 \\ LBSN2Vec  & 0.0864 & 0.1186 & 0.1390 & 0.1032 & 0.2190 & 0.3955 & 0.4621 & 0.2781 \\ LightGCN  & 0.0428 & 0.1439 & 0.2115 & 0.1224 & 0.0540 & 0.1790 & 0.2710 & 0.1574 \\ LSTPM  & 0.0721 & 0.1843 & 0.2327 & 0.1306 & 0.2484 & 0.4489 & 0.5018 & 0.3365 \\ Flashback  & 0.1158 & 0.2754 & 0.3479 & 0.1925 & 0.2496 & 0.5399 & 0.6326 & 0.3805 \\ STAN  & 0.0891 & 0.2096 & 0.2763 & 0.1523 & 0.2265 & 0.4515 & 0.5310 & 0.3420 \\ GETNext  & 0.1419 & 0.3270 & 0.4081 & 0.2294 & 0.2646 & 0.5640 & 0.6431 & 0.3988 \\ Graph-Flashback  & 0.1495 & 0.3399 & 0.4242 & 0.2401 & 0.2786 & 0.5733 & 0.6501 & 0.4109 \\ SNPM  & 0.1593 & 0.3514 & 0.4346 & 0.2505 & 0.2899 & 0.5967 & 0.6763 & 0.4278 \\ 
**LoTNext (Ours)** & **0.1668** & **0.3605** & **0.4429** & **0.2591** & **0.3155** & **0.6059** & **0.6812** & **0.4469** \\   

Table 2: Acc@k and MRR performance comparison on Gowalla and Foursquare datasets.

as long-tailed samples to test the model's specific predictive performance on both long-tailed and head samples. We compare LoTNext with Graph-Flashback which provides the pre-trained model for ease of comparison. As shown in Figure 3(a) and Figure 3(b), LoTNext consistently outperforms Graph-Flashback on both Acc@1 and MRR metrics, whether for head or long-tailed samples. Furthermore, Figure 3(c) reveals a notable distinction in the prediction of long-tailed POIs, LoTNext exhibits a roughly 6% higher propensity to predict long-tailed POIs compared to Graph-Flashback. This increment not only underscores the enhanced capacity of LoTNext to identify and anticipate long-tailed POIs but also demonstrates the efficacy of our methodology.

**Ablation Study.** To analyze the impact of different modules on LoTNext, we conducted the following ablation settings: (1) without the Long-Tailed Graph Adjustment module (w/o LTGA), where we conducted with the raw graph without graph adjustment. (2) without the Long-Tailed Loss Adjustment module (w/o LTLA), meaning we only used the original cross-entropy loss for testing. (3) without the original cross-entropy loss (w/o \(_{CE}\)), meaning we only use Long-Tailed Loss Adjustment module (\(_{LTA}\) loss). (4) without the auxiliary prediction task module, we utilized the LTLA module and cross-entropy loss function, removing the auxiliary time prediction task, denoted as w/o \(_{ ux}\).

From Table 3, we have the following findings: (1) The embeddings obtained after the LTGA module contribute to the model's predictive performance. This is mainly because long-tailed POIs can be considered noise to some extent, and appropriately eliminating some noise helps with model prediction. (2) Utilizing only the original cross-entropy loss results in performance below SNPM, indicating that the strategy of considering the long-tailed distribution through the LTLA module is effective for improving model accuracy in identifying the most relevant items. (3) The results using only the \(_{LTA}\) loss show slightly higher metrics than results w/o LTLA, which suggests that the model may over-focus on long-tail data, leading to a decline in the recommendation performance for head data. For this reason, we consider incorporating the \(_{CE}\) to balance the recommendation performance between long-tail data and head data. (4) Without the time prediction task, we observe a decline in the MRR metric, suggesting that temporal features play a crucial role in helping the model capture the dynamic changes in user behavior.

**Case Study: Learned POI Embedding.** Figure 4 presents t-SNE visualizations of the embeddings for the four least frequently occurring POIs on Gowalla dataset. In Figure 4(b) representing LoTNext the embeddings of these low-frequency POIs are more distinct and well-separated, indicating that LoTNext effectively captures the unique characteristics of these tail POIs. This clear separation demonstrates that LoTNext can learn meaningful representations even for the least frequent POIs, which is crucial for accurate prediction and recommendation. In contrast, Figure 4(a) showing Graph-Flashback's performance, reveals more overlapping and less distinct clusters for these low-frequency

    &  &  \\   & Acc@1 & Acc@5 & Acc@10 & MRR & Acc@1 & Acc@5 & Acc@10 & MRR \\  w/o LTGA & 0.1617 & 0.3568 & 0.4419 & 0.2550 & 0.3020 & 0.6002 & 0.6783 & 0.4368 \\ w/o LTLA & 0.1544 & 0.3439 & 0.4266 & 0.2450 & 0.3014 & 0.5985 & 0.6758 & 0.4362 \\ w/o \(_{CE}\) & 0.1550 & 0.3455 & 0.4287 & 0.2462 & 0.3029 & 0.5989 & 0.6771 & 0.4365 \\ w/o \(_{Aux}\) & 0.1609 & 0.3567 & 0.4344 & 0.2523 & 0.3039 & 0.5993 & 0.6769 & 0.4370 \\ 
**LoTNext** & **0.1668** & **0.3605** & **0.4429** & **0.2591** & **0.3155** & **0.6059** & **0.6812** & **0.4469** \\   

Table 3: The performance comparison among the LoTNext and variants without some components.

Figure 3: The performance comparison of the long-tailed and head POIs between LoTNext and Graph-Flashback on Gowalla dataset.

POIs. This overlap suggests that Graph-Flashback struggles to differentiate between the tail POIs, potentially leading to less accurate predictions for these rarely visited locations.

**Case Study: Prediction on Long-Tailed Sample.** Figure 5 provides a visual comparison of sample predictions made by the Graph-Flashback and LoTNext models on a trajectory from the Gowalla dataset for user 5. Each POI in the user's trajectory is identified by a unique ID and its visitation frequency, where the number in parentheses represents the frequency of visits. In this specific trajectory, user 5 visits a sequence of POIs. For the given POI 934, LoTNext accurately predicts the next POI to be 933, a long-tail POI with a visitation frequency of 94. In contrast, the Graph-Flashback model incorrectly predicts the next POI to be 61, a head POI with an extremely high visitation frequency of 2023. This is the same sample as the problem shown in Figure 1, demonstrating the efficacy of LoTNext in capturing the user's actual movement pattern, which encompasses both frequently and infrequently visited POIs.

## 6 Conclusion

In this work, we propose LoTNext, a novel framework for human next POI prediction under long-tailed data distribution. Specifically, we employ a Long-Tailed Graph Adjustment module to mitigate the impact of long-tailed nodes within the User-POI Interaction Graph. Additionally, to balance the influence of long-tailed data in the loss, we propose the Long-Tailed Loss Adjustment module to adjust the model's predicted logits and adaptively increase the weight of long-tailed samples. Moreover, we leverage the auxiliary prediction task to achieve spatial and temporal prediction synergy. Through comparisons with 10 state-of-the-art methods, we demonstrate the superiority of LoTNext over the most advanced approaches. A limitation of our approach lies in that LoTNext's reliance on extensive user trajectory data poses a potential risk for privacy breaches if deployed by certain institutions or companies, which could lead to negative social impacts. We plan to address it in future work.