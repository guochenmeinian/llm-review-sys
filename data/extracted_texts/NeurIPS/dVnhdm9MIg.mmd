# Human-like Few-Shot Learning via

Bayesian Reasoning over Natural Language

 Kevin Ellis

Cornell University

kellis@cornell.edu

###### Abstract

A core tension in models of concept learning is that the model must carefully balance the tractability of inference against the expressivity of the hypothesis class. Humans, however, can efficiently learn a broad range of concepts. We introduce a model of inductive learning that seeks to be human-like in that sense. It implements a Bayesian reasoning process where a language model first proposes candidate hypotheses expressed in natural language, which are then re-weighed by a prior and a likelihood. By estimating the prior from human data, we can predict human judgments on learning problems involving numbers and sets, spanning concepts that are generative, discriminative, propositional, and higher-order.

## 1 Introduction

Human learning is rapid and broad. Consider a child learning a new routine like 'high-five': given just 1 or 2 examples, they can learn that move, and even generalize to variations like low-fives. Or consider learning the basics of a game like Pacman, or an AI researcher learning a new technique like 'few-shot prompting', or a mathematician extrapolating '1, 4, 16, 64,...'. In each of these cases, the relevant routine, rules, or concept can be learned from little data and only seconds to minutes of experience. Furthermore, the space of possible concepts is effectively infinite, because concepts can compose to yield more complex constructs like 'high-five followed by a fist bump'. Thus a key computational challenge is to understand how an intelligent system can acquire a wide range of new concepts, given modest data, and granted a modest computational budget. Building AI systems that can efficiently master many concepts is also practically valuable, because data-efficiency and broad generalization remain some of the most salient gaps between human and machine intelligence .

Fundamentally, we are concerned with the problem of _induction_: Inferring a generalizable pattern, rule, trend, or law from specific examples. A classic approach to induction is to start with a hypothesis space of possible concepts, and then probabilistically infer which hypothesis most likely generated the observed data using Bayes' Rule. This Bayesian paradigm has proved widely applicable across both cognitive science and artificial intelligence .

On its own, however, the Bayesian paradigm leaves important questions unanswered. Acquiring a broad range of possible concepts demands an expressive hypothesis space, but inference over a rich space of concepts comes at steep computational cost. For increased expressivity, many Bayesian models design hypothesis spaces that resemble a programming language . Posterior inference then corresponds to constructing high-probability programs. Each of these program-learning models requires a custom domain-specific programming language. Despite confining themselves to a domain-specific language, these models still require specialized inference machinery, such as heuristically-designed search moves , or exorbitant compute budgets .

Our goal is to build a model of humanlike concept learning that makes progress toward resolving the tension between intractable inference and expressive hypothesis classes. We propose a new modelthat expresses its concepts in natural language-even when the learning problem does not involve natural language. We do this for two reasons. First, language is an effective representation for many human concepts. It is compositional, richly expressive, and regularizes the learner toward natural generalizations. Second, we find we can efficiently infer natural language concepts using modern large language models [22; 23] based on the transformer architecture .

Like any Bayesian model, we will first define a prior over concepts, which in our case exerts a top-down pressure for naturally-structured language. Our model also has a bottom-up mechanism for efficiently inferring possible hypotheses, analogous to a recognition network . The interaction of these top-down and bottom-up models is surprisingly effective as a model of humanlike learning: Given around 50 samples from the recognition network, our model can account for human patterns of generalization for concepts that are generative or discriminative, and propositional or first-order. We show the model can also capture fine-grained structure in human judgements: both subtle gradations of uncertainty, and also the dynamics of learning starting from a few examples and going to dozens of examples. Finally, a key reason why humans can learn so efficiently is because they have a good inductive bias or prior [26; 27]. Our model can fine-tune its prior to human judgements, effectively extracting a human-like prior from behavioral data. We find this gives a more faithful model of human generalization, and also improves average accuracy on concept-learning tasks.

We focus on abstract symbolic concepts, such as 'prime numbers less than 30', which we think are well-suited to natural language. We do not consider concepts grounded in perception and actuation, such as 'dog' or 'chewing', and hence do not provide a single unified account of inductive learning.

However, for these abstract concepts, we provide a _rational process model_. Following the Marr levels of analysis , this means we propose algorithmic mechanisms for concept learning that rationally approximate optimal inference, subject to bounds on computation (sampling). This contrasts with _computational-level models_, which characterize the goal of the learner, without committing to a theory of how the learner mechanistically accomplishes that goal . Most Bayesian concept learning models operate at the computational level, avoiding issues of intractability [3; 15] (cf. ).

We contribute (1) a model of symbolic concept learning that supports efficient inference over a flexible hypothesis class; (2) an evaluation on human data from two different concept learning experiments; and (3) a simple recipe for extracting a humanlike prior over concepts, given raw behavioral data.

## 2 Background and Related Work

**Bayesian Program Learning** (BPL: ) models concept learning as Bayesian inference over latent symbolic programs. BPL models first define a domain-specific programming language spanning a space of possible concepts, and then infer a posterior over concepts \(C\) given training data \(D\) via Bayes' Rule: \(p(C|D) p(D|C)p(C)\). Although the set of possible concepts remains hardcoded, the prior \(p(C)\) can be learned through hierarchical Bayesian methods. Given parameters \(\) indexing possible priors, and a collection of datasets \(\), the prior can be learned by approximately solving :

\[^{*}=*{arg\,max}_{}p(|)= *{arg\,max}_{}p()_{D}_{C}p(D| C)p_{}(C)\]

Bayesian models can learn from few examples, because the prior regularizes them toward reasonable generalizations. They also produce nuanced uncertainty estimates, because they represent the posterior. Program learners can also acquire any concept expressible in their domain-specific language, but this language must be appropriately circumscribed for inference to remain tractable. Systems such as DreamCoder  partly address this concern by growing the language and training neural networks to aid inference, but even then, general-purpose programming languages remain out of scope. We next turn to latent language, which considers the broad hypothesis space of all natural language.

**Latent Language.** Using language as an internal representation for nonlinguistic tasks was introduced by the Latent Language framework [31; 32]. These systems perform few-shot learning by searching for the language which minimizes a loss on the training examples. Given training input-output examples \(\{(x,y)\}\), the latent language approach infers the language \(C^{*}\) minimizing

\[C^{*}=*{arg\,min}_{C^{*}}_{(x,y)}(y,f_{ }(x;C))\]

where \(f_{}\) is a neural network and \(^{*}\) is the set of all strings. Because there are infinitely many strings, another neural network samples a finite pool of candidate concepts. Relative to Bayesian learners,

[MISSING_PAGE_FAIL:3]

**Comparing hypotheses to data.** The likelihood \(p(X|C)\) and the prediction \([X C]\) both require comparing natural language \(C\) against a nonlinguistic datum \(X\). For the domains we consider it is convenient to implement this comparison by translating the concept \(C\) into Python using an LLM--which we do deterministically, via greedy decoding--and then execute the Python program on \(X\), similar to . We do not view this latent program as essential to the general framework: Alternatively, another neural network could serve to link \(X\) to \(C\), which would allow fuzzier comparisons between hypotheses and data. Fig. 1 diagrams these details as a Bayesian network.

## 4 The Number Game

The Number Game is a few-shot concept learning setup covered by classic textbooks and dissertations . Participants playing The Number Game are given a few example numbers belonging to a hidden concept, and then rate how likely it is that other numbers also belong to the same concept. Given just the example number _16_, the concept could be'square numbers', 'powers of two', 'evens', 'odds but also 16', '97 and 16', 'numbers ending in 6', or infinitely many other concepts. With more examples such as _16, 8, 2, 64_, humans consistently rate powers of two as almost certainly in the concept, but gradations of uncertainty remain: other evens like 24 could plausibly belong in the concept, but humans rate odds like 23 as extremely unlikely. Examining human judgments for these and other concepts reveal a variety of belief states, including sharp, all-or-none concepts like 'powers of two,' but also soft graded concepts like 'numbers around 20' (Fig. 2, blue bars).

**Human Data.** We take human data from . Eight human participants rated test numbers on a scale of 1-7, given different training sets of example numbers. We model the average human rating for each test number, on each training set of example numbers.

Figure 1: Model as Bayesian network. The program is a deterministic function of \(C\).

Figure 2: Number Game human judgments (blue bars) for different example data. For instance, the top plot shows that after seeing that _16_ belongs to the concept, humans rate _64_ as around 50% likely to belong to that same concept. Bars at zero correspond to missing data. Orange curves show our model’s predictions. The text to the right of each plot shows 5 samples from our model’s approximate posterior after proposing 100 concepts using \(q\). Human data from . See also Appendix Fig. 7

**Prior.** We consider two different prior distributions. The **pretrained prior** scores the log likelihood of each concept \(C\) using an open source language model, specifically, CodeGen 350M . The **tuned prior** first extracts features of \(C\) using a pretrained sentence feature extractor \(\), specifically all-MiniLM-L6 , which outputs a 384-dimensional feature vector. The tuned prior maps those features to an unnormalized log probability via a linear layer with parameters \(\):

\[ p_{}(C)((C ))\] (6)

**Likelihood.** Evaluating \(p(X|C)\) requires first determining which numbers belong to the concept \(C\). To efficiently enumerate those numbers, we translate \(C\) from natural language to Python using Codex code-davinci-002 , a language model trained on source code. We run the Python code on the numbers 1..100 to determine the members of \(C\). Given the members of \(C\), we assume numbers are sampled uniformly from \(C\) with probability \((1-)\), and otherwise sampled uniformly from 1..100:

\[p(X|C)=(1-)[X C]}{|C|}+ {100}\] (7)

**Parameter fitting.** We want a single parameter setting that works for _all_ of the training example sets, so we fit the above parameters to the average human judgment for each test number, and for each set of examples. When comparing model predictions against the average human judgment on a particular test number, we always holdout that particular human data from the parameter fitting. We use Adam  to perform maximum likelihood estimation of the parameters, following Eq. 5.

**Temperature, Platt transform.** Because human subjects rated on a scale of 1-7, we introduce a learnable Platt transform between the model's predicted probabilities and the human judgments . We also place a learnable temperature parameter on the posterior.

**Proposal distribution.** We implement \(q\) using Codex code-davinci-002 . We prompt Codex by adapting the cover story given to the human subjects, then append the training example numbers \(X_{1:K}\) and have it complete the natural language description of the hidden concept.

**Alternative models.** We compare against GPT-4 to understand the few-shot learning abilities of a bleeding-edge large language model. Prompted with example numbers belonging to a concept, together with a test number, we measure the probability that GPT-4 responds "yes" to the test number belonging to the concept, vs responding "no". We fit a Platt transform to those probabilities. We also compare against DreamCoder , a recent Bayesian Program Learning system. Starting with a Number Game DSL, DreamCoder learns a prior and trains a neural proposal distribution. DreamCoder considers \(10^{4}\) hypotheses at test time--two orders of magnitude more than our model--and trains its neural network on \(10^{5}\) synthetic number concepts ("dreams"). We further contrast against Latent Language , using the same Codex-based proposal and likelihood distributions, and the same learnable Platt transform. Finally, we consider versions of our model that encode hypotheses in Python instead of natural language ('code prior'), as well as a version of our model that ablates the proposal distribution by generating concepts unconditioned on \(X_{1:K}\) ('no proposal dist.').

**Results.** Fig. 3 shows that an out-of-the-box pretrained natural language prior offers a decent fit to the human data after proposing 50-100 hypotheses. Our tuned prior achieves a very close fit to the human data, again using 50-100 samples. Switching from English to Python significantly degrades model fit, even when the Python prior is learned ('tuned code prior'). Ablating the proposal distribution-sampling hypotheses from the prior-also provides a poor fit: the space of possible number hypotheses is too vast to be randomly guessed without looking at the data.

These results establish that a language-generating proposal distribution can support efficient inference, and accurately model the average of a small pool of human participants. Recall that we are modeling the average of 8 human judgements, and a good fit to this average requires 50-100 samples. Therefore, our model suggests that each human might only need to draw a couple dozen samples, which we think is psychologically plausible (and practical, from an engineering perspective). In contrast, the original Number Game model considered over 5000 hypotheses , and a typical BPL system such as DreamCoder still lags our model, even when it considers orders of magnitude more hypotheses.

Last, GPT-4's judgments are decidedly different from humans. This does not mean that GPT-4 is wrong in its predictions: there is no ground-truth for whether the number 30 should belong to the same concept as the number 60. To better understand how humans and models stack up against each other, we next consider a richer domain where accuracy can be more objectively measured.

## 5 Logical Concepts

We next consider concepts with more complex logical structure. Consider a concept such as _bachelor_, defined as "unmarried man", or _Valedictorian_, defined as "the person, within a single school, with the highest GPA". Using the primitives of propositional logic, we can define _bachelor_: (Male\(\)-Married). Using the more expressive language of first-order logic, which includes quantifiers, we can define _valedictorian_ as \((x)( y:(x)=(y) (x)(y))\). Discovering the discrete logical structure that best explains a dataset of examples is a well-known AI challenge [48; 49; 50]. Within the cognitive sciences, understanding how people come to grasp logical relations has been proposed to be a key component of understanding how people comprehend number systems, geometry, causal processes, social and kinship relations, and other domains [51; 52; 53; 54].

For our modeling, we consider an online learning setup from  where a learner observes a stream of examples of a unknown logical concept. On each example, the learner observes a fresh batch of 1-5 objects, and must pick out which objects belong to the hidden concept. The learner then gets feedback on which objects in the batch actually belonged to the concept, and then the process repeats for a new batch. Fig. 4 illustrates this experimental setup: each object is a shape defined by its size (small, medium, large), color (green, yellow, blue), and shape (triangle, rectangle, circle). Recording each human response to each shape on each batch gives a fine-grained learning curve capturing how learning unfolds over dozens of examples. These learning curves signal what concepts people readily learn, what patterns of mistakes they make, and what concepts remain essentially unlearnable from even dozens of examples. We obtain this human data from , which covers 112 concepts, collecting judgements from 1,596 human participants as they attempt to learn each concept over 25 batches of examples. These 25 batches corresponds to \( 75\) examples/concept, and each concept run on \( 20\) participants. Most human learning happens over the first dozen batches, so we take the first 15/25 batches, which conveniently also nearly halves the cost and time of running the model.

Figure 4: Concept learning experiment from  (illustration used with permission). On each batch, participants label which shapes they think belong to a new concept (called _wudsy_). Previous batches are shown with the ground truth positive examples surrounded by a square. From these examples, participants might infer a simple concept like “green triangles”, and select the second test object.

Figure 3: How well different models predict held-out human judgments (\(R^{2}\)), as a function of the sampling budget (left panel, X-axis, log scale). Error bars: \(\)SEM over 3 runs with different seeds. Variance across runs decreases with number of samples. See Appendix Fig. 8-9 for further results.

**Model.** Our modeling approach is similar to The Number Game, except we now have a discriminative learning problem instead of a generative one, and an online learning setup where the learner observes a stream of examples. To model online learning, we draw fresh proposals from \(q\) for each training batch, and perform Bayesian inference over all proposals drawn so far. To model discriminative learning, each example is now a triple \((B,T,Y)\), where \(B\) is a batch of shapes, \(T\) is a test shape in that batch, and \(Y\) is zero or one depending on whether \(T\) in \(B\) is an example of the concept.

Our likelihood model assumes human subjects predict according to \(C\) with probability \((1-)\) and otherwise predict randomly with a base rate \(\) of labeling an example as positive. Following  we model a memory decay process where the relative importance of earlier observations falls off according to a power law with parameter \(\):

\[p(Y=1|B,T,C) =(1-)[(B,T) C]+\] (8) \[ p(X_{1:K}|C) =_{(B_{k},T_{k},Y_{k}) X_{1:K}}(1+K-k)^{-} p(Y|B,T,C)\] (9)

As before, we translate hypotheses from natural language into Python using code-davinci-002, and evaluate the likelihood term above by running Python code. We consider both pretrained and tuned priors. Our proposal distribution \(q\) comes from running GPT-4 on prompts that illustrate previous batches, either as truth tables (for propositional concepts) or as a raw list of previous observed batches (for higher-order concepts). We again place a learnable temperature on the posterior.

**Bayesian Program Learning Baseline (BPL).** We contrast with a strong BPL baseline. It uses a grammar over expressions in first-order logic, plus predicates for shape, color, and size, totaling 28 primitives that were selected by the creator of the logical concept learning dataset (A.3.3). The BPL baseline uses the same memory-decay likelihood model, and fits (tunes) its prior by estimating probabilities for each logical primitive. It is implemented in Fleet , the state-of-the-art in fast parallelized MCMC over grammatically structured hypothesis spaces.

Our model differs in two important ways. First, the baseline is given first-order primitives that were chosen specifically for this dataset. While our model can use natural language expressing first-order concepts (e.g., _the only_ for \(\)), it can also express concepts like _objects with the least common color_ that are unrepresentable by the baseline, and which are not in the dataset.

The second difference is that our model supports efficient inference via bottom-up proposals, while this baseline performs a stochastic search over hypotheses (MCMC), requiring many more samples. It takes \(10^{6}\) Metropolis-Hastings proposals per batch, and per learning curve, totaling \( 10^{9}\) proposals, which are deduplicated to yield \( 45,000\) unique concepts, which provide the support of subsequent posterior inference. This means every BPL posterior is informed by the total \( 10^{9}\) sampling moves.

**Results.** Our model's predictions generally align well with human judgments (Fig. 5). Using 100 proposals per batch, our model explains 81% of the variance in human responses (\(R^{2}=.81\)), which is much higher than GPT-4 on its own. The model is also more accurate at the actual task than GPT-4, and within 3% of human-level (Fig. 6C). The model also fits the human data somewhat better than the BPL baseline, even when that baseline is granted an exorbitant sampling budget. Tuning the prior proves critical, possibly because these logical concepts are more complex than the earlier number concepts, and so can be expressed in a wider variety of syntactic forms. The pretrained model is highly sensitive to syntax and cannot learn to attend to semantic features, unlike the tuned model.

Figure 5: Model fits on holdout data. Error bars: \(\)SEM over 3 runs. (Error bars often close to zero)Although our model explains most of the variation in the human responses, nontrivial variation remains. One possible reason is that we are modeling the responses of many human subjects, and different subject groups per concept, so it is difficult to capture the full variability of the human responses: Building a model that accurately reflects the judgments of a population of humans may be much more difficult, and require a higher sampling budget, than building a model of a single person. The model also slightly underperforms humans, and so a higher fidelity model might come from simply performing the task better. (Although one can slightly surpass human accuracy by optimizing purely for task performance, doing so degrades model fit. See Fig. 6C, 'tune for accuracy'.) More fundamentally, the data come from many successive trials, so they likely contain memory and order effects such as garden-pathing  and anchoring  which are not well accounted for by the pure probabilistic inference our model approximates, nor by our simple memory decay model.

At the same time, our model does account for many fine-grained details in the behavioral data, including predicting specific patterns of successes and failures (Fig. 6A). Because our approach is manifestly interpretable--it explicitly verbalizes its hypotheses in human language--we can inspect its maximum a posteriori concept at the end of each learning episode, and observe that its successes typically occur because its verbalization of the concept describes the correct first-order law. Conversely, when humans make highly selective failures, we can probe the model to suggest what alternative hypotheses humans may have incorrectly inferred (Fig. 6A, top right).

Figure 6: **A.** Left and middle: learning concepts isomorphic to _bachelor_ and _valedictorian_. Dark ticks delimit batches. Above each plot is the ground-truth logical expression and the predicted natural language description. Right: the model can explain human mistakes by verbalizing what other concept humans might have been misled into learning. Both humans and the model seem to have learned _largest blue_ instead of _the largest and it also happens to be blue_. **B.** Further learning curves, including somewhat worse fits, and getting the right answer despite having a slightly odd solution (rightmost). **C.** The model is close to human performance after extracting a prior from human judgments. **D.** New concepts run on new participants. All results on holdout learning curves.

Modeling new concepts.To test the flexibility of our model, we created two new concepts for evaluating both the model and a new group of human participants. These two concepts were _shapes with the majority color_, and _shapes with the least common color_. 16 human subjects participated in an IRB-approved study (A.2). Our study finds that humans rapidly learn these concepts (Fig. 6D.)

We also test our model on these new concepts, but using the prior estimated earlier on the data in . Our model correctly predicts that humans will learn the concept of _majority color_ after just 2 batches of examples. It predicts learning _minority color_ after 4 batches, while humans need just 3, but the primary result--that this concept is very learnable--holds for both humans and the model.

Although these two new concepts are easy to explain in words, and could be expressed in first-order logic with the right primitives--set cardinality and quantification over colors--neither concepts are learnable by the BPL baseline. This is because both concepts are simply unrepresentable: despite being equipped with 28 primitives, those primitives were designed without anticipating these new concepts. This highlights the fact that it is difficult to preprogram a sufficiently broad set of primitives that can efficiently encode all the different concepts people might learn.

## 6 Discussion

Putting humanlike inductive biases into machines.Humans excel at rapidly mastering new tasks and understanding new concepts in part because they have a good inductive bias or prior [60; 61]. Imparting similar priors upon machines is therefore an important problem. Our work gives a recipe for training such a prior by fitting it directly to human judgments, marginalizing out the natural language, meaning we never need to elicit natural language from human subjects. Because our approach simply tunes a small network on top of a large open-source pretrained model, and because it can be fit to raw human judgments, we hope that it can serve as a broadly applicable engineering strategy for extracting and using human priors. Recent work has also explored complimentary strategies for instilling a humanlike prior upon a machine learning system. For example, Kumar et al. 2022  show that training neural networks with auxiliary linguistic tasks, and with auxiliary programming tasks, causes their representations to better align with human priors.

Bayesian Program Learning (BPL).Our model has similar motivations to BPL. Because we translate the natural language into Python to compute the likelihood, it is possible to see our approach as BPL with an unusual prior: \(p()=_{}p()p(|)\). In that sense, our work provides a new prior for BPL, together with the demonstration that it is possible and practical to do BPL over a Turing-complete language like Python. Relatedly, recent BPL modeling has found synergies between natural language and program representations for cognitive AI models [9; 62].

Beyond BPL, combining probabilistic reasoning with expressive symbolic representations has long been an appealing paradigm [63; 64; 65], although the expressivity of the symbolic language must be balanced against the tractability of inference [66; 67]. Guiding inference with a neural model is a natural choice, but this is hard because of the lack of natural training data (though synthetic data can help: [68; 69; 70]). Encoding knowledge in natural language allows pretrained neural models to guide inference, and it could be fruitful to examine statistical-relational AI  in light of that fact.

Large Language Models.Our work suggests that an out-of-the-box large language model is not an effective approach to inductive reasoning, at least on its own. Bayesian mechanics are needed to dampen the unpredictability of the language model. To the extent that being Bayesian is a normative account of rational behavior, our work offers a framework for enabling language models to draw more rational inferences, and ultimately generalize in more predictable and human-like ways by tuning their prior beliefs to match human data.

The Language of Thought.Our work connects to the Language of Thought Hypothesis , which says that human learning and thinking relies on an inner symbolic language. This has been a productive framework for computational modeling [15; 16; 18; 73]. In its most literal forms, language-of-thought models are afflicted by the _curse of a compositional mind_ (Spelke 2022 ): the free-form recombination of concepts yields a combinatorial explosion, which here we address by using pretrained knowledge from language to guide the learner. Whatever the true Language of Thought looks like, however, it must have a wide array of composable basic concepts in order to explain the breadth, flexibility, and generality of human thinking. Natural language, even if it is not actually the same as our inner mental language, acts as a vast reservoir of human concepts,and provides a flexible algebra for combining them. Therefore a reasonable near-term strategy for modeling human thinking may be to use natural language as a heuristic approximation to an inner Language of Thought, despite strong evidence that human thinking need not engage language-processing brain regions .

**Rational Process Modeling.** As a rational process model, our account of concept learning bridges the computational and algorithmic levels of the Marr hierarchy : We commit to a Bayesian computational-level theory, and a particular Monte Carlo algorithm as a rational approximation to that theory. One important sense in which our account is inadequate is that we do not actually explain how the bottom-up process works, or how it came to be learned. We merely require that it is stochastic and unreliable, but occasionally correct enough to not need many millions of proposals. Given those requirements, a modern large language model is a reasonable surrogate for this bottom-up process, even if it its inner workings might differ greatly from human bottom-up proposal processes.

**Generalizability of the theoretical framework.** The basics of the model make few commitments, yet instantiating it requires selecting specific language models, engineering prompts and likelihoods, etc. More broadly, a high-resolution cognitive model, particularly a structured Bayesian one, requires domain-specific modeling choices. How much credit should we assign to the general theoretical framing, as opposed to particular engineering decisions? Although our paradigm introduces new degrees of freedom, such as which LLMs/prompts to use, it removes others, such as the grammatical structure of the symbolic hypothesis space. On balance, we are cautiously optimistic that the framework will generalize with less domain-specific tinkering, at least for abstract symbolic domains, because it replaces hand-designed symbolic hypothesis spaces with pretrained neural models, and because reasonable "default" neural networks worked well across our experiments.

**Inference, Natural Language, and Recursive Reasoning.** There is a rich literature on natural language and probabilistic inference from a social or communicative perspective, such as modeling pragmatic inference . These models often use a recursive reasoning formulation where each agent represents the beliefs of other agents, including beliefs about themselves, and so on, recursively. Our work does not consider the communicative function of natural language, and so does not engage with these issues. However, models of pedagogical inductive learning--where a helpful teacher selects the training examples--benefit from similar forms of recursive reasoning, because the teacher and learner must reason about each other's beliefs . These insights could be important for building versions of our model that might simulate aspects of how humans learn from each other.

**Limitations.** Our model performs induction via discrete structure learning. Given the combinatorial difficulty of structure learning, it is unclear whether our approach can scale to inferring complex systems of symbolic rules. We believe recent work on iteratively refining language model outputs may be promising here . The present form of our model is also limited to processing discrete symbolic input-outputs. Actual human thinking connects with the messy perceptual world. It would be valuable to understand whether this limitation can be addressed using multimodal language models , or approaches that interface separate language and vision modules . It is worth noting that BPL models can straightforwardly interoperate with perceptional data , and that many outstanding challenge problems within AI have at their core a perceptual-reasoning process, such as Bongard problems  and the Abstraction and Reasoning Corpus .

Currently, the model relies on costly, energy-intensive models for its proposal distribution, a constraint that might be mitigated by open-source models and network compression .

Last, a strong justification for formal representations is that they allow specifying knowledge precisely and unambiguously . Natural language is usually imprecise and ambiguous, which we deferred addressing by translating language into Python. It remains to be seen whether language models can be coaxed into producing sufficiently precise language to support representing knowledge solely in natural language, or if refinement into precise languages like Python offers the better scaling route.

**Code and data available at:** https://github.com/ellisk42/humanlike_fewshot_learning

**Acknowledgements.** We are grateful to Steven Piantadosi for providing the raw human data and Fleet results for the logical concepts, as well as Joshua Tenenbaum for providing his Number Game data, and Mathias Sable-Meyer for comments on the manuscript and work.