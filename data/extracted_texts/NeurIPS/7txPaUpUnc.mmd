# Identifying Functionally Important Features with End-to-End Sparse Dictionary Learning

Dan Braun

Apollo Research

Jordan Taylor

ML Alignment & Theory Scholars (MATS), University of Queensland

Nicholas Goldowsky-Dill

Lee Sharkey

Apollo Research

###### Abstract

Identifying the features learned by neural networks is a core challenge in mechanistic interpretability. Sparse autoencoders (SAEs), which learn a sparse, overcomplete dictionary that reconstructs a network's internal activations, have been used to identify these features. However, SAEs may learn more about the structure of the dataset than the computational structure of the network. There is therefore only indirect reason to believe that the directions found in these dictionaries are functionally important to the network. We propose end-to-end (e2e) sparse dictionary learning, a method for training SAEs that ensures the features learned are functionally important by minimizing the KL divergence between the output distributions of the original model and the model with SAE activations inserted. Compared to standard SAEs, e2e SAEs offer a Pareto improvement: They explain more network performance, require fewer total features, and require fewer simultaneously active features per datapoint, all with no cost to interpretability. We explore geometric and qualitative differences between e2e SAE features and standard SAE features. E2e dictionary learning brings us closer to methods that can explain network behavior concisely and accurately. We release our library for training e2e SAEs and reproducing our analysis at [https://github.com/ApolloResearch/e2e_sae](https://github.com/ApolloResearch/e2e_sae).

## 1 Introduction

Sparse Autoencoders (SAEs) are a popular method in mechanistic interpretability (Sharkey et al., 2022; Cunningham et al., 2023; Bricken et al., 2023). They have been proposed as a solution to the problem of superposition, the phenomenon by which networks represent more 'features' than they have neurons. 'Features' are directions in neural activation space that are considered to be the basic units of computation in neural networks. SAE dictionary elements (or 'SAE features') are thought to approximate the features used by the network. SAEs are typically trained to reconstruct the activations of an individual layer of a neural network using a sparsely activating, overcomplete set of dictionary elements (directions). It has been shown that this procedure identifies ground truth features in toy models (Sharkey et al., 2022).

However, current SAEs focus on the wrong goal: They are trained to minimize mean squared reconstruction error (MSE) of activations (in addition to minimizing their sparsity penalty). The issue is that the importance of a feature as measured by its effect on MSE may not strongly correlate with how important the feature is for explaining the network's performance. This would not be a problem if the network's activations used a small, finite set of ground truth features - the SAE would simply identify those features, and thus optimizing MSE would have led the SAE to learn the functionallyimportant features. In practice, however, Bricken et al. (2023) observed the phenomenon of feature splitting, where increasing dictionary size while increasing sparsity allows SAEs to split a feature into multiple, more specific features, representing smaller and smaller portions of the dataset. In the limit of large dictionary size, it would be possible to represent each individual datapoint as its own dictionary element. Since minimizing MSE does not explicitly prioritize learning features based on how important they are for explaining the network's performance, an SAE may waste much of its fixed capacity on learning less important features. This is perhaps responsible for the observation that, when measuring the causal effects of circuits made from SAE features on network performance, a significant amount is mediated by the reconstruction residual errors (i.e. everything _not_ explained by the SAE) and not mediated by SAE features (Marks et al., 2024).

Given these issues, it is therefore natural to ask how we can identify the _functionally important_ features used by the network. We say a feature is functionally important if it is important for explaining the network's behavior on the training distribution. If we prioritize learning functionally important features, we should be able to maintain strong performance with fewer features used by the SAE per datapoint as well as fewer overall features.

To optimize SAEs for these properties, we introduce a new training method. We still train SAEs using a sparsity penalty on the feature activations (to reduce the number of features used on each datapoint), but we no longer optimize activation reconstruction. Instead, we replace the original activations with the SAE output (Figure 1) and optimize the KL divergence between the original output logits and the output logits when passing the SAE output through the rest of the network, thus training the SAE end-to-end (e2e). We use SAE\({}_{}\) to denote an SAE trained with KL divergence and a sparsity penalty.

Figure 1: **Top:** Diagram comparing the loss terms used to train each type of SAE. Each arrow is a loss term which compares the activations represented by circles. SAE\({}_{}\) uses MSE reconstruction loss between the SAE input and the SAE output. SAE\({}_{}\) uses KL-divergence on the logits. SAE\({}_{}\) (end-to-end \(+\) downstream reconstruction) uses KL-divergence in addition to the sum of the MSE reconstruction losses at all future layers. All three are additionally trained with a \(L_{1}\) sparsity penalty (not pictured).

**Bottom:** Pareto curves for three different types of GPT2-small layer 6 SAEs as the sparsity coefficient is varied. E2e-SAEs require fewer features per datapoint (i.e. have a lower \(L_{0}\)) and fewer features over the entire dataset (i.e. have a low number of alive dictionary elements). GPT2-small has a CE loss of \(3.139\) over our evaluation set.

By contrast, we use SAE\({}_{}\) to denote our baseline SAEs, trained only to reconstruct the activations at the current layer with a sparsity penalty.

One risk with this method is that it may be possible for the outputs of SAE\({}_{}\) to take a different computational pathway through subsequent layers of the network (compared with the original activations) while nevertheless producing a similar output distribution. For example, it might learn a new feature that exploits a particular transformation in a downstream layer that is unused by the regular network or that is used for other purposes. To reduce this likelihood, we also add terms to the loss for the reconstruction error between the original model and the model with the SAE at downstream layers in the network (Figure 1). We use SAE\({}_{}\) to denote SAEs trained with KL divergence, a sparsity penalty, and downstream reconstruction loss. We use \(e2e\)_SAEs_ to refer to the family of methods introduced in this work, including both SAE\({}_{}\) and SAE\({}_{}\).

Previous work has used the performance explained - measured by cross-entropy loss difference when replacing the original activations with SAE outputs - as a measure of SAE quality (Cunningham et al., 2023; Bricken et al., 2023; Bloom, 2024). It's reasonable to ask whether our approach runs afloat of Goodhart's law ("_When a measure becomes a target, it ceases to be a good measure_"). We contend that mechanistic interpretability should prefer explanations of networks (and the components of those explanations, such as features) that explain more network performance over other explanations. Therefore, optimizing directly for quantitative proxies of performance explained (such as CE loss difference, KL divergence, and downstream reconstruction error) is preferred.

We train each SAE type on language models (GPT2-small (Radford et al., 2019) and Tinystories-1M (Eldan and Li, 2023)), and present three key findings:

1. For the same level of performance explained, SAE\({}_{}\) requires activating more than twice as many features per datapoint compared to SAE\({}_{}\) and SAE\({}_{}\) (Section 3.1).
2. SAE\({}_{}\) performs equally well as SAE\({}_{}\) in terms of the number of features activated per datapoint (Section 3.1), yet its activations take pathways through the network that are much more similar to SAE\({}_{}\) (Sections 3.2, 3.3).
3. SAE\({}_{}\) requires more features in total over the dataset to explain the same amount of network performance compared with SAE\({}_{}\) and SAE\({}_{}\) (Section 3.1).

These findings suggest that e2e SAEs are more efficient in capturing the essential features that contribute to the network's performance. Moreover, our automated-interpretability and qualitative analyses reveal that SAE\({}_{}\) features are at least as interpretable as SAE\({}_{}\) features, demonstrating that the improvements in efficiency do not come at the cost of interpretability (Section 3.4). These gains nevertheless come at the cost of longer wall-clock time to train (Appendix H).

As a supplementary investigation, we tested e2e SAEs on a set of subject-verb agreement tasks from Finlayson et al. (2021). These tests had inconclusive results (Appendix I), indicating that further work is needed to identify which downstream tasks would benefit most from e2e SAEs.

In addition to this article, we also provide: A library for training all SAE types presented in this article ([https://github.com/ApolloResearch/e2e_sae](https://github.com/ApolloResearch/e2e_sae)); a Weights and Biases (Biewald, 2020) report that links to training metrics for all runs ([https://api.wandb.ai/links/sparsify/evnay8t6](https://api.wandb.ai/links/sparsify/evnay8t6)); a Neuronpedia (Lin and Bloom, 2023) page for interacting with the features in a subset of SAEs (those presented in Tables 2 and 3) ([https://www.neuronpedia.org/gpt2sm-apollojt](https://www.neuronpedia.org/gpt2sm-apollojt)) as well as a repository for downloading these SAEs directly ([https://huggingface.co/apollo-research/e2e-saes-gpt2](https://huggingface.co/apollo-research/e2e-saes-gpt2)).

## 2 Training end-to-end SAEs

Our experiments train SAEs using three kinds of loss function (Figure 1), which we evaluate according to several metrics (Section 2.5):

1. \(L_{}\) trains SAEs to reconstruct activations at a particular layer (Section 2.2);
2. \(L_{}\) trains SAEs to learn functionally important features (Section 2.3);
3. \(L_{}\) trains SAEs to learn functionally important features that optimize for faithfulness to the activations of the original network at subsequent layers (Section 2.4).

### Formulation

Suppose we have a feedforward neural network (such as a decoder-only Transformer (Radford et al., 2018)) with \(L\) layers and vectors of hidden activations \(a^{(l)}\):

\[a^{(0)}(x) =x\] \[a^{(l)}(x) =f^{(l)}(a^{(l-1)}(x)),l=1,,L-1\] \[y =(f^{(L)}(a^{(L-1)}(x))).\]

We use SAEs that consist of an encoder network (an affine transformation followed by a ReLU activation function) and a dictionary of unit norm features, represented as a matrix \(D\), with associated bias vector \(b_{d}\). The encoder takes as input network activations from a particular layer \(l\). The architecture we use is:

\[(a^{(l)}(x))=(W_{e}a^{(l)}(x )+b_{e})\] \[(a^{(l)}(x))=D^{}(a^{(l)} (x))+b_{d},\]

where the dictionary \(D\) and encoder weights \(W_{e}\) are both (N_dict_elements\(\)d_hidden) matrices, \(b_{e}\) is a N_dict_elements-dimensional vector, while \(b_{d}\) and \(a^{(l)}(x)\) are d_hidden-dimensional vectors.

### Baseline: Local SAE training loss (\(L_{}\))

The standard, baseline method for training SAEs is SAElocal training, where the output of the SAE is trained to reconstruct its input using a mean squared error loss with a sparsity penalty on the encoder activations (here an L1 loss):

\[L_{}=L_{}+L_{}=||a^{(l)}(x)- _{}(a^{(l)}(x))||_{2}^{2}+||(a^{(l)}(x))|| _{1}.\]

\(=(a^{(l)})}\) is a sparsity coefficient \(\) scaled by the size of the input to the SAE (see Appendix D for details on hyperparameters).

### Method 1: End-to-end SAE training loss (\(L_{}\))

For SAEe2e, we do not train the SAE to reconstruct activations. Instead, we replace the model activations with the output of the SAE and pass them forward through the rest of the network:

\[^{(l)}(x) =_{}(a^{(l)}(x))\] \[^{(k)}(x) =f^{(k)}(^{(l)}(x))k=l,,L-1\] \[ =(f^{(L)}(^{(L-1)}(x)))\]

We train the SAE by penalizing the KL divergence between the logits produced by the model with the SAE activations and the original model:

\[L_{}=L_{}+L_{}=KL(,y)+||(a^{(l)}(x))||_{1}\]

Importantly, we freeze the parameters of the model, so that only the SAE is trained. This contrasts with Tamkin et al. (2023), who train the model parameters in addition to training a 'codebook' (which is similar to a dictionary).

Method 2: End-to-end with downstream layer reconstruction SAE training loss (\(L_{}\))

A reasonable concern with the \(L_{}\) is that the model with the SAE inserted may compute the output using an importantly different pathway through the network, even though we've frozen the original model's parameters and trained the SAE to replicate the original model's output distribution. To counteract this possibility, we also compare an additional loss: The end-to-end with downstreamreconstruction training loss (\(L_{}\)) additionally minimizes the mean squared error between the activations of the new model at downstream layers and the activations of the original model:

\[ L_{}&=L_{} +L_{}+L_{}\\ &=KL(,y)+||(a^{(l)})||_{1}+}{ L-l}_{k=l+1}^{L-1}||^{(k)}(x)-a^{(k)}(x)||_{2}^{2} \]

where \(_{l}\) is a hyperparameter that controls the downstream reconstruction loss term (Appendix D). \(L_{}\) thus has the desirable properties of 1) incentivizing the SAE outputs to lead to similar computations in downstream layers in the model and 2) allowing the SAE to "clear out" some of the non-functional features by not training on a reconstruction error at the layer with the SAE. Note, however, the inclusion of the intermediate reconstruction terms means that \(L_{}\) may encourage the SAE to learn features that are less functionally important.

### Experimental metrics

We record several key metrics for each trained SAE:

1. **Cross-entropy loss increase** between the original model and the model with SAE: We measure the increase in cross-entropy (CE) loss caused by using activations from the inserted SAE rather than the original model activations on an evaluation set. We sometimes refer to this as 'amount of performance explained', where a low CE loss increase means more performance explained. _All other things being equal, a better SAE recovers more of the original model's performance._
2. \(}\): How many SAE features activate on average for each datapoint. _All other things being equal, a better SAE needs fewer features to explain the performance of the model on a given datapoint._
3. **Number of alive dictionary elements**: The number of features in training that have not 'died' (which we define to mean that they have not activated over a set of \(500\)k tokens of data). _All other things being equal, a better SAE needs a smaller number of alive features to explain the performance of model over the dataset._

We also record the **reconstruction loss at downstream layers**. This is the mean squared error between the activations of the original model and the model with the SAE at all layers following the insertion of the SAE (i.e. downstream layers). If reconstruction loss at downstream layers is low, then the activations take a similar pathway through the network as in the original model. This minimizes the risk that the SAEs are learning features that take different computational pathways through the downstream layers compared to the original model. Finally, following Bills et al. (2023), we perform **automated-interpretability scoring** and qualitative analysis on a subset of the SAEs, to verify that improved quantitative metrics does not sacrifice the interpretability of the learned features.

We show results for experiments performed on GPT2-small's residual stream before attention layer \(6\).3 Results for layers \(2\), \(6\), and \(10\) of GPT2-small and some runs on a model trained on the TinyStories dataset (Eldan and Li, 2023) can be found in Appendices A.1 and A.2, respectively. They are qualitatively similar to those presented in the main text. For our GPT2-small experiments, we train SAEs with each type of loss function on \(400\)k samples of context size \(1024\) from the Open Web Text dataset (Gokaslan and Cohen, 2019) over a range of sparsity coefficients \(\). Our dictionary is fixed at \(60\) times the size of the residual stream (i.e. \(60 768=46080\) initial dictionary elements). Hyperparameters, along with sweeps over dictionary size and number of training examples, are shown in Appendices D and E, respectively.

## 3 Results

### End-to-end SAEs are a Pareto improvement over local SAEs

We compare the trained SAEs according to CE loss increase, \(L_{0}\), and number of alive dictionary elements. The learning rates for each SAE type were selected to be Pareto-optimal according to their \(L_{0}\) vs CE loss increase curves.4 Each experiment uses a range of sparsity coefficients \(\). In Figure 1, we see that both SAE\({}_{}\) and SAE\({}_{}\) achieve better CE loss increase for a given \(L_{0}\) or for a given number of alive dictionary elements. This means they need fewer features to explain the same amount of network performance for a given datapoint or for the dataset as a whole, respectively. For similar results at other layers see Appendix A.1.

This difference is large: For a given \(L_{0}\), both SAE\({}_{}\) and SAE\({}_{}\) have a CE loss increase that is less than \(45\)% of the CE loss increase of SAE\({}_{}\).5 SAE\({}_{}\) must therefore be learning features that are not maximally important for explaining network performance.

This improved performance comes at the expense of increased compute costs (\(2\)-\(3.5\) times longer runtime, see Appendix H). We test to see if additional compute improves our SAE\({}_{}\) baseline in Appendix E. We find neither increasing dictionary size from \(60*768\) to \(100*768\) nor increasing training samples from \(400\)k to \(800\)k noticeably improves the Pareto frontier, implying that our e2e SAEs maintain their advantage even when compared against SAE\({}_{}\) dictionaries trained with more compute.

For comparability, our subsequent analyses focus on 3 particular SAEs that have approximately equivalent CE loss increases (Table 1).

### End-to-end SAEs have worse reconstruction loss at each layer despite similar output distributions

Even though SAE\({}_{}\)S explain more performance per feature than SAE\({}_{}\)s, they have much worse reconstruction error of the original activations at each subsequent layer (Figure 2). This indicates that the activations following the insertion of SAE\({}_{}\) take a different path through the network than in the original model, and therefore potentially permit the model to achieve its performance using different computations from the original model. This possibility motivated the training of SAE\({}_{}\)s.

In later layers, the reconstruction errors of SAE\({}_{}\) and SAE\({}_{}\) are extremely similar (Figure 2). SAE\({}_{}\) therefore has the desirable properties of both learning features that explain approximately as much network performance as SAE\({}_{}\) (Figure 1) while having reconstruction errors that are much closer to SAE\({}_{}\). There remains a difference in reconstruction at layer \(6\) between SAE\({}_{}\) and SAE\({}_{}\). This is not surprising given that SAE\({}_{}\) is not trained with a reconstruction loss at this layer. In Appendix B, we examine how much of this difference is explained by feature scaling. In Appendix G.3, we find a specific example of a direction with low functional importance that is faithfully represented in SAE\({}_{}\) but not SAE\({}_{}\).

### Differences in feature geometries between SAE types

#### 3.3.1 End-to-end SAEs have more orthogonal features than SAE\({}_{}\)

Bricken et al. (2023) observed 'feature splitting', where a locally trained SAEs learns a cluster of features which represent similar categories of inputs and have dictionary elements pointing in similar directions. A key question is to what extent these subtle distinctions are functionally important for the

   SAE Type & \(\) (Sparsity Coeff) & \(L_{0}\) & Alive Elements & CE Loss Increase \\  Local & 4.0 & 69.4 & 26k & **0.145** \\ End-to-end & 3.0 & 27.5 & 22k & **0.144** \\ E2e + Downstream & 50.0 & 36.8 & 15k & **0.125** \\   

Table 1: Three SAEs from layer \(6\) with similar CE loss increases are analyzed in detail.

network's predictions, or if they are only helpful for reconstructing functionally unimportant patterns in the data.

We have already seen that SAE\({}_{}\) and SAE\({}_{}\) learn smaller dictionaries compared with SAE\({}_{}\) for a given level of performance explained (Figure 1). In this section, we explore if this is due to less feature splitting. We measure the cosine similarities between each SAE dictionary feature and next-closest feature in the same dictionary. While this does not account for potential semantic differences between directions with high cosine similarities, it serves as a useful proxy for feature splitting, since split features tend to be highly similar directions (Bricken et al., 2023). We find that SAE\({}_{}\) has features that are more tightly clustered, suggesting higher feature splitting (Figure 3a). Compared to SAE\({}_{}\) the mean cosine similarity is \(0.04\) higher (bootstrapped 95% CI \([0.037-0.043]\)); compared to SAE\({}_{}\) the difference is \(0.166\) (95% CI \([0.163-0.168]\)). We measure this for all runs in our Pareto frontiers and find that this difference is not explained by SAE\({}_{}\) having more alive dictionary elements than e2e SAEs (Appendix A.5).

3.2 SAE\({}_{}\) features are not robust across random seeds, but SAE\({}_{}\) and SAE\({}_{}\) are

We find that SAE\({}_{}\)s trained with one seed learn similar features as SAE\({}_{}\)s trained with a different seed (Figure 3b). The same is true for two SAE\({}_{}\)s. However, features learned by SAE\({}_{}\) are quite different for different seeds. This suggests there are many different sets of SAE\({}_{}\) features that achieve the same output distribution, despite taking different paths through the network.

3.3 SAE\({}_{}\) and SAE\({}_{}\) features do not always align with SAE\({}_{}\) features

The cosine similarity plots between SAE\({}_{}\) and SAE\({}_{}\) (Figure 3c top) reveal that the average similarity between the most similar features is low, and includes a group of features that are very dissimilar. SAE\({}_{}\) learns features that are much more similar to SAE\({}_{}\), although the cosine similarity plot is bimodal, suggesting that SAE\({}_{}\) learns a set of directions that very different to those identified by SAE\({}_{}\) (Figure 3c bottom).

It is encouraging that SAE\({}_{}\) and SAE\({}_{}\) features are somewhat similar, since this indicates that SAE\({}_{}\)s may serve as good initializations for training SAE\({}_{}\)s, reducing training time.

### Interpretability of learned directions

Using the automated-interpretability library (Lin, 2024) (an adaptation of Bills et al. (2023)), we generate automated explanations of our SAE features by prompting _gpt-4-turbo-2024-04-09_(OpenAI et al., 2024) with five max-activating examples for each feature, before generating "interpretability scores" by tasking _gpt-3.5-turbo_ to use that explanation to predict the SAE feature's true activations on a random sample of 20 max-activating examples. For each SAE we generate automated-interpretabilty scores for a random sample of features (\(n=198\) to \(201\) per SAE). We then measure the difference between average interpretability scores. This interpretability score is an

Figure 2: Reconstruction mean squared error (MSE) at later layers for our set of GPT2-small layer 6 SAEs with similar CE loss increases (Table 1). SAE\({}_{}\) is trained to minimize MSE at layer 6, SAE\({}_{}\) was trained to match the output probability distribution, SAE\({}_{}\) was trained to match the output probability distribution _and_ minimize MSE in all downstream layers.

imperfect metric of interpretability, but it serves as an unbiased verification and is therefore useful for ensuring that we are not trading better training losses for significantly less interpretable features.

For pairs of SAEs with similar \(L_{0}\) (listed in Table 3), we find no difference between the average interpretability scores of SAE\({}_{}\) and SAE\({}_{}\). If we repeat the analysis for pairs with similar CE loss increases, we find the SAE\({}_{}\) features to be more interpretable than SAE\({}_{}\) features in Layers \(2\) (\(p=0.0053\)) and \(6\) (\(p=0.0005\)) but no significant difference in layer \(10\). For additional automated-interpretability analysis, see Appendix A.7.

We also provide some qualitative, human-generated interpretations of some groups of features for different SAE types in Appendix G. Features from the SAEs in Table 2 and Table 3 can be viewed interactively at [https://www.neuronpedia.org/gpt2sm-apollojt](https://www.neuronpedia.org/gpt2sm-apollojt).

## 4 Related work

### Using sparse autoencoders and sparse coding in mechanistic interpretability

When Elhage et al. (2022) identified superposition as a key bottleneck to progress in mechanistic interpretability, the field found a promising scalable solution in SAEs (Sharkey et al., 2022). SAEs have since been used to interpret language models (Cunningham et al., 2023; Bricken et al., 2023; Bloom, 2024) and have been used to improve performance of classifiers on downstream tasks (Marks et al., 2024). Earlier work by Yun et al. (2021) concatenated together the residual stream of a language model and used sparse coding to identify an undercomplete set of sparse 'factors' that spanned multiple layers. This echoes even earlier work that applied sparse coding to word embeddings and found sparse linear structure (Faruqui et al., 2015; Subramanian et al., 2017; Arora et al., 2018). Similar to our work is Tamkin et al. (2023), who trained sparse feature codebooks, which are similar to SAEs, and trained them end-to-end. However, to achieve adequate performance, they needed to train the model parameters alongside the sparse codebooks. Here, we only trained the SAEs and left the interpreted model unchanged.

### Identifying problems with and improving sparse autoencoders

Although useful for mechanistic interpretability, current SAE approaches have several shortcomings. One issue is the functional importance of features, which we have aimed to address here. Some work has noted problems with SAEs, including Anders and Bloom (2024), who found that SAE features trained on a language model with a given context length failed to generalize to activations collected from activations in longer contexts. Other work has addressed 'feature suppression' (Wright and Sharkey, 2024), also known as'shrinkage' (Jermyn et al., 2024), where SAE feature activations systematically undershoot the 'true' activation value because of the sparsity penalty. While Wright and Sharkey (2024) approached this problem using finetuning after SAE training, Jermyn et al. (2024) and Riggs and Brinkmann (2024) explored alternative sparsity penalties during training that aimed to reduce feature suppression (with mixed success). Farrell (2024), taking an approach similar to Jermyn et al. (2024), has explored different sparsity penalties, though here not to address shrinkage,

Figure 3: Geometric comparisons for our set of GPT2-small layer \(6\) SAEs with similar CE loss increases (Table 1). For each dictionary element, we find the max cosine similarity between itself and all other dictionary elements. In (a)a we compare to others directions in the same SAE, in (b)b to directions in an SAE of the same type trained with a different random seed, in (c)c to directions in the SAE\({}_{}\) with similar CE loss increase.

but instead to optimize for other metrics of SAE quality. Rajamanoharan et al. (2024) introduce Gated SAEs, an architectural variation for the encoder which both addresses shrinkage and improves on the Pareto frontier of \(L_{0}\) vs CE loss increase.

### Methods for evaluating the quality of trained SAEs

One of the main challenges in using SAEs for mechanistic interpretability is that there is no known 'ground truth' against which to benchmark the features learned by SAEs. Prior to our work, several metrics have been used, including: Comparison with ground truth features in toy data; activation reconstruction loss; \(L_{1}\) loss; number of alive dictionary elements; similarity of SAE features across different seeds and dictionary sizes (Sharkey et al., 2022); \(L_{0}\); KL divergence (between the output distributions of the original model and the model with SAE activations) upon causal interventions on the SAE features (Cunningham et al., 2023); reconstructed negative log likelihood of the model with SAE activations inserted (Cunningham et al., 2023; Bricken et al., 2023); feature interpretability Cunningham et al. (2023) (as measured by automatic interpretability methods (Bills et al., 2023)); and task-specific comparisons (Makelov et al., 2024). In our work, we use (1) \(L_{0}\), (2) number of alive dictionary elements, (3) the average KL divergence between the output distribution of the original model and the model with SAE activations, and (4) the reconstruction error of activations in layers that follow the layer where we replace the original model's activations with the SAE activations.

### Methods for identifying the functional importance of sparse features

In our work, we optimize for functional importance directly, but previous work measured functional importance _post hoc_ using different approaches. Cunningham et al. (2023) used activation patching (Vig et al., 2020), a form of causal mediation analysis, where they intervened on feature activations and found the output distribution was more sensitive (had higher KL divergence with the original model's distribution) in the direction of SAE features than other directions, such as PCA directions. With the same motivation, Marks et al. (2024) use a similar, approximate, but more efficient, method of causal mediation analysis (Nanda, 2022; Sundararajan et al., 2017). Unlike our work, these works use the measures of functional importance to construct circuits of sparse features. Bricken et al. (2023) used logit attribution, measuring the effect the feature has on the output logits.

## 5 Conclusion

In this work, we introduce end-to-end dictionary learning as a method for training SAEs to identify functionally important features in neural networks. By optimizing SAEs to minimize the KL divergence between the output distributions of the original model and the model with SAE activations inserted, we demonstrate that e2e SAEs learn features that better explain network performance compared to the standard locally trained SAEs.

Our experiments on GPT2-small and Tinystories-1M reveal several key findings. First, for a given level of performance explained, e2e SAEs require activating significantly fewer features per datapoint and fewer total features over the entire dataset. Second, SAE\({}_{}\), which has additional loss terms for the reconstruction errors at downstream layers in the model, achieves a similar performance explained to SAE\({}_{}\) while maintaining activations that follow similar pathways through later layers compared to the original model. Third, the improved efficiency of e2e SAEs does not come at the cost of interpretability, as measured by automated-interpretability scores and qualitative analysis.

These results suggest that standard, locally trained SAEs are capturing information about dataset structure that is not maximally useful for explaining the algorithm implemented by the network. By directly optimizing for functional importance, e2e SAEs offer a more targeted approach to identifying the essential features that contribute to a network's performance.

## 6 Impact statement

This article proposes an improvement to methods used in mechanistic interpretability. Mechanistic interpretability, and interpretability broadly, promises to let us understand the inner workings of neural networks. This may be useful for debugging and improving issues with neural networks. For instance, it may enable the evaluation of a model's fairness or bias. Interpretability may relatedly be useful for improving the trust-worthiness of AI systems, potentially enabling AI's use in certain high stakes settings, such as healthcare, finance, and justice. However, increasing the trust-worthiness of AI systems may be dual use in that may also enable its use in settings such as military applications.