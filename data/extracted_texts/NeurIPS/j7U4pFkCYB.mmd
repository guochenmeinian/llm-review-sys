# DynPoint: Dynamic Neural Point For View Synthesis

Kaichen Zhou, Jia-Xing Zhong, Sangyun Shin, Kai Lu,

**Yiyuan Yang, Andrew Markham, Niki Trigoni**

Department of Computer Science

University of Oxford

{rui.zhou, jiaxing.zhong, sangyun.shin, kai.lu}@cs.ox.ac.uk

{yiyuan.yang, andrew.markham, niki.trigoni}@cs.ox.ac.uk

###### Abstract

The introduction of neural radiance fields has greatly improved the effectiveness of view synthesis for monocular videos. However, existing algorithms face difficulties when dealing with uncontrolled or lengthy scenarios, and require extensive training time specific to each new scenario. To tackle these limitations, we propose DynPoint, an algorithm designed to facilitate the rapid synthesis of novel views for unconstrained monocular videos. Rather than encoding the entirety of the scenario information into a latent representation, DynPoint concentrates on predicting the explicit 3D correspondence between neighboring frames to realize information aggregation. Specifically, this correspondence prediction is achieved through the estimation of consistent depth and scene flow information across frames. Subsequently, the acquired correspondence is utilized to aggregate information from multiple reference frames to a target frame, by constructing hierarchical neural point clouds. The resulting framework enables swift and accurate view synthesis for desired views of target frames. The experimental results obtained demonstrate the considerable acceleration of training time achieved - typically an order of magnitude - by our proposed method while yielding comparable outcomes compared to prior approaches. Furthermore, our method exhibits strong robustness in handling long-duration videos without learning a canonical representation of video content.

## 1 Introduction

The computer vision community has directed significant attention towards novel view synthesis (VS) due to its potential for both emerging techniques in artificial reality and also to enhance a machine's ability to comprehend the appearance and geometric properties of target scenarios [37; 8; 39]. State-of-the-art techniques leveraging neural rendering algorithms, as demonstrated in studies such as [37; 58; 61], have successfully attained photorealistic reconstruction of views in static scenarios. However, the dynamic characteristics inherent to most real-world scenarios present a formidable challenge to the suitability of existing approaches that rely on the epipolar geometric relationship, traditionally applicable to static scenarios [22; 45].

Recent studies have primarily focused on the synthesis of views in dynamic scenarios by employing one or multiple multilayer perceptrons (MLPs) to encode the essential spatiotemporal information of the scene [45; 31; 43; 42]. In one approach, a latent representation is generated to encompass the comprehensive per-frame details of the target video [31; 16; 62]. Although this method is capable of producing visually realistic results, its applicability is limited to short videos due to the constrained memory capacity of MLPs or other representation mechanisms . Alternatively, another approach seeks to construct a latent representation of canonical scenarios and establish correspondences between individual frames and the canonical scenario [45; 43; 63]. This alternative approach allows for the processing of long-term videos; however, it imposes specific requirements on the videocharacteristics being learned. For instance, the videos should consistently feature similar objects across frames, and some algorithms may require prior knowledge about the video [60; 44].

In order to address this challenge, we introduce DynPoint, a novel approach designed to achieve efficient view synthesis of lengthy monocular videos without the need for learning a latent canonical representation. Unlike conventional methods that encode information implicitly, DynPoint employs an explicit estimation of consistent depth and scene flow for surface points. These estimates are subsequently utilized to aggregate information from reference frames into the target frame. Subsequently, hierarchical neural point clouds are constructed based on the aggregated information. This hierarchical point cloud set is then employed to synthesize views of the target frame. Our contributions can be summarized as follows:

* We introduce a novel module to estimate consistent depth information for monocular video with the help of a proposed regularization and training strategy.
* We propose an efficient approach to estimate smooth scene flow between adjacent frames with the proposed training strategy by leveraging the estimated consistent depth maps.
* We present a representation to aggregate information from reference frames to target frame, facilitating rapid view synthesis of the target frame within a monocular video.
* Comprehensive experiments are conducted on datasets including Nerfie, Nvidia, HyperNeRF, Iphone, and Davis showcasing the speed and accuracy of DynPoint for view synthesis.

## 2 Related Works

### Static View Synthesis

The generation of photo-realistic views from arbitrary input viewing angles has been a longstanding challenge in the field of computer vision. In the scenario of static scenes, early approaches addressed the challenge of synthesizing photo-realistic views by employing local warping techniques to handle densely sampled views [19; 30; 2; 5; 7]. Additionally, the gradient domain was utilized to handle the single-view case . In order to tackle the challenges associated with view synthesis, several subsequent works have been developed. These works aim to address issues such as reflections, repetitive patterns, and untextured regions [28; 15; 24; 14; 48; 9; 34; 36; 41; 50; 51; 52; 53; 59; 69]. In more recent developments, researchers have explored the representation of scenes as continuous neural radiance fields (NeRF) using fully connected neural networks. These works, such as [38; 1; 66; 25], have demonstrated remarkable outcomes with a trade-off between accuracy and computational complexity (i.e., one network for one scene). To tackle the computational burden associated with neural radiance fields, recent works have focused on developing approaches that generalize the representation across multiple scenes using a single network. These methods employ various techniques, such as fully-convolutional architectures , plane-swept cost volumes , image-based rendering , disentanglement of shape and texture , utilization of local features in 2D , as well as generative methods [6; 49; 40; 20; 3].

### Dynamic View Synthesis

The emergence of static scene advancements has spurred interest in the exploration of view synthesis for dynamic scenes within the field. Previous research efforts have expanded upon studies conducted in static scenes, incorporating elements such as globally coherent depth  and 3D mask volume . Recent research direction builds upon the concept of NeRF and extends it to dynamic scenes by integrating time into the learning process of spatio-temporal radiance fields. One category of research focuses on the assumption of a canonical scenario that spans the entire video [4; 10; 21]. Deformable radiance field-based approaches, as described in previous works [45; 55; 42; 13; 35], employ temporal warping techniques to adapt a base NeRF representation of the canonical space for dynamic scenes. This enables the synthesis of novel views in the context of long monocular videos. Another category of algorithms aims to encode the temporal dynamics of the scene into a global representation.  employs a MLP to model the 3D dense motion, resulting in a spatial-temporal NeRF. Building upon this, [12; 57; 16] demonstrate that introducing additional regularization techniques that encourage consistency and physically plausible solutions can enhance the accuracy of view reconstruction. The first category of methods, while achieving impressive photorealistic results, is constrained by the requirement for object-centric videos, thus limiting their generalizability to diverse scenarios.

Conversely, the second category of methods encounters difficulties when dealing with long videos, leading to limitations in effectively handling such scenarios. To address the aforementioned issue, our algorithm focuses on achieving novel synthesis by aggregating information from the reference frame to the target frame. This information aggregation process is accomplished by explicitly modeling the object movement and depth information. As a result, our algorithm exhibits significant advancements in both accuracy and speed.

## 3 Methodology

### Overview

Our algorithm is designed to realize view synthesis for a dynamic scenario by utilizing a monocular video \(\{I_{1},I_{2},...,I_{T}\}\). The frames in the video, denoted by \(I_{t}\), are captured by a known camera \(_{t,c}=\{_{t,c}|[_{t,c},_{t,c}]\}\), where \(c\) denotes known camera viewpoint. The objective is to generate the novel view from a specified viewpoint \(q\) at a desired time frame \(_{t,q}=\{_{t,q}|[_{t,q},_{t,q}]\}\).

Consistent with previous researches [31; 16; 17; 32; 35; 62], we adopt a training paradigm in which our model is trained on the input monocular video with the assistance of pre-trained optic flow and monocular depth models [47; 54; 26]. During the training process, the RGB information obtained from the observed viewpoint is utilized as the supervision signal, without relying on any canonical information. Subsequently, the trained model is evaluated on the task of synthesizing corresponding RGB, depth and scene flow information for unobserved viewpoints.

In contrast to previous methods that utilize one or multiple MLPs to encode the 3D information of each frame, our work focuses on establishing correspondence relationships, i.e., scene flow, between the 3D surface points of the current frame and those of adjacent frames. We can infer 3D information about unobserved points of the current frame by aggregating the information from adjacent frames.

To realize the aforementioned concept, our proposed model should undertake three key tasks. The first task is to estimate depth information consistently for each frame, as outlined in Sec. 3.2. The second task involves learning the 3D scene flow between the current frame and its adjacent frames, as detailed in Sec. 3.3. These two processes are demonstrated in the stage 1 of Fig. 1. The final task is

Figure 1: **Structure of DynPoint. The Stage 1** shows the pipeline of consistent depth estimation in Sec. 3.2 and scene flow estimation in Sec. 3.3. Initially, the frames are employed in the Flow Net, Depth Net, and Scale Parameters to produce optic flows and depth. Then, surface points are calculated based on the estimated depth and utilized in the Scene Flow MLP. The **Stage 2** shows the process of information aggregation presented in Sec. 3.4. Neural Point Clouds is firstly generated based on pre-computed scene flow. The Rendering MLP utilizes all neural points located within a specified radius from the queried point as inputs to predict the final color and density.

to aggregate information based on learned correspondence and subsequently use this information to realize view synthesis, as discussed in Sec. 3.4. This process is shown in the stage 2 of Fig. 1.

### Consistent Depth Estimation

Despite the ability of current monocular depth methods [47; 46] to produce accurate depth priors, the predicted depth maps \(d_{t}^{}\) suffer from scale-variance and shift problems when compared to the ground truth depth [18; 68]. This characteristic renders \(d_{t}^{}\) inconsistent across the temporal axis of monocular video. Moreover, since the optic flow \(f_{t t^{}}\) between frames could be predicted from a pretrained model, a depth value \(_{t}\) can be computed using the triangulation relation between frames, along with the camera parameters and Mid-point method. Compared to \(d_{t}^{}\), \(_{t}\) can have consistent scaling across frames. However, \(_{t}\) heavily relies on \(f_{t t^{}}\) and Epipolar constraint, and it can only generate accurate depth information for a limited portion of the frame. The first module of DynPoint aims to combine \(d_{t}^{}\) and \(_{t}\) to generate the final consistent depth estimation \(_{t}\).

**Regularization:** To address this issue, DynPoint identifies the accurate region of \(_{t}\) by utilizing three masks: the corresponding mask, the geometric edge mask, and the dynamic object mask.

Correspondence Mask \(_{c,t t^{}}\): The purpose of the optic flow is to capture the pixel-wise correspondence between two frames, making it accurate only for the corresponding regions. These regions can be identified by masking out areas of occlusion caused by both ego-motion and object movement. This Correspondence Mask could be formulated as follow:

\[_{c,t t^{}}=0&if|f_{t t^{}}(p)+ f_{t^{} t}(p+f_{t t^{}}(p))|>_{c},\\ 1&if|f_{t t^{}}(p)+f_{t^{} t}(p+f_{t t^{}}(p))| _{c},\] (1)

where \(_{c}\) is a predefined threshold for the correspondence mask.

Geometric Edge Mask \(_{g}\): Furthermore, it has been observed that the reliability of \(_{t}\) diminishes when applied to geometric edges as in Fig. 2, particularly in areas where the optic flow exhibits non-smooth characteristics. To compute the mask \(_{g}\), we first estimate the normal vector map of the surface \(n=(-,-,1)/||(-,-,1)||\) with the help of \(_{t}\). Then we apply the Canny edge detector  on the \(n^{H W}\) to generate the estimation of geometric edge. The intuition of the geometric edge mask is demonstrated in the left part of Fig. 2. From the error map shown in Fig. 2(b), it is evident that the errors primarily manifest around the geometric boundaries of the scenario.

Dynamic Object Mask \(_{d}\): In addition to the two masks mentioned above, a Dynamic Object Mask is necessary to exclude the dynamic regions of the frame where the triangulation relationship does not hold. Similar to , we combine the MASK R-CNN  with the Sampson error to generate the \(_{d}\). To obtain a valid mask with high accuracy, we apply _image erosion_ on the inverse of \(_{d}\) and

Figure 2: **Demonstration of Geometric Edge Mask and Scene Flow Estimation. The left section depicts the conceptual basis for designing the Geometric Edge Mask. The right part demonstrates the construction of the scene flow objective function shown in Sec. 3.3.**

\(_{c}\) to mitigate inaccurate boundary detection. We also perform _image dilation_ on \(_{g}\) to include the surrounding region of the geometric edge.

**Objective Function:** Based on the above three masks, the reliable region of the \(_{t}\) could be masked out by using the final mask \(_{f}=_{c} M_{g}_{d}\). To combine the information of \(d^{}_{t}\) and \(_{t}\), we assume that the consistent depth map \(_{t}^{H W}\) could be approximated by using \(d^{}_{t}\), a scale variable \(_{t}\) and a shift variable \(_{t}\). The parameters \(_{t}\) and \(_{t}\) can be generated by optimizing:

\[_{t},_{t}=_{f}|_ {t}-(_{t}d^{}_{t}+_{t})|.\] (2)

**Training Strategy:** Dependent solely on the nearest frame for the computation of \(_{t}\) would lack sufficient reliability due to the combined influence of the accuracy of the camera matrix and the accuracy of the optic flow on the triangulation process. We employ a series of adjacent \(2K\) frames to calculate the triangulated depth set denoted as \(\{^{k}_{t}\}_{k=1}^{2K}\). Instead of directly utilizing all \(\{^{k}_{t}\}_{k=1}^{2K}\) in Eqn. 2, we perform a reevaluation by recomputing the intersection mask as \(_{f}=^{1}_{f}...^{2K}_{f}\), which further refines the triangulated depth \(_{t}\), ensuring the appropriate scale constraint for \(d^{}_{t}\). It's worth noting that pose estimation may not be accurate for dynamic scenarios in certain datasets, as it relies on COLMAP-based estimation. In such cases, we utilize the algorithm presented in our Supplementary material to enhance and fine-tune the pose estimation.

### Scene Flow Estimation

Combined with estimated consistent depth map \(_{t}\) and optic flow \(f_{t t^{}}\), DynPoint also aims to infer the scene flow \(s_{t t^{}}\) to build the 3D correspondence between the current frame and adjacent frames. Unlike previous works [42; 45; 55; 13], which estimate the trajectory of all points (hundreds of sampled points on the ray of each point) in the scenario, DynPoint only infers the trajectory of surface point (one point on the ray of each point) of the frame to accelerate both training and inference process. To realize this process, we use a MLP to estimate the scene flow, which can be written as \( P_{t t+1}, P_{t t-1}=F_{}(P,t)\) where \(P^{3}\) denotes input 3D point; \( P_{t t^{}}\) denotes the trajectory of \(P\) from \(t\) to \(t^{}\). The weight \(\) can be optimized by using the relationship among the depth \(_{t}\), the optic flow \(f_{t t^{}}\) and the scene flow \(s_{t t^{}}\).

**Objective Function:** Given a pixel \(p_{t}\) in frame \(t\), its corresponding pixel in frame \(t^{}\), denoted as \(p_{t^{}}\), can be obtained by adding the 2D flow \(f_{t t^{}}(p_{t})\) to \(p_{t}\). Additionally, utilizing the depth map \(_{t}\) and camera matrix \(_{t}\), which are available at frame \(t\), the 3D point corresponding to \(p_{t}\) can be expressed as \(P_{t}=_{t}_{t}^{-1}_{t}(p_{t})p_{t}+_{t}\). The same method can be used to compute \(P_{t^{}}\). Thus, we've:

\[s_{t t^{}}(p_{t})=_{t^{}}(p_{t}+f_{t t^{}}(p_ {t}))_{t^{}}_{t^{}}^{-1}(p_{t}+f_{t t^{ }}(p_{t}))+_{t^{}}-P_{t}.\] (3)

This process is demonstrated in the right part of Fig. 2. For static part masked by \(_{d}\), we set \(s_{t}(p_{t})=0\). For the dynamic part, the loss function can be written as

\[_{s}=_{p_{t}_{c}_{g} _{d}}|s_{t t^{}}(p_{t})- P_{t t^{}}|.\] (4)

In order to enhance the accuracy of scene flow estimation for the dynamic elements within the scenario, we employ the cycle constraint, a well-established technique utilized in prior studies [16; 35]. The cycle constraint can be expressed as follows:

\[_{c}=_{p_{t}_{d}}| P_{t t+k}+  P_{t+k t}(P_{t}+ P_{t t+k})|.\] (5)

**Training Strategy:** We have observed that optimizing Eqn. 4 solely with the near frames, where \(t^{}=t-1\) or \(t+1\), does not produce accurate results for further information aggregation. To reconstruct the 3D information of the current frame, it is necessary to compute the correspondence between the current frame and \(2K\) adjacent frames, in order to aggregate sufficient information. During the training process, we compute the scene flow between frame \(t\) and its \(2K\) adjacent frames, where \(K\{1,...,K\}\). We then utilize Eqn. 4 to form the loss function between current frame and \(2K\) adjacent frames. The scene flow \( P_{t t+k}\) could be written as:

\[ P_{t t+k}=F_{}(P_{t},t)+...+F_{}(P_{t}+ P_{t  t+k-1},t+k-1).\] (6)

[MISSING_PAGE_FAIL:6]

downsampling the depth map, the intrinsic matrix should also be adjusted accordingly to maintain accurate spatial information.)

**View Synthesis**: Given a 3D position \(q\) and view direction \(d\), we leverage \(M\) proximate neural points within a radius of \(R\) to generate the corresponding density and color data \(,c\) as in . This process is shown in the right part of Fig. 1. This can be expressed as follows:

\[(,c)=F_{}(q,d,_{t}^{1},_{t}^{1},_{t}^{1},..., _{t}^{M},_{t}^{M},_{t}^{M}).\] (8)

where \(_{t}^{1}\) is the per-point confidence introduced in . Finally, we make use the rendering process in  to predict final RGB value \(C\) and depth \(D\) as:

\[C=_{j=1}^{N}_{j}(1-exp(-_{j}_{j}))c_{j},\] (9)

where \(_{j}=exp(-_{t=1}^{j-1}_{t}_{t})\); \(_{j}\) denotes the distance between adjacent shading samples; \(c_{j}\) is the color information and \(_{j}\) is the density information. The L2 loss function is used to supervise our rendered pixel values similar to the setting of . For further information regarding the network architecture, please consult our supplementary materials.

### Discussion

The purpose of this section is to explicate the dissimilarities between the DynPoint and a recently published concurrent work, namely DynIBaR  which was released in March 2023 and currently lacks available code. Both DynIBaR and DynPoint harness information aggregation mechanisms to realize the synthesis of novel views. However, DynIBaR predominantly centers around the aggregation of information through two-dimensional (2D) pixel units. This approach draws inspiration from image-based rendering principles, entailing the synthesis of novel perspectives from a collection of reference images via a weighted fusion of reference pixels. In contrast, DynPoint's focal point lies in the information aggregation achieved by constructing three-dimensional (3D) neural point clouds. The final novel view synthesis is realized by using neural points surrounding queries' position.

   PSNR \(\) / LPIPS \(\) & CURLS & TOBY SIT & TAIL & BROOM & Average \\  NeRF  & 14.40 / 0.616 & 22.80 / 0.463 & 23.00 / 0.571 & 21.00 / 0.667 & 20.30 / 0.579 \\ NeRF + time & 17.30 / 0.539 & 19.40 / 0.385 & 24.90 / 0.404 & 21.90 / 0.576 & 20.87 / 0.476 \\ NSFF  & 18.00 / 0.432 & **26.90** / 0.208 & **30.60** / 0.245 & **28.20** / **0.202** & 25.93 / 0.272 \\ Nerfies  & **24.90** / **0.312** & 22.80 / **0.174** & 23.60 / **0.175** & 21.00 / 0.270 & 23.08 / **0.233** \\  DynPoint & 24.33 / 0.339 & 24.90 / 0.186 & 29.12 / 0.218 & 27.28 / 0.222 & **26.41** / 0.241 \\   

Table 2: **Novel View Synthesis Results on Nerfie Dataset.** We report the average PSNR and LPIPS results with comparisons to existing methods on Nerfie dataset .

Figure 4: **Demonstration of View Synthesis Results on Nerfie Dataset.** This demonstration compares the view synthesis outcomes of DynPoint with those of NSFF.

Moreover, DynPoint introduces an efficacious strategy for the seamless integration of monocular depth estimation within the ambit of monocular video view synthesis. In contrast to DynIBaR, which endeavors to model the trajectory of all samples (128) traversing each ray, DynPoint exclusively focuses on the trajectory of surface points, thereby yielding a substantial acceleration in both training and inference stage.

## 4 Experiment

### Experimental Setting

To evaluate the view synthesis capabilities of DynPoint, we performed experiments on four extensively utilized datasets, namely Nvidia dataset in , Nerfie in , HyperNeRF in  and Iphone in . It is noteworthy to mention that the official website of Nerfie  only provides four specific scenarios. Consequently, our experiments were solely conducted on provided four scenarios as in . Additionally, we also assessed DynPoint's performance on a recent dataset Iphone , which specifically addresses the challenge of camera teleportation. Furthermore, we examined the efficacy of monocular depth estimation and scene estimation by visualizing the results obtained from the Davis dataset, as in .

We conducted a comparative analysis of our work with several recent methods, based on the reported results in their original papers or the reimplementation results of their official code. The methods we compared with include NeRF , NeRF + time  (which directly utilizes embedded time information as an input to encode all information of the target dynamic scenario), D-NeRF , NSFF , DynamicNeRF , HyperNeRF , Nerfie , TiBeuVox , and RoDYN . In our research, we employed the pretrained Deep Pruning Transformer (DPT) network in , for monocular depth estimation. For optic flow estimation, we utilized the pretrained FlowFormer model . To facilitate the fine-tuning process, we initialized the weights of the Rendering MLP by pretraining it on the DTU dataset, employing a similar training set to that used in .

The per-scenario training time is shown in Tab. 1. A notable observation was made regarding the reduced per-scenario training time of DynPoint in comparison to other algorithms. This enhancement can be attributed to the implementation of a two-step strategy. In the initial stage, the optimization process focuses on a limited set of parameters pertaining to monocular depth estimation and scene flow estimation. Subsequently, for the second stage, leveraging the outcomes obtained from the first stage, the generation of the neural point cloud for subsequent view synthesis is achieved successfully. Furthermore, the pretraining stage also contributes to the efficiency of our view synthesis stage, requiring only a few iterations to produce desirable results on novel scenarios.

**Nvidia** (Tab. 1): During this experiment, it was observed that DynPoint exhibited superior performance compared to other algorithms in terms of peak signal-to-noise ratio (PSNR). Additionally, DynPoint achieved the second highest ranking among all algorithms when evaluated based on the Learned Perceptual Image Patch Similarity (LPIPS) metric. Even for scenarios involving multiple objectives, such as Jumping, DynPoint demonstrates reasonable performance without requiring the learning of any canonical representation or extensive training time. The results of specific partial

    & Apple & Block & Paper-windmill & Space-out & Spin & Tebly & Web & Average \\  NSFF  & 17.54 / **0.726** & 16.61 / 0.639 & 12.34 / 0.728 & 17.29 / 0.622 & 18.38 / **0.585** & 13.65 / 0.527 & 13.82 / 0.458 & 1.46 / 0.569 \\ Nerfie  & 12.64 / 0.73 & 13.64 / **0.70** & **13.78 / 0.822** & **17.93 / 0.605 & **19.20 / 0.561** & **13.97 / 0.556 & 16.45 / 0.569 \\ HyperNeRF  & 16.47 / 0.754 & 14.71 / 0.606 & 14.94 / 0.272 & 17.65 / **0.636** & 17.26 / 0.540 & 12.59 / 0.537 & 14.59 / 0.511 & 16.81 / 0.550 \\  DynPoint & **17.78** / 0.743 & **17.67** / 0.667 & 17.32 / 0.366 & 17.78 / 0.603 & 19.04 / 0.564 & 13.95 / 0.551 & **14.72** / **0.515** & **16.89** / **0.572** \\   

Table 4: **Novel View Synthesis Results of Iphone Dataset.** We compare the mPSNR and mSSIM scores with existing methods on the iPhone dataset .

    &  Broom \\ 197 Frames \\  } & 3D printer & Chicken & Expressions & Peel Banana & \\  & & 207 Frames & 164 Frames & 259 Frames & 513 Frames & Average \\  NSFF  & 26.10 / 0.284 & **27.70** / 0.125 & 26.90 / 0.106 & 26.70 / 0.157 & 24.60 / 0.198 & 26.40 / 0.174 \\ Nerfies  & 19.20 / 0.325 & 20.60 / **0.108** & 26.70 / **0.078** & 21.80 / 0.150 & 22.40 / 0.147 & 22.10 / 0.162 \\ Hyper-NeRF  & 20.60 / 0.613 & 21.40 / 0.212 & 27.60 / 0.108 & 22.00 / 0.196 & 24.30 / 0.170 & 23.20 / 0.260 \\  DynPoint & **27.40** / **0.248** & 22.60 / 0.163 & **28.10** / 0.089 & **27.90** / **0.147** & **26.50** / **0.129** & **27.50** / **0.155** \\   

Table 3: **Novel View Synthesis Results of HyperNeRF Dataset.** We report the average PSNR and LPIPS results with comparisons to existing methods on HyperNeRF dataset .

scenarios, namely Playground, Skating, Truck, and Umbrella, are presented in Fig. 3. Notably, leveraging monocular depth estimation, DynPoint generally produces views with improved geometric features, as evident in the Skating case shown in the second row of Fig. 3. Even in challenging scenarios like Umbrella, DynPoint successfully generates high-quality views while minimizing blurring effects. **Nerfie** (Tab. 2): In the case of the extended scenario, DynPoint exhibits superior performance in terms of PSNR and achieves comparable results to those obtained in the short video Nvidia, as presented in Tab. 2. This achievement can be attributed to our information aggregation approach, which focuses on effectively aggregating information from the target frame by establishing associations between its points and those in the reference frames. Novel view synthesis results for scenarios TAIL and TOBY SIT are depicted in Figure 4. It is evident that for longer videos, DynPoint continues to produce more realistic frames. Notably, the generated views in this figure do not exist in either the training or test dataset. **HyperNeRF** (Tab. 3): In the case of longer video sequences, DynPoint showcases superior performance in PSNR, as highlighted in Table 3. **Iphone** (Tab. 4): In the context of monocular videos without camera teleportation, as demonstrated in the work , DynPoint attains comparable outcomes to previous algorithms. Due to the inherent limitations of having few multi-view perspectives and overlapping information, establishing correspondences between adjacent frames becomes challenging. Consequently, the view synthesis task based on monocular videos proves to be more arduous on this dataset compared to other datasets.

### Ablation Studies

In order to evaluate the effectiveness of the strategies proposed in our paper, we conducted three ablation studies. These studies include: (1) the absence of the multiple-step training strategy outlined in Sec. 3.2 and Sec. 3.3; (2) the utilization of only six frames in the vicinity (\(K=3\)); and (3) the exclusion of the hierarchical point cloud. The results are presented in Tab. 5. It is evident from the results that the omission of the multiple-step training strategy leads to the largest drop in performance. Without this strategy, the first stage produces noisy outcomes for both monocular depth and scene

Figure 5: **Demonstration of Depth and Scene Flow Estimation. This figure presents the output of the target images obtained by warping the reference image using depth estimation (second row) or using both depth and scene flow estimation (third row). It is important to clarify that the figure is not intended for comparing view synthesis results. The synthesized figures generated based on scene flow inherently incorporate object motion as input, resulting in observable motion blur within the synthesized figures. Additionally, an error map represented by the intensity of red is provided to visualize the performance, where deeper shades of red indicate larger errors (in terms of pixel movement compared to corrected optic flow).**

   PSNR \(\)/LPPS \(\) & Junping & Skating & Truck & Umbrella & Balloon1 & Balloon2 & Playground & Average \\  w/o multiple-step strategies & 15\(\)0 / 0.711 & 17.43 / 0.691 & 15.36 / 0.606 & 14.90 / 0.837 & 13.98 / 0.583 & 15.46 / 0.624 & 11.35 / 0.613 & 14.78 / 0.666 \\ w/ K = 3 & 20.22 / 0.264 & 22.53 / 0.274 & 22.38 / 0.291 & 19.13 / 0.383 & 16.59 / 0.413 & 16.92 / 0.459 & 14.83 / 0.416 & 18.94 / 0.357 \\ w/o Hierarchical Point Cloud & 23.82 / 0.174 & 28.34 / 0.053 & 27.50 / 0.085 & 22.73 / 0.192 & 21.08 / 0.256 & 24.67 / 0.180 & 22.14 / 0.189 & 24.38 / 0.161 \\  DynPoint (\(=6\)) & **24.09** / **0.097** & **31.34** / **0.045** & **29.30** / **0.064** & **24.59** / **0.066** & **22.77** / **0.097** & **27.43** / **0.049** & **25.37** / **0.039** & **26.53** / **0.088** \\   

Table 5: **Ablation studies of Nvidia Dataset. We report the average PSNR and LPIPS results with comparisons to existing methods on Nvidia dataset .**flow estimation, consequently hindering the generation of the neural point cloud and impacting the performance of the second stage. Moreover, using a limited number of adjacent frames also adversely affects the final performance, which aligns with our expectations as limited inputs correspond to limited information. Although the removal of the hierarchical point cloud does not significantly degrade performance, it still plays a role in generating finer results.

### Consistent Depth & Scene Flow Estimation On Davis

In order to validate the efficacy of the monocular depth estimation technique and the scene flow estimation method, we present the following visualization results: (1) Reconstructed Target Image using Monocular Depth Estimation: We demonstrate the reconstruction of the target image by warping the reference image based on the monocular depth estimation. (2) Reconstructed Target Image using Scene Flow and Depth Estimation: We present the visual reconstruction of the target image achieved through warping the reference image using solely depth estimation or a combination of scene flow estimation and depth estimation. The results are displayed in Fig. 5. Upon observing the second row, it is evident that DynPoint demonstrates commendable performance in reconstructing the static background of the target frame through monocular depth estimation. However, the primary errors (deep red part) occur in the dynamic region, where accounting for object movement becomes crucial for accurate warping. Moving to the third row, our scene flow estimation proves to be effective in capturing the movement of dynamic objects, as in the red error map Fig. 5.

### Failure Cases

Despite the notable achievements of DynPoint, certain failure cases were observed during the view synthesis process, as demonstrated in Fig. 6. By comparing the first and second images, it becomes apparent that generating realistic facial features in regions with intricate details proves to be challenging. Furthermore, when comparing the third and fourth images, it is evident that DynPoint struggles with handling fine objects and reflections, as these aspects heavily rely on the accurate geometry inference obtained in the first stage.

## 5 Conclusion

In this research paper, we present DynPoint, an algorithm specifically designed to address the view synthesis task for monocular videos. Rather than relying on learning a global representation encompassing color, geometry, and motion information of the entire scene, we propose an approach that aggregates information from neighboring frames. This aggregation process is facilitated by learning correspondences between the target frame and reference frames, aided by depth and scene flow inference. The experimental results demonstrate that our proposed model exhibits improved performance in terms of both accuracy and speed compared to existing approaches.

Acknowledgements.Our research is supported by Amazon Web Services in the Oxford-Singapore Human-Machine Collaboration Programme and by the ACE-OPS project (EP/S030832/1). We are grateful to all of the anonymous reviewers for their valuable comments.

Figure 6: **Demonstration of Failure Results on Nvidia Dataset. In this demonstration, we present the failure results generated by DynPoint.**