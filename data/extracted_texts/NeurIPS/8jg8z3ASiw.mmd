# Closing the Computational-Statistical Gap in Best Arm Identification for Combinatorial Semi-bandits

Ruo-Chun Tzeng

EECS

KTH, Stockholm, Sweden

rctzeng@kth.se

&Po-An Wang

EECS

KTH, Stockholm, Sweden

wang9@kth.se

Alexandre Proutiere

EECS and Digital Futures

KTH, Stockholm, Sweden

alepro@kth.se

&Chi-Jen Lu

Institute of Information Science

Academia Sinica, Taiwan

cjlu@iis.sinica.edu.tw

###### Abstract

We study the best arm identification problem in combinatorial semi-bandits in the fixed confidence setting. We present Perturbed Frank-Wolfe Sampling (P-FWS), an algorithm that (i) runs in polynomial time, (ii) achieves the instance-specific minimal sample complexity in the high confidence regime, and (iii) enjoys polynomial sample complexity guarantees in the moderate confidence regime. To the best of our knowledge, even for the vanilla bandit problems, no algorithm was able to achieve (ii) and (iii) simultaneously. With P-FWS, we close the computational-statistical gap in best arm identification in combinatorial semi-bandits. The design of P-FWS starts from the optimization problem that defines the information-theoretical and instance-specific sample complexity lower bound. P-FWS solves this problem in an online manner using, in each round, a single iteration of the Frank-Wolfe algorithm. Structural properties of the problem are leveraged to make the P-FWS successive updates computationally efficient. In turn, P-FWS only relies on a simple linear maximization oracle.

## 1 Introduction

An efficient method to design statistically optimal algorithms solving active learning tasks (e.g., regret minimization or pure exploration in bandits and reinforcement learning) consists in the following two-step procedure. The first step amounts to deriving, through change-of-measure arguments, tight information-theoretical fundamental limits satisfied by a wide class of learning algorithms. These limits are often expressed as the solution of an optimization problem, referred in this paper to as the _lower-bound problem_. Interestingly, this solution specifies the instance-specific optimal exploration process: it characterizes the limiting behavior of the adaptive sampling rule any statistically optimal algorithm should implement. In the second step, the learning algorithm is designed so that its exploration process approaches the solution of the lower-bound problem. This design yields statistically optimal algorithms, but typically requires to repeatedly solve the lower-bound problem. This method has worked remarkably well for simple learning tasks such as regret minimization or best-arm identification with fixed confidence in classical stochastic bandits , but also in bandits whose arm-to-average reward function satisfies simple structural properties (e.g., Lipschitz, unimodal) .

The method also provides a natural way of studying the computational-statistical gap  for active learning tasks. Indeed, if solving the lower-bound problem in polynomial time is possible, onemay hope to devise learning algorithms that are both statistically optimal and computationally efficient. As of now, however, the computational complexity of the lower-bound problem remains largely unexplored, except for simple learning tasks. For example, in the case of best policy identification in tabular Markov Decision Processes, the lower-bound problem is non-convex  and its complexity and approximability are unclear.

In this paper, we leverage the aforementioned two-step procedure to assess the computational-statistical gap for the best arm identification in combinatorial semi-bandits in the fixed confidence setting. We establish that, essentially, this gap does not exist (a result that was conjectured in ). Specifically, we present an algorithm that enjoys the following three properties: (i) it runs in polynomial time, (ii) its sample complexity matches the fundamental limits asymptotically in the high confidence regime, and (iii) its sample complexity is at most polynomial in the moderate confidence regime. Next, after formally introducing combinatorial semi-bandits, we describe our contributions and techniques in detail.

**Best arm identification in combinatorial semi-bandits.** In combinatorial semi-bandits , the learner sequentially selects an action from a combinatorial set \(\{0,1\}^{K}\). When in round \(t\), the action \((t)=(x_{1}(t),,x_{K}(t))\) is chosen, the environment samples a \(K\)-dimensional vector \((t)\) whose distribution is assumed to be Gaussian \((,)\). The learner then receives the detailed reward vector \((t)(t)\) where \(\) denotes the element-wise product (in other words, the learner observes the individual reward \(y_{k}(t)\) of the arm \(k\) if and only if this arm is selected in round \(t\), i.e., \(x_{k}(t)=1\)). The parameter \(\) characterizing the average rewards of the various arms is initially unknown. The goal of a learner is to identify the best action \(^{}()=*{argmax}_{} ,\) with a given level of confidence \(1-\), for some \(>0\) while minimizing the expected number of rounds needed. We assume that the best action is unique and denote by \(=\{^{K}:|^{}()|=1\}\) the set of parameters satisfying this assumption. The learner strategy is defined by three components: (i) a sampling rule dictating the sequence of the selected actions; (ii) a stopping time \(\) defining the last round where the learner interacts with the environment; (iii) a decision rule specifying the action \(\) believed to be optimal based on the data gathered until \(\).

**The sample complexity lower-bound problem.** Consider the set of \(\)-PAC algorithms such that for any \(\), the best action is identified correctly with probability at least \(1-\). We wish to find a \(\)-PAC algorithm with minimal expected sample complexity \(_{}[]\). To this aim, using classical change-of-measure arguments , we may derive a lower bound of the expected sample complexity satisfied by any \(\)-PAC algorithm. This lower bound is given by1\(_{}[] T^{}()(,1-)\). The characteristic time \(T^{}()\) is defined as the value of the following problem

\[T^{}()^{-1}=_{}_{ ()},-)^ {2}}{2},\] (1)

where2\(=\{_{}w_{}:_{||}\}\), \((a,b)\) is the KL-divergence between two Bernoulli distributions with respective means \(a\) and \(b\), and \(()=\{:^{}() ^{}()\}\) is the set of _confusing_ parameters. As it turns out (see Lemma 1), \(T^{}()\) is at most quadratic in \(K\), and hence the sample complexity lower bound is polynomial. (1) is a concave program over \(\), and a point \(^{}\) in its solution set corresponds to an optimal allocation of action draws: an algorithm sampling actions according to \(^{}\) and equipped with an appropriate stopping rule would yield a sample complexity matching the lower bound. In this paper, we provide computationally efficient algorithms to solve (1) and show how these can be used to devise a \(\)-PAC best action identification algorithm with minimal sample complexity and running in polynomial time. We only assume that we have access to a computationally efficient Oracle, referred to as the LM (Linear Maximization) Oracle, identifying the best action should \(\) be known (but for any possible \(\)). This assumption, made in all previous work on combinatorial semi-bandits (see e.g. ), is crucial as indeed, if there is no computationally efficient algorithm solving the offline problem \(*{argmax}_{^{}},\) with known \(\), there is no hope to solve its online version with unknown \(\) in a computationally efficient manner. The assumption holds for a large array of combinatorial sets of actions [S\({}^{+}\)03], including \(m\)-sets, matchings, (source-destination)-paths, spanning trees, matroids (refer to  for a thorough discussion).

**The Most-Confusing-Parameter (MCP) algorithm.** The difficulty of solving (1) lies in the inner optimization problem, i.e., in evaluating the objective function:

\[F_{}()=_{()}< ,-)^{2}}{2}>=_{ ^{*}()}f_{}(,)\] (2)

where \(f_{}(,)=_{_{}} <,-)^{2}}{2}>\) and \(_{}=\{^{K}:<, ^{*}()-><0\}\). Evaluating \(F_{}()\) is required to solve (1), but also in the design of an efficient stopping rule. Our first contribution is MCP (Most-Confusing-Parameter), a polynomial time algorithm able to approximate \(F_{}()\) for any given \(\) and \(\). The algorithm's name refers to the fact that by computing \(F_{}()\), we implicitly identify the _most confusing parameter_\(^{*}_{()} ,-)^{2}}{2}\). The design of MCP leverages a Lagrangian relaxation of the optimization problem defining \(f_{}(,)\) and exploits the fact that the Lagrange dual function linearly depends on \(\). In turn, this linearity allows us to make use of the LM Oracle. From these observations, we show that computing \(F_{}()\) boils down to solving a two-player game, for which one of the players can simply update her strategy using the LM Oracle. We prove the following informally stated theorem quantifying the performance of the MCP algorithm (see Theorem 3 for a more precise statement).

**Theorem 1**.: _For any \((,)\), the MCP algorithm with precision \(\) and certainty parameter \(\) returns \(\) and \(}\) satisfying \(_{}[F_{}()(1+)F_{ }()] 1-\) and \(=f_{}}(,)\). The number of calls to the LM Oracle is, almost surely, at most polynomial in \(K\), \(^{-1}\), and \(^{-1}\)._

**The Perturbed Frank-Wolfe Sampling (P-FWS) algorithm.** The MCP algorithm allows us to solve the lower-bound problem (1) for any given \(\). The latter is initially unknown, but could be estimated. A Track-and-Stop algorithm  solving (1) with this plug-in estimator in each round would yield asymptotically minimal sample complexity. It would however be computationally expensive. To circumvent this difficulty, as in , our algorithm, P-FWS, performs a single iteration of the Frank-Wolfe algorithm for the program (1) instantiated with an estimator of \(\). To apply the Frank-Wolfe algorithm, P-FWS uses stochastic smoothing techniques to approximate the non-differentiable objective function \(F_{}\) by a smooth function. To estimate the gradient of the latter, P-FWS leverages both the LM Oracle and the MCP algorithm (more specifically its second output \(}\)). Finally, P-FWS stopping rule takes the form of a classical Generalized Likelihood Ratio Test (GLRT) where the estimated objective function is compared to a time-dependent threshold. Hence the stopping rule also requires the MCP algorithm. We analyze the sample and computational complexities of P-FWS. Our main results are summarized in the following theorem (refer to Theorem 4 for details).

**Theorem 2**.: _For any \((0,1)\), P-FWS is \(\)-PAC, and for any \((,)(0,1)\) small enough, its sample complexity satisfies:_

\[_{}[])^{2}}{T^{*}( )^{-1}-} H)^{2}}{T^{*}()^{-1}-}+(,),\]

_where \(H(x)=(x)+(x)\), \(c>0\) is a universal constant, and \((,)\) is polynomial in \(^{-1}\), \(^{-1}\), \(K\), \(_{}\), and \(_{}^{-1}\), where \(_{}=_{^{*}()}^{*}()-,\). Under P-FWS, the number of LM Oracle calls per round is at most polynomial in \(^{-1}\) and \(K\). The total expected number of these calls is also polynomial._

To the best of our knowledge, P-FWS is the first polynomial time best action identification algorithm with minimal sample complexity in the high confidence regime (when \(\) tends to 0). Its sample complexity is also polynomial in \(K\) in the moderate confidence regime.

## 2 Preliminaries

We start by introducing some notation. We use bold lowercase letters (e.g., \(\)) for vectors, and bold uppercase letter (e.g., \(\)) for matrices. \(\) (resp. \(\)) denotes the element-wise product (resp. sum over \(_{2}\)). For \(^{K},i\), \(^{i}=(x_{k}^{i})_{k[K]}\) is the \(i\)-th element-wise power of \(\). \(D=_{}_{1}\) denotes the maximum number of arms part of an action. For any \(\), we define the sub-optimality gap of \(\) as \(_{}()=^{*}()-,\), and the minimal gap as \(_{}()=_{^{*}()}_{}()\). \(_{}\) (resp. \(_{}\)) denotes the probability measure (resp. expectation) when the arm rewards are parametrized by \(\). Whenever it is clear from the context, we will drop \(\) for simplicity, e.g. \(^{*}=^{*}()\), \(_{}=_{}()\), and \(_{}=_{^{*}}_{}\). Refer to Appendix A for an exhaustive table of notation.

### The lower-bound problem

Classical change-of-measure arguments lead to the asymptotic sample complexity lower bound \(_{}[] T^{}()(,1-)\) where the characteristic time is defined in (1). To have a chance to develop a computationally efficient best action identification algorithm, we need that the sample complexity lower bound grows at most polynomially in \(K\). This is indeed the case as stated in the following lemma, whose proof is provided in Appendix K.

**Lemma 1**.: _For any \(\), \(T^{}() 4KD_{}()^{-2}\)._

We will use first-order methods to solve the lower-bound problem, and to this aim, we will need to evaluate the gradient w.r.t. \(\) of \(f_{}(,)\). We can apply the envelop theorem  to show that for \((,)_{+}\),

\[_{}f_{}(,)=-_{,}^{}())^{2}}{2},\]

where \(_{+}=_{>0}^{K}\), \(_{,}^{}()=*{argmin}_{ (_{})},-)^{2}}{2}\) and \((_{})\) is the closure of \(_{}\) (refer to Lemma 19 in Appendix G.2).

### The Linear Maximization Oracle

As mentioned earlier, we assume that we have access to a computationally efficient Oracle, referred to as the LM (Linear Maximization) Oracle, identifying the best action if \(\) is known. More precisely, as in existing works in combinatorial semi-bandits , we make the following assumption.

**Assumption 1**.: _(i) There exists a polynomial-time algorithm identifying \(^{}()\) for any \(^{K}\); (ii) \(\) is inclusion-wise maximal, i.e., there is no \(,^{}\) s.t. \(<^{}\); (iii) for each \(k[K]\), there exists \(\) such that \(x_{k}=1\); (iv) \(|| 2\)._

Assumption 1 holds for combinatorial sets including \(m\)-sets, spanning forests, bipartite matching, \(s\)-\(t\) paths. For completeness, we verify the assumption for these action sets in Appendix J. In the design of our MCP algorithm, we will actually need to solve for some \(^{K}\) the linear maximization problem \(,\) over \(\{^{}()\}\); in other words, we will probably need to identify the second best action. Fortunately, this can be done in a computationally efficient manner under Assumption 1. The following lemma formalizes this observation. Its proof, presented in Appendix J, is inspired by Lawler's \(m\)-best algorithm .

**Lemma 2**.: _Let \(^{K}\) and \(\). Under Assumption 1, there exists an algorithm that solves \(_{^{}:^{}}, ^{}\) by only making at most \(D\) queries to the LM Oracle._

## 3 Solving the lower bound problem: the MCP algorithm

Solving the lower bound problem first requires to evaluate its objective function \(F_{}()\). A naive approach, enumerating \(f_{}(,)\) for all \(\{^{}\}\), would be computationally infeasible. In this section, we present and analyze MCP, an algorithm that approximates \(F_{}()\) by calling the LM Oracle a number of times growing at most polynomially in \(K\).

### Lagrangian relaxation

The first step towards the design of MCP consists in considering the Lagrangian relaxation of the optimization problem defining \(f_{}(,)=_{_{}} ,-)^{2}}{2}\) (see e.g., ). For any \((,)_{+}\) and \(^{}\), the Lagrangian \(_{,}\) and Lagrange dual function \(g_{,}\) of this problem are defined as, \( 0\),

\[_{,}(,,)= ,-)^{2}}{2}+ ^{}-, g_{,}(,)=_{^{K}} _{,}(,,),\]

respectively. The following proposition, proved in Appendix C.1, provides useful properties of \(g_{,}\):

**Proposition 1**.: _Let \((,)_{+}\) and \(\{^{}()\}\). (a) The Lagrange dual function is linear in \(\). More precisely, \(g_{,}(,)=c_{,}()+ _{,}(),\)__where \(c_{,}()=- ^{-1},^{}()\) and \(_{,}()=-(+ ^{-1}(_{K}-2^{}()))\). (b) \(g_{,}(,)\) is strictly concave (for any fixed \(\)). (c) \(f_{}(,)=_{ 0}g_{,}(,)\) is attained by \(^{}_{}=}()}{^{}(),^{-1}}\). (d) \(\|_{,}(^{}_{})\|_{1}  L_{,}=4D^{2}K\|\|_{}^{2} \|^{-1}\|_{}\)._

From Proposition 1 (c), strong duality holds for the program defining \(f_{}(,)\), and we conclude:

\[F_{}()=_{^{}}_{ 0 }g_{,}(,).\] (3)

\(F_{}()\) can hence be seen as the value in a two-player game. The aforementioned properties of the Lagrange dual function will help to compute this value.

### Solving the two-player game with no regret

There is a rich and growing literature on solving zero-sum games using no-regret algorithms, see for example . Our game has the particularity that the \(\)-player has a discrete combinatorial action set whereas the \(\)-player has a convex action set. Importantly, for this game, we wish not only to estimate its value \(F_{}()\) but also an _equilibrium_ action \(_{c}\) such that \(F_{}()=_{ 0}g_{,}(_{c },)\). Indeed, an estimate of \(_{c}\) will be needed when implementing the Frank-Wolfe algorithm and more specifically when estimating the gradient of \(F_{}()\). To return such an estimate, one could think of leveraging results from the recent literature on last-iterate convergence, see e.g. . However, most of these results concern saddle-point problems only, and are not applicable in our setting. Here, we adopt a much simpler solution, and take advantage of the properties of the Lagrange dual function \(g_{,}(,)\) to design an iterative procedure directly leading to estimates of \((F_{}(),_{c})\). In this procedure, the two players successively update their actions until a stopping criterion is met, say up to the \(N\)-th iterations. The procedure generates a sequence \(\{(^{(n)},^{(n)})\}_{1 n N}\), and from this sequence, estimates \((,})\) of \((F_{}(),_{c})\). The details of the resulting MCP algorithm are presented in Algorithm 1.

\(\)**-player.** We use a variant of the Follow-the-Perturbed-Leader (FTPL) algorithm . The \(\)-player updates her action as follows:

\[^{(n)}*{argmin}_{^{}}\!( _{m=1}^{n-1}g_{,}(,^{(m)})+ }_{n}}{_{n}},)=* {argmin}_{^{}}\!(_{m=1}^{n-1 }_{,}(^{(m)})+}_{n}}{ _{n}},),\]

where \(}_{n}\) is a random vector, exponentially distributed and with unit mean (\(\{}_{n}\}_{n 1}\) are i.i.d.). Compared to the standard FTPL algorithm, we vary learning rate \(_{n}\) over time to get _anytime_ guarantees (as we do not know a priori when the iterative procedure will stop). This kind of time-varying learning rate was also used in  with a similar motivation. Note that thanks to the linearity of \(g_{,}\) and Lemma 2, the \(\)-player update can be computed using at most \(D\) calls to the LM Oracle.

\(\)**-player and MCP outputs.** From Proposition 1, \(f_{}(,)=_{ 0}g_{,}(,)\). This suggests that the \(\)-player can just implement a best-response strategy: after the \(\)-player action \(^{(n)}\) is selected, the \(\)-player chooses \(^{(n)}=^{}_{^{(n)}}=^{(n)}}()}{^{(n)}^{}(),^{-1 }}\). This choice ensures that \(f_{^{(n)}}(,)=g_{,}(^{(n)}, ^{(n)})\), and suggests natural outputs for MCP: should it stops after \(N\) iterations, it can return \(=_{n[N]}g_{,}(^{(n)},^{(n)})\) and \(}*{argmin}_{n[N]}g_{,}(^ {(n)},^{(n)})\).

**Stopping criterion.** The design of the MCP stopping criterion relies on the convergence analysis and regret from the \(\)-player perspective of the above iterative procedure, which we present in the next subsection. This convergence will be controlled by \(_{,}(^{}_{})\) and its upper bound \(L_{,}\) derived in Proposition 1. Introducing \(c_{}=L_{,}(4+)/2})\), the MCP stopping criterion is: \(>c_{}(1+)/()\). Since \(\) strictly increases with \(n\) and since \( F_{}()\), this criterion ensures that the algorithm terminates in a finite number of iterates. Moreover, as shown in the next subsection, it also ensures that \(\) returned by MCP is an \((1+)\)-approximation of \(F_{}()\) with probability at least \(1-\).

### Performance analysis of the MCP algorithm

We start the analysis by quantifying the regret from the \(\)-player perspective of MCP before its stops. The following lemma is proved in Appendix C.3.

**Lemma 3**.: _Let \(N\). Under \((,)(,)\),_

\[_{n=1}^{N}g_{,}(^{(n )},^{(n)})-_{^{}}_{n=1}^{N}g_{ ,}(,^{(n)})}{}  1-.\]

Observe that on the one hand,

\[_{n=1}^{N}g_{,}(^{(n)},^{(n)}) _{n[N]}g_{,}(^{(n)},^{(n)})=\] (4)

always holds. On the other hand, if \(_{}*{argmin}_{^{}} _{ 0}g_{,}(,)\), then we have:

\[_{^{}}_{n=1}^{N}g_{,}(,^{(n)})_{n=1}^{N}g_{, }(_{},^{(n)})_{ 0}g_{,}(_{},)=F_{}().\] (5)

We conclude that for \(N\) such that \((1+)}{}\), Lemma 3 together with the inequalities (4) and (5) imply that \(-F_{}()}{}}{1+}\) holds with probability at least \(1-\). Hence \((1+)F_{}() 1-\). From this observation, we essentially deduce the following theorem, whose complete proof is given in Appendix C.2.

**Theorem 3**.: _Let \(,(0,1)\). Under Assumption 1, for any \((,)_{+}\), the \((,)(,)\) algorithm outputs \((,})\) satisfying \(F_{}()(1+)F_{}() 1-\) and \(=_{ 0}g_{,}(},).\) Moreover, the number of LM Oracle calls the algorithm does is almost surely at most \(}^{2}(1+)^{2}}{^{2}F_{}()^{2}}=\|_{}^{ _{}}^{_{}}\|^{_{}^{-1}} _{}^{2}K^{3}D^{5} K^{-1}}{^{2}F_{}()^{2}}\)._

## 4 The Perturbed Frank-Wolfe Sampling (P-Fws) algorithm

To identify an optimal sampling strategy, rather than solving the lower-bound problem in each round as a Track-and-Stop algorithm would , we devise P-FWS, an algorithm that performs a single iteration of the Frank-Wolfe algorithm for the lower-bound problem instantiated with an estimator of \(\). This requires us to first smooth the objective function \(F_{}()=_{^{}}f_{}(,)\) (the latter is not differentiable at points \(\) where the \(\) is achieved for several sub-optimal actions \(\)). To this aim, we cannot leverage the same technique as in , where \(r\)-subdifferential subspaces are built from gradients of \(f_{}(,)\). These subspaces could indeed be generated by a number of vectors (here gradients) exponentially growing with \(K\). Instead, to cope with the combinatorialdecision sets, P-FWS applies more standard stochastic smoothing techniques as described in the next subsection. All the ingredients of P-FWS are gathered in SS4.2. By design, the algorithm just leverages the MCP algorithm as a subroutine, and hence only requires the LM Oracle. In SS4.3, we analyze the performance of P-FWS.

### Smoothing the objective function \(F_{}\)

Here, we present and analyze a standard stochastic technique to smooth a function \(\). In P-FWS, this technique will be applied to the objective function \(=F_{}\). Let \(:_{>0}^{K}\) be a concave and \(\)-Lipschitz function. Assume that the set of points where \(\) is not differentiable is of Lebesgue-measure zero. To smooth \(\), we can take its average value in a neighborhood of the point considered, see e.g. . Formally, we define the _stochastic smoothed_ approximate of \(\) as:

\[_{}()=_{(B_{2})}[ (+)]\,,\] (6)

where \(B_{2}=\{^{K}:\|\|_{2} 1\}\) and \((0,_{k[K]}_{k})\). The following proposition lists several properties of this smoothed function, and gathers together some of the results from , see Appendix H for more details.

**Proposition 2**.: _For any \(_{+}\) and \((0,_{k[K]}_{k})\), \(_{}\) satisfies: (i) \(()-_{}()()\); (ii) \(_{,}()=_{(B_{2})}[ _{}(+)]\); (iii) \(_{}\) is \(\)-smooth; (iv) if \(>^{}>0\), then \(_{^{}}()_{}()\)._

Note that with (i), we may control the approximation error between \(_{}\) and \(\) by \(\). (ii) and (iii) ensure the differentiability and smoothness of \(_{}\) respectively. (iii) is equivalent to \(_{}(^{})_{}()+ _{}(),^{}-+\|-^{ }\|_{2}^{2},\ ,^{}_{+}\). Finally, (iv) stems from the concavity of \(\), and implies that the value \(_{}()\) monotonously increases while \(\) decreases, and it is upper bounded by \(()\) thanks to (i). The above results hold for \(=F_{}\). Indeed, first it is clear that the definition (2) of \(F_{}\) can be extended to \(^{K}\); then, it can be shown that \(F_{}\) is Lipschitz-continuous and almost-everywhere differentiable - refer to Appendices I and H for formal proofs.

### The algorithm

Before presenting P-FWS, we need to introduce the following notation. For \(t 1\), \(k[K]\), we define \(N_{k}(t)=_{s=1}^{t}\{x_{k}(s)=1\}\), \(_{k}(t)=N_{k}(t)/t\), and \(_{k}(t)=_{s=1}^{t}y_{k}(s)\{x_{k}(s)=1\}\,/N_{k}(t)\) when \(N_{k}(t)>0\).

**Sampling rule.** The design of the sampling rule is driven by the following objectives: (i) the empirical allocation should converge to the solution of the lower-bound problem (1), and (ii) the number of calls to the LM Oracle should be controlled. To meet the first objective, we need in the Frank-Wolfe updates to plug an accurate estimator of \(\) in. The accuracy of our estimator will be guaranteed by alternating between _forced exploration_ and _FW update_ sampling phases. Now for the second objective, we also use forced exploration phases when in a Frank-Wolfe update, the required number of calls to the LM Oracle predicted by the upper bound presented in Theorem 3 is too large. In view of Lemma 1 and Theorem 3, this happens in round \(t\) if \(\|}(t-1)\|_{}\) or \(_{}(}(t-1))^{-1}\) is too large. Next, we describe the forced exploration and Frank-Wolfe update phases in detail.

_Forced exploration._ Initially, P-FWS applies the LM Oracle to compute the _forced exploration set_\(_{0}=\{^{}(_{k}):k[K]\}\), where \(_{k}\) is the \(K\)-dimensional vector whose \(k\)-th component is equal to one and zero elsewhere. P-FWS then selects each action in \(_{0}\) once. Note that Assumption 1 (iii) ensures that the \(k\)-th component of \(^{}(_{k})\) is equal to one. In turn, this ensures that \(_{0}\) is a \([K]\)-covering set, and that playing actions from \(_{0}\) is enough to estimate \(\). P-FWS starts an exploration phase at rounds \(t\) such that \(_{0}|}\) is an integer or such that the maximum of \(_{}(}(t-1))^{-1}\) and \(\|}(t-1)\|_{}\) is larger than \(\). Whenever this happens, P-FWS pulls each \(_{0}\) once.

_Frank-Wolfe updates._ When in round \(t\), the algorithm is not in a forced exploration phase, it implements an iteration of the Frank-Wolfe algorithm applied to maximize the smoothed function \(_{}(t-1),_{t}}(}(t-1))=_{(B_{2})}F_{}(t-1)}(}(t-1) +_{t})\). The sequence of parameters \(\{_{t}\}_{t 1}\) is chosen to ensure that \(_{t}\) chosen in \((0,_{k}_{k}(t))\), and hence \(}(t-1)+_{t}_{>0}^{K}\). Also note that in a round \(t\) where the algorithm is not in a forced exploration phase,by definition \(_{}(}(t-1))>0\). This implies that \(}(t-1)\) and that \(F_{}(t-1)}\) and \(_{}(t-1),_{t}}(}(t-1))\) are well-defined. Now an ideal FW update would consist in playing an action \(^{}(_{}(t-1),_{t}}(}(t -1)))=*{argmax}_{}_{ }(t-1),_{t}}(}(t-1)),\), see e.g. . Unfortunately, we do not have access to \(_{}(t-1),_{t}}(}(t-1))\). But the latter can be approximated, as suggested in Proposition 2 (ii), by \(_{}(t-1),_{t},n_{t}}(}(t-1))= }_{m=1}^{n_{t}} f_{}_{m}}(} (t-1)+_{t}_{m},}(t-1))\), where \(_{1},,_{n_{t}}(B_{2})\), \(}_{m}\) is the action return by \((_{t},_{t})(}(t-1)+_{t}_{m}, }(t-1))\). P-FWS uses this approximation and the LM Oracle to select the action: \((t)^{}(_{}(t-1),_{t},n _{t}}(}(t-1))).\) The choices of the parameters \(_{t}\), \(n_{t}\), \(_{t}\) and \(_{t}\) do matter. \(_{t}\) impacts the sample complexity and should converge to 0 as \(t\) so that \(_{,_{t}}() F_{}()\) at any point \(_{+}\) (this is a consequence of Proposition 2 (i)(iv)). \(_{t}\) should not decay too fast however as it would alter the smoothness of \(_{,_{t}}\). We will show that \(_{t}\) should actually decay as \(1/\). \((n_{t},_{t},_{t})\) impact the trade-off between the sample complexity and the computational complexity of the algorithm. We let \(n_{t}\) and \((_{t},_{t}) 0\) as \(t\) so that \(_{,_{t},n_{t}}()-_{,_{t}}(), 0\) for any \((,)_{+}\).

**Stopping and decision rule.** As often in best arm identification algorithms, the P-FWS stopping rule takes the form of a GLRT:

\[=\{t>4|_{0}|:_{t}}{1+_{t}}> t,(1-_{0}|}), \{_{}(}(t))^{-1},\|}(t)\| _{}\}\},\] (7)

where \(_{t}_{>0}\), \(_{t}\) is returned by the \((_{t},/t^{2})(}(t),}(t))\) algorithm. The function \(\) satisfies

\[ t 1,t_{}(t)}((t)) (t,)(_{}[^{}(}(t))^{}()]),\] (8)

\[ c_{1},c_{2}>0: t c_{1},(t,)( t}{}).\] (9)

Examples of function \(\) satisfying the above conditions can be found in . The condition (8) will ensure the \(\)-correctness of P-FWS, whereas (9) will control its sample complexity. Finally, the action returned by P-FWS is simply defined as \(}=^{}(}())\). The complete pseudo-code of P-FWS is presented in Algorithm 2.3

### Non-asymptotic performance analysis of P-Fws

The following theorem provides an upper bound of the sample complexity of P-FWS valid for any confidence level \(\), as well as the computational complexity of the algorithm.

**Theorem 4**.: _Let \(\) and \((0,1)\). If P-FWS is parametrized using_

\[(_{t},_{t},n_{t},_{t},_{t})=(t^{-},\, _{0}|}},\,[t^{}],\, {16tD^{2}|_{0}|},\,}e^{}}),\] (10)

_then (i) the algorithm finishes in finite time almost surely and \(_{}[}^{}( )]\); (ii) its sample complexity satisfies \(_{}_{ 0}} T^{}()=1\) and for any \(,(0,1)\) with \(<\{1,_{}^{2}}{K},\| \|_{}^{2}}{3}\}\),_

\[_{}[])^{2}}{T^{ }()^{-1}-6} H }{3})^{2}}{T^{}()^{-1}-6}+(,),\]

_where \(H(x)= x+ x+1\) and \((,)\) (refer to (34) for a detailed expression) is polynomial in \(^{-1}\), \(^{-1}\), \(K\), \(\|\|_{}\), and \(_{}()^{-1}\); (iii) the expected number of LM Oracle calls is upper bounded by a polynomial in \(^{-1}\), \(K\), \(\|\|_{}\), and \(_{}()^{-1}\)._

The above theorem establishes the statistical asymptotic optimality of P-FWS since it implies that \(_{ 0}_{}[]\,/(1/) (1+)^{2}/(T^{}()^{-1}-6)\). This upper bound matches the sample complexity lower bound (1) when \( 0\) and \( 0\).

**Proof sketch.** The complete proof of Theorem 4 is presented in Appendix D.

_(i) Correctness._ To establish the \(\)-correctness of the algorithm, we introduce the event \(\) under which \(_{t}\), computed by \((_{t},/t^{2})\)-MCP\((}(t),}(t))\), is an \((1+_{t})\)-approximation of \(F_{}(t)}(}(t))\) in each round \(t 4|_{0}|+1\). From Theorem 3, we deduce that \(_{}[^{c}]_{t=4|_{0}|+ 1}^{}/t^{2}/4|_{0}|\). In view of (8), this implies that \(_{}[}^{} ()]\).

_(ii) Non-asymptotic sample complexity upper bound._

Step 1. (Concentration and certainty equivalence) We first define two _good_ events, \(_{t}^{(1)}\) and \(_{t}^{(2)}\). \(_{t}^{(2)}\) corresponds to the event where \(}(t)\) is close to \(\), and its occurrence probability can be controlled using the forced exploration rounds and concentration inequalities. Under \(_{t}^{(1)}\), the selected action \((t)\) is close to the ideal FW update. Again using concentration results and the performance guarantees of MCP given in Theorem 3, we can control the occurrence probability of \(_{t}^{(2)}\). Overall, we show that \(_{t=1}^{}_{}[(_{t}^{(1)} _{t}^{(2)})^{c}]<\). To this aim, we derive several important continuity results presented in Appendix G. These results essentially allow us to study the convergence of the smoothed FW updates as if the certainty equivalence principle held, i.e., as if \(}(t)=\).

Step 2. (Convergence of the smoothed FW updates) We study the convergence assuming that \((_{t}^{(1)}_{t}^{(2)})\) holds. We first show that \(_{,_{t}}\) is \(\)-Lipschitz and smooth for \(=2D^{2}\|\|_{}^{2}\), see Appendices H and I. Then, in Appendix E, we establish that the dynamics of \(_{t}=_{}\,F_{}()-F_{}(}(t))\) satisfy \(t_{t}(t-1)_{t-1}+(_{t-1}+}{2t_{t}})\). Observe that, as mentioned earlier, \(1/\) is indeed the optimal scaling choice for \(_{t}\). We deduce that after a certain finite number \(T_{1}\) of rounds, \(_{t}\) is sufficiently small and \(\{_{}(}(t))^{-1},\|}(t)\|_{}\}\).

Step 3. Finally, we observe that \(_{}[] T_{1}+_{t=T_{1}}^{} _{}t_{t}(1+_{t})t,(1- _{0}|})+_{t=T_{1}+1}^{} _{}(_{t}^{(1)}_{t}^{ (2)})^{c}\,,\) and show that the second term in the r.h.s. in this inequality is equivalent to \(T^{}()(1/)\) as \( 0\) using the property of the function \(\) defining the stopping threshold and similar arguments as those used in .

_(iii) Expected number of LM Oracle calls._ The MCP algorithm is called to compute \(_{t}\) and to perform the FW update only in rounds \(t\) such that \(\{_{}(}(t))^{-1},\|}(t)\|_{}\}\). Thus, from Theorem 3 and Lemma 1, the number of LM Oracle calls per-round is a polynomial in \(t\) and \(K\). As the \(_{}[]\) is polynomial (in \(^{-1}\), \(K\), \(\|\|_{}\) and \(_{}^{-1}\)), the expected number of LM Oracle calls is also polynomial in the same variables.

Related Work

We provide an exhaustive survey of the related literature in Appendix B. To summarize, to the best of our knowledge, CombGame  is the state-of-the-art algorithm for BAI in combinatorial semi-bandits in the high confidence regimes. A complete comparison to P-FWS is presented in Appendix B. CombGame was initially introduced in  for classical bandit problems. There, the lower-bound problem is casted as a two-player game and the authors propose to use no-regret algorithms for each player to solve it.  adapts the algorithm for combinatorial semi-bandits, and provides a non-asymptotic sample complexity upper bound matching (1) asymptotically. However, the resulting algorithm requires to call an oracle solving the Most-Confusing-Parameter problem as our MCP algorithm. The authors of  conjectured the existence of such a computationally efficient oracle, and we establish this result here.

## 6 Conclusion

In this paper, we have presented P-FWS, the first computationally efficient and statistically optimal algorithm for the best arm identification problem in combinatorial semi-bandits. For this problem, we have studied the computational-statistical trade-off through the analysis of the optimization problem leading to instance-specific sample complexity lower bounds. This approach can be extended to study the computational-statistical gap in other learning tasks. Of particular interest are problems with an underlying structure (e.g. linear bandits , or RL in linear / low rank MDPs ). Most results on these problems are concerned with statistical efficiency, and ignore computational issues.