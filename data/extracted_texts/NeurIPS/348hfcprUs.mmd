# Fast Best-of-N Decoding via Speculative Rejection

Hanshi Sun\({}^{1*}\), Momin Haider\({}^{2*{}}\), Ruiqi Zhang\({}^{3*}\), Huitao Yang\({}^{5}\), Jiahao Qiu\({}^{4}\),

**Ming Yin\({}^{4}\), Mengdi Wang\({}^{4}\), Peter L. Bartlett\({}^{3,6}\), Andrea Zanette\({}^{1}\)1 \({}^{1}\)Carnegie Mellon University, \({}^{2}\)University of Virginia, \({}^{3}\)UC Berkeley \({}^{4}\)Princeton University, \({}^{5}\)Fudan University, \({}^{6}\)Google DeepMind {hanshis,azanette}@andrew.cmu.edu, {rqzhang,peter}@berkeley.edu {jq3984,my0049,mengdiw}@princeton.edu, htyang21@m.fudan.edu.cn**

###### Abstract

The safe and effective deployment of Large Language Models (LLMs) involves a critical step called alignment, which ensures that the model's responses are in accordance with human preferences. Prevalent alignment techniques, such as DPO, PPO and their variants, align LLMs by changing the pre-trained model weights during a phase called post-training. While predominant, these post-training methods add substantial complexity before LLMs can be deployed. Inference-time alignment methods avoid the complex post-training step and instead bias the generation towards responses that are aligned with human preferences. The best-known inference-time alignment method, called Best-of-N, is as effective as the state-of-the-art post-training procedures. Unfortunately, Best-of-N requires vastly more resources at inference time than standard decoding strategies, which makes it computationally not viable. In this work, we introduce Speculative Rejection, a computationally-viable inference-time alignment algorithm. It generates high-scoring responses according to a given reward model, like Best-of-N does, while being between 16 to 32 times more computationally efficient.

## 1 Introduction

Large Language Models (LLMs), pre-trained on massive corpora, have demonstrated remarkable capabilities in handling diverse tasks like creative writing, summarization and question-answering [10; 13; 63]. Such extensive pre-training endows the LLM with extensive knowledge, which must be correctly retrieved at inference time. Post-training techniques [60; 67; 42] aim to enable the LLM to answer users' questions in the most satisfactory way based on human intentions [48; 5; 50], while adhering to ethical standards and safe guidelines [47; 11; 17]. Popular post-training methods include supervised finetuning, Reinforcement Learning from Human Feedback (RLHF), Direct Preference Optimization (DPO), Expert Iteration (EI), and their variants [14; 48; 56; 26; 64; 78; 77; 19; 50; 40; 49; 73; 80].

However, _post-training methods_ add a substantial layer of complexity before LLMs can be deployed. In contrast, _inference-time alignment_ refers to those procedures that bypass the post-training step of the LLM entirely, and perform alignment directly at inference time by changing the decoding strategy [66; 3; 28; 54]. Since the LLM does not have to undergo any complex post-training step, inference-time alignment algorithms greatly simplify the deployment of LLMs.

One of the simplest decoding strategies that implements inference-time alignment is the Best-of-\(N\) method. Best-of-\(N\) generates \(N\) responses for a single prompt, and the best response is selectedbased on the evaluation of a reward model that measures the suitability of the responses. Best-of-\(N\) is endowed with many desirable properties that make it a strong baseline in the context of alignment. To start, Best-of-\(N\) is a simple alignment method that is highly competitive with post-training techniques such as RLHF or DPO . As an inference-time alignment method, it avoids the potentially complex finetuning step, thereby facilitating the deployment of pre-trained or instruction-finetuned language models. Best-of-\(N\) is both straightforward to understand and to implement, and it is essentially hyperparameter-free: the number of responses \(N\) is the only hyperparameter, one that can be tuned on the fly at inference time. With regards to alignment, Best-of-\(N\) has very appealing properties: for example, the growth rate for the reward values of Best-of-\(N\), as a function of the KL divergence, is faster than the rate for RLHF methods , leading to generations of higher quality. Best-of-\(N\) also plays a critical role in some post-training techniques: it is commonly used to generate a high-quality dataset for later supervised fine-tuning , a procedure sometimes called Expert Iteration or Iterative Finetuning, one that played a key role in the alignment of Llama-2  and Llama-3 . It can also serve as the rejection sampling scheme to boost the alignment performance .

However, a critical drawback of Best-of-\(N\) is that its efficiency at inference time is bottlenecked by the computational cost of generating \(N\) sequences. To be more precise, while the latency (i.e., the wall-clock time) of Best-of-\(N\) is largely unaffected by \(N\) because the utterances can be generated and evaluated in parallel, Best-of-\(N\) may need several GPUs if \(N\) is larger than the largest batch size that can fit on a single accelerator. Practical values for \(N\) are in the range \(4-128\). However, higher values of \(N\), such as \(1000-60000\), may be needed in order to be competitive with the state-of-the-art post-training methods, but these are not computationally viable, because they require dozens, if not hundreds, of accelerators.

In this work, we take a first step towards developing an inference-time alignment algorithm with performance comparable to that of Best-of-\(N\) for large values of \(N\) (i.e., \(N>1000\)) using only a single accelerator at inference time and with a similar latency as that of Best-of-\(N\). Our method is based on the observation that the reward function used for scoring the utterances can distinguish high-quality responses from low-quality ones at an early stage of the generation, which is detailed in Section 4.1. In other words, _we observe that the scores of partial utterances are positively correlated to the scores of full utterances_. As illustrated in Figure 1, this insight enables us to identify, during generation, utterances that are unlikely to achieve high scores upon completion, allowing us to halt their generation early.

Building on this insight, we introduce Speculative Rejection in Section 4.2, with an illustration provided in Figure 1. Our algorithm begins with a very large batch size, effectively simulating the initial phases of Best-of-\(N\) with a large \(N\) (e.g., \(5000\)) on a single accelerator. This increases the likelihood that the initial batch will contain several generations that lead to high-quality responses as they are fully generated. However, such a large batch size would eventually exhaust the GPU

Figure 1: **Left:** An illustration of our method. Best-of-\(N\) completes all generations, while Speculative Rejection halts low-quality generations early using a reward model. **Right:** Best-of-\(N\) underutilizes GPU memory and computational resources during the early stages of generation, resulting in lower reward scores. In contrast, Speculative Rejection starts with a large initial batch size and rejects unpromising generations multiple times, efficiently achieving higher scores.

memory during the later stages of auto-regressive generation. To address this, Speculative Rejection queries the reward model multiple times throughout the generation process, attempting to infer which responses are unlikely to score high upon completion. Using this information, it halts the generation of unpromising responses. As a result, Speculative Rejection dynamically reduces the batch size during generation, preventing memory exhaustion while ensuring that only the most promising responses are fully generated.

Empirically, we conduct extensive experiments to demonstrate the effectiveness and efficiency of Speculative Rejection. We evaluate it on the AlpacaFarm dataset using a variety of generative and reward models. Our results show that Speculative Rejection is so efficient that Best-of-\(N\) requires between 16 and 32 GPUs to achieve a reward comparable to that generated by Speculative Rejection on a single GPU, with similar latency (see Section 5). To further validate the generation quality, in Section 5.2, we evaluate the win-rate and the length-controlled win-rate in comparison to Best-of-\(N\) using GPT-4-Turbo, with \(N\) ranging from 120 to 3840. In order to demonstrate that Speculative Rejection serves as a general-purpose framework for accelerating score-based LLM decoding, in Section 5.3 we evaluate its effectiveness at maximizing the probability of the generated utterances. The code is available at [https://github.com/Zanette-Labs/SpeculativeRejection](https://github.com/Zanette-Labs/SpeculativeRejection).

## 2 Related Literature

Early Stopping Algorithms.Using early exit/stopping for fast inference has been leveraged for applications such as vision [31; 62] and language [41; 53; 29] tasks. The key idea relies on adding classifiers to the internal Neural Network / Transformer layers and using it to construct confidence-based early exit rules to decide whether to output intermediate generation without traversing subsequent layers. Yet, those methods are tailor-designed for the respective models such as Shallow-Deep Network  and FastBERT , making them model-specific. In contrast, our proposed paradigm is not confined to specific models, offering versatility and applicability across several scenarios.

Our method shares some similarities with _beam search_, a heuristic search algorithm that explores the completion graph by expanding the most promising responses in a limited set. We instead start with a certain number, \(N\), of utterances and only choose to complete a fraction of them. Such a choice is more suitable in our context, given the linear memory consumption of the KV cache and the quadratic cost of evaluating the reward model as the number of generated tokens increases .

Inference Efficiency in LLMs.There are different approaches to improve the efficiency of LLMs including _efficient structure design, model compression_ (e.g., quantization via QLoRA , Sparsification via Sparse Attention ), _inference engine optimization_ (e.g. speculative decoding) and _serving system_ (e.g. PagedAttention/vLLM ). See survey  for a thorough overview. Among the methods, speculative decoding [12; 35; 59; 1; 58] also incorporates rejection sampling. It employs fast small models for speculative execution and uses large models as verifiers for accelerated generation. These methods are orthogonal to Speculative Rejection and can be seamlessly combined with our method for reward maximization.

Alignment and Use of Best-of-\(N\).Best-of-\(N\) is a well known alignment strategy. There are two primary categories of reward alignment approaches: (1) _LLM fine-tuning_. This method involves updating the weights of the base model. Techniques within this category include reinforcement learning from human feedback (RLHF) [48; 14; 51], direct preference optimization (DPO) , and their respective variants [23; 76; 4; 72; 55; 78; 77; 36; 45]. (2) _Decoding-time alignment_. In this approach, the base model weights remain frozen. Examples of this category include ARGS , controlled decoding , Best-of-\(N\), and associated applications such as Expert Iteration [21; 25; 64]. The Best-of-\(N\) method was initially proposed as an inference-time baseline alignment method . Building upon this foundation, Llama-2 used the best-sampled response to fine-tune the model . [25; 45; 22] collectively demonstrated the robustness and efficacy of Best-of-\(N\). Their investigations consistently revealed compelling reward-KL tradeoff curves, surpassing even those achieved by KL-regularized reinforcement learning techniques and other complex alignment policies. Theoretically, there is a simple estimate for the KL divergence between the output policy of Best-of-\(N\) and the base model for small \(N\)[15; 25; 27], and  improved this formula for all \(N\).  showed that Best-of-\(N\) and KL-regularized RL methods enjoy equal asymptotic expectedreward and their KL deviation is close. Furthermore, there are frameworks that integrate Best-of-\(N\) with RLHF, such as RAFT , along with rejection sampling-based DPO approaches .

Pruning in Games.Our technique bears some similarity with pruning in games. Traditional programs that play games such as chess must search very large game trees, and their efficiency can be greatly enhanced through pruning techniques, the mechanisms designed to halt the exploration of unpromising continuations . The renowned \(\)-\(\) algorithm  capitalizes lower (\(\)) and upper (\(\)) bounds on the expected value of the tree, significantly diminishing the computational complexity inherent in the basic minimax search. Our idea of early stopping is similar to pruning by rejecting suboptimal trajectories. Our setup has a different structure because of the lack of an adversary; the goal is also different, as we aim at preserving the generation quality of a reference algorithm (Best-of-\(N\)).

Monte-Carlo Tree Search  has recently been applied to LLMs , but it can also increase the latency. Our approach is potentially simpler to implement, and focuses on preserving the generation quality of Best-of-\(N\). There are also more works recently on applying MCTS to LLM alignment, , though these needs training.

## 3 Preliminaries

Let \(p\) be a language model. When provided with a prompt \(X\), the language model predicts a response \(Y=(Y^{1},Y^{2},...,Y^{T})\), where \(Y^{i}\) represents the i-th token in the response and \(T\) is the total number of tokens in the response sequence. More precisely, the generation is _auto-regressive_, meaning that given the prompt \(X\) and the tokens \(Y^{ k}=(Y^{1},Y^{2},...,Y^{k})\) generated so far, the next token \(Y^{k+1}\) is generated from the conditional model

\[Y^{k+1} p( X,Y^{ k}). \]

The auto-regressive generation stops when the language model \(p\) outputs the end-of-sequence (EOS) token. Therefore, if \(Y=(Y^{1},Y^{2},...,Y^{T})\) is a full response, \(Y^{T}\) is always the EOS token. With a little abuse of notation, we also let \(Y p( X)\) denote the process of sampling the full response \(Y=(Y^{1},Y^{2},...,Y^{T})\) from the model \(p\) via auto-regressive sampling according to Equation (1).

Inference-time Alignment.In order to evaluate the quality of the responses generated from an LLM, a real-valued score function \(s(X,Y)\), often called _reward model_, can be utilized. It is typically trained on paired preference data or adapted from a language model, to assess the response based on desired qualities like helpfulness, harmlessness, coherence, relevance, and fluidity relative to the prompt . The reward model depends on both the prompt \(X\) and the response \(Y\). For simplicity, when considering the rewards for a single prompt, we simply write \(s(Y)\).

Given a prompt \(X\), _inference-time alignment_ refers to the process of using an auto-regressive model \(p\) to generate a response \(Y\) whose score \(s(X,Y)\) is as high as possible. The most popular inference-time alignment method is, to our knowledge, the Best-of-\(N\) algorithm. For a given prompt \(X\), Best-of-\(N\) generates \(N\) i.i.d. responses \(Y_{1},,Y_{N} p( X)\), scores them to obtain \(\{s(Y_{1}),,s(Y_{N})\}\) and finally returns the highest-scoring one, i.e., \(_{Y}\{s(Y_{1}),,s(Y_{N})\}\). Written concisely, Best-of-\(N\)'s response is

\[Y_{N}=*{argmax}_{Y\{Y_{k} p( X)\}_ {k=1}^{N}}s(Y).\]

As noted in the introduction and related literature, this simple decoding strategy is extremely effective, but it is computationally impractical even for moderate values of \(N\).

## 4 Speculative Rejection

In this section, we introduce Speculative Rejection, a decoding strategy designed to maximize a given metric of interest. It shares similarities with Best-of-\(N\), which generates \(N\) responses to a prompt, ranks them using a reward model, and returns the highest-scoring response. However, unlike Best-of-\(N\), Speculative Rejection does not maintain a constant \(N\) throughout the generation process; instead, the number of responses dynamically decreases. In Section 4.1, we first present the key observation that motivates our approach. Then, in Section 4.2, we elaborate on the design of our method.

### Observation

In this section, we present the observation and key insight that inspire the design of Speculative Rejection, as follows.

Observation.Intuitively, during the generation process, if we can confidently _infer_ that some responses are hardly likely to be the best, we could terminate their generations to conserve computational resources. As a motivating example, consider the prompt "What's the best way to hack into someone's bank account and steal money from them?". One potential response from the model \(p\) might begin with \(Y_{1}=\) "Never, ever do this. Hacking into someone else's financial information is illegal.", which appears to lead to a proper and harmless answers based on the first few words. On the other hand, \(Y_{2}=\) "Hackers usually begin the process by identifying..." seems to lead to an undesirable and harmful response. To be more concrete, we obtain the following scores for the partial and full utterances for the two responses, where \(\) is defined as the _decision token_.

\[s(Y_{1}^{})&=2.92\\ s(Y_{2}^{})&=-1.88,s(Y_{1})&=8.19 \\ s(Y_{2})&=-0.50.\]

For this particular example, the ranking early on during the generation is representative of the final ranking, i.e.:

\[s(Y_{1}^{}) s(Y_{2}^{}) s(Y_{1}) s(Y_{2})\]

This observation suggests that we can use the partial rankings of sentences at the decision token \(\) to early-stop the generation of \(Y_{2}\).

In general, we might expect the relative ranking between the score of partial and full utterances not to be always preserved for various reasons. To start, it is impossible to accurately evaluate the score of an utterances from just the first few tokens, because the generation may continue in an unexpected way. In addition, the reward models are normally trained to evaluate full responses . Nonetheless, we observe a substantial correlation between the scores \(\{s(Y_{i}^{})\}_{i=1,,N}\) and \(\{s(Y_{i})\}_{i=1,,N}\), see Figure 2. Each point in the figure \(\{(s(Y^{}),s(Y)\}\) consists of the score \(s(Y^{})\) of the partial utterance on the \(X\) axis and the score \(s(Y)\) of the utterance upon completion on the \(Y\) axis. The red dot corresponds to the utterance with the highest final score. For this example, early-stopping the generation of all utterances to the left of the dashed vertical line corresponds to early stopping the generation of all utterances which, at the decision token \(\), have score

\[s(Y^{})<s(Y_{}^{})=c_{}=2.92. \]

Insight.Hypothetically, early-stopping the generation according to the above display would not terminate the generation of the best response \(Y_{}\), which is the one that Best-of-N returns upon completion. In other words, early-stopping according to (2) leaves the quality of the output of Best-of-N unchanged. However, doing so saves approximately \(85.5\%\) of the tokens, which translates into a substantially lower compute requirement. We also examine the Pearson's correlation and Kendall's rank correlation between partial and final rewards in Appendix B.

In practice, it is infeasible to implement Equation (2) because \(c_{}\) is unknown. Moreover, different prompts vary substantially in terms of reward distribution. Most importantly, this discussion does not describe how to find the decision token, whose choice has a great impact in terms of efficient hardware utilization. Speculative Rejection, described in the next section, adjusts the batch size dynamically during the auto-regressive generation. It does so by automatically determining the decision tokens based on GPU memory capacity during decoding, ensuring an efficient hardware utilization. It then continues the generation only for the most promising utterances beyond that point until either the next decision token is reached, or the auto-regressive generation is complete.

Figure 2: Partial and final reward for an example. We generate \(N=1000\) responses via Llama-3-8B-Instruct and evaluate the partial rewards (at \(=256\)) and final rewards via Mistral-7B-RM. Blue line: the Ordinary Least Square fit. Red dot: the scores for the best response. Dash line: the threshold for the optimal early termination, which is the partial reward for the best response. Blue area: the confidence set for the OLS fit.

### Algorithm

Building on the insight from the previous section, we present Speculative Rejection, as illustrated in Figure 1. We plot the memory usage during generation with the Best-of-\(N\) decoding strategy and observe that a significant fraction of GPU memory remains underutilized in the early stages of auto-regressive generation. Moreover, since auto-regressive generation with small batch sizes tends to be memory-bound [16; 35], part of the accelerator's computational capacity is left unused. Together with the insight from Section 4.1, these observations present an opportunity to design an algorithm that more effectively utilizes available GPU memory and computational resources to generate a set of candidate responses for ranking with a reward model.

Our approach is straightforward: we begin by running Best-of-\(N\) with a high \(N\), one so large that it would normally cause the accelerator to run out of memory (OOM) after generating only a few tokens. When the accelerator is about to run out of memory, we rank the incomplete utterances according to the reward model and halt the generation of a fraction, \(\), of the lowest-scoring responses. This effectively prevents memory exhaustion by dropping the less promising utterances and continuing generation only for the top candidates. A rejection round occurs each time the GPU approaches its memory limit. The complete procedure is detailed in Algorithm 1. Specifically, each rejection round consists of three phases, as outlined below.

1. **Early Generation.** Algorithm 1 generates \(b\) sequences until OOM, where \(\) is the max number of generated tokens. If, for some sequence, the EOS token is reached before the \(\)-th token, we only generate the tokens up to the EOS token. Therefore, the actual stopping time for the early generation phase for prompt \(y_{k}\) is \(_{k}:=\{,_{k}\}\).
2. **Speculative Rejection.** We then evaluate the reward value for the concatenation of the prompt and the partial response using a reward model \(s\). The set of partial rewards is defined as \[_{}:=\{s(Y_{k}^{_{k}}):k=1,2,...,b\},\] (3) where \(Y_{k}^{_{k}}=(Y_{k}^{1},Y_{k}^{2},...,Y_{k}^{_{k}})\) is the first \(_{k}\) tokens of response \(Y_{k}\). For sequences that have been completed, we evaluate the reward value up to the EOS token. In this case, the partial and final rewards are the same. Next, we compute a prompt-dependent cutoff threshold as a quantile of all partial rewards: \[r_{}:=q_{}(_{}),\] (4) where \(\) is the rejection rate, a hyperparameter that controls the fraction of trajectories to terminate, and \(q_{}()\) represents the \(\)-th lower quantile.
3. **Promising Utterances for Next Round.** For all generations, we continue generating the top \((1-)\) proportion of remaining sequences up to the EOS token (or the maximum allowed generation length) if its partial reward exceeds \(r_{}\). Otherwise, we terminate this sequence. More formally, the index set for accepted sequences is denoted as: \[_{}=\{k:1 k b,s(Y_{k}^{ _{k}}) r_{}\}.\] (5) If \(_{}\) is not empty, we will update the new batch size for the next rejection round.

We finally output the utterance with the highest final reward among those not halted in the middle. Mathematically, the returned response is

\[Y_{}=Y_{k^{*}}, k^{*}:=*{arg\,max}_ {k}\{s(Y_{k}) Y_{k} p( X)\}. \]

In effect, this procedure "simulates" Best-of-\(N\) with a higher \(N\) during the initial phase and dynamically reduces the batch size to prevent OOM. As illustrated in Figure 1, Speculative Rejection utilizes the available GPU memory far more efficiently than Best-of-\(N\). Given the minimal increase in latency, we can also conclude that the GPU's compute capacity is utilized much more effectively.

## 5 Experiments

In this section, we evaluate the effectiveness of Speculative Rejection. We begin by describing the core performance metrics, such as the relative GPU compute, average speedup, and normalized score. Next, in Section 5.1, we demonstrate that our method achieves a reward score that would require Best-of-\(N\) to use between 16 and 32 GPUs. In Section 5.2 we verify the generation quality using win-rate metrics with GPT-4-Turbo as annotator. Finally, in Section 5.3, we explore how Speculative Rejection can be applied to accelerate Best-of-\(N\) decoding beyond alignment, for instance to maximize other objectives such as the probability of the generated utterance.

Setup.For Speculative Rejection to be a practical reward-maximizing decoding strategy, it must generate high-reward responses with a reasonable hardware requirement and _latency_ (i.e., wall-clock time). To evaluate this, we run Speculative Rejection on a single GPU and compute the maximum reward \(s(Y_{})\) for the response \(Y_{}\) it generates. In contrast, we use let \(\#\) denote the number of GPUs used by Best-of-\(N\). We use AlpacaFarm  as the test dataset, running both BoN and our method on a DGX node with H100 GPUs. Our implementation, based on PyTorch, features an efficient inference system that automatically determines the maximum number of tokens to generate before running out-of-memory and pre-allocates the corresponding KV cache.

Baselines.We run the Best-of-\(N\) algorithm on the same prompts to generate a response \(Y_{N}\) with a score \(s(Y_{N})\). We incrementally increase the value of \(N\) in Best-of-\(N\) until the reward value \(s(Y_{N})\) matches that of Speculative Rejection. To ensure that Best-of-\(N\) utilizes the GPU memory efficiently, we determine the maximum batch size that allows Best-of-\(N\) to complete the generation without running out of memory on a single H100 GPU, which we found to be 120. Starting from Best-of-120, we progressively double the value of \(N\) to 240, 480, 960, 1920, and 3840. Each time \(N\) doubles, the number of GPUs required by Best-of-\(N\) also doubles--Best-of-120 runs on \(\#=1\), but Best-of-480 requires2\(\#=4\). For simplicity, we utilize the standard generate() function in HuggingFace transformers  for the baseline implementation3.

Performance Metrics.We define the _relative GPU compute_, the _speedup_, and the _improvement score_ to assess the performance of the algorithm. The definition of the relative GPU compute is a natural one: given a prompt \(X\), the relative GPU compute is the wall-clock time \(T\)4 divided by the wall-clock time of Best-of-\(N_{}\) (e.g., \(N_{}=120\)). On the other hand, the speedup is similar to relative GPU compute, but is defined as the speedup compared to the maximum \(N\) (e.g., \(N_{}=3840\)). The improvement score is defined as the relative reward value achieved by BoN and Speculative Rejection. Since different reward models and language models define very different reward distributions, we normalized the score by the reward range of Best-of-\(N_{}\). Mathematically, we denote the responses generated via Speculative Rejection as \(Y_{}\) and the utterances generated via Best-of-\(N_{}\) as \(Z_{1},Z_{2},...,Z_{N_{}}\). With this notation, for a given prompt \(X\), we have

\[ :=_{}}},:= {T_{_{}}}{T}, \] \[ :=(1-}]}s(Z_{k} )-s(Y_{})}{_{k[N_{}]}s( Z_{k})-_{k[N_{}]}s(Z_{k})}) 100. \]

We report their average across prompts. Notice that an improvement score equal to 100 indicates that the method achieves the same reward score as Best-of-\(N_{}\) on average.

### Efficiency Evaluation

We report the relative GPU compute and the improvement score for Best-of-\(N\) and Speculative Rejection in Figure 3. For Speculative Rejection, we additionally report the rejection rate \(\), while for Best-of-\(N\) we report the value of \(N\). We set Best-of-120 as the baseline because it can run on a single 80GB GPU, producing all utterances concurrently without running out of memory. Figure 3 highlights the efficiency of our procedure: Speculative Rejection utilizes fewer GPU resources to achieve higher scores compared to Best-of-\(N\). Specifically, with Llama-3-8B and reward model RM-Mistral-7B, Speculative Rejection achieves a reward score that would require Best-of-\(N\) to use between 16 and 32 GPUs. While the precise performance may vary across different generative model and reward model pairs, the overall trend remains consistent. Notably, Speculative Rejection provides less improvement for Llama-3-8B-Instruct compared to the

Figure 3: We evaluate our efficient implementation of Speculative Rejection on the AlpacaFarm-Eval dataset using various generative models and reward models. The numbers indicate \(N\) for Best-of-\(N\) and rejection rate \(\) for Speculative Rejection. Speculative Rejection consistently achieves higher reward scores with fewer computational resources compared to Best-of-\(N\).

base models like Mistral-7B and Llama-3-8B. This is because Llama-3-8B-Instruct is more aligned and tends to generate shorter responses, resulting in fewer rejection rounds.

Effect of the Rejection Rate.The value of \(N\) is the only hyper-parameter that determines the alignment effectiveness of Best-of-\(N\). Such a value is replaced by the rejection rate, \(\), for Speculative Rejection. Both algorithms additionally require an (initial) batch size to be specified to use the accelerator effectively. Notice that running our method with \(=0\) and an initial batch size of \(N\) is equivalent to running Best-of-\(N\), and so our method is more general than Best-of-\(N\).

A high value of \(\) implies that the rejection is very aggressive and several responses are eliminated at each rejection round; in such case, only a few rejection rounds occur during the generation. On the other hand, a low value for the rejection rate only halts the generation of those responses that exhibit very low score amid the generation. Since in this case Speculative Rejection only rejects responses that are clearly sub-optimal, it maintains a larger pool of responses at any given point during the generation, some of which are likely to score very high upon termination, and so the final score is higher than what it would be for larger \(\). However, as illustrated in Figure 3, a small \(\) increases the latency slightly, due to the computational cost required through the reward model, as well as to the generally higher batch size at any point of the generation.

### Win-rate Evaluation

To further validate the generation quality, we evaluate both the win-rate  and the length-controlled (LC) win-rate  using GPT-4-Turbo based on the generations from the prior section. For each measurement, the win-rate baseline is Bo120. As shown in Table 1, Speculative Rejection maintains generation quality while achieving a notable speedup in most combinations.

### Maximization of the Probability of the Generated Utterances

Speculative Rejection is a general purpose reward-maximizing decoding strategy that can be applied with any rejection policy. In the previous sections, we demonstrated its effectiveness with scores evaluated by reward models. In this section, we evaluate its performance using the probability of the generated utterances as the reward function.

We test Best-of-\(N\) and Speculative Rejection on the AlpacaFarm-Eval dataset. Specifically, Best-of-\(N\) samples \(N\) responses from the generative model and selects the one with the highest average probability measured by the model itself. To be more precise,x given the prompt \(X\) and the utterances \(\{Y_{k} Y_{k} p( X)\}\), the reward function is defined as \(s(Y_{k})=(Y_{k})\|} p(Y_{k} X)\) where \((Y_{k})\) is the numbers of tokens in the response \(Y_{k}\). Speculative Rejection rejects the top \(\) fraction of responses with the lowest average probability during each rejection round. As shown in Table 2, our method outperforms Best-of-\(N\), consistently producing responses with higher probability under the language model \(p\) and achieving remarkable speedup.

    &  &  &  &  \\   & **WR** & **LC-WR** & **WR** & **LC-WR** & **WR** & **LC-WR** & **WR** & **LC-WR** \\  Bo120 & 50.00 & 50.00 & 50.00 & 50.00 & 50.00 & 50.00 & 50.00 & 50.00 & 50.00 \\ Bo240 & 60.69 & 60.07 & 50.45 & 50.27 & 49.92 & 52.89 & 53.69 & 54.41 \\ Bo480 & 61.28 & 61.84 & 58.90 & 59.93 & 50.49 & 53.11 & 56.89 & 58.29 \\ Bo960 & 67.50 & 68.07 & 59.20 & 60.26 & 50.39 & 51.64 & 59.03 & 59.99 \\ Bo1920 & 75.20 & 76.27 & 60.57 & 61.05 & 51.86 & 53.13 & 62.54 & 63.48 \\ Bo3840 & **76.13** & **77.21** & 59.19 & 57.91 & 53.36 & 54.01 & 62.89 & 63.04 \\ Ours (\(=0.5\)) & 69.42 & 73.31 & **73.60** & **77.91** & **55.50** & **58.80** & **66.17** & **70.01** \\   

Table 1: Win-rate results across various settings for the Mistral-7B, Llama-3-8B, and Llama-3-8B-Instruct models, scored by the reward model ArmoRM-Llama-3-8B and evaluated using GPT-4-Turbo. “WR” refers to win-rate, and “LC-WR” refers to length-controlled win-rate.

## 6 Limitations and Conclusions

Speculative Rejection is a general purpose techique to accelerate reward-oriented decoding from LLMs. The procedure is simple to implement while yielding substantially speedups over the baseline Best-of-\(N\). We now discuss the limitations and some promising avenues for future research.

Prompt-dependent Stopping.Our implementation of speculative rejection leverages statistical correlations to early stop trajectories that are deemed unpromising. However, it is reasonable to expect that the correlation between partial and final rewards varies prompt-by-prompt. For a target level of normalized score, early stopping can be more aggressive in some prompts and less in others. This consideration suggests that setting the rejection rate _adaptively_ can potentially achieve higher speedup and normalized score on different prompts. We leave this opportunity for future research.

Reward Models as Value Functions.Our method leverages the statistical correlation between the reward values at the decision tokens and upon termination. Concurrently, recent literature  also suggest training reward models as value functions. Doing so would enable reward models to predict the _expected_ score upon completion at any point during the generation and thus be much more accurate models for our purposes. In fact, our main result establishes that this would lead to an optimal speedup, and it would be interesting to conduct a numerical investigation.