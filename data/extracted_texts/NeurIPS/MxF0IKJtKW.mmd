# SlimGPT: Layer-wise Structured Pruning for Large Language Models

Gui Ling, Ziyang Wang, Yuliang Yan1, Qingwen Liu

Alibaba Group

{linggui.lg, shanyi.wzy, yuliang.yyl, xiangsheng.lqu}@alibaba-inc.com

###### Abstract

Large language models (LLMs) have garnered significant attention for their remarkable capabilities across various domains, whose vast parameter scales present challenges for practical deployment. Structured pruning is an effective method to balance model performance with efficiency, but performance restoration under computational resource constraints is a principal challenge in pruning LLMs. Therefore, we present a low-cost and fast structured pruning method for LLMs named _SlimGPT_ based on the Optimal Brain Surgeon framework. We propose Batched Greedy Pruning for rapid and near-optimal pruning, which enhances the accuracy of head-wise pruning error estimation through grouped Cholesky decomposition and improves the pruning efficiency of FFN via Dynamic Group Size, thereby achieving approximate local optimal pruning results within one hour. Besides, we explore the limitations of layer-wise pruning from the perspective of error accumulation and propose Incremental Pruning Ratio, a non-uniform pruning strategy to reduce performance degradation. Experimental results on the LLaMA benchmark show that SlimGPT outperforms other methods and achieves state-of-the-art results.

## 1 Introduction

Large Language Models (LLMs) [1; 2; 3] have made significant strides in various natural language processing tasks, leading to the emergence of novel applications such as AI agents . One of the factors contributing to the exceptional capabilities of LLMs is their massive parameter scales. However, these extensive parameters also introduce increased inference costs and deployment challenges, hindering the widespread application and adoption of LLMs. Accelerating inference for LLMs has become a focal point of current research. Model compression , as one of the strategies for inference acceleration, including techniques like pruning and quantization [6; 7], has been extensively researched. Nevertheless, earlier model compression techniques, particularly model pruning, typically rely on heavy post-training to recover the model's capabilities, which typically involves retraining with the entire training dataset. Given the constraints of current computational resources, the above approaches are not feasible for LLMs.

In the domain of LLM pruning, recent studies have largely focused on unstructured (or semi-structured) pruning , a method that shrinks models by selectively zeroing out weights considered non-critical. Despite its advancements, unstructured pruning falls short in substantially reducing parameter count, which is crucial for accelerating LLM inference as it is often bottlenecked on memory bandwidth and communication . To accelerate inference speed, unstructured pruning models are often paired with specialized frameworks or hardware solutions. Conversely, _structured pruning_[10; 11] effectively decreases the model's parameter count by systematically eliminating columns or rows from weight matrices, enabling significant improvements in inference speed, andreduce deployment cost on conventional hardware. Yet, structured pruning often entails more pronounced compromises in model performance, which poses a greater challenge.

Recently, researchers have applied the classic Optimal Brain Surgeon (OBS) framework to the compression of LLMs. This approach includes parameter compensation which can mitigate the loss incurred during compression and reduce the dependence on post-training. The OBS framework is currently applied in the areas of unstructured pruning  and quantization  for LLMs. However, there exist some challenges in its application to structured pruning:

* The OBS is a fine-grained compression framework that compresses one parameter at each iteration, whereas structured pruning has a minimum granularity of either a column or head. Directly applying the OBS framework will result in high numerical errors, impairing model performance.
* The OBS is essentially a layer-wise compression method. It focuses on each individual layer, thus failing to allocate pruning ratios for each layer rationally using global information (such as global gradients). This is crucial for LLM structured pruning, which relies on a non-uniform strategy to reduce the impact on performance.

To address these issues, we propose a new structured pruning method for LLMs. We introduce Batched Greedy Pruning to achieve low-cost and rapid pruning for LLMs. Specifically, for attention heads, we propose grouped Cholesky decomposition to select nearly optimal heads for pruning in each iteration, thereby maintaining an approximately locally optimal pruning result. For Feed-Forward Networks (FFNs), we achieve near-optimal and efficient pruning results through Dynamic Group Size. Furthermore, since the OBS is essentially a layer-wise compression framework, we investigate the error accumulation phenomenon in layer-wise pruning and propose pruning by Incremental Pruning Ratio, a straightforward non-uniform strategy to control the pruning rate of each layer, further mitigating performance loss under a given overall pruning ratio.

**Contribution.** In this paper, we propose SlimGPT, a layer-wise pruning approach that extends the classical OBS framework to structured pruning for LLMs. The characteristics of SlimGPT can be summarized as follows: **(i)** Task-agnostic pruning scheme. Only a random sample of data from generic pre-training corpora is needed as a calibration set, and we can obtain a compressed model with most performance preserved; **(ii)** Low-cost, low-resource, and time-efficient compression scheme. The model can be compressed using just a single GPU, a few hundred of calibration data, and about one hour; **(iii)** A universal pruning method for Transformer-based models. It has good transferability and, theoretically, is applicable to all large models based on the conventional Transformer architecture. We employ LLaMA models for pruning and conduct evaluations on wikitext2 and Commonsense Reasoning tasks. The results indicate that SlimGPT substantially retains the performance of the pruned models, surpassing state-of-the-art methods.

## 2 Related Work

**Compression methods with regularization.** Before the era of LLMs, using the scaling factors from Batch Normalization layers as indicators of channel importance made pruning based on regularization a very popular method [14; 15]. Notably, Louizos et al.  implemented the non-differentiable L0 penalty in a differentiable form, a technique frequently used for pruning in large models. Compresso  combines L0 regularization with LoRA training , effectively preserving model performance at a low cost. In a similar vein, Sheared LLaMA  employs augmented L0 regularization on inserted masks for structured pruning, using extensive data to restore performance and deliver compact yet powerful pruned models.

**Global gradient-based compression methods**. NVIDIA's works [20; 21] involve a Taylor expansion of the global loss. By eliminating higher-order terms, it is revealed that the impact of a weight on the loss can be assessed using the magnitude of the weight combined with gradient information. Based on this, LLM-Pruner  employs a first-order importance estimation to gauge the importance of weights. LORAPrune  measures the importance of weights based on the gradients of the LORA parameters rather than the model's parameters, achieving commendable results.

**Outliers-dependent compression methods**. Dettmers et al.  identifies an attribute unique to LLMs, where a small subset of activation values in the data features have magnitudes significantly larger than the others. And removing corresponding weights impacts model performance substantially. Building upon this, Wanda  proposes a simple yet effective unstructured pruning method, usingthe product of a weight's L1 norm and the L2 norm of eigenvalues to gauge its importance, achieving impressive pruning results. OWL  determines layer-wise sparsity ratios based on Layerwise Outlier Distribution (LOD), obtaining substantial performance gains at high sparsity levels.

**Layer-wise compression methods**. The early works [26; 27] provide a layer-wise compression framework with a locally optimal solution named Optimal Brain Surgeon (OBS). And then OBC  reduces the computational burden by converting layer-wise pruning into row-wise pruning and updating the inverse Hessian using a proposed formula. Furthermore, GPTQ  accelerates the process with Lazy Batch-Updates and Cholesky Reformulation, enabling the application of this method to the quantization of LLMs. SparseGPT  also adapts this approach for unstructured pruning of LLMs. However, there appears to be no existing research that has implemented OBS in structured pruning for LLMs.

**Structured Pruning vs. Other Techniques**. Given that OBS has previously been used in both quantization and unstructured pruning, and is now being applied to structured pruning, there is an inherent consistency across these three compression schemes. These methods actually compress the model at varying levels of granularity. Quantization, which "trims" floating-point precision, represents the finest granularity and delivers excellent compression outcomes. Structured pruning, on the other hand, involves trimming weight vectors and represents the coarsest granularity, naturally resulting in higher performance losses compared to other methods, which poses significant challenges. For small models, it is possible to recover most of the performance with post-training, but this is challenging to achieve in LLMs due to resource constraints. Nonetheless, structured pruning effectively reduces the number of parameters without needing special inference framework support and is compatible with the other two methods, thus still holding considerable potential for application.

## 3 Preliminary

**Layer-Wise Pruning.** Consider the scenario of pruning on a well-optimized model, known as post-training pruning, a prevalent approach involves decomposing the global model pruning challenge into layer-wise subproblems (_i.e.,_ Layer-wise pruning), which are typically modeled as issues of minimizing L2 error. Specifically, let \(_{l}\) represent the weights of the \(l\)-th layer of a pretrained model and \(X_{l}\) be the input features for layer \(l\). The goal is to determine pruned weights \(}_{l}\) that achieve a predefined pruning ratio while minimizing the squared error:

\[_{}_{l}}\|_{l}X_{l}-}_{l }X_{l}\|_{2}^{2}.\] (1)

**Optimal Brain Surgeon (OBS) Framework.** As Equation 1 can be rewritten as the sum of square error of each row of the weights to be pruned, the layer-wise pruning can be further split into row-wise pruning . Consider the removal of a single weight from a row in \(W_{l}\), Equation 1 has a closed-form solution . Let \(w\) denote a specific weight in a row of \(W_{l}\), and let \(p\) be its corresponding index. Given that our optimization objective is to minimize row-wise squared error, the Hessian of this objective with respect to the weight row of layer \(l\) is given by \(H_{l}=2X_{l}X_{l}^{T}\). The weight to be pruned, \(w_{p}\), as well as the necessary update \(_{p}\) applied to the remaining weights of the same row to counterbalance the removal, can be determined through the following calculation:

\[w_{p}=_{w_{p}}^{2}}{H_{p,p}^{-1}},\ _{p}=-}{H_{p,p}^{-1}} H_{:,p}^{-1},\] (2)

where \(H_{p,p}^{-1}\) denotes the \(p\) th diagonal entry of the inverse Hessian, and \(H_{:,p}^{-1}\) is its \(p\) th column. By iteratively using Equation 2 to remove one weight and update the remaining weights in the same row, one can obtain a locally optimal compressed model. After each iteration, \(H\) will be updated by removing the \(p\) row and column, which is represented by \(H_{[-p]}\), here we use \([-p]\) to indicate the removal of \(p\) row and column of the matrix. As \(H^{-1}\) cannot be updated by simple removal as \((H_{[-p]})^{-1}(H^{-1})_{[-p]}\), to avoid the expensive full recomputations of \(H^{-1}\), the following formula is proposed to quickly update \(H^{-1}\):

\[(H_{[-p]})^{-1}=(H^{-1}-^{-1}}H_{:,p}^{-1}H_{p,:}^{-1})_{[-p]}.\] (3)

This framework can be practically applied to medium-sized models. However, for models with billions of weights, the iterative pruning becomes exceedingly time-consuming.

Methodology

In this section, by extending the OBS framework to structured pruning, we introduce SlimGPT from two aspects: (1) By employing **Batched Greedy Pruning** to reduce error computation, we minimize the performance degradation caused by pruning while also accelerating the pruning speed; (2) By analyzing the limitation of layer-wise pruning from the perspective of error accumulation, we introduce **Incremental Pruning Ratio**, a non-uniform pruning strategy.

### Structured Pruning with OBS Framework

As mentioned above, the pruning between different rows is independent, making it possible to prune all rows simultaneously . We extend the OBS framework to structured column pruning, _i.e.,_ pruning one column at a time and compensating the rest columns using the following formula:

\[W_{:,p}=_{W_{:,p}}^{2}}{H_{p,p}^{-1}},\ \ =-}{H_{p,p}^{-1}} H_{p,:}^{-1},\] (4)

where \(H_{p,:}^{-1}\) denotes the \(p\)-th row of \(H^{-1}\), and the obtained \(\) is a compensation matrix of the same size as \(W\). We following previous works employ attention blocks and FFNs as the smallest units for pruning. By pruning the columns of the output matrix in attention blocks and the dimensionality reduction matrix in FFN blocks, we reduce the number of attention heads and FFN channels, thereby decreasing the model's parameter count.

However, the above formula cannot be applied directly, as iteratively finding and pruning the column with the minimum error is time-consuming. More critically, the structural dependency in attention blocks imposes additional constraints on column pruning, making it impossible to evaluate the importance of a head based solely on information from a single column.

### Batched Greedy Pruning

Given that the calculation of the pruning error requires only the diagonal elements of \(H^{-1}\) (see Equation 4), which are updated after each iteration, computing these elements in advance allows for calculating the head-wise error. With the observation that the sequential row removal via Equation 3 for the symmetric \(H^{-1}\) essentially corresponds to taking a Cholesky decomposition , we can obtain the elements in advance with Cholesky decomposition.

Hoewever, the matrix obtained by Cholesky decomposition is triangular, and the elements of the current row (column) are calculated based on the elements of all the previous rows (columns), which means the Cholesky decomposition breaks the comparability between rows (columns). So it is hard to obtain all the required information in advance through the Cholesky decomposition like [12; 13], whose error comparison is usually within the same column but structured pruning requires the comparison of different columns.

Since structured pruning only requires traversing the columns that need to be removed, by rearranging the rows and columns corresponding to a head that is to be pruned in \(H\) to the front, and then invert the matrix followed by Cholesky decomposition, we can calculate the

Figure 1: The figure illustrates Batched Greedy Pruning on attention blocks, where \(W\) is a output matrix and \(H\) is the corresponding Hessian. Different colors represent distinct attention heads and gray indicates the pruned weights.

head error column-wise. However, repeated rearrangement followed by matrix inversion and Cholesky decomposition is highly time-consuming, and this is just to find one head to be pruned.

We accelerate the above process through two common lemmas (proofs are provided in the Appendix): **(i)** For symmetric \(H\), the inverse matrix after permutation can be obtained by the same permutation of \(H^{-1}\); **(ii)** The principal submatrix of symmetric \(H^{-1}\) after Cholesky decomposition is equivalent to the Cholesky decomposition of its principal submatrix. Thus we can calculate the pruning error of all the heads at once through _grouped Cholesky decomposition_. Specifically, we inverse \(H\) once and split it into \(n_{head}\) matrices along the main diagonal, with each remains definite and symmetric, and decompose them in parallel:

\[}^{-1}=(([H_{0:d,0:d}^{-1},H_{d:2d,d:2d}^{-1},...,H_{(n-1)d:nd,(n-1)d:nd}^{-1}]))\] (5)

where decomposed \(}^{-1}\) is a matrix of size \(n_{head} d_{head} d_{head}\), \(n_{head}\) and \(d_{head}\) represent the head number and head dimension, respectively. Utilizing GPU acceleration, we can quickly calculate the value of the diagonal element in advance and calculate the head-wise error. Note that during error computation, we only update the diagonal elements of \(H^{-1}\) and skip the update of \(W\), which is small and does not dominate the ordering of errors.

After determining the head to be pruned, we rearrange the corresponding columns of \(W\) and the corresponding rows and columns of \(H^{-1}\) to the front, and again use the global Cholesky decomposition on reordered \(H^{-1}\) to prune the head column by column until the first head is pruned. In this way, we can avoid traversing columns that do not need pruning and only traverse necessary columns to improve pruning efficiency further. Figure 1 shows the process of Batched Greedy Pruning applied to attention blocks, and Algorithm 1 is a pseudocode illustrating how to prune a head with two steps: calculating head-wise error and pruning a head column-wise.

For FFNs, since there is no block constraint similar to attention heads, we can achieve local numerical optimality by pruning columns individually using Equation 4. However, the column-wise pruning is time-consuming because of the substantial intermediate dimensions of FFN. We thus prune a group of columns at a time and select the top-k columns with the most minor errors for pruning at each iteration. Considering that the compensation at each iteration may lead to a local reshuffling of column errors, we adopt a dynamic grouping strategy for pruning FFN blocks. We start with larger group size such as 1024 for pruning and gradually decrease the group size to a small number like 8, which allows us to enhance pruning efficiency while approaching an approximate optimal solution.

### Incremental Pruning Ratio

Through Batched Greedy Pruning, we can obtain near-optimal structured pruning results for each layer. However, finding a suitable pruning ratio for each layer is difficult, as considering global information is quite challenging for layer-wise pruning, which only provides optimal pruning resultsfor the current layer. Maintaining a uniform pruning ratio across all layers is unreasonable and will impact model performance, especially when the pruning ratio is high. Existing works have different approaches to the problem. For example, LLM-Pruner  avoids pruning in the initial and final layers while maintaining a consistent ratio in the intermediate layers to manually implement non-uniform pruning. OWL  adjusts sparse ratios dynamically for each layer based on the proportion of feature outliers, which is applied to unstructured pruning.

We find that layer-wise pruning, particularly structured layer-wise pruning, suffers from error accumulation due to its locality. Errors introduced during pruning in one layer can be amplified in subsequent layers, resulting in significant discrepancies between the final model output and the original. Figure 2 presents the per-layer output error of FFN between the original model and three distinct pruned models. The pruned models each implement a first-layer pruning of 25%, 50%, and 75%, respectively. The error increases with model depth and accumulates at a rate exceeding linear progression as the initial layer's pruning ratio increases. Based on this observation, we propose a straightforward pruning strategy for layer-wise pruning, termed Incremental Pruning Ratio, which can effectively minimize pruning losses without any additional operation.

In Incremental Pruning Ratio, without loss of generality, we employ a logarithmically increasing strategy to control the layer-wise pruning ratio. Specifically, for an \(n\)-layer model with the first and last layer pruning ratios denoted as \(r_{0}\) and \(r_{n-1}\) respectively, the pruning ratio for the \(i\)-th layer is defined as follows:

\[r_{i}=r_{0}+(r_{n-1}-r_{0}),\;(0 i<n)\] (6)

where \(r_{i}\) represents the pruning ratio for the \(i\)-th layer. This formula ensures that the pruning ratio from the first layer to the last layer transitions smoothly as a logarithmic curve. The strategy mitigates the pruning error accumulation in shallow layers while avoiding the issue of excessive pruning in the deeper layers, allowing for further reduction in performance loss.

## 5 Experiment

### Experimental Settings

**Implementation details.** We use C4 dataset  as the calibration set. From the first shard of C4, we randomly select 256 2048-token sequences for pruning. To restore performance, we following LLM-Pruner  finetune the pruned model with LORA . We tune with Alpaca datsets  for one epoch and utilize the AdamW optimizer with an initial learning rate set to 1e-4, coupled with a cosine annealing schedule for the learning rate. The global batch size is set to 64 and the sequence length is truncated to 256. All pruning experiments are conducted on a single A100, while finetuning is performed using two A100s.

**Models and Metrics.** To assess the effectiveness and generality of SlimGPT, We carry out a series of experiments on the LLaMA families . And to measure the effectiveness of our pruned models in the task-agnostic setting, we follow previous pruning works to evaluate language modeling performance and commonsense reasoning capabilities. The language modeling performance is evaluated on the WikiText2  validation set with sequence length truncated to 128, and the commonsense reasoning capabilities is carried out under a zero-shot setting on the Commonsense Reasoning datasets, which encompass seven diverse subtasks: BoolQ , PIQA , HellaSwag , WinoGrande , ARC-easy , ARC-challenge , and OpenbookQA . We utilize the lm-eval-harness framework  to conduct these evaluations.

Figure 2: Per-layer FFN output error between the original LLaMA-7B and three distinct pruned models. The pruned models each implement a first-layer reduction of 25%, 50%, and 75%, respectively. The PPL of original model is 12.63. For ease of visualization, the layer index has been truncated to 25.

To validate the universality of SlimGPT, we conduct experiments on additional models and supplementary evaluation datasets. The results of these experiments can be found in the Appendix. We conduct further pruning experiments on Vicuna , LLaMA2 , and Baichuan , which yield results consistent with those observed using the LLaMA model. In addition, we engage in preliminary evaluations on more complex tasks, specifically MMLU  and LongBench . Although SlimGPT exhibits slightly larger performance losses on these datasets, it still retains a significant advantage over the baseline models.

**Baselines.** We compare SlimGPT with the following recent SOTA works on structured pruning, which we could find during our experiments:

* LLM-Pruner , a gradient-based pruning approach, serves as our benchmark. This method involves a two-step process: a one-shot pruning followed by performance restoration through LORA fine-tuning.
* Compresso  is a pruning method based on sparse training, applying L0 penalty to manually inserted masks during the LORA fine-tuning phase and employing a cubic sparsity schedule to iteratively prune the model until the desired pruning ratio is achieved.
* LoRAPtune  utilizes gradients from the LORA module's parameters to determine the importance of the original model's parameters, thus requiring only gradient information from the LORA module, which significantly reduces computational demands.

### Main Result

#### 5.2.1 Performance Evaluation

To facilitate a more effective comparison of the evaluated results with prior works, we prune the LLaMA-7B model using four distinct pruning ratios--20%, 25%, 33%, and 50%--resulting in four smaller models with parameter counts of 5.4B, 5B, 4.5B, and 3.4B, respectively. Table 1 shows the detailed perplexity and zero-shot performance of pruned LLaMA-7B with four different sizes. Compared to other approaches, SlimGPT demonstrates superior performance in language modeling and commonsense reasoning across most subtasks. Under a pruning condition of 20%, SlimGPT achieves a slightly better perplexity score than the best existing results (16.68 vs. 16.80) and shows

   Prune\% & Method & \#Params & PPL\(\) & BoolQ & PIQA & HellaS & WinoG & ARC-e & ARC-c & OBQA & Avg. \\  - & -* & 6.7B & 12.63 & 75.08 & 79.16 & 76.20 & 70.00 & 72.89 & 44.88 & 44.40 & 66.09 \\   & LLM-Pruner* & & 18.01 & 66.76 & 78.45 & 71.44 & 63.77 & 66.41 & 39.85 & 43.80 & 61.50 \\  & Compresso & - & **79.08** & 75.46 & 53.44 & 67.80 & 68.64 & 37.97 & 34.20 & 59.51 \\  & LoraPrune & 5.4B & 16.80 & 65.62 & **79.31** & 70.00 & 62.76 & 65.87 & 37.69 & 39.14 & 60.06 \\  & SlimGPT w/o tune & & 16.99 & 75.93 & 77.58 & 73.07 & 67.96 & 68.60 & 41.72 & 41.80 & 63.81 \\  & SlimGPT & & **16.68** & 74.59 & 78.94 & **74.40** & **68.43** & **70.50** & **43.26** & **45.40** & **65.07** \\   & LLM-Pruner* & & 20.57 & 62.81 & 76.93 & 69.21 & 60.46 & 63.34 & 38.14 & 39.80 & 58.67 \\  & Compresso & - & 73.55 & 73.07 & 49.16 & 64.80 & 66.20 & 37.20 & 29.80 & 56.25 \\  & SlimGPT w/o tune & & 19.11 & **75.11** & 76.77 & 70.60 & **67.25** & 66.75 & 40.40 & **40.40** & **62.47** \\  & SlimGPT & & **18.45** & 73.46 & **77.42** & **72.07** & 65.51 & **67.17** & **41.13** & **40.40** & 62.45 \\   & LLM-Pruner* & & 24.50 & 62.02 & 74.92 & 64.41 & 61.80 & 53.79 & 32.00 & 38.80 & 55.39 \\  & Compresso & - & 68.69 & 72.85 & 47.18 & 63.38 & **65.99** & 35.07 & 29.00 & 54.59 \\  & SlimGPT w/o tune & & 24.55 & **72.72** & 75.68 & 68.10 & **66.54** & 62.29 & 37.03 & 40.20 & 60.37 \\  & SlimGPT & & **22.43** & 71.53 & **76.66** & **70.55** & 66.06 & 64.35 & **39.33** & **41.40** & **61.41** \\   & LLM-Pruner* & & 40.64 & 60.21 & 68.88 & 47.86 & 54.62 & 43.94 & 27.73 & 35.20 & 48.35 \\  & LoraPrune &  & **30.12** & 61.88 & 71.53 & 47.86 & 55.01 & 45.13 & 31.62 & 34.98 & 49.72 \\  & SlimGPT w/o tune & & 38.83 & **65.87** & 70.35 & 54.62 & **59.59** & 49.71 & 31.06 & 34.40 & 52.23 \\   & SlimGPT & & 31.07 & 65.11 & **71.60** & **59.94** & 59.27 & **53.37** & **31.83** & **35.20** & **53.76** \\   

Table 1: PPL & Commonsense Reasoning zero-shot performance of the pruned LLaMA-7B. The average score is computed across seven datasets. The **bolded** results represent the optimal results, while the underlined ones is the sub-optimal results. The asterisk-marked (*) results are those replicated within a consistent experimental framework, which slightly differ from the original source.

a 3.6-point improvement in zero-shot average (65.07 vs. 61.50). As the pruning ratio increases to 50%, the advantages of SlimGPT become even more pronounced. SlimGPT without post-training represents an approximately 8% improvement over the baseline LLM-Pruner in average performance (52.23 vs. 48.35), and with post-training, the average performance improvement reaches up to 11% (53.76 vs. 48.35). Specifically, on a dataset like Hellaswag, the improvement soars up to 25% (59.94 vs. 47.86).

Moreover, we observe that although SlimGPT affects different subtasks to varying degrees, its impact is relatively balanced across different tasks, eliminating the occurrence of disproportionately large losses in particular tasks. At lower pruning ratios, some tasks such as BoolQ can even outperform the original unpruned model. Additionally, the effects of fine-tuning also differ among tasks, significantly improving tasks like HellaSwag and ARC-easy, while potentially causing negative side effects for tasks such as BoolQ and WinoGrande. This phenomenon is likely closely associated with the datasets used for fine-tuning.

For larger-scale models such as LLaMA-13B and LLaMA-30B, previous works have not provided pruning results for these models. Therefore, we solely compare our results to the LLM-Pruner baseline, concentrating on two specific pruning settings: a lower pruning ratio (20%) and a higher pruning ratio (50%). The replication of LLM-Pruner is consistent with the method described in the paper, where the pruned models by LLM-Pruner are finetuned with LORA.

Table 2 presents the pruning results of LLaMA-13B and LLaMA-30B, and we can draw similar conclusions: SlimGPT outperforms LLM-Pruner in terms of both PPL and zero-shot average scores even without post-training. Note that as the scale of the model increases, the performance loss due to pruning becomes smaller, suggesting a higher degree of parameter redundancy in larger models. At a low pruning ratio of 20%, the LLaMA-13B model's average performance in commonsense reasoning is nearly on par with that of the original, unpruned model (68.06 vs. 68.16). Similarly, the pruned LLaMA-30B model slightly outperforms the unpruned version (72.56 vs. 71.92). For the perplexity task, even though SlimGPT exhibits gaps compared to the original model, it still performs better than baseline, even at low pruning ratios.

Besides, we can find that the performance of LLaMA-13B pruned by 50% falls short compared to LLaMA-7B pruned by 20%. This highlights the limitations of low-cost fine-tuning, where resource constraints and training with techniques like LoRA result in limited performance recovery for the model. Therefore, using lower pruning ratios to compress smaller LLMs yields better returns.

   Prune\% & \#Params & Latency & Memory \\  - & 6.7B & 13.51ms & 27737MB \\
20\% & 5.4B & 11.89ms & 22497MB \\
50\% & 3.4B & 9.21ms & 14297MB \\   

Table 4: Inference Latency and Memory Usage

   Prune\% & Method & \#Params & PPL\(\) & Zero-shot Avg.\(\) & \#Params & PPL\(\) & Zero-shot Avg.\(\) \\  - & -* & 13.0B & 11.58 & 68.16 & 32.5B & 9.78 & 71.92 \\   & LLM-Pruner* & & 16.62 & 65.68 & & 12.06 & 69.99 \\  & SlimGPT w/o tune & 10.4B & 14.87 & 66.37 & 26.0B & **11.59** & 71.13 \\  & SlimGPT & & **14.73** & **68.06** & & 11.69 & **72.56** \\   & LLM-Pruner* & & 74.62 & 53.22 & & 22.33 & 59.47 \\  & SlimGPT w/o tune & 6.5B & 31.05 & 57.82 & 16.3B & 18.61 & 65.50 \\   & SlimGPT & & **26.38** & **59.49** & & **17.17** & **66.79** \\   

Table 2: PPL & Commonsense Reasoning zero-shot performance of the pruned LLaMA-13B/30B. The perplexity is evaluated on Wikitext2 and the zero-shot average is computed across seven Commonsense Reasoning datasets. The **bolded** results represent the optimal results. The asterisk-marked (*) results are those replicated within a consistent experimental framework, which slightly differ from the original source. Detailed results are available in the Appendix.

   Prune\% & \#Params & Latency & Memory \\  - & 6.7B & 13.51ms & 27737MB \\
20\% & 5.4B & 11.89ms & 22497MB \\
50\% & 3.4B & 9.21ms & 14297MB \\   

Table 3: Pruning Runtime and Memory Usage

#### 5.2.2 Efficiency Analysis

The pruning runtime and memory usage for LLaMA-7B and LLaMA-13B are detailed in Table 3. Memory usage fluctuates based on the model size and the calibration scale, while the pruning speed is additionally affected by the pruning ratio. We demonstrate the pruning efficiency results derived from our experimental setup. Utilizing SlimGPT, which operates on a layer-wise basis, there is no need to load the entire model at once. Instead, we only load the parameters of the current layer along with the corresponding input features, significantly reducing memory consumption. For instance, to prune the 7B model by 20%, approximately 7 GB of GPU memory and 18 minutes are required to complete the process. Similarly, pruning the 13B model by 50% necessitates around 12 GB of GPU memory and 41 minutes to finalize.

Table 4 illustrates the inference latency and memory usage of the pruned LLaMA-7b models. We prune LLaMA-7b by 20% and 50% respectively. The maximum output limit is set to 512 and the presented values are the average derived from 50 inference trials. When pruning 50% of the parameters, the memory usage of the model during inference decreases to approximately 51% (14297MB vs. 27737MB), and the inference latency is reduced to about 69% (9.21ms vs. 13.51ms).

### Ablation Study

We systematically analyze the influence of several key parts of SlimGPT on the pruning effect, including the Batched Greedy Pruning and Incremental Pruning Ratio strategy. Within the calibration dataset, we conduct thorough experiments with sample sizes and sequence lengths. Unless specifically stated otherwise, all the following experiments are conducted under the condition of pruning 50% of LLaMA-7b **without** further post-training, to eliminate potential confounding effects. Supplementary ablation experiments can be found in the Appendix.

#### 5.3.1 Impact of Batched Greedy Pruning Strategy

We leverage grouped Cholesky decomposition to enhance the accuracy of head-wise error computation in attention blocks. Similarly, for FFNs, our proposed Dynamic Group Size substantially increases pruning efficiency while preserving near-optimal pruning results. To validate the effectiveness of these two strategies, we start with the complete SlimGPT algorithm and first remove the Dynamic Group Size (denoted as '-DGS'), setting the group size for FFN pruning to a fixed value of 128. Then, we remove the grouped Cholesky decomposition (denoted as '-GCD') and use the initial \(H^{-1}\) to calculate head-wise errors. The experimental results are shown in Table 5. For attention blocks, the grouped Cholesky decomposition strategy plays a key role in language modeling capabilities by improving the accuracy of error compensation. Replacing it with ordinary Cholesky decomposition results in a significant increase in PPL (38.83 vs 54.94). In comparison to the naive fixed group size scheme for FFNs, the Dynamic Group Size strategy proposed contributes to maintaining the model's commonsense reasoning performance (52.23 vs 51.63).

    & Model Size & PPL\(\) & Zero-shot Avg.\(\) \\  log increase (SlimGPT) & 3.40b & **38.83** & 52.23 \\ linear increase & 3.34b & 46.57 (+7.74) & **53.45** (+1.22) \\ uniform & 3.50b & 123.05 (+84.22) & 44.34 (-7.89) \\ log decrease & 3.40b & 380.69 (+341.86) & 36.73 (-15.50) \\ linear decrease & 3.34b & 932.64 (+893.81) & 35.62 (-16.61) \\   

Table 6: Pruning results with different pruning ratio strategies.

    & PPL\(\) & Zero-shot Avg.\(\) \\  SlimGPT & 38.83 & 52.23 \\ - DGS & 39.73 (+0.90) & 51.63 (-0.60) \\ - GCD & 54.94 (+16.11) & 51.59 (-0.64) \\   

Table 5: Pruning results under different strategies of SlimGPT. ‘-DGS’ means removing Dynamic Group Size for FFN while ‘-GCD’ means removing grouped Cholesky decomposition for attention blocks.

#### 5.3.2 Impact of Incremental Pruning Ratio Strategy

The Incremental Pruning Ratio is a strategy specifically proposed for addressing the issue of layer-wise pruning. To maintain generality, we selected various common non-uniform strategies for comparative experiments, including logarithmic and linear increase strategies, as well as their corresponding decrease strategies. Among these, the logarithmic increase strategy is the default configuration for SlimGPT. Additionally, we conduct experiments under the setting of uniform pruning. Table 6 details the results under the different settings. From an overall perspective, the increase strategy for the pruning ratio has a clear advantage over uniform, and likewise, uniform shows a distinct advantage over decrease. Such results further verify the phenomenon of layer-wize error accumulation. As for the increase strategies of logarithmic and linear changes, due to disparities in model sizes, their results are not entirely comparable. The former performs best in language modeling (38.83), while the latter shows better performance in common sense reasoning tasks (53.45).

#### 5.3.3 Effects of Calibration Samples & Sequence Length

We delve further into the impact of calibration samples and sequence length, and we choose C4 dataset for our experiments as it has a longer average sequence length. In exploring the effects of the sample scale, we fix the sequence length at 256 and test five scales ranging from 128 to 2048; similarly, when investigating the impact of sequence length, the sample scale is set to 256, with choices of sequence length varying from 64 to 2048. Figure 3 presents the perplexity result and zero-shot performance with different calibration samples and sequence lengths. As the number of samples increases, the PPL and zero-shot averages show a positive overall trend. Furthermore, after the sample count reaches 2048, the PPL does not bottom out, and there is room for further reduction. Similar phenomena can be observed in experiments on sequence length. With more sufficiently high-quality datasets with longer sequences, we believe SlimGPT can achieve better pruning effects.

## 6 Conclusion

In this work, we introduce a fast, structured pruning method for large-scale models within resource-constrained scenarios, based on the OBS framework, termed SlimGPT. Leveraging the novel Batched Greedy Pruning, we enhance the accuracy of pruning error estimation, thereby minimizing performance degradation from pruning. Moreover, we analyze the limitations of layer-wise pruning from the perspective of error accumulation and propose a non-uniform strategy named Incremental Pruning Ratio, which effectively improves the pruned model's performance. Evidence from open-source experiments affirms the efficacy of our approach.

**Limitations.** Even though SlimGPT achieves SOTA results in the structured pruning of LLMs, the model performance degradation at high pruning ratios (_e.g.,_ 50%) or on more complex tasks (_e.g.,_ LongBench) is still significant. How to enhance the model compression effectiveness under low-resource conditions remains a challenge. Moreover, we utilized a naive logarithmic change strategy in the Incremental Pruning Ratio, which, while ensuring generality, is not the optimal solution. The most suitable non-uniform approach requires further exploration. Lastly, similar to many large-scale open-source models available today, the model obtained through pruning by SlimGPT poses risks in terms of ethical safety and requires cautious handling.

Figure 3: Effects of Calibration Sample Size & Sequence Length.