# FlowPG: Action-constrained Policy Gradient with Normalizing Flows

Janaka Chathuranga Brahmanage, Jiajing Ling, Akshat Kumar

School of Computing and Information Systems

Singapore Management University

{janakat.2022, jjing.2018}@phdcs.smu.edu.sg, akshatkumar@smu.edu.sg

###### Abstract

Action-constrained reinforcement learning (ACRL) is a popular approach for solving safety-critical and resource-allocation related decision making problems. A major challenge in ACRL is to ensure agent taking a valid action satisfying constraints in each RL step. Commonly used approach of using a projection layer on top of the policy network requires solving an optimization program which can result in longer training time, slow convergence, and zero gradient problem. To address this, _first_ we use a normalizing flow model to learn an invertible, differentiable mapping between the feasible action space and the support of a simple distribution on a latent variable, such as Gaussian. _Second_, learning the flow model requires sampling from the feasible action space, which is also challenging. We develop multiple methods, based on Hamiltonian Monte-Carlo and probabilistic sentential decision diagrams for such action sampling for convex and non-convex constraints. _Third_, we integrate the learned normalizing flow with the DDPG algorithm. By design, a well-trained normalizing flow will transform policy output into a valid action without requiring an optimization solver. Empirically, our approach results in significantly fewer constraint violations (upto an order-of-magnitude for several instances) and is multiple times faster on a variety of continuous control tasks.

## 1 Introduction

Action-constrained reinforcement learning (ACRL), where an agent's action taken in each RL step should satisfy specified constraints, has been applied to solve a diverse range of real-world applications . One example is the resource allocation problem in supply-demand matching . The allocation of resources must satisfy constraints such as total assigned resources should be within a specific upper and lower limit. In robotics, kinematics constraints (e.g., limits on velocity, acceleration, torque among others) can be modeled effectively using action constraints .

One of the main challenges in solving ACRL is to ensure that during training and evaluation, all the action constraints are satisfied at each time step, while simultaneously improving the policy. Lagrangian Relaxation (LR) is a popular approach for solving constrained RL problems , however directly applying LR to ACRL is impractical due to the difficulty in defining cost functions (\(c(s,a)\)) that penalize infeasible actions for all \((s,a)\), and the inability to guarantee zero constraint violation during training and policy execution. Also, there are studies addressing ACRL with discrete action spaces . As they use propositional logic, it is not clear how to extend them to continuous action spaces. Recently proposed approaches aim to satisfy continuous action constraints using an _action projection_ step. One natural approach is to add a differentiable projection layer at the end of the policy network to satisfy the constraints . This projection layer projects the unconstrained policy action onto the feasible action space by solving a quadratic program (QP). However, this approach has two primary limitations. Firstly, solving a QP at each RL step can becomputationally expensive, particularly when dealing with non-convex action constraints or large action spaces. Secondly, the coupling between the policy network and projection layer can lead to a potential issue of zero gradient during end-to-end training, which can undermine the effectiveness of the projection layer approach, especially in the early training stages, as highlighted by recent studies . This issue occurs when the policy output is far outside the feasible action space, thereby any small change in the policy parameters does not result in any change in the projected action.

To overcome the zero gradient issue, an ACRL algorithm has been proposed in , which decouples policy gradients from the projection layer. The policy parameters are updated by following the direction found by the Frank-Wolf method , which is within the feasible action space. However, this approach can also be computationally expensive, as solving a QP is still required during the update of policy parameters and during policy execution. To summarize, while there are several proposed approaches for solving ACRL with continuous action space, all of them share the common drawback of requiring QP solving during either training or action execution, or both. This can cause a significant reduction in training speed, which we also validate empirically. Moreover, some of these approaches also suffer from the zero gradient issue, which can make training sample inefficient. Therefore, there is need for more efficient methods to tackle ACRL with continuous action spaces.

Often, action constraints are specified analytically using features from state and actions (e.g., \(x^{2}+y^{2}<=1\) where \(x,y\) can be features). Our key idea is to exploit given action constraints as domain knowledge and develop an effective, compact representation of all valid actions that can be integrated with RL algorithms. To find such a representation, generative models provide an attractive solution since they can generate valid actions by learning from a finite number of valid actions (which can be provided by sampling from the valid action space). This allows for a compact feasible action space representation even for continuous action spaces. Furthermore, generative models can be easily integrated with RL algorithms for end-to-end training, as shown in previous work , even though they are not specifically solving ACRL problems. The idea of learning the representation of all valid actions also shares a connection with offline RL, where invalid actions are often treated as out-of-distribution (OOD) actions . However, a notable difference between our work and offline RL lies in the availability of a dataset comprising valid actions. In offline RL, such a dataset is assumed to be available (e.g., collected from a random policy or an expert). In ACRL, collecting data even from a random policy is not straightforward as random policy must also select actions uniformly from the feasible action space, which itself is the key problem we address in this work.

**Our main contributions are:**

* We utilize the normalizing flows, a type of generative model, to learn a differentiable, invertible mapping between the data distribution of sampled valid actions and a simple latent distribution (e.g., Gaussian, uniform distribution) . When a member of the latent distribution is given, the flow model can transform it into an element that conforms to the distribution of valid actions, assuming the model is well-trained. Compared to other generative models, such as Generative Adversarial Networks (GANs) and Variational Autoencoders (VAEs), the normalizing flow model is known to be more efficient at completing the task of data generation .
* Sampling uniformly from the feasible action space to train the flow model is challenging. For example, valid action space may be characterized using a set of constraints over binary variables. We therefore develop multiple methods, based on Hamiltonian Monte-Carlo  and probabilistic decision diagrams (\(\)) , for valid action sampling for (non)convex constraints. These methods are significantly more sample efficient than the standard rejection sampling.
* We propose a simple and easy to implement method to integrate the normalizing flow model with deep RL algorithms such as DDPG . Our approach is general, requires change only in the last layer of the policy network, and can be integrated with other deep RL methods. In our method, the modified policy network outputs an element of the latent distribution used in the normalizing flow model, which is then transformed into a valid action via the mapping provided by the normalizing flow. We also show gradients can be propagated through the normalizing flow to improve the policy. By integrating the normalizing flow with deep RL algorithms, we can avoid the zero gradient issue since there is no projection of invalid action onto the feasible action space. We show empirically that the flow model can be trained well on a variety of action constraints used in the literature, therefore, probability of constraint violation occurring remains low. Empirically, our approach results in significantly fewer constraint violations (upto 10x less), and is multiple times faster on a variety of continuous control tasks than the previous best method .

Preliminaries

Action-constrained Markov Decision ProcessWe consider a Markov decision process (MDP) model, which is defined by a tuple \((S,A,p,r,,b_{0})\), where \(S\) is the set of possible states, \(A\) is the set of possible actions that an agent can take, \(p(s_{t+1}|s_{t},a_{t})\) is the probability distribution over the next state \(s_{t+1}\) given the current state \(s_{t}\) and action \(a_{t}\), \(r(s_{t},a_{t})\) is the reward function that determines the reward received by the agent after taking action \(a\) in state \(s\) at time step \(t\), \([0,1)\) is the discount factor, and \(b_{0}\) is the initial state distribution. We assume the action space \(A\) is continuous, and focus on deterministic policies. Specifically, let \(_{}()\) denote a deterministic policy parameterized by \(\); action taken in state \(s\) is given as \(a=_{}(s)\). Under policy \(_{}\), the state value function (\(V\)) and the state-action value function (\(Q\)) are defined as follows respectively.

\[V^{_{}}(s)=[_{t=0}^{}^{t}r(s_{t},a_{t})|s_ {0}=s;_{}],\;Q^{_{}}(s,a)=[_{t=0}^{} ^{t}r(s_{t},a_{t})|s_{0}=s,a_{0}=a;_{}]\] (1)

An action-constrained MDP extends the standard MDP by incorporating explicit action constraints that determine a valid action set \((s) A\) for each state \(s S\). In other words, the agent can only choose an action from the set of valid actions at each time step. The goal of an action-constrained MDP is to find a policy that maximizes the expected discounted total reward while ensuring that all chosen actions are valid with respect to the constraints. Formally, we have:

\[_{}J(_{})=_{s b_{0}}[V^{_{}}(s)] \;\;\;\;\;a_{t}(s_{t})\;\;\;\;\; t\] (2)

We consider a RL setting where transition and reward functions are not known. The agent learns a policy by interacting with the environment and using collected experiences \((s_{t},a_{t},r_{t},s_{t+1})\).

Deep Deterministic Policy GradientDeep Deterministic Policy Gradient (DDPG) is a RL algorithm specifically designed to handle continuous action spaces . The algorithm combines deterministic policy gradient  with deep \(Q\)-learning . To solve an _unconstrained_ RL problem, DDPG applies stochastic gradient ascent to update policy parameters \(\) in the direction of the gradient \(_{}J(_{})\). The deterministic policy gradient theorem is used to compute the policy gradient as:

\[_{}J(_{})=_{s}[_{a}Q^{ _{}}(s,a;)_{}_{}(s)|_{a=_{}(s)}]\] (3)

The state-action value function \(Q(s,a;)\) is approximated using a deep neural network, and the parameters \(\) of this neural network are updated by minimizing the following loss function:

\[_{(s,a,s^{},r)}[(r+ Q(s^{},_{ ^{}}(s^{});^{})-Q(s,a;))^{2}]\] (4)

where \((s,a,s^{},r)\) is a transition sample; \(\) is the replay buffer that stores transition samples; \(^{}\) and \(^{}\) are the parameters of the target policy and the target state-action value function respectively.

Normalizing FlowsA normalizing flow model is a type of generative model that transforms a simple distribution, such as a Gaussian or uniform distribution, into a complex one by applying a sequence of invertible transformation functions [9; 27]. Let \(f=f_{K} f_{K-1} f_{1}:^{D}^{D}\) denote a normalizing flow model, where each \(f_{i}:^{D}^{D}\), \(i=1:K\), is an invertible _transformation_ function. Starting from an initial sample from a base distribution (or prior distribution), \(z_{0} p(z^{0})\), the transformed sample from the model is \(x=f_{K} f_{K-1} f_{1}(z^{0})\). Each \(f_{i}\) takes input \(z^{i-1}\) and outputs \(z^{i}\), and \(x=z^{K}\). Given a training dataset \(\), the mapping function \(f\) is learned by maximizing the log-likelihood of the data, which is defined as \( p()=_{x} p(x)\). The log probability \( p(x)\) is computed by repeatedly applying the change of variables theorem, and is expressed as:

\[ p(x)= p(z^{0})-_{i=1}^{K}(z^{ i-1})}{(z^{i-1})^{T}}\] (5)

## 3 Normalizing Flow for ACRL

### Learning Valid Action Mapping Using Normalizing Flows

We employ normalizing flows to establish an invertible mapping between the support of a simple distribution and the space of valid actions. While various transformation functions can be utilizedfor implementing normalizing flows, we specifically focus on the conditional RealNVP model  due to its suitability for the general ACRL setting, where the set of valid actions is dependent on the state variable. The conditional RealNVP extends the original RealNVP  by incorporating the conditioning variable in both the prior distribution and the transformation functions. These transformation functions, which are implemented as affine coupling layers, possess the advantageous properties of enabling efficient forward propagation during model learning and efficient backward propagation for sample generation .

Given a dataset \(\) consisting of valid actions (details in Section 3.2), we train the invertible mapping \(f_{}\) parameterized by \(\) to capture the relationship between the support of a uniform distribution \(p\) and the elements in \(\). Learning this mapping provides an easy way to generate new valid actions. The policy network outputs an element from the domain of the uniform distribution, which is then mapped to a valid action using the learned flow. This process of generating actions is much simpler than using a math program for action projection, which can result in the zero gradient issue.

The flow learning process involves maximizing the log-likelihood of the data, following the methodology presented in . In contrast to using a Gaussian distribution, we opt for a uniform distribution as it demonstrated better empirical performance when combined with the DDPG algorithm. Once the normalizing flow model is learned, during backward propagation with conditioning variables, each bijective function \(f_{_{i}}\), where \(i=1,,K\), takes inputs of \(z^{i-1}^{D}\) and a conditioning variable \(y^{D_{y}}\) (representing state features) and produces an output of \(x^{i}^{D}\) as:

\[x^{i}_{1:d} =z^{i-1}_{1:d}\] (6) \[x^{i}_{d+1:D} =(z^{i-1}_{d+1:D}-t(z^{i-1}_{1:d},y))(-k(z^{i-1}_{1:d},y))\] (7)

where \(d<D\) is the index that splits dimensions of input \(x^{i}\) into two parts; \(k\) and \(t\) are scale and translation functions that map from \(^{d+D_{y}}^{D-d}\). These two functions are modeled using neural networks. \(\) denotes the element-wise product (Hadamard product). Therefore, given a random member of the uniform distribution \(z^{0} p(z^{0})\) and a conditioning variable \(y\), the mapped element is:

\[x=f_{_{K}} f_{_{K-1}} f_{_{1}}(z^{0},y)\] (8)

Note that the transformed output \(x\) obtained through the normalizing flow model may not precisely match any specific element from the dataset \(\). However, when the mapping \(f_{}\) is effectively trained, the resulting \(x\) should exhibit similar characteristics to the elements in \(\), thereby satisfying the constraints with high probability, as we also observed empirically. In essence, the combination of the uniform distribution and the learned mapping serves as an efficient representation of all valid actions, providing a means to generate actions that adhere to the constraints.

Unlike other generative models, normalizing flows provide the ability to measure the recall rate in learning the valid action mapping due to their invertible bijective transformations. The recall rate (we call it "coverage") indicates the fraction of valid actions that can be generated from the latent space. Given a conditioning variable \(y\), let \((y)\) denote the set of valid actions that are uniformly distributed in the feasible region. The recall can be computed as follows.

\[recall(y)=(y)}_{dom_{_{0}}}f_{}^ {-1}(x,y)}{|(y)|}\] (9)

where \(f_{}^{-1}\) is the inverse transformation function of the normalizing flows model \(f_{}\). Recall is useful to characterize the learned generative model. If the recall is low, it would limit the feasible constrained space over which ACRL algorithm optimizes the policy. This can result in lower solution quality.

The Mollified Uniform PriorMost recent studies of normalizing flows employ a standard Gaussian distribution as the latent space distribution , which spans the entire real number space \(^{D}\). However, through empirical observation, we noticed that with Gaussian latent distribution, the feasible action region tends to be mapped _closer to zero_ in the latent space, where the probability of the standard Gaussian is higher. On the other hand, points located far away from the center of the Gaussian (several standard deviations) often get mapped into the _infeasible_ action space. Consequently, when coupling the DDPG policy network with the flow, it resulted in high constraint violations as the policy network output can be any number from the support of the Gaussian, and not just limited to the high probability region.

To address this issue, we decided to use a uniform distribution from \([-1,1]^{D}\) as the latent distribution instead of the standard Gaussian. In the uniform distribution, there is no high or low probability region unlike the standard Gaussian. However, the uniform distribution is not differentiable, therefore we employ a modified version called the Mollified uniform distribution . In order to train the normalizing flow, we require the probability density of the prior distribution as in Eq. 5. Computing the probability density of a multi-dimensional mollified distribution can be challenging since it requires integrating over all dimensions . However, in the case of a single dimension, a sample drawn from a mollified uniform distribution can be seen as a sample from a uniform distribution with added Gaussian noise. In other words, a sample \(x\) is obtained as \(x=x_{0}+\), where \(x_{0}\) follows a uniform distribution in the range \([-1,1]\), and \(\) follows a Gaussian distribution with mean \(0\) and standard deviation \(\).

To calculate the overall probability density, we treat each dimension individually, compute their probability densities, and take their product as the overall probability. The probability density in a single dimension can be easily calculated using the following formula: \(p(x)=_{-1}^{1}}}e^{-}(x- x_{0})^{2}}dx_{0}=()-()\). In this formula, \(\) represents the cumulative density function of the standard Gaussian distribution.

### Generating Random Samples from the Valid Action Space

To effectively train the normalizing flow model, we need to generate samples from the set of valid actions. Even with the known analytical form of action constraints this is a challenging problem. Standard rejection sampling is highly inefficient to sample from the complex constraints that arise in ACRL benchmarks. Therefore, we use two methods described next.

Hamiltonian Monte-Carlo (HMC)HMC is a Markov chain Monte Carlo method, which utilizes energy conservation to effectively sample a target distribution . It utilizes Hamiltonian-dynamics to simulate the movement of a particle in a continues space based on a potential energy function. It uses leap-frog algorithm with the first order integrator, to estimate the next position of the particle. In our work, we need to generate samples in the feasible region. Therefore we define energy function to be a fixed value \(0\) in the feasible region. Then we bound the feasible region with a hard wall of infinity potential by setting the potential to \(\) in the infeasible region. Figure 1(c) depicts the distribution of feasible action samples generated by HMC in the action constraint of the Reacher Environment (\(a_{1}^{2}+a_{2}^{2} 0.05\)). It presents a contour map of the sample density in Figure 1(c)-(ii), as well as their projection onto each dimension in Figure 1(c)-(i) and Figure 1(c)-(iii) respectively.

Probabilistic Sentential Decision DiagramsIn many real-world applications such as resource allocation, the constraints are defined using a set of linear equalities/inequalities over integer variables. However, sampling valid actions using HMC that satisfy such constraints is very challenging due to the presence of equality constraints. To address this challenge, we propose to use a Probabilistic Sentential Decision Diagram (\(\))  to encode a uniform distribution over all the valid actions and then sample actions from the \(\). For this setting, we assume that all the constraints are linear (in)equalities. We describe the process of constructing a \(\) next. Consider an inequality constraint \(x+y 2\). We follow the following steps:

Figure 1: (a)An \(\) representing the PB constraint \(A 2^{1}+B 2^{0}+C 2^{1}+D 2^{0} 2\); (b)A \(\) ; (c) Samples generated with HMC

1. We convert the variables into binary representations. The number of bits used in the binary representation depends on the upper/lower bounds of variables. For example, assuming \(x,y\{0,1,2,3\}\), we can use \({}_{A} 2^{1}+B 2^{0}\) to represent \(x\) and \({}_{C} 2^{1}+D 2^{0}\) to represent \(y\) where \(A,B,C,D\) are Boolean variables.
2. We convert the given linear constraint into a Pseudo-Boolean (PB) constraint by using the binary representation of variables. The resulting PB constraint is \({}_{A} 2^{1}+B 2^{0}+C 2^{1}+D 2^{0} 2\). Note that the coefficients in a PB constraint can be real numbers.
3. We compile the PB constraint into an \(\) using the method described in . An \(\) encodes all instantiations of Boolean variables that satisfy the constraint. Each valid instantiation is called a _model_ of the \(\). Figure 1(a) shows a compiled \(\) for the PB constraint. For the syntax and semantics of \(\), we refer to  for detailed elaboration. When there are multiple equalities/inequalities constraints, we create \(\)s in this fashion for each constraint. We then conjoin all such \(\)s (which is a poly-time operation) to encode all the constraints into a single \(\) that represents the valid action space satisfying all the constraints.
4. We parameterize the final \(\) using a standard package  to obtain a \(\) as shown in Figure 1(b), which represents a probability distribution over all models of the underlying \(\). A uniform distribution over all models is achievable by a special parameter initialization scheme as provided in . Sampling models from the \(\) can be efficiently performed using a fast and top-down procedure, as described in .

We use this scheme to sample valid resource allocation actions in a bike sharing domain that has multiple equality and inequality constraints and has been used previously .

### Integrating DDPG with Normalizing Flows

In previous approaches to ACRL, addressing zero constraint violations often involves adding a projection layer to the original policy network. However, this method has drawbacks such as increased training time, slow convergence, and the issue of zero gradient when updating policy parameters, particularly during the early stages of training when pre-projection actions are likely to be invalid. In our work, we propose an integration of the DDPG algorithm with the _learned_ mapping between the support of a uniform distribution \(p\) and the set of valid actions as in Section 3.1. This integration allows us to incorporate the learned mapping directly into the original policy network of DDPG, alleviating the aforementioned issues.

Figure 2(a) illustrates the architecture of our proposed policy network, which consists of two modules.

* The first module is the original parameterized policy network \(_{}\) from DDPG, which takes the state \(s\) as input and outputs \(\). To ensure that \(\) belongs to a uniform distribution \(p\) used for learning the mapping \(f_{}\), we employ a Tanh activation function at the end of the original policy network.
* The second module is the learned mapping function \(f_{}\) using normalizing flows. This mapping function takes inputs of \(\) and \(s\).

Since \(\) is a member of the uniform distribution \(p\), for a well trained \(f_{}\), chances of the mapped action outside of the valid action space will be low, which we also observe empirically. Our proposed policy network offers two significant advantages compared to previous ACRL methods. First, it eliminates the need to solve a QP to achieve zero constraint violation. Instead, the valid action is obtained by mapping a sample from the uniform distribution, resulting in a substantial increase in training speed. Note that in our work the mapping function \(f_{}\) is pre-trained, and its parameters \(\) remain fixed during the learning process of the original policy parameters \(\). However, if it becomes necessary for large state/action spaces, we can adapt our approach to refine the flow during the learning process. This can be achieved by performing a gradient update on \(f_{}\), using newly encountered states and valid actions, as described in Section 3.1. Through our experiments, we demonstrate the accuracy of the learned mapping, highlighting the effectiveness of our approach to satisfy action constraints. Second, the architecture of our policy network enables end-to-end updating of the original policy parameters \(\) without solving a math program for action projection, thereby avoiding the issue of zero gradient. This advantage allows for smoother training and more stable convergence.

Policy updateThe objective is to learn a deterministic policy \(f_{}(_{}(s),s)\) that gives the action \(a\) given a state \(s\) such that \(J(_{})\) is maximized. We assume that the \(Q\)-function is differentiable with respect to the action. Given that the learned mapping \(f_{}\) is also differentiable and the parameters \(\) are frozen, we can update the policy by performing gradient ascent only with respect to the original policy network parameters \(\) to solve the following optimization problem:

\[_{}J(_{})=_{s}[Q(s,f_{}(_{ }(s),s);)]\] (10)

where \(\) is the replay buffer and \(Q\)-function parameters \(\) are treated as constants. Figure 2(b) shows the reversed gradient backpropagation path (in blue) for \(\). The new deterministic policy gradient for the update of \(\) is then given as follows.

\[_{}J(_{})=_{s}[_{a}Q^{ _{}}(s,a;)_{}f_{}(,s)_{}_ {}(s)|_{=_{}(s),a=f_{}(,s)}]\] (11)

Next, we derive the analytical form of the gradient term \(_{}f_{}(,s)\) in the new deterministic policy gradient, which is an additional component compared to the standard DDPG update (3). For notational simplicity, we focus on computing \(_{z^{0}}f_{}(z^{0},y)\), which is same as \(_{}f_{}(,s)\) (as last layer of the policy maps to the domain of the latent uniform distribution, or \(=z^{0}\)). We also note \(\) is the collection of parameters \(_{i}\)\( i=1,,K\). To compute this gradient, we apply the chain rule of differentiation. Considering the composition of functions \(f_{}(z^{0},y)=f_{_{K}}(f_{_{K-1}}( f_{_{1}}(z^{0},y)))\), we can express the derivative as a product of gradients:

\[_{z^{0}}f_{}(z^{0},y) =} f_{_{K-1}} f _{_{1}}(z^{0},y)}{(z^{0})^{T}}(z^{0})\] \[=}}{(z^{0})^{T}}(z^{0}) }}{(z^{K-1})^{T}}(z^{K-1}=f_{ _{K-1}}(z^{K-2},y))\] (12)

The Jacobian of each bijective function \(f_{_{i}},i=1,,K\) is

\[}}{(z^{i-1})^{T}}=}{ (z^{i-1})^{T}}=_{d}&\\ _{d+1,D}}{(z^{i-1}_{d})^{T}}&([-k (z^{i-1}_{1:d},y)])\] (13)

where \(_{d}\) is a \(d d\) identity matrix. \(([-k(z^{i-1}_{1:d},y)])\) is the diagonal matrix where the diagonal consist of elements corresponding to the vector \([-k(z^{i-1}_{1:d},y)]\) and the other elements are all zeros. \( x^{i}_{d+1:D}/(z^{i-1}_{1:d})^{T}\) is computed as follows.

\[_{d+1:D}}{(z^{i-1}_{1:d})^{T}}=-[-k(z^{i-1}_{1 :d},y)]^{T}([z^{i-1}_{d+1:D}-t(z^{i-1}_{1:d},y)]^{T}_{1:d},y)}{(z^{i-1}_{1:d})^{T}}+ _{1:d},y)}{(z^{i-1}_{1:d})^{T}})\] (14)

where \(^{T}\) denotes a row vector of length \(d\) whose elements are all one. \(_{1:d},y)}{(z^{i-1}_{1:d})^{T}}\) and \(_{1:d},y)}{(z^{i-1}_{1:d})^{T}}\) are the Jacobian of \(k\) and \(t\) respectively. Note that when \(k\) and \(t\) are complex functions modeled by neural networks. The Jacobian matrix can be computed efficiently using automatic differentiation tools such as Pytorch and Tensorflow.

Critic UpdateThe update of \(Q\)-function parameters \(\) in our approach follows the same update rule as in DDPG (4). However, in case the mapped action by the learned flow does not satisfy action constraints, we solve a QP to project it into the feasible action space as the environment only accepts valid actions. Therefore, the action stored in the replay buffer \(\) is either the output from the flow model or the projected action, depending on whether flow mapped action is valid or not. We note that the probability of using the projected action during training is low as for all the tested instances as the normalizing flow had high accuracy. Even if the projection was required, the difference between the flow output and the projected action was small as we show empirically. We also highlight that for policy update, we use the flow mapped action without using any projection, which enables end-to-end training of the policy.

Other RL algorithmsWhile our work focuses on DDPG, it can be extended to other RL algorithms such as SAC or PPO. This is possible because the normalizing flows enable the computation of log probabilities of actions, which is required during training in SAC or PPO. This showcases an additional advantage of using the normalizing flow model in our work compared to other generative models.

## 4 Experiments

**Environments** We evaluate our proposed approach on four continuous control RL tasks in the MuJoCo environment  and one resource allocation problem that has been used in previous works [4; 18].

* **Reacher:** The agent is required to navigate a 2-DoF robot arm to reach a target. The agent's actions \((a_{1},a_{2})^{2}\) are 2D. The action space is subject to a nonlinear convex constraint \(a_{1}^{2}+a_{2}^{2} 0.05\).
* **Half Cheetah:** The task is to make the cheetah run forward by applying torque on the joints. An action is a 6-dimensional vector \((v_{1},v_{2},...v_{6})\), bounded by \([-1,1]\). The constraint is defined as \(_{i=1}^{6}|v_{i}w_{i}| 20\) where \(w_{i}\) is the velocity, which can be observed as part of the state.
* **Hopper and Walker2d:** The task involves controlling a robot to hop or walk forward by applying torques to its hinges. An action is a \(n\)-dimensional vector \((v_{1},...,v_{n})\), bounded by \([-1,1]\) where \(n\) is the number of hinges on the robot (3 for Hopper and 6 for Walker2d). The constraint is defined as \(_{i=1}^{n}\{w_{i}v_{i},0\} 10\) where \(w_{i}\) is the angular velocity of the \(i^{th}\) hinge, observed in the state.
* **Bike Sharing System (BSS):** The environment consists of \(m\) bikes and \(n\) stations, each with a capacity \(c\). At every RL step, the agent allocates \(m\) bikes among \(n\) stations based on previous allocation and demand while adhering to capacity constraints. The agent's action \(a=(a_{1},a_{2},..a_{n})\) must satisfy \(_{i=1}^{n}a_{i}=m\) and \(0 a_{i} c\). We evaluate our approach on a specific scenario with \(n=5\), \(m=150\), and \(c=35\) as in . It poses a significant challenge due to the large combinatorial action space of \(151^{5}\).

**Baselines** We compare our approach \(\) with the following two baselines.

* **DDPG+P:** DDPG+Projection is an extension of the vanilla DDPG , which introduces an additional step to ensure feasible actions. Invalid actions are projected onto the feasible action space by solving an optimization problem.
* **NFWPO  :** This algorithm efficiently explores feasible action space by using the Frank-Wolf method, and is also state-of-the-art approach for ACRL.

**Learning the Normalizing Flows** We employ different techniques to generate random samples from the valid action set in each environment. For the Reacher and Half Cheetah environments, we utilize HMC to generate random samples. Specifically, we generate 1 million random samples for training, which could take up to 5 minutes based on the constraint. HMC is more efficient than rejection sampling and a comparison is available in Appendix A. In the Reacher and Half Cheetah environments, all samples generated by HMC are valid actions, which shows the effectiveness of HMC compared to traditional rejection sampling which only produces 3.93%, 4.70% valid actions respectively. For the BSS environment, we use a \(\) to sample valid actions and obtain all valid actions from the \(\) to train the flow. Additional information on compiling the linear constraints into a \(\) and statistics about the \(\) are provided in the Appendix A.

We apply batch gradient descent to train the conditional flow with Adam optimizer and a batch size of 5000. For Reacher, Half Cheetah, Hopper and Walker2d environments, we train the model for 5K epochs. For BSS environment, we train for 20K epochs. Further details about the training the flow such as learning rates, and neural network architecture of the model are provided in the Appendix B.

Figure 2: (a) Policy network; (b) The reversed gradient path of \(\) (in blue). Nodes denote variables and edges denote operations. Paths in black are detached for \(\). The green block is a negative loss (assuming a minimization task).

The source code of our implementation is publicly available1. To evaluate the accuracy of the flow model, we sample 100K random points from the uniform distribution \([-1,1]\), and then apply the flow. We measure the accuracy based on whether the output lies within the feasible action region. Our flow model was able to produce 99.98%, 97.25%, 87.89%, 86.58% and 85.56% accuracy respectively for Reacher, Half Cheetah, Hopper, Walker2d and BSS environments. Further, we compute the average recall over all uniformly sampled states to obtain the recall of our flow model using Equation 9. The achieved recall rates for our trained normalizing flow models were 97.85%, 78.01%, 81.61%, 83.58%, and 82.35% respectively for Reacher, Half Cheetah, Hopper, Walker2d and BSS environments. More details such as time are available in Table 1 in Appendix B.

**Comparing with other generative models** We conduct an ablation study comparing two other generative models VAE and WGAN (which is more stable than GAN) in Reacher domain. We first evaluated the accuracy by calculating the percentage of valid actions among 100k generated actions. The accuracy rates were as follows: Normalizing flows: 99.98%; WGAN 98%; VAE: 83%. We then considered the recall rate. Our flow model can achieve a recall rate of 97.85%. In contrast, recall rate cannot be computed in a straightforward fashion in VAE and WGAN since determining the corresponding latent action for a given valid action is not possible . Nonetheless, we still can visualize the coverage of VAE and WGAN. In Figure 3, we can see that the feasible region is not fully covered in both VAE and WGAN models, while it is well covered in the normalizing flow model.

**Results** We present the empirical results of our approach and the baselines on three different environments to show the effectiveness of our method in terms of low constraint violations and achieving fast training speeds. We report results using ten different random seeds. To make a fair comparison, we keep the architectures of our policy network (with the exception of the Tanh layer and the normalizing flow model) and the critic network identical to those used in the baseline approaches. For the detailed pseudo-code of our approach and the neural network architectures along with hyperparameters, please refer to the appendix.

Figure 4(a) shows the average return of all three approaches over the training steps. Our approach achieves a comparable average return to NFWPO in the challenging Half Cheetah, Hopper and Walker2d environments. Additionally, our approach outperforms the other two approaches in terms of average return in the Reacher and BSS environments. We note that DDPG+P suffers from the zero gradient issue, leading to convergence to a lower average return.

In Figure 4(b), we present the cumulative constraint violations before projection for all three approaches over the training steps, with the y-axis represented in log-scale. In all environments, except for the more challenging Walker2d, our approach demonstrates the fewest cumulative constraint violations before projection. In the Reacher and Half Cheetah environments, it notably reduces the violations by an order of magnitude. Moreover, although our approach sometimes generates infeasible actions, they tend to be located near the feasible region, which can be inferred from the average magnitude of constraint violations. To quantify the magnitude of constraint violations, we consider a constrained set \(\) defined with \(m\) inequality constraints and \(n\) equality constraints: \(\{x|x^{d},f_{i}(x) 0,h_{j}(x)=0,i=1,,m,j=1,,n\}\). We define the magnitude of constraint violations as \(CV(x)=_{i=1}^{m}(f_{i}(x),0)+_{j=1}^{n}(||h_{j}(x)|- |,0)\), where \(=0.1\) represents the error margin for the equality constraint. Figure 4(c) illustrates the average magnitude of constraint violations over training steps, with the y-axis presented in log-scale. Our approach exhibits the lowest average magnitude of constraint violations in all environments except Hopper and

Figure 3: Mapping between a uniform distribution and action space of Reacher with constraint \(a_{1}^{2}+a_{2}^{2} 0.05\)

Walker2d. In the Reacher, Half Cheetah, Hopper and Walker2d environments, the average magnitude of constraint violations is close to zero, indicating that the invalid actions are very close to the feasible region. In the BSS environment, our approach shows slightly higher average magnitude due to the integer property of the actions. The low number of cumulative constraint violations and lower average magnitude of constraint violations demonstrate the effectiveness of our learned flow model.

In Figure 4(d), we show the runtime of the training process. Our approach demonstrates a significantly faster training time compared to NFWPO, with a speed improvement of 2\(\)3 times. This speed advantage is attributed to the fact that NFWPO requires computationally expensive QP solutions to determine the policy update direction within the feasible action space. In contrast, our approach utilizes the learned normalizing flow model to generate valid actions, with the flow model parameters frozen during the policy update. Although DDPG+P shows a faster runtime, it comes at the expense of a lower average return and higher constraint violations.

## 5 Conclusion

In this work, we present a novel approach called \(\) based on Normalizing Flows to address action constraints in RL. The architecture of \(\) allows the policy network to generate actions within the feasible action region. Furthermore, our experimental results demonstrate that \(\) effectively handles action constraints and outperforms the previous best method by significantly reducing the number of constraint violations while having faster training speeds.

Figure 4: Training curves for the Reacher, Half Cheetah, and BSS environments are displayed in columns from left to right, showcasing the Average Return(\(\)), Cumulative Constraint Violations(\(\)), Average Magnitude of Constraint Violations(\(\)), and Time Elapsed(\(\)).