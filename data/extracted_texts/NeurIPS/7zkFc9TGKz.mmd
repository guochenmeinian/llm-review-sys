# LD\({}^{2}\): Scalable Heterophilous Graph Neural Network

with Decoupled Embeddings

 Ningyi Liao

Nanyang Technological University

liao0090@e.ntu.edu.sg

&Siqiang Luo

Nanyang Technological University

siqiang.luo@ntu.edu.sg

Corresponding author.

Xiang Li

East China Normal University

xiangli@dase.ecnu.edu.cn

&Jieming Shi

Hong Kong Polytechnic University

jieming.shi@polyu.edu.hk

###### Abstract

Heterophilous Graph Neural Network (GNN) is a family of GNNs that specializes in learning graphs under heterophily, where connected nodes tend to have different labels. Most existing heterophilous models incorporate iterative non-local computations to capture node relationships. However, these approaches have limited application to large-scale graphs due to their high computational costs and challenges in adopting minibatch schemes. In this work, we study the scalability issues of heterophilous GNN and propose a scalable model, LD\({}^{2}\), which simplifies the learning process by decoupling graph propagation and generating expressive embeddings prior to training. Theoretical analysis demonstrates that LD\({}^{2}\) achieves optimal time complexity in training, as well as a memory footprint that remains independent of the graph scale. We conduct extensive experiments to showcase that our model is capable of lightweight minibatch training on large-scale heterophilous graphs, with up to \(15\) speed improvement and efficient memory utilization, while maintaining comparable or better performance than the baselines. Our code is available at: [https://github.com/gdmnl/LD22](https://github.com/gdmnl/LD22)

## 1 Introduction

Graph Neural Networks (GNNs) combine graph management techniques and neural networks to learn from graph-structured data, and have shown remarkable performance in diverse graph processing tasks, including node classification , link prediction , and community detection . Common GNN models rely on the principle of _homophily_, which assumes that connected nodes tend to be similar to each other in terms of classes . This inductive bias introduces additional information from the graph structure and improves model performance in appropriate tasks .

However, this assumption does not always hold in practice. A broad range of real-world graphs are _heterophilous_, where class labels of neighboring nodes usually differ from the ego node . In such cases, the aggregation mechanism employed by conventional GNNs, which only passes messages from a node to its neighbors, may mix the information from non-homophilous nodes and cause them to be less discriminative. Consequently, the locality-based design is considered less advantageous or even potentially harmful in these applications . Various solutions have been proposed to address the heterophily problem, giving rise to a class of specialized GNNs known as heterophilous GNNs. Common strategies to address heterophily include discovering multi-hop or global graph relations , , , , and retrieving expressive node information through enhanced network architectures , , , , , .

[MISSING_PAGE_FAIL:2]

[MISSING_PAGE_FAIL:3]

**Decoupled GNNs.** As the scalability of GNN is closely tied to the graph propagation, a promising approach to simplify the process is decoupling it from iterative training and efficiently computing it in advance. The representative two-stage model SGC  encodes graph information with \(\) into an embedding matrix \(=}^{L_{P}}\), which is then input to a Multi-Layer Perceptron \(^{(L)}=()\).  further generalize the embedding aggregation. Such decoupled GNN is considered optimal for training efficiency, as its time complexity \(O(ILnF)\) is identical to the simple MLP .

However, applying the decoupling technique to heterophilous GNNs is non-trivial due to the full-graph relationships. To our knowledge, LINKX  is the only model conceptually similar to this scheme, removing graph-related propagation during training iterations and enabling solely node-wise minibatching. It exploits a simple architecture \(^{(L)}=(_{X}\|_{A})\), where the matrix \(\) is used as an input feature in learning. The major drawback of this design is that it suffers from the \(O(nF)\) term in model size and \(O(mF)\) term in forward time, hindering its scalability to large graphs.

## 3 Method

In this section, we first present an overview of our LD\({}^{2}\) model, then respectively elaborate on the selection of the adjacency and feature embeddings. Lastly, an end-to-end scalable algorithm, namely A\({}^{2}\)Prop, is proposed to efficiently and concurrently compute all the embeddings.

### LD\({}^{2}\): A Decoupled Heterophilous GNN

In order to achieve superior time and memory scalability for heterophilous GNNs, we employ the concept of decoupling, which removes the dependency of graph adjacency propagation in training iterations. The main idea of our model is first generating _embeddings_ from raw _features_ including node attributes and adjacency in a precomputation stage. Then, these embeddings are taken as inputs to learn _representations_ by a simple neural network model. We embrace the multi-channel architecture  to enhance flexibility, where the input data is a list consisting of embedding matrices \([_{1},_{2},,_{C}]\). Each embedding is separately processed and then merged in the network.

LD\({}^{2}\) utilizes diverse embeddings based on pure graph adjacency and node attributes, denoted as \(_{A}()\) and \(_{X}(,)\), respectively. Both types of embeddings can be produced by our precomputation A\({}^{2}\)Prop following Algorithm . The initial layer of the LD\({}^{2}\) network applies a separate linear transformation to each embedding input, and the results are concatenated to form the representation matrix. Lastly, an \(L\)-layer MLP is leveraged for the classification task. The high-level framework of LD\({}^{2}\) is depicted in Figure  and can be expressed as follow:

\[:_{A},_{X}=^{2}(, );\ \ :^{(L)}=(_{A}_{A} \|_{X}_{X}). \]

**Training/Inference Complexity.** Our decoupled model design enables a simple on-demand minibatch scheme in training and inference, that only \(n_{b}\) rows corresponding to the batch nodes in the embedding matrices are loaded into GPU and processed by the network transformation. For LD\({}^{2}\) with \(C\) channels, the GPU memory footprint is therefore bounded by \(O(L_{C}n_{b}F+L_{C}F^{2})\). It is worth noting that such complexity does not depend on the graph scale \(n\) or \(m\). Consequently, the training is freely configurable with an arbitrary GPU memory budget. Regarding computation operations, the time complexity of forward inference through the graph is \(O(LnF^{2})\), being just linear to \(n\). As

Figure 1: LD\({}^{2}\) framework: decoupled precomputation and training. Figure 2: Propagations under heterophily.

the model complexity only contain essential operations of MLP-like transformation on nodes in the graph with no additional expense, this is the optimal scale with respect to the iterative training of GNN architectures.

### Low-Dimensional Adjacency Embedding

Several studies reveal that, despite the feature information of nodes, the pure graph structure is equally or even more important in the context of heterophilous GNNs . Particularly, the most informative aspects are often associated with 2-hop neighbors, i.e., "neighbors of neighbors" of ego nodes.  proves that even under heterophily, the 2-hop neighborhood is expected to be homophily-dominant.  also verifies that the 2-hop similarity is strongly relevant to GNN performance. We thence intend to explicitly model such topological information.

The 2-hop relation can be described by the 2-hop adjacency matrix \(^{2}\). Note that as the sparse matrix \(\) has \(m\) entries, the number of entries in \(^{2}\) is at the scale of \(O(md)\), which indicates that directly applying 2-hop graph propagation in the training stage will demand even more expensive time and memory overhead to be scaled up. We instead propose an approximate scheme that seeks to prevent the 2-hop adjacency from explicit processing, and retrieves a low-dimensional but expressive embedding prior to training in the precomputation stage. In other words, we utilize the embedding to resemble 2-hop information which can be directly learned by the neural network transformation. Denote the \(F\)-dimensional embedding matrix as \(_{A}^{n F}\). We aim to minimize its approximation error in Frobenius norm \((\|\|_{F})\):

\[_{A}=*{arg\,min}_{^{n F}}\| ^{2}-^{T}\|_{F}^{2}. \]

The solution to Eq. 2 can be derived from the eigendecomposition of the symmetric matrix \(^{2}\), that \(_{A}^{*}=||^{1/2}\), where \(=(_{1},,_{F})\) is the diagonal matrix with top-\(F\) eigenvalues \(_{1}_{2}_{F}\), and \(^{n F}\) is the matrix consisting of corresponding orthogonal eigenvectors. The eigenvalues are also called _frequencies_ of the graph, and large eigenvalues of the adjacency matrix refer to low-frequency signals in the graph spectrum.

**Spectral Analysis.** Let \(A_{2}(u,v)\) be the entry \((u,v)\) of matrix \(^{2}\). Its diagonal degree matrix is \(_{2}=(d_{2}(u_{1}),d_{2}(u_{2}),,d_{2}(u_{n}))\), where \(d_{2}(u)=_{v V}A_{2}(u,v)\). Denote \(_{A}(u)\) as the \(F\)-dimensional adjacency embedding vector of node \(u\). We show that the embedding matrix \(_{A}^{*}\) defined by Eq. 2 is also the solution to the following optimization problem:

\[_{A}=*{arg\,min}_{^{n F},^{ }_{2}=}\;_{u,v V}A_{2}(u,v)\|(u)-(v)\|^{2}. \]

This is because \(_{u,v}A_{2}(u,v)\|(u)-(v)\|^{2}=2_{u}d_{2}(u)\|(u)\|^ {2}-2_{u,v}A_{2}(u,v)(u)(v)=2(^{} _{2}-^{}^{2})\). As \(^{}_{2}\) is fixed, finding the minimum of Eq. 3 is equivalent to optimizing \(_{}^{}^{2}\), of which the solution is exactly \(_{A}^{*}\) according to the property of eigenvectors. Equation 5 implies that, 2-hop neighbors \((u,v),t(u),v(t)\) in the graph will share similar embeddings \(_{A}(u)\) and \(_{A}(v)\).

In fact, the low-dimensional embedding \(_{A}^{*}\) can be interpreted as the adjacency spectral embedding of the 2-hop graph \(^{2}\). Graph spectral embedding is a technique concerning the low-frequency spectrum of a graph, and is employed in tasks such as graph clustering . As \(_{A}\) corresponds to the dominant eigenvalues of \(^{2}\), the embedding provides an approximate representation of the 2-hop neighborhoods based on the overall graph topology. Alternatively, if we regard the adjacency information solely as features input into the network like LINKX, \(_{A}\) correlates to the uncentered principal components of matrix \(\). Therefore, learning a linear transformation \(_{A}_{A}\) with weight matrix \(_{A}^{F F}\) in LD\({}^{2}\) is the same expressive as the rank-\(F\) approximation of \(_{A0}\) in LINKX, where \(_{A0}^{n F}\), but with a less computational cost independent to the graph scale. Compared to other works attempting to generate graph embeddings based on graph geometric or similarity measures [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 82, 84, 89, 91, 85, 86, 87, 89, 92, 93, 94, 95, 96, 97, 98, 99, 99, 99, 98, 99, 99, 99, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 111, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 12based on the homophily assumption and focus on local neighborhoods. In order to apply decoupled propagation to heterophilous graphs and exploit the multi-channel ability of our model, we formulate the general form of approximate propagation as the weighted sum of powers of a propagation matrix applied to the input feature, i.e., \(_{X}=_{l=1}^{L_{P}}_{l}^{l}\). Examples of propagation matrix \(\) include \(}\) and \(}\), which respectively correspond to aggregating and discriminative operations.

LD\({}^{2}\) utilizes the following channels jointly as input embeddings: (1) _inverse_ summation of 1-hop improved Laplacian propagations \(_{X,H}=}_{l=1}^{L_{P},H}(+})^{l} \), (\(_{l}=1\), \(=+}\)); (2) _constant_ summation of 2-hop adjacency propagations \(_{X,L2}=}_{l=1}^{L_{P,L2}}}^{2l}\), (\(_{l}=1\), \(=}^{2}\)); (3) raw node attributes \(_{X,0}=\).

Intuitively, the first two channels perform distinct topology-based propagations on node feature \(\), and employ inverse or constant summation to aggregate multi-hop information, in contrast to the local _decaying_ summation (\(_{l} 0\) when \(l\)) commonly adopted in homophilous GNNs. Hence, such summations are suitable for retrieving long-range information under heterophily. The raw matrix \(\) is also directly used as one input channel to depict node identity, which is a ubiquitous practice known as the skip connection or all-pass filter in heterophilous GNNs .

Illustrated in Figure 2 the inverse embedding \(_{X,H}\) is based on the intuition that, as neighbors tend to be different from the ego node, their features are also dissimilar. Hence in propagation, the embedding of the ego node should contain the previous embedding of itself, as well as the inverse of adjacent embeddings, which is exactly the interpretation of propagating node features by graph Laplacian matrix \(}=-}\), while an additional identity matrix is applied to balance the embedding distribution. The second embedding \(_{X,L2}\) performs a 2-hop propagation through the graph and aggregates the results of multi-scale neighbors. It echoes the earlier statement on the importance of 2-hop adjacency from the feature aspect. Note that for \(_{X,L2}\), the employed adjacency matrix is \(}\) which escapes self-loops, since it is shown to be relatively favorable for capturing non-local homophily in multi-hop propagations compared with \(}\).

**Spectral Analysis.** Assume that \(\|(u)\|=\|(u)\|=1\). We first examine the following regularization problem optimizing the embedding \(\) based on input \(\) for homophilous graphs :

\[_{X,L}=*{arg\,min}_{\|(u)\|=1, u  V}\ _{u,v V}A(u,v)\|(u)/d^{a}(u)-(v)/d^{b}(v)\|^{2}+\| -\|_{F}^{2}. \]

Differentiating the objective function with respect to \(\) leads to \((-})-=0\). Therefore the closed-form solution is \(_{X,L}^{*}=(-})^{-1}=_{l=0}^{}}^{l}\). In practical implementation, a limited \(L_{P,L}\)-hop summation is used instead due to the over-smoothing issue that the infinite form converges to identical node-wise embeddings. This Markov diffusion kernel \(_{X,L}=}_{l=0}^{L_{P,L}}}^{l}\) is investigated in S\({}^{2}\)GC  as an approach for balancing locality and multi-hop propagation, functioning as a low-pass filter to the signal \(\) but also preserves high frequency. Its interpretation can be observed from Eq. (4), that it simultaneously minimizes the embedding difference of neighboring nodes as well as the approximation closeness to the input feature \(\).

To obtain the channel \(_{X,L2}\) used in LD\({}^{2}\), we introduce the low-frequency regularization preferably to 2-hop adjacency in the graph, as 1-hop neighbors exhibit heterophily. Therefore, replacing \((u,v)\) in Eq. (4) with \(_{2}(u,v)\) yields our constant 2-hop embedding \(_{X,L2}\). It shares similar spectral properties with S\({}^{2}\)GC for acting as a low-pass filter in 2-hop neighborhoods, while maintaining certain long-distance knowledge thanks to the multi-scale aggregation. The other channel in feature embedding, i.e. the Laplacian propagation, can be derived as \(_{X,H}=(+})(-})^{-1}=( +})_{X,L}\). Based on the above analysis, the embedding \(_{X,L}\) contains multi-hop neighborhood information, while \((+})\) can be seen as the improved Laplacian operator extracting the high-frequency components. The embedding \(_{X,H}\) thus serves as a high-pass filter focusing on discriminative structures in a non-local manner. In terms of spatial domain interpretation, such high-frequency information corresponds to the fine-grained embedding differences between two nodes . It is noticeable that these three channels \(_{X,L2},_{X,H},_{X,0}\) respectively represent low-pass, high-pass, and all-pass propagations through the graph while addressing heterophily. Combining them as inputs to the neural network benefits the model performance with expressive information at various distances including identity, local, and global perspectives.

### Approximate Adjacency Propagation Precomputation

Conventionally, calculating the graph propagation \(}\) for an arbitrary feature matrix \(\) is conducted by the sparse-dense matrix multiplication. However, such an approach does not recognize the property of the adjacency matrix \(}\), that it can be represented by the adjacency list of nodes, and non-zero values in its data are solely determined by node degrees. Furthermore, since the propagation result is subsequently processed by the neural network, it is not necessary to be precise as the model is robust to handle noisy data . We first define the precision bound for approximate embedding:

**Definition 3.1** (Approximate Vector Embedding).: _Given a relative error bound \(0<<1\), a norm threshold \(>0\), and a failure probability \(0<<1\), the estimation \(}(u)\) for an arbitrary embedding vector \((u)\) should satisfy that, for each \(u V\) with \(\|(u)\|>\), \(\|(u)-}(u)\|\|(u)\|\) with probability at least \(1-\)._

Graph power iteration algorithm is the variant of power iteration particularly applied for calculating powers of adjacency matrix \(\). In essence, the algorithm can be derived by maintaining a _residue_\(^{(l)}(u)\) that holds the current \(l\)-hop propagation results for each node, and iteratively updating the next-hop residues of neighboring nodes \(^{(l+1)}(v),v(u)\) for all nodes \(u\). For each iteration, the _reserve_\(}^{(l)}\) is also added up and converges to an underestimation of \(\).

We propose Algorithm  for our specific scenario, namely Approximate Adjacency Propagation (A\({}^{2}\)Prop). Based on power iteration, our algorithm is greatly generalized to accommodate normalized adjacency, feature vectors for nodes, and a limited number of hops. We show that the algorithmic output can be bounded by Definition . For \(L_{P}\) iterations, denote the acceptable error per entry for push as \(_{P}\), the matrix-wise absolute error is \(\|-}\|_{1,1}_{f=1}^{L_{P}}_{u V}^{F}d(u)_ {P}=L_{P}mF_{P}\). By setting \(_{P}=/L_{P}m\), the estimation \(}\) satisfies Definition .

Approximate Feature Embedding.The feature embedding formed as \(_{X}=_{l=0}^{L_{P}}_{l}^{T}\) can be computed by iteratively applying graph power iterations to the initial residue \(^{(0)}=\). The implicit propagation behavior is described by matrix \(\). For example, for Laplacian propagation \(=+}\) to node \(u\), the embeddings from the previous iteration are aggregated as \(^{(l+1)}(u)=2^{(l)}(u)-_{v(u)}^{(l)}(v)/d^ {u}(u)d^{b}(v)=_{v(u)\{u\}}(u,v)}{d^{a}( u)d^{b}(v)}^{(l)}(v)\). Here \(_{T}(u,v)\) is a propagation factor for unifying the aggregation by \(\), that \(_{L}(u,u)=2d^{a+b}(u),_{L}(u,v)=-1,v(u)\). For propagation \(}\) and \(}\), the factor is \(_{A}(u,v)=1\) and \(_{A}(u,u)=1,0\), respectively.

In each iteration \(l\), the reserve is updated after propagation according to the coefficient \(_{l}\) to sum up corresponding embeddings. Intuitively, one multiplication of \(}^{2}\) is equivalent to two iterations of \(}\) propagation. Hence for \(_{X,L2}\) there is \(_{l}=l 2=0,1,0,1,\) under the summation scheme

Figure 3: Effect of embedding channels and propagation hops on accuracy.

in Algorithm . Since all embeddings we consider are constant, that is, \(_{l}\{0,1\}\), the reserve can be simply increased without the rescaling terms in more general cases such as .

Approximate Adjacency Embedding.The adjacency embedding is represented by leading eigenvectors \(_{A}=||^{1/2}\). This eigendecomposition of \(^{2}\) can be solved by the truncated power iteration : Initialize the \(n F\) residue by i.i.d. Gaussian noise \(^{(0)}=N(0,1)\). For each iteration \(l\), firstly multiply the residue by \(^{2}\) as \(^{(l+1)}=^{2}^{(l)}\); then, perform column-wise normalization to the residue \((^{(l+1)})\) so that its columns are orthogonal to each other and of L2 norm \(1\). After convergence, the matrix satisfies \(^{2}^{(L_{P})}=^{(L_{P})}\) within the error bound, which leads to the estimated output \(}=^{(L_{P})},}_{A}=}|} |^{1/2}\).

Similarly, the 2-hop power iteration of \(_{A}\) can be merged with those for \(_{X}\) with a shared maximal iteration \(L_{P}\), and orthonormalization is conducted every two \(\) iterations. When the algorithm converges with error bound \(\), the number of iteration follows \(L_{P}=O((F/)/(1-|_{F+1}/_{F}|))\). By selecting proper values for \(F\) and \(\), the algorithm produces satisfying results within \(L_{P}\) iterations.

Precomputation Complexity.Since A\({}^{2}\)Prop serves as a general approximation for various adjacency-based propagations, the computation of all feature channels can be performed simultaneously in a single run. The memory overhead of the algorithm is mainly the residue and reserve matrices for \(C\) embedding channels, which is \(O(CnF)\) in total. Note that A\({}^{2}\)Prop precomputation is performed in the main memory, and benefits from a less-constrained budget compared to GPU memory.

For each A\({}^{2}\)Prop iteration, neighboring connections are accessed for at most \(m\) times. The time complexity of Algorithm  can thus be bounded by \(O(L_{P}mF)\). In addition, its loops over nodes and features can be parallelized and vectorized to reduce execution time. Moreover, the graph power iteration design is also amendable for further enhancements, such as reduction to sub-linear complexity , better memory utilization , and precision-efficiency trade-offs . We leave these potential improvements on A\({}^{2}\)Prop for future work.

## 4 Experimental Evaluation

We implement the LD\({}^{2}\) model and evaluate its performance from the perspectives of both efficacy and scalability. In this section we highlight key empirical results compared to minibatch GNNs on large-scale heterophilous graphs, while parameter settings, further experiments, and subsequent discussions can be found in the Appendix.

### Experiment Setting

Datasets.We mainly perform experiments on million-scale and above heterophilous datasets  for the transductive node classification task, with the largest available graph wiki (\(m=243\)) included. Evaluations on more homophilous and heterophilous graphs can be found in Appendices D and E. We leverage settings as per  such as the random train/test splits and the induced subgraph testing for GSAINT-sampling models.

Baselines.We focus on GNN models applicable to _minibatch_ training in our evaluation regarding scalability, and hence most _full-batch_ networks mentioned in Section E are excluded in the main experiments, while more comprehensive results for both minibatch and full-batch models are in Appendices D and E. Conventional baselines in the main experiments include MLP which only processes node attributes without considering graph topology, as well as PPRGo  and SGC  representing decoupled schemes for traditional graph propagation. For GNNs under non-homophily, we investigate GCNJK-GS  and MixHop-GS , where GSAINT random walk sampling  is utilized to empower the original backbone models for minibatching. LINKX is the decoupled heterophilous GNN proposed by . Simple i.i.d. node batching is adopted for decoupled networks. Explorations on the model settings are displayed in Appendix E.

Evaluation Metrics.We uniformly use classification accuracy on the test set to measure network effectiveness. Note that since the datasets are updated and the minibatch scheme is employed, results may be different from their original works. In order to evaluate scalability performance, we conduct repeated experiments and record the network training/inference time and peak memory footprint as efficiency metrics. For precomputed methods, we consider the learning process combining both precomputation and training. Evaluations are conducted on a machine with 192GB RAM, two 28-core Intel Xeon CPUs (2.2GHz), and an NVIDIA RTX A5000 GPU (24GB memory).

### Performance Comparison

The main evaluations of LD\({}^{2}\) and baselines on 8 large heterophilous datasets are presented in Tables 2 and 3 for effectiveness and efficiency metrics, respectively. As an overview, our model demonstrates its scalability in completing training and inference with fast running speed and efficient memory utilization, especially on large graphs. At the same time, it achieves comparable or superior prediction accuracy against the state-of-the-art minibatch heterophilous GNNs on most datasets.

**Time Efficiency.** We first highlight the scalability performance of our LD\({}^{2}\) model. Specifically, compared to heterophilous benchmarks on the four largest graphs with million-scale data, LD\({}^{2}\) speeds up the minibatch training process by 3-15 times, with an acceptable precomputation cost. Its inference time is also consistently below 0.1 seconds. The outstanding efficiency of LD\({}^{2}\) is mainly attributed to the simple model architecture that removes graph-scale operations while ensuring rapid convergence. In contrast, the execution speeds of MixHop and LINKX are highly susceptible to node and edge sizes, given their design dependency on the entire input graph. The extensive parameter space also causes them to converge slower, necessitating relatively longer training times. PPRGo shows limited scalability due to the costly post-transformation propagation. The superiority of LD\({}^{2}\) efficiency even holds when compared to simple methods such as MLP and SGC, indicating that the model is favorable for incorporating extra heterophilous information with no significant additional overhead. The empirical results affirm that LD\({}^{2}\) exhibits optimized training and inference complexity at the same level as simple models.

**Memory Footprint.** LD\({}^{2}\) remarkably reduces run-time GPU memory consumption. As the primary overhead only comprises the model parameters and batch representations, it enables flexible configuration of the model size and batch size to facilitate powerful training. Even for the largest graph

  
**Dataset** & **genius** & **tolokers** & **arxiv-year** & **penn94** & **twitch-gamers** & **pokec** & **snap-patents** & **wiki** \\  Nodes \(n\) & 421,858 & 11,758 & 169,343 & 41,536 & 168,114 & 1,632,803 & **2,738,035** & 1,770,981 \\ Edges \(m\) & 922,864 & 1,038,000 & 1,157,799 & 1,362,220 & 6,797,557 & 22,301,964 & 13,967,949 & **242,507,069** \\ \(F\)\(/\)\(N_{c}\) & 12 / 2 & 10 / 2 & 128 / 5 & 4,814 / 2 & 7 / 2 & 65 / 2 & 269 / 5 & 600 / 5 \\  MLP & 82.47 \(\)0.06 & 73.38 \(\)0.25 & 37.23 \(\)0.31 & 74.41 \(\)0.48 & 61.26 \(\)0.19 & 61.81 \(\)0.07 & 23.03 \(\)1.48 & 35.64 \(\)0.10 \\ PPRGo & 79.81 \(\)0.00 & 78.16 \(\)0.00 & 39.35 \(\)0.12 & 58.75 \(\)0.31 & 47.19 \(\)2.26 & 50.61 \(\)0.04 & (>12h) & (>12h) \\ SGC & 79.85 \(\)0.01 & 71.16 \(\)0.06 & 43.40 \(\)0.16 & 68.31 \(\)0.27 & 57.05 \(\)0.21 & 56.58 \(\)0.06 & 37.70 \(\)0.06 & 28.12 \(\)0.08 \\ GCNVL-GS & 80.65 \(\)0.07 & 74.41 \(\)0.73 & 48.26 \(\)0.64 & 65.91 \(\)0.16 & 59.91 \(\)0.42 & 59.38 \(\)0.21 & 33.64 \(\)0.05 & 42.95 \(\)0.39 \\ MixHop-GS & 80.63 \(\)0.04 & 77.47 \(\)0.40 & 49.26 \(\)0.16 & 75.00 \(\)0.37 & 61.80 \(\)0.06 & 64.02 \(\)0.02 & 34.73 \(\)0.15 & 45.52 \(\)0.11 \\ LINKX & 82.51 \(\)0.10 & 77.74 \(\)0.13 & **50.44**\(\)0.30 & **78.63**\(\)0.25 & 64.15 \(\)0.18 & 68.64 \(\)0.65 & 52.69 \(\)0.05 & 50.59 \(\)0.12 \\
**LD\({}^{2}\) (ours)** & **85.31**\(\)0.06 & **79.76**\(\)0.26 & 50.29 \(\)0.11 & 75.52 \(\)0.10 & **64.33**\(\)0.19 & **74.93**\(\)0.10 & **58.58**\(\)0.34 & **52.91**\(\)0.16 \\   

Table 2: Average test accuracy (%) of minibatch LD\({}^{2}\) and baselines on heterophilous datasets. “\(>12\)h” means the model requires more than \(12\)h clock time to produce proper results. Respective results of the first and second best performances on each dataset are marked in **bold** and underlined fonts.

    &  &  &  &  \\  & Learn & Infer & Mem. & Learn & Infer & Mem. & Learn & Infer & Mem. & Learn & Infer & Mem. \\  MLP & 6.36 & 0.02 & 0.61 & 47.86 & 0.11 & 13.77 & 27.39 & 0.28 & 9.33 & 133.55 & 0.62 & 18.15 \\ PPRGo & 10.46+15.88 & 0.41 & 9.64 & 121.95+56.11 & 2.69 & 3.82 & & (>12h) & & & (>12h) \\ SGC & 0.09+0.74 & 0.01 & 0.28 & 1.05+8.08 & 0.01 & 0.28 & 4.94+23.54 & 0.01 & 0.42 & 12.66+7.98 & 0.01 & 0.52 \\  GCNVL-GS & 71.48 & 0.02\({}^{*}\) & 7.33 & 27.33 & 0.09\({}^{*}\) & 9.03 & 19.02 & 0.23\({}^{*}\) & 9.21 & 95.52 & 0.69\({}^{*}\) & 16.36 \\ MixHop-GS & 52.12 & 0.01\({}^{*}\) & 1.49 & 71.35 & 0.03\({}^{*}\) & 12.91 & 45.24 & 0.16\({}^{*}\) & 19.58 & 84.22 & 0.23\({}^{*}\) & 16.28 \\ LINKX & 10.99 & 0.19 & 2.35 & 28.77 & 0.33 & 9.03 & 39.80 & 0.22 & 21.53 & 180.71 &wiki with \(n=1.77\) and \(F=600\), the footprint remains below \(5\) under our hyperparameter settings. Other heterophilous GNNs, though adopting the minibatch scheme, experience high memory requirements and even occasionally encounter out-of-memory errors during experiments, as their space-intensive graph propagations are executed on the GPU. Consequently, when the graph scales up, they can only be applied with highly constrained model capacities to conserve space, potentially resulting in compromised performance.

**Test Accuracy.** With regard to efficacy, LD\({}^{2}\) achieves top testing accuracy on 6 out of 8 heterophilous graphs and comparable performance on the remaining ones. It also consistently outperforms the sampling-based GCNJK and MixHop, as well as conventional GNNs. Particularly, by extracting embeddings from not only node features but pure graph topology as well, LD\({}^{2}\) obtains significant improvements over feature-based networks on datasets such as genius, snap-patents, and wiki, demonstrating the importance of pure graph information in heterophilous learning. We deduce that the relatively suboptimal accuracy on penn94 may be correlated with the difficulty of fitting one-hot encoding features into informative embeddings, as explored in Appendix C. Consistent with the previous studies , regular GNN baselines suffer from performance loss on most heterophilous graphs, while MLP achieves comparably high accuracy when node attributes are discriminative enough. For non-homophilous models GCNJK and MixHop, the minibatch scheme hinders them from reaching higher results because of the neglect of their full-graph relationships.

### Effect of Parameters

To gain deeper insights into the multi-channel embeddings of LD\({}^{2}\), in Figure 3 we explore the effect of embeddings channels and propagation hops which are critical to our model design, while more discussions on other parameters and factors are displayed in Appendix E.

**Embedding Channels.** Lines in Figure 3 represent the results of learning on separate inputs on two representative datasets genius and pokec. It can be observed that different graphs imply varying patterns when embedding channels and propagation hops are changed. For the genius dataset where raw node attributes already achieve an accuracy above 82%, applying the other two feature embeddings further improves the result. While the adjacency embedding alone shows secondary performance, integrating it with other channels proves beneficial. In comparison, on pokec, it is the inverse embedding \(_{X,H}\) that becomes the key contributor. The empirical evaluation supports our design that by adopting multi-channel and heterophily-oriented embeddings, LD\({}^{2}\) benefits from learning both topology and feature for a more comprehensive understanding of the graph data.

**Propagation Hops.** As elaborated in Section 3.4 propagation hops \(L_{P}\) determines the number of iterations in Algorithm  Particularly, for the approximate adjacency embedding \(_{A}\), it also affects the convergence of decomposition. As shown by the brown dashdotted lines in Figure 3 the accuracy typically becomes stable when \(L_{P}>8\), indicating the utility of the low-dimensional approximation in producing effective topology embedding within limited iterations. For the multi-channel scheme in general, as the graph scale increases, employing more propagation hops becomes advantageous in capturing distant information. Aligned with our analysis, above observation validates that LD\({}^{2}\) is powerful in capturing implicit information of various frequencies and scales that is important in the presence of heterophily.

## 5 Conclusion

In this work, we propose LD\({}^{2}\), a scalable GNN design for heterophilous graphs, that leverages long-distance propagation to capture non-local relationships among nodes, and incorporates low-dimensional yet expressive embeddings for effective learning. The model decouples full-graph dependency from the iterative training, and adopts an efficient precomputation algorithm for approximating multi-channel embeddings. Theoretical and empirical evidence demonstrates its optimized training characteristics, including time efficiency with a complexity linear to \(O(n)\), and GPU memory independence from the graph size \(n\) and \(m\). As a noteworthy result, LD\({}^{2}\) successfully applies to million-scale datasets under heterophily, with learning times as short as 1 minute and GPU memory expense below \(5\). We also recognize the current limitations of our work including potential accelerations for precomputation and adaptability to diverse feature patterns. Detailed limitations and broader impacts are addressed in the Appendix.