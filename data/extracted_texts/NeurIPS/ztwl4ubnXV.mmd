# OxonFair: A Flexible Toolkit for Algorithmic Fairness

Eoin Delaney

University of Oxford

&Zihao Fu

University of Oxford

Sandra Wachter

University of Oxford

&Brent Mittelstadt

University of Oxford

firstname.lastname@oii.ox.ac.uk

&Chris Russell

University of Oxford

###### Abstract

We present OxonFair, a new open source toolkit for enforcing fairness in binary classification. Compared to existing toolkits: (i) We support NLP and Computer Vision classification as well as standard tabular problems. (ii) We support enforcing fairness on validation data, making us robust to a wide range of overfitting challenges. (iii) Our approach can optimize any measure based on True Positives, False Positive, False Negatives, and True Negatives. This makes it easily extensible and much more expressive than existing toolkits. It supports all 9 and all 10 of the decision-based group metrics of two popular review articles. (iv) We jointly optimize a performance objective alongside fairness constraints. This minimizes degradation while enforcing fairness, and even improves the performance of inadequately tuned unfair baselines. OxonFair is compatible with standard ML toolkits, including sklearn, Autogluon, and PyTorch and is available at https://github.com/oxfordinternetinstitute/oxonfair.

## 1 Introduction

The deployment of machine learning systems that make decisions about people offers an opportunity to create systems that work for everyone. However, such systems can lock in existing prejudices. Limited data for underrepresented groups can result in ML systems that do not work for them, while the use of training labels based on historical data can result in ML systems copying previous biases. As such, it is unsurprising that AI systems have repeatedly exhibited unwanted biases towards certain demographic groups in a wide range of domains including medicine , finance , and policing . Such groups are typically identified with respect to legally protected attributes, such as ethnicity or gender . The field of algorithmic fairness has sprung up in response to these biases.

Contributions to algorithmic fairness can broadly be split into methodological and policy-based approaches. While much methodological work focuses on measuring and enforcing (un)fairness, a common criticism from the policy side is that this work can occur _'in isolation from policy and civil societal contexts and lacks serious engagement with philosophical, political, legal and economic theories of equality and distributive justice'_.

In response to these criticisms, we have developed OxonFair, a more expressive toolkit for algorithmic fairness. We acknowledge that people designing algorithms are not always the right people to decide on policy, and as such we have chosen to create as flexible a toolkit as possible to allow policymakers and data scientists with domain knowledge to identify relevant harms and directly alter the system behaviour to address them. Unlike existing Fairness toolkits such as AIF360 , which take a method-driven approach, and provide access to a wide range of methods but with limited control over their behaviour, we take a measure-based approach and provide one fairness method that is extremely customizable, and can optimize user-provided objectives and group fairness constraints.

To do this, we focus on one of the oldest and simplest approaches to group fairness: per-group thresholding [10; 11; 3], which is known to be optimal for certain metrics under a range of assumptions [3; 12; 13]. Our contribution is to make this as expressive as possible while retaining speed, for the relatively low number of groups common in algorithmic fairness. Inherently, any approach that allows a sufficiently wide set of objectives, and sets per-group thresholds will be exponential with respect to the number of groups, but we use a standard trick, widely used in the computation of measures such as mean absolute precision (mAP) to make this search as efficient as possible. Accepting the exponential complexity allows us to solve a much wider range of objectives than other toolkits, including maximizing F1 or balanced accuracy (see Figure 1 left), minimizing difference in precision , and guaranteeing that the recall is above k% for every group . Where groups are unavailable at test time, we simply use a secondary classifier to estimate group memberships [15; 16] and set different thresholds per inferred group to enforce fairness with respect to the true groups.

Thresholding can be applied to most pretrained ML algorithms, and optimal thresholds can be selected using held-out validation data unused in training. This is vital for tasks involving deep networks such as NLP and computer vision, where the training error often goes to zero, and fairness methods that balance error rates between groups cannot generalize from constraints enforced on overfitting training data to previously unseen test data . While overfitting is unavoidable in vision and NLP tasks, it is still a concern on tabular data. Figure 1 Top-Right, shows examples of decision trees, random forests  and XGBoost  trained with default parameters and obtaining 0 training error on standard datasets. This causes the Fairlearn reductions method  to fail to enforce fairness.

NLP and vision are so challenging that two popular toolkits Fairlearn and AIF360 do not attempt to work in these domains. In contrast, we target them, making use of a recent work  that showed how fair classifiers based on inferred group thresholds can be compressed into a single network.

## 2 Related Work

Bias mitigation strategies for classification have been broadly categorized into three categories [22; 23; 6; 24]: pre-processing, in-processing and post-processing.

Figure 1: **Left: The need for an objective when enforcing fairness. We evaluate a range of methods with respect to balanced accuracy and demographic parity (OxonFair generates a frontier of solutions). Only OxonFair and RejectOptimization optimize balanced accuracy. As we improve the balanced accuracy of fair methods by adjusting classification thresholds (gray lines) fairness deteriorates. To avoid this, we jointly optimize a fairness measure and an objective. For more examples, see Figure 6. Right Top: Using validation data in fairness. We compare against Fairlearn using standard algorithms with default parameters. These methods perfectly overfit and show no unfairness with respect to equal opportunity on the trainset, but substantial unfairness on test. OxonFair enforces fairness on held-out validation data and is less prone to overfitting. Right Bottom: A comparison of toolkits. AIF360 offers a large range of tabular methods, most of which do not allow fairness metric selection, Fairlearn offers fewer but more customizable tabular methods. OxonFair offers one method that can be applied to text, image, and tabular data, while supporting more notions of fairness and objectives.**

**Pre-processing** algorithms improve fairness by altering the dataset in an attempt to remove biases such as disparate impact  before training a model. Popular preprocessing approaches include simply reweighting samples in the training data to enhance fairness , optimizing this process by learning probabilistic transformations , or by generating synthetic data .

**In-processing / In-training** methods mitigate bias by adjusting the training procedure. Augmenting the loss with fair regularizers  is common for logistic regression and neural networks. Agarwal et al.  iteratively alter the cost for different datapoints to enforce fairness on the train set. Approaches based on adversarial training typically learn an embedding that reduces an adversary's ability to recover protected groups whilst maximizing predictive performance . Other popular approaches include Disentanglement , Domain Generalization , Domain-Independence  and simple approaches such as up-sampling or reweighing minority groups during training. Notably, in the case of high-capacity models in medical computer-vision tasks, a recent benchmark paper by Zong et al.  showed state-of-the-art in-processing methods do not significantly improve outcomes over training without consideration of fairness. A comprehensive benchmark study of in-processing methods in other domains is provided by Han et al. .

**Post-processing** methods enforce fairness by using thresholds and randomization to adjust the predictions of a trained model based on the protected attributes . Post-processing methods are typically _model-agnostic_ and can be applied to any model that returns confidence scores.

**Enforcing Fairness on Validation Data** avoids the misestimation of error rates due to overfitting. It has shown particular promise in computer vision through Neural Architecture Search , adjusting decision boundaries , reweighting  and data augmentation .

### Fairness Toolkits

Most toolkits such as Fairness Measures , TensorFlow Fairness Indicators , and FAT Forensics  focus on measuring bias and do not support enforcing fairness through bias mitigation. FairML  audits fairness by quantifying the importance of different attributes in prediction. This is best suited for tabular data where features are well-defined. FairTest  investigates the associations between application outcomes (e.g., insurance premiums) and sensitive attributes such as age to highlight and debug bias in deployed systems. Aequitas  provides examples of when different measures are (in)appropriate with support for some bias mitigation methods in binary classification. Themis-ML  supports the deployment of several simple bias mitigation methods such as relabelling , but focuses on linear models. Friedler et al.  introduce the more complete Fairness Comparison toolkit where four bias mitigation strategies are compared across five tabular datasets and multiple models (Decision trees, Gaussian Naive Bayes, SVM, and Logistic Regression).

There are two fairness toolkits that support sklearn  like OxonFair. These are the two most popular toolkits: Microsoft Fairlearn  (1.9k GitHub Stragazers as of June 2024) and IBM AIF360  (2.4k Stragazers). AIF360 offers a diverse selection of bias measures and pre-processing, in-processing and post-processing bias mitigation strategies on binary classification tabular datasets. For mitigation, Fairlearn primarily offers implementations of  avoiding the use of the term _bias_, instead considering fairness through the lens of fairness-related harms  where the goal is to _"help practitioners assess fairness-related harms, review the impacts of different mitigation strategies and make trade-offs appropriate to their scenario"_. Lee & Singh  recognized Fairlearn as one of the most user-friendly fairness toolkits, and critiqued AIF360 as being the least user-friendly toolkit.

Both AIF360 and Fairlearn contain post-processing methods that select per-group thresholds. Unlike OxonFair, neither method uses the fast optimization we propose; both methods require group information at test time; AIF360 only supports two groups, but does use cross-validation to avoid overfitting; Fairlearn does not support the use of validation data, but does support more than two groups. According to their documentation, neither toolkit can be applied to NLP or computer vision.

Specialist solversFairret  is a recent PyTorch library shown to enforce fairness on tabular data. As PyTorch is a focus of OxonFair (see Section 4.2), we compare with Fairret in Appendix D.1. Cruz and Hardt  proposed an efficient LP-based formulation for post-processing Equalized Odds. It supports randomized thresholds, and dominates fairness methods such as OxonFair that use only one threshold per group. In Appendix D.2 we show how OxonFair can be extended to support randomizedthresholds, alongside a deterministic variant and another using inferred group membership that are not supported by .

## 3 Toolkit interface

The interface of OxonFair decomposes into three parts: (i) evaluation of fairness and performance for generic classifier outputs. (ii) evaluating and enforcing fairness for particular classifiers. (iii) specialist code for evaluating and enforcing fairness for deep networks.

Code for the evaluation of classifier outputs takes target labels, classifier outputs, groups, and an optional conditioning factor as input; while code for the evaluation and enforcement of fairness of a particular classifier, are initialized using the classifier, and from then on take datasets (in the form of a pandas dataframe , or a dictionary) as input, and automatically extracts these factors from them.

The evaluation code provide three functions: evaluate which reports overall performance of the classifier; evaluate_per_group which reports performance per group of the classifier; and evaluate_fairness which reports standard fairness metrics. All methods allow the user to specify which metrics should be reported. We recommend data scientists focus on evaluate_per_group which shows direct harms such as poor accuracy, precision, or low selection rate for particular groups.

OxonFair provides an interface FairPredictor(classifier, validation_data, groups) that takes an existing classifier as an input, a validation dataset, and specification of the groups as an input and returns an object which we then enforce fairness on by calling.fit(objective, constraint, value). Internally, the method explores a wide range of possible thresholds for each group, membership of which is assumed to be either known or inferred by an auxiliary classifier.

The resulting FairPredictor has evaluation methods as described above. When called without arguments, they report both the performance of the original and the updated fair classifier on the validation data. In addition, FairPredictor provides methods predict and predict_proba which make fair predictions and return scores corresponding to the left-hand side of Equation (1).

Calling fit optimizes the objective - typically a relevant performance criteria such as accuracy, subject to the requirement that the constraint is either greater or less than the value. If the objective should be minimized or maximized is inferred automatically, as is the requirement that the constraint is less than or greater than the value, but this default behavior can be user overridden.

This is a relatively minimal interface, but one that is surprisingly expressive. By explicitly optimizing an objective, we can not just minimize the degradation of the metric as we enforce fairness, but sometimes also improve performance over the unfair baseline that is not fully optimized with respect to this metric. Even when optimizing for accuracy, this can create situations where it looks like some improvements in fairness can be had for free, although generally this is an artifact of the gap between optimizing log-loss and true accuracy in training. By formulating the problem as a generic constrained optimization, and not requiring the constraint to be a typical fairness constraint, we leave it open

Figure 2: **Left: Summary of the fast path algorithm for inferred attributes (Section 4.1). Groups are noisily estimated using a classifier. Within each estimated group, we cumulatively sum positive and negative samples that truly belong to each group. For each pair of thresholds, we select relevant sums from the inferred group and combine them. See Appendix A.1. **Center:** Combining two heads (original classifier and group predictor) to create a fair classifier. See Section 4.2. **Right:** The output of a second head predicting the protected attribute in CelebA. The pronounced bimodal distribution makes the weighted sum of the two heads a close replacement for per-group thresholds.

for enforcing a much broader space of possible objectives. This can be seen in Appendix C, where we show how to enforce minimax fairness , maximize utility  combined with global recall constraints, and demonstrate levelling-up  by specifying minimum acceptable harm thresholds.

Under the hood, a call to fit generates a Pareto frontier1 and selects the solution that best optimizes the objective while satisfying the constraint. The frontier can be visualized with plot_frontier.

## 4 Inference

To make decisions, we assign thresholds to groups. We write \(f(x)\) for the response of a classifier \(f\), on datapoint \(x\), \(t\) for the vector corresponding to the ordered set of thresholds, and \(G(x)\) for the one-hot encoding of group membership. We make a positive decision if

\[f(x)-t G(x) 0\] (1)

To optimize arbitrary measures we perform a grid search over the choices of threshold, \(t\).

Efficient grid samplingWe make use of a common trick for efficiently computing measures such as precision and recall for a range of thresholds. This trick is widely used without discussion for efficient computation of the area under ROC curves, and we have had trouble tracking down an original reference for it. As one example, it is used by scikit-learn .

The trick is as follows: sort the datapoints by classifier response, then generate a cumulative sum of the number of positive datapoints and the number of negatives, going from greatest response to least. When picking a threshold between points \(i\) and \(i+1\), TP is given by the cumulative sum of positives in the decreasing direction up to and including \(i\); FN is the sum of negatives in the same direction; FP is the total sum of positives minus TP, and TN is the total sum of negatives minus TN.

We perform this trick per group, and efficiently extract the TP, FN, FP and TN for different thresholds. These are combinatorially combined across the groups and the measures computed. This two stage decoupling offers a substantial speed-up. If we write \(T\) for the number of thresholds, \(k\) for the number of groups, and \(n\) for the total number of datapoints, our procedure is upper-bounded by \(O(T^{k}+n n)\), while the naive approach is \(O(nT^{k})\). No other fairness method makes use of this, and in particular, all the threshold-based methods offered by AIF360 make use of a naive grid search.

From the grid sampling, we extract a Pareto frontier with respect to the two measures2. The thresholds that best optimize the objective while satisfying the constraint are returned as a solution. If no such threshold exists, we return the thresholds closest to satisfying the constraint.

### Inferred characteristics

When using inferred characteristics, we offer two pathways for handling estimated group membership. The first pathway we consider makes a hard assignment of individuals to groups, based on a classifier response. The second pathway explicitly uses the classifier confidence as part of a per-datapoint threshold. In practice, we find little difference between the two approaches, but the hard assignment to groups is substantially more efficient and therefore allows for a finer grid search and generally better performance. However, the soft assignment remains useful for the integration of our method with neural networks, where we explicitly merge two heads (a classifier and a group predictor) of a neural network to arrive at a single fair model. For details of the two pathways see Appendix A.

### Fairness for Deep Networks

We use the method proposed in  (N.B., they used it only for demographic parity). Consider a network with two heads \(f\), and \(g\), comprised of single linear layers, and trained to optimize two tasks on a common backbone \(B\). Let \(f\) be a standard classifier trained to maximize some notion of performance such as log-loss and \(g\) is a classifier trained to minimize the squared loss3 with respect to a vector that is a one hot-encoding of group membership. Any decision \(f(x)-t g(x) 0\) can now be optimized for given criteria by tuning weights \(w\) using the process outlined in the slow pathway.

As both \(f\) and \(g\) are linear layers on top of a common nonlinear backbone \(B\), we can write them as:

\[f(x)=w_{f} B(x)+b_{f}, g(x)=w_{g} B(x)+b_{g}\] (2)

note that as \(f(x)\) is a real number, and \(g(x)\) is a vector, \(w_{f}\) is a vector and \(b_{f}\) a real number, while \(w_{g}\) is a matrix and \(b_{g}\) a vector.

This means that the decision function \(f(x)-t g(x) 0\) can be rewritten using the identity:

\[f(x)-t g(x) =w_{f} B(x)+b_{f}-t w_{g} B(x)-t b_{g}\] (3) \[=(w_{f}-t w_{g}) B(x)+(b_{f}-t b_{g})\] (4)

This gives a 3 stage process for enforcing any of these decision/fairness criteria for deep networks.

1. Train a multitask neural network as described above.
2. Compute the optimal thresholds \(t\) on held-out validation data as described in Appendix A.
3. Replace the multitask head with a neuron with weights \((w_{f}-t w_{g})\) and bias \((b_{f}-t b_{g})\).

To maximize performance, the training set should be augmented following best practices, while, to ensure fairness, the validation set should not4. The resulting network \(f^{*}\) will have the same architecture as the original non-multitask network, while satisfying chosen criteria.

OxonFair has a distinct interface for deep learning5. Training and evaluating NLP and vision frequently involves complex pipelines. To maximize applicability, we assume that the user has trained a two-headed network as described above, and evaluated on a validation set. Our constructor DeepFairPredictor takes as an input: the output of the two-headed network over the validation set; the ground-truth labels; and the groups. fit and the evaluation functionality can then be called in the same way. Once a solution is selected, the method merge_heads_pytorch generates the merged head, while extract_coefficients can be called to extract the thresholds \(t\) from 4, when working with a different framework.

### Toolkit expressiveness

Out of the box, OxonFair supports all 9 of the decision-based group fairness measures defined by Verma and Rubin  and all 10 of the fairness measures from Sagemaker Clarify . OxonFair

Figure 3: **Left: Results on Compas without using group annotations at test time. Right: Runtime Comparison for Fairlearn Reductions and OxonFair on Adult using a Macbook M2. To alter the groups, we iteratively merge the smallest racial group with ‘Other’, reducing the search space. For both methods, we enforced demographic parity over a train set consisting of 70% of the data. Despite the exponential complexity of our approach, we remain significantly faster until we reach 5 groups. The 0.6+ indicates the seconds to train XGBoost. OxonFair(S) indicates the runtime of the naive slow pathway described in Appendix A.2 rather than our accelerated approach.**

supports any fairness measure (including conditional fairness measures) that can be expressed per group as a weighted sum of True Positives, False Positives, True Negatives and False Negatives. OxonFair does not support notions of individual fairness such as fairness through awareness  or counterfactual fairness .

See Appendix B for a discussion of how metrics are implemented and comparison with two review papers. Appendix C contains details of non-standard fairness metrics, including utility optimization ; minimax fairness ; minimum rate constraints , and Conditional Demographic Parity . This also includes a variant of Bias Amplification .

## 5 Experimental Analysis

For tabular data, we compare with all group fairness methods offered by AIF360, and the reductions approach of Fairlearn. OxonFair is compatible with any learner with an implementation of the method predict_proba consistent with scikit-learn  including AutoGluon  and XGBoost . A comparison with Fairlearn and the group methods from AIF360 on the adult dataset can be seen in Figures 1 and 6 using random forests. This follows the setup of : we enforce fairness with respect to race and binarize the attribute to white vs everyone else (this is required to compare with AIF360), 50% train data, 20% validation, and 30% test, and a minimum leaf size of 20. With this large leaf size, all errors on train, validation, and test are broadly comparable, but our approach of directly optimizing an objective and a fairness measure leads us to outperform others.

Figure 1 top right shows the importance of being able to use a validation set to balance errors. Using sklearn's default parameters we overfit to adult, and as the classifier is perfect on the training set, all fairness metrics that match error rates are trivially satisfied . The same behavior can be observed using XGBoost on the medical dataset  when enforcing equal opportunity with respect to sex6. In general, tabular methods need not overfit, and tuning parameters carefully can allow users to get relatively good performance while maintaining error rates between training and test.

Figure 3 left shows Equal Opportunity on the COMPAS dataset. To show that OxonFair can also work in low-data regimes where we have insufficient data for validation, we enforce fairness on the training set. As before, we binarize race to allow the use of AIF360. We drop race from the training data, and use inferred protected attributes to enforce fairness. Here OxonFair generates a frontier that is comparable or better than results from existing toolkits, and OxonFair+ (see Section A), further improves on these results. See Figure 3 right for a comparison with Fairlearn varying the groups.

### Computer Vision and CelebA

**CelebA**: We use the standard aligned & cropped partitions frequently used in fairness evaluation . Following Ramaswamy et al. , we consider the 26 _gender-independent_, _gender-dependent_ and _inconsistently labelled_ attributes as the target attributes for our evaluations (see Table 12 for details). _Male_ is treated as the protected attribute.

**Implementation Details** We follow Wang et al.'s setup . We use a Resnet-50 backbone  trained on ImageNet . A multitask classification model is trained, replacing the final fully-connected layer of the backbone with a separate fully-connected head that performs binary prediction for all attributes. Dropout  (p = 0.5) is applied. All models are trained with a batch size of

    & ERM & Unicnf. & Domain & Domain & OxonFair & ERM & Debiasing & Regularized & g-SMOTE & g-SMOTE & ERM & FairMixup \\  & multitask & Adv. & Disc.  & Ind.  & DEO & single task GAN  &  & Adaptive  &  &  &  \\  Acc. & \(\) & \(92.71\) & \(92.96\) & \(92.63\) & \(92.75\) & \(92.47\) & \(92.12\) & \(91.05\) & \(92.56\) & \(\) & \(\) & \(88.46\) \\ DEO & \(16.47\) & \(19.63\) & \(14.61\) & \(7.78\) & \(\) & \(12.54\) & \(9.11\) & \(\) & \(14.28\) & \(15.11\) & \(7.97\) & \(\) \\   

Table 1: We report mean scores over the 14 gender independent CelebA labels . Single task methods and FairMixup scores in the second and third blocks are from Zietlow et al. . ERM is the baseline architecture run without fairness. OxonFair (optimizing for accuracy and difference in equal opportunity (DEO)), has better accuracy (\(\)) and DEO (\(\)) scores than any other fair method.

32 is and using Adam  (learning rate 1e-4). We train for 20 epochs and select the model with highest validation accuracy. Images are center-cropped and resized to \(224 224\). During training, we randomly crop and horizontally flip the images. See Appendix E.

Results:Table 1 and 2 demonstrates that using OxonFair as described in Section 4.2 generates fairer and more accurate solutions on unseen test data than other fair methods. Simple approaches such as Domain Independent training were more effective than adversarial training for enforcing fairness confirming . Occasionally, OxonFair finds solutions on the Pareto frontier that are both fairer and more accurate than the unconstrained classifier (See Figure 5).

Figure 4 shows a novel fairness evaluation motivated by medical use cases  where practitioners might want to correctly identify at least \(6\%\) of positive cases in each group. We evaluate how accuracy changes if we guarantee that the minimum recall is above \(\%\) for every group. For OxonFair, we call.fit(accuracy, recall.min, \(\)). For other methods, we vary a global offset to ensure that the minimum recall is at least \(\).

### NLP and Toxic Content

We conducted experiments on hate speech detection and toxicity classification using two datasets: the multilingual Twitter corpus  and Jigsaw . Experiments were performed across five languages (English, Polish, Spanish, Portuguese, and Italian) and five demographic factors (age, country, gender, race/ethnicity, and religion) were treated as the protected groups. For details, see Appendix F.1.

We compare OxonFair with the following approaches. **Base** reports results of the standard BERT model . **CDA** (Counterfactual Data Augmentation)  rebalances a corpus by swapping bias attribute words (e.g., he/she) in a dataset based on a given dictionary. **DP** (Demographic Parity) uses regularization  to enforce DP. **EO** (Equal Opportunity ) uses the regularization of  to enforce EO. **Dropout** is used as a regularization technique  for bias mitigation and improving small group generalization. **Rebalance** method resamples the minor groups to the same sample size as other groups to mitigate bias. We report scores on Oxonfair optimized for

   CelebA & \(\) = 0.50 & \(\) = 0.75 & \(\) = 0.90 \\  Baseline & 89.0 & 84.5 & 77.6 \\ Adversarial & 87.8 & 82.4 & 75.2 \\ Domain-Dep & 82.3 & 76.8 & 68.6 \\ Domain-Ind & 89.2 & 86.2 & 79.8 \\ OxonFair & **89.9** & **87.3** & **81.8** \\   

Table 2: A comparison against standard vision approaches on the more challenging CelebA attributes. OxonFair continues to work well here. All methods share a common backbone and training process. An extended version of this table that considers minimax fairness can be found in Table 14.

Figure 4: **Left: The Pareto frontier of min. group recall vs. accuracy on Blond Hair demonstrates OxonFair’s superior performance. Right: Comparing accuracy of fairness methods on 26 CelebA attributes while varying global decision thresholds to increase the minimum group recall level to \(\).**

different metrics: Accuracy; F1 Score; and Balanced Accuracy, and always enforce that the DEO is under 5% on the validation set.

Results:Results are shown in Tables 3 and 4. Our observations indicate that: 1) all debiasing methods improve the equal opportunity score and help mitigate bias on Twitter, but not on jigsaw. 2) our toolkit consistently reduces the difference in equal opportunity more than any other approach; 3) for 4/6 experiments we actually improve the objective over the baseline while enforcing fairness, showing the value in targeting a particular objective. For additional experiments on multilingual and multi-demographic data, and the Jigsaw race data, see Appendix F.2, and Appendix F.3.

While improving fairness more than existing approaches, OxonFair performs substantially worse on these NLP datasets than on CelbA. There are two challenges present in these datasets but not in CelbA: _(i)_ it is likely much harder to infer gender or religion from short text data than it is to infer gender from a photo of a face. _(ii)_ The limited number of positively labelled datapoints examples that makes estimating DEO, F1,and balanced accuracy unstable (see Tables 16 and 17 for details). To better understand the influence of the two factors we refit OxonFair using the true rather than inferred attributes at test time (bottom block) and see no reliable improvements, suggesting that we are most limited by data scarcity.

    & F1 & Balanced & Acc. & DEO \\  & (\(\)) & Acc. (\(\)) & (\(\)) & (\(\)) \\  Base & 42.1 & 74.8 & 75.0 & 7.33 \\ CDA  & 40.4 & 73.8 & 73.0 & 8.98 \\ DP  & 44.5 & 69.2 & 85.5 & 3.68 \\ EO  & 41.1 & 68.8 & 82.2 & 4.60 \\ Dropout  & 42.7 & 74.1 & 77.0 & 7.94 \\ Rebalance  & 39.1 & 73.7 & 70.3 & 9.67 \\  OxonFair Ac. & 33.7 & 60.5 & 89.2 & 2.36 \\ OxonFair F1 & 44.4 & 69.5 & 85.0 & 3.79 \\ OxonFair B. Ac. & 42.2 & 74.2 & 76.1 & 4.78 \\  OxonFair* Ac. & 26.3 & 57.6 & 88.8 & 1.84 \\ OxonFair* F1 & 44.3 & 68.5 & 86.2 & 0.84 \\ OxonFair* B. Ac. & 41.9 & 73.7 & 76.3 & 4.56 \\   

Table 4: Jigsaw dataset: Religion (3 groups: Christian, Muslim, Other).

Figure 5: The Pareto frontier on test data when enforcing two fairness measures (DEO and Min Group Min Label Acc; see Appendix C.1) for the Earrings attribute. Inspecting the Pareto frontier shows a wide range of solutions, including some that improve fairness while retaining similar accuracy.

    & F1 & Balanced & Acc. & DEO \\  & (\(\)) & Acc. (\(\)) & (\(\)) & (\(\)) \\  Base & 40.8 & 63.2 & 89.8 & 21.4 \\ CDA  & 43.2 & 64.4 & 89.8 & 16.0 \\ DP  & 37.2 & 61.7 & 89.5 & 17.9 \\ EO  & 32.0 & 59.6 & 89.1 & 13.2 \\ Dropout  & 32.2 & 59.8 & 88.9 & 13.8 \\ Rebalance  & 38.2 & 62.1 & 89.5 & 19.1 \\  OxonFair Ac. & 34.1 & 60.7 & 88.5 & 8.45 \\ OxonFair F1 & 44.6 & 69.1 & 84.7 & 2.10 \\ OxonFair B. Ac. & 47.1 & 71.2 & 84.8 & 7.33 \\  OxonFair* Ac. & 40.0 & 63.3 & 89.0 & 5.99 \\ OxonFair* F1 & 47.5 & 70.9 & 85.5 & 5.59 \\ OxonFair* B. Ac. & 40.8 & 64.6 & 87.3 & 13.0 \\   

Table 3: Multilingual Twitter dataset: Gender (2 groups: Male, Female).

Conclusion

The key contributions of our toolkit lie in being more expressive than other approaches, and supporting NLP and computer vision. Despite this, most of the experiments focus on the standard definitions of Demographic Parity and Equal Opportunity. This is not because we agree that they are the right measures, but because we believe that the best way to show that OxonFair works is to compete with other methods in what they do best. On low-dimensional tabular data, when optimizing accuracy and a standard fairness measure, it is largely comparable with Fairlearn, but if overfitting or non-standard performance criteria and fairness metrics are a concern, then OxonFair has obvious advantages. For NLP, and computer vision, our approach clearly improves on existing state-of-the-art. In no small part, this is due to the observation of , that methods for estimating or enforcing error-based fairness metrics on high-capacity models that do not use held-out validation data can not work.

We hope that OxonFair will free policy-makers and domain experts to directly specify fairness measures and objectives that are a better match for the harms that they face. In particular, we want to call out the measures in Figure 8 as relevant to medical ML. The question of how much accuracy can we retain, while guaranteeing that classifier sensitivity (AKA recall) is above k% for every group, captures notions of fairness and clinical relevance in a way that standard fairness notions do not .

**Limitations:** We have chosen to optimize as broad a set of formulations as possible. As a result, for certain metrics (particularly equalized odds ) the solutions found are known to be suboptimal8; and for others  the exponential search is unneeded. Techniques targeting particular formulations may be needed to address this.

A key challenge for most fairness approaches is in obtaining the group labels used to measure unfairnesss, and we are no exception. In particular, the gender labels in CelebA and the race and religion labels in our NLP experiments consist of a small number of externally assigned labels that may not match how people self-identify. Improving and measuring fairness with respect to these coarse labels can miss other forms of inequality. Moreover, a major driver of unfairness is a lack of data regarding particular groups. However, this very absence of data makes it hard for any toolkit to detect or rectify unfairness.

**Broader Impact:** OxonFair is a tool for altering the decisions made by ML systems that are frequently trained on biased data. Care must be taken that fair ML is used as a final step after correcting for bias and errors in data collation, and not as a sticking plaster to mask problems . Indeed, inappropriate uses of fairness can lock in biases present in training . Under the hood, OxonFair performs a form of positive discrimination, where we alter scores in response to (perceived) protected characteristics to rectify specific existing inequalities9. As such, there are many scenarios where its use may be inappropriate for legal or ethical reasons.

## 7 Acknowledgements

This work has been supported through research funding provided by the Wellcome Trust (grant nr 223765/Z/21/Z), Sloan Foundation (grant nr G-2021-16779), Department of Health and Social Care, EPSRC (grant nr EP/Y019393/1), and Luminate Group. Their funding supports the Trustworthiness Auditing for AI project and Governance of Emerging Technologies research programme at the Oxford Internet Institute, University of Oxford.

An early prototype version of the same toolkit, for tabular data, was developed while CR was working at AWS and is available online as autogluon.fair (https://github.com/autogluon/autogluon-fair/). CR is grateful to Nick Erickson and Weisu Yin for code reviews of the prototype. The authors thank Kaivalya Rawal for feedback on the manuscript and testing the codebase.