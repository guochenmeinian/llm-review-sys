# Classifier-guided Gradient Modulation for

Enhanced Multimodal Learning

 Zirun Guo\({}^{1,2}\), Tao Jin\({}^{1}\), Jingyuan Chen\({}^{1}\), Zhou Zhao\({}^{1,2}\)

\({}^{1}\) Zhejiang University, \({}^{2}\) Shanghai AI Lab

zguo.cs@gmail.com

Corresponding author

###### Abstract

Multimodal learning has developed very fast in recent years. However, during the multimodal training process, the model tends to rely on only one modality based on which it could learn faster, thus leading to inadequate use of other modalities. Existing methods to balance the training process always have some limitations on the loss functions, optimizers and the number of modalities and only consider modulating the magnitude of the gradients while ignoring the directions of the gradients. To solve these problems, in this paper, we present a novel method to balance multimodal learning with **C**lassifier-**G**uided **G**radient **M**odulation (CGGM), considering both the magnitude and directions of the gradients. We conduct extensive experiments on four multimodal datasets: UPMC-Food 101, CMU-MOSI, IEMOCAP and BraTS 2021, covering classification, regression and segmentation tasks. The results show that CGGM outperforms all the baselines and other state-of-the-art methods consistently, demonstrating its effectiveness and versatility. Our code is available at https://github.com/zrguo/CGGM.

## 1 Introduction

Humans perceive the world in a multimodal way, such as sight, touch and sound. These multimodal features can provide comprehensive information to help us understand and explore the environment. Recent years have witnessed great success in multimodal learning, such as visual question answering , multimodal sentiment analysis  and multimodal retrieval .

Although multimodal learning has made significant progress in recent years, inadequate use of different modality information during training remains a challenge. Theoretically, for example, Wu et al.  put forward the greedy learner hypothesis which states that a multimodal model learns to rely on one of the input modalities, based on which it could learn faster, and does not continue to learn to use other modalities. Huang et al.  find that during joint training, multiple modalities will compete with each other and some modalities will fail in the competition. Experimentally, on some multimodal datasets, there is little improvement in accuracy between training with only one modality and training with all modalities . These theoretical analyses and experimental results demonstrate the inefficiency of multimodal learning to fully utilize and integrate information from different modalities.

To deal with this problem, recent studies  investigate the training process of multimodal learning and propose gradient modulation strategies to better integrate the information of different modalities and balance the training process in some situations. However, all of these methods can not be applied easily for some limitations. For example, Wu et al. , Peng et al. , Li et al.  and Hua et al.  propose balancing methods based on cross-entropy loss forclassification tasks. For regression tasks or other tasks, we can not use these strategies. Besides, most of these methods can just deal with situations where there are only two modalities. For example, Wu et al.  propose the conditional learning speed which is difficult to calculate and employ if there are more than two modalities. For situations where there are more modalities, these methods can not be applied. Furthermore, most of these methods only consider modulating the magnitude of the gradients while ignoring the directions of the gradients.

Based on the above observations, in this paper, we propose a novel method to balance multimodal learning with **C**lassifier-**G**uided **G**radient **M**odulation (CGGM). In CGGM, we consider a more general situation with no limitations on the type of tasks, optimizers, the number of modalities, etc. Additionally, we consider both the magnitude and directions of the gradients to fully boost the training process of multimodal learning. Specifically, we add classifiers to evaluate the utilization rate of each modality and obtain the unimodal gradients. Then, we leverage the utilization rate to adaptively modulate the magnitude of the gradients of encoders and use the unimodal gradients to instruct the model to optimize towards a better direction.

We conduct extensive experiments on four multimodal datasets: UPMC-Food 101 , CMU-MOSI , IEMOCAP , and BraTS 2021 . UPMC-Food 101 and IEMOCAP are classification tasks, CMU-MOSI is a regression task, and BraTS 2021 is a segmentation task. CGGM outperforms all the baselines and other state-of-the-art methods, demonstrating its effectiveness and universality. In summary, our contributions are as follows:

* We propose CGGM to balance multimodal learning by both considering the magnitude and direction of the gradients.
* CGGM can be easily applied to many multimodal tasks and networks with no limitations on the type of tasks, optimizers, the number of modalities, etc. which indicates its versatility.
* Our proposed CGGM brings consistent improvements to various tasks, including classification, regression and segmentation tasks. Extensive experiments show that CGGM outperforms other state-of-the-art methods, demonstrating its effectiveness.

## 2 Related Work

**Multimodal Learning.** One of the main challenges of multimodal learning is how to effectively utilize and integrate the information from different modalities to complement each other. According to the fusion strategies, there are three main multimodal fusion strategies: early fusion, intermediate fusion and late fusion. In early fusion methods [16; 24], raw data from different modalities is combined via concatenation or other methods at the input level before being fed into a model. Intermediate fusion  methods combine data from different modalities at various intermediate processing stages within a model architecture. Late fusion [2; 18] methods process data from each modality independently through separate models and combine them at a later stage. In general, late fusion is the predominant method used in multimodal learning. The main reason  is that the architecture of each unimodal stream has been carefully designed over the years to achieve state-of-the-art performance for each modality. Therefore, we can leverage these pre-trained models [5; 6] to achieve better results. Therefore, in this paper, our method is based on late fusion.

These fusion strategies are able to integrate information from different modalities effectively, but they have limited improvements to utilize information from different modalities to complement each other. In other words, they are not able to deal with the modality competition  or imbalanced multimodal learning. When the dominant modality is missing  or corrupted, the performance would degrade significantly. Different from these fusion strategies, our method aims to make relatively full use of the information of each modality and address the imbalanced multimodal learning.

**Balanced Multimodal Learning.** The inefficiency in fully utilizing and integrating information from multiple modalities poses a great challenge to the multimodal learning field. Some studies [18; 21] present that there is little improvement in accuracy between training with only one modality and training with all modalities. Wang et al.  show that multimodal models using multiple modalities can be even inferior to those using only one modality. To balance the multimodal learning process and fully utilize different modalities, a series of balanced multimodal learning methods [25; 17; 15; 8; 28; 9; 7; 11] are proposed. Wu et al.  propose the conditional learning speed to capture the relative learning speed between modalities and balance the learning process. Peng et al. propose a gradient modulation strategy that adaptively controls the optimization of each modality via monitoring the discrepancy of their contribution towards the learning objective. More recently, Fan et al.  propose the prototypical modal rebalance strategy to introduce different learning strategies for different modalities. Li et al.  propose an adaptive gradient modulation method that can boost the performance of multimodal models with various fusion strategies. Hua et al.  dynamically adjust the learning objective with a reconcilement regularization against competition with the historical models.

However, all of these previous works have certain limitations and can only be used in some specific situations. For example, Wu et al.  propose conditional learning speed based on intermediate fusion strategy which makes it hard to apply to situations where there are more than two modalities or where the network is not based on intermediate fusion. Peng et al. , Fan et al. , Fu et al. , Li et al.  and Hua et al.  propose the balancing strategies with the assumption of the cross-entropy loss function mainly for classification. Particularly, Peng et al.  employ the SGD optimizer. Different from these methods, we consider a more general situation with no limitations on the number of modalities, the optimizer, the loss function and so on. Additionally, most of existing methods only consider the magnitude of the gradients and ignore the directions of the gradients. In contrast, we consider both of them.

## 3 Proposed Method

### Problem Settings

Suppose there are \(M\) modalities, referred to as \(m_{1},\)\(m_{2},\)\(,m_{M}\). We denote the multimodal dataset as \(=\{(_{i},y_{i})\}_{i=1}^{N}\), where \(N\) is the number of data in the dataset and \(_{i}=(x_{i}^{m_{1}},x_{i}^{m_{2}},,x_{i}^{m_{M}})\).

We consider the most common structure (Figure 1) in multimodal models, where the inputs of different modalities are first fed into modality-specific encoders and then the representations of all modalities are inputted into a fusion module. We denote the encoder of modality \(m_{i}\) as \(_{i}\) where \(i=1,2,,M\) and the fusion module as \(\).

For the forward propagation, the features are first inputted into the encoder:

\[h_{i}=_{i}(x^{m_{i}})\] (1)

where \(h_{i}\) is the representation of modality \(m_{i}\). After obtaining the representations of all modalities, the fusion module is applied:

\[=(([h_{1},h_{2},,h_{M}]))\] (2)

where \(\) is the prediction, \([]\) is the concatenation operation, and \(()\) is the prediction head to predict the answer. \(()\) fuses the multimodal representations and outputs the fused feature as the prediction token.

Figure 1: The overall architecture of CGGM. During the training stage, classifiers are introduced to calculate the directions of unimodal gradients and evaluation metrics. During the inference stage, the classifiers are discarded.

### Gradient Analysis

To introduce CGGM, we first analyze the gradient updating process. We denote the loss function as \(()=_{i=1}^{N}(_{}^{i},y^{i})\) where \(\) represents the parameters of the network, \(_{}^{i}\) is the prediction and \(y^{i}\) is the ground truth. For simplicity, we use \(^{i}\) to represent the predictions in the following context. Different from previous methods which only consider cross-entropy loss [17; 8; 11], our \(\) can be cross-entropy loss, L1 loss or any other loss functions. With the _Gradient Descent_ (GD) optimization method, the parameters of the fusion module \(\) and encoders \(_{i}\) can be updated as:

\[_{t+1}^{}=_{t}^{}-_{^{}} (_{t}^{})=_{t}^{}-_{ n=1}^{N}(}{})^{}^{n},y^{n})}{}\] (3)

\[_{t+1}^{_{i}}=_{t}^{_{i}}-_{^{_{i}} }(_{t}^{_{i}})=_{t}^{_{i}}- _{n=1}^{N}(}{}})^{}^{n},y^ {n})}{}\] (4)

where \(\) is the learning rate, \(N\) is batch size, and \(t\) is the iteration. According to the chain rule used to find the gradient in backpropagation, the update of \(_{i}\) will influence the update of \(\), and vice versa. According to Figure 2(a) and 2(b), the gradient and the accuracy of the dominant modality will increase during the training process while the other two remain stable. Particularly, the gradient magnitude of the text modality increases very fast during the training process. This suggests the encoder of the dominant modality will be updated much faster than others, which makes \(\) much larger. This phenomenon can also be validated by previous works [8; 17; 25]. Besides, in Figure 2(c), we present the gradient direction between each modality and the fusion. We can observe that the similarity between audio modality and the multimodal fusion is less than 0, indicating that they optimize towards the opposite direction, thus hindering the gradient update for multimodal branch. Meanwhile, the similarity between text modality and the multimodal fusion is increasing, suggesting the optimization direction towards the dominant modality. With the progress of optimization, the encoder of the dominant modality can make relatively accurate predictions, which makes the fusion module \(\) only depend on this modality (both magnitude and direction as mentioned above), leaving other encoders under-optimized.

### Classifier-guided Gradient Modulation

#### 3.3.1 Gradient Magnitude Modulation

As we discuss in Section 3.2, the gradient magnitude of the dominant modality increases fast during the training while the other modalities remain stable, thus being under-optimized. To balance the training process and make the fusion module benefit from all the encoders simultaneously, we propose the classifier-guided gradient modulation. Specifically, we use a modality-specific classifier to make predictions of \(h_{i}\) in Equation 1. We can write the process as:

\[_{m_{i}}=f_{i}(h_{i})\] (5)

where \(f_{i}\) is the classifier of modality \(m_{i}\) and \(_{m_{i}}\) is the prediction only using modality \(m_{i}\). The classifier \(f_{i}\) consists of 1-2 multi-head self-attention (MSA) layers  and a fully connected layer

Figure 2: (a) Accuracy of each modality and the fusion. (b) Gradient magnitude of each modality. We use the Euclidean norm of the gradient vector to represent the gradient magnitude. (c) Gradient direction between each modality and their fusion. We use cosine similarity to represent the direction between two gradient vectors. We get all the results on the CMU-MOSI dataset.

for classification and regression tasks. And for segmentation tasks, \(f_{i}\) is a light decoder. After \(h_{i}\) is inputted into the fusion module \(\), it becomes a more high-level representation. Therefore, we use several MSA layers to make \(h_{i}\) more consistent with the output of the fusion module.

For a specific task, we have some evaluation metrics such as accuracy and mean absolute error. Here, we choose one of the evaluation metrics (_e.g._ accuracy for classification tasks and mean absolute error for regression tasks) and denote it as \(\). For every iteration of training, we can get predictions from the classifiers. We denote the predictions as \(}^{i}=(^{i}_{m_{1}},^{i}_{m_{2}},, {y}^{i}_{m_{M}})\) where \(i\) is the current iteration. Furthermore, we evaluate the task using \(}^{i}\) to get the evaluation metric \(^{i}=(^{i}_{m_{1}},^{i}_{m_{2}}, ,^{i}_{m_{M}})\). Here, we use the difference between the two consecutive \(\) to denote the modality-specific improvement for each iteration:

\[}& =}-^{t}=( ^{t+1}_{m_{1}},^{t+1}_{m_{1}},, ^{t+1}_{m_{M}})\\ &=(^{t+1}_{m_{1}}-^{t}_{m_{1}}, ^{t+1}_{m_{2}}-^{t}_{m_{2}},,^{t+1}_{m_{M}}- ^{t}_{m_{M}})\] (6)

where \(t=0,1,2,,T\) and \(T\) is the total iterations of training. Particularly, \(}\) is initialized to \(\). In some multimodal datasets, only using one of the modalities can achieve good results so we can not directly use \(\) to measure the utilization rate of different modalities. Therefore, it is reasonable to use the difference between \(\) to denote the relative improvements for each iteration. Then, we define the gradient magnitude balancing term of modality \(m_{i}\) for the \(t\)-th iteration as follows:

\[^{t}_{m_{i}}=^{M}^{t}_ {m_{k}}}{_{k=1}^{M}^{t}_{m_{k}}}\] (7)

where \(\) is a scaling hyperparameter and \(M\) is the number of modalities. According to Equation 7, it is easy to find that when the performance of the model only using modality \(m_{i}\) improves very fast (_i.e._\(^{t}_{m_{i}}\) is large), \(^{t}_{m_{i}}\) will be small. Similarly, when the modality \(m_{i}\) brings relatively limited improvements to the model (_i.e._\(^{t}_{m_{i}}\) is small), \(^{t}_{m_{i}}\) will be large. Therefore, \(^{t}_{m_{i}}\) is able to measure the relative utilization rate of these modalities and we can use \(^{t}_{m_{i}}\) to modulate the magnitude of the gradient of the encoder \(_{i}\). So Equation 4 can be rewritten as:

\[^{_{i}}_{t+1}&=^{ _{i}}_{t}-^{t+1}_{m_{i}}_{^{_{i}}} (^{_{i}}_{t})\\ &=^{_{i}}_{t}-^{M} ^{t+1}_{m_{k}}}{_{k=1}^{M}^{t+1}_{m_{k}} }_{^{_{i}}}(^{_{i}}_{t})\] (8)

According to Equation 2, we know that the final predictions are closely related to \(h_{i}\). Therefore, after we modulate the gradient of the corresponding encoder \(_{i}\), it has an impact on the input of \(\), which in turn helps the optimization of the fusion module \(\).

#### 3.3.2 Gradient Direction Modulation

As Wu et al.  discover, when the model only depends on one modality to perform well, it does not continue to learn to use other modalities. As discussed in Section 3.2, it means that this modality dominates the updating of the model. Previous works  address this problem mainly by focusing on gradient magnitude modulation. However, in Section 3.2, we find that the model is optimized towards the dominant modality. Therefore, in this subsection, we introduce a method that could modulate the direction of the gradients to balance the training process.

In general, we want to balance the optimization direction of the model when the model only relies on one modality to make predictions. Therefore, we propose to enforce the gradient direction of the model as close as possible to the weighted average gradient direction of models only using one modality. We use \(^{t}_{m_{i}}\) in Equation 7 as the weight term. This ensures that when the model tends to optimize towards the dominant modality, \(^{t}_{m_{i}}\) can help the model use information from other modalities. Besides, since \(^{t}_{m_{i}}\) changes during the training process, this term can make a dynamic adjustment to balance the optimization directions. Concretely, we can feed one modality into the model and drop other modalities by replacing them with \(\) or other fixed values during training to calculate the gradient of this modality. By this method, we can calculate the unimodal gradients for all modalities. Then, we just enforce the gradient direction of the model as close as possible to the weighted average of these unimodal gradient directions. However, this method is very complex during training, because in every iteration we need to drop modalities to calculate the unimodal gradients, which is time-consuming with the increase in the number of modalities.

Therefore, we propose to use the gradients of the classifiers \(f_{i}\) to represent the unimodal gradients. We will later demonstrate they are similar (Section 4.4 and Figure 4). Here, we take the gradient of regression tasks as an example where the output dimension is 1 so the gradient is an \(n\)-d vector. For classification tasks or other tasks where the gradient is a matrix, see Appendix A for details. Concretely, we can calculate the gradient of the classifier \(f_{i}\) as:

\[_{^{f_{i}}}(^{f_{i}})= (^{f_{i}})}{ f_{i}}=[(^{f_{ i}})}{_{1}^{f_{i}}},(^{f_{i}})}{ _{2}^{f_{i}}},,(^{f_{i}})}{ _{n}^{f_{i}}}]^{}\] (9)

where \(^{f_{i}}\) represents the parameters of \(f_{i}\). Different from \(_{1}^{f_{i}}\) in Equation 3 and 4 where \(t\) is the iteration, \(_{n}^{f_{i}}\) here represents one of the variables of \(^{f_{i}}\). Similarly, we can calculate the gradient of the classifier \(\) of the fusion module as:

\[_{^{}}(^{})=(^{})}{}=[(^{})}{_{1}^{}},(^{})}{_{2}^{}},,(^{})}{_{n}^ {}}]^{}\] (10)

We regard \(_{^{f_{i}}},i=1,2,,M\) as the unimodal gradients and \(_{^{}}\) as the fusion gradients. As mentioned before, we want to make \(_{^{}}\) as close as possible to the weighted average direction of \(_{^{f}},i=1,2,,M\). Let \((,)=^{}/||||||||\) denote the dot product between \(_{2}\) normalized \(\) and \(\) (_i.e._ cosine similarity). We can enforce the gradient direction of the fusion module as close as possible to the weighted average of these unimodal gradient directions by maximizing their cosine similarity:

\[_{i=1}^{M}_{m_{i}}^{t}(_{^{ }},_{^{f_{i}}})\] (11)

where \(t\) is the current iteration. We rewrite Equation 11 as a loss term:

\[_{gm}^{t}=_{i=1}^{M}|_{m_{i}}^{t}|- _{m_{i}}^{t}(_{_{i}^{}} ,_{_{i}^{f_{i}}})\] (12)

The cosine similarity is a number between \(-1\) and \(1\). By adding \(|_{m_{i}}^{t}|\) to the loss term, we can ensure that the loss \(_{gm}\) is always positive. As aforementioned, when modality \(m_{i}\) has limited improvement, \(_{m_{i}}^{t}\) is large. Therefore, the corresponding term in \(_{gm}^{t}\) will be large, making the optimization direction towards modality \(m_{i}\), which will balance the learning process.

Then our overall loss function can be written as:

\[^{t}=_{task}+^{t}_{gm}\] (13)

where \(_{task}\) is the task loss function (_e.g._ cross-entropy loss, L1 loss) and \(\) is a trade-off between the two loss terms. We present our overall method in Algorithm 1.

## 4 Experiments

### Datasets and Evaluation Metrics

We use four multimodal datasets: UPMC-Food 101 , CMU-MOSI , IEMOCAP , and BraTS 2021 . Table 1 presents the difference between these four datasets.

**UPMC-Food 101** is a food classification dataset, which contains about 100,000 recipes for a total of 101 food categories. Each item in the dataset is represented by one image plus textual information. We use accuracy and F1 score to evaluate the performance of the model.

**CMU-MOSI** is a popular dataset for multimodal (audio, text and video) sentiment analysis. Each video segment is manually annotated with a sentiment score ranging from strongly negative to strongly positive (-3 to +3). Following previous work [18; 10], we use binary accuracy (ACC-2), F1 score, 7-class accuracy (ACC-7), mean absolute error (MAE) and pearson correlation (Corr) to evaluate the performance of the model.

**IEMOCAP** is a multimodal emotion recognition dataset, which contains recorded videos from ten actors in five dyadic conversation sessions. Following previous works [18; 24; 10], four emotions (happiness, anger, sadness and neutral state) are selected for emotion recognition. We use accuracy and F1 score to evaluate the performance of the model.

**BraTS 2021** is a 3D multimodal brain tumor segmentation dataset, which has four modalities: _flair, t1ce, t1_ and _t2_. The input image size is \(240 240 155\). The annotations are combined into three nested subregions: Whole Tumor (WT), Tumor Core (TC), and Enhancing Tumor (ET). We use Dice score of these three nested subregions and their average value to evaluate the performance.

   Dataset & Task type & No. of modality \\  UPMC-Food 101 & Classification & 2 \\ CMU-MOSI & Regression & 3 \\ IEMOCAP & Classification & 3 \\ BraTS 2021 & Segmentation & 4 \\   

Table 1: The difference between the four datasets we use.

   Method & Acc & F1 \\  Text only & 84.77 & 84.72 \\ Image only & 68.24 & 68.23 \\  Baseline & 90.32 & 90.30 \\ G-Blending  & 90.42 & 90.38 \\ Greedy  & 91.21 & 91.20 \\ OGE  & 91.08 & 91.08 \\ AGM  & 91.49 & 91.48 \\ PMR  & 92.01 & 91.98 \\ UMT  & 91.82 & 91.82 \\ UME  & 90.69 & 90.68 \\ QMF  & 92.87 & 92.85 \\ ReconBoost  & 92.52 & 92.51 \\  CGGM & **92.94** & **92.90** \\   

Table 2: Quantitative results on the UPMC-Food 101 dataset. **Bold**: best results. _Underline_: second best results.

   Method & WT & TC & ET & Avg. \\  flair only & 70.42 & 51.41 & 45.27 & 55.70 \\ t1 only & 50.73 & 36.13 & 38.77 & 41.88 \\ t2 only & 64.82 & 42.17 & 34.62 & 47.20 \\ t1ce only & 56.61 & 53.83 & 53.14 & 54.53 \\  Baseline & 74.03 & 67.08 & 66.53 & 69.21 \\ MRD & 74.02 & 68.04 & 67.28 & 69.78 \\ MSLR & 74.47 & 69.98 & 67.20 & 70.55 \\ UMT  & 74.15 & 67.69 & 66.80 & 69.55 \\ UME  & 74.65 & 68.74 & 67.58 & 70.32 \\ QMF  & 75.11 & 70.78 & 68.94 & 71.61 \\ ReconBoost  & 75.21 & 70.18 & 70.01 & 71.80 \\  CGGM & **76.94** & **72.75** & **72.14** & **73.94** \\   

Table 3: Results on BraTS 2021. WT, TC and ET denote the dice score of Whole Tumor, Tumor Core and Enhancing Tumor respectively.

### Implementation Details

**Input.** For UPMC-Food 101, we use extracted features as inputs. Specifically, we use the pre-trained bert-base-uncased model  to extract text features and use pre-trained ViT  on ImageNet to extract image features. For CMU-MOSI and IEMOCAP, we follow Guo et al.  to extract acoustic, visual and textual features. For BraTS 2021, we use the preprocessed raw images as inputs.

**Backbone.** For UPMC-Food 101, CMU-MOSI and IEMOCAP, we use transformer encoders  as modality encoders and the fusion module. For the BraTS 2021 dataset, we use DeepLab v3+  as the encoders and several convolution layers as the fusion module.

**Training Details.** For images in UPMC-Food 101 and BraTS 2021, we implement data augmentation strategies, including random cropping, random flipping, color jitter, adding noise, etc. To save memory, we consider BraTS 2021 as a 2D segmentation task by randomly slicing an image from the 3D image. For CMU-MOSI, we use L1 loss as our loss function. For UPMC-Food 101 and IEMOCAP, we use cross-entropy loss. For BraTS 2021, we use the combination of soft dice loss and cross-entropy loss. Besides, we use the Adam optimizer for CMU-MOSI, the AdamW optimizer for UPMC-Food 101 and IEMOCAP, and the SGD optimizer for BraTS 2021. Other hyperparameters are described in Appendix B in detail.

### Main Results

**Comparison with the state-of-the-arts.** We compare our CGGM with other methods to demonstrate the effectiveness of our proposed method. For these four datasets, we compare CGGM with the model training only using one modality, multimodal joint training (Baseline), Modality Random Dropout (MRD), and Modality-specific Learning Rate (MSLR) methods. Additionally, we compare CGGM with SOTA methods including G-Blending , Greedy , OGM , AGM , PMR , UMT , UME , QMF  and ReconBoost . Table 2, 3 and 4 present the results of

    &  &  \\   & Acc-2 & Acc-7 & F1 & MAE & Corr & Acc & F1 \\  Text only & 76.83 & 28.24 & 76.80 & 1.016 & 0.664 & 65.35 & 64.30 \\ Audio only & 64.12 & 23.04 & 66.96 & 1.451 & 0.510 & 52.18 & 50.14 \\ Video only & 62.00 & 21.65 & 66.18 & 1.441 & 0.499 & 54.55 & 53.97 \\  Baseline & 81.23 & 29.26 & 81.23 & 0.952 & 0.710 & 70.74 & 69.53 \\ MRD & 80.78 & 31.44 & 80.75 & 0.975 & 0.688 & 71.81 & 71.08 \\ MSLR & 81.22 & 31.00 & 81.19 & 0.950 & 0.704 & 71.99 & 70.96 \\ AGM  & - & - & - & - & - & 72.35 & 71.94 \\ UMT  & 81.78 & 31.98 & 81.77 & 0.942 & 0.712 & 70.75 & 69.81 \\ UME  & 80.83 & 30.94 & 80.78 & 0.969 & 0.701 & 71.53 & 70.94 \\ QMF  & - & - & - & - & - & 72.08 & 71.64 \\ ReconBoost  & - & - & - & - & - & 73.14 & 72.71 \\  CGGM & **82.84** & **33.73** & **82.74** & **0.915** & **0.717** & **75.38** & **74.97** \\   

Table 4: Quantitative results on the CMU-MOSI and IEMOCAP datasets. **Bold**: best results. Underline: second best results.

Figure 3: Changes in (a) performance, (b) gradient magnitude and (c) direction during training with CGGM. We get the results on CMU-MOSI dataset.

CGGM and its compared methods. Compared with the baseline method, CGGM brings significant improvements to the performance of the model, which demonstrates the effectiveness of our proposed method. Besides, CGGM takes both gradient magnitude and direction into consideration, thus making it outperform other gradient modulation methods consistently in all four datasets. Most importantly, CGGM can be easily applied to various tasks and has good performance, including classification tasks, regression tasks, segmentation tasks, etc. Meanwhile, CGGM has no limitations on the optimizer, loss function and the number of modalities.

**Effectiveness of CGGM.** In Figure 3, we visualize the changes in accuracy, gradient magnitude and direction during training with CGGM. Compared with Figure 2(a), the accuracy of text modality in Figure 3(a) does not increase very fast with CGGM, which indicates that CGGM imposes constraints to the dominant modality during the optimization process. Besides, the accuracies of all the modalities and the fusion improves, indicating the effectiveness of CGGM. Additionally, in Figure 2(b), the dominant modality always has the largest gradient while in Figure 3(b), the gradient magnitude of the text modality decreases at first, indicating that CGGM slows down its optimization and accelerates other modalities' optimization, helping each modality learn sufficiently, thus improving the multimodal performance. In case of gradient direction, in Figure 2, the similarity between audio modality and the fusion is always less than 0 during the training process, indicating an opposite optimization direction between the unimodal and multimodal, thus hindering the optimization process. In Figure 3, we observe the multimodal direction is consistent with all modalities, indicating that the multimodal branch utilizes unimodal information efficiently.

### Classifier Performance and Gradient Direction

**Classifier performance.** In Table 5, we present the accuracy of classifiers in different situations. Unimodal training can be considered a baseline that fully utilizes the unimodal information. Compared with unimodal training, the accuracies of \(f_{1}\) and \(f_{2}\) in multimodal training drop slightly while the accuracy of \(f_{3}\) increases slightly. This demonstrates that multimodal training can not fully utilize the information from audio and video, indicating that they are under-optimized. The improvement of \(f_{3}\) indicates that the text modality is fully exploited and learns some information from the other two modalities. In contrast, the accuracies of the three classifiers in CGGM all improve. This suggests that during the balancing process, the fusion can fully utilize the information from all the modalities, thus in turn making the encoders of three modalities fuse the information from other modalities during backpropagation. Therefore, the accuracies of all the three classifiers improve correspondingly. This also validates the effectiveness of CGGM.

**Classifier gradient direction.** In Section 3.3.2, we propose to use the gradients of classifiers to represent the unimodal gradients. In this subsection, we give a visualization of the gradients of classifiers and the unimodal gradients. Specifically, for every batch of data, we input them into

Figure 4: t-SNE visualization of the gradients of classifiers and the unimodal gradients. Each point represents a gradient vector or matrix of a batch of data.

    &  &  \\  audio & video & text & \(f_{1}\) & \(f_{2}\) & \(f_{3}\) & \(f_{1}\) & \(f_{2}\) & \(f_{3}\) \\ 
52.18 & 54.55 & 65.35 & 50.59 & 53.04 & 67.15 & 54.95 & 56.77 & 67.39 \\   

Table 5: Accuracy on IEMOCAP. \(f_{1},f_{2}\) and \(f_{3}\) represent the audio, video and text classifier, respectively. We train three separate models in unimodal training.

the model to get representations \(h_{i}\) which are then fed into the classifiers \(f_{i}\) to get the gradients of classifiers. Then we input \(h_{i}\) of only one modality into the fusion module \(\) to get the unimodal gradients. We use t-SNE  to visualize the gradient vectors. Figure 4 shows the visualization results on the four datasets. As shown in the figure, for each modality, the unimodal gradient vectors and the gradient vectors of the corresponding classifier are very close to each other, demonstrating that it is meaningful to use the gradients of the classifiers to represent the unimodal gradients.

### Ablation Study

**Gradient magnitude and direction.** To measure the contribution of gradient magnitude modulation and gradient direction modulation separately, we present our ablation results on IEMOCAP in Table 6. Compared with the baseline in the first row, modulating the magnitude of the gradients brings more improvements to the performance of the model than modulating the direction of the gradients. Compared with the CGGM performance in Table 4, the combination of modulating gradient magnitude and gradient directions furthermore enhances the performance of the model.

**Scaling hyperparameter \(\).** To explore the impacts of the scaling hyperparameter \(\) on the model's performance, we select seven different values of \(\) and present our results on IEMOCAP in Figure 5(a). We discover that the accuracy improves with the increase of \(\) before hitting the highest value when \(=1.2\). Then, the accuracy drops with the increase of \(\). Compared to the baseline, modulating the magnitude of the gradients brings consistent improvements regardless of how big \(\) is taken. Intuitively, the larger the \(\), the larger the modification to the gradients. Therefore, the results in the table indicate that we need to carefully choose a \(\) to avoid modifications that are too large or too small.

**Loss trade-off \(\).**\(\) measures the strength we modulate the directions of the gradients. We select six different values of \(\) and present the results on IEMOCAP in Figure 5(b). As shown in the figure, when \(\) is 0.01 or 0.25, the accuracy will decrease slightly. When \(\) is too small, the modulation is insufficient and could influence the optimization process. When \(\) is too large, the modulation is large and will influence the task loss, thus making optimization deviate from the task.

## 5 Conclusion

In this paper, we propose CGGM, a novel strategy to balance the multimodal training process. Compared to existing gradient modulation methods, CGGM has no limitations on the loss functions, the optimizer, the number of modalities, etc. Moreover, we consider both the magnitude and direction of the gradients with the guidance of the classifiers. Extensive experiments and ablation studies fully demonstrate the effectiveness and universality of CGGM. However, CGGM also has a limitation. CGGM needs to leverage extra classifiers to implement gradient modulation. Although these classifiers are lightweight, they still lead to more computational resources. We lead this challenging problem to future work.

   Model & Acc & F1 \\  Baseline & 70.74 & 69.53 \\ CGGM (\(=1.0,=0\)) & 72.35 & 71.56 \\ CGGM (\(=,=0.1\)) & 72.41 & 72.07 \\ CGGM (\(=1.0,=0.1\)) & 73.74 & 73.18 \\   

Table 6: The benefits of modulating the magnitude of the gradients and the directions of the gradients.

Figure 5: The improved performance with different \(\) and \(\) compared to the joint training baseline.