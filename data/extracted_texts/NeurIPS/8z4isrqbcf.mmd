# [MISSING_PAGE_EMPTY:1]

[MISSING_PAGE_EMPTY:1]

Furthermore, latent video generative models can be classified into two groups according to the type of VAE they utilize: LLM-like and diffusion-based video models. LLM-like models train a transformer on discrete tokens extracted by a 3D VAE with a quantizer within the VQ-VAE framework . For example, VideoGPT  initially trains a 3D-VQVAE and subsequently an autoregressive transformer in the latent space. The 3D-VQVAE is inflated from the 2D-VQVAE  used in image generation. TATS  and MAGVIT  use 3D-VQGAN for better visual quality by employing discriminators, while Phenaki  utilizes a transformer-based encoder and decoder, namely CViViT.

However, recent latent diffusion-based video models typically exploit 2D VAEs, rather than 3D VAEs, to generate continuous latents to train a UNet or DT . The commonly used 2D VAE is the image VAE  from Stable Diffusion, as training a video model from scratch can be quite challenging. Almost all high-performing latent video models are trained with the SD image model  as initialization for the inflated UNet or DiT. Examples include Align-your-latent , VideoCrafter1 , AnimateDiff , SVD , Modelscope , LaVie , MagicVideo , Latte , _etc._ Temporal compression is simply achieved by uniform frame sampling while ignoring the motion information between frames (see Fig. 2). Consequently, the trained video models may not fully understand smooth motion, even when FPS is set as a condition. When projecting a sampled latent sequence to a video using the decoder of the 2D VAE, the generated video exhibits a low FPS and lacks visual smoothness.

Currently, the research community lacks a commonly used 3D video VAE for generating continuous latent variables with spatio-temporal compression for latent video models. Training a high-quality video VAE without considering the compatibility with existing pretrained image and video models might not be too difficult. However, even though the trained video VAE exhibits low reconstruction errors, a gap exists between its learned latent space and the one used by pretrained models, such as the video VAE of Open-Sora-Plan . This means that bridging the gap requires significant computational resources and extensive training time, even when using pre-trained models as initialization. One example is shown in Fig. 2. When training a video VAE independently without considering compatibility, the sampled latent of SVD  cannot be projected into the pixel space correctly due to the latent space gap, as shown in Fig. 2(a). After finetuning the SVD model in the new latent space on 16 A100 for 58K iterations, the quality of the generated video is still poor (see Fig. 2(b)). In contrast, our video VAE achieves promising results in the pretrained SVD even without finetuning the UNet as shown in Fig. 2(c).

In this work, we propose a novel method to train a video VAE to extract continuous latents for generative video models, which is compatible with existing pretrained image and video models, _e.g._ Stable Diffusion  and SVD . We also inflate the SD image VAE to form a video VAE by adding 3D convolutions to both encoder and decoder of the 2D VAE, which allows us to train video models efficiently with the pretrained models as initialization in a truly spatio-temporally compressed latent space, instead of uniform frame sampling for temporal compression (see Fig. 1). Consequently, the generated videos will be smoother and have a higher FPS than those produced using a 2D VAE.

To ensure latent space compatibility between 2D and 3D VAEs, we propose a latent space regularization to avoid distribution shifts. We examine the effectiveness of using either the encoder or decoder of the 2D VAE to form constraints and explore four types of mapping functions to design regularization. Moreover, to improve video VAE efficiency, we investigate its architecture and partially integrate 3D convolutions instead of exploiting 3D convolution in all blocks. The proposed video VAE can be used not only for training new video models with pretrained ones as initialization but also as a frame interpolator for existing video models with slight finetuning.

Our main contributions are summarized as follows: (1) We propose a video VAE that provides a truly spatio-temporally compressed continuous space for training latent generative video models, which is compatible with existing image and video models, greatly reducing the expense of training or finetuning video models. (2) We propose a latent space regularization to avoid distribution shifts and design an efficient architecture for the video VAE. (3) Extensive experiments are conducted to demonstrate the effectiveness of the proposed video VAE.

## 2 Related Work

Variational Autoencoder.Variational Autoencoders (VAEs), introduced by , have been widely used in two-stage generative models. The first stage involves compressing the pixels into a lower-dimensional latent representation, followed by a second stage that generates pixels from this latent space. VAEs can be divided into two groups according to the token, _i.e.,_ discrete and continuous latent. The difference between the two types of VAEs is the quantization. Continuous VAEs have no quantization, while discrete VAEs learn a codebook for quantization and use it to convert the continuous latent features to discrete indices, called VQVAE . When training discrete VAEs, some methods exploit a discriminator to improve the visual image quality, called VQGAN .

In video generation, 2D VAEs are typically inflated into 3D ones by injecting 3D Conv or temporal attention. 3D Convs are for CNN-based VAEs, _e.g.,_ 3D-VQVAE , 3D-VAQGAN [14; 41]. Attentions are for transformer-based VAEs, _e.g.,_ CViViT . Although there are several discrete 3D VAEs for video generation, there are no commonly used continuous 3D VAEs.

Video Generative models.Video generation has achieved remarkable progress in recent years. The announcement of Imagen Video  and Make-A-Video  made researchers see the hope of purely AI-generated videos. Then, the launch of OpenAI SORA  brought the enthusiasm of researchers in academia and industry to a climax. Many video generation models [17; 29; 42] directly learn the distribution of pixels while some others [5; 6; 44; 34; 35; 24; 41; 14; 33; 40; 4; 15] learn the distribution of tokens in a latent space. The tokens are always extracted by a variational autoencoder . Latent video generation models can be categorized into two groups according to whether the token is discrete or continuous. TATS , MAGVIT , VideoGPT , and Phenaki  are representative models trained with discrete tokens extracted by a 3D VAE within the VQVAE framework . A codebook is learned jointly with the VAE for quantization. SVD , AnimateDiff , VideoCrafter , _etc._, are video models trained with continuous latent extracted by a 2D VAE without quantization, rather than a 3D VAE. SD image VAE is the commonly used 2D VAE. One reason is that video models are difficult to train from scratch and they are always initialized with the weights of a pretrained T2I model such as Stable Diffusion UNet . Hence, the corresponding image VAE is used to extract latentents from a video. Since the image VAE can only perform spatial compression, the temporal compression is realized by uniform frame sampling. This strategy ignores the motion between key frames.

There lacks a video VAE that is compatible with the pretrained T2I or video models. Though it is not difficult to train a video VAE (3D VAE) independently with high reconstruction accuracy; it will result in a latent space gap between the learned video VAE and existing pre-trained image and video models that are always used as initialization. The Open-Sora-Plan project  offers a video VAE; however, it is not compatible with existing image or video models. Large computational resources and a long training time are required to bridge the gap. In this work, we propose a latent space regularization method to train a video VAE whose latent space is compatible with pretrained models.

## 3 Method

We propose a latent space regularization method for training a video VAE that is compatible with pre-trained image and video models. We examine multiple strategies for implementing the regularization, focusing on either the encoder or the decoder of the image VAE. Additionally, we explore four types of mapping functions to develop the regularization loss. To enhance the efficiency of the video VAE, we introduce an architecture that employs different inflation strategies in distinct blocks, instead of incorporating 3D convolutions in all blocks.

### Latent Space Regularization

We inflate a 2D VAE into a 3D VAE, initializing it with the 2D VAE's weights. The 3D VAE is designed to be capable of encoding both image and video (see details in Sec.3.2). The key of building a compatible video VAE is the latent space alignment between the video VAE and the image VAE.

Notations.Let \(x^{H W 3}\) denote an image in RGB space and \(X^{(T+1) H W 3}\) denote a video with \(T+1\) frames. When \(T=0\), \(X\) degrades into an image and the video VAE will process it with temporal padding. \(z^{h w c}\) denotes the latent tokens extracted by either an image VAE or a video VAE. \(Z^{(t+1) h w c}\) is latent tokens extracted by the video VAE. \(_{s}=H/h=W/w\) and \(_{t}=T/t\) are the spatial and temporal compression rates. Let \(_{i}\) and \(_{i}\) denote the encoder and decoder of the image VAE, respectively. While \(_{v}\) and \(_{v}\) are for the video VAE. Then, we have \(z=_{i}(x)\), \(Z=_{v}(X)\), and \(z=_{v}(x)\). \(=_{i}(z)=_{i}(_{i}(x))\), \(=_{v}(Z)=_{v}(_{v}(X))\), and \(=_{v}(z)=_{v}(_{v}(x))\) are the reconstructed image and video from the latent tokens.

Regularization.We assume the latent of the image VAE follow a distribution, _i.e,_\(z p^{i}(z)\). The joint distribution of \(t+1\) independent frames is \(p^{i}(Z)=_{k}^{t+1}p^{i}(z_{k})\). The latent distribution of the video VAE can be denoted as \(Z p^{v}(Z)\). To achieve the alignment between the latent spaces of the image and video VAEs, we have to build mappings between \(p^{i}(Z)\) and \(p^{v}(Z)\). Since both distributions have no analytic formulation, distance metric for measuring differences between distributions is not applicable.

Here, we build the cooperation between the image VAE and the video one to construct reconstruction loss for space alignment. When exploiting the encoder of the image VAE for alignment, the latent extracted from the image encoder should be corrected decoded by the decoder of the video VAE, _i.e.,_\(_{i}^{v}=_{v}(_{i}((X)))\). The illustration is shown in Fig. 3(a). For a given input video \(X^{(T+1) H W 3}\), we use a mapping function \(\) to sample \((X)^{(T/_{t}+1) H W 3}\). Thus the reconstructed video \(_{i}^{v}\) is the same as the shape of \(X\). Then, the reconstruction loss of using the image encoder can be defined as

\[L_{}^{}=||X-_{i}^{v}||^{2}.\] (1)

Figure 3: (a-b): Two different regularization methods; (c) The framework of CV-VAE with the regularization of the pretrained 2D decoder.

When exploiting the decoder of the image VAE, the latent extracted by the video encoder can be decoded by the decoder of the image VAE, _i.e.,_\(_{v}^{i}=_{i}(_{v}(X))\). The illustration is shown in Fig. 3(b). For a given input video \(X^{(T+1) H W 3}\), the reconstructed video is \(_{i}^{v}^{(T/_{t}+1) H W 3}\). Then, the reconstruction loss of using the image decoder can be defined as

\[L_{}^{}=||(X)-_{v}^{i}||^{2}.\] (2)

Mapping Functions.To bridge the dimension gap between \(_{v}^{i}\) or \(_{i}^{v}\) and \(X\), we investigate four types of mapping functions \(\) as follows. **1) First frame.** We compare only the first frame of the input video and the reconstructed one. The regularization loss degenerates to measure the difference between the input and reconstruction of the image. **2) Slice.**\(\) samples one frame every \(_{t}\) frames to form a shorter video. It starts from the second frame and the first one is reserved. **3) Average.**\(\) computes the average of every \(_{t}\) frames, starting from the second frame. **4) Random.**\(\) randomly samples one frame from every \(_{t}\) frames, starting from the second frame.

Training Objective.Following the training of the 2D VAE in LDM , our basic objective is a combination of a reconstruction loss , an adversarial loss , and a KL regularization , _i.e.,_

\[L_{}=_{_{v},_{v}}_{D_{v}}\ L_{}(X,_{v}(_{v}(X))-L_{}(_{v}( _{v}(X)))+ D_{v}(X)+L_{}(X;_{v}, _{v}),\]

where the first term is the reconstruction loss, the second and third are the adversarial loss, and the last is the KL regularization. \(D_{v}\) is the discriminator that differentiates original videos from reconstructed ones. It is inflated from the image discriminator in LDM by injecting 3D convolutions. Then, for latent space alignment, our full training objective is:

\[L_{}^{}=L_{}+_{1}L_{}^{}+_{2}L_{}^{},\] (3)

where \(_{1}\) and \(_{2}\) are trade-off parameters. We explore different settings of \(_{1}\) and \(_{2}\) and find that using the decoder only achieves the best performance. The framework of CV-VAE is shown in Fig. 3(c) and evaluations between different regularization methods can be found in Tab. 6.

### Architecture Design of Video VAE

We design the architecture of the video VAE according to the image VAE in LDM . The detailed architecture is presented in the Appendix A.1. We explain the key modifications as follows.

Model Inflation.Considering the latent space compatibility and the convergence speed of the video VAE, we make full use of the pretrained weights of the image VAE for initialization, instead of training from scratch. We inflate the image VAE into the video VAE by replacing 2D convolutions with 3D convolutions. 3D convolutions are used to model the temporal dynamics among frames. To initialize the 3D convolutions, we copy the weights of the 2D Conv kernel to the corresponding positions in the 3D Conv kernel and set the remaining parameters to zero. We set the stride to achieve temporal downsampling and increase the number of 3D kernels by a factor of \(s\) to achieve \(s\) temporal upsampling. To enable the video VAE to handle both image and video, given \(T+1\) frames as input, we use reflection padding in the temporal dimension for the first frame. By initializing the video VAE using the above operations, we can reconstruct images without training, significantly accelerating the training convergence speed on video datasets.

Efficient 3D Architecture.Expanding 2D Convs to 3D Convs (e.g., \(k k k k k\)) results in \(k\) parameters and computational complexity. To improve the computational efficiency of the model, we adopt a 2D+3D network structure. Specifically, we retain half of the convolutions in the ResBlock as 2D Convs and set the other half as 3D Convs. We find that, compared to setting all Convs to 3D, the number of parameters and the computational complexity are reduced by roughly 30%, while the reconstruction performance remains nearly the same. See Sec. 4.2 for experimental comparisons.

Temporal Tiling for Arbitrary Video LengthExisting image VAEs employ spatial tiling on large spatial resolution images to achieve memory-friendly processing, which cannot handle long videos. As a result, we introduce temporal tiling processing. During encoding, the video \(X\) is divided into \([X_{1},X_{2},...X_{n}]\), where \(X_{i}^{(1+f_{t}) H W 3}\) and \(f\) is a parameter controlling the size of each block. \(X_{i}\) and \(X_{i+1}\) have a one-frame overlap in the temporal dimension. After encoding each \(X_{i}\) to obtain \(Z_{i}\), we discard the first frame of \(Z_{i}\) when \(i 0\) and concatenate all \(Z_{i}\) in the temporal dimension to obtain \(Z\). The decoding process is handled similarly to the encoding process. By combining our method with 2D tiling, we can encode videos with arbitrary resolution and length.

## 4 Experiments

### Experimental Setups

**Datasets and Metrics.** We evaluate our CV-VAE on the COCO2017  validation dataset and the Webvid  validation dataset which includes 1024 videos. Both images and videos are resized and cropped to a resolution of \(256 256\). Each video is sampled with 33 frames and a frame stride of 3. We evaluate the reconstruction performance of CV-VAE on images and videos using metrics such as PSNR, SSIM , and LPIPS scores . We employ 3D tiled processing to encode and decode videos with arbitrary resolution and length within a limited memory footprint. During inference, we allow a single video block size of \(17 576 576\). We evaluate the video generation quality of our model using 2048 randomly sampled videos from UCF101  and MSR-VTT . Videos are resized and cropped to a resolution of \(576 1024\) to fit the SVD . We use Frechet Video Distance (FVD) , Kernel Video Distance (KVD) , and Perceptual Input Conformity (PIC)  metrics to evaluate video generation quality. For evaluating image generation quality, we use 2048 samples from the COCO2017 validation dataset and employ FID , CLIP score , and PIC score metrics.

**Training Details.** We train our CV-VAE model using image datasets including LAION-COCO  and Unsplash , as well as the video dataset Webvid-10M . For image datasets, we employ two resolutions, _i.e._, \(256 256\) and \(512 512\). In the case of video datasets, we use two settings of frames and resolutions: \(9 256 256\) and \(17 192 192\). The batch sizes for these four settings are 8, 2, 1, and 1, with sampling ratios of 40%, 10%, 25%, and 25%, respectively. We employed the AdamW optimizer  with a learning rate of 1e-4 and cosine learning rate decay. To avoid numerical overflow, we trained CV-VAE using float32 precision, and the training was carried out on 16 A100 GPUs for 200K steps. To fine-tune the SVD on CV-VAE, we utilize in-house data with a frame rate and resolution of \(97 576 1024\). We employ deepspeed stage 2 , gradient checkpointing  techniques, and train with bfloat16 precision. We used a constant learning rate of 1e-5 with the AdamW  optimizer, and only optimized the last layer of U-Net. The training was carried out on 16 A100 GPUs for 5K steps.

### Image and Video Reconstruction

We evaluated the reconstruction quality of various VAE models on image and video test sets. The comparison group includes: (1) VAE-SD2.1  which is widely used in the community for image and video generation models. (2) VQGAN  which encoding pixels into discrete latents. We use the f8-8192 version for comparision. (3) TATS : a 3D VQGAN designed for video generation. (4) VAE-OSP : a 3D VAE from Open-Sora-Plan which is initialized from VAE-SD2.1 and trained with video data. (5) Our CV-VAE (2D+3D): retains half of the 2D convolutions to reduce computational overhead. (6) Our CV-VAE (3D): utilizes only 3D convolutions.

As illustrated in Tab. 1, we present the parameter count (Params), Frame Compression Ratio (FCR), and compatibility with existing diffusion models (Comp.) for various VAE models. Thanks to the latent constraint, our model is compatible with current diffusion models, compresses videos by 4\(\) in the temporal dimension, and achieves top-tier image and video reconstruction quality. This enables the generation of longer videos under roughly the same computational resources. Reconstruction

    &  &  &  &  &  \\   & & & &  & SSIM(\(\)) & LPIPS(\(\)) & PNSR(\(\)) & SSIM(\(\)) & LPIPS(\(\)) \\  VAE-SD2.1  & 34M + 49M & 1x & - & 26.6 & 0.773 & **0.127** & **28.9** & 0.810 & 0.145 \\ VQGAN  & 26M + 38M & 1x & \(\) & 22.7 & 0.678 & 0.186 & 24.6 & 0.718 & 0.179 \\ TATS  & 7M + 16M & 4x & \(\) & 23.4 & 0.741 & 0.287 & 24.1 & 0.729 & 0.310 \\ VAE-OSP  & 94M +135M & 4x & \(\) & 27.0 & 0.791 & 0.142 & 26.7 & 0.781 & 0.166 \\ Ours(2D+3D) & 68M + 114M & 4x & ✓ & 27.6 & **0.805** & 0.136 & 28.5 & 0.817 & **0.143** \\ Ours(3D) & 100M + 156M & 4x & ✓ & **27.7** & **0.805** & 0.135 & 28.6 & **0.819** & 0.145 \\   

Table 1: Quantitative evaluation on image and video reconstruction. FCR represents the frame compression rate, and Comp. indicates compatibility with existing generative models.

quality improves as the number of latent channels increases. For comparison results with 16 latent channels, please refer to Appendix A.2.

We also conducted a qualitative comparison of the reconstruction results for different VAE models, as shown in Fig. 4. In the top row, we reconstructed images with a resolution of \(512 512\) and compared them with Image VAE models. All three models compressed the images to a latent size of \(64 64\). Our results were close to those of VAE-SD2.1, while VQGAN had the worst performance. In the bottom row, we reconstructed videos with a resolution of \(33 512 512\) and compared them with Video VAE models. All three models compressed the videos to a latent size of \(9 64 64\). Comparing the decoded videos at the same frames, our model achieved the best results. Check Appendix A.3 and A.4 for more reconstruction results.

### Compatibility with Existing Models

**Text-to-Image Models**  We tested the compatibility of our CV-VAE by integrating it into the pretrained SD2.1 , replacing the original 2D VAE without any finetuning. We evaluated it on

Figure 4: Qualitative comparison of image and video reconstruction. Top: Reconstruction with different Image VAE models (_i.e._, VQGAN  and VAE-SD2.1  ) on images; Bottom: Reconstruction with different Video VAE models (_i.e._, TATS  and VAE-OSP ) on video frames.

Figure 5: Text-to-image generation comparison. In each pair, the left is generated by the SD2.1  with the image VAE while the right is generated by the SD2.1 with our video VAE.

[MISSING_PAGE_FAIL:8]

the first and last layers. We use captions from the validation set of MSR-VTT  for evaluation, with the resolution of 320x512. Following the approach taken by previous studies , we used the CLIP  metric to evaluate the generation quality of text-to-video models, including Frame Consistency (F.C.) and Textual Alignment (T.A.). The experimental results are shown in Tab. 4.3, where the 'VC2+CV-VAE-V' setting achieved the best generation performance through fine-tuning VideoCrafter2. Check Appendix A.5 for quantitative comparison.

### Ablation Study

Influence of Regularization TypeWe evaluated the impact of three types of latent regularization, which are: (1) **2D Enc.**, _i.e._, \(_{1}=0\) and \(_{2}=1\) in Eq. 3; (2) **2D Dec.**, _i.e._, \(_{1}=1\) and \(_{2}=0\) in Eq. 3; (3) **2D Enc. + Dec.**, _i.e._, \(_{1}=1\) and \(_{2}=1\) in Eq. 3.

   Method & FVD(\(\)) & KVD(\(\)) & PIC(\(\)) \\  SVD+RIFE  & **253** & 3.12 & 0.721 \\ SVD+CV-VAE & 295 & **2.26** & **0.734** \\   

Table 4: Comparison between CV-VAE and frame interpolation model.

Figure 6: Comparison between the image VAE and our video VAE on image-to-video generation of SVD . ‘SVD’ means using the image VAE. ‘SVD \(+\) CV-VAE’ means using our video VAE and tuning the output layer of SVD. _Click to play the video clips with Adobe or Faxit PDF Reader._

    &  &  &  \\   & & & F.C. & T.A. \\  VC2  & 1\(\) & \(\) & 0.292 & 0.960 \\ VC2+CV-VAE-I & 1\(\) & \(\) & 0.290 & 0.964 \\ VC2+CV-VAE-V & 4\(\) & \(\) & 0.285 & 0.953 \\ VC2+CV-VAE-V & 4\(\) & ✓ & **0.301** & **0.987** \\   

Table 5: Evaluation results of text-to-video generation.

Tab. 6 shows the impact of various latent regularization methods. Using the 2D decoder for latent regularization results in better reconstruction for both image and video test sets compared to the 2D encoder. This is likely because the gradient backpropagation through the 2D decoder provides better guidance for the 3D VAE's learning, while the frozen 2D encoder doesn't propagate gradients. The '2D Enc. + Dec.' method performs slightly better on image test sets but worse on video datasets compared to '2D Enc.' Since our main goal is video reconstruction and for simplicity, we use the 2D decoder for regularization.

Influence of Mapping FunctionsThe 2D decoder decodes \(n\) frames of latents into \(n\) frames of video, while the 3D decoder decodes the same \(n\) frames of latents into \(1+(n-1) 4\) frames of video. Therefore, we need to mapping the input video to \(n\) frames to calculate the regularization loss in Eq. 2. We evaluated four mapping functions mentioned in Sec. 3.1.

As shown in Tab. 7, the four methods have similar effects on image reconstruction, with the main differences being in video reconstruction. The '1st Frame' approach yields the worst video reconstruction results due to the lack of regularization and guidance for subsequent frames. The 'Slice' method results in poor reconstruction quality for the three unsampled middle frames. The 'Average' method is inferior to 'Random' in video reconstruction, primarily because calculating the mean for multiple consecutive frames leads to motion blur in the target.

## 5 Conclusion and Limitations

We propose a novel method to train a video VAE that is compatible with existing image and video models trained with SD image VAE. The video VAE provides a truly spatio-temporally compressed latent space for latent generative video models, as opposed to uniform frame sampling. Due to the latent space compatibility, a new video model can be trained efficiently with the pretrained image or video models as initialization. Besides, existing video models such as SVD can generate smoother videos with four times more frame using our video VAE by slightly fine-tuning a few parameters. Extensive experiments are performed to demonstrate the effectiveness of the proposed VAE.

Limitations.The performance of the proposed video VAE relies on the channel dimension of the latent space. A higher dimension may yield better reconstruction accuracy. Since we pursue the latent space compatibility with existing image and video models trained with SD image VAE, the channel dimension of our video VAE is limited to be the same as the image VAE. This can be improved if an image VAE with a higher channel dimension becomes available, _e.g.,_ the VAE of SD3 .

    &  &  \\   & PNSR(\(\)) & SSIM(\(\)) & LPIPS(\(\)) & PNSR(\(\)) & SSIM(\(\)) & LPIPS(\(\)) \\ 
2D Enc. & 26.0 & 0.759 & 0.205 & 26.0 & 0.748 & 0.222 \\
2D Dec. & 27.5 & 0.801 & 0.151 & **28.0** & **0.803** & **0.158** \\
2D Enc. + Dec. & **27.9** & **0.808** & **0.150** & 27.6 & 0.795 & 0.176 \\   

Table 6: Comparison of different regularization types.

   Mapping &  &  \\  Function & PNSR(\(\)) & SSIM(\(\)) & LPIPS(\(\)) & PNSR(\(\)) & SSIM(\(\)) & LPIPS(\(\)) \\ 
1st Frame & 27.3 & 0.797 & 0.156 & 26.6 & 0.771 & 0.191 \\ Average & 27.5 & 0.801 & 0.151 & 27.9 & 0.801 & 0.172 \\ Slice & 27.5 & 0.802 & 0.152 & 27.7 & 0.799 & 0.168 \\ Random & **27.6** & **0.803** & **0.138** & **28.4** & **0.811** & **0.153** \\   

Table 7: Comparison of different mapping functions.