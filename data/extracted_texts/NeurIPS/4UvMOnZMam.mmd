# Real-Time Recurrent Learning using

Trace Units in Reinforcement Learning

 Esraa Elelimy, Adam White\({}^{*}\), Michael Bowling\({}^{*}\), Martha White\({}^{*}\)

University of Alberta, Alberta Machine Intelligence Institute (Amii)

\({}^{*}\)Canada CIFAR AI Chair

elelimy,amw8,mbowling,whitem@ualberta.ca

###### Abstract

Recurrent Neural Networks (RNNs) are used to learn representations in partially observable environments. For agents that learn online and continually interact with the environment, it is desirable to train RNNs with real-time recurrent learning (RTRL); unfortunately, RTRL is prohibitively expensive for standard RNNs. A promising direction is to use linear recurrent architectures (LRUs), where dense recurrent weights are replaced with a complex-valued diagonal, making RTRL efficient. In this work, we build on these insights to provide a lightweight but effective approach for training RNNs in online RL. We introduce Recurrent Trace Units (RTUs), a small modification on LRUs that we nonetheless find to have significant performance benefits over LRUs when trained with RTRL. We find RTUs significantly outperform other recurrent architectures across several partially observable environments while using significantly less computation.1

## 1 Introduction

Agents, animals, and people perceive their surrounding environment through imperfect sensory observations. When the state of the environment is partially observable, agents construct and maintain their own state from the stream of observations. The constructed _agent state_ summarizes past environment-agent interactions in a form that is useful to predict and control future interactions . Recurrent Neural Networks (RNNs) provide a flexible architecture for constructing agent state .

While standard RNN architectures have been mainly supplanted by Transformers , in online reinforcement learning settings where the agent learns while interacting with the environment, RNNs remain a promising direction to pursue . There are two main issues that limit the use of self-attention mechanisms from Transformers in online learning. First, calculating the similarity between each pair of points results in a computational complexity that is a function of \(k^{2}\), where \(k\) is the sequence length. Moreover, calculating the similarity between all pairs ignores the temporal order of the data points, which limits the usefulness of self-attention when the data is temporally correlated . Second, we need access to the whole sequence of observations before taking an action or updating the learnable parameters, which is impractical in continual learning. While recent works have reduced the complexity of transformers from quadratic in the sequence length to linear , the entire sequence length is still needed to train such architectures. Gated Transformer-XL attempts to overcome this issue by keeping a moving window of previous observations . A window of past observations does not scale well to long sequences--the computation is quadratic in the sequence length--and a window is one particular fixed function of history. The simpler recursive form in RNNs, on the other hand, can learn a great variety of functions of history from the data and is wellsuited for updating the state online from a sequential data stream and have been shown to outperform transformers in such settings .

A key open question is how to efficiently train RNNs in online RL. We can divide the literature into methods that approximate Real-Time Recurrent Learning (RTRL) and those that restrict the recurrent architecture. RTRL  exploits the recursive nature of the gradient for RNNs, carrying forward the needed gradient information instead of unrolling the recurrent dynamics back in time like Truncated Backpropagation Through Time (T-BPTT) . RTRL avoids storing past data but is so computationally expensive and is intractable for even moderately sized networks. Several methods approximate the RTRL gradient update, including NoBackTrack , Unbiased Online Recurrent Optimization [43; 5], Sparse N-Step Approximation (SnAp) . All of these methods produce a biased gradient estimate. Other works have tried to approximate an unbiased gradient estimate of BPTT specifically for the case of policy gradient updates in RL. However, the approximation resulted in a high variance due to added stochasticity to the policy .

Methods in the second category usually restrict the RNN architecture to a diagonal RNN [9; 30], including Columnar Networks , the element-wise LSTM , and Independently Recurrent Neural Networks (IndRNNs) . The RTRL algorithm is computationally efficient for such architectures. However, this approach sacrifices representation power and can perform poorly . Recent work suggests overcoming the poor performance of diagonal RNNs with a small modification: having a complex-valued recurrent state instead of restricting it to real values . In fact, as we will show in section 3.1, there exists an equivalence between using a dense linear recurrent layer and a diagonal recurrent layer with complex values, indicating no loss of representational capacity. LRUs have been combined with RTRL , though only empirically explored for supervised learning datasets.

In this work, we extend the insights from LRUs into the online RL setting. Our primary contribution are our experiments showing that such a lightweight recurrent architecture can outperform standard approaches like Gated Recurrent Units (GRUs)  in RL, with significantly less computation. To obtain this result, we propose a small extension on LRUs, which we call Recurrent Trace Units (RTUs). RTUs incorporate nonlinearity into the recurrence and use a slightly different parameterization than LRUs, but one we find is more amenable to the use of RTRL in online RL than LRUs. We extend Proximal Policy Optimization (PPO)  to use RTRL, ablating the decision choices we propose. We provide an in-depth study in an animal-learning prediction benchmark, showing that RTUs scale better than GRUs with increasing compute and number of parameters and that RTUs outperform alternative diagonal recurrent architectures trained with RTRL. We then show across numerous control environments that RTUs have comparable or better performance, compared to GRUs and LRUs.

## 2 Background

We formalize the problem setting as a Partially Observable Markov Decision Process (POMDP). At each time step \(t=0,1,2,\), the agent perceives an observation \(_{t}\), a limited view of the state \(_{t}\), and takes an action \(A_{t}(_{t})\). Depending on the action taken, the agent finds itself in a new state \(_{t+1}\), observes the corresponding observation \(_{t+1}\) and a reward \(R_{t+1}\). In the online control setting, the agent's goal is to maximize the discounted sum of the received rewards. It may also make predictions about its environment, such as future observations' outcomes.

For prediction and control in a partially observable environment, the agent should use the stream of observations to construct its _agent state_. The agent state summarizes information from the history of the agent-environment interactions that are useful for prediction and control . We could use the whole history up to \(t\), namely \((_{0},A_{1},R_{1},_{1},A_{2},R_{2},_{t})\), as the agent state. Though the history preserves all the information, it is not feasible to use directly. We want the agent to have constant memory and computation per time step and storing the whole history causes the memory and the computation to grow with time. Instead, the agent needs to compress this history into a concise representation. We refer to the agent's internal representation of the history at time \(t\) as its agent state or its hidden state \(_{t}\). The agent constructs its current agent state \(_{t}^{n}\) from its previous agent state \(_{t-1}^{n}\) and the recent observation \(_{t}^{d}\) using a state-update function \(:^{n}^{d}^{n}\): \(_{t}=(_{t-1},_{t})\).

One way to learn this state-update function \(\) is with a recurrent neural network (RNN). A simple form is a linear recurrent layer, where \((_{t-1},_{t})=_{x}_{t}+ _{h}_{t-1}\) for weight matrices \(_{x}\) and \(_{h}\). We can also add a nonlinear activation, such as ReLU.

In general, we will write

\[_{t}=(_{t-1},_{t},),\]

where \(\) are the learnable parameters in the network. The agent maps the agent state \(_{t}\) to an output \(_{t}\) and then receives a loss \(_{t}(_{t},y_{t})\) indicating how far the output is from a target \(y_{t}\). The agent updates \(\) to minimize this loss over time.

Two main gradient-based algorithms are widely used to train RNNs: Truncated Backpropagation Through Time (TBPTT) and Real-Time Recurrent Learning (RTRL). T-BPTT specifies a truncation length \(T\), which controls the number of steps considered when calculating the gradient . As a result, the computation and memory complexities of T-BPTT are functions of the truncation length. Learning with T-BPTT involves a trade-off between the network's ability to look further back in time and its compute and memory requirements. Picking a large \(T\) can be expensive, or require us to limit the network size, but picking too small of a \(T\) can cause the agent to miss important relationships and so result in poor performance.

Williams and Zipser (1989) introduced the Real-time Recurrent Learning algorithm (RTRL) as a learning algorithm for continual recurrent learning. Instead of unrolling the recurrent dynamics back in time, RTRL computes the gradient using the most recent observation, and the gradient is calculated and carried from the last step . Assuming the network parameters have not changed, this recursive form gives the exact gradient and does not suffer from the truncation bias inherent to T-BPTT. We provide a more detailed background on the BPTT and RTRL in Appendix A. In reality, the agent updates its parameters frequently, so the gradient information saved from previous time steps is stale, i.e., calculated w.r.t old parameters; yet, under the assumption of small learning rates, RTRL is known to converge . These properties make RTRL ideal for online learning, but unfortunately, there is a catch: its computational complexity is quartic, of fourth order, in the size of \(_{t}\), which can be prohibitively expensive. For this reason, we pursue a restricted diagonal form in this work, for which RTRL is efficient and linear in \(_{t}\).

## 3 Recurrent Trace Units

In this section, we introduce Recurrent Trace Units (RTUs). We start by revisiting why complex-valued diagonals represent dense recurrent layers, and why using real-valued diagonals is insufficient. We then introduce the specific form for RTUs that leverages this relationship. We then provide the RTRL update for RTUs, highlighting that it is simple to implement and linear in the hidden dimension. We finally contrast RTUs to LRUs and motivate why this small extension beyond LRUs is worthwhile.

### Revisiting Complex-valued Diagonal Recurrence

Assume we have the recurrence relationship, with learnable parameters \(_{h}^{n n}\) and \(_{x}^{n d}\), \(_{t}\ _{h}_{t-1}+_{x}( _{t})\), where \(\) can be any transformation of the inputs \(_{t}\) before they are inputted into the recurrent layer. We can rewrite the square matrix \(_{h}\) using an eigenvalue decomposition \(_{h}\ =\ \ \ ^{-1}\), where \(\) contains the \(n\) linearly independent eigenvectors and \(^{n n}\) is a diagonal matrix with the corresponding eigenvalues. Then we have that

\[_{t}=(\ ^{-1}\ _{t-1}\ + ^{-1}_{x}\ (_{t}))^{-1} _{t}=^{-1}\ _{t-1}\ +\ ^{-1}\ _{x}\ ( _{t})\]

By defining \(}_{t}^{-1}\ _{t}^{n}\) and \(}_{x}\ \ ^{-1}_{x}^{n d}\), we get a new recurrence \(}_{t}=\ }_{t-1}+ }_{x}(_{t})\).

We can see \(}_{t}\) and \(_{t}\) are representationally equivalent: they are linearly weighted for downstream predictions, and so the linear transformation on \(}_{t}\) can fold into this downstream linear weighting. But it is more computationally efficient to use \(}_{t}\) with a diagonal weight matrix \(\), meaning each hidden unit only has one recurrent relation instead of n. LRUs precisely leverage this equivalence . Specifically, they learn a complex-valued \(}_{t}\), and use \((}\ }_{t})\) as an input to an MLP for downstream nonlinearity.

Since we did not impose constraints on the matrix \(_{h}\), other than being diagonalizable, the eigenvalues of \(_{h}\) can be complex or real numbers. Previous diagonal RNNs such as eLSTM , Columnar networks , and IndRNNN  use only real-valued diagonal matrices. Having only real-valued diagonals assumes that the matrix \(_{h}\) is symmetric. We provide a small experiment in Appendix B.2 showing that this assumption does not hold even in the simplest setting and that complex eigenvalues do arise. We also investigate whether this result can be extended beyond linear recurrence, and largely obtain a negative theorical result (see Appendix B.1 and C ).

### The RTU Parameterization

A complex number can be represented in three ways: \(a+bi\) (the real representation), \(r(i)\) (the exponential representation), and \(r(()+i())\) (the cosine representation). Mathematically, these three representations are equivalent, but do they affect learning differently? Orvieto et al.  empirically showed that using the exponential representation resulted in a better-behaved loss function than the real representation on a simple task; we provide some discussion in Appendix D.1 further motivating why the real representation is less stable. We chose instead to pursue the cosine representation, because it allows us to represent the complex hidden vector as two real-valued vectors. The remainder of this section outlines RTUs, with and without nonlinearity in the recurrence.

Our goal is to learn a complex-valued diagonal matrix with weights \(_{k}=r_{k}((_{k})+i(_{k}))\) on the diagonal, for \(k=1,,n\). Multiplying by a complex number is equivalent to multiplying by a 2x2 block matrix with a rescaling. We can use this rotational form to avoid explicitly using complex numbers, and instead use two real-values for each complex-valued hidden node. We write this real-valued matrix \(^{2n 2n}\) as blocks of rotation matrices2

\[=_{1}&&\\ &&\\ &&_{n}_{k}=_ {k}(_{k})&-(_{k})\\ (_{k})&(_{k}).\] (1)

Each element of \(_{t}=_{t-1}+_{x}\,_{t }^{2n}\) has two components \(_{t}^{c_{1}},_{t}^{c_{2}}\), updated recursively:

\[_{t}^{c_{1}} =()_{t-1}^{c_{1} }-()_{t-1}^{c_{2}}+ _{x}^{c_{1}}_{t},\] \[_{t}^{c_{2}} =()_{t-1}^{c_{2} }+()_{t-1}^{c_{1}}+ _{x}^{c_{2}}\,_{t}.\]

We finally combine the new recurrent states into one state \(_{t}[(_{t}^{c_{1}});( _{t}^{c_{2}})]\), potentially using a non-linearity \(f\) after the recurrence.

We also adopt two parameterization choices made in LRUs that showed improved performance. The first is learning logarithmic representations of the parameters rather than learning them directly: instead of learning \(\) and \(\), the network learns \(^{}\) and \(^{}\), where \((-)\), \(=(^{})\), and \(^{}()\). This re-parametrization restricts the \(\) to be \((0,1]\), required for stability. We found these modifications to improve stability of RTUs (see Appendix E). The second parameterization choice we adopt from LRUs is to multiply the input \((_{x}_{t})_{k}\) by a normalization factor of \(_{k}=(1-r_{k}^{2})^{1/2}\). Putting this all together, the final formulation of RTUs is:

\[_{t}^{c_{1}} =(^{},^{}) _{t-1}^{c_{1}}-(^{}, ^{})_{t-1}^{c_{2}}+ _{x}^{c_{1}}_{t},\] \[_{t}^{c_{2}} =(^{},^{}) _{t-1}^{c_{2}}+(^{}, ^{})_{t-1}^{c_{1}}+ _{x}^{c_{2}}_{t},\] (2) \[_{t} =[(_{t}^{c_{1}});(_{t}^ {c_{2}})],\]

where \(^{n}\) is the vector composed of \(_{k}=(1-(-(_{k}^{}))^{2})^{1/2}\) and

\[g(_{k},_{k}) (-(_{k}^{}))((_{k}^{})),\] (3) \[(_{k},_{k}) (-(_{k}^{}))((_{k}^{})).\]

Note that \(\) can be absorbed by \(\), and so does not change representation capacity.

There are two ways to incorporate non-linearity into RTUs: inside the recurrence or after the recurrence. In the above, in Equation (2), the non-linearity is after the recurrence. These RTUsmaintain the equivalence to a dense linear RNN, because the recurrence itself remains linear. We refer to this definition of RTUs as _Linear RTUs_, because the recurrence is linear, even though we have the ability to represent nonlinear functions by allowing for any nonlinear activation after the recurrence. We also evaluated a different variation of RTUs where the non-linearity is added to the recurrence directly. These _Nonlinear RTUs_ are written as:

\[_{t}^{c_{1}} =((^{},^{})_{t-1}^{c_{1}}-(^{},^{})_{t-1}^{c_{2}}+ _{x}^{c_{1}}_{t}),\] \[_{t}^{c_{2}} =((^{},^{})_{t-1}^{c_{2}}+(^{},^{})_{t-1}^{c_{1}}+ _{x}^{c_{2}}_{t}),\] (4) \[_{t} =[_{t}^{c_{1}};_{t}^{c_{2}}].\]

Notice now \(f\)--a nonlinear activation like ReLU--is used in the update to \(_{t}^{c_{1}}\) and \(_{t}^{c_{2}}\), and the final \(_{t}\) simply stacks these two components. Nonlinear RTUs lose the equivalence to dense RNNs, though in our experiments, we find they perform as well or better than Linear RTUs.

### The RTRL Update for RTUs

This section shows the RTRL updates for RTUs with more in-depth derivations in Appendix E. To keep notation simpler, we write the updates as if we are directly updating \(r\) and \(\); the updates for \(^{}\) and \(^{}\) are easily obtained then using the chain rule. The full derivation is in Appendix E.2.

Consider the partial derivative with respect to \(r_{1}\) for the first RTU with input \(_{1}(_{x}^{c_{1}}_{t})_{1}\):

\[h_{t,1}^{c_{1}}=r_{1}(_{1})h_{t-1,1}^{c_{1}}-r_{1}(_{1})h_ {t-1,1}^{c_{2}}+^{2})}_{1}.\]

Then

\[_{t}}{ r_{1}}=_{t}}{  h_{t,1}^{c_{1}}}^{c_{1}}}{ r_{1}}+ _{t}}{ h_{t,1}^{c_{2}}} ^{c_{2}}}{ r_{1}}.\]

Since \(r_{1}\) only impacts the two units in the first RTU, and derivatives w.r.t. the remaining hidden units are zero. Therefore, we just need to keep track of the vector of partial derivatives for these two components, \(_{t}^{r,c_{1}}[^{c_{1}}}{ r_{1}}, ,^{c_{1}}}{ r_{n}}]\) and \(_{t}^{r,c_{2}}[^{c_{2}}}{ r_{1}}, ,^{c_{2}}}{ r_{n}}]\) with recursive formulas:

\(_{t}^{r,c_{1}}\!\!=\!()_{t-1}^{c_{1}}\!+ \!()_{t-1}^{r,c_{1}}-() _{t-1}^{c_{2}}-()_{t-1}^{r,c_{2}}-}{^{2}}}_{x}^{c_{1}} _{t}\)

\(_{t}^{r,c_{2}}\!\!=\!()_{t-1}^{c_{2}}\!+ \!()_{t-1}^{r,c_{2}}+() _{t-1}^{c_{1}}+()_{t-1 }^{r,c_{1}}-}{^{2}}}_{x}^{c_ {2}}_{t}\)

We can similarly derive such traces for \(\). The update to \(\) involves first computing \(_{t}}{ h_{t}^{c_{1}}}\), using backpropagation to compute gradients back from the output layer to the hidden layer; this step involves no gradients back-in-time. Then \(\) is updated using the gradient \(_{t}}{_{t}^{c_{1}}}_{ t}^{r,c_{1}}+_{t}}{_{t}^{c_{2}}} _{t}^{r,c_{2}}\), which is linear in the size of \(^{n}\), as the vectors \(_{t}^{r,c_{1}},_{t}^{r,c_{2}}^{n}\) can be updated with linear computation in the above recursion. This update is the RTRL update, with no approximation.

### Contrasting to LRUs

RTUs are similar to LRUs, with two small differences. First, RTUs have real-valued hidden units, because the cosine representation is used instead of the exponential representation. Second, RTUs use nonlinear activations in the recurrence, making them no longer linear. Though again a minor difference, we find that incorporating nonlinearity in the recurrence can be beneficial. RTUs can be seen as a small generalization of LRUs, moving away from strict linearity--and thus motivating the name change--but nonetheless a generalization we find performs notably better in practice.

Let us now motivate the utility of moving to a cosine representation and real-valued traces. LRUs parameterize each hidden unit with \(_{k}=r_{k}(i_{k})=(-(_{k}^{})+i(_{k} ^{}))\) and directly work with complex numbers. Consequently, the hidden layer cannot be directly used to predict real-values. It would be biased to take \((}_{t})\) (see Appendix D.2), and instead an additional weight matrix \(}^{n n}\) must be learned, to get \((}\ }_{t})\). To understand why this works, assume that we took the original \(_{t}\) from the dense NN, and handed it to an MLP. This would involve multiplying \(_{t}\) for some \(\). If we set \(}=\), then \(}\ }_{t}=^{-1} _{t}=_{t}\) and we did not introduce any bias. In fact, if \(}\) is set this way, we do not need to take the real-valued part, because the output of \(}}_{t}\) is real-valued. Of course, learning does not force this equivalence--in fact this parameterization is more flexible than the original--and so it is necessary to take the real-part.

RTUs avoid some of these complications by explicitly writing the recurrence and updates with real-valued hidden states. Implicitly, the relationship between the two real-valued hidden vectors forces them to behave like complex numbers (as rotations), but all equations and learning stay in real-valued space. RTUs consequently avoid the need to post multiply by the matrix, removing a small number of learnable parameters, allowing the use of a nonlinear activation directly on the output, and allowing the hidden state to be immediately passed to a downstream MLP. We acknowledge that others may argue that working directly with complex numbers is preferable. The preference for real-valued hidden layers may simply be our own limitations, but we suspect much of the reinforcement learning community is similarly more comfortable to work in real-valued space. We found small choices in our implementation for LRU did not always behave as expected, partially due to how auto-differentiation is implemented in packages for complex numbers3.In the end, our goal is to make these simple recurrent traces easy to use, and providing updates with real numbers may remove some barriers.

## 4 Online Prediction Learning

In this section, we explore different architectural variants of RTUs and LRUs in a online prediction task and then move on to study the tradeoffs between computational resources and performance when using RTUs with RTRL compared to GRUs and LRUs with T-BPTT.

### Ablation Study on Architectural Choices for RTUs and LRUs

In this first experiment, we investigate the impact of several architectural choices on the performance of RTUs and LRUs varying where nonlinearity is applied. We use a simple multi-step prediction task called _Trace conditioning_ inspired by experiments in animal learning. The agent's objective is to predict a signal--called the Unconditional Stimulus (US)--conditioned on an earlier signal--the Conditional Stimulus (CS). The prediction is formulated as a return, \(G_{t}_{k=0}^{}^{k}_{t+k+1}\), where the agent's goal is to estimate the value function for this return. More details on this environment and experimental settings are in Appendix F. Figure 1 summarizes the results.

### Learning under resources constraints

In this section, we investigate the tradeoffs between computational resources and performance when using RTUs with RTRL compared to GRUs and LRUs with T-BPTT.

In the following experiments, all agents consist of a recurrent layer followed by a linear layer generating the prediction. We measure performance of the agents online by calculating the Mean Square Return Errors (MSRE), which is the mean squared error between the agent's prediction at time \(t\) and \(G_{t}\). In all the experiments, we used the Adam optimizer. We first ran each agent with different step sizes for \(5\) runs and \(2\) million steps. We then averaged the MSRE over the \(2\) million steps and selected each agent's best step size value. Finally, we ran the agents with the best step size value for \(10\) runs, which we report here. We also report all agents' step size sensitivity curves in Appendix F.3.

Figure 1: Ablation over different architectural choices for RTUs and LRUs. The RTU variants are blue, and the LRU variants are orange. In each subplot, we restrict both architectures in a particular way, reporting prediction error (MSRE) as a function of hidden state size. Across variations, RTUs are often better and, at worst, tie LRU. Here, both architectures were using RTRL.

**Learning under computational constraints:** We first investigate: _how well do different agents exploit the available computational resources?_ We specified a fixed computational budget of \(~{}15000\) FLOPs. Since RTUs are learning using RTRL and have a linear computational complexity, the computational budget only determines the number of hidden units in the architecture. For GRU and LRU, both the truncation length and the hidden dimension contribute to the budget. We tested several configurations of truncation lengths and parameters such that the overall computations fit the computational budget. Figure 2.a shows the results of this experiment. As we move along the horizontal axis, the number of parameters for GRU and LRU decreases as \(T\) increases to fit the computational constraints. However, the RTU agents do not depend on \(T\), so their performance and computation is constant.

**Scaling with computation:** The computational complexity of T-BPTT depends on the truncation length and the number of parameters in the neural network. Thus, the agent can use the additional resources in two ways: (1) Increasing the truncation length, and (2) Increasing the number of parameters. On the other hand, RTUs use all the computations to have more parameters.

Now, we move to our second question: _how well do different methods scale with increasing the computational budget?_ We answer this question in two stages: Firstly, we study T-BPTT with increasing \(T\) and a fixed number of parameters. For RTU, the computation increases by adding more parameters such that all corresponding points from GRU and RTU use the same amount of computation. Secondly, we fixed the truncation length for GRU to 45, which is more than the maximum distance between the CS and the US, and increased the computation by increasing the number of parameters for GRU. Again, for RTU, we increased the computation by increasing the number of parameters.

Figure of 2.b shows the first experiment's results. While GRU's performance improved as the truncation length increased, RTU outperformed GRU across all different computational budgets. Figure 2.c shows the results of the second experiment. The RTU agent's performance consistently improves as we increase the computation available. However, the performance improvement for the GRU agent is inconsistent. The inconsistency of GRU performance could be associated with the trade-off between the truncation length and the number of parameters.

**Scaling With Parameters:** Finally, we study the performance of RTU and GRU when given the same number of parameters and allow the GRU agent to use more computation. We fixed the truncation length for GRU to \(45\) as before and used the same number of parameters for both agents. Figure 2.d shows the results of this experiment. For RTU, we see the same consistent performance improvement as we increase the number of parameters. For GRU, the performance improvement is also consistent, though it degrades slightly towards the end. The RTU agent outperforms the GRU agent even though the GRU uses more computation.

We provide additional experiments comparing RTUs to two other approaches that use RTRL: online LRUs and a real-valued diagonal RNN in Appendix F.1.

Figure 2: **Learning under resources constraints in Trace Conditioning. Each of the four subplots shows how each algorithm’s performance varies as a function of resources. (a) LRU and GRU with T-TBTT is not competitive with RTUs even as \(T\) is increased while restricting the number of hidden units in LRU and GRU so that all algorithms use about the same computation per step. (b) If we allow GRU and LRU’s computation to increase (fixed network size) while increasing \(T\), the performance gap remains. (c) Fixing \(T\) to a large value to solve the task, we can increase the number of parameters, holding the computation equal for all methods. (d) If we do not require compute to be equal across methods as we scale parameters, then the LRU can eventually match the error of RTU, but GRU cannot. The black dashed line represents the near perfect prediction performance.**Real-Time Recurrent Policy Gradient

This section first highlights some differences in using _linear RTRL_ methods, i.e., RTRL with linear complexity, in incremental and batch settings. We then investigate different ways of integrating linear RTRL methods with policy gradient approaches, and we use PPO as a case study for this investigation. Finally, we compare the performance of RTRL methods with T-BPTT methods and other baselines.

### Linear RTRL Methods in Incremental and Batch Settings

The benefits of linear RTRL methods over T-BPTT are more evident in the incremental rather than the batch setting. In the incremental learning setting, where the agent updates its parameters after each interaction step, linear RTRL methods have a constant computational complexity per update that depends only on the number of parameters. In contrast, T-BPTT methods have a complexity proportional to the truncation length T since T-BPTT methods require storing a sequence of past T activations to perform one gradient update. Figure 3 shows the time it takes to make one update with linear RTRL and T-BPTT given the same number of parameters. For T-BPTT, the time to make one update scales with the truncation length T, while for linear RTRL, it is constant.

The computational analysis for the batch setting is different than the incremental setting. In the batch setting, linear RTRL still have a constant cost per update and provide an untruncated yet stale gradient for all the samples. When using T-BPTT in the batch setting, there are two possibilities for the gradient updates. The first option, the typical strategy, is to divide the batch into non-overlapping sequences, each of length T, and perform T-BPTT on each sequence. In this case, the cost of one gradient update per sequence is a function of T, resulting in an effective update cost per sample independent of T. As a result, T-BPTT is computationally efficient in this case, albeit at the expense of a worse gradient estimate; in each sequence, only the last sample has a gradient estimate with T steps . Figure 3 shows the time it takes to make one batch update with linear RTRL and T-BPTT given the same number of parameters. In this case, both methods use similar time per update. The second option is to divide the batch into overlapping sequences, where each gradient uses a sequence of T steps . This approach increases the cost of updates per sample to be proportional to T, as in the incremental setting, with the benefit of better gradient estimates. However, all standard implementations of RL methods with T-BPTT use the computationally efficient option .

**Integrating Linear RTRL Methods with PPO** When performing batch updates, as with PPO, the RTRL gradients used to update the recurrent parameters will be stale, as they were calculated during the interaction with the environment w.r.t old policy and value parameters. One solution to mitigate the gradient staleness is to go through the whole trajectory after each epoch update and re-compute the gradient traces. However, this can be computationally expensive. In Appendix G, Algorithm 1, we provide the pseudocode for integrating RTRL methods with PPO with optional steps for re-running the network to update the RTRL gradient traces, the value targets, and the advantage estimates. We also performed an ablation study to investigate the effect of the gradient staleness in RTRL when combined with PPO, Appendix G. The results from the ablation study show that using a stale gradient results in better performance with RTUs and suggests that the staleness might help PPO maintain the trust region.

## 6 Experiments in Memory-Based Control

In this section, we evaluate the memory capabilities of RTUs when solving challenging RL control problems. We divide the problems in this section based on the source of partial observability. 1) Missing sensory data, where we mask out parts of the agent's observation. The agent must

Figure 3: Contrasting runtime in incremental and batch settings. In the incremental setting, evaluated in the animal-learning prediction task, T-BPTT updates scale with truncation length, whereas linear RTRL is constant. With batch updates, evaluated in Ant-P with PPO, linear RTRL remains linear and T-BPTT is slightly more efficient.

accumulate and integrate the sensory observations over time to account for the missing information. 2) Remembering important cues, where the agent must remember an essential cue about the environment that happened many steps in advance.

**Integrating Sensory Observations:** We use the standard Mujoco POMDP benchmark widely used in prior work for evaluating memory-based RL agents . The benchmark consists of several challenging tasks where the agent controls a multi-joint dynamical body while only observing the joints' positional (Mujoco-P) or velocity information (Mujoco-V). To increase experiment throughput, we use the Jax implementation of Mujoco from the Brax library  and implemented wrappers to mask either the velocity (Mujoco-P) or positional information (Mujoco-V).

We evaluated our Linear and Non-linear RTUs against GRU, LRU, and Online LRU. All agents use PPO  as the control algorithm, and the difference between the agents is the recurrent component. For all agents, we fixed the number of parameters for the recurrent part to be \( 24\)k. We tuned the learning rate for all agents in all environments and selected the best learning rate for each agent per environment. We also included a GPT2-transformer baseline. We followed the implementation details in previous work , and used a GPT2 variant with \(200\)k parameters. We provide the results for GPT2 in Appendix H.

When given the same number of parameters, RTU agents outperform other baselines in all environments in Figure 4. Furthermore, we show in Appendix H that even when increasing the truncation length of both GRU and LRU agents to use significantly longer history, they outperform RTUs in only one task. Of particular note is again that RTUs outperform online LRUs, highlighting again that our simple modifications have a large impact on performance in this online RL setting.

**Remembering Important Cues:**

Next, we test the agents' ability to remember essential environmental cues. We use several tasks from the POPGym benchmark  in addition to the Reacher POMDP task, a modified version of Mujoco Reacher where the agent observes the target position only at the beginning of the episode.

The POPGym tasks we consider along with the Reacher POMDP are all long-term memory tasks  as the agent must remember and carry the information for a long time.

Figure 5 summarizes the results for the reacher POMDP task and the POPGym results can be found in Figure 6. In both cases, we can see that RTUs outperform the other approaches. Non-linear RTUs achieve a better performance than linear RTUs in reacher POMDP, and both achieve a better performance in all tasks than online LRUs. In Reacher POMDP, GRU was able to achieve a similar performance to that of linear RTUs.

Figure 4: Learning curves on the Mujoco POMDP benchmark. Environments with -P mean that velocity components are occluded from the observations, while -V means that the positions and angles are occluded. All architectures have the same number of recurrent parameters ( \(24\)k parameter). For each architecture, we show the performance of its best-tuned variant.

Figure 5: Reacher, \(30\) runs with standard errors.

## 7 Conclusion and Limitations

In this work, we investigated using complex-valued diagonal RNNs for online RL. We built on LRUs, to provide a small modification (RTUs) that we found performed significantly better in online RL across various partially observable prediction and control settings. We also found RTUs performed better than the more computationally intensive GRUs. Overall, RTUs are a promising, lightweight approach to online learning in partially observable RL environments.

A primary limitation of RTUs is the extension to multilayer recurrence. This limitation is inherent to all RTRL approaches; with multilayers, we need to save the gradient traces of the hidden state w.r.t the weights from all the preceding layers . Previous work [17; 48] showed that using stop gradient operations between the layers and not tracing the time dependencies across layers is a viable choice. However, we need a more principled approach for tracing the gradient across layers.

One advantage of the linearity restriction in LRUs is that it allows the use of parallel scans for training . However, recent works have shown the possibility of employing parallel scans to non-linear RNNs [8; 22]. A future direction is to investigate the use of parallel scans for training RTUs.

## 8 Acknowledgments

We would like to thank Nicolas Zucchet for advice about the online LRU implementation, and Subhojeet Pramanki for many discussions on transformers and RNNs. We would like to thank NSERC, CIFAR and Amii for research funding and the Digital Research Alliance of Canada for the computational resources.