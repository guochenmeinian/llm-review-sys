# Continual Learning with Global Alignment

Xueying Bai Jinghuan Shang Yifan Sun Niranjan Balasubramanian

Department of Computer Science

Stony Brook University

{xubai, jishang, ysun, niranjan}@cs.stonybrook.edu

###### Abstract

Continual learning aims to sequentially learn new tasks without forgetting previous tasks' knowledge (catastrophic forgetting). One factor that can cause forgetting is the interference between the gradients on losses from different tasks. When the gradients on the current task's loss are in opposing directions to those on previous tasks' losses, updating the model for the current task may cause performance degradation on previous tasks. In this paper, we first identify causes of the above interference, and hypothesize that correlations between data representations are a key factor of interference. We then propose a method for promoting appropriate correlations between arbitrary tasks' data representations (i.e., global alignment) in individual task learning. Specifically, we learn the data representation as a task-specific composition of pre-trained token representations shared across all tasks. Then the correlations between different tasks' data representations are grounded by correlations between pre-trained token representations. We explore different ways to learn such compositions. Without experience replay, our model achieves SOTA performance in continual learning tasks. It also achieves advanced class-incremental performance through task-incremental training. The code is available at: https://github.com/StonyBrookNLP/global-alignment.

## 1 Introduction

Continual Learning (CL) aims to develop models that can sequentially learn from streams of data and tasks, which is an important need for many real-world applications . One main challenge in developing CL models lies in reducing catastrophic forgetting, where models forget knowledge obtained from previous tasks after learning new tasks .

Catastrophic forgetting can happen when there is interference during task learning, especially in models that use shared parameters for all tasks . Specifically, when learning a new task, if the model's gradients on the new task's loss are contradictory (e.g. in opposing directions) to those on the previous tasks' loss, the model will be updated towards a direction that increases the losses on previous tasks, causing forgetting. In this paper, we first identify factors that may lead to interference by analyzing the dot product between models' (flattened) gradients on losses from two tasks. Then, we design methods to address interference based on each factor.

Our analysis in Section 3 shows that interference mainly depends on two factors: correlations between hidden representations of the data from different tasks; and correlations between columns of the classifier (which we call class vectors) that map data representations to corresponding classes.

To address interference caused by the first factor, we want models to learn _aligned_ data representations that do not have destructive correlations (i.e., leading to interference) when switching tasks and during task learning. Specifically, this requires models to accommodate future task representations when learning the current task. This motivates learning data representations based on some (well-correlated) global representations, for which we use pre-trained token representations for language data . Specifically, we compose data representations as task-specific interpolations of pre-trained tokenrepresentations. This allows the correlations between tasks' data representations to be grounded by correlations between pre-trained representations. We design three transformer-based  models that target such _global alignment_: (1). learning data representations by interpolating the pre-trained token representations through the attention mechanism; (2). the above model with additional neighborhood information to expand the search space of task information; (3). a controlled LoRA  model that adapts the pre-trained token representation with a small scaling factor.

To address interference caused by the second factor, we first train the classifier only when switching the task and then tune the whole model. This probing first strategy was first proposed in  to reduce representation distortion in single-task learning. Here we use it to reduce interference especially when there are destructive correlations between representations (e.g., caused by overlapping representations ). Probing enables different class vectors to focus on different features in data representations when switching tasks, which is useful when different tasks' representations are overlapped unexpectedly.

An overall view of our methods is in Fig. 1. Evaluations show that both the aligned representations and the probing first strategy improve CL performance in multiple settings. Specifically, global alignment models perform well in class-incremental evaluation after task-incremental training.

In conclusion, we make the following key contributions in this paper:

1. We identify factors that cause interference in CL, and propose to address the interference issues by learning aligned representations and applying the probing first strategy.
2. We design three models to learn aligned representations, which learn task-specific attention with different levels of adaptations on pre-trained token representations.
3. We conduct extensive experiments on multiple CL settings. Results show that our models can significantly reduce forgetting even without the use of experience replay.

## 2 Related Work

Continual LearningCL Models can be divided into three main categories: regularization-based models which constrain the deviation of new parameters from the older ones [25; 62; 1; 29]; replay-based models which reduce forgetting by rehearsing on real or pseudo samples from previous tasks [35; 7] or generative models [49; 24]; and architecture-based models which learn evolving architectures for sequential tasks, with their capacities for each task carefully assigned [48; 60].

CL in NLP is an emerging area [32; 3]. MBPA++  uses experience replay and local adaptation to mitigate forgetting; LAMOL  generates pseudo samples for replay; IDBR  disentangles task-agnostic and task-specific information; CTR  uses a capsule network for knowledge transfer. All the above models are based on pre-trained LM [11; 4; 43]. Recent works show that pre-training can alleviate catastrophic forgetting [59; 39; 28]. Our work is also based on the pre-trained LM, but we use it for alignment purposes without experience replay.

Alignment in CLRecent CL works have studied the importance of alignment between different tasks' learning. Riemer et al.  aligns gradients between tasks to reduce destructive interference; Guo et al.  preserves holistic information for future tasks. If the previously learned knowledge does not align with that for future tasks, models may abruptly change previously learned knowledge and cause forgetting [5; 36; 22]. However, previous works focus on the alignment between observed tasks, which lack a global view and can cause forgetting in the future . Instead, our work achieves alignment by pre-trained semantic features, which are general even to unseen future tasks.

Figure 1: Overview of our methods. Task \(i\)’s data representations are denoted as \(_{i}\) with pre-trained token representations as grey dots in the ‘Representation’ block. Correlations between aligned data representations from different tasks depends on correlations between pre-trained token representations. In the ‘Class Vectors’ block, class vectors for different classes have different focuses on representations after probing, which can reduce interference caused by overlapped representations.

Adaptation Models

With limited trainable parameters, our alignment models have connections to adaptation models, which originally aimed at parameter efficiency. Different adaptation models add limited trainable parameters on the frozen transformer layer [19; 40; 17; 20]; or selectively update existing parameters [42; 61]. Recent works do adaptation by prompt tuning [31; 30; 34], which learns prompt embeddings for target tasks.

Adaptation models have also been used for CL [57; 13; 56; 45; 50]. However, most works use the models' parameter efficiency to construct progressive memory. Whether different adaptation structures influence CL, why and how they help remain unexplored. Our model has a similar form to adaptation models after derivation, but our design focuses on representation alignment rather than computational efficiency, with no progressive memory.

## 3 Problem Statement

In this paper, we focus on the catastrophic forgetting caused by cross-task interference [46; 47]. We conduct a case study to identify factors of the interference in Section 3, which motivates our global alignment approach in Section 4.

### Continual Learning Settings

Tasks and DataWe consider the setting where models continually learn a sequence of tasks, with the condition that the previous tasks' data becomes inaccessible when learning new tasks. We denote a representative data for each task \(i\) as \((_{i},y_{i})\), where \(_{i}\) is the model input and \(y_{i}_{i}\) is its class logit. \(_{i}\) is the set of all class logits in task \(i\), and we denote the set of class logits across all \(T\) tasks as \(=\{_{i}\}_{i=1}^{T}\).

ScenariosWe consider two CL scenarios: _task-incremental learning_ and _class-incremental learning_. The main difference between them is that at inference time for task \(i\) the model knows its task-specific classes \(_{i}\) in _task-incremental learning (task-aware)_, while the model has to predict the class from all classes \(\) in _class-incremental learning (task-agnostic)_.

ModelsOur models consist of an encoder that encodes the input \(_{i}\) to a \(d\)-dimensional representation \(_{i}^{d}\), and a matrix of class vectors (i.e., a classifier) \(^{d||}\) whose \(y_{i}\)-th column \(_{y_{i}}\) maps the hidden representation \(_{i}\) to the space of the class \(y_{i}\). The probability of \(y_{i}\) being predicted by the model is calculated by the softmax function: \(p(y_{i}|_{i})=(_{i}^{T})_{y_{i}}\). At training time, the softmax is computed over classes in each task, while at inference time the softmax is computed over the range of classes specified in the task- or class-incremental scenarios. We sequentially train each task with the cross-entropy loss: \((_{i},y_{i})=- p(y_{i}|_{i})\) for task \(i\)'s data \((_{i},y_{i})\).

### Cross-Task Interference

According to Riemer et al. , catastrophic forgetting can occur when a model learns a new task if its gradients on the new task's loss are contradictory (e.g. in opposing directions) to its gradients for the previous tasks' losses. In other words, the gradient descent for the new task might update the model towards a direction that increases its losses on previous tasks, and thus cause forgetting.

In this section, we analyze factors that can lead to interference between gradients. Specifically, we study a case based on a representative toy model. The model's encoder contains two linear layers with corresponding weight matrices denoted by \(^{l}^{d d}\), where \(l\) indexes the layers. The encoder outputs the representation: \(_{i}=^{2}^{1}_{i}\) for data in task \(i\). Here the input \(_{i}^{d}\) is a \(d\)-dimensional vector.

Suppose we are learning task \(j\) after task \(i\) using gradient descent. Consider \((_{i},y_{i})\), \((_{j},y_{j})\), two arbitrary data instances in tasks \(i\) and \(j\) respectively. The interference between gradients of the weight matrix \(^{l}\) with respect to the cross-entropy loss is given by:

\[(^{l})=_{^{l}}(_{i },y_{i})_{^{l}}(_{j},y_{j}).\]

Destructive interference occurs when \((^{l})<0\), which can cause the model to forget task \(i\)'s knowledge after updating \(^{l}\) for task \(j\). On the other hand, when \((^{l})>0\), the gradients of two tasks can enhance each other which encourages knowledge transfer across tasks .

We expand \((^{l})\) below. For simplicity, we calculate gradients related to the \(y_{i}\)-th and \(y_{j}\)-th class vectors in the matrix \(\):

\[(^{l};_{y_{i}},_{y_{j}})=p(y_{i}|_{i})-1p(y_{j}|_{j})-1} _{ 0}_{i}^{l-1} ^{T}_{j}^{l-1}}_{}_{y_{i}}^{T}^{l+1} _{y_{j}}}_{}.\] (1)

\(_{i}^{l-1}=_{x_{i}}^{l-1} _{x_{i}},\;\;l=2\\ _{i},\;\;l=1\) is the hidden representation at the (\(l\)-1)-th layer, \(^{l+1}=,\\ (^{l+1})^{T}^{l+1},\;l=2\\ (^{l+1})^{T}^{l+1},\;l=1\) is about the weight matrix at the (\(l\)+1)-th layer. The class vector \(_{y_{i}}^{d}\) is the \(y_{i}\)-th column of the classifier \(\), mapping the output representation to the space of class \(y_{i}\).

Based on Eq. 1, \((^{l})\) depends on the correlation between data's hidden representations at the (\(l\)-1)-th layer; and the correlation between class vectors transformed by weight matrices of the subsequent (e.g. (\(l\)+1)-th) layers. To address the interference issue, we discuss each correlation below.

**Correlations Between Hidden Representations** We consider correlations between different hidden representations at two time points (Fig. 2): (1) _The model has learned task \(i\) and is switching to learn task \(j\)_. At this time, the model's hidden representations of task \(j\)'s data should not destructively interfere with those of task \(i\)'s data, even though the model hasn't been trained for task \(j\) yet. (2) _After learning Task \(j\)_. At this time, the model should still produce good hidden representations for task \(i\)'s data, even though it no longer has access to task \(i\)'s training data.

Some previous works address the interference issue by forcing models to learn different tasks in orthogonal subspaces . However, they may constrain models' knowledge transfer ability as \((^{l})\) will always be zero. Other works minimize the destructive interference at time (2), by learning task \(j\) with the replay of task \(i\)'s data . However, if hidden representations do not correlate well when switching to task \(j\), they may cause and propagate interference in task \(j\)'s learning (Fig. 2 (a)). Then even with replay, representations of task \(i\)'s data may drift towards representations of task \(j\) data, leading to disruptive model updates .

Our work tackles correlations of hidden representations at both time points. When learning across tasks, the model is expected to produce _aligned_ hidden representations of both the current and previous tasks' data at all times. The _aligned_ representations should have appropriate correlations, which will not lead to destructive interference but retain the model's ability for knowledge transfer. To achieve this, we encourage the model to learn data representations for each task as different (task-specific) interpolations of pre-trained token representations. This then enables the correlations between data representations to be grounded by correlations between pre-trained token representations (details are in Section 4).

**Correlations Between Class Vectors** The interference also depends on correlations between class vectors. Assuming no shared classes in task \(i\) and \(j\), the class vector \(_{y_{i}}\) is not involved in learning task \(j\) and thus remains unchanged after task \(i\). When learning the class vector \(_{y_{j}}\) for task \(j\), we denote \(_{y_{j}}\) at the time step \(t\) as \(_{y_{j},t}\). Then the correlation between class vectors \(_{y_{i}}\) and \(_{y_{j},t}\) is:

\[_{y_{i}}^{T}_{y_{j},t}=_{y_{i}}^{T}_{y _{j},0}-_{y_{i}}^{T}_{t}_{_{y_{j }}}(_{j,t},y_{j}),\] (2)

where \(_{j,t}\) is the output data representation at time step \(t\), \(_{y_{j},0}\) is the initialization of the class vector \(_{y_{j}}\), \(\) is the learning rate.

Figure 2: T-SNE plots of all tasks’ data representations after learning the first (with classes _Village_, _Ahlete_) and last task. Under the vanilla sequential learning in (a), after the first task, representations of data from unseen tasks are overlapped. This may cause interference when switching tasks, which makes representations indistinguishable after learning the last task. With our global alignment model (Wire-Neigh) in (b), representations remain distinguishable after the first and last tasks.

In Eq. 2, the correlation of class vectors depends on the initialization of the class vector \(_{y_{j},0}\) and the learning of data representations \(_{j,t}\) (in the gradient \(_{_{y_{j}}}(_{j,t},y_{j})\)). The learning of the representation \(_{j,t}\) depends on the correlations between representations, which we have discussed above. In addition, we hypothesize that a good initialization of class vectors can help mitigate the interference problem. To obtain suitable initialization for class vectors, we apply the _probing then fine-tuning_ (PF) strategy  which first learns the class vectors (classifier) only and then fine-tune the whole model. We describe details in Section 4.

## 4 Methodology

In this section, we introduce our models that align data representations and initialize class vectors. First, we introduce our global alignment models which learn task data representations as interpolations of pre-trained token representations. Then we discuss the probing and then fine-tuning strategy and the effects of initializing the class vectors for CL.

### Data Representation as Interpolation of Pre-Trained Token Representations

#### Pre-trained Token Representations

In this paper, we focus on language models which are typically pre-trained in a self-supervised manner [11; 41]. For example, some models are pre-trained by the masked language modeling objective, which first masks tokens in input texts and then learns models to predict masked tokens. By pre-training, models learn semantic relationships between tokens.

We consider transformer-based  language models. Typically, for an arbitrary task1, the input of the model is a sequence of \(n\) tokens. At the \(l\)-th transformer layer, denote the input representations of all tokens as \(^{l-1}=[_{1}^{l-1},...,_{n}^{l-1}]^{T}\)\((l 1)\) where each token representation is an \(^{d}\) vector. Then the output token representation is:

\[^{l}=Attn(^{l-1}_{q}^{l},^{l-1} _{k}^{l})^{l-1}_{v}^{l},\] (3)

where \(_{q}^{l}\) and \(_{k}^{l}^{d d}\) are query and key matrices, \(Attn(,)=^{T}/ \) is a function calculating the attention matrix based on the query \(\) and key \(\). The initial token representation \(^{0}\) is the output of an embedding layer in the model. A feed-forward layer is applied after self-attention for token-wise transformation. We omit it here for simplicity.

After pre-training, we obtain contextual token representations \(^{l}\) at each layer \(l\) using the pre-trained matrices \(_{q}^{l}\), \(_{k}^{l}\) and \(_{v}^{l}\). Such token representations contain semantic information of input tokens, which are general enough to accommodate diverse uses in different downstream tasks. We refer to representations \(^{l}\) as _pretrained token representations_.

#### Data Representations

To address a downstream task, models learn a data representation that summarizes the task-specific information in the entire input. Typically, these data representations are learned by fine-tuning all parameters in the pre-trained model. This type of full fine-tuning has been shown to distort the pre-trained token representations  and may not consider correlations between data representations across tasks. This does not fit the alignment goal stated in Section 3.2.

To align data representations across tasks, we propose to wire (interpolate) the pre-trained token representations to construct the data representation. Our proposal is based on the following hypothesis:

_Task-specific information of data can be composed from the general semantics of tokens in that data._

For example, given the input text 'Some actors have so much _charisma_ that you'd be _happy_ to listen to them reading the phone book' from _'positive'_ class in a sentiment analysis task, a composition of tokens {charisma, happy} can convey the information of _'positive'_.

Based on the hypothesis and the fact that pre-trained token representations contain the information of general token semantics, appropriately interpolating pre-trained token representations can represent task-specific information in the data. Since correlations between pre-trained token representations are general across tasks, this type of composition aligns data representations from different tasks.

#### Alignment Effect

For an arbitrary task, the pre-trained token representations \(^{l}\) can be interpolated to yield the data representation at the \(l\)-th layer as: \(^{l}=^{l}^{l}^{T}\) where \(^{l}^{1 n}\) is a learnable stochastic row vector with weights for the interpolation. To assess the alignment effect of this scheme, we obtain the correlation between data representations \(_{i}^{l}\) and \(_{j}^{l}\) from task \(i\) and \(j\) as:

\[(_{i}^{l})^{T}_{j}^{l}=_{i}^{l}_{i}^{l}( _{j}^{l})^{T}(_{j}^{l})^{T},\] (4)

where \(_{i}^{l}\), \(_{j}^{l}\) are learned interpolations, \(_{i}^{l}\), \(_{j}^{l}\) are pre-trained token representations for data in task \(i\) and \(j\).

At any time step, the correlation between data representations is grounded by the correlation between pre-trained token representations: Eq. 4 involves the correlation \(_{i}^{l}(_{j}^{l})^{T}\) between pre-trained token representations; and the task-specific interpolation weights \(_{i}^{l}\), \(_{j}^{l}\) are also learned with the guidance of \(_{i}^{l}\) and \(_{j}^{l}\) respectively. This grounding to pre-trained token representations thus aligns the data representations across tasks.

### Global Alignment Models

We develop global alignment models to learn data representations as interpolations of pre-trained token representations. Parameters in models are trained by the cross-entropy loss for each task. Following common practice in traditional models, we append a [CLS] token to the input text and use the representation of [CLS] as the data representation, denoted as \(_{}^{l}\).

**Fixed Wiring** Applying the interpolation weights \(^{l}\) on pre-trained token representation \(^{l}\) generated by Eq. 3, we have \(^{l}^{l}=^{l}Attn(^{l-1}_{q} ^{l},^{l-1}_{k}^{l})^{l-1}_{k}^{l}\). Since the product of a stochastic row vector and a row-stochastic matrix is stochastic, \(^{l}Attn(^{l-1}_{q}^{l},^{l-1}_{k}^{l})\) can be viewed as task-specific attention on the pre-trained token representations \(^{l-1}\).

Based on this, we develop a _fixed wiring_ model that learns task-specific attention for [CLS] only, while using the pre-trained parameters to compute hidden representations of other tokens as the pre-trained representations \(\). In the model, the task-specific attention is calculated as the attention from [CLS]'s query, using a new learnable key matrix \(_{k}^{l}\) and the pre-trained query matrix \(_{q}^{l}\). Formally, the data representation \(_{}^{l}\) is:

\[(_{}^{l})^{T}=Attn((_{}^{l-1 })^{T}_{q}^{l},^{l-1}_{k}^{l})^ {l-1}_{v}^{l},\] (5)

where \(_{}^{0}\) is the pre-trained embedding of [CLS]. \(_{k}^{l}\) is low-ranked  for efficiency.

By constraining non-cls tokens' hidden representations to be close to the pre-trained token representations, the fixed-wiring model may have limited learning capacity. To avoid this, we design two other methods with improved model capacity, which we describe below.

**Wiring with Neighbor Attention** Sometimes, the task information may not be easy to extract from pre-trained representations of input tokens. For example, in a text entailment task, give a sentence pair 'The boy is crying; He's happy about the view.' with the label '_contradiction_'. The pre-trained representations of task-related tokens 'crying' and 'happy' may not be negatively correlated, which makes the model hard to learn their contradiction. However, 'crying' usually has a neighbor token'sad', and pre-trained representations of'sad' and 'happy' are more likely to have negative correlations. Therefore, using the information of'sad' may make the model easier to learn the task.

Therefore, to increase the model capacity while preserving its alignment ability, we retain the guidance of pre-trained token representations while exploring the tokens' neighborhood to better search for the

Figure 3: Comparison between alignment models. Modules in blue are pre-trained and in orange are learnable. Representations in grey are mainly adapted and in blue are close to the pre-trained ones. We specify hidden representations for [CLS] and any other token as \(_{}^{l}\) and \(_{}^{l}\).

task-specific information. The data representation can be written as:

\[(^{l}_{})^{T}=Attn((^{l-1}_{})^{T} ^{l}_{q},^{l-1}_{expand}^{l}_{k}) ^{l-1}_{expand}^{l}_{v},\] (6)

where \(_{expand}=[^{l-1};^{l-1}_{nei}]\) concatenates input tokens' pre-trained representations \(^{l-1}\) and their neighbors' representations \(^{l-1}_{nei}\).

Since each token has its own neighbors, to obtain the data representation \(^{l}_{}\) in Eq. 6, we first adapt each pre-trained token representation individually to incorporate task-specific information from their neighbors. Then we calculate task-specific attention on adapted token representations, using the attention mechanism in Eq. 5. Specifically, we adapt the \(p\)-th pre-trained token representation \(^{l}_{p}\) by:

\[(^{l}_{p})^{T}\,(1-s)(^{l}_{p})^{T}+s Attn ((^{l-1}_{p})^{T}^{l}_{q},^{l-1}_{nei,p} ^{l}_{k})^{l-1}_{nei,p}^{l}_{v},\]

where \(^{l-1}_{nei,p}^{k d}\) contains \(k\) neighbor representations for the \(p\)-th token, and \(^{0}_{nei,p}\) is the pre-trained embedding of the neighbor tokens. \(s\) is a scaling factor. The neighbor tokens are selected by comparing cosine similarities between token embeddings. To stay close to the pre-trained token representations but incorporate task-specific information, we update the neighbor representations as: \(^{l}_{nei,p}=(1-s)(^{l}_{p})+s Attn (^{l-1}_{nei,p}^{l}_{q},^{l-1}_{nei,p} ^{l}_{k})^{l-1}_{nei,p}^{l}_{v}\), where \((^{l}_{p})^{k d}\) is the matrix which duplicates \(^{l}_{p}\) for \(k\) tokens.

\(_{nei}\) provides extra capacity in learning data representations. Meanwhile, the alignment effect is preserved by controlling the scale \(s\), and making the neighborhood \(_{nei}\) not deviate far away from pre-trained token representations \(\).

Controlled-LoRAAnother way to increase the model capacity is to adapt representations of all tokens (including both [CLS] and other tokens in the text) by learning low-rank matrices added to the pre-trained query and value matrices (LoRA ). This has the model capacity close to fine-tuning, while keeping reference to the pre-trained parameters.

Denote the input representations of all tokens at layer \(l\) as \(^{l-1}\), where \(^{0}=^{0}\) is the pre-trained token embeddings. In LoRA, all token representations are updated by the same attention mechanism, with a learnable query and value matrices \(^{l}_{q}\) and \(^{l}_{v}\). The data representation \(^{l}_{}\) is:

\[(^{l}_{})^{T}=Attn((^{l-1}_{} )^{T}(^{l}_{q}+s^{l}_{q}),^{l-1} ^{l}_{k})^{l-1}(^{l}_{v}+s^ {l}_{v}).\] (7)

When \(s=0\), we have \(^{l}=^{l}\). When \(s>0\), the added query and value matrices not only learn the task-specific attention, but also adapt the token representations which can deviate away from the pre-trained ones. To keep alignment with pre-trained token representations, we control the scaling factor \(s\) to make adapted token representations close to the pre-trained ones.

### Initialization of Class Vectors

Although data representations are grounded by pre-trained token representations, at the start time of learning task \(j\) after task \(i\), the interpolation for task \(j\)'s data may not be well learned. In this case, properly initializing class vectors of classes in task \(j\) can help reduce interference.

To initialize the new class vectors when switching tasks, we adopt the _probing and then fine-tuning_ (PF) strategy first proposed in Kumar et al. : when learning a new task, it first freezes the encoder and only trains the classifier for the task (probing); and then tunes the encoder and classifier together (fine-tuning). This is beneficial in the case, for example, when the two tasks have similar input distributions but target different classes (e.g., news sentiment analysis vs. news categorization). In this case, data representations for two tasks may overlap when switching tasks. However, the class vectors can focus on different features in data representations after probing. Therefore, the correlation between class vectors may be small (or 0) and can reduce the interference.

## 5 Experiments

### Datasets and Metrics

We evaluate four sequences of CL tasks: (1) **Yahoo**: a split of Yahoo dataset for news question-answer categorization  with 5 disjoint tasks containing 2 classes each; (2) **DB**: a split of DBPedia data for Wikipedia article classification  with 7 disjoint tasks containing 2 classes each; (3) **News Series**: a sequence of tasks on news-related data, including AG_news (news classification, 4 classes), MRPC (paraphrase detection, 2 classes) , RTE (text entailment, 2 classes)  and SST (sentiment analysis, 2 classes) ; (4). **All**: All tasks in the above sequences. For each task, we randomly sample 1245 samples per class, which is the least number of class samples in our datasets.

We train alignment and adaptation models in task-incremental (Task-IL) settings, where in-task classes are specified during training. Then we evaluate models on both Task-IL and Class-IL inferences, where in-task classes are not specified for Class-IL inference . We measure models' average accuracy and forgetting (Appendix B) over five random seeds.

### Models

We compare different models on the pre-trained BERT-base model, including:

**Alignment Models (ours):** (1) _Wire-Fixed_: the model freezes pre-trained token representations and learns task-specific attention for data representations (i.e. [CLS] token). (2) _Wire-Neight_: the wiring model with neighbor attention. We set \(s=0.1\). For computation efficiency, we fix the number of neighbors as \(k=5\), and randomly select neighbors from top-\(K\) (\(K=20\)) nearest neighbors to control the range of neighborhood. (3) _C-LoRA_: the controlled LoRA model with the scaling factor \(s=0.1\). For both Wiring and C-LoRA models, we set the matrix rank \(r=8\). We also evaluate above models with the _probing then fine-tuning_ (PF) strategy, denoted as _Model+PF_.

**Adaptation Models:** (1) _Fine-tuning (FT)_: fine-tuning all parameters sequentially. (2) _Prefix Tuning (Prefix)_: freezing the pre-trained parameters and adding learnable embeddings to attention layers. (3) _Adapter_: freezing the pre-trained parameters and injecting learnable linear projections after self-attention. (4) _LoRA_: the LoRA model with suggested scaling \(s=1\) for single task learning.

**CL Models:** (1) _ER_: the FT model storing all seen examples and performs sparse (1%) experience replay. (2) _A-GEM_: the FT model constraining gradients to prevent degrading performance on previous tasks. (3) _MBPA++_: the FT model that stores and retrieves samples to locally adapt the model at inference time like . (4) _IDBR_: the FT model with information-disentanglement-based regularization and replay. We also compare to IDBR without replay, denoted as _IDBR(-R)_. (5) _CTR_: an adapter-based model with capsules and task transfer routing. (6) _L2P_: a prompt-based model that dynamically prompts for different data and tasks. (7) _CODA_: a prompt-based model that learns attention over extensive prompt components for tasks. (8). _ERACE_: a model for class-IL that calculates the current task's loss over in-task classes, while calculating the replay loss over all seen classes in the replay buffer. We also show the performance of _MTL_, which is an FT model jointly trained on all tasks (not CL). Detailed settings for models are shown in Appendix A.

    &  &  &  &  &  \\   & & \(ACC\) & _FGT\({}_{all}\)_ & \(ACC\) & _FGT\({}_{all}\)_ & \(ACC\) & _FGT\({}_{all}\)_ & \(ACC\) & _FGT\({}_{all}\)_ \\ 
**Classifier-only** & Probing & 88.43\({}_{ 0.05}\) & — & 99.30\({}_{ 0.05}\) & — & 74.81\({}_{ 0.16}\) & — & 89.84\({}_{ 0.16}\) & — \\ 
**Adaptation** & FT & 73.07\({}_{ 0.13}\) & 18.67\({}_{ 0.11}\) & 73.15\({}_{ 0.24}\) & 24.90\({}_{ 0.17}\) & 59.98\({}_{ 0.06}\) & 21.13\({}_{ 0.14}\) & 60.92\({}_{ 0.09}\) & 30.53\({}_{ 0.05}\) \\
**Models** & Adapter & 79.85\({}_{ 0.13}\) & 11.86\({}_{ 0.15}\) & 98.70\({}_{ 0.10}\) & 1.19\({}_{ 1.0}\) & 65.43\({}_{ 1.75}\) & 15.53\({}_{ 0.27}\) & 76.31\({}_{ 1.31}\) & 15.97\({}_{ 0.11}\) \\  & LoRA & 86.32\({}_{ 0.25}\) & 5.61\({}_{ 0.18}\) & 88.63\({}_{ 0.15}\) & 11.25\({}_{ 0.25}\) & 69.95\({}_{ 0.16}\) & 12.43\({}_{ 1.43}\) & 77.37\({}_{ 1.31}\) & 14.89\({}_{ 0.11}\) \\  & Prefix & 89.75\({}_{ 0.10}\) & 30.40\({}_{ 0.79}\) & 99.83\({}_{ 0.04}\) & 0.07\({}_{ 0.07}\) & 75.03\({}_{ 0.05}\) & 6.13\({}_{ 0.18}\) & 87.53\({}_{ 0.35}\) & 38.00\({}_{ 0.05}\) \\ 
**CL** & ER & 87.42\({}_{ 0.25}\) & 5.61\({}_{ 0.01}\) & 91.05\({}_{ 0.20}\) & 8.70\({}_{ 0.14}\) & 75.47\({}_{ 0.07}\) & 78.21\({}_{ 0.27}\) & 66.42\({}_{ 1.74}\) & 24.91\({}_{ 0.10}\) \\
**Models** & A-GEM & 89.43\({}_{ 0.05}\) & 2.95\({}_{ 0.04}\) & 94.71\({}_{ 0.03}\) & 5.98\({}_{ 0.04}\) & 75.90\({}_{ 0.04}\) & 6.60\({}_{ 0.04}\) & 71.60\({}_{ 0.15}\) & 19.40\({}_{ 0.15}\) \\  & MBPA++ & 89.65\({}_{ 0.20

[MISSING_PAGE_FAIL:9]

data representations are closed to pre-trained token representations the model aligns to. Results are shown in Table 2. From the table, decoded tokens of alignment models are close to tokens that are related to target classes, while those of non-alignment models (FT, LoRA) are hard to interpret.

We also quantify the model's alignment ability using E-SNLI data , where each data's task-related tokens are annotated by human. We calculate the Recall@20 of annotated task-related tokens being retrieved from data representations, on SNLI and News Series data. The results are shown in Table 3. Results suggest that wiring models have more alignment ability than C-LoRA, in both in-task (SNLI) and CL evaluations on similar NLI tasks (News Series).

This interpretability may explain the effectiveness of alignment models in Class-IL: even when trained with local classes, data representations in each task are correlated to pre-trained token representations that relate to all tasks' classes. This may help to separate representations from different tasks.

**Influence of Scaling Factor** We show Task-IL accuracies of different scaling factors \(s\) for Wire-Neigh and C-LoRA in Table 4. C-LoRA's CL performance tends to decrease when \(s\) increases. This may be due to the decrease of the global alignment effect, which increases the interference. After applying PF, C-LoRA's accuracy first increases and then slightly decreases. This may be because PF reduces the interference caused by the class vectors, and the model can fully utilize its global alignment ability when increasing plasticity. However, when the scaling factor goes too large, the loss of alignment will lead to more forgetting even with PF. For Wire-Neigh, the observation is similar to C-LoRA: when \(s\) goes up, the model's accuracy first increases and then decreases because of the trade-offs between global alignment and plasticity. And since Wire-Neigh interpolate pre-trained token representations with their neighbor representations, the increase of \(s\) leads to the decrease of pre-trained information. And therefore we observe a more rapid performance drop when \(s\) increases.

**Influence of Neighborhood** In Wire-Neigh, we randomly select five neighbor tokens from top-\(K\) nearest neighbors. Here we study the effect of the range of neighborhood with different \(K\) value in Table 5. For relatively simple sequences DB and Yahoo, Wire-Neigh under different \(K\) has stable performance. However, for hard sequence News Series, when \(K\) increases, the model has more neighbor information (more capacity) to solve the task, which first improves its CL performance. However, when \(K\) is too large (\(K=100\)), the neighbor information may become noisy, which makes the CL performance drop.

## 6 Limitation

We discuss our limitations in model and assumption perspectives: For models, without replaying previous data, there can be a problem of shifting attention; e.g. the model shifts attention on previous task-related tokens after learning new tasks. This may lead to forgetting, which we leave as our future study. For assumptions, our model assumes we have a pre-trained model. For domains that do not have well-established pre-trained semantic features, our model may not be immediately applicable. However, since fundamental models are consistently established and shown to be beneficial across different domains, we can expect our models to apply to more domains in the future.

## 7 Conclusion

In this paper, we investigate methods to address correlations between data representations and class vectors to reduce interference when training across tasks. Specifically, for alignment, we propose to learn data representations as task-specific compositions of pre-trained token representations. To learn the composed representations, we propose wiring models with or without neighbor attention and a controlled LoRA model. To address correlations between class vectors, we adopt the probing and then fine-tuning strategy, which can effectively reduce interference even when the representations do not correlate well. Experiments show that our models can successfully learn the composed representations for alignment and achieve SOTA performance in CL.

  
**Model** & \(s=0\) & 0.1 & 0.4 & 0.7 & 1.0 \\  Wire-Neigh & 76.28 & 77.10 & 72.59 & 68.18 & 66.59 \\ C-LoRA & 74.81 & 74.83 & 72.99 & 71.02 & 69.59 \\ +PF & 74.81 & 78.59 & 77.41 & 76.83 & 76.81 \\   

Table 4: Average _ACC_ with different \(s\) in C-LoRA, Wire-Neigh on News Series.

   \(K\) & **Yahoo** & **DB** & **News Series** \\ 
5 & 99.86 & 91.16 & 76.90 \\
20 & 99.86 & 90.98 & 77.10 \\
50 & 99.86 & 91.16 & 77.20 \\
100 & 99.87 & 91.13 & 76.58 \\   

Table 5: Average _ACC_ with different neighborhood range \(K\) in Wire-Neigh.