# Learning Multi-agent Behaviors from Distributed and Streaming Demonstrations

Shicheng Liu & Minghui Zhu

School of Electrical Engineering and Computer Science

Pennsylvania State University

University Park, PA 16802, USA

{sf15539,muz16}@psu.edu

###### Abstract

This paper considers the problem of inferring the behaviors of multiple interacting experts by estimating their reward functions and constraints where the distributed demonstrated trajectories are sequentially revealed to a group of learners. We formulate the problem as a distributed online bi-level optimization problem where the outer-level problem is to estimate the reward functions and the inner-level problem is to learn the constraints and corresponding policies. We propose a novel "multi-agent behavior inference from distributed and streaming demonstrations" (MA-BIRDS) algorithm that allows the learners to solve the outer-level and inner-level problems in a single loop through intermittent communications. We formally guarantee that the distributed learners achieve consensus on reward functions, constraints, and policies, the average local regret (over \(N\) online iterations) decreases at the rate of \(O(1/N^{1-_{1}}+1/N^{1-_{2}}+1/N)\), and the cumulative constraint violation increases sub-linearly at the rate of \(O(N^{_{2}}+1)\) where \(_{1},_{2}(1/2,1)\).

## 1 Introduction

Multi-agent systems (MASs) are an effective tool to model networked systems where multiple entities interact with each other to reach certain goals. Due to the lack of a centralized authority, the data in MASs is usually distributed . Therefore, distributed learning is desired for MASs where machine learning models are trained over distributed data sets. Current works on distributed learning include distributed supervised learning , distributed unsupervised learning , distributed reinforcement learning , etc. Recently, distributed learning is applied to learn the behaviors in MASs from distributed experts' demonstrations via inverse reinforcement learning (IRL) .

In IRL , a learner aims to learn a policy that imitates the expert behaviors in the demonstrations by first learning a reward function. Multi-agent IRL  extends IRL to MASs where the reward functions and policies of a group of experts are learned. However, current works on multi-agent IRL have the following two limitations: (i) As mentioned, the demonstration data in MASs is usually distributed while these works assume that there is a centralized learner which can obtain all the demonstrations. (ii) There are usually many underlying constraints in MASs, e.g., avoiding collision with each other and obstacles, and thus learning a reward function combined with a set of constraints is better than learning a single reward function in terms of explaining the experts' behaviors . Therefore, distributed inverse constrained reinforcement learning (D-ICRL)  is proposed where a group of learners cooperatively learn the behaviors in an MAS by estimating the experts' reward functions and constraints and each learner can only access a local demonstration set.

While D-ICRL performs over pre-collected distributed data, recent applications  of IRL motivate the need for algorithms that can learn from sequentially revealed demonstrations and continuously improve the learned models. For example, inferring a person's intent by observing herongooing daily routine  and updating evasion strategies by continuously observing the patrollers' behaviors . However, D-ICRL is not efficient to deal with streaming data because it has a double-loop learning structure where the outer loop is to update the constraints and the inner loop needs to find a corresponding reward estimate. While the computation overhead of this double-loop structure is reluctantly acceptable in offline settings, it is too time-consuming for streaming data since the computation may not be finished before the next data arrives. As D-ICRL is the most important baseline of our work, we include a section in Appendix to summarize our improvements from it.

**Related works and our improvements**. Current theoretical works on online IRL [20; 21] only consider linear reward functions and thus cast the problem as online convex optimization. While these approaches achieve sub-linear regret, their analysis does not hold for non-linear reward functions (e.g., neural networks) as the corresponding objective functions can be non-convex. To quantify the algorithmic performance on online non-convex optimization, "local regret" [22; 23] is proposed which, at each online iteration, quantifies the gradient norms of the average sum of some already-revealed loss functions. Current state-of-the-arts [22; 23] use follow-the-leader-based methods to minimize the local regret. While their methods can achieve the tight regret bound, the follow-the-leader-based methods require multiple gradient descent steps until reaching a near-stationary point at each online iteration. However, if the data arrival rate is fast, the computation may not be done before the next data arrives. To alleviate the computation burden at each online iteration, we use an online gradient descent (OGD) method which only updates the decision variable by one gradient descent step at each online iteration. To the best of our knowledge, no works can quantify the local regret of OGD.

Inspired by [9; 24], we formulate a distributed online bi-level optimization problem where the learners cooperatively learn the reward functions in the outer-level problem and the constraints and corresponding policies in the inner-level problem. Papers [9; 24; 25] use double-loop methods [26; 27; 28] to solve their bi-level optimization problems where they first find a (sub)optimal solution of the inner-level problem in a faster loop and then solve the outer-level problem in a slower loop. However, when it comes to streaming data, the double-loop method needs multiple steps for the inner-level problem before updating the decision variable of the outer-level problem, which can be too slow to finish the update of the outer decision variable when the data is revealed in a fast speed. Therefore, we use a single-loop method which updates both the outer and inner decision variable only once at each iteration. Notice that the state-of-the-arts on single-loop bi-level optimization [29; 30] cannot be directly applied to our problem because they are centralized and require the inner objective function to be strongly convex while our problem does not have these properties.

**Contribution statement**. Our contributions are threefold. First, we consider the problem where a group of learners cooperatively recover the policies by estimating the reward functions and constraints from distributed streaming demonstrations of cooperative experts. We formulate this "multi-agent behavior inference from distributed and streaming demonstrations" (MA-BIRDS) problem as a distributed online bi-level optimization problem. Second, we propose a novel distributed online gradient descent algorithm for the learners to learn the reward functions, constraints, and the corresponding policies in a single loop where the decision variables of both the outer-level and inner-level problems are updated only once at each online iteration. Third, we prove that the distributed learners achieve consensus in reward functions, constraints, and policies, respectively, at the rate of \(O(1/N^{_{1}}+^{N})\), \(O(1/N^{_{2}}+^{N})\), and \(O(1/N^{_{1}}+1/N^{_{2}}+^{N})\) where \((0,1)\) and \(_{1},_{2}(1/2,1)\). The local regret averaged over \(N\) iterations decreases at the rate of \(O(1/N^{1-_{1}}+1/N^{1-_{2}}+1/N)\) and the cumulative constraint violation grows sub-linearly at the rate of \(O(N^{_{2}}+1)\). Moreover, if the reward functions are linear, we prove that the average cumulative reward difference between the experts and learners diminishes at the rate of \(O(1/N^{1-_{1}}+1/N)\).

## 2 Model

This section presents the models of the experts and learners.

**Experts**. There are \(N_{E}\) experts whose decision making is modeled as a constrained Markov game (CMG) . A CMG \((,,,T,P_{0},P,r_{E},c_{E},b)\) consists of a state set \(_{i=1}^{N_{E}}^{(i)}\), an action set \(_{i=1}^{N_{E}}^{(i)}\), a discount factor \(\), a time horizon \(T\), and an initial state distribution \(P_{0}\). The state transition function is \(P\) and \(P(s^{}|s,a)\) represents the probability of transitioning to state \(s^{}\) from \(s\) by taking action \(a(a^{(1)},,a^{(N_{E})})\). Expert \(i\)'s reward function is \(r_{E}^{(i)}:\) and the experts are cooperative, i.e., \(r_{E}_{i=1}^{N_{E}}r_{E}^{(i)}\). The cost function of expert \(i\) is \(c_{E}^{(i)}(_{E}^{(i)})^{}^{(i)}\) where \(^{(i)}:[0,d_{1}]^{t^{(i)}}\) is an \(l^{(i)}\)-dimensional cost feature vector, \(d_{1}\) is a bounded constant, and \(_{E}^{(i)}_{+}^{l^{(i)}}\) is the weight. The cost function of all the experts is \(c_{E}_{i=1}^{N_{E}}c_{E}^{(i)}\). Expert \(i\)'s policy \(_{E}^{(i)}(a^{(i)}|s)\) represents the probability of expert \(i\) taking action \(a^{(i)}\) at state \(s\) and the joint policy of all the experts is \(_{E}(a|s)_{i=1}^{N_{E}}_{E}^{(i)}(a^{(i)}|s)\). We define \(J_{r_{E}}() E_{S,}^{E}[_{t=0}^{T}^{t}r_{E}(S _{t},A_{t})]\) as the expected cumulative reward under policy \(\) where the initial state is drawn from \(P_{0}\) and \(J_{c_{E}}() E_{S,}^{}[_{t=0}^{T}^{t}c_{E }(S_{t},A_{t})]\) as the expected cumulative cost. The experts' policy \(_{E}\) wants to maximize \(J_{r_{E}}()\) subject to \(J_{c_{E}}() b\) where \(b\) is the budget. Following , we study hard constraints (i.e., \(b=0\)). These experts use \(_{E}\) to demonstrate \(N_{L}\) trajectories \(\{^{[v]}(n)\}_{v=1}^{N_{L}}\) at each online iteration \(n\) where each trajectory \(^{[v]}(n) s_{0}^{[v]}(n),a_{0}^{[v]}(n),,s_{N}^{[v]}(n),a_{ T}^{[v]}(n)\) is a state-action sequence of all the experts. This distributed online data style can also be found in .

**Learners**. There are \(N_{L}\) learners where each learner \(v\) knows \((,T,\{^{(i)}\}_{i=1}^{N_{E}},^{[v]}(n))\) and \(^{[v]}(n)\) is a demonstration observed by learner \(v\) at online iteration \(n\). Each learner wants to use communications to learn the cost functions by estimating \(_{E}[(_{E}^{(1)})^{},,(_{E}^{(N_{E})})^ {}]^{}\) and reward functions using parameterized models \(\{r_{^{(i)}}^{(i)}\}_{i=1}^{N_{E}}\) where \(^{(i)}^{d^{(i)}}\) is \(d^{(i)}\)-dimensional. Here we relax the linear reward assumption in  but keep its linear cost assumption because non-linear cost functions can make the problem ill-defined (explained in Appendix).

**Assumption 1**.: _The reward function \(r_{}\) satisfies the following: \(|r_{}(s,a)| C\), \(||_{}r_{}(s,a)||\), and \(||_{}^{2}r_{}(s,a)||\) for any \((s,a)\) and any \(\) where \(C\), \(\), and \(\) are positive constants._

Notice that Assumption 1 is standard in RL .

The communication network is modeled as a time-varying directed graph \((n)(,(n))\) where \(\{1,,N_{L}\}\) is the node (learner) set and \((n)\) is the set of directed edges (communication links) at time \(n\). The edge \((v,v^{})(n)\) means that learner \(v\) receives information from learner \(v^{}\) at time \(n\) and \((v,v)(n)\) for all \(n 0\). The adjacency matrix of the graph at time \(n\) is \(W(n)[W^{[vv^{}]}(n)]_{v,v^{}} ^{N_{L} N_{L}}\) where \(W^{[vv^{}]}(n)=0\) if and only if \((v,v^{})(n)\). The set of neighbors of learner \(v\) at time \(n\) is \(^{[v]}(n)\{v^{}|(v,v^{}) (n)\}\).

**Assumption 2**.: _There exists an integer \(B 1\) such that the graph \((,(n)(n+B-1))\) is strongly connected for all \(n 0\)._

**Assumption 3**.: _The adjacency matrix \(W(n)\) has the following properties: (i) \(^{}W(n)=^{}\) and \(W(n)=\) where \(\) is the column vector whose entries are all ones. (ii) There is an \((0,1)\) such that \(W^{[vv]}(n)\) for all \(v\) and \(W^{[vv^{}]}(n)\) if \((v,v^{})(n)\)._

Notice that these two assumptions are standard in distributed learning .

Figure 1 shows that the learners stand outside the MAS observing the sequential data revealed by the experts and collaboratively learn the reward functions and constraints. Each learner aims to learn the reward functions and constraints of all the experts where \(^{[v]}\) and \(^{[v]}\) are the reward and cost function parameter estimates of all the experts learned by learner \(v\).

**Notions and Notations**. Define \([(^{(1)})^{},,(^{(N_{E})})^{}]^{}\) and \(r_{}_{i=1}^{N_{E}}r_{^{(i)}}^{(i)}\). We use \(^{[v]}\) to represent learner \(v\)'s learned \(\). Therefore, the dimension of each \(^{[v]}\) is \(_{i=1}^{N_{E}}d^{(i)}\). Given a trajectory \(=s_{0},a_{0},,s_{T},a_{T}\), the empirical cumulative reward under \(r_{}\) is \(_{r_{}}()_{t=0}^{T}^{t}r_{}(s_{t},a_{ t})\), the empirical cumulative cost feature is defined as \(()_{t=0}^{T}^{t}(s_{t},a_{t})\) where \([(^{(1)})^{},,(^{(N_{E})})^{}]^{}\). The expectation of cumulative cost feature under a given policy \(\) is \(() E_{S,A}^{}[_{t=0}^{T}^{t}(S_{t},A_{t})]\) and the expectation of cumulative reward \(r_{}\) under a

Figure 1: Relation between experts and learners

given policy \(\) is \(J_{r_{}}() E_{S,A}^{}[_{t=0}^{T}^{t}r_{}(S_{ t},A_{t})]\). The set of all stochastic policies is \(\) where every \(\) satisfies \((a|s) 0\) for any \((s,a)\) and \(_{a}(a|s)da=1\) for any \(s\).

## 3 Problem Formulation

In MA-BIRDS, the learners collaboratively learn the experts' policy \(_{E}\) by estimating the reward function \(r_{E}\) and cost function \(c_{E}\), and each learner \(v\) does not share its private data such as local trajectory \(^{[v]}\) and local estimates \(_{r_{}}(^{[v]})\) and \((^{[v]})\). While it seems that learning a well-structured reward function is enough to prevent "bad" movements by assigning negative reward, we include a section (in Appendix) to further discuss the benefits of learning both reward and cost functions.

Many IRL works [9; 11; 24; 377 ] have a bi-level learning structure where the outer level is to learn a reward function and the inner level is to learn a corresponding policy by solving an RL problem under the current learned reward function. Inspired by their bi-level structure, we formulate a bi-level optimization problem where the outer level is to learn a reward function \(r_{}\) and the inner level is to find the cost function and policy corresponding to \(r_{}\). In what follows, we first define the inner-level optimization problem and then introduce the bi-level optimization problem.

**The inner-level optimization**. Given a learned reward function \(r_{}\), the corresponding policy \(_{r_{}}\) is the optimal solution of the following constrained RL problem where the reward function is \(r_{}\):

\[_{r_{}}=*{arg\,max}_{}\,H()+J_{r_{ }}(),()=}_{v=1}^{N_{L}}(^{[v]}(n)) },\] (1)

where \(H()_{t=0}^{T}E_{S,A}[-^{t}(A_{t}|S_{t})]\) is causal entropy . The constraint in problem (1) is cost feature expectation matching similar to the spirit of "feature expectation matching" in [11; 38].

However, the policy \(_{r_{}}\) is hard to get because problem (1) is non-convex. A standard way to tackle this difficulty is dual methods , therefore, we introduce the dual function of problem (1): \(G(;,n)_{}H()+J_{r_{}}()+ ^{}(()-}_{v=1}^{N_{L}}(^{[v]}(n)))\) where the dual variable \(\) is used to estimate \(_{E}\). Notice that the dual function \(G(;,n)\) is convex in \(\).

**Lemma 1**.: _The optimal solution of problem (1) is the constrained soft Bellman policy \(_{^{*}(,n);}\) and its parameter \(^{*}(,n)\) is the optimal solution of the **dual problem**\(_{}G(;,n)\)._

The expression of constrained soft Bellman policy is in Appendix. Lemma 1 shows that \(_{^{*}(,n);}=_{r_{}}\) and \(^{*}(,n)=*{arg\,min}_{}G(;,n)\). Therefore, we can solve problem (1) by solving its dual problem. We use the dual problem to be the inner-level problem where \(^{*}(,n)\) is the learned cost function and \(_{^{*}(,n);}\) is the learned policy corresponding to the current learned reward function \(r_{}\).

**The bi-level optimization**. Given a reward function \(r_{}\), the inner-level problem \(*{arg\,min}_{}G(;,n)\) can find the corresponding cost function and policy. The outer level aims to learn \(r_{}\) via minimizing the following loss function over \(\):

\[L(,^{*}(,n),n),^{*}(,n)= *{arg\,min}_{}G(;,n),\] (2)

where \(L(,^{*}(,n),n)-_{v=1}^{N_{L}}_{t=0}^{T} ^{t}_{^{*}(,n);}(a_{t}^{[v]}(n)|s_{t}^{[v]}(n))\) is the negative log likelihood of the trajectories \(\{^{[v]}(n)\}_{v=1}^{N_{L}}\) received at time \(n\) under the policy \(_{^{*}(,n);}\)[9; 40] and \(^{[v]}(n)=\{(s_{t}^{[v]}(n),a_{t}^{[v]}(n))\}_{0 t T}\). The likelihood function is widely used in IRL [92; 40] to learn the reward function.

Notice that (2) requires all the demonstrations \(\{^{[v]}(n)\}_{v=1}^{N_{L}}\) at time \(n\). However, each learner \(v\) can only observe \(^{[v]}(n)\) and formulate its local negative log likelihood function \(L^{[v]}(,^{*}(,n),n)-_{t=0}^{T}^{t} _{^{*}(,n);}(a_{t}^{[v]}(n)|s_{t}^{[v]}(n))\) and local dual function \(G^{[v]}(;,n)_{}H()+J_{r_{}}()+ ^{}(()-(^{[v]}(n)))\). Notice that \(L=_{v=1}^{N_{L}}L^{[v]}\) and \(G=}_{v=1}^{N_{L}}G^{[v]}\).

As the demonstrations are streaming, we have a sequence of loss functions \(\{L(,^{*}(,n),n)\}_{n 1}\). We use this sequence of loss functions to formulate an online learning problem and a common problem for online learning is to minimize the regret: \(_{n=1}^{N}L((n),^{*}((n),n),n)-_{n=1}^{N}L(^{*}, ^{*}(^{*},n),n)\)which quantifies the difference of the accumulative losses between the learned parameter \(\) and the best parameter \(^{*}\) in hindsight. However, it is too challenging to minimize the regret in our case because \(L\) is non-convex . Therefore, we use local regret [22; 23] which is widely used in online non-convex optimization. It quantifies the general stationarity of a sequence of loss functions. In specific, given a sequence of loss functions \(\{f(,n)\}_{n 1}\), the local regret [22; 23] at online iteration \(n\) is defined as \(||_{i=0}^{l-1} f(x(n),n-i)||^{2}\) which quantifies the gradient norms of the average of \(l\) previously received loss functions under the current learned parameter \(x(n)\). The total local regret is defined as the sum of the local regret at every online iteration \(n\), i.e., \(_{n=1}^{N}||_{i=0}^{l-1} f(x(n),n-i)||^{2}\). In our case, we replace \(f\) with our loss function (2) and thereby formulate the local regret (3)-(4) which has a distributed bi-level formulation. We want to minimize the local regret (3)-(4).

\[_{n=1}^{N}||_{i=0}^{l-1}_{v=1}^{N_{L}}  L^{[v]}((n),^{*}((n),n),n-i)||^{2},\] (3) \[~{}^{*}((n),n)=_{}_{v=1 }^{N_{L}}G^{[v]}(;(n),n).\] (4)

The time window length is \(1 l N\) and \(L^{[v]}(,,i)=0\) if \(i 0\). The outer-level problem (3) is to learn the reward parameter \(\) and the inner-level problem (4) is to learn the cost parameter \(\) given \(\). The learned policy is the constrained soft Bellman policy \(_{;}\) with parameters \((,)\).

## 4 Algorithm and Performance Guarantee

This section consists of two subsections where the first one introduces an approximation method to solve the bi-level optimization problem (3)-(4) in a single loop and the second one introduces a consensus-based method for the multiple learners to solve the problem in a distributed way.

### Approximation-based single-loop method

In this part, we develop an approximation-based single-loop method which (i) does not use the exact gradient of the outer-level problem (3) but an approximation of the gradient; (ii) solves the outer-level and inner-level problems in a single loop. In the following analysis, for simple notations, we omit the time index \(n\) and imply that the analysis holds for all \(n\).

**Lemma 2**.: _The problem \(_{}G(;)\) has a unique optimal solution \(^{*}()\) for any \(\)._

Since the inner-level problem (4) is unconstrained and \(^{*}()\) is its optimal solution, then we have \(_{}G(^{*}();)=0\). Taking derivative with respect to \(\) on both sides renders:

\[_{}^{2}G(^{*}();)+_{}^{ 2}G(^{*}();)^{*}()=0 ^{*}()=-M(,^{*}())^{},\]

where \(M(,)_{}^{2}G(;)[_{ }^{2}G(;)]^{-1}\). Then, using the chain rule, we have:

\[ L(,^{*}())=_{}L(,^{*}( ))-M(,^{*}())_{}L(,^{*}( )).\] (5)

At online iteration \(n\), an intuitive way to solve the bi-level optimization problem (3)-(4) is to solve it in a double-loop way [9; 26; 28]. In specific, the double-loop method first solves the inner-level problem (4) to find a close approximation of \(^{*}()\) and then uses the obtained result to get the gradient (5), thus solving the outer-level problem (3). However, it requires multiple gradient descent for the inner-level problem (4) to get \(^{*}()\) before updating the decision variable of the outer-level problem where each gradient descent of the inner-level problem needs to solve a constrained RL problem in our case. Therefore, the double-loop method is not suitable to be an online algorithm when the data is revealed in a fast speed. To design an algorithm suitable for the online fashion, we adopt the spirit of [29; 30] and solve the outer-level and inner-level problems in a single loop. However, our method is not a simple extension of [29; 30] to online settings because they are centralized and require the inner objective function to be strongly convex but our problem does not have these properties.

In specific, at each online iteration, the decision variables of both the outer-level and inner-level problems update only once where the gradient of the inner objective function is given in Lemma 3. For the outer-level problem, as \(^{*}()\) is inaccessible, we cannot get the exact gradient defined in (5). Therefore, we propose the finding gradient approximation whose derivation can be found in Appendix: \(L(,)=N_{L}E_{S,A}^{_{,}}[_{t=0}^{T} ^{t}_{}r_{}(S_{t},A_{t})]-_{v=1}^{N_{L}}_{ }_{r_{}}(^{[v]})\), where \(_{;}\) is the constrained soft Bellman policy with parameters \((,)\). Compared to (5), this gradient approximation does not include the second-order term \(M(,)\) and thus is much more computationally efficient. It is shown in Appendix that the approximation error \(|| L(,^{*}())-L(,)|| C_{ }||^{*}()-||\) where \(C_{}\) is a positive constant whose expression is in Appendix. Intuitively, as the inner decision variable \(\) approaches \(^{*}()\) in the learning process, this gradient approximation error can be sufficiently small.

**Lemma 3**.: _The gradient of \(G^{[v]}(;)\) is \((_{;})-(^{[v]})\) where \(_{;}\) is the constrained soft Bellman policy with parameters \((,)\)._

**Lemma 4**.: _The global likelihood function \(L(,)\) is \(C_{L}\)-Lipschitz continuous and \(_{L}\)-smooth in \((,)\), where \(C_{L}\) and \(_{L}\) are positive constants._

### Consensus-based distributed learning

In our distributed learning setting, each learner \(v\) only knows its local information (e.g., \(L^{[v]}\) and \(G^{[v]}\)), so that it cannot directly solve the problem (3)-(4). Therefore, each learner \(v\) updates the decision variables using the gradients of its local outer-level and inner-level objective functions and uses communications to collaboratively solve the problem (3)-(4). Similar to the global gradient approximation \(L(,)\), learner \(v\) has its local gradient approximation: \(L^{[v]}(,)=E_{S,A}^{_{,}}[_{t=0}^{ T}^{t}_{}r_{}(S_{t},A_{t})]-_{}_{r_{ }}(^{[v]})\). Learner \(v\) uses samples to estimate \(L^{[v]}(,)\) via \(L^{[v]}(,)}_{j=1}^{m^{[ v]}}_{}_{r_{}}(^{[v]})-_{}_{r_{ }}(^{[v]})\) where \(^{j}\) is generated by rolling out \(_{;}\) and \(m^{[v]}\) is the number of the samples. Moreover, learner \(v\) also uses the same samples to estimate \( G^{[v]}(;)\) in Lemma 3 via \(G^{[v]}(;)}_{j=1}^{m^{[ v]}}(^{j})-(^{[v]})\).

```
0:\(\{^{[v]}(1)\}_{v=1}^{N_{L}},\{^{[v]}(1)\}_{v=1}^{N_{L}},W(n)\)
0:\(^{[v]}(N),^{[v]}(N),_{^{[v]}(N);^{[v]}(N)},  v\)
1:for\(n=1,,N\)do
2:for\(v\)do
3: Finds policy \(_{^{[v]}(n);^{[v]}(n)}\) using soft Q-learning  or soft actor-critic .
4: Simulates samples \(\{^{j}\}_{j=1}^{m^{[v]}}\) using \(_{^{[v]}(n);^{[v]}(n)}\).
5: Receives \(^{[v^{}]}(n),^{[v^{}]}(n)\) from the neighbors \(v^{}^{[v]}(n)\) and observes \(^{[v]}(n)\).
6:\(^{[v]}(n+1)=_{v^{}=1}^{N_{L}}W^{[vv^{}]}(n)^{[v^{ }]}(n)-_{i=0}^{l-1}G^{[v]}(^{[v ]}(n);^{[v]}(n),n-i)\)
7:\(^{[v]}(n+1)=_{v^{}=1}^{N_{L}}W^{[vv^{}]}(n)^{[v^{ }]}(n)-_{i=0}^{l-1}L^{[v]}(^{[v ]}(n),^{[v]}(n),n-i)\)
8:endfor
9:endfor ```

**Algorithm 1** Multi-agent behavior inference from distributed and streaming demonstrations

In Algorithm \(1\), at online iteration \(n\), each learner \(v\) sequentially executes the following two steps: (i) uses current reward and cost function parameters to get the corresponding policy and generate samples (Lines \(3\)-\(4\)); (ii) communicates with neighbors and updates its parameters for both outer-level and inner-level problems in a single loop using the samples generated in last step (Lines \(5\)-\(7\)). In the update process (Lines \(6\)-\(7\)), the first term (convex combination) encourages consensus among different learners and the second term (gradient) drives to the set of stationary points. Notice that even though soft Q-learning and soft actor-critic are designed for unconstrained RL, as shown in Appendix, we can revise them to approximate the constrained soft Bellman policy.

**Theorem 1**.: _Suppose Assumptions 1, 2, 3 hold. Let the step sizes \((n)=}{n^{3}}\) and \((n)=}{n^{3}}\) where \(_{1},_{2}(,1)\) and \(,(0,(2C_{L}+1)})\), then for any \(v,v^{}\) in Algorithm \(1\): (consensus): \(||^{[v]}(N)-^{[v^{}]}(N)|| O(}}+ ^{N})\), \(||^{[v]}(N)-^{[v^{}]}(N)|| O(}}+^{N})\), and \(_{(s,a)}\{|_{^{[v]}(N);^{[v]}(N )}(a|s)-_{^{[v^{}]}(N);^{[v^{}]}(N)}(a|s)|\} O( }}+}}+^{N}))\), where \(_{(s,a)}\{\}\) outputs the supremum value over \(\) and the expression of \((0,1)\) can be found in Appendix. (decreasing average local regret): \(_{n=1}^{N}E||_{i=0}^{l-1} L(^{[v ]}(n),^{[v]}(n),n\ -\ i)||^{2} O(}}+}}+ {N})+)^{2}}{l}\)._

_(sub-linear cumulative constraint violation): \(_{n=1}^{N}EJ_{c_{E}}^{2}(_{^{[v]}(n),^{[v]}(n)})  O(N^{_{2}}+1)\), where the expectation is taken over randomly demonstrated trajectories at each online iteration._

Theorem 1 shows that the learners will achieve consensus on the reward and cost function parameters, and policy. The average local regret decreases to an upper bound \(2(C_{L})^{2}/l\). Notice that this upper bound has similar property with that in [22; 23]: (i) they are both less that the uniform upper bound \(C_{L}^{2}\) of the global loss function \(L\) when \(l>2\); (ii) they are both diminishing if \(l\) is dependent on \(n\) and \(l(n)=(1)\). The number of total outer gradient steps taken by each learner in Algorithm \(1\) is \(O(N)\) which is smaller than \(O(2Nl+l^{2})\) in  and \(O(Nl^{2})\) in . The reason of fewer gradient steps in Algorithm \(1\) is that it is an online gradient descent algorithm, which does not require multiple gradient calls at each online iteration as follow-the-leader-based methods [22; 23] do.

Moreover, if the reward functions are linear as in [20; 21], we have the following stronger result:

**Corollary 1**.: _If the reward functions are linear, the average difference of cumulative reward between the learned policy and expert policy diminishes: \(_{n=1}^{N}E(J_{r_{E}}(_{^{[v]}(n);^{[v]} (n)})-J_{r_{E}}(_{E}))^{2} O(}}+)\) for any \(v\)._

## 5 Simulations

This section shows that Algorithm 1 is effective to both discrete and continuous environments. We use four centralized baselines for comparisons: (i) **Behavior inference from centralized and streaming demonstrations (BICS)**: This is the centralized counterpart of MA-BIRDS where a central learner obtains all the demonstrations at each online iteration. (ii) **Follow the leader (FTL)**: This method  uses a follow-the-leader-based method to solve online non-convex optimization problems where a (near)-stationary solution of the sum of all the previous loss functions is found at each online iteration. As this method only solves single-level optimization problems, we revise it to a single-loop method to solve bi-level optimization problems. (iii) **Double-loop method (DLM)**: This method extends D-ICRL  to online centralized settings where the inner-level problem is first solved and then the result is used to solve the outer-level problem. At each online iteration, DLM only updates the decision variable of the outer-level problem once. (iv) **ME-greedy**: This method is an online extension of  which assumes the access to the ground truth reward and uses a greedy method to estimate the constraints based on maximum entropy (ME) IRL .

### Evasion from patrolled area

We consider the evader-patroller setting (Figure 1(a)) introduced in . The experts (E1 and E2) are the patrollers patrolling around the area and they aim to switch their positions. They have four actions (i.e., moving up, down, left, and right) and need to avoid collisions with each other and the obstacles (i.e., constraints). The experts are programmed to follow the optimal policy. The learners (L1 and L2) are the evaders who want to learn the behavior model of the experts in order to reach the goal G without being caught. The red crosses in Figure 2 represent the constraints and each state is colored according to the scaled visitation frequency.

Figure 1(b) shows the results learned by Algorithm \(1\) (each learner recovers the same constraints). Two constraints are not recovered as the experts' policy will not change even these constraints are absent. Three constraints are falsely learned because the experts (optimal policy) do not visit those states but the learned policy (constraint soft Bellman policy) have a high chance of visiting the states if the

Figure 2: Evader-patroller environment.

states are not prohibited as the constrained soft Bellman policy has non-zero probability of choosing any action and this probability can be large if the corresponding action is not heavily penalized.

To reason about the performance of our algorithm, we use four metrics: false positive rate (FPR), false negative rate (FNR), constraint violation rate (CVR), and success rate (SR). The FPR , is the proportion of learned constraints that are not the ground truth constraints, FNR is the proportion of the ground truth constraints that are not learned, CVR introduced in  is the percentage of the learned policy violating any constraint, and SR is the percentage of the learned policy reaching the destinations and avoiding collisions.

Figure 3 shows that Algorithm \(1\) is on par with and even outperforms the baselines even if it is distributed and does not have the access to the ground truth reward. For the baselines, the centralized learners receive two demonstrations at each online iteration. We can see that the gradient-based methods (i.e., MA-BIRDS, BICS, FTL, and DLM) have much better performance than the greedy-based method (i.e., ME-greedy). The reason is that the greedy-based method can only learn one constraint at each online iteration while the gradient-based methods can learn multiple constraints at each online iteration because the gradient-based methods update \(\) which works on all the possible constraints indicated by the cost feature vector \(\).

Table 1 shows the final results after the \(40\) demonstrations are revealed. Notice that even if the gradient-based methods have different results in FPR and FNR, they achieve similar performance in CVR and SR. The reason is that the different constraints they learn will not affect the learned policy as those constraints are either blocked by other constraints or occupy the states that the experts will barely visit (as shown in Figure 1(b)).

Moreover, to show that MA-BIRDS is suitable for online learning when the streaming data arrives at a fast speed, we propose the following three metrics: scaled time per online iteration (STPOI), \(50\%\) SR scaled time (\(50\%\) ST), and \(90\%\) SR scaled time (\(90\%\) ST). The STPOI is the scaled time that an algorithm needs to finish the computation of an online iteration, \(50\%\) ST is the scaled time that an algorithm needs to reach \(50\%\) SR, and \(90\%\) ST is the scaled time to reach \(90\%\) SR. We use scaled time instead of actual time because actual time varies a lot on different

   & D & NATR & FPR & FNR & CVR & SR \\   & L1 & ✓ & ✓ & \(0.053 0.008\) & \(0.013 0.013\) & \(0.040 0.010\) & \(0.960 0.010\) \\   & L2 & ✓ & ✓ & \(0.053 0.008\) & \(0.013 0.013\) & \(0.045 0.015\) & \(0.955 0.015\) \\   & \(\) & ✓ & \(0.038 0.019\) & \(0.013 0.013\) & \(0.040 0.005\) & \(0.960 0.005\) \\   & \(\) & ✓ & \(0.047 0.009\) & \(0.032 0.032\) & \(0.030 0.010\) & \(0.970 0.010\) \\  DLM & \(\) & ✓ & \(0.050 0.009\) & \(0.022 0.022\) & \(0.015 0.005\) & \(0.985 0.005\) \\  ME-greedy & \(\) & \(\) & \(0.019 0.000\) & \(0.753 0.000\) & \(1.000 0.000\) & \(0.000 0.000\) \\  

Table 1: Performance comparisons. Here, D means distributed and NATR means no access to the (ground truth) rewards.

   & STPOI & \(50\%\) ST & \(90\%\) ST \\  L1 & \(1.000\) & \(1.000\) & \(1.000\) \\  L2 & \(1.000\) & \(1.000\) & \(1.000\) \\  BICS & \(1.157\) & \(1.155\) & \(1.158\) \\  FTL & \(7.500\) & \(3.753\) & \(5.769\) \\  DLM & \(7.482\) & \(3.740\) & \(7.481\) \\  ME-greedy & \(63.615\) & \(>318.075\) & \(>97.869\) \\  

Table 2: Computation time comparisons.

Figure 3: Algorithm performance. The L1 and L2 are the distributed learners in MA-BIRDS.

hardwares and different problems. The time is scaled in the way that the fastest algorithm has scaled time \(1.000\).

Table 2 shows that MA-BIRDS and BICS are much faster than the baselines in each online iteration, and thus are more suitable for the online setting with fast streaming data. The MA-BIRDS is slightly faster than BICS in each online iteration because the centralized learner needs to process two new demonstrations at each online iteration while each distributed learner only needs to process one. Moreover, we can see that MA-BIRDS achieves \(50\%\) and \(90\%\) SR with the shortest time.

### Drone motion planning with obstacles

In this example, we analyze MA-BIRDS on a real-world problem with continuous state and action spaces introduced in . We build a simulator in Gazebo (Figure 3(a)) where we (humans) control the two drones to their diagonal doors while avoiding collisions. We reveal each of the four learners one demonstration at each online iteration. In this experiment, the learners are the computers recording the demonstrations of the experts (humans) controlling the drones. As the state and action spaces are continuous, the potential constraints can also be continuous. Therefore, we cannot use the metrics FPR and FNR, and we cannot use the baseline ME-greedy. As ME-greedy is designed for discrete state-action space, we replace it with ME-gradient  which extends ME-greedy to continuous settings where a cost function is learned using a gradient-based method. Similar to ME-greedy, ME-gradient is centralized and assumes access to the ground truth reward. Figure 3(b) shows the learned constraints on which the learners reach consensus and the trajectories of the learned policy. Each of the four trajectories is generated by one of the four learners L1-L4. Each trajectory consists of the paths of the two drones (i.e., a red path and a blue path).

Table 3, together with Table 2, shows that MA-BIRDS and BICS can reach the same good performance with the baselines and use much shorter time or have fewer requirements. In specific, compared to FTL , MA-BIRDS only requires about \(20\%\) of the time to reach the same performance and is more than six times faster in each iteration. Compared to DLM , MA-BIRDS only requires about \(15\%\) of the time to reach the same performance and is also more than six times faster in each iteration. Compared to ME-gradient, MA-BIRDS can reach the same performance within the same amount of time even if it is distributed and has no access to the ground truth reward.

## 6 Discussion and future work

We propose MA-BIRDS, the first IRL framework that is effective in learning multi-agent behaviors from distributed and streaming demonstrations under continuous and discrete environments. We formulate a distributed online bi-level optimization problem and propose a fast distributed online gradient descent single-loop algorithm with theoretical guarantees that is suitable to online settings.

Figure 4: Drone motion planning with obstacles.

   & D & NATR & CVR & SR & STPOI & \(50\%\) ST & \(90\%\) ST \\  L1 & ✓ & ✓ & \(0.025 0.025\) & \(0.974 0.025\) & 1.000 & 1.000 & 1.000 \\  L2 & ✓ & ✓ & \(0.030 0.010\) & \(0.970 0.010\) & 1.000 & 1.000 & 1.000 \\  L3 & ✓ & ✓ & \(0.025 0.025\) & \(0.973 0.025\) & 1.000 & 1.000 & 1.000 \\  L4 & ✓ & ✓ & \(0.025 0.025\) & \(0.972 0.015\) & 1.000 & 1.000 & 1.000 \\  BICS & \(\) & ✓ & \(0.015 0.015\) & \(0.979 0.020\) & 1.029 & 1.025 & 1.027 \\  FTL & \(\) & ✓ & \(0.015 0.010\) & \(0.981 0.018\) & 10.481 & 7.860 & 5.240 \\  DLM & \(\) & ✓ & \(0.020 0.015\) & \(0.975 0.015\) & 9.658 & 6.767 & 6.837 \\  ME-gradient & \(\) & \(\) & \(0.013 0.013\) & \(0.980 0.018\) & 1.013 & 1.010 & 1.012 \\  

Table 3: Performance and computation time comparisons (drone motion planning).

Experimental results show that MA-BIRDS is effective in both continuous and discrete environments. Despite its benefits, one limitation is the assumption of linear cost functions. We will explore approaches to relax this assumption in the future.

**Potential negative social impact**. Since MA-BIRDS can infer the experts' behaviors, potential negative social impact may occur if the learners are malicious. Take the evader-patroller setting as an example; the patrollers could be safeguards or park rangers, and the evaders could be poachers. The malicious poachers may use MA-BIRDS to escape. To avoid this situation, the experts should take additional strategies such as regularly demonstrating misleading behaviors so that MA-BIRDS will learn a wrong behavior model of the experts.

## 7 Acknowledgements

This work is partially supported by the National Science Foundation through grants ECCS 1846706 and CNS 1830390. We would like to thank the reviewers for their insightful and constructive suggestions.