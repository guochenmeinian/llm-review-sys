# Quantile Activation: departing from single point estimation for better generalization across distortions

Quantile Activation: departing from single point estimation for better generalization across distortions

Anonymous Author(s)

Affiliation

Address

email

###### Abstract

A classifier is, in its essence, a function which takes an input and returns the class of the input and implicitly assumes an underlying distribution. We argue in this article that one has to move away from this basic tenet to obtain generalization across distributions. Specifically, the class of the sample should depend on the points from its _"context distribution"_ for better generalization across distributions. _How does one achieve this?_ - The key idea is to "adapt" the outputs of each neuron of the network to its context distribution. We propose quantile activation,QAct, which, in simple terms, outputs the _relative quantile_ of the sample in its context distribution, instead of the actual values in traditional networks.

The scope of this article is to validate the proposed activation across several experimental settings, and compare it with conventional techniques. For this, we use the datasets developed to test robustness against distortions - CIFAR10C, CIFAR100C, MNISTC, TinyImagenetC, and show that we achieve a significantly higher generalization across distortions than the conventional classifiers, across different architectures. Although this paper is only a proof of concept, we surprisingly find that this approach outperforms DINOv2(small) at large distortions, even though DINOv2 is trained with a far bigger network on a considerably larger dataset.

## 1 Introduction

Deep learning approaches have significantly influenced image classification tasks on the machine learning pipelines over the past decade. They can easily beat human performance on such tasks by non-trivial margins by using innovative ideas such as Batch Normalization  and other normalization techniques [3; 31], novel rectifiers such as ReLU/PReLU [26; 31; 3] and by using large datasets and large models.

However, these classification systems do not generalize across distributions [2; 34], which leads to instability when used in practice.  shows that deep networks with ReLU activation degrades in performance under distortions.  observes that there exists a feature collapse which inhibits the networks to be reliable.

Fundamental Problem of Classification:We trace the source of the problem to the fact that - _Existing classification pipelines necessitates single point prediction_, i.e., they should allow classification of a single sample given in isolation. We argue that, for good generalization, one should move away from this basic tenet and instead allow the class to be dependent on the _"context distribution"_ of the sample. That is, when performing classification, one needs to know both the sample and the context of the sample for classification.

While this is novel in the context of classification systems, it is widely prevalent in the specific domain of Natural Language Processing (NLP) - The meaning of a word is dependent on the context of the word. However, to our knowledge, this has not been considered for general classification systems. Even when using dominant NLP architectures such as Transformers for vision , the technique has been to split the image into patches and then obtain the embedding for an individual image.

Obtaining a classification framework for incorporating context distribution:We suspect that the main reason why the context distribution is not incorporated into the classification system is - The naive approach of considering a lot of samples in the pipeline to classify a single sample is computationally expensive. We solve this problem by considering the context distribution of each neuron specifically. We introduce _Quantile Activation_ (QAct), which outputs a probability depending upon the context of _all_ outputs. This, however, gives rise to new challenges in training, which we address in section 2.

Figure 1 illustrates the differences of the proposed framework with the existing framework. As severity increases (w.r.t Gaussian Noise), we observe that ReLU activation loses the class structure. This behaviour can be attributed to the fact that, as the input distribution changes, the activations either increase/decrease, and due to the multiplicative effect of numerous layers, this leads to very different features. On the other hand, the proposed QAct framework does not suffer from this, since if all the pre-activations1 change in a systematic way, the quantiles _adjust_ automatically to ensure that the inputs for the next layer does not change by much. This is reflected in the fact that class structure is preserved with QAct.

Remark:Quantile activation is different from existing quantile neural network based approaches, such as regression , binary quantile classification , Anomaly Detection . Our approach is achieving best in-class performance by incorporating context distribution in the classification paradigm. Our approach is also markedly different from Machine unlearning which is based on selective forgetting of certain data points or retraining from scratch .

Contributions:A decent amount of literature on neuronal activation is available. However, to the best of our knowledge, none matches the central idea proposed in this work.

In , the authors propose an approach to calibrate a pre-trained classifier \(f_{}()\) by extending it to learn a _quantile function_, \(Q(,,)\) (\(\) denotes the quantile), and then estimate the probabilities using \(_{}I[Q(,,) 0.5]d^{2}\). They show that this results in probabilities which are robust to distortions.

1. In this article, we extend this approach to the level of a neuron, by suitably deriving the forward and backward propagation equations required for learning (section 2).
2. We then show that a suitable incorporation of our extension produces context dependent outputs at the level of each neuron of the neural network.

Figure 1: Comparing TSNE plots of QAct and ReLU activation on CIFAR10C with Gaussian distortions. Observe that QAct maintains the class structure extremely well across distortions, while the usual ReLU activations loses the class structure as severity increases.

3. Our approach contributes to achieving better generalization across distributions and is more robust to distortions, across architectures. We evaluate our method using different architectures and datasets, and compare with the current state-of-the-art - DINOv2. We show that QAct proposed here is more robust to distortions than DINOv2, even if we have considerably less number of parameters (22M for DINOv2 vs 11M for Resnet18). Additionally, DINOv2 is trained on 20 odd datasets, before being applied on CIFAR10C; in contrast, our framework is trained on CIFAR10, and produces more robust outcome (see figures 3,5).
4. The proposed QAct is consistent with all the existing techniques used in DINOv2, and hence can be easily incorporated into any ML framework.
5. We also adapt QAct to design a classifier which returns better calibrated probabilities.

Related Works on Domain Generalization (DG):The problem of domain generalizations tries to answer the question - Can we use a classifier trained on one domain across several other related domains? The earliest known approach for this is _Transfer Learning_[28; 37], where a classifier from a single domain is applied to a different domain with/without fine-tuning. Several approaches have been proposed to achieve DG, such as extracting domain-invariant features over single/multiple source domains [11; 1; 9; 29; 16], Meta Learning [17; 9], Invariant Risk Minimization . Self supervised learning is another proposed approach which tries to extract features on large scale datasets in an unsupervised manner, the most recent among them being DINOv2 . Very large foundation models, such as GPT-4V, are also known to perform better with respect to distribution shifts . Nevertheless, to the best of our knowledge, none of these models incorporates context distributions for classification.

## 2 Quantile Activation

Rethinking Outputs from a Neuron:To recall - if \(\) denotes the input, a typical neuron does the following - (i) Applies a linear transformation with parameters \(w,b\), giving \(w^{t}+b\) as the output, and (ii) applies a rectifier \(g\), returning \(g(w^{t}+b)\). Typically, \(g\) is taken to be the ReLU activation - \(g_{relu}(x)=(0,x)\). Intuitively, we expect that each neuron captures an "abstract" feature, usually not understood by a human observer.

An alternate way to model a neuron is to consider it as predicting a latent variable \(\), where \(=1\) if the feature is present and \(=0\) if the feature is absent. Mathematically, we have the following model:

\[=w^{t}+b+ and=I[ 0]\] (1)

This is very similar to the standard latent variable model for logistic regression, with the main exception being, the _outputs \(\) are not known_ for each neuron beforehand. If \(\) is known, it is rather easy to obtain the probabilities - \(P( 0)\). Can we still predict the probabilities, even when \(\) itself is a latent variable?

The authors in  propose the following algorithm to estimate the probabilities:

1. Let \(\{_{i}\}\) denote the set of input samples from the input distribution \(\) and \(\{z_{i}\}\) denote their corresponding latent outputs, which would be from the distribution \(\)
2. Assign \(=1\) whenever \(>(1-)^{th}\) quantile of \(\), and \(0\) otherwise. For a specific sample, we have \(y_{i}=1\) if \(z_{i}>(1-)^{th}\) quantile of \(\{z_{i}\}\)
3. Fit the model \(Q(x,;)\) to the dataset \(\{((_{i},),y_{i})\}\), and estimate the probability as, \[P(y_{i}=1)=_{=0}^{1}I[Q(x,;) 0.5]d\] (2)

The key idea:Observe that in step 2., the labelling is done without resorting to actual ground-truth labels. This allows us to obtain the probabilities on the fly for any set of parameters, only by considering the quantiles of \(\).

Defining the Quantile Activation QActLet \(\) denote the pre-activation of the neuron, and let \(\{_{i}\}\) denote the samples from this distribution. Let \(F_{}\) denote the cumulative distribution function (CDF), and let \(f_{}\) denote the density of the distribution. Accordingly, we have that \(F_{}^{-1}()\) denotesthe \(^{th}\) quantile of \(\). Using step (2) of the algorithm above, we define,

\[()=_{=0}^{1}I[>F_{}^{-1}(1-)]d }{}{}}}}_{=0}^ {1}I[>F_{}^{-1}()]d\] (3)

**Computing the gradient of QAct:** However, to use QAct in a neural network, we need to compute the gradient which is required for back-propagation. Let \(_{}\) denote the quantile at which \(F_{}^{-1}(_{})=\). Then we have that \(()=_{z}\) since \(F_{}^{-1}()\) is an increasing function. So, we have that \((F_{}^{-1}())=\). In other words, we have that \(()\) is \(F_{}()\), which is nothing but the CDF of \(\). Hence, we have,

\[()}{ z}=f_{}()\] (4)

where \(f_{}()\) denotes the density of the distribution.

**Grounding the Neurons:** With the above formulation, observe that since QAct is identical to CDF, it follows that, \(()\) is always a uniform distribution between \(0\) and \(1\), irrespective of the distribution \(\). When training numerous neurons in a layer, this could cause all the neurons to learn the same behaviour. Specifically, if, half the time, a particular abstract feature is more prevalent than others, QAct (as presented above) would not be able to learn this feature. To correct this, we _enforce that positive values and negative values have equal weight_. Given the input distribution \(\), We perform the following transformation before applying QAct. Let

\[^{+}=& 0\\ 0&^{-}= &<0\\ 0&\] (7)

denote the truncated distributions. Then,

\[^{}=^{+}&0.5\\ ^{-}&0.5\] (8)

From definition of \(^{}\), we get that the median of \(^{}\) is \(0\). This grounds the input distribution to have the same positive and negative weight.

Dealing with corner cases:It is possible that during training, some neurons either only get positive values or only get negative values. However, for smooth outputs, one should still only give the weight of \(0.5\) for positive values. To handle this, we include two values \(c\) (large positive) and \(-c\) (large negative) for each neuron. Since, the quantiles are conventionally computed using linear interpolation, this allows the outputs to vary smoothly. We take \(c=100\) in this article.

Estimating the Density for Back-Propagation:Note that the gradient for the back propagation is given by the density of \(^{}\) (weighted distribution). We use the _Kernel Density Estimation_ (KDE), to estimate the density. We, (i) First sample \(N\) points with weights \(w_{+},w_{-}\), and (ii) then estimate the density at all the input points \([_{i}]\). This is point-wise multiplied with the backward gradient to get the gradient for the input. In this article we use \(N=1000\), which we observe gets reasonable estimates.

Computational Complexity:Computational Complexity (for a single neuron) is majorly decided by 2 functions - (i) Computing the quantiles has the complexity for a vector \([_{i}]\) of size \(n\) can be performed in \((n(n))\). Since this is log-linear in \(n\), it does not increase the complexity drastically compared to other operations in a deep neural network. (ii) Computational complexity of the KDE estimates is \((Sn_{})\) where \(S\) is the size of sample (weighted sample from \([_{i}]\)) and \(n_{}\) is the number of quantiles, giving a total of \((n+Sn_{})\). In practice, we consider \(S=1000\) and \(n_{}=100\) which works well, and hence does not increase with the batch size. This too scales linearly with batch size \(n\), and hence does not drastically increase the complexity.

Remark:Algorithms 1, and 2 provide the pseudocode for the quantile activation. For stable training, in practice, we prepend and append the quantile activation with BatchNorm layers.

Why QAct is robust to distortions?To understand the idea behind quantile activation, consider a simple toy example in figure 2. For ease of visualization, assume that the input features (blue) are in 2 dimensions, and also assume that the line of the linear projection is given by the red line in figure 1(a). Now, assume that the blue input features are rotated, leading to a different distribution (indicated here by orange). Since activations are essentially (unnormalized) signed distances from the line, we plot the histograms corresponding to the two distributions in figure 1(b). As expected, these distributions are different. However, after performing the quantile activation in equation 3, we have that both are uniform distribution. This is illustrated in figures 1(c) and 1(d). This behaviour has a normalizing effect across different distributions, and hence has better distribution generalization than other activations.

Figure 2: Intuition behind quantile activation. (a) shows a simple toy distribution of points (blue), it’s distortion (orange) and a simple line (red) on which the samples are projected to obtain activations. (b) shows the distribution of the pre-activations. (c) shows the distributions of the activations with QAct of the original distribution (blue). (d) shows the distributions of the activations with QAct under the distorted distribution (orange). Observe that the distributions match perfectly under small distortions. Note that even if the distribution matches perfectly, the quantile activation is actually a deterministic function.

Training with QAct

In the previous section, we described the procedure to adapt a single neuron to its context distribution. In this section we discuss how this extends to the Dense/Convolution layers, the loss functions to train the network and the inference aspect.

Extending to standard layers:The extension of equation 3 to dense outputs is straightforward. A typical output of the dense layer would be of the shape \((B,N_{c})\) - \(B\) denotes the batch size, \(N_{c}\) denotes the width of the network. The principle is - _The context distribution of a neuron is all the values which are obtained using the same parameters._ In this case, each of the values across the '\(B\)' dimension are considered to be samples from the context distribution.

For a convolution layer, the typical outputs are of the form - \((B,N_{c},H,W)\) - \(B\) denotes the size of the batch, \(N_{c}\) denotes the number of channels, \(H,W\) denotes the sizes of the images. In this case we should consider all values across the 1st,3rd and 4th dimension to be from the context distribution, since all these values are obtained using the same parameters. So, the number of samples would be \(B H W\).

Loss Functions:One can use any differentiable loss function to train with quantile activation. We specifically experiment with the standard Cross-Entropy Loss, Triplet Loss, and the recently proposed Watershed Loss  (see section 4). However, if one requires that the boundaries between classes adapt to the distribution, then learning similarities instead of boundaries can be beneficial. Both Triplet Loss and Watershed Loss fall into this category. We see that learning similarities does have slight benefits when considering the embedding quality.

Inference with QAct:As stated before, we want to assign a label for classification based on the context of the sample. There exist two approaches for this - (1) One way is to keep track of the quantiles and the estimated densities for all neurons and use it for inference. This allows inference for a single sample in the traditional sense. However, this also implies that one would not be able to assign classes based on the context at evaluation. (2) Another way is to make sure that, even for inference on a single sample, we include several samples from the context distribution, but only use the output for a specific sample. This allows one to assign classes based on the context. In this article, we follow the latter approach.

Quantile Classifier:Observe that the proposed QAct (without normalization) returns the values in \(\) which can be interpreted as probabilities. Hence, one can also use this for the classification layer. Nonetheless, two changes are required - (i) Traditional softmax used in conjunction with negative-log-likelihood loss already considers "relative" activations of the classification in normalization. However, QAct does not. Hence, one should use Binary-Cross-Entropy loss with QAct, which amounts to one-vs-rest classification. (ii) Also, unlike a neuron in the middle layers, the bias of the neuron in the classification layer depends on the class imbalance. For instance, with \(10\) classes, one would have only \(1/10\) of the samples labelled \(1\) and \(9/10\) of the samples labelled \(0\). To address this, we require that the median of the outputs be at \(0.9\), and hence weight the positive class with \(0.9\) and the negative class with \(0.1\) respectively. In this article, whenever QAct is used, we use this approach for inference.

We observe that (figures 13 and 14) using quantile classifier on the learned features in general improves the consistency of the calibration error and also leads to the reducing the calibration error. In this article, for all networks trained with quantile activation, we use quantile classifier to compute the accuracies/calibration errors.

## 4 Evaluation

To summarize, we make the following changes to the existing classification pipeline - (i) Replace the usual ReLU activation with QAct and (ii) Use triplet or watershed loss instead of standard cross entropy loss. We expect this framework to learn context dependent features, and hence be robust to distortions. (iii) Also, use quantile classifier to train the classifier on the embedding for better calibrated probabilities.

Evaluation Protocol:To evaluate our approach, we consider the two datasets developed for this purpose - CIFAR10C, CIFAR100C, TinyImagenetC , MNISTC. These datasets have a set of 15 distortions at 5 severity levels. To ensure diversity we evaluate our method on 4 architectures - (overparametrized) LeNet, ResNet18 (11M parameters), VGG(15M parameters) and DenseNet (1M parameters). The code to reproduce the results can be found at https://anonymous.4open.science/r/QuantAct-2B41.

Baselines for Comparison:To our knowledge, there exists no other framework which proposed classification based on context distribution. So, for comparison, we consider standard ReLU activation , pReLU , and SELU  for all the architectures stated above. Also, we compare our results with DINOV2 (small)  (22M parameters) which is current state-of-the-art for domain generalization. Note that for DINOV2, architecture and datasets used for training are substantially different (and substantially larger) from what we consider in this article. Nevertheless, we include the results for understanding where our proposed approach lies on the spectrum. We consider the small version of DINOV2 to match the number of parameters with the compared models.

Metrics:We consider four metrics - Accuracy (ACC), calibration error (ECE)  (both marginal and Top-Label) and mean average precision at \(K\) (MAP@K) to evaluate the embedding. For the case of ReLU/pReLU/SELU activation with Cross-Entropy, we use the logistic regression trained on the train set embeddings, and for QAct we use the calibrated linear classifier, as proposed above. We do not perform any additional calibration and use the probabilities. We discuss a selected set of results in the main article. Please see appendix C for more comprehensive results.

Calibration error measures the reliability of predicted probabilities. In simple words, if one predicts 100 samples with (say) probability 0.7, then we expect 70 of the samples to belong to class \(1\) and the rest to class \(0\). This is measured using either the marginal or top-label calibration error. We refer the reader to  for details, which also provides an implementation to estimate the calibration error.

Remark:For all the baselines we use the standard Cross-Entropy loss for training. For inference on corrupted datasets, we retrain the last layer with logistic regression on the train embedding and evaluate it on test/corrupted embedding. For QAct, we as a convention use watershed loss unless otherwise stated, for training. For inference, we train the Quantile Classifier on the train embedding and evaluate it on test/corrupted embedding.

The proposed QAct approach is robust to distortions:In fig. 3 we compare the proposed QAct approach with predominant existing pipeline - ReLU+Cross-Entropy and DINOV2(small) on CIFAR10C. In figure 2(a) we see that as the severity of the distortion increases, the accuracy of ReLU and DINOV2 drops significantly. On the other hand, while at small distortions the results are comparable, as severity increases QAct performs substantially better than conventional approaches.

Figure 3: Comparing QAct with ReLU activation and DINOV2 (small) on CIFAR10C. We observe that, while at low severity of distortions QAct has a similar accuracy as existing pipelines, at higher levels the drop in accuracy is substantially smaller than existing approaches. With respect to calibration, we observe that the calibration error remains constant (up to standard deviations) across distortions.

At severity \(5\), QAct outperforms DINOv2. On the other hand, we observe that in figure 2(b), the calibration error stays consistent across distortions.

How much does QAct depend on the loss function?Figure 3(a) compares the watershed classifier with other popular losses - Triplet and Cross-Entropy. We see that all the loss functions perform comparably when used in conjunction with QAct. We observe that watershed has a slight improvement when considering MAP and hence, we consider that as the default setting. However, we point out that QAct is compatible with several loss functions as well.

QAct vs ReLU/pReLU/SELU activations:To verify that most existing activations do not share the robustness property of QAct, we compare QAct with other activations in figures 3(b) and 3(c). We observe that QAct is greatly more robust with respect to distortions in both accuracy and calibration error than other activation functions.

Results on Larger Datasets:To verify that our observations hold for larger datasets, we use CIFAR100C/ TinyImagenetC to compare the proposed QAct+watershed with existing approaches. We observe on figure 5 that QAct performs comparably well as DINOv2, although DINOv2(s) has 22M parameters and is trained on significantly larger datasets. Moreover, we also observe that

Figure 4: (a) Dependence on Loss functions. Here we compare watershed with other popular loss functions – Triplet and Cross-Entropy when used with QAct. We see that watershed performs slightly better with respect to MAP. (b) Comparing QAct with other popular activations – ReLU/pReLU/SELU with respect to accuracy. (c) Comparing QAct with other popular activations – ReLU/pReLU/SELU with respect to Calibration Error (Marginal). From both (b) and (c) we can conclude that QAct is notably more robust across distortions than several of the existing activation. All the plots use ResNet18 with CIFAR10C dataset.

Figure 5: Results on CIFAR100C/ TinyImagenetC. We compare QAct+watershed to ReLU and DinoV2 small on CIFAR100C/ TinyImagenetC dataset with ResNet18. Note that the observations are consistent with CIFAR10C. (a) shows how accuracy changes across distortions. Observe that QAct is similar to DINOv2(s) with respect to embedding quality across all distortions, even if DINOv2 has 22M parameters as compared to Resnet18 11M parameters and is trained on larger datasets. (b) shows how calibration error (marginal) changes across severities. While other approaches lead to an increase in calibration error, QAct has similar calibration error across distortions.

QAct has approximately constant calibration error across distortions, as opposed to a significantly increasing calibration error for ReLU or DINOv2.

## 5 Conclusion And Future Work

To summarize, traditional classification systems do not consider the "context distributions" when assigning labels. In this article, we propose a framework to achieve this by - (i) Making the activation adaptive by using quantiles and (ii) Learning a kernel instead of the boundary for the last layer. We show that our method is more robust to distortions by considering MNISTC, CIFAR10C, CIFAR100C, TinyImagenetC datasets across varying architectures.

The scope of this article is to provide a proof of concept and a framework for performing inference in a context-dependent manner. We outline several potential directions for future research:

1. The key idea in our proposed approach is that the quantiles capture the distribution of each neuron from the batch of samples, providing outputs accordingly. This poses a challenge for inference, and we have discussed two potential solutions: (i) remember the quantiles and density estimates for single sample evaluation, or (ii) ensure that a batch of samples from the same distribution is processed together. We adopt the latter method in this article. An alternative approach would be to _learn the distribution of each neuron_ using auxiliary loss functions, adjusting these distributions to fit the domain at test time. This gives us more control over the network at test time compared to current workflows.
2. Since the aim of the article was to establish a proof-of-concept, we did not focus on scaling, and use only a single GPU for all the experiments. To extend it to multi-GPU training, one needs to synchronize the quantiles across GPU, in a similar manner as that for Batch-Normalization. We expect this to improve the statistics, and to allow considerably larger batches of training.
3. On the theoretical side, there is an interesting analogy between our quantile activation and how a biological neuron behaves. It is known that when the inputs to a biological neuron change, the neuron adapts to these changes . Quantile activation does something very similar, which leads to an open question - can we establish a formal link between the adaptability of a biological neuron and the accuracy of classification systems?
4. Another theoretical direction to explore involves considering distributions not just at the neuron level, but at the layer level, introducing a high-dimensional aspect to the problem. The main challenge here is defining and utilizing _high dimensional quantiles_, which remains an open question .

Broad Impact:In this article, we propose an approach to maintain calibration and generalization across small distortions. While, we do not foresee any direct societal consequences of our work, we expect the potential future consequences of the technique to reduce the bias in the following ways - (i) Since we do not assume normal distribution, our approach is likely to handle long tails better than existing methods. This would help in reducing the dataset bias where marginal groups are less represented. (ii) Note that the output of each QAct layer is a uniform distribution. This can allow us to understand the working of each layer in isolation and possibly reduce the black-box nature of the current classification systems. (iii) Moreover, by directly modifying the context distribution of each neuron, one can easily make the networks more reliable without resorting to expensive re-training the entire network.