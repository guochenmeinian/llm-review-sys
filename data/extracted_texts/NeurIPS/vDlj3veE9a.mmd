# The Space Complexity of Approximating Logistic Loss

Gregory Dexter

LinkedIn Corporation

gdexter@linkedin.com

&Petros Drineas

Department of Computer Science

Purdue University

pdrineas@purdue.edu

&Rajiv Khanna

Department of Computer Science

Purdue University

rajivak@purdue.edu

###### Abstract

We provide space complexity lower bounds for data structures that approximate logistic loss up to \(\)-relative error on a logistic regression problem with data \(^{n d}\) and labels \(\{-1,1\}^{d}\). The space complexity of existing coreset constructions depend on a natural complexity measure \(_{}()\), first defined in . We give an \((})\) space complexity lower bound in the regime \(_{}()=(1)\) that shows existing coresets are optimal in this regime up to lower order factors. We also prove a general \((d_{}())\) space lower bound when \(\) is constant, showing that the dependency on \(_{}()\) is not an artifact of mergeable coresets. Finally, we refute a prior conjecture that \(_{}()\) is hard to compute by providing an efficient linear programming formulation, and we empirically compare our algorithm to prior approximate methods.

## 1 Introduction

Logistic regression is an indispensable tool in data analysis, dating back to at least the early 19th century. It was originally used to make predictions in social science and chemistry applications , but over the past 200 years it has been applied to all data-driven scientific domains, from economics and the social sciences to physics, medicine, and biology. At a high level, the (binary) logistic regression model is a statistical abstraction that models the probability of one of two alternatives or classes by expressing the log-odds (the logarithm of the odds) for the class as a linear combination of one or more predictor variables.

Formally, logistic regression aims to find a parameter vector \(^{d}\) that minimizes the logistic loss, \(()\), which is defined as follows:

\[()=_{i=1}^{n}(1+e^{-_{i}^{T} }),\] (1)

where \(^{n d}\) is the data matrix (\(n\) points in \(^{d}\), with \(_{i}^{T}\) being the rows of \(\)) and \(\{-1,1\}^{n}\) is the vector of labels whose entries are the \(_{i}\). Due to the central importance of logistic regression, algorithms and methods to improve the efficiency of minimizing the logistic loss are always of interest .

The prior study of linear regression, a much simpler problem that admits a closed-form solution, has provided ample guidance on how we may expect to improve the efficiency of logistic regression. Letus first consider how a data structure that approximates \(_{2}\)-regression loss may be leveraged to design efficient algorithms for linear regression. Let \(():^{d}\) be a data structure such that:

\[(1-)\|-\|_{2}()(1+ )\|-\|_{2}.\]

Then, for, say, any \((0,}{{3}})\)

\[}=*{argmin}_{^{d}}()\|}- \|_{2} _{^{d}}\|-\|_{2}\] \[(1+3)_{^{d}}\| -\|_{2}.\]

That is, a data structure that approximates the \(_{2}\)-regression loss up to \(\)-relative error may be used to solve the original regression problem up to \(3\)-relative error. This is particularly interesting when \(()\) has lower _space_ complexity than the original problem or can be minimized more efficiently.

Practically efficient data structures satisfying these criteria for linear regression have been instantiated through matrix sketching and leverage score sampling . There is extensive work exploring constructions of a matrix \(^{s n}\), where given a data matrix \(^{n d}\) and vector of labels \(^{n}\), we may solve the lower dimensional problem \(}=*{argmin}_{^{d}}\| -\|_{2}\) to achieve the guarantee \(\|}-\|_{2}_{^{d}}\|-\|_{2}\) for a chosen \(>0\). Under conditions that guarantee that \(s n\), we can achieve significant _computational time and space savings_ by following such an approach. An important class of matrices \(^{s n}\) that guarantee the above approximation are the so-called \(_{2}\)-subspace embeddings which satisfy:

\[(1-)\|-\|_{2}\|(- )\|_{2}(1+)\|-\|_{2}\ \ ^{d}.\]

Despite the central importance of logistic regression in statistics and machine learning, relatively little is known about how the method behaves when matrix sketching and sampling are applied to its input. Munteanu et al. [10; 11] initiated the study of _coresets_ for logistic regression. Meanwhile, Munteanu and Omlor  provide the current state-of-the-art bounds bounds on the size of a coreset for logistic regression. Analogously to linear regression, these works present an efficient data structure \(}()\) such that

\[(1-)()}()(1+) ().\] (2)

We call \(}()\) an _\(\)-relative error approximation_ to the logistic loss. Prior work on coreset construction for logistic regression critically depends on the data complexity measure \(_{}()\), which was first introduced in , and is defined as follows.

**Definition 1**.: _(Classification Complexity Measure ) For any \(^{n d}\) and \(\{-1,1\}^{n}\), let_

\[_{}()=_{}_{ })^{+}\|_{1}}{\|(_{} )^{-}\|_{1}},\]

_where \(_{}\) is a diagonal matrix with \(\) as its diagonal, and \((_{})^{+}\) and \((_{})^{-}\) denote the positive and the negative entries of \(_{}\) respectively._

Specifically, these methods construct a coreset by storing a subset of the rows indexed by \(\{1 n\}\) such that \(||=}(}()}{ ^{2}})\) and generating a set of weights \(\{w_{i}\}_{i}\) such that each \(w_{i}\) is specified by \(( nd)\) bits . The approximate logistic loss is then computed as:

\[}()=_{i}w_{i}(1+e^{-_{i}_{i}^{}})\] (3)

is an \(\)-relative error approximation to \(()\). We see that \(_{}()\) is important in determining how compressible a logistic regression problem is through coresets, and prior has proven this dependency in coresets is necessary . Our work further shows this dependency is fundamental to the space complexity of approximating logistic loss by any data structure.

Our work advances understanding of data structures that approximate logistic loss to reduce its space and time complexity. Our results provide guidance on how existing coreset constructions may be improved upon as well as their fundamental limitations.

### Our contributions

We briefly summarize our contributions in this work; see Section 1.3 for notation.

* We prove that any data structure that approximates logistic loss up to \(\)-relative error must use \((})\) space in the worst case on a dataset with constant \(\)-complexity (Theorem 1).
* We show that any coreset that provides an \(\)-relative error approximation to logistic loss requires storing \((})\) rows of the original data matrix \(\) (Corollary 2). Thereby, we prove that analyses of existing coreset constructions are optimal up to logarithmic factors in the regime where \(_{}()=(1)\).
* We prove that _any_ data structure that approximates logistic loss to relative error must take \((d_{}())\) space, thereby showing that the dependency on the \(\)-complexity measure is not an artifact of using mergeable coresets which the prior work  had relied on (Theorem 3).
* We provide experiments that demonstrate how prior methods that only approximate \(_{}()\) can be substantially inaccurate, despite being more complicated to implement than our method (see Section 4).
* Finally, we prove that low rank approximations can provide a simple but weak additive error approximation to logistic loss and these guarantees are tight in the worst case (See Appendix D).

### Related Work

Prior work has explored the space complexity of data structures that preserve \(\|\|_{p}\) for \(^{d}\), particularly in the important case where \(p=2\). Lower bounds for this problem are analogous to our work and motivate our inquiry. An early example of such work is , which lower bounds the minimum dimension of an "oblivious subspace embedding", a particular type of data structure construction that preserves \(\|\|_{2}\). A more recent example in this line of work is , which provides space complexity lower bounds for general data structures that preserves \(\|\|_{p}\) for general \(p\).

Recent work on the development of coresets for logistic regression motivates our focus on this problem. This line of work was initiated by Munteanu et al. . Mai et al.  used Lewis weight sampling to achieve an \(}(d_{}()^{2}^{-2})\). The work of Woodruff and Yasuda  later provided an online coreset construction containing \(}(d_{}()^{2}^{-2})\) points as well as a coreset construction using \(}(d^{2}_{}()^{-2})\) points. Finally, Munteanu and Omlor  recently proved an \(}(d_{}()^{-2})\) size coreset construction. Our work is complementary to the above works, since it highlights the limits of possible compression of the logistic regression problem while maintaining approximation guarantees to the original problem.

### Notation

We assume, without loss of generality, that \(_{i}=-1\) for all \(i=1 n\). Any logistic regression problem with \((,)\) defined above can be transformed to this standard form by multiplying both \(\) and \(\) by the matrix \(-_{}\). Here \(_{}^{n n}\) is a diagonal matrix with \(i\)-th entry set as \(_{i}\). The logistic loss of the original problem is equal to that of the transformed problem for all \(^{d}\). Let \(_{i}\) denote the \(i\)-th row of a matrix \(\). We denote as \(\) the matrix formed by stacking \(_{i}\) as rows. We will use \(}()\) and \(()\) to suppress logarithmic factors of \(d\), \(n\), \(1/\), and \(_{}()\). Finally, let \([n]=\{1,2,...,n\}\).

## 2 Space complexity lower bounds

In this section, we provide space complexity lower bounds for a data structure \(}()\) that satisfies the relative error guarantee in eqn. 2. We use the notations as specified in Section 1. Additionally, we require throughout this section that the entries of \(\) can be specified in \(( nd)\) bits.

Our first main result is a general lower bound on the space complexity of _any_ data structure which approximates logistic loss to \(\)-relative error for every parameter vector \(^{d}\) on a data set whosecomplexity measure \(_{}()\) is bounded by a constant. As a corollary to this result, we show that existing coreset constructions are optimal up to lower order terms in the regime where \(_{}()=(1)\). Our second main result shows that any data structure providing a \(_{0}\)-constant factor approximation to the logistic loss requires \((_{}())\) space, where \(_{0}>0\) is constant. Both of these results proceed by reduction to the INDEX problem  (see Section A.2), where we use the fact that an approximation to the logistic loss can approximate ReLU loss under appropriate conditions.

Consider the ReLU loss:

\[(;)=_{i=1}^{n}\{_{i}^{T},0\}.\] (4)

Our lower bound reductions hinge on the fact that a relative error approximation to logistic loss can be used to simulate a relative error approximation to ReLU loss under appropriate conditions. We capture this in the following lemma. We include all proofs omitted from the main text in Appendix B.

**Lemma 2.1**.: _Given a data set \(^{n d}\) and \(^{d}\) such that \(_{}(;)>1\), if there exists a data structure \(}()\) that satisfies:_

\[(1-)()}()(1+) ()\;\;\;,\]

_then there exists a data structure taking \(}(1)\) extra space such that:_

\[(1-3)()}()(1+3 )()\;\;\;.\]

### Lower bounds for the \(_{}()=(1)\) regime

We lower bound the space complexity of any data structure that approximates logistic loss to \(\)-relative error. Recall that the running time of the computation compressing the data to a small number of bits and evaluating \(}()\) for a given query \(\) is unbounded in this model. Hence, Theorem 1 provides a strong lower bound on the space needed for _any_ compression of the data that can be used to compute an \(\)-relative error approximation to the logistic loss, including, but not limited to, coresets.

At a high level, our proof operates by showing that a relative error approximation to logistic loss can be used to obtain a relative error approximation to ReLu regression, which in turn can be used to construct a relative error \(_{1}\)-subspace embedding. Previously, Li et al.  lower bounded the worst case space complexity of any data structure that maintains an \(_{1}\)-subspace embedding by reducing the problem to the well-known INDEX problem in communication complexity. Notably, the construction of \(\) has complexity measure bounded by a constant, i.e., \(_{}()=(1)\).

**Lemma 2.2**.: _There exists a matrix \(^{n d}\) such that \(_{}() 4\) and any data structure that, with at least \(2/3\) probability, approximates \((;)\) up to \(\)-relative error requires \((})\) space, provided that \(d=( 1/)\), \(n=(d/^{2})\), and \(0<_{0}\) for some small constant \(_{0}\)._

_Furthermore, \((;)>3\|\|_{1}\) for all \(^{d}\)._

Using Lemma 2.1, we can extend this lower bound on the space complexity to approximate ReLU loss to logistic loss.

**Theorem 1**.: _Any data structure \(}()\) that, with at least \(2/3\) probability, is an \(\)-relative error approximation to logistic loss for some input \((,)\), requires \((})\) space in the worst case, assuming that \(d=( 1/)\), \(n=(d^{-2})\), and \(0<_{0}\) for some sufficiently small constant \(_{0}\)._

Proof.: By Lemma 2.2, there exists a matrix \(\) such that any data structure that approximates the ReLU loss up to \(\)-relative error requires the stated space complexity. Let

\[=\{^{d}\|\|_{1}=1\}\]

Then, by Lemma 2.2, \(_{}(;) 3\). Therefore, by Lemma 2.1, any \((1+)\) factor approximation to the logistic loss for the matrix \(\) provides a \((1+3)\)-factor approximation to \((;)\) for \(\). Since \(()=\|\|_{1}(}{{\|\| _{1}}})\), we can extend this guarantee to all \(^{d}\). By Lemma 2.2, any data structure that provides such a guarantee requires the stated space complexity, and, finally, \(}()\) requires the stated complexity.

From the above theorem, we can derive a lower bound on the number of rows needed by a coreset that achieves an \(\)-relative error approximation to the logistic loss (see eqn. 3 for specification of a coreset).

**Corollary 2**.: _Any coreset construction that, with at least \(2/3\) probability, satisfies the relative error guarantee in eqn. 2 must store \((})\) rows of some input matrix \(\), where \(_{}()=(1)\)._

Proof.: Using the previous theorem, there exists a matrix \(^{n( n)}\) such that, assuming that \(n=(^{-2})\) and \(\) is sufficiently small, any data structure that approximates the logistic loss up to relative error on \(\) must use \((}{{^{2}}})\) bits in the worst case. (Recall that \(()\) suppresses \( n\) factors.)

If the data structure stores entire rows of \(\) while storing a total of \((})\) bits, then it must store at least

\[(})= {}(})\]

rows of \(\) in total.

Recall that the proof of Theorem 1 proceeds by showing that a relative error approximation to the logistic loss can be used to solve the INDEX problem. If we have \(d\) independent instances of the matrix \(\), i.e., \(_{(1)},_{(2)},..._{(d)}\), then we may create the matrix

\[=_{(1)}&&&\\ &_{(2)}&&\\ &&&\\ &&&_{(d)}.\]

Note that any relative error approximation to the logistic loss on \(\) would allow relative error approximation to the logistic loss on each of the individual \(_{(i)},\;i=1 d\) matrices, thus allowing one to solve \(d\) instances of the INDEX problem simultaneously. This implies that we can query any bit in each of the \(d\) index problems which solves an INDEX problem of size \((}{{^{2}}})\).

If the data structure is restricted to store entire rows of \(_{(i)}\), then recall that we must store \((}{{^{2}}})\) rows of \(_{(i)}\). Therefore, we conclude that any coreset that achieves a relative error approximation to the logistic loss on \(\) with at least \(2/3\) probability must store \((}{{^{2}}})\) rows of \(\). 

The work of Munteanu and Omlor  showed that sampling \(}(}()}{^ {2}})\) rows of \(\) yields an \(\)-relative error coreset for logistic loss with high probability. Hence, Corollary 2 implies that the coreset construction of Mai et al.  is of optimal size in the regime where \(_{}()=(1)\). However, Theorem 1 only guarantees that coresets are optimal up to a \(d\) factor in terms of bit complexity. An interesting future direction would be closing this gap by either proving that coresets have optimal bit complexity or showing approaches, like matrix sparsification, could achieve even greater space savings.

### An \((_{}() d)\) lower bound

In this section, we provide a space complexity lower bound for a data structure achieving a constant \(_{0}\)-relative error approximation to logistic loss on an input \(\) with variable \(_{}()\). We again assume \(_{i}=-1\) for all \(i[n]\) without loss of generality.

The proof depends on the existence of a matrix \(\{-1,1\}^{n^{4}n}\) that has nearly orthogonal rows. From \(\), we can construct the matrix \(\) such that \(_{}()=(n)\) and a \(2\)-factor approximation to ReLU loss on \(\) can solve the size \(n\) INDEX problem. By Lemma 2.1 and the lower space complexity bound for solving the INDEX problem, we prove the described lower bound for approximating logistic loss.

We begin by proving the existence of the matrix \(\). Recall that for any matrix \(\), we use \(_{i}\) to denote the \(i\)-th row of \(\).

**Lemma 2.3**.: _Let \(n=2^{p}\) for \(n\). There exists a matrix \(\{-1,1\}^{n k}\) such that \(k=^{4}n\) and \(|_{i},_{j}| 4^{2}n\) for all \(i j\)._

We now use the previous lemma to construct a matrix \(\) such that a \(2\)-factor approximation to ReLU loss on \(\) requires \((d_{}())\) space.

**Lemma 2.4**.: _Let \(n=2^{p}\) for \(n\) and assume that \(^{4}(n/2)>16^{2}n\). Then, there exists a matrix \(^{n k}\) such that \(k=(^{4}n)\) and \(_{}()=(n)\) such that any data structure \(}()\) that, with at least \(2/3\) probability, satisfies (for a fixed \(^{d}\))_

\[()}() 2()\]

_and requires at least \((n)\) bits of space._

Proof.: Our proof will proceed by reduction to the INDEX problem. Let \(y_{i}\{0,1\}\) for all \(i=1^{n}\!/2\) represent an arbitrary sequence of \(n/2\) bits. We will show how to encode the state of the \(n\) bits in a relative error approximation to ReLU loss on some data set \(\).

First, let us start with the matrix \(\{-1,1\}^{n/2 k^{}}\) specified in Lemma 2.3, where \(k^{}=^{4}(n/2)\). Let \(}^{n/2 k^{}}\) such that \(}_{i*}=}_{i*}\) if \(y_{i}=1\) and \(}_{i*}=}{{2}}_{i*}\) otherwise. In words, we multiply the \(i\)-th row of \(\) by one if \(y_{i}=1\) and \(}{{2}}\) if \(y_{i}=0\). Next, let us construct the matrix \(^{n k^{}+1}\):

\[=}&\\ -}&-,\] (5)

where \(>0\) will be specified later.

Suppose we want to query \(y_{i}\). Let \(=[}_{i},-4^{2}n]^{T}\). We will show that \(}_{j}< 8^{2}n\) for all \(j i\) by considering three cases:

**Case 1 (\(j n/2;\ j i\)):** In this case, \(}_{j}=}_{i},}_ {j}-4^{2}n\). By Lemma 2.3, \(}_{i},}_{j} _{i},_{j}<4^{2}(n/2)\), hence we can conclude this case.

**Case 2 (\(j>n/2;\ j 2i\)):** Here, \(_{j}=-}_{i},}_{j} +4^{2}n\). Since \(|}_{i},}_{j}|| _{i},_{j}|<4^{2}n\), \(_{j}< 8^{2}n\), so we conclude the case.

**Case 3 (\(j=2i\)):** In this case, \(_{j}=-}_{i},}_{i} +4^{2}n\). Since \(-}_{i},}_{i}\) is negative, we conclude the case.

The above cases show that \(_{j}< 8^{2}n\) when \(j i\). Therefore,

\[() n 8^{2}n+(_{i}) ()(_{i}).\]

We next show that the bit \(y_{i}\) will have a large effect on \(()\). If \(y_{i}=0\), then,

\[_{i}=}_{i},}_{i} =\|_{i}\|_{2}^{2}-4^{2}n< ^{4}(n/2),\]

since \(}_{i}^{^{4}(n/2)}\). On the other hand, if \(y_{i}=1\), then,

\[_{i}=\|}_{i}\|_{2}^{2}-4^{2}n=^{4}(n /2)-4^{2}n>^{4}(n/2),\]

where we used our assumption that \(^{4}(n/2)>16^{2}n\). Therefore, if \(y_{i}=0\), \(()^{4}n+n 8^{2}n\). By setting \(=n}{26 n}\), we find that \(()<^{4}(n/2)\). On the other hand, if \(y_{i}=1\), then \(()>^{4}n/2\). Therefore, a \(2\)-factor approximation to \(()\) is able to decide if \(y_{i}\) equals zero or one. By reduction to the INDEX problem, this implies that any \(2\)-factor approximation to \(()\) must take at least \((n)\) space (see Theorem 6).

Now we must just prove that \(_{}()=(n)\). We will use the following inequality . For any two length \(n\) sequences of positive numbers, \(a_{r},\ r=1 n\) and \(b_{r},\ r=1 n\),

\[^{n}a_{r}}{_{r=1}^{n}b_{r}}_{r=1 n} }{b_{r}},\]where the maximum is taken over an arbitrary fixed ordering of the sequences. Let us define these two sequences as follows for a fixed \(^{d}\). For \(i 1}{{2}}\), if \(_{i}>0\), let \(a_{i}=_{i}\) and \(b_{i}=-1_{2i}\). If \(_{i}<0\), let \(a_{i}=_{2i}\) and \(b_{i}=-1_{i}\). We can disregard the case where \(_{i}=0\), since this will not affect the sums of the sequences. Given such sequences, we get:

\[)^{+}\|_{1}}{\|()^{-}\|_{1}}=a_{r}}{_{r}b_{r}}_{r}}{b_{r}}.\]

The last inequality follows since \(_{2i}=-_{i}\) for \(i=1}{{2}}\). Hence, we conclude that \(_{}()=^{-1}=(n)\). 

The above theorem proves that a constant factor approximation to \(()\) requires \((_{}())\) space. We now extend this result to logistic loss.

**Theorem 3**.: _Let \(n n_{0}\) (for some constant \(n_{0}\)) be a positive integer. There exists a global constant \(_{0}>0\) and a matrix \(^{n k}\) such that any data structure \(}()\) that, with at least \(2/3\) probability, satisfies (for a fixed \(^{d}\)):_

\[(1-_{0})(;)}(; )(1+_{0})(;)\]

_and requires at least \((d_{}())\) bits of space._

Proof.: The space complexity lower bound holds even if \(}()\) approximates \(}()\) only on the values of \(\) used to query the data structure in the proof of Lemma 2.4. Define this set as

\[=\{[}_{i},-4^{2}n]^{T}^{k^{ }} i=1}{{2}}\},\]

where \(}\) is used to construct \(\) in eqn. 5. Since \(()_{i}\), we get

\[()\|}_{i}\|_{2}^{2}-4^{2}n(n/2)}{4}-4^{2}n.\]

Therefore, \(() 1\) for all \(n n_{0}\), where \(n_{0}\) is some constant in \(\). By Lemma 2.1, the space complexity of a data structure that achieves

\[(1-)()}()(1+) ()\]

for a fixed \(\) must be at least the space complexity of a data structure achieving

\[()}()()\]

for \(\). We can now solve for \(\) by setting \(}{{(1-3)}}=2\). Therefore, from Lemma 2.4, we conclude that there exists a constant \(_{0}>0\) such that any data structure providing an \(_{0}\)-relative approximation to the logistic loss requires at least \((n)=(_{}())\) space.

Finally, applying the argument used in Corollary 2 of constructing a matrix \(\), we achieve an \((d_{}())\) lower bound. 

While prior work has show that mergeable coresets must include \((d_{}())\) points to attain a constant factor guarantee to logistic loss , our lower bound result holds for general data structures and applies even for data structure providing the weaker "for-each" guarantee, where the guarantee must hold for an arbitrary but fixed \(^{d}\) with a specified probability. The proof of the lower bound in  relies on constructing a matrix \(\) that encodes \(n\) bits such that the \(i\)-th bit can be recovered by adding some points to \(\) and performing logistic regression on the new matrix. Hence, a mergeable coreset that compresses \(\) can be used to solve the INDEX problem of size \(n\). Meanwhile, our proof does not require constructing a regression problem but rather allows recovering the \(i\)-th bit by only observing an approximate value of the ReLU loss at a single fixed input vector for a fixed matrix \(\). In addition to an arguably simpler proof, our approach needs weaker assumptions on the data structure. Therefore, our lower bound applies in more general settings, i.e., when sparsification is applied to \(\).

Computing the complexity measure \(_{}()\) in polynomial time

We present an efficient algorithm to compute the data complexity measure \(_{}()\) of Definition 1 on real data sets, _refuting an earlier conjecture that this measure was hard to compute_. The importance of this measure for logistic regression has been well-documented in prior work and further understanding its behavior on real-world data sets would help guide further improvements to coreset construction for logistic regression.

Prior work conjectured that \(_{}()\) was hard to compute and presented a polynomial time algorithm to approximate the measure to within a \((d)\)-factor (see Theorem 3 of Munteanu et al. ). We refute this conjecture by showing that the complexity measure \(_{}()\) can in fact be computed efficiently via linear programming, as shown in the following theorem. The specific LP formulation for computing a vector \(^{*}\) such that \(_{}()=_{}^ {*})-\|_{1}}{\|(_{}^{*})+\|_{1}}\) is given in eqn. (9) in the Appendix.

**Theorem 4**.: _If the complexity measure \(_{}()\) of Definition 1 is finite, it can be computed exactly by solving a linear program with \(2n\) variables and \(4n\) constraints._

We conclude the section by noting that prior experimental evaluations of coreset constructions in [10; 7] relied on estimates of \(_{}()\) using the method provided by Munteanu et al. . We will empirically compare how prior methods of estimating the complexity measure compare to our exact method in Section 4.

## 4 Experiments

We provide empirical evidence verifying the algorithm of Section 3 to exactly computes the classification complexity measure \(_{}()\) of Definition 1. We compare our results with the approximate sketching-based calculation of Munteanu et al. .

In order to estimate \(_{}()\) for a dataset using the sketching-based approach of Munteanu et al. , we create several smaller sketched datasets of a given full dataset of size \(n d\) (\(n\) rows and \(d\) columns). We then use a modified linear program along the lines of Munteanu et al. . These new datasets are created so that they have number of rows \(n^{}=(d(d/))\), for various values of \(\), so that with probability at least \(1-\), the estimated \(_{}()\) will lie between some lower bound (given by \(t\), the optimum value of the aforementioned linear program) and an upper bound (given by \(t(d d)\)). In order to solve the modified linear programs, we make use of the OR-tools1.

**Synthetic data:** We create the synthetic dataset as follows. First, we construct the _full_ data matrix \(^{n d}\) by drawing \(n=10,000\) samples from the \(d\)-dimensional Gaussian distribution \((0,_{d})\) with \(d=100\). We generate an arbitrary \(^{d}\) with \(\|\|_{2}=1\) and generate the posterior \(p(_{i}|_{i})=1/(1+(-^{}_{i}+ (0,1)))\). Finally, we create the labels \(_{i}\) for all \(i=1 n\) by setting \(_{i}\) to one if \(p(_{i}|_{i})>0.5\) and to \(-1\) otherwise.

Using the full data matrix \(=_{}\), we create several sketched data matrices having a number of rows equal to \(n^{}=(d(d/))\). We choose \(\) so that \(n^{}\{512,1024,2048,4096,8192\}\). These values of \(n^{}\) are chosen to be powers of two so that we can employ the Fast Cauchy Transform algorithm (FastL1Basis ) for sketching. The algorithm is meant to ensure that the produced sketch identifies \(_{1}\) well-conditioned bases for \(\), which is a prerequisite for using the subsequent linear program to estimate \(_{}()\). (See Section C for details).

The results are presented in Figure 0(a). For various values of \(n^{}\), including when \(n^{}=n=10,000\), which we deem to be the original data size, we show the exact computation of \(_{}()\) on the sketched matrix using the linear program of Theorem 4. We also show the corresponding upper and lower bounds on \(_{}()\) of the full data set as estimated by the well-conditioned basis hunting approximation proposed by Munteanu et al. . For the lower bound, we use the optimum value of the modified linear program as proposed in Munteanu et al.  and detailed in Section C. We set the upper bound by multiplying the lower bound by \(d(d/)\). Note that this upper bound is conservative, and the actual upper bound could be a constant factor higher, since the guarantees of Munteanu et al.  are only up to a constant factor. The presented results are an average over 20 runs of different sketchesfor each value of \(n^{}\). Figure 0(a) shows that the exact computations on sketched matrices are close to the actual \(_{}()\) of the full data matrix, while the upper and lower bounds as proposed by Munteanu et al.  can be fairly loose.

**Real data experiments:** To test our setup on real data, we make use of the sklearn KDDCup dataset.2 The dataset consists of 100654 data points and over 50 features. We only use continuous features which reduces the feature size to 33. The dataset contains 3377 positive data points, while the rest are negative. To create various sized subsets for exact calculation, we subsample from positives and negatives so that they are in about equal proportion. For larger subsamples, we retain all the positives, and subsample the rest from the negative data points. Since the calculation of \(\) for the full dataset is intractable as it will require to solve an optimization problem of over 400k constraints, we subsample 16384 data points and use its \(\) as proxy for that of the full dataset (referred to as ExactFull. For such a large subsample, the error bars are small. We compare against sketching and exact \(\) calculations for smaller subset (See Figure 0(b) for the results).

## 5 Future work

Our work shows that existing coresets are optimal up to lower order factors in the regime where \(_{}()=(1)\). A clear open direction would be proving a space complexity lower bound that holds for all valid values of \(\) and \(_{}()\). Additionally, there is still a \(d\) factor gap between existing upper bounds  and our lower bounds (Theorems 1 and 3) in the regime where \(\) is constant and the complexity measure varies or the complexity measure is constant and \(\) varies respectively.

Another interesting direction would be to explore whether additional techniques can further reduce the space complexity in approximating logistic loss compared to coresets alone. While Theorem 1 shows that the size of coreset constructions are essentially optimal, it does not preclude reducing the space by a \(d\) factor by using other methods. In particular, the construction of \(\) used in the proof of Theorem 1 is sparse, and so existing matrix sparsification methods would save this \(d\) factor here.

We also note that our first lower bound (Theorem 1) only applies to data structures providing the the "for-all" guarantee on the logistic loss, i.e., with a given probability, the error guarantee in eqn.(2) holds for all \(^{d}\). It would be interesting to know if it could strengthened to apply in the "for-each" setting as Theorem 3 does, where \(^{d}\) is arbitrary but fixed.

Finally, it would be useful to gain a better understanding of the complexity measure \(_{}()\) in real data through more comprehensive experiments using our method provided in Theorem 4. In particular, subsampling points of a data set may create bias when computing \(_{}()\).

Figure 1: Simulated data results for exact computation of \(_{}()\) (Theorem 4) using the full data (Exactfull), sketched data (ExactSketched) vs the approximate upper (ApprSketchedUpper) and lower bounds (ApprSketchedLower) as suggested by Munteanu et al.  (see Section C). The results clearly show that the upper and lower bounds can be very loose compared to our exact calculation of the complexity measure \(_{}()\)