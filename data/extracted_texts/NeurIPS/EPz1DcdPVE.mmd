# Towards Federated Foundation Models: Scalable Dataset Pipelines for Group-Structured Learning

Zachary Charles

Google Research

zachcharles@google.com

&Nicole Mitchell

Google Research

nicolemitchell@google.com

&Krishna Pillutla

Google Research

kpillutla@google.com

&Michael Reneer

Google Research

michaelreneer@google.com

&Zachary Garrett

Google Research

zachgarrett@google.com

Authors contributed equally to this work.

###### Abstract

We introduce Dataset Grouper, a library to create large-scale group-structured (e.g., federated) datasets, enabling federated learning simulation at the scale of foundation models. This library facilitates the creation of group-structured versions of existing datasets based on user-specified partitions, and directly leads to a variety of useful heterogeneous datasets that can be plugged into existing software frameworks. Dataset Grouper offers three key advantages. First, it scales to settings where even a single group's dataset is too large to fit in memory. Second, it provides flexibility, both in choosing the base (non-partitioned) dataset and in defining partitions. Finally, it is framework-agnostic. We empirically demonstrate that Dataset Grouper enables large-scale federated language modeling simulations on datasets that are orders of magnitude larger than in previous work, allowing for federated training of language models with hundreds of millions, and even billions, of parameters. Our experimental results show that algorithms like FedAvg operate more as meta-learning methods than as empirical risk minimization methods at this scale, suggesting their utility in downstream personalization and task-specific adaptation. Dataset Grouper is available at https://github.com/google-research/dataset_grouper.

## 1 Introduction

In most machine learning and artificial intelligence settings, algorithms operate on "flat" collections of examples, that is, examples with no differentiation in source or group structure. However, data in the real world often consists of an explicit or implicit underlying _group structure_, where the examples are partitioned across some number of groups with markedly different statistical characteristics. Increasingly, research has found that this structure is important in a variety of settings, both for encoding constraints (such as data restrictions) and in developing algorithms for learning tasks.

Federated learning (FL) is one such setting. FL methods are designed to operate on data partitioned explicitly across "clients". In cross-device FL [1, Table 1], clients are often edge devices which exhibit heterogeneity in both quantity and distribution of data. Cross-silo FL exhibits a similar structure, often with a coarser notion of clients (such as institutions or companies). Group structures also arise in meta-learning, in which data is grouped according to a notion of "task" , and in personalization, in which a user's specific data is used to tune an algorithm's outputs. The group structure can also be highly relevant in the context of differential privacy . An intuitive "unitof privacy" is the total collection of examples associated with a given user . To ensure user-level differential privacy, we must generally train the model in a user-aware manner.

The increasing prominence of foundation models and large language models (LLMs) and their wise applicability to downstream tasks enhance the need for group-structured data. Though foundation models are generally trained on massive flat datasets, they are often evaluated by considering the performance on various benchmarks, yielding a natural group structure. Moreover, for downstream, user-facing applications, one may want to train on user-partitioned data that is representative of the actual task at hand. Alternatively (or in conjunction) one can personalize a foundation model for a given user . In all these settings, one may wish to maintain formal user-level privacy guarantees, especially given the privacy and memorization concerns surrounding foundation models .

All of the aforementioned scenarios require datasets with explicit group structure. Since foundation models generally require large amounts of data, these research areas may specifically benefit from large-scale group-structured datasets. Unfortunately, to the best of our knowledge, there are relatively few existing datasets that meet such criteria. While a variety of federated datasets are available to researchers , many of these are small-scale in terms of the number of groups, the quantity of data, or quantity of data per group. Moreover, they may only be available in formats that do not scale well, either due to memory requirements or insufficient efficiency.

**Contributions.** In this work, we address the growing need for a wider variety of group-structured datasets, especially at larger scales. Concretely, we make the following contributions.

* **A library for creating group-structured datasets**: We introduce Dataset Grouper, a library that can _flexibly_ create group-structured (and federated) versions of existing datasets via user-defined partition functions. We engineer it for _efficiency_, both in partitioning datasets and in iterating over data. The library is designed with large-scale datasets in mind and can support datasets with millions or even billions of groups. Dataset Grouper can be used to create group-structured versions of all datasets available in Tensorflow Datasets  and HuggingFace Datasets .
* **Large-scale federated text datasets**: While Dataset Grouper can be used for a wide array of modalities and tasks, we illustrate its use by creating group-structured versions of four large language modeling datasets (see Table 1 and Figure 1), designed specifically for FL research. They are orders of magnitude larger than previous datasets in terms of one or more of the following: the number of groups, the amount of data, and the length of sequences. They are suitable for both pre-training and fine-tuning tasks, and exhibit long tails, as is common in large-scale text corpora.
* **Experiments**: We train \(O(100)\) and \(O(1)\) parameter decoder-only transformer models from scratch on a group-structured version of the C4 dataset , using FL training algorithms. This is, to the best of our knowledge, the first demonstration of federated training of a model of this magnitude on a federated dataset of this scale. We compare FedAvg and FedSGD in this setting in terms of their pre- and post-personalization metrics. Our results highlight that at this scale, FedAvg behaves more like a meta-learning algorithm than an empirical risk minimization algorithm.

**On the term "federated".** Our work is primarily motivated by the research needs of the FL community. Throughout, we will often approach questions, design decisions, and experiments from this

    &  &  &  &  &  &  &  \\   & & & & \(10^{}\) perc. & Median & \(90^{}\) perc. & & \(10^{}\) perc. & Median & \(90^{}\) perc. \\   & FedC4 & Domain & \(132\) & \(15.6\) & \(82\) & \(815\) & \(0.5\) & \(0.36\) & \(49\) & \(191\) & \(783\) \\  & FedWalk & Article & \(38\) & \(6.5\) & \(39\) & \(198\) & \(70\)K & \(6.5\) & \(39\) & \(198\) & \(70\)K \\  & FedSGDCO & Book & \(1.2\) & \(18\)K & \(24\) & \(52\) & \(4\)M & \(18\)K & \(24\) & \(52\) & \(4\) \\  & FedCnews & Domain & \(0.3\) & \(8.8\) & \(303\) & \(5\)K & \(8.4\) & \(0.7\) & \(78\) & \(316\) & \(842\) \\   & Amazon Reviews & Account & \(4.3\) & \(1.5\) & \(278\) & \(1.1\) & \(5\) & \(68\) & \(3\) & \(28\) & \(155\) \\  & Stack Overflow & Account & \(2\) & \(0.3\) & \(1.2\) & \(2.7\) & \(11\) & \(0.1\) & \(3\) & \(13\) & \(29\) \\  & Redkit & Account & \(1.2\) & \(1.7\) & \(58\) & \(257\) & \(1720\) & \(33\) & \(7\) & \(21\) & \(81\) \\  & Blog Corpus & Account & \(0.1\) & \(17\) & \(551\) & \(2\) & \(13\) & \(0.5\) & \(6\) & \(105\) & \(460\) \\  & Shakespeare & Role/play & \(0.4\) & \(715\) & \(14\) & \(175\) & \(1.6\) & \(16\) & \(4\) & \(12\) & \(63\) \\  & Gigword & Synthetic & \(0.3\) & \(100\) & \(3.0\) & \(3.1\) & \(3.2\) & \(10\) & \(21\) & \(31\) & \(41\) \\   

Table 1: Summary of the per-group (i.e., per-client) and per-example (i.e., per-sequence) statistics of the new language modeling datasets we introduce using Dataset Grouper, compared to those of previous federated benchmark datasets supplied by TFF , LEAF , FedNLP , and FedScale .

perspective, and will occasionally use the terms "federated" and "group-structured" interchangeably. This is a broadening of the definition of the federated setting often given in the literature, especially the definition proposed by Kairouz et al. . There and in previous literature, FL is characterized by the group-level structure of the data coupled with the location of each group (e.g., a client's dataset is assumed to reside only on its local device). In this work, we de-emphasize the location of the data, and will primarily focus on the group-structure of the data regardless of where that data lives.

## 2 Related Work

Many widely used group-structured datasets arise from the FL community. Early work on FL benchmark datasets combined benchmark datasets with simulation environments. For example, LEAF , TensorFlow Federated (TFF) , Flower , FedML  (and its text-specific dataset provided in FedNLP ), FedScale , FLBench , OARF , and FedJAX  all supply partitioned datasets commonly used in FL benchmarks. These frameworks have helped drive much of FL research into areas such as optimization algorithms , privacy and security , robustness to adversaries  and distribution shifts , and personalization .

Later work on FL introduced specialized datasets and benchmarks. FLAIR  is a large-scale multi-label image classification dataset with \(0.4\) images from \(50\)K Flickr accounts. FLamby  is a cross-silo FL benchmark for healthcare applications where the datasets contain \(2\)-\(6\) groups with \(400\) to \(23\)K total examples. The personalized federated learning algorithm benchmark Motley 's largest dataset is Stack Overflow while pFL-bench  offers no language modeling datasets.

The scale of the existing language modeling datasets that FL frameworks provide is summarized in Table 1. By comparison, the datasets we provide are significantly larger, which allows training models that are an order of magnitude larger than previous work . Additionally, our datasets are generally framework-agnostic and can be combined with many of these simulation frameworks. Further, existing federated datasets that are derived from datasets in TensorFlow Datasets , such as Amazon Reviews and Blog Corpus, can be generated via Dataset Grouper.

Group-structured data have also been studied in the context of distribution shifts, e.g., the WILDS benchmark . The datasets provided in WILDS are smaller than what we consider in Table 1 -- the code language modeling dataset Py150 dataset has \(150\)K examples partitioned over \(8\)K groups. Moreover, WILDS does not support optimized per-group data-loaders as of this writing , which are necessary for benchmarking federated algorithms.

LLMs are typically pre-trained on large web-scraped text corpora without any group structure [e.g. 18, 60, 61]. Besides the tremendous amount of data on which they are trained , the success of LLMs is also driven by the capacity of these models to handle much longer sequences than previous RNN-based models . This requires datasets with long enough contiguous sequences that contain hundreds to thousands of words. Almost all of the existing group-structured language modeling datasets have extremely short sequences (Table 1). For instance, the Stack Overflow dataset has a median and \(90^{}\) percentile sequence lengths of \(13\) and \(29\) words respectively. In comparison, the datasets we introduce have significantly longer sequences, e.g., FedBookCO has on the order of \(10^{3}\) to \(10^{6}\) words per sequence.

Some recent advances at the intersection of FL and foundation models include collaborative prompt tuning using FL , federating chain-of-though reasoning  through diverse crowd-workers , and instruction-tuning LLMs using FL . Dataset Grouper can also be used to generate federated datasets compatible with these methods as well.

Figure 1: Per-group statistics of the new group-structured (i.e. federated) language modeling datasets.

## 3 Core Design

We now discuss the core design of Dataset Grouper and the various trade-offs it entails. One unifying theme throughout is a focus on enabling the types of training workflows used for foundation models, at the expense of some amount of flexibility in what kinds of simulations can be performed.

### Group-Structured Datasets at Scale

Our primary goal is to enable research using large-scale group-structured datasets. In order to do so, we need a group-structured dataset format that balances the following characteristics:

* **Scalability**: Can the dataset format scale to large numbers of examples, groups, and bytes?
* **Group access time**: How long does it take to access the examples held by a single group?
* **Group access patterns**: What kinds of sampling patterns across groups are permitted? Can we access group datasets arbitrarily, and in any order?

There is a trade-off between these characteristics. Dataset formats used in the FL community often optimize for either scalability or group sampling time, while enabling maximum flexibility in access patterns. Our core insight is that by limiting the access patterns possible, we can use a dataset format that is scalable and efficient simultaneously. We discuss three archetypes of group-structured dataset formats (in-memory, hierarchical, and streaming) and their resulting trade-offs briefly in Table 2, and in more detail below. Figure 2 gives a graphical representation of the formats.

**In-memory formats.** In-memory group-structured datasets are essentially key-value mappings held entirely in memory. Adopted by e.g. LEAF  and FedNLP , this is suitable for small datasets such as EMNIST or CIFAR-100. Looking up a group's dataset is fast (e.g., via a hash map), and groups can be accessed in an arbitrary order. Of course, this approach is limited by the cumulative size of the dataset and is therefore not scalable in full generality. As we see in Table 3, this format does not even scale to FedBookCO on a single CPU; FedC4 and FedWiki are even larger.

**Hierarchical formats.** Hierarchical dataset formats store examples across files in such a way that (a) the dataset need not be loaded entirely into memory, and (b) individual groups can be constructed in arbitrary orders. For example, TensorFlow Federated  uses SQL databases to both store and access client datasets for FL simulations, facilitating the loading of the group index in-memory, then construction of a group's dataset at a later time. For larger datasets, constructing an arbitrary group's dataset can be slow, as it is often bottlenecked by indexing and searching over a large number of (possibly distributed) files. Table 3 shows that the hierarchical format can be significantly slower than other formats when accessing groups in very large datasets.

    & **In-Memory** & **Hierarchical** & **Streaming** \\  Scalability & Limited & High & High \\ Group Access Time & Very Fast & Slow & Fast \\ Group Access Patterns & Arbitrary & Arbitrary & Shuffle + Streaming \\   

Table 2: Characteristics of group-structured dataset formats.

Figure 2: High-level representations of group-structured dataset formats.

#### Streaming formats.

Instead of allowing arbitrary group access, Dataset Grouper provides ways to iterate over all the groups in a stream-like fashion. The datasets for each group are backed by some number of files,2 which are interleaved to create a "group stream". Concretely, this restricts the possible group access patterns, only allowing stream-level operations such as buffered shuffling, repeating, and batching. This essentially lifts the stream-of-examples format used large-scale centralized training pipelines to streams of groups for federated training -- both formats allow dataset iterators with limited shuffling (e.g., with a fixed-size buffer), but not arbitrary access to the individual elements. This restriction allows us to use parallel reads, prefetching, and interleaving to speed up dataset iteration and generally enables the total iteration time of the dataset to scale linearly (as opposed to super-linearly) with the number of groups in the dataset.

Each group's dataset is further represented as a stream of examples so that no group's data need to be fully loaded into memory. This is crucial in scaling to large datasets like FedC4, something that is memory-prohibitive for in-memory formats, and speed-prohibitive for hierarchical formats. To illustrate this further, we detail the time required to iterate fully over various group-structured datasets (accessing the groups' datasets sequentially, in a random order) in different formats in Table 3. For details on the amount of memory used by each format, see Appendix E.

### Flexible and Efficient Dataset Partitioning

An underlying theme of both foundation model research and FL research is the need for a wide variety of datasets. It is often useful to have different datasets for different downstream tasks and modalities for foundation models, while the wide variety of FL settings (e.g. cross-device vs. cross-silo) and types of group heterogeneity (feature heterogeneity, label heterogeneity, heteroskedasticity, etc.) require dedicated datasets. It is often useful in FL to be able to explicitly partition the same dataset in multiple ways, in order to understand the impact of heterogeneity . Therefore, our second key design goal is to allow flexibility both in the base (non-partitioned) dataset and in how it is partitioned.

To achieve this, we make two important, albeit related, design decisions. First, Dataset Grouper does not directly host datasets, but instead allows users to create partitioned versions of existing datasets in TensorFlow Datasets  and HuggingFace Datasets . Second, Dataset Grouper operates by applying data-parallel processing pipelines3 to partition these "base" datasets. Notably, Dataset Grouper allows user-specified partition methods, but they must operate in an embarrassingly parallel manner. This decision is a formal trade-off made for scalability reasons. Sequential partitioning (e.g., deciding which group has an example \(x\) based on which group has an example \(y\)) can fail to scale to datasets with billions of examples. Thus, Dataset Grouper supports (at scale) embarrassingly parallelizable partitions of datasets available in TensorFlow Datasets or HuggingFace Datasets.

### Compatibility with Existing Frameworks

Foundation model research and FL research also share a common feature in that there is a wide array of available simulation frameworks. Another goal of our work is to support as wide an array of such frameworks as possible. To that end, Dataset Grouper provides access to datasets as nested iterators

  
**Dataset Format** & **In-Memory** & **Hierarchical** & **Streaming** \\  CIFAR-100 & \(0.0783 0.0007\) & \(25.11 0.81\) & \(9.88 0.075\) \\ FedCCnews & \(0.549 0.014\) & \(>7200\) & \(248 17.5\) \\ FedBookCO & Out of memory & \(>7200\) & \(192 9.07\) \\   

Table 3: The time (in seconds) to iterate over federated datasets. This is the time required to iterate over all examples in all group datasets, in serial, on a single CPU. We present the average and standard deviation over 5 trials, omitting trials that take more than 2 hours (\(>7200\) seconds), or that ran out of memory. We compare a federated CIFAR-100 dataset (partitioned across 100 groups, each with 100 examples), FedCCnews (in which examples are split across users at a domain level), and FedBookCO (in which examples are split across users at a title level). See Section 4 for more details on the latter two datasets.

of tensors. Specifically, group-structured datasets are represented as an iterator of group datasets, each of which is an iterator of tensors. These tensors can be represented in both TensorFlow  and NumPy  formats, ensuring that, in principle, Dataset Grouper can be used in any simulation framework built on top of NumPy, TensorFlow, PyTorch , or JAX .4

## 4 Examples and Applications

We now focus on four new group-structured text datasets we create via Dataset Grouper: FedC4, FedWiki, FedCCnews, FedBookCO. We focus on language modeling datasets due to their prominence in training foundation models and their large-scale nature. Compared to prior benchmark datasets, FedC4 is an order of magnitude larger, while FedBookCO contains significantly longer sequences. The new datasets, particularly FedC4 and FedCCnews, are also more heavy-tailed than existing ones. See Appendix B for more details.

While representative of the statistical structure suited to training larger models, we wish to emphasize that these datasets are only a small sample of what is possible with Dataset Grouper. The library can also be used to create group-structured multi-lingual text datasets, datasets in other modalities (audio, image, etc.), and to study the effect of different partitions on the same base dataset.

**FedC4.** We create a federated version of the Colossal Clean Crawled Corpus (C4) dataset , which is a cleaned version of Common Crawl's web crawl corpus.5 We focus on partitioning by web domain, e.g., all articles crawled from https://www.nytimes.com/ correspond to one group. We note that a finer partitioning at the level of articles is also possible. We see from Figure 1 and Table 1 that the amount of data per client is extremely heavy-tailed; this is expected from real-world text corpora [75; 76]. Indeed, this distribution is nearly log-normal, meaning that its logarithm is approximately Gaussian. This can be seen from the nearly straight line in the Q-Q plot in Figure 3.

The C4 data is also used as a pre-training corpus for some LLMs such as T5 , meaning that FedC4 can potentially be used for federated pre-training, which we explore further in Section 5. Note that C4 is already de-duplicated and artifacts like code, placeholder text (e.g. lorem ipsum), and boilerplate (e.g. menus) are removed along with a heuristic list of "bad words". See  for details.

**FedWiki.** We create a federated version of the Wikipedia dataset, where each client contains the content of one full English Wikipedia article. As a result, the amount of data per client is smaller than that in FedC4, where each client can contain multiple articles. Wikipedia data is often a part of the pre-training corpora of LLMs.

**FedBookCO.** We create a federated version of the BookCorpusOpen dataset [77; 78], an open-source collection of \(18\) books from various genres. Each client corresponds to one sequence that is a full book, leading to significantly longer sequences than other datasets.

**FedCCnews.** We create a federated version of CC-News, which contains English news articles from news sites around the world. Similar to FedC4, each group corresponds to a web domain; a finer-grained article-level partitioning is also possible. Indeed, FedCCnews is a subset of FedC4. It exhibits similar long-tailed behavior and could serve well as its smaller proxy.

Figure 3: Fitting a log-normal distribution to the per-group sizes of the new text datasets we introduce: we show a Q-Q plot of the log quantiles of the per-group data sizes vs. those of a Gaussian distribution.

## 5 Experiments

To begin to demonstrate the scale of federated learning simulation that these newly partitioned datasets enable, we run experiments on FedC4 with a decoder-only transformer architecture.

### Experimental Setup

We use FedC4 with domain-level partitioning in our experiments. We use a WordPiece tokenizer  with a pre-trained BERT vocabulary  of size of \(30523\). We train _from scratch_ a \(108\) parameter decoder-only transformer model commensurate in size with BERT base and GPT-2 small (i.e., \(12\) layers, \(12\) attention heads, and hidden layers of dimension \(768\)) using the causal language modeling loss (i.e., next token prediction with cross-entropy). We report the cross-entropy loss throughout, which equals the logarithm of the perplexity.

**Federated algorithms.** We use two prototypical FL algorithms: FedAvg and FedSGD . In each federated round, we select the next cohort of 16 clients. Local training is done on client data batched to 16 examples with a sequence length of 128 tokens. We repeat client data as necessary to ensure that all clients have 1024 examples. For FedAvg, we run 3125 rounds of federated training. During each round, each client in that round's cohort takes 64 gradient steps. Thus, the federated training will involve roughly \(200\) batched gradient computations in total. For FedSGD, we use the same setup, except that clients do not locally update their own model when computing local gradients. Instead, these \(64\) minibatch gradients are averaged into a single large-batch gradient and sent to the server.

**Optimizer hyperparameters.** For FedAvg, we use the client/server-optimizer framework proposed by Reddi et al. . We use SGD for the client optimizer and Adam for the server optimizer. FedSGD only has a server optimizer, which we also set to Adam. We only tune the learning rate(s), tuning over \(\{10^{-4},10^{-3},,10^{0}\}\), and selecting the learning rate(s) that minimize average training loss. For details and a full list of optimizer hyperparameters, see Appendix C.

**Hardware configuration.** We run our experiments using a TPU Pod slice consisting of 16 TPU v3 chips in a 4x4 topology, configured to use a multi-machine inter-chip interconnect mesh. Each TPU v3 chip contains two TensorCores, 32 GiB of high-bandwidth memory, 87.25 GiB RAM, 900 GBps bandwidth, and 123 teraflops peak compute.

### Experimental Results

**Iteration efficiency.** We test the efficiency of Dataset Grouper in practical large-scale simulations. Specifically, we measure the time it takes for each round of federated training and what portion of that time is spent iterating over data, including preprocessing. We perform 100 rounds of FedAvg for varying cohort sizes (the number of clients per round) and present the results in Table 4. We see that dataset iteration takes under \(10\%\) of the total runtime, even for larger cohort sizes. This is despite the fact that dataset iteration is done entirely on the host, while the training time is parallelized between multiple TPU slices. Further improvements in the data pipeline can only lead to a marginal speedup, highlighting the efficiency and scalability of the streaming dataset format in Section 3.1.

**Federated learning rate schedules.** Large-scale training on non-partitioned data generally involves a variety of important techniques, such as learning rate scheduling, to attain good performance. In order to determine how best to scale federated training to larger-scale settings, we investigate the use of various learning rate schedules for FedAvg and FedSGD. In both cases, we apply the learning rate schedule at the _server_ (see  for a discussion of client versus server optimizers). We use constant

  
**Cohort Size** & **Data Iteration Time** (s) & **Training Time** (s) & **Data Iteration Time** (\%) \\ 
8 & \(0.26 0.48\) & \(3.03 2.58\) & 7.78 \\
16 & \(0.66 0.85\) & \(5.70 2.61\) & 10.43 \\
32 & \(1.16 1.48\) & \(11.30 2.48\) & 9.33 \\   

Table 4: Average time spent per round on iterating over data, including preprocessing, versus training. Results are computed for 100 rounds of training of FedAvg, with varying cohort sizes.

learning rates, warmup with exponential decay, and warmup with cosine decay. Whenever we use warmup, we warmup for 10% of the total number of training rounds, and decay for the remainder.

We compare the resulting training loss for FedAvg and FedSGD in Figure 4. Notably, we see that learning rate scheduling leads to significant improvements in the behavior of FedSGD, while FedAvg is robust to different choices. This reflects the fact that these learning rate schedules were developed in the context of SGD, which involves applying many unbiased gradient estimates. FedSGD operates similarly, computing an unbiased gradient estimate at each round. By contrast, FedAvg involves biased gradients, often called "pseudo-gradients" , which may not be the gradient of any loss function . Our results suggest that developing effective learning rate scheduling techniques for FedAvg is an open question, and may involve coordinating client and server learning rates.

We also see that FedAvg appears to attain a significantly lower train loss than FedSGD. We stress that this is due to how the training loss is computed. For both algorithms, it is computed by averaging the loss of all batches seen by a client and then averaging that quantity across all clients. However, the client trains as it sees data batches in FedAvg. Therefore, the client's local model adapts to its own distribution (leading to a lower loss), while in FedSGD the client does not adapt its local model. We explore this difference, which is connected to **meta-learning**, below.

**Federated evaluation and personalization.** Partitioned datasets enable group-structured learning, as well as group-level (or federated) evaluation, which may be particularly informative for measuring downstream performance across heterogeneous data splits. To demonstrate this, we use Dataset Grouper to generate an evaluation dataset from FedC4 by using its held-out validation split. We use the same partition structure as before, grouping examples according to their base domain. Because of this group structure, we can compute histograms of metrics across all groups, rather than just an average metric across all examples.

We take the resulting models trained by FedAvg and FedSGD (with constant learning rates, though we see similar results for all learning rate schedules we considered above), and compute two separate metrics for each validation client. First, we compute the average loss of the model on all examples held by the client. We refer to this as the **pre-personalization loss**. We then fine-tune the model for a single epoch on the client's dataset (using a client optimizer of SGD with a tuned learning rate). After personalization, we compute the average loss again, resulting in the **post-personalization loss**.

Figure 4: Training loss of FedAvg and FedSGD on FedC4 with different learning rate schedules. The per-round training loss is computed by (a) averaging over all batches seen by a given client within the round, and (b) averaging over all clients that participate in the round.

  
**Algorithm** &  &  \\   & \(10^{}\) perc. & Median & \(90^{}\) perc. & \(10^{}\) perc. & Median & \(90^{}\) perc. \\  FedAvg & \(5.13\) & \(5.64\) & \(6.27\) & \(\) & \(\) & \(\) \\ FedSGD & \(\) & \(\) & \(\) & \(1.25\) & \(3.38\) & \(4.53\) \\   

Table 5: Validation loss of FedAvg and FedSGD, before and after personalizing on a clientâ€™s dataset. Percentiles are computed across all clients in the FedC4 validation dataset.

We present quantiles of these metrics in Table 5. Intriguingly, they show that the FedSGD-trained model works better for pre-personalization, but the FedAvg-trained model is much more effective at personalizing to the client's data. To further illustrate this, we consider histograms of the two distributions (across all clients) in Figure 5. This suggests a more dramatic shift. While the FedAvg- and FedSGD-trained models are close in pre-personalization performance (though FedSGD does better), the post-personalization distribution for FedAvg is extremely light-tailed.

**Task-specific personalization.** Pre-trained foundation models are typically employed on a range of downstream tasks. In this spirit, we use the models trained on FedC4 to perform pre- and post-personalization evaluation on FedBookCO. The results, Figures 6 and 7, are similar to but less drastic than those of Figure 5. The pre-personalization loss of FedAvg is slightly larger than FedSGD (\(5.0\) vs. \(4.3\) in the last checkpoint) while its post-personalization loss is smaller (\(2.9\) vs. \(4.0\)). Similar trends hold for FedCCnews and FedWiki datasets; cf. Appendix D. Overall, these results show that FedAvg's superior personalization performance is **robust to shifts in the distribution over clients**.

This phenomenon highlights connections between federated learning and meta-learning previously noted in the literature . In short, we see that FedAvg acts as a meta-learning algorithm (specifically, the Reptile algorithm ) where it quickly minimizes the loss of a client after a few local gradient steps (i.e., after personalization). It does not behave like an algorithm designed to minimize the empirical risk. By contrast, FedSGD operates much like SGD in the centralized setting, attempting to minimize the average loss across all examples. To the best of our knowledge, Figure 5 constitutes some of the strongest empirical evidence of the connection between federated and meta-learning to date. The scale of the FedC4 dataset (enabled by Dataset Grouper) is critical here, as clients have sufficiently large amounts of data to exacerbate client drift  and cause tension between loss minimization and meta-learning.

**Scaling to larger models.** To further demonstrate the scalability of Dataset Grouper, we train a transformer model with 1 billion parameters on the FedC4 dataset. In contrast to the results above, we train with 4 batches per client (rather than 64). Despite this, we see in Figure 8 that FedSGD still sees

Figure 5: Histograms of pre- and post-personalization loss across all FedC4 validation clients.

Figure 6: Median pre-personalization (left) and post-personalization (left) loss over FedBookCO clients while training on FedC4. The shaded region indicates the 10th and 90th percentiles.

improved pre-personalization loss compared to FedAvg. Moreover, both algorithms see improved pre-personalization compared to Table 5, highlighting the effect of increasing the larger size.

## 6 Discussion and Outlook

The intersection of foundation models and group-structured data is a fertile area for research. We provide tooling for creating group-partitioned datasets for use in large-scale research simulation. We acknowledge that there are inherent risks in this endeavor. As detailed by Koch et al. , the typical dynamics of dataset use in machine learning research tend to enshrine certain datasets as "sole benchmarks" in the field, even on tasks for which they were not designed. Tooling aimed at allowing for flexible and reproducible dataset creation risks further entrenchment of these sole benchmarks by expanding the scope of tasks to which they are applied. However, we posit that Dataset Grouper's pipeline approach will prove to be a sustainable mechanism for ensuring availability of datasets whose intended use cases match their application in research, and can potentially reduce the enshrinement of benchmarks in areas such as federated learning.

There are a wide array of other research benefits enabled by Dataset Grouper, especially as it delivers scalable and efficient partitioned dataset pipelines compatible with foundation model training and fine-tuning. This crucially enables the exploration of phenomena that only emerge at the scale of foundation models. Our experiments are intended as a demonstration of the scaling capabilities unlocked by Dataset Grouper to the billion parameter regime. Our empirical findings indicate several interesting future directions. Most excitingly (and speculatively), the tendency of FedAvg to meta-learn tasks suggests that it could provide a better "base" model for the personalization of foundation models or adaptation to downstream tasks. Moreover, there is a need to design tailored learning rates and default optimization recipes for the wider applicability of federated training algorithms. We hope that Dataset Grouper will spur further research in training, evaluation, finer grained analyses, and diagnoses of foundation models with group-structured data.

Figure 8: Pre-personalization loss of FedAvg and FedSGD across all FedC4 validation clients on a 1 billion parameter transformer model.

Figure 7: Histograms of pre- and post-personalization loss on FedBookCO after FedC4 training.

#### Acknowledgements

The authors thank Keith Rush, H. Brendan McMahan, Sean Augenstein, and Liam Collins for fruitful discussions and helpful comments. The authors would also like to thank Keith Rush for help with training code and multi-TPU support. Finally, the authors would like to thank Zheng Xu, Shanshan Wu, Keith Rush, and Arun Ganesh for helpful conversations on group-structured datasets.