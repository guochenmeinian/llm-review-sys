# Jianye Hao\({}^{2,3}\), Mingxuan Yuan\({}^{2}\), Junchi Yan\({}^{1}\)

FlexPlanner: Flexible 3D Floorplanning via Deep Reinforcement Learning in Hybrid Action Space with Multi-Modality Representation

Ruizhe Zhong\({}^{1}\), Xingbo Du\({}^{1}\), Shixiong Kai\({}^{2}\), Zhentao Tang\({}^{2}\), Siyuan Xu\({}^{2}\),\({}^{1}\)Dept. of CSE & School of AI & MoE Key Lab of AI, Shanghai Jiao Tong University

\({}^{2}\)Noah's Ark Lab, Huawei

\({}^{3}\)College of Intelligence and Computing, Tianjin University

{zerzerzerzerz271828, duxingbo, yanjunchi}@sjtu.edu.cn

{kaishixiong, tangzhentao1, xusiyuan520, yuan.mingxuan}@huawei.com

jianye.hao@tju.edu.cn

Corresponding Author. This work was partly supported by NSFC (62222607, 92370201) and Shanghai Municipal Science and Technology Major Project under Grant 2021SHZDZX0102.

###### Abstract

In the Integrated Circuit (IC) design flow, floorplanning (FP) determines the position and shape of each block. Serving as a prototype for downstream tasks, it is critical and establishes the upper bound of the final PPA (Power, Performance, Area). However, with the emergence of 3D IC with stacked layers, existing methods are not flexible enough to handle the versatile constraints. Besides, they typically face difficulties in aligning the cross-die modules in 3D ICs due to their heuristic representations, which could potentially result in severe data transfer failures. To address these issues, we propose FlexPlanner, a flexible learning-based method in hybrid action space with multi-modality representation to simultaneously handle position, aspect ratio, and alignment of blocks. To our best knowledge, FlexPlanner is the first learning-based approach to discard heuristic-based search in the 3D FP task. Thus, the solution space is not limited by the heuristic floorplanning representation, allowing for significant improvements in both wirelength and alignment scores. Specifically, FlexPlanner models 3D FP based on multi-modalities, including vision, graph, and sequence. To address the non-trivial heuristic-dependent issue, we design a sophisticated policy network with hybrid action space and asynchronous layer decision mechanism that allow for determining the versatile properties of each block. Experiments on public benchmarks MCNC and GSRC show the effectiveness. We significantly improve the alignment score from 0.474 to 0.940 and achieve an average reduction of 16% in wirelength. Moreover, our method also demonstrates zero-shot transferability on unseen circuits. Code is publicly available at: https://github.com/Thinklab-SJTU/EDA-AI.

## 1 Introduction

In the very beginning stage of physical design in Electronic Design Automation (EDA), floorplanning (FP) plays a critical role. As a subsequent stage of hardware design  and logic synthesis , floorplanning provides a prototype for downstream tasks , ranging from power delivery network (PDN) design  to placement  & routing  (P&R), hence determining the upper bound of final PPA (Power, Performance, Area). Recognized as an NP-hard problem , FP establishesthe chip's physical layout by optimizing the position and shape of the major blocks to minimize interconnect lengths and ensure efficient silicon area utilization. As floorplanning technologies evolve, 3D FP with stacked layers emerges with more challenges. In particular, the cross-die module alignment becomes another pivotal factor in 3D FP [10; 11; 12]. For instance, vertical buses  for cross-die communication connect the aligned blocks spread among multiple dies . Another example is the Memory-on-Logic technology [12; 13; 14], partitioning the processor  into twoiers: memory tier and logic tier. The memory tier consists of memory blocks and customized intellectual property cores (IP cores) , while the logic tier contains other components, such as logic blocks. Blocks on different dies should be aligned together, enabling the communication established by bonding bumps or pads .

Existing works can be categorized into heuristic-based methods, analytical approaches, and learning-based methods. Heuristics-based methods [17; 18; 19; 20; 21] model the FP with a certain heuristic representation. To refine the current FP, they modify the heuristic representation and convert it to the corresponding FP through a decoding scheme. However, this implementation limits the flexibility to directly adjust the position of blocks. After a single modification, the entire FP result needs to be regenerated, incapable of making fine-grained adjustments. Moreover, the alignment constraints cannot be satisfied by simply incorporating alignment metrics into its heuristics. Analytical approaches [9; 22] compute the gradient of objectives w.r.t. block position and utilize gradient descent technique to optimize FP. However, the calculation of alignment is non-differentiable, making them inapplicable in 3D FP. Recently, with the emergence of Reinforcement Learning (RL), learning-based methods are promising in FP [23; 24; 25; 26; 27; 28; 29]. Among these approaches, [23; 24; 25] still retain traditional FP representation, thereby leading to the same issues encountered by heuristic methods. Conversely, [26; 27; 28; 29] focus on determining block positions in 2D scenarios. However, when directly implemented in 3D scenarios, these methods could result in 1) overlooking alignment requirements and 2) multi-die property. Specifically, in 2D FP, blocks are arranged exclusively on a single die and organized in a queue that represents the placing order of all blocks. However, in 3D scenarios, multiple queues exist due to the multi-die property, necessitating a layer decision mechanism to merge these queues and determine the comprehensive placing order. This is a critical issue, yet it remains insufficiently explored in current research. Additionally, current learning-based methods are 3) incapable of addressing the variable aspect ratio of modules. Characteristics of typical approaches are summarized in Table 1.

To address the aforementioned challenges, we propose **FlexPlanner**, a flexible deep-learning-based approach in hybrid action space with multi-modality representation for 3D FP. FlexPlanner directly outputs the final FP result, without the reliance on any heuristic representation. Under the Actor-Critic framework, the policy network consists of three sub-modules, responsible for determining the position, layer, and aspect ratio of blocks, spanning a hybrid action space. Empirical results demonstrate the effectiveness and significance of FlexPlanner. **The main contributions are highlighted as follows:**

* **First learning-based method to discard heuristic-based search in the 3D FP task.** We propose a novel learning-based method with flexible hybrid action space for 3D FP, simultaneously handling the position, aspect ratio, and cross-die alignment of blocks. Without relying on the heuristic-based search, FlexPlanner allows the position and aspect ratio of each block to be explored across a comprehensive spectrum, rather than be limited by the constraints of heuristic FP representation, thereby breaking through the upper bound of performance. And we propose an innovative strategy for more effectively addressing the alignment issue.
* **Tackle the non-trivial issue of dependency on heuristics by incorporating hybrid action space and multi-modality representation.** It is non-trivial to avoid the dependency on heuristics-based search in 3D FP due to the difficulty of modeling the complex solution space. Heuristics can only represent a subset of the entire solution space, resulting in limitations on the upper bound performance. To address this issue, we initially introduce three modalities, including vision, graph, and sequence, to comprehensively represent the state space. Additionally, we design a sophisticated policy network with hybrid action space and asynchronous layer decision mechanisms, enabling learning versatile properties such as position, aspect ratio, layer for each block in a 3D FP setting.

   Method & Type & AR & Aln & 3D & Med \\  PeF  & Analytical & ✗ & ✗ & N/A \\
3D-B\({}^{*}\)SA [17; 21] & Heuristics & ✗ & ✗ & ✓ & H \\ Wirennas-BBO & Heuristics & ✗ & ✗ & ✗ & V \\
3D-FBL  & Heuristics, RL & ✗ & ✗ & H, G \\ GraphPlace  & RL & ✗ & ✗ & ✗ & G \\ DeepPlace  & RL & ✗ & ✗ & ✗ & V, G \\ MaskPlace  & RL & ✗ & ✗ & ✗ & V \\ Ours & RL & ✗ & ✓ & ✓, G, S \\   

* AR: aspect ratio of blocks. All cross-dose block alignment. Model. Stability.
* H = Heuristics, V = Vision, G = Graph, S = Sequence.
* **First learning-based method to discard heuristic-based search in the 3D FP task.** We propose a novel learning-based method with flexible hybrid action space for 3D FP, simultaneously handling the position, aspect ratio, and cross-die alignment of blocks. Without relying on the heuristic-based search, FlexPlanner allows the position and aspect ratio of each block to be explored across a comprehensive spectrum, rather than be limited by the constraints of heuristic FP representation, thereby breaking through the upper bound of performance. And we propose an innovative strategy for more effectively addressing the alignment issue.
* **Tackle the non-trivial issue of dependency on heuristics by incorporating hybrid action space and multi-modality representation.** It is non-trivial to avoid the dependency on heuristics-based search in 3D FP due to the difficulty of modeling the complex solution space. Heuristics can only represent a subset of the entire solution space, resulting in limitations on the upper bound performance. To address this issue, we initially introduce three modalities, including vision, graph, and sequence, to comprehensively represent the state space. Additionally, we design a sophisticated policy network with hybrid action space and asynchronous layer decision mechanisms, enabling learning versatile properties such as position, aspect ratio, layer for each block in a 3D FP setting.

   Method & Type & AR & Aln & 3D & Med \\  PeF  & Analytical & ✗ & ✗ & ✗ & N/A \\
3D-B\({}^{*}\)SA [17; 21] & Heuristics & ✗ & ✗ & ✓ & H \\ Wirennas-BBO & Heuristics & ✗ & ✗ & ✗ & ✗ \\
3D-FBL-CB  & Heuristics, RL & ✗ & ✗ & ✗ & H, G \\ GraphPlace  & RL & ✗ & ✗ & ✗ & G \\ DeepPlace  & RL & ✗ & ✗ & ✗ & V, G \\ MaskPlace  & RL & ✗ & ✗ & ✗ & V \\ Ours & RL & ✗ & ✓ & ✓ & V, G, S \\   

Table 1: Characteristics of typical methods.

* **Zero-shot transferability.** Leveraging the advantage of the learning scheme and multi-modalities, FlexPlanner demonstrates the ability to exhibit zero-shot transferability on previously unseen circuits. This capability shows strengths in its efficiency, as it conserves substantial training resources when confronted with new IC cases.
* **SOTA experimental results with significant alignment improvement.** Within the learning framework, FlexPlanner achieves state-of-the-art performance on wirelength and alignment in 3D FP. Specifically, the average reduction in wirelength arrives at 16%, compared to previous works. Moreover, by effectively incorporating the alignment constraint, we achieve 0.940 on the alignment score, significantly surpassing the previous SOTA score of 0.474.

## 2 Preliminary and Formulation

**Floorplan.** The 2D floorplan task aims to determine the position and shape of each block given the block list, I/O port list, and netlist. Based on this, the 3D floorplan task is further required to place all blocks across multiple dies/layers. Each _die/layer_\(d\) is a rectangular region with width \(W\) and height \(H\), and all dies are of the same shape. Specifically, the block list is denoted as \(=\{b_{1},b_{2},,b_{n}\}\) with \(n\) blocks, where each _block_\(b_{i}\) is a rectangle with width \(w_{i}\), height \(h_{i}\), and area \(a_{i}=w_{i} h_{i}\). The bottom-left coordinate of block \(b_{i}\) is denoted as \((x_{i},y_{i})\), and the layer where the \(b_{i}\) is located is denoted as \(z_{i}\). There are two types of blocks: _hard block_ and _soft block_. For a _hard block_, its aspect ratio \(_{i}=}{h_{i}}\) is fixed. For a _soft block_, \(_{i}\) can vary between \([_{},_{}]\), while the area must always satisfy \(a_{i}=w_{i} h_{i}\). Additionally, we denote the I/O port list as \(=\{t_{1},t_{2},,t_{m}\}\) with \(m\)_ports_2. Each _port_\(t_{j}\) is viewed as a point with a pre-determined position \((x_{j},y_{j},z_{j})\), where \((x_{j},y_{j})\) is the coordinate, and \(z_{j}\) is the layer index. _Netlist_ is defined as a set consisting of all nets, where each _net_ is a set of blocks and ports, representing the interconnections. Since the layer \(z_{i}\) of block \(b_{i}\) is pre-assigned, we only need to determine the coordinate \((x_{i},y_{i})\) and the aspect ratio \(_{i}\) for all blocks to optimize the following objectives:

**1) Alignment.** Given two blocks \(b_{i},b_{j}\) on different layers, _alignment_ evaluates the overlap/intersection area between them on the common projected 2D plane. We define the alignment score \((i,j)\):

\[_{x}(i,j)&=(0, (x_{i}+w_{i},x_{j}+w_{j})-(x_{i},x_{j})),\\ _{y}(i,j)&=(0,(y_{i}+h_{i}, y_{j}+h_{j})-(y_{i},y_{j})),\\ (i,j)&=(1,_{x }(i,j)_{y}(i,j)}{_{m}(i,j)}),\] (1)

where \(_{m}(i,j)\) is the required minimum alignment area between block \(b_{i}\) and \(b_{j}\). The total alignment score should be _maximized_ to satisfy the alignment requirement. \((b_{i},b_{j})\) forms an alignment pair if \(_{m}(i,j)>0\), and \(b_{i},b_{j}\) are mutual _alignment partners_.

Cross-die block alignment is common in 3D FP [11; 13; 14]. Taking two blocks in different dies as an example, vertical buses  or bonding bumps/pads  are employed for communication, which requires capabilities for cross-die block alignment. That is, considering their projection onto a 2D plane, the related blocks must exhibit some minimum intersecting region, denoted as \(_{m}(i,j)\).

**2) HPWL and 3) Overlap.** Half Perimeter Wire Length (HPWL) is an approximate metric of wirelength. It can be computed much more efficiently, as accurate wirelength can be accessed only after the time-consuming routing stage. The summation of HPWL should be _minimized_:

\[_{}(_{m_{i}}x_{i} ^{c}-_{m_{i}}x_{i}^{c}+_{m_{i}}y_{i}^{ c}-_{m_{i}}y_{i}^{c}),\] (2)

where \(m_{i}\) is either a block or port in net and \(x_{i}^{c}\) is the center x-coordinate. For a block, \(x_{i}^{c}=x_{i}+}{2}\), and for a port, \(x_{i}^{c}=x_{i}\). Given two blocks \(b_{i},b_{j}\) on the same die, the overlap area between them should be _minimized_ (detailed calculation is given in Alg. 4 in Appendix G.1). Besides, all blocks should be placed within the fixed outline.

## 3 Methodology

**Overview.** The 3D floorplanning task can be formulated as an episodic Markov Decision Process. As shown in Fig. 1, pipeline of our approach mainly includes state, hybrid action space, policy network and critic network. State \(s_{t}\) consists of three modalities, including vision, graph, and sequence. Action \(a_{t}\) is represented as \((x,y,z,)\), where position \((x,y,z)\) are discrete variables and aspect ratio \(\) is a continuous variable. These properties form a hybrid action space. Under the Actor-Critic framework, critic \(V_{}(s_{t})\) evaluates the current state. Policy network \(_{}(a_{t}|s_{t})\) determines the 2D coordinate \((x_{t},y_{t})\) of current block \(b_{t}\), the layer \(z_{t+1}\) to access next block \(b_{t+1}\), and the aspect ratio \(_{t+1}\) of \(b_{t+1}\). To explicitly impose constraints on the action space, masks are applied to the probability matrix of block positions. This process filters out invalid coordinates that violate constraints, such as non-alignment, overlap, or out-of-bounds locations. We respectively introduce the multi-modalities, layer decision, and reward function design in Sec. 3.1, Sec. 3.2 and Sec. 3.3.

### Multi-Modality Representation of 3D Floorplanning

The state space contains three modalities: FP vision, netlist graph, and block placing sequence.

#### 3.1.1 Vision Modality

It represents current floorplanning through images. We utilize four vision masks to depict chip layout.

**Alignment Mask.**\(f_{a}^{W H}\) (\(\) is the field of natural number) is a matrix to evaluate the alignment area between blocks \(b_{i}\) and its alignment partner \(b_{j}\). If \(b_{j}\) has already been placed, \(f_{a}[x,y]\) is the intersection area on a 2D projected plane if \(b_{i}\) is placed at \((x,y)\). If \(b_{j}\) has not been placed yet, the

Figure 1: Pipeline of FlexPlanner. Under the Actor-Critic framework, taking the multi-modality representation as input, the policy network consists of three sub-modules, responsible for determining the position, layer, and aspect ratio of blocks. Alignment mask and position mask are incorporated to filter out invalid positions where constraints (alignment, non-overlap, etc.) are not satisfied.

Figure 2: Demonstration of alignment. In (a), the light blue region will be occupied by the block to place, and the dark blue region is occupied by its alignment partner block which has been placed. By sliding block to place across the plane, we obtain the alignment values at each position along the X and Y dimensions, as shown in (b) and (c). Final alignment can then be calculated through element-wise matrix multiplication, as illustrated in (d). Only \((x,y)\) satisfying \(_{x}_{y} _{m}\) are valid positions shown in (e), and this binary mask can be incorporated to filter out invalid positions.

alignment mask of \(b_{i}\) will be set to a matrix full-filled with \(_{m}(i,j)\). The native approach has the complexity \((WH)\). However, when \(W\) or \(H\) is large, it has a low efficiency. We design an efficient alignment mask generation algorithm with _meshgrid_ operation, which only iterates in regions causing projection overlap between these blocks and harnessing the power of parallel computing, thus reducing the complexity to \((wh)\) namely \((1)\). Demonstration of alignment and details of the algorithm are shown in Fig. 2 and Alg. 1. Alignment mask is also utilized to filter out the positions that do not satisfy the alignment constraint.

**Canvas Mask.** Canvas mask \(f_{c}^{|| W H}\) is a global observation of current chip layout. The canvas mask is initialized to all zeros. After placing a block \(b\) at each step, we modify the canvas mask with \(f_{c}[z,x:x+w,y:y+h]+=1\). Based on the canvas mask, we can implement a fast calculation of the total overlap of chip layout, shown in Alg. 4 in Appendix G.1.

**Wire Mask & Position Mask .** Wire mask \(f_{w}^{W H}\) is a matrix for how HPWL will increase if a block is placed at the position. It records the increase of HPWL by placing the current block to all candidate positions. Position mask \(f_{p}\{0,1\}^{W H}\) indicates available positions for current block to place without overlap or out-of-boundary. \(1\) implies this position is feasible to place the block.

Overall, in step \(t\), given current block \(b_{t}\), we concatenate \(f_{a}^{(t)},f_{c}^{(t)}\), \(f_{w}^{(t)},f_{p}^{(t)}\). We also incorporate masks \(f_{w}^{(t+1)},f_{p}^{(t+1)}\) of header block in FIFO queue \(q\) (introduced in sequence modality in Sec. 3.1.2) in each die, which represent all possible choices for next block in step \(t+1\), providing policy with future horizon. All of these input masks constitute the floorplanning vision modality.

#### 3.1.2 Graph and Sequence Modality

**Graph Modality.** Given a netlist, we convert it to a graph \(G(V,E)\), where \(V\) is the set of vertices and \(E\) is the set of edges. For two blocks \(b_{i},b_{j}\) within a net, we add edges \(e_{ij},e_{ji}\) between vertex pair \((v_{i},v_{j})\). For the vertex feature, We select \((bid,x,y,z,w,h,a,p)\), where \(bid\) is the block index and \(p\) indicates whether this block has already been placed or not. Considering each block has a placing order showing the property as a sequence, it is natural to utilize positional encoding  to model this feature. Furthermore, we employ a Graph Attention Network  to produce embeddings of graph and nodes, representing the logical connection among blocks.

**Sequence Modality.** Given a die \(d_{i}\), blocks in \(d_{i}\) are sorted by their area in descending order, forming a FIFO (first in, first out) queue \(q_{i}\). Thus, the block placing order for each die is pre-determined, and each queue can be viewed as a sequence. Combined with block features, we enhance and re-organize the multi-die sequence \(^{|| L C}\), where \(L\) is the maximum number of blocks in a single die, \(C\) is the number of features. We select \((bid,x,y,z,w,h,a,p)\) as sequence features. The sequence modality provides the model with global observation of entire block placing order, and is employed in the asynchronous layer decision discussed in Sec. 3.2.

``` Current block \(b_{i}\), alignment partner \(b_{j}\), chip width and height \(W,H\) Output: Alignment mask \(f_{a}^{(t)}\) for block \(b_{i}\) \(x_{s}=(0,x_{j}-w_{i})\), \(x_{e}=(x_{j}+w_{j},W)\) \(y_{s}=(0,y_{j}-h_{j})\), \(y_{e}=(y_{j}+h_{j},H)\) \(_{i}=(x_{s},x_{e})\), \(_{i}=(y_{s},y_{e})\) \(_{i},_{i}=meshofid(_{i},_{i})\) \(_{i}=_{i},\ _{i}=_{i}+w_{i}\) \(_{j}=x_{j}\), \(_{j}=x_{j}+w_{j}\) // broadcast to a matrix \(=where(_{i}>_{j},_{i},_{j})\) \(=where(_{i}<_{j},_{i},_{j})\) \(f_{ax}^{(i)}=(0,-)\) // we omit y-dimension due to page limitation \(f_{a}^{(i)}=zeros(W,H),\ f_{a}^{(i)}[_{i},_{i}]=f_{ax}^{(i) } f_{ay}^{(i)}\) ```

**Algorithm 1**Alignment mask generation.

During the training process under asynchronous block placing, on one hand, the entire block placing order could vary hugely and become unstable due to the sparsity of the reward, making it non-trivial for position decider to determine the positions of blocks. On the other hand, the layer decision module could converge too fast to mode collapse (a fixed placing order leading to poor quality), empirically degenerating to synchronous die-by-die block placing. In our analysis, it is the short forward horizon leading to this problem. Since policy is only able to sense current and next states, it lacks the global receptive field of entire placing order.

To address these issues, we enhance the representation with the sequence modality, and employ Transformer  to extract global placing order feature. Given the multi-die sequence feature \(^{|| L C}\), self-attention is computed. \(\) is viewed as the source sequence input with length \(L\). The memory \(^{|| L L}\), output of self-attention of \(\) is given by :

\[=(()+),= (()+),\] (3)

where \(\) is the multi-head self-attention, \(\) is layer normalization, and \(\) is the feed-forward network. Next, cross-attention is applied on \(\) and current block feature \(_{k}\). The single block feature \(_{k}^{1 C}\) is treated as the target sequence with length \(1\), serving as the query vector. The output of cross-attention \(^{|| 1 C}\) is :

\[=((_{k},,)+ _{k}),=(()+),\] (4)

where \((,,)\) denotes multi-head attention. Finally, the next layer decision probability vector can be further computed through linear projection and \(\) operation.

### Reward Function with Local Advantage and Global Baseline

```
0: (Partial) Alignment score \(\), (partial) overlap \(o\), (partial) \(\), and corresponding weight \(w_{a},w_{o},w_{t}\)
0: Reward \(r\) for each step for\(t\) from \((episode)\) to 1do if\(t\) is the end of an episodethen \(r_{t}=w_{a}_{t}-w_{o} o_{t}-w_{t}_{t}\) \(b=r_{t}\) else \(r_{t}=w_{a}(_{t}-_{t-1})-w_{o}(o_{t}-o_{t-1} )-w_{l}(_{t}-_{t-1})+b\) ```

**Algorithm 2**Reward function with local advantage and global baseline.

In 3D floorplanning task, final wirelength, overlap and alignment can only be accessed at the end of each episode, leading to a sparse reward. GraphPlace  uses this sparse reward design, where rewards at intermediate steps are all zeros. DeepPlace  adopts it with additional intrinsic reward via Random Network Distillation . MaskPlace  introduces a dense reward scheme based on partial HPWL, which is calculated only on the currently placed blocks at each step. However, in two former methods [26; 27], they fail to accurately sense the intermediate quality through reward, and in MaskPlace , only difference between local adjacent steps is involved, lacking the global view of the whole episode. As a result, all these reward designs demonstrate relatively poor performances, especially with the complicated hybrid action space consisting of position, layer and aspect ratio.

To alleviate this problem, we design a novel reward function with local advantage and global baseline. We define _local advantage_ as the difference of metric between two adjacent steps, and _global baseline_ as the overall metric at the end of an episode. With local advantage, our model has the ability to acquire current state is whether better or worse than the previous. Global baseline depicts the overall quality of the final floorplanning result. It is also essential for asynchronous layer decision module to avoid early convergence and degeneration to poor die-by-die synchronous block placing order, shown in Sec. 4.4 and Fig. 5(b). Details of reward design is shown in Alg. 2.

### Flexible RL with Hybrid Action Space for 3D Floorplanning

We employ RL with a hybrid action space to address the 3D FP task. The state space consists of three modalities, including floorplanning vision, netlist graph and sequence of block placing order. The hybrid action space is formulated as \(\), with \(,,\) as discrete sets and \(\) as a continuous set. In each step \(t\), the policy outputs three distributions: **1)** a discrete probability distribution for 2D position \((x_{t},y_{t})\) of current block \(b_{t}\), **2)** a discrete probability distribution to determine the layer \(z_{t+1}\) for accessing next block \(b_{t+1}\), and finally **3)** the mean value and standard deviation of a contiguous Gaussian distribution to determine the aspect ratio \(_{t+1}\) for \(b_{t+1}\). The reason for action \(a_{t}\) containing the layer and aspect ratio for next step \(t+1\) instead of \(t\) is that: after the execution of \(a_{t}\), next state \(s_{t+1}\) can be generated only after block \(b_{t+1}\) to place at step \(t+1\) and its shape have already been determined, since \(b_{t+1}\) and its shape \((w_{t+1},h_{t+1})\) are involved in the calculation of alignment mask and wire mask. To guarantee adherence to the specified non-overlap and alignment constraints, position mask \(f_{p}\) and alignment mask \(f_{a}\) are incorporated in 2D position decision. Only \((x,y)\) satisfying \(f_{p}[x,y]=1\) and \(f_{a}[x,y]_{m}\) are considered as valid positions, where \(_{m}\) is the required minimum alignment area between current block and its alignment partner. Finally, without the reliance on conventional heuristic FP representation, our approach exhibits more flexibility to directly solve position, aspect ratio and cross-die alignment for blocks.

We select the Actor-Critic  framework and Hybrid Proximal Policy Optimization [35; 36] algorithm. The objective function of our hybrid policy \(_{}(a_{t}|s_{t})\) can be formulated as:

\[L()=_{k=1}^{3}_{k}}_{t}[(r _{t}^{(k)}()_{t},(r_{t}^{(k)}(),1- ,1+)_{t})],\] (5)

where \(k=1,2,3\) represents position, layer and aspect ratio decision. \(_{k}\) is the weight for each clip loss. \(r_{t}^{(k)}()\) is the probability ratio \((a_{t}^{(k)}|s_{t})}{_{_{old}}(a_{t}^{(k)}|s_{t})}\). \(_{t}\) denotes the generalized advantage estimation (GAE) , and \(G_{t}=_{t}+V_{t}\) is the cumulative discounted reward [37; 38]. \(V_{t}\) is the estimated state value from critic network \(V_{}(s_{t})\), and critic network is updated with minimizing Mean Squared Error (MSE) \(L()=_{}}_{t}[(G_{t}-V_{}(s_{t}))^{2}]\). Entropy of each action distribution is also added as a regularization term for exploration encouragement. Training algorithm is shown in Appendix G.2, and details of model architecture are shown in Appendix D.

## 4 Experiment and Analysis

### Evaluation Protocol and Benchmark

We evaluate the performance of FlexPlanner and other typical methods on public benchmark **MCNC**3 and **GSRC**4 shown in Table 7 in Appendix B. The floorplanning region is set to square region. I/O ports are projected to the fixed outline, and their positions are kept unchanged. Aspect ratio of each block can vary in range \([,2]\). Each experiment is run for five times with different seeds. More implementation details and hyper-parameter settings can be found in Appendix C.

   CM & 3D-B*-SA  & RL-CBL  & Wiwemask-BBO  & GraphPlace  & DeepPlace  & MaskPlace  & Ours \\  ami3 & 0.550\(\)0.058 & 0.132\(\)0.038 & 0.179\(\)0.091 & 0.207\(\)0.067 & 0.286\(\)0.051 & 0.300\(\)0.017 & **0.905\(\)0.017** \\ ami49 & 0.438\(\)0.099 & 0.107\(\)0.043 & 0.222\(\)0.082 & 0.265\(\)0.063 & 0.180\(\)0.056 & 0.218\(\)0.052 & **0.955\(\)0.010** \\ n10 & 0.383\(\)0.167 & 0.241\(\)0.076 & 0.211\(\)0.004 & 0.197\(\)0.049 & 0.235\(\)0.080 & 0.354\(\)0.066 & **0.917\(\)0.012** \\ n30 & 0.537\(\)0.159 & 0.108\(\)0.040 & 0.288\(\)0.051 & 0.233\(\)0.039 & 0.287\(\)0.074 & 0.511\(\)0.067 & **0.920\(\)0.024** \\ n50 & 0.626\(\)0.158 & 0.048\(\)0.016 & 0.290\(\)0.053 & 0.378\(\)0.120 & 0.343\(\)0.064 & 0.764\(\)0.002 & **0.900\(\)0.004** \\ n100 & 0.131\(\)0.051 & 0.016\(\)0.008 & 0.195\(\)0.034 & 0.279\(\)0.050 & 0.332\(\)0.073 & 0.575\(\)0.046 & **0.961\(\)0.017** \\ n200 & 0.033\(\)0.025 & 0.013\(\)0.009 & 0.182\(\)0.031 & 0.360\(\)0.060 & 0.387\(\)0.039 & 0.534\(\)0.041 & **0.923\(\)0.020** \\ n300 & 0.009\(\)0.009 & 0.005\(\)0.005 & 0.205\(\)0.038 & 0.383\(\)0.023 & 0.399\(\)0.031 & 0.533\(\)0.023 & **0.965\(\)0.010** \\  Avg. & 0.338 & 0.084 & 0.222 & 0.288 & 0.306 & 0.474 & **0.940** \\   

Table 2: Alignment score comparison among baselines and our method. The higher the alignment score, the better, and the optimal results are shown in **bold.** C/M means Circuit/Method.

   CM & 3D-B*-SA  & RL-CBL  & Wiwemask-BBO  & GraphPlace  & DeepPlace  & MaskPlace  & Ours \\  ami3 & 85.165\(\)5.563 & 85.033\(\)1.447 & 66.87\(\)3.531 & 82.685\(\)6.572 & 79.457\(\)6.885 & 62.125\(\)5.829 & **58.339\(\)1.984** \\ ami49 & 1.407\(\)3.658\(\)6.043 & 1.338\(\)1.219\(\)5.565 & 1.100\(\)8.91\(\)5.49 & 14.455\(\)8.722 & 4.068\(\)4.186 & 13.260\(\)5.454 & 12.18\(\)0.945 & **76.721\(\)12.78** \\ n10 & 35.20\(\)115 & 34.80\(\)1.132 & 33.04\(\)6.36 & 35.20\(\)6.869 & 34.971\(\)8.17 & 33.68\(\)1.966 & **29.781\(\)75** \\ n30 & 101.672\(\)2.626 & 105.796\(\)1.344 & 87.198\(\)1.862 & 94.87\(\)1.860 & 97.923\(\)1.392 & 6.269\(\)1.764 & **83.962\(\)1.030** \\ n50 & 132.42\(\)31.323 & 156.13\(\)4.039 & 111.87\(\)8.337 & 31.960\(\)2.219 & 126.91\(\)2.865 & 113.145\(\)4.047 & **105.839\(\)9.16** \\ n100 & 233.38\(\)19.123 & 27

### Comparison with Baselines

Methods including heuristic-based and learning-based approaches are selected as baselines, and the implementation details are shown in Appendix E. Average alignment score and total HPWL are employed as evaluation metrics. Results are shown in Table 2 and 3. For alignment score, our approach achieves 0.940, significantly surpassing the second-best method which scores 0.474. For HPWL, our approach achieves an average reduction of 16%. Our method reduces HPWL to 249,053, and the second-best method (Wiremask-BBO) reduces it to 296,791. However, it only achieves 0.222 for alignment score, failing to effectively tackle the alignment constraint, empirically showing that our approach is capable of address alignment and HPWL simultaneously. Demonstration of 3D floorplanning results by our method are also shown in Fig. 3 and Fig. 4. We also compare performances on overlap, out-of-bound and runtime, shown in Appendix F. Capability and flexibility of our approach to address pre-placed modules (PPMs) are also demonstrated in Appendix F.5.

Figure 4: Visualization of cross-die block alignment on circuit n50. Two blocks with the same index forms an alignment pair. For a pair with block \(i,j\), we calculate individual alignment score \((i,j)\) according to Eq. 1. Green means these two blocks are aligned (\((i,j) 0.5\)) while red means not aligned (\((i,j)<0.5\)). Total alignment score is calculated according to Alg. 3 in Appendix G.1. It demonstrates that our method achieves much better alignment score than other baselines.

Figure 3: Our 3D floorplan result. Two blocks with the same index and the same color on different dies form an alignment pair, which roughly locate on the same positions and share a 2D common projected area. Gray blocks mean they do not have alignment partners.

### Transferable 3D Floorplanning

The zero-shot transferability of our method is also evaluated. We firstly train the model on circuit n100, and directly test the performance without any fine-tuning. In Table 4, ratio is calculated between running inference and training on corresponding circuit. It demonstrates that our model exhibits a good zero-shot transferability, on either smaller or larger cases. The transferability is also demonstrated through the training curves between fine-tuning (based on pre-trained weights of circuit n100) and training from scratch. In Fig. 5, through fine-tune technique, better or similar performance can be achieved, conserving substantial training resources.

### Ablation Studies

We ablate effectiveness of each component in our approach, including asynchronous layer decision, multi-modality representation and reward function. Experiments on circuit n100 are shown in Table 5. Removing the alignment mask leads to a huge drop of alignment score, from 0.961 to 0.349. We also evaluate the effectiveness of incorporating the alignment mask as an input feature and a constraint. In Fig. 5(a), 'input' refers to the scenario where we feed the alignment mask as input to the model, while 'constr.' indicates that the alignment mask is utilized to filter out invalid positions that do not satisfy the alignment constraint. As the input, alignment mask plays a critical role to effectively capture the alignment information. As the constraint, it reduces the action space and accelerates training process.

Shown in the column'sync' in Table 5, fixed synchronous die-by-die block placing order performs worse than asynchronous layer decision, since in the latter, more flexibility is provided to plan the entire placing order. Our reward design, incorporating the local advantage and global baseline, is crucial for fully leveraging the asynchronous layer decision mechanism. In Fig. 5(b), with the guidance of our reward, the layer decision module keeps active to learn an optimal placing order. However, with other reward design schemes, it is faced with either rapid convergence to the degeneration of synchronous die-by-die decision-making, or unstable oscillation. Under reward function 'diff' in MaskPlace , only the difference between two consecutive steps is focused, while the global reward is disregarded, leading to rapid convergence to the degeneration of synchronous die-by-die layer decision. Under reward function'sparse' in GraphPlace , rewards for intermediate steps are all zeros, and only the reward of the final step is non-zero. The policy lacks the modeling of local information, resulting in its inability to accurately assess the influence of current action on the entire decision-making process.

   Metric/Circuit & ami33 & ami49 & n10 & n30 & n50 & n200 & n300 \\   & value & 0.859 & 0.894 & 0.875 & 0.947 & 0.970 & 0.877 & 0.908 \\  & ratio & 0.949 & 0.936 & 0.954 & 1.029 & 1.000 & 0.950 & 0.941 \\   & value & 59,923 & 835,170 & 30,720 & 87,784 & 111,039 & 322,242 & 462,780 \\  & ratio & 1.027 & 1.095 & 1.032 & 1.046 & 1.049 & 1.019 & 1.008 \\   

Table 4: Zero-shot transferability evaluation (training on circuit n100).

Figure 5: Training curve between fine-tune (based on circuit n100) and training from scratch.

   Metric/Method & sync & w/o ain & w/o graph & w/o seq & sparse rew & diff rew & Ours \\  Alignment & 0.850\(\)0.042 & 0.349\(\)0.026 & 0.874\(\)0.027 & 0.860\(\)0.021 & 0.840\(\)0.018 & 0.721\(\)0.054 & **0.961\(\)0.017** \\
1HPWL & 185,624\(\)1.822 & 187,617\(\)3.096 & 185,079\(\)1.681 & 186,005\(\)8.46 & 189,219\(\)1.164 & 190,384\(\)2.192 & **176,639\(\)1.001** \\   

Table 5: Ablation study on n100. sync: synchronous die-by-die placing. w/o aln: remove alignment mask in vision modality. w/o seq: remove sequence modality. w/o graph: remove graph modality. sparse rew: the same reward as GraphPlace . diff rew: the same reward as MaskPlace .

## 5 Related Works

Classical methods in FP can be roughly categorized into heuristics and analytical approaches. The former typically models FP with a certain representation, such as B*-tree , Corner Block List  and Sequence Pair , based on which heuristic algorithm (especially Simulated Annealing ) is utilized to search for an optimal solution. Finally, the representation is converted to corresponding FP result via a decoding scheme. Apart from the heuristics, analytical approaches [9; 22; 41] regard the FP problem as an electrostatic system [42; 43]. They compute the gradient of objective functions w.r.t. block coordinates, and utilize gradient descent-based algorithm to optimize the solution.

**RL-based floorplanning approaches.** Recently, floorplanning also attracted attention from the reinforcement learning communities. For instance, [23; 24; 25] incorporate traditional FP representation and RL. Among these methods, at each step, the policy network either 1) decides whether to accept the randomly perturbed state or not [23; 25] or 2) determines how to perturb the current state . [26; 27; 28] primarily focus on making decisions about block position in 2D scenarios with RL. GraphPlace  and DeepPlace  incorporate graph and vision as representation. MaskPlace  employs visual representation, and designs a dense reward function based on partial HPWL.

**RL with hybrid action space.** Common RL can be categorized into discrete and continuous action spaces. However, in certain scenarios, besides the discrete action, we need to make decisions regarding its parameters, typically residing in continuous spaces . Consequently, it gives rise to a hybrid action space.  proposes to discretize the continuous portion, which creates a large discrete set and sacrifices fine-grained control. Alternatively, [45; 46; 47; 48] convert the discrete action selection into a continuous space with an actor network and employ a DQN-based [49; 50] algorithm for training, but found to be unstable and inefficient.  suggests to use multiple policy heads consisting of one for discrete actions and the others for corresponding continuous parameters separately.  proposes to encode the hybrid action space to a continuous space with GAE .

## 6 Conclusion

In this paper, we propose FlexPlanner, a flexible learning-based method in hybrid action space with multi-modality representation for 3D floorplanning task. It involves no reliance on heuristic-based search, thus achieves better flexibility to tackle position, aspect ratio and cross-die alignment for blocks under complex constraints. FlexPlanner outperforms baselines in alignment score and wirelength, and it also demonstrates zero-shot transferability on unseen circuits. This paper also has some _limitations_ for future work: further optimization in 3D FP could be involved such as thermal optimization. Our method has no potential harm to the public society at the moment.

Figure 6: (a) Effectiveness of the alignment mask. As the input feature, it plays a critical role in capturing the alignment information. As the constraint (constr.), it reduces the action space and accelerates the training process. (b) Effectiveness of rewards on layer decision, shown in circuit n100 with episode length \(L=100\) and \(||=2\) dies. \(z_{t}\) is the determined layer index at step \(t\), and we note \(Z=_{t=1}^{L/2}z_{t}\). \(Z 0\) or \(Z L/2\) means degeneration to die-by-die synchronous layer decision (almost all die 0 or 1 in the first half episode).