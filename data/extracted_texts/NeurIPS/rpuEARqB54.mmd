# On the Role of Noise in the Sample Complexity of Learning Recurrent Neural Networks: Exponential Gaps for Long Sequences

On the Role of Noise in the Sample Complexity of Learning Recurrent Neural Networks: Exponential Gaps for Long Sequences

Alireza F. Pour

Cheriton School of Computer Science

University of Waterloo

a2fathol@uwaterloo.ca

&Hassan Ashtiani

Department of Computing and Software

McMaster University

zokaeiam@mcmaster.ca

###### Abstract

We consider the class of noisy multi-layered sigmoid recurrent neural networks with \(w\) (unbounded) weights for classification of sequences of length \(T\), where independent noise distributed according to \((0,^{2})\) is added to the output of each neuron in the network. Our main result shows that the sample complexity of PAC learning this class can be bounded by \(O(w(T/))\). For the non-noisy version of the same class (i.e., \(=0\)), we prove a lower bound of \((wT)\) for the sample complexity. Our results indicate an exponential gap in the dependence of sample complexity on \(T\) for noisy versus non-noisy networks. Moreover, given the mild logarithmic dependence of the upper bound on \(1/\), this gap still holds even for numerically negligible values of \(\).1

## 1 Introduction

Recurrent Neural Networks (RNNs) are effective tools for processing sequential data. They are used in numerous applications such as speech recognition (Graves et al., 2013), computer vision (Karpathy and Fei-Fei, 2015), translation (Sutskever et al., 2014), modeling dynamical systems (Hardt et al., 2018) and time series (Qin et al., 2017). Recurrent models allow us to design classes of predictors that can be applied to (i.e., take input values from) sequences of arbitrary length. For processing a sequence of \(T\) elements, a predictor \(f\) (e.g., a neural network) "consumes" the input elements one by one, generating an output at each step. This output is then used in the next step (as another input to \(f\) along with the next element in the input sequence). Defining recurrent models formally takes some effort, and we relegate it to the next sections. In short, the function \(f\) is (recursively) applied \(T\) times in order to generate the ultimate outcome.

Let us fix a base class \(_{w}\) of all multi-layered feed-forward sigmoid neural networks with \(w\) weights. We can create a recurrent version of this class, which we will denote by \([_{w},T]\), for classifying sequences of length \(T\). One can study the sample complexity of PAC learning \([_{w},T]\) with respect to different loss functions. Koiran and Sontag (1998) studied the binary-valued version of this class by applying a threshold function at the end, and proved a lower bound of \((wT)\) for its VC dimension.

There has also been efforts for proving upper bounds on the sample complexity of PAC learning \([,T]\) for various base classes \(\) and different loss functions. Given the above lower bound, a gold standard has been achieving a linear dependence on \(T\) in the upper bound. Koiran and Sontag (1998) proved an upper bound of \(O(w^{4}T^{2})\) on the VC dimension of \([_{w},T]\) discussed above. More recent papers have considered the more realistic setting of classification with continuous-valuedRNNs, e.g., by removing the threshold function and using a bounded Lipschitz surrogate loss. In this setting, Zhang et al. (2018) proved an upper bound of \((T^{4}w\|W\|^{O(T)})\) on the sample complexity2 where \(\|W\|\) is the spectral norm of the network. Chen et al. (2020) improved over this result by proving an upper bound of \((Tw\|W\|^{2}\{,\|W\|^{O(T)}\})\). These bounds get close to the gold standard when the spectral norm of the network satisfies \(\|W\| 1\).

The above upper bounds are proved by simply "unfolding" the recurrence, effectively substituting the recurrent class REC[\(_{w},T\)] with the (larger) class of \(T\)-fold compositions \(_{w}_{w}_{w}\). These unfolding techniques do not exploit the fact that the function \(f\) (that is applied recursively for \(T\) steps to compute the output of the network) is fixed across all the \(T\) steps. Consequently, the resulting sample complexity has (super-)linear dependence on \(T\). Therefore, we would need a prohibitively large sample size for training recurrent models for classifying very long sequences. Nevertheless, this dependence is inevitable in light of the of lower bound of Koiran and Sontag (1998). Or is it?

In this paper, we consider a related class of _noisy_ recurrent neural networks, REC[\(}_{w}^{},T\)]. The hypotheses in this class are similar to those in REC[\(_{w},T\)], except that outputs of (sigmoid) activation functions are added with independent Gaussian random variables, \((0,^{2})\). Our main result demonstrates that, remarkably, the noisy class can be learned with a number of samples that is only logarithmic with respect to \(T\).

**Theorem 1** (Informal version of Theorem 15).: _The sample complexity of PAC learning the class REC[\(}_{w}^{},T\)] of noisy recurrent networks with respect to ramp loss is \((w(T/))\)._

One challenge of proving the above theorem is that the analysis involves dealing with _random_ hypotheses. Therefore, unlike the usual arguments that bound the covering number of a set of deterministic maps with respect to the \(_{2}\) distance, we study the covering number of a class of random maps with respect to the total variation distance. We then invoke some of the recently developed tools in Fathollah Pour and Ashtiani (2022) for bounding these covering numbers. Another challenge is deviating from the usual "unfolding method" and exploiting the fact that in recurrent models a _fixed_ function/network is applied recursively.

The mere fact that learning REC[\(}_{w}^{},T\)] requires less samples compared to its non-noisy counterpart is not entirely unexpected. For classification of long sequences, however, the sample complexity gap is quite drastic (i.e., exponential). We argue that a logarithmic dependency on \(T\) is actually more realistic in practical situations: for finite precision machines, one can effectively break the \((T)\) barrier even for non-noisy networks. To see this, let us choose \(\) to be a numerically negligible number (e.g., smaller than the numerical precision of our computing device). In this case, the class of noisy and non-noisy networks become effectively the same when implemented on a device with finite numerical precision. But then our upper bound shows a mild logarithmic dependence on \(1/\).

One caveat in the above argument is that the lower bound of Koiran and Sontag (1998) is proved for the 0-1 loss and perhaps not directly comparable to the setting of the upper bound which uses a Lipschitz surrogate loss. We address this by showing a comparable lower bound in the same setting.

**Theorem 2** (Informal version of Theorem 10).: _The sample complexity of PAC learning REC[\(_{w},T\)] with ramp loss is \((wT)\)._

In the next section we introduce our notations and define the PAC learning problem. We state the lower bound in Section 3, and the upper bound in Section 5. Sections 6, 7, and 8 provide a high-level proof of our upper bound.

**Additional Related Work.** Due to space constraints, we postpone the discussion of some additional related work to Appendix 9.

## 2 Preliminaries

### Notations

\(\|x\|_{1},\|x\|_{2}\), and \(\|x\|_{}\) denote the \(_{1},_{2}\), and \(_{}\) norms of a vector \(x^{d}\) respectively. We denote the cardinality of a set \(S\) by \(|S|\). The set of natural numbers smaller or equal to \(m\) is represented by 

[MISSING_PAGE_FAIL:3]

**Definition 6** (Recurrent Application of a Function).: _Let \(U=[u^{(0)} u^{(i)} u^{(T-1)}]^{p T}\) be a sequence of inputs of length \(T\), where \(u^{(i)}^{p}\) denotes the \(i\)-th column of \(U\) for \(0 i T-1\). Let \(f\) be a (random) function from \(^{s}\) to \(^{q}\), where \(s=p+q-1\). Moreover, define \(f^{R}(U,0)=f(_{q-1}&u^{(0)} ^{})\). Then, for any \(1 t T-1\), the recursive application of \(f\) is denoted by \(f^{R}:^{p T}[T-1]^{q}\) and is defined as \(f^{R}(U,t)=f((f^{R}(U,t-1 ))&u^{(t)}^{})\)._

Now we are ready to define the (recurrent) hypothesis class REC\([,T]\). Each hypothesis in this class takes a sequence \(U\) of input vectors, and applies a function \(f\) recurrently on the elements of this sequence. The final output will be a real number. We give the formal definition in the following; also see Figure 1 for a visualization.

**Definition 7** (Recurrent Class).: _Let \(s,p,q\) such that \(s=p+q-1\). Let \(\) be a class of functions from \(^{s}\) to \(^{q}\). The class of recurrent models with length \(T\) that use functions in \(\) (which we denote by recurring class) as their recurring block is defined by_

\[,T=\{h:^{p T} h (U)=(f^{R}(U,T-1)),f\}\]

For example, REC[MNET[\(p_{0},p_{k},w\)],T\) is the class of (real-valued) recurrent neural networks with length \(T\) that use MNET[\(p_{0},p_{k},w\)] as their recurring block. We say that REC[MNET[\(p_{0},p_{k},w\)],T\) is _well-defined_ if MNET[\(p_{0},p_{k},w\)] is well-defined and also the input/output dimensions are compatible (i.e., \(p_{0} p_{k}\)).

### PAC learning with ramp loss

In this section we formulate the PAC learning model for classification with respect to the ramp loss. The use of ramp loss is natural for classification (see e.g., Boucheron et al. (2005); Bartlett et al. (2006)) and the main features of the ramp loss that we are going to exploit are boundedness and Lipschitzness. We start by introducing the ramp loss.

**Definition 8** (Ramp Loss).: _Let \(f:\) be a hypothesis and let \(\) be a distribution over \(\). Let \((x,y)\), where \(=\{-1,1\}\). The ramp loss of \(f\) with respect to margin parameter \(>0\) is defined as \(l_{}(f,x,y)=r_{}(-f(x).y)\), where \(r_{}\) is the ramp function defined by_

\[r_{}(x)=0&x<-,\\ 1+&- x 0\\ 1&x 0.\]

**Definition 9** (Agnostic PAC Learning with Respect to Ramp Loss).: _We say that a hypothesis class \(\) of functions from \(\) to \(\) is agnostic PAC learnable with respect to ramp loss with margin parameter \(>0\) if there exists a learner \(\) and a function \(m:(0,1)^{2}\) with the following property: For every distribution \(\) over \(\{-1,1\}\) and every \(,(0,1)\), if \(S\) is a set of \(m(,)\) i.i.d. samples from \(\), then with probability at least \(1-\) (over the randomness of \(S\)) we have_

\[_{(x,y)}[l_{}((S),x,y )]_{f}_{(x,y)} [l_{}((S),x,y)]+.\]

Figure 1: An example of a recurrent model in REC\([,T]\). The first \(q-1\) dimensions of \(f^{R}(U,t-1)\) is concatenated with \(u^{(t)}\) to form the input at time \(t\). The last dimension of \(f^{R}(U,T-1)\) is taken to be the final output of the recurrent model.

The _sample complexity_ of PAC learning \(\) with respect to ramp loss is denoted by \(m_{}(,)\), which is the minimum number of samples required for learning \(\) (among all learners \(\)). The definition of agnostic PAC learning with respect to ramp loss works for any value of \(\) and when we are analyzing the sample complexity we consider it to be a fixed constant.

## 3 A lower bound for sample complexity of learning recurrent neural networks

In this section, we consider the sample complexity of PAC learning sigmoid recurrent neural networks with respect to ramp loss. Particularly, we state a lower bound on the sample complexity of the class REC[\([p_{0},p_{k},w],T\)] of all sigmoid recurrent neural networks with length \(T\) that use multi-layer neural networks with \(w\) weights as their recurring block. The main message is that this sample complexity grows at least linearly with \(T\).

**Theorem 10** (Sample Complexity Lower Bound for Recurrent Neural Networks).: _For every \(T 3\) and \(w 19\) there exists a well-defined class \(_{w}=[p_{0},p_{k},w],T]\) and a universal constant \(C>0\) such that for every \(,(0,1/40)\) we have_

\[m_{_{w}}(,) C.(}).\]

The proof of the above lower bound is based on a similar result due to Sontag et al. (1998). However, the argument in Sontag et al. (1998) is for PAC learning with respect to 0-1 loss. To extend this result for the ramp loss, we construct a binary-valued class \(_{w}=\{f:f(U)=(h(U)),h_{w}\}\) where \((x)=1\) if \(x 0\) and \((x)=-1\) if \(x<0\). We prove that every function \(f_{w}\) can be related to another function \(h_{w}\) such that the ramp loss of \(h\) is almost equal to the zero-one loss of \(f\). This is formalized in the following lemma, which is a key result in proving Theorem 10. The proof of Theorem 10 and Lemma 11 can be found in Appendix **??**.

**Lemma 11**.: _Let \(_{w}=,p_{k},w],T]}\) be a well-defined class and let \(_{w}=\{f:[-1/2,1/2]^{p T}\{-1,1\} f(U)=(h(U)),h_{w}\}\). Then, for every distribution \(\) over \([-1/2,1/2]^{p T}\{-1,1\}\), \(>0\), and every function \(f_{w}\) there exists a function \(h_{w}\) such that \(_{(U,y)}[l_{}(h,U,y)] _{(U,y)}[l^{0-1}(f,U,y)]+\) where \(l^{0-1}(f,U,y)=\{f(U) y\}\)._

## 4 Noisy recurrent neural networks

In this section, we will define classes of noisy recurrent neural networks. Let us first define the singleton Gaussian noise class, which contains a single additive Gaussian noise function.

**Definition 12** (The Gaussian Noise Class).: _The \(d\)-dimensional noise class with scale \( 0\) is denoted by \(_{,d}}=\{}\}\). Here, \(}:^{d}^{d}\) is a random function defined by \(}()=+\), where \((,^{2}I_{d})\). When it is clear from the context we drop \(d\) and write \(_{}}=\{}\}\)._

The following is the noisy version of multi-layer networks in Definition 5. Basically, Gaussian noise is composed (Definition 3) before each layer.

**Definition 13** (Noisy Multi-Layer Sigmoid Neural Networks).: _The class of all noisy multi-layer sigmoid networks with \(w\) weights that take values in \([-1/2,1/2]^{p_{0}}\) as input and output values in \([-1/2,1/2]^{p_{k}}\) is defined by_

\[_{}}[p_{0},p_{k},w]=,p_{k} ]}_{}}p_{1},p_{2} ]_{}}p_{0},p_{1}] _{}},\]

_where \( 0\) is scale of the Gaussian noise and the union is taken over all choices of \((p_{1},p_{2},,p_{k-1})^{k-1}\) that satisfy \(_{i=1}^{k}p_{i}.p_{i-1}=w\)._

Similar to the deterministic case, \(_{}}[p_{0},p_{k},w]\) is said to be well-defined if the union is not empty (i.e., \(p_{0},p_{k}\) and \(w\) are compatible). We can use Definition 7 to create recurrent versions of the above class. For example, \(_{}[p_{0},p_{k},w],T]\) is a class of recurrent (and random) hypotheses for sequence of length \(T\) that use \(_{}}[p_{0},p_{k},w]\) as their recurring block. Again, similar to the deterministic case, we say \(_{}[p_{0},p_{k},w],T]\) is well-defined if \(p_{0},p_{k}\) and \(w\) are compatible and \(_{}}[p_{0},p_{k},w]\) is well-defined.

PAC learning noisy recurrent neural networks

In section 3, we established an \((T)\) lower bound on the sample complexity of learning recurrent networks (i.e., REC[MNET[\(p_{0},p_{k},w],T\)]). In this section, we consider a related class (based on noisy recurrent neural networks) and show that the dependence of sample complexity on \(T\) is only \(O( T)\). In particular, \(_{}}\) REC[MNET\({}_{}\)[\(p_{0},p_{k},w],T\)] can be regarded as a (noisy) sibling of REC[MNET[\(p_{0},p_{k},w],T\)]. Since it is more standard to define PAC learnability for deterministic hypotheses, we define the deterministic version of the above class by derandomization5.

**Definition 14** (Derandomization by Expectation).: _Let \(\) be a class of (random) functions from \(^{p T}\) to \(^{q}\). The derandomization of a function class \(}\) by expectation is defined as \((})=\{h:^{p T}^{q}  h(u)=_{}[\ (u)],}\}\)._

We show that, contrary to Theorem 10, the sample complexity of PAC learning the (derandomized) class of noisy recurrent neural networks, \((_{}}\) REC[MNET\({}_{}\)[\(p_{0},p_{k},w],T\)]), grows at most logarithmically with \(T\) while it still enjoys the same linear dependence on \(w\). This is formalized in the following theorem (see Appendix 27 for a proof).

**Theorem 15** (Main Result).: _Let \(_{w}}=_{}}\) REC[MNET\({}_{}\)[\(p_{0},p_{k},w\)],T] be any well-defined class and assume \(T,0<<1\), \(,(0,1)\). Then the sample complexity of learning \(_{w}=(_{w}})\) is upper bounded by_

\[m_{_{w}}(,)=O(())+(1/ )}{^{2}})=()+(1/)}{^{2}}),\]

_where \(\) hides logarithmic factors._

One feature of the above theorem is the mild logarithmic dependence on \(1/\). Therefore, we can take \(\) to be numerically negligible and still get a significantly smaller sample complexity compared to the deterministic case for large \(T\). Note that adding such small values of noise would not change the empirical outcome of RNNs on finite precision computers.

The milder (logarithmic) dependency on \(T\) is achieved by a novel analysis that involves bounding the covering number of noisy recurrent networks with respect to the total variation distance. Also, instead of "unfolding" the network, we exploit the fact that the same function/hypothesis is being used recurrently. We also want to emphasize that the above bound does not depend on the norms of weights of the network. Achieving this is challenging, since a little bit of noise in a previous layer can change the output of the next layer drastically. The next few sections are dedicated to give a high-level proof of this theorem.

## 6 Covering numbers: the classical view

One of the main tools to derive sample complexity bounds for learning a class of functions is studying their covering numbers. In this section we formalize this classic tool.

**Definition 16** (Covering Number).: _Let \((,)\) be a metric space. A set \(A\) is \(\)-covered by a set \(C A\) with respect to \(\), if for all \(a A\) there exists \(c C\) such that \((a,c)\). We denote by \(N(,A,)\) the cardinality of the smallest set \(C\) that \(\)-covers \(A\) and we refer to is as the \(\)-covering number of \(A\) with respect to metric \(\)._

The notion of covering number is defined with respect to a metric \(\). We now give the definition of extended metrics, which we will use to define _uniform_ covering numbers. The extended metrics can be seen as measures of distance between two hypotheses on a given input set.

**Definition 17** (Extended Metrics).: _Let \((,)\) be a metric space. Let \(u=(a_{1},,a_{m}),v=(b_{1},,b_{m})^{m}\) for \(m\). The \(\)-extended and \(_{2}\)-extended metrics over \(^{m}\) are defined by \(^{,m}(u,v)=_{1 i m}(a_{i},b_{i})\) and \(^{_{2},m}(u,v)=_{i=1}^{m}((a_{i},b_{i}))^{2}}\), respectively. We drop \(m\) and use \(^{}\) or \(^{_{2}}\) if it is clear from the context._A useful property about extended metrics is that the \(\)-extended metric always upper bounds the \(_{2}\)-extended metric, i.e., \(^{_{2}}(u,v)^{}(u,v)\) for all \(u,v\). Based on the above definition of extended metrics, we define the uniform covering number of a hypothesis class with respect to \(\|.\|_{2}\).

**Definition 18** (Uniform Covering Number with Respect to \(\|.\|_{2}\)).: _Let \(\) be a hypothesis class of functions from \(\) to \(\). For a set of inputs \(S=\{x_{1},x_{2},,x_{m}\}\), we define the restriction of \(\) to \(S\) as \(_{|S}=\{(f(x_{1}),f(x_{2}),,f(x_{m})):f\} ^{m}\). The uniform \(\)-covering numbers of hypothesis class \(\) with respect to \(\|.\|_{2}^{},\|.\|_{2}^{_{2}}\) are denoted by \(N_{U}(,,m,\|.\|_{2}^{})\) and \(N_{U}(,,m,\|.\|_{2}^{_{2}})\) and are the maximum values of \(N(,_{|S},\|.\|_{2}^{,m})\) and \(N(,_{|S},\|.\|_{2}^{_{2},m})\) over all \(S\) with \(|S|=m\), respectively._

The following theorem connects the notion of uniform covering number with PAC learning. It converts a bound on the \(\|.\|_{2}^{_{2}}\) uniform covering number of a hypothesis class to a bound on the sample complexity of PAC learning the class; see Appendix **??** for a more detailed discussion.

**Theorem 19**.: _Let \(\) be a class of functions from \(\) to \(\). Then there exists an algorithm \(\) with the following property: For every distribution \(\) over \(\{-1,1\}\) and every \(,(0,1)\), if \(S\) is a set of \(m\) i.i.d. samples from \(\), then with probability at least \(1-\) (over the randomness of \(S\)),_

\[_{(x,y)}[l_{}((S),x,y)]\] \[_{f}_{(x,y)}[ l_{}(f,x,y)]+16+}(,,m,\|.\|_{2}^{_{2}})}+6}.\]

_Moreover, the algorithm that returns the function with the minimum error on \(S\) satisfies the above property (i.e., Algorithm \(\) such that \(()=_{f}_{(x,y) S}l _{}(f,x,y)\))._

## 7 Total variation covers for random hypotheses

One idea to prove a generalization bound for noisy neural networks is to bound their covering numbers. However, noisy neural networks are random functions, and therefore their behaviours on a sample set cannot be directly compared. Instead, one can compare the output distributions of a random function on two sample sets. We therefore use the recently developed tools from Fathollah Pour and Ashtiani (2022) to define and study covering numbers for random hypotheses. These covering numbers are defined based on metrics between distributions. Specifically, our analysis is based on the notion of uniform covering number with respect to total variation distance.

**Definition 20** (Total Variation Distance).: _Let \(\) and \(\) denote two probability measures over \(\) and let \(\) be the Borel sigma-algebra over \(\). The TV distance between \(\) and \(\) is defined by_

\[d_{TV}(,)=_{B}|(B)-(B)|.\]

_Furthermore, if \(\) and \(\) have densities \(f\) and \(g\) then_

\[d_{TV}(,)=_{B}_{B}(f(x)-g(x))dx=_{}|f(x)-g(x)|\,dx=\|f-g\|_{1}.\]

For two random variables \(\) and \(\) with probability measures \(\) and \(\) we sometimes abuse the notation and write \(d_{TV}(,)\) instead of \(d_{TV}(,)\). For example, we write \(d_{TV}(}(),}())\) in order to refer to the Total Variation (TV) distance between pushforwards of \(\) under mappings \(}\) and \(}\). We also write \(d_{TV}^{,m}((}(}),, }(})),(}(}),,}(})))\) to refer to the extended TV distance between mappings of the set \(S=\{},,}\}\) by \(}\) and \(}\). We use the extended total variation distance to define the uniform covering number for classes of random hypotheses.

**Definition 21** (Uniform Covering Number for Classes of Random Hypotheses).: _Let \(}\) be a class of random hypotheses from \(}\) to \(}\). For a set of random variables \(=\{},},,}\} }\), the restriction of \(}\) to \(\) is defined as \(}_{|}=\{((}), (}),,(})):}\}}^{m}\). Let \(}\). The uniform \(\)-covering numbers of \(}\) with respect to \(\) and \(d_{TV}^{}\) is defined by_

\[N_{U}(,},m,d_{TV}^{},)=_{S ,|S|=m}N(,}_{|},d_{TV}^{,m}).\]Some hypothesis classes that we analyze (e.g., single-layer noisy neural networks) may have "global" total variation covers that do not depend on \(m\). This will be addressed with the following notation: \(N_{U}(,},,^{},)=_{m }N_{U}(,},m,^{}, ).\) The set \(\) in Definition 21 is used to define the input domain for which we want to find the covering number of a class of random hypotheses. For instance, some of the covers that we see are derived with respect to inputs with bounded domain or some need the input to be first smoothed by Gaussian noise. In this paper, we will be working with the following choices of \(\)

* \(=_{d}}\) and \(=_{B,d}}\): the set of all random variables defined over \(^{d}\) and \([-B,B]^{d}\), respectively, that admit a generalized density function. For example, we use \(_{0.5,d}}\) to address the set of random variables in \([-1/2,1/2]^{d}\).
* \(=}=\{=[ }}}} ]^{},u^{(i)}^{p}\}\) and \(=}=\{=[ }}}} ]^{},u^{(i)}[-B,B]^{p}\}\), where \(}}\) is the random variable associated with Dirac delta measure on \(u^{(i)}\). Note that \(}}\).
* \(=_{,d}}_{B,d}}=\{ }()_ {B,d}}\}\): all members of \(_{B,d}}\) after being "smoothed" by adding (convolving the density with) Gaussian noise.

We mentioned in Section 6 that a bound on the \(\|.\|_{2}^{_{2}}\) uniform covering number can be connected to a bound on sample complexity of PAC learning. We now show that a bound on \(d_{TV}^{}\) covering number of a class of random hypotheses can be turned into a bound on the \(\|.\|_{2}^{_{2}}\) covering number of its derandomized version and, thus, PAC learning it.

**Theorem 22** (\(\|.\|_{2}^{_{2}}\) Cover of \(()\) From \(d_{TV}^{}\) Cover of \(\)(Fathollah Pour and Ashtiani, 2022)).: _Let \(}\) be a class of functions from \(^{p T}\) to \([-B,B]^{q}\). Then for every \(>0\) and \(m\) we have_

\[N_{U}(2B,(}),m,\|.\|_{2}^{ _{2}}) N_{U}(,},m,d_{TV}^{}, }) N_{U}(,}, ,d_{TV}^{},}).\]

## 8 Bounding the covering number of recurrent models

In Section 6, we mentioned that finding a bound on covering number of a hypothesis class is a standard approach to bound its sample complexity. In the previous section, we introduced a new notion of covering number with respect to total variation distance that was developed by Fathollah Pour and Ashtiani (2022). We showed how this notion can be related to PAC learning for classes of random hypotheses. In the following, we give an overview of the techniques used to find a bound on the \(d_{TV}^{}\) covering number of the class of noisy recurrent models. We also discuss why this bound results in a sample complexity that has a milder logarithmic dependency on \(T\), compared to bounds proved by "unfolding" the recurrence and replacing the recurrent model with the \(T\)-fold composition.

One advantage of analyzing the uniform covering number with respect to TV distance is that it comes with a useful composition tool. The following theorem basically states that when two classes of hypotheses have bounded TV covers, their composition class has a bounded cover too. Note that such a result does not hold for the usual definition of covering number (e.g., Definition 18); see Fathollah Pour and Ashtiani (2022) for details.

**Theorem 23** (TV Cover for Composition of Random Classes, Lemma 18 of Fathollah Pour and Ashtiani (2022)).: _Let \(}\) be a class of random hypotheses from \(^{d}\) to \(^{p}\) and \(}\) be a class of random hypotheses from \(^{p}\) to \(^{q}\). For any \(_{1},_{2}>0\) and \(m\), denote \(N_{1}=N_{U}(_{1},},m,d_{TV}^{}, _{d}})\). Then we have,_

\[N_{U}(_{1}+_{2},}},m,d_{TV}^{},_{d}}) N_{U} (_{2},},mN_{1},d_{TV}^{},_{p}}).N_{1}.\]

An approach to bound the TV uniform covering number of a recurrent model REC\([},T]\) is to consider it as the \(T\)-fold composition \(}}}\). One can then use a similar analysis to that of Fathollah Pour and Ashtiani (2022) to bound the covering number of the \(T\)-fold composition. Unfortunately, this approach fails to capture the fact that a _fixed_ function \(}\) is applied recursively, and therefore results in a sample complexity bound that grows at least linearly with \(T\).

Instead, we take another approach to bound the covering number of recurrent models. Intuitively, we notice that any function in the \(T\)-fold composite class \(}}=\{ }}},,} }\}\)\(}\)) is determined by \(T\) functions from \(}\). On the other hand, any function in REC[\(},T\)] \(=\{(U)=(^{R}(U,T-1) )\}\) is only defined by one function in \(}\) and the capacity of this class must not be as large as the capacity of \(}}\). Interestingly, data processing inequality for total variation distance (Lemma 3) suggests that if two functions \(\) and \(}\) are "globally" close to each other with respect to TV distance (i.e., \(d_{TV}((),}())\) for every \(\) in the domain), then \(d_{TV}((()),}(())) 2\) (i.e., \(\) and \(}}\) are also close to each other). By applying the data processing inequality recursively, we can see that for the \(T\)-fold composition we have \(d_{TV}((),}}()) T\). The above approach results in the following theorem which bounds the \(\)-covering number of a noisy recurrent model with respect to TV distance by the \((/T)\)-covering number of its recurring class. Intuitively, this theorem helps us to bound the covering number of noisy recurrent models using the bounds obtained for their non-recurrent versions. Here, Gaussian noise is added to both the input of the model (i.e., \(_{}}=}_{}}\)) and the output of the model (by composing with \(_{}}\)).

**Theorem 24** (TV Covering Number of \(_{}}[_{}},T]\) From \(_{}}_{}}\)).: _Let \(s,p,q\) such that \(s=p+q-1\). Let \(}\) be a class of functions from \(_{B,s}}\) to \(_{B,q}}\) and denote by \(_{}}=}_{,s}}\) the class of its composition with noise. Then we have_

\[N_{U}(,_{}}[ _{}},T],,d_{TV}^{},}) N_{U}(/T,_{,q}} _{}},,d_{TV}^{},_{B,s}}).\]

For using this theorem, one needs to have a finer \(/T\)-cover for the recurring class. As we will see in the next section, this will translate into a mild logarithmic sample complexity dependence on \(T\).

### Covering noisy recurrent networks

An example of \(_{}}\) is the class \(_{}}[p_{0},p_{k},w]\) of well-defined noisy multi-layer networks (Definition 13). Theorem 24 suggests that a bound on the covering number of \(_{}}[_{}} [p_{0},p_{k},w],T]\) can be found from a bound for \(_{}}_{}}[p_{0},p_{k },w]\). We use the following theorem as a bound for the class of single-layer noisy sigmoid networks together with theorem 23 to bound the covering number of \(_{}}_{}}[p_{0},p_{k },w]\) (see Appendix 3, Theorem 3).

**Theorem 25** (A TV Cover for Single-Layer Noisy Neural Networks, Theorem 25 of Fathollah Pour and Ashtiani (2022)).: _For every \(p,d,>0,<5d/\) we have_

\[ N_{U}(,_{,p}}[d,p], ,d_{TV}^{},_{,d}}_{0.5,d}}) p(d+1)(30)}}{^{3/2}^{2}} ()).\]

Interestingly, the above bound (on the logarithm of the covering number) is logarithmic with respect to \(1/\). We will extend this result to multi-layer noisy networks, and then apply Theorem 24 to obtain the following bound on the covering number noisy recurrent neural networks. Crucially, the dependency (of the logarithm of the covering number) on \(T\) is only logarithmic.

**Theorem 26** (A TV Covering Number Bound for Noisy Sigmoid Recurrent Networks).: _Let \(T\). For every \(,(0,1)\) and every well-defined class REC[\(_{}}[p_{0},p_{k},w],T\)] we have_

\[ N_{U}(,_{}}[ _{}}[p_{0},p_{k},w],T],,d_{TV}^{}, })\] \[=O(w(()))=(w()).\]

Finally, we turn the above bound into a \(\|.\|_{2}^{_{2}}\) covering number bound for the derandomized function \((_{}}[_{}}[p_{0},p_{k},w],T])\) by an application of Theorem 22. We then upper bound the sample complexity by the logarithm of covering number (see Theorem 19) and conclude Theorem 15.

**Limitations and future work.** Our results are derived for sigmoid (basically bounded, monotone, and Lipschitz) activation functions. It is open whether such results can be proved for unbounded activation functions such as RELU. Our results are theoretical and we leave empirical evaluations on the performance of noisy networks to future work.

More on related work

There is plethora of work on generalization in neural networks. There are a family of approaches that aim to bound the VC-dimension of neural networks. (Baum and Haussler, 1988; Maass, 1994; Goldberg and Jerrum, 1995; Vidyasagar, 1997; Sontag et al., 1998; Koiran and Sontag, 1998; Bartlett et al., 1998; Bartlett and Maass, 2003; Bartlett et al., 2019). These approaches result in generalization bounds that are dependent on the number of parameters. Another family of approaches are aimed at obtaining generalization bounds that are dependent on the norms of the weights and Lipschitz continuity properties of the network (Bartlett, 1996; Anthony et al., 1999; Zhang, 2002; Neyshabur et al., 2015; Bartlett et al., 2017; Neyshabur et al., 2018; Golowich et al., 2018; Arora et al., 2018; Nagarajan and Kolter, 2018; Long and Sedghi, 2020). It has been observed that these generalization bounds are usually vacuous in practice. One speculation is that the implicit bias of gradient descent (Gunasekar et al., 2017; Arora et al., 2019; Ji et al., 2020; Chizat and Bach, 2020; Ji and Telgarsky, 2021) can lead to benign overfitting (Belkin et al., 2018, 2019; Bartlett et al., 2020, 2021). It has also been conjectured that uniform convergence theory may not be able to fully capture the performance of neural networks in practice (Nagarajan and Kolter, 2019; Zhang et al., 2021). It has been shown that there are data-dependent approaches that can achieve non-vacuouys bounds (Dziugiue and Roy, 2017; Zhou et al., 2019; Negrea et al., 2019). There are also other approaches that are independent of data (Arora et al., 2018); see Fathollah Pour and Ashtiani (2022) for more details.

Adding different types of noise such as dropout noise (Srivastava et al., 2014), DropConnect (Wan et al., 2013), and Denoising AutoEncoders (Vincent et al., 2008) are shown to be helpful in training neural networks. Wang et al. (2019) and Gao and Zhou (2016) theoretically analyze the generalization under dropout noise. More recently, Fathollah Pour and Ashtiani (2022) developed a framework to study the generalization of classes of noisy hypotheses and show that adding noise to the output of neurons in a network can be helpful in generalization. Jim et al. (1996) show that additive and multiplicative noise can help speed up the convergence of RNNs on local minima surfaces. Recently, Lim et al. (2021) showed that noisy RNNs are more stable and robust to input perturbations by formalizing the regularization effects of noise.

Another line of work focuses on the generalization of neural network that are trained with Stochastic Gradient Descent (SGD) or its noisy variant Stochastic Gradient Langevin Descent (SGLD) (Russo and Zou, 2016; Xu and Raginsky, 2017; Russo and Zou, 2019; Steinke and Zakynthinou, 2020; Raginsky et al., 2017; Haghifam et al., 2020; Neu et al., 2021). Zhao et al. (2020) analyze the memory properties of recurrent networks and how well they can remember the input sequence. Tu et al. (2020) study the generalization of RNN by analyzing the Fisher-Rao norm of weights, which they obtain from the gradients of the network. They offer generalization bounds that can potentially become polynomial in \(T\). Allen-Zhu and Li (2019) analyze the change in output through the dynamics of training RNNs and prove generalization bounds for recurrent networks that are again polynomial in \(T\).