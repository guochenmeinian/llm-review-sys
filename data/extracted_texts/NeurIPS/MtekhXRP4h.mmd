# Convolutional Neural Operators for robust and accurate learning of PDEs

Bogdan Raonic\({}^{1,2}\) Roberto Molinaro\({}^{1}\) Tim De Ryck\({}^{1}\) Tobias Rohner\({}^{1}\)

Francesca Bartolucci\({}^{3}\) Rima Alaifari\({}^{1}\) Siddhartha Mishra\({}^{1,2}\) Emmanuel de Bezenac\({}^{1}\)

\(1\) Seminar for Applied Mathematics, ETH, Zurich, Switzerland

\(2\) ETH AI Center, Zurich, Switzerland

\(3\) Delft University of Technology, Netherlands

###### Abstract

Although very successfully used in conventional machine learning, convolution based neural network architectures - believed to be inconsistent in function space - have been largely ignored in the context of learning solution operators of PDEs. Here, we present novel adaptations for convolutional neural networks to demonstrate that they are indeed able to process functions as inputs and outputs. The resulting architecture, termed as convolutional neural operators (CNOs), is designed specifically to preserve its underlying continuous nature, even when implemented in a discretized form on a computer. We prove a universality theorem to show that CNOs can approximate operators arising in PDEs to desired accuracy. CNOs are tested on a novel suite of benchmarks, encompassing a diverse set of PDEs with possibly multi-scale solutions and are observed to significantly outperform baselines, paving the way for an alternative framework for robust and accurate operator learning.

## 1 Introduction.

Partial Differential Equations (PDEs)  are ubiquitous as mathematical models in the sciences and engineering. Solving a PDE amounts to (approximately) computing the so-called _solution operator_ that maps function space inputs such as initial and boundary conditions, coefficients, source terms etc, to the PDE solution which also belongs to a suitable function space. Well-established numerical methods such as finite differences, finite elements, finite volumes and spectral methods (see ) have been very successfully used for many decades to approximate PDE solution operators. However, the prohibitive computational cost of these methods, particularly in high dimensions and for _many query_ problems such as UQ, inverse problems, PDE-constrained control and optimization, necessitates the design of _fast, robust and accurate_ surrogates. This provides the rationale for the use of _data-driven machine learning_ methods for solving PDEs .

As _operators_ are the objects of interest in solving PDEs, learning such operators from data, which is loosely termed as _operator learning_, has emerged as a dominant paradigm in recent years for the applications of machine learning to PDEs. A very partial list of architectures for operator learning include operator networks , DeepONets  and its variants , PCA-net , neural operators  such as graph neural operator , Multipole neural operator  and the very popular Fourier Neural Operator  and its variants , VIDON , spectral neural operator , LOCA , NOMAD  and transformer based operator learning architectures .

Despite the considerable success of the recently proposed operator learning architectures, several pressing issues remain to be addressed. These include, but are by no means restricted to, limited expressivity for some of these algorithms  to aliasing errors for others  to the very fundamental issue of possible _lack of consistency in function spaces_ for many of them. As argued in a recent paper , a structure-preserving operator learning algorithm or _representation equivalent neural operator_ has to respect some form of _continuous-discrete equivalence_ (CDE) in order to learn the underlying operator, rather than just a discrete representation of it. Failure to respect such a CDE can lead to the so-called _aliasing errors_ and affect model performance at multiple discrete resolutions.

Despite many attempts, see  and references therein, the absence of a suitable CDE, resulting in aliasing errors, has also plagued the naive use of convolutional neural networks (CNNs) in the context of operator learning, see  on how using CNNs for operator learning leads to results that heavily rely on the underlying grid resolution. This very limited use of Convolution (in physical space) based architectures for operator learning stands in complete contrast to the fact that CNNs  and their variants are widely used architectures for image classification and generation and in other contexts in machine learning . Moreover, CNNs can be thought of as natural generalizations of the foundational finite difference methods for discretizing PDEs . Given their innate locality, computational and data efficiency, ability to process multi-scale inputs and outputs and the availability of a wide variety of successful CNN architectures in other fields, it could be very advantageous to bring CNN-based algorithms back into the reckoning for operator learning. This is precisely the central point of the current paper where we make the following contributions,

* We propose novel modifications to CNNs in order to enforce structure-preserving continuous-discrete equivalence and enable the genuine, alias-free, learning of operators. The resulting architecture, termed as _Convolutional Neural Operator_ (CNO), is instantiated as a novel _operator_ adaptation of the widely used U-Net architecture.
* In addition to showing that CNO is a _representation equivalent neural operator_ in the sense of , we also prove a universality result to rigorously demonstrate that CNOs can approximate the operators, corresponding to a large class of PDEs, to desired accuracy.
* We test CNO on a _novel_ set of benchmarks, that we term as _Representative PDE Benchmarks_ (RPB), that span across a variety of PDEs ranging from linear elliptic and hyperbolic to nonlinear parabolic and hyperbolic PDEs, with possibly _multiscale solutions_. We find that CNO is either on-par or outperforms the tested baselines on all the benchmarks, both when testing in-distribution as well as in _out-of-distribution_ testing.

Thus, we present a new CNN-based operator learning model, with desirable theoretical properties and excellent empirical performance, with the potential to be widely used for learning PDEs.

## 2 Convolutional Neural Operators.

Figure 1: Schematic representation of CNO (2.3) as a modified U-Net with a sequence of layers (each identified with the relevant operators on the right, see Section 2) mapping between bandlimited functions. Rectangles represent multi-channel signals. Larger the height, larger is the resolution. Wider the rectangles, more channels are present.

Setting.For simplicity of the exposition, we will focus here on the two-dimensional case by specifying the underlying domain as \(D=^{2}\), being the \(2\)-d torus. Let \(=H^{r}(D,^{d_{}})\) and \(=H^{s}(D,^{d_{}})\) be the underlying function spaces, where \(H^{r,s}(D,)\) are Sobolev spaces of order \(r\) and \(s\). Without loss of generality, we set \(r=s\) hereafter. Our aim would be to approximate _continuous operators_\(^{}:\) from data pairs \(u_{i},^{}(u_{i})_{i=1}^{M} \). We further assume that there exists a _modulus of continuity_ for the operator i.e.,

\[\|^{}(u)-^{}(v)\|_{} (\|u-v\|_{}), u,v,\] (2.1)

with \(:_{+}_{+}\) being a monotonically increasing function with \(_{y 0}(y)=0\). The underlying operator \(^{}\) can correspond to solution operators for PDEs (see Section 3 for the exact setting) but is more general than that and encompasses examples such as those arising in inverse problems, for instance in imaging .

Bandlimited Approximation.As argued in a recent paper , Sobolev spaces such as \(H^{r}\) are, in a sense, _too large_ to allow for any form of _continuous-discrete equivalence_ (CDE), i.e., equivalence between the underlying operator and its discrete representations, which is necessary for robust operator learning. Consequently, one has to consider smaller subspaces of \(H^{r}\) which allow for such CDEs. In this respect, we choose the space of _bandlimited functions_ defined by,

\[_{w}(D)=\{f L^{2}(D):[-w,w]^{2}\},\] (2.2)

for some \(w>0\) and with \(\) denoting the Fourier transform of \(f\). It is straightforward to show using (2.1) (see **SMA**.1) that for any \(>0\), there exists a \(w\), large enough depending on \(r\), and a continuous operator \(^{*}:_{w}(D)_{w}(D)\), such that \(\|^{}-^{*}\|<\), with \(\|\|\) denoting the corresponding operator norm. In other words, the underlying operator \(^{}\) can be approximated to arbitrary accuracy by the operator \(^{*}\) that maps between band-limited spaces. Consequently, as shown in **SMA**.2, one can readily define discrete versions of \(^{*}\) using the underlying _sinc_ basis for bandlimited functions and establish a continuous-discrete equivalance for it.

Definition of CNO.Given the above context, our goal will be to approximate the operator \(^{*}\) in a _structure-preserving manner_ i.e., as the underlying operator maps between spaces of bandlimited functions, we will construct our operator approximation architecture to also map bandlimited functions to bandlimited functions, thus respecting the continuous-discrete equivalence. To this end, we denote the operator \(:_{w}(D)_{w}(D)\) as a _convolutional neural operator_ (CNO) which we define as a compositional mapping between functions as

\[:u P(u)=v_{0} v_{1} v_{L} Q(v_{L}) =,\] (2.3)

where

\[v_{l+1}=_{l}_{l}_{l}(v_{l}), 1  L-1.\] (2.4)

From (2.3), we see that first, the input function \(u_{w}(D)\) is lifted to the latent space of bandlimited functions through a _lifting layer_:

\[P:\{u_{w}(D,^{d_{}})\}\{ v_{0}_{w}(D,^{d_{0}})\}.\]

Here, \(d_{0}>d_{}\) is the number of channels in the lifted, latent space. The lifting operation is performed by a convolution operator which will be defined below.

Then, the lifted function is processed through the composition of a series of mappings between functions (layers), with each layer consisting of three elementary mappings, i.e., \(_{l}\) is either the _upsampling_ or _downsampling_ operator, \(_{l}\) is the convolution operator and \(_{l}\) is the activation operator. These elementary operators are defined below and are inspired by the modifications of CNNs for image generation in . Finally, the last output function in the iterative procedure \(v_{L}\) is projected to the output space with a _projection operator_\(Q\), defined as

\[Q:\{v_{L}_{w}(D,^{d_{L}})\}\{ _{w}(D,^{d_{}})\}.\]

The projection operation is also performed by a convolution operator defined below.

Convolution Operator.For simplicity of exposition, we will present the _single-channel_ version of the convolution operator \(_{l}\) here. See **SM** A.3 for the _multi-channel_ version for this and other operators considered below. Convolution operations are performed with discrete kernels

\[K_{w}=_{i,j=1}^{k}k_{ij}_{z_{ij}}\]

defined on the \(s s\) uniform grid on \(D\) with grid size \( 1/2w\), in-order to satisfy the requirements of the Whittaker-Shannon-Kotelnikov sampling theorem , and \(z_{ij}\) being the resulting grid points, \(k\) being the kernel size and \(_{x}\) denoting the Dirac measure at point \(x D\). The convolution operator for a _single-channel_\(_{w}:_{w}(D)_{w}(D)\) is defined by

\[_{w}f(x)=(K_{w} f)(x)=_{D}K_{w}(x-y)f(y)dy=_{i,j=1}^{k} k_{ij}f(x-z_{ij}), x D,\]

where the last identity arises from the fact that \(f_{w}\). Thus, our convolution operator is directly parametrized in physical space, in contrast to the Fourier space parametrization of a convolution in the FNO architecture of . Hence, our parametrization is of a _local_ nature.

Upsampling and Downsampling Operators.For some \(>w\), we can _upsample_ a function \(f_{w}\) to the _higher band_\(_{}\) by simply setting,

\[_{w,}:_{w}(D)_{}( D),_{w,}f(x)=f(x), x D.\]

On the other hand, for some \(<w\), we can _downsample_ a function \(f_{w}\) to the _lower band_\(_{}\) by setting \(_{w,}:_{w}(D)_{} (D)\), defined by

\[_{w,}f(x)=(}{w})^{2}(h_ {} f)(x)=(}{w})^{2}_{D}h _{}(x-y)f(y)dy, x D,\]

where \(\) is the convolution operation on functions defined above and \(h_{}\) is the so-called _interpolation sinc filter_:

\[h_{w}(x_{0},x_{1})=(2wx_{0})(2wx_{1}),(x_{0}, x_{1})^{2}.\] (2.5)

Activation Layer.Naively, one can apply the activation function pointwise to any function. However, it is well-known that such an application will no longer respect the band-limits of the underlying function space and generate _aliasing errors_. In particular, nonlinear activations can generate features at arbitrarily high frequencies. As our aim is to respect the underlying CDE, we will modulate the application of the activation function so that the resulting outputs fall within desired band limits. To this end, we first upsample the input function \(f_{w}\) to a higher bandlimit \(>w\), then apply the activation and finally downsample the result back to the original bandlimit \(w\) (See Figure 1). Implicitly assuming that \(\) is large enough such that \((_{w})_{}\), we define the activation layer in (2.3) as,

\[_{w,}:_{w}(D)_{w}(D),_{w, }f(x)=_{,w}(_{w, }f)(x), x D.\] (2.6)

Instantiation through an Operator U-Net architecture.The above ingredients are assembled together in the form of an Operator U-Net architecture that has bandlimited functions as inputs and outputs. In addition to the blocks that have been defined above, we also need additional ingredients, namely incorporate _skip connections_ through _ResNet_ blocks of the form, \(_{w,}:_{w}(D,^{d})_{w }(D,^{d})\) such that

\[_{w,}(v)=v+_{w}_{w,} _{w}(v), v_{w}(D,^{d}).\] (2.7)

We also need the so-called _Invariant blocks_ of the form, \(_{w,}:_{w}(D,^{d})_{w }(D,^{d})\) such that

\[_{w,}(v)=_{w,}_{w}(v),  v_{w}(D,^{d}).\] (2.8)

Finally, all these ingredients are assembled together in a modified Operator U-Net architecture which is graphically depicted in Figure 1. As seen from this figure, the input function, say \(u_{w}(D,^{d_{X}})\) is first lifted and then processed through a series of layers. Four types of blocks are used i.e.,downsampling (D) block corresponding to using the downsampling operator \(\) as the \(\) in (2.4), upsampling (U) block corresponding to using the upsampling operator \(\) as the \(\) in (2.4), ResNet (R) block corresponding to (2.7) and Invariant (I) block corresponding to (2.8). Each block takes a band-limited function as input and returns another band-limited function (with the same band) as the output. Finally, U-Net style patching operators, which concatenate outputs for different layers as additional channels are also used. As these operations act only in the channel width and leave the spatial resolution unchanged, they conform to the underlying bandlimits. Thus, CNO takes a function input and passes it through a set of encoders, where the input is downsampled in space but expanded in channel width and then processed through a set of decoders, where the channel width is reduced but the space resolution is increased. At the same time, encoder and decoder layers (at the same spatial resolution or band limit) are connected through additional ResNet blocks. Thus, this architectural choice allows for transferring high frequency content via the skip connections, before filtering them out with the _sinc_ filter as we go deeper into the encoder. Hence, the high frequency content is not just recreated with the activation function, but also modified through the intermediate networks. Consequently, we build a genuinely _multiscale operator learning architecture_.

Continuous-Discrete Equivalence for CNO.We have defined CNO (2.3) as an operator that maps bandlimited functions to bandlimited functions. In practice, like any computational algorithm, CNO has to be implemented in a discrete manner, with _discretized versions_ of each of the above-defined elementary operations being specified in **SM** A.4. Given how each of the elementary blocks (convolution, up- and downsampling, activation, ResNets etc) are constructed, we prove the following proposition (in **SM** A.5):

**Proposition 2.1**.: _Convolutional Neural Operator \(:_{w}(D,^{d_{}})_{ w}(D,^{d_{}})\) (2.3) is a Representation equivalent neural operator or ReNO, in the sense of , Definition 3.4._

Further details about the notion of ReNOs is provided in **SM** A.4 and we refer the reader to , where this concept is presented in great detail and the representation equivalence of CNO is discussed. In particular, following , representation equivalence implies that CNO satisfies a form of _resolution invariance_, allowing it to be evaluated on multiple grid resolutions without aliasing errors.

## 3 Universal Approximation by CNOs.

We want to prove that a large class of operators, stemming from PDEs, can be approximated to desired accuracy by CNOs. To this end, we consider the following abstract PDE in the domain \(D=^{2}\),

\[(u)=0,(u)=0,\] (3.1)

with \(\) being a differential operator and \(\) a boundary operator. We assume that the differential operator \(\) only depends on the coordinate \(x\) through a _coefficient_ function \(a H^{r}(D)\). The corresponding _solution_ operator is denoted by \(^{}:^{*} H^{r}(D) H^{r}(D):a u\), with \(u\) being the solution of the PDE (3.1). We assume that \(^{}\) is continuous. Moreover, we also assume the following modulus of continuity,

\[\|^{}(a)-^{}(a^{})\|_{L^ {p}(^{2})}(\|a-a^{}\|_{H^{}(^{ 2})}),\] (3.2)

for some \(p\{2,\}\) and \(0 r-1\), and where \(:[0,)[0,)\) is a monotonously increasing function with \(_{y 0}(y)=0\). (3.2) is automatically satisfied if \(^{*}\) is compact and \(^{}\) is continuous. Under these assumptions, we have the following _universality theorem_ for CNOs (2.3),

**Theorem 3.1**.: _Let \(_{0}\) and \(p\{2,\}\) as in (3.2), \(r>\{,2/p\}\) and \(B>0\). For any \(>0\) and any operator \(^{}\), as defined above, there exists a CNO \(\) such that for every \(a^{*}\) with \(\|a\|_{H^{r}(D)} B\) it holds,_

\[\|^{}(a)-(a)\|_{L^{p}(D)}<.\] (3.3)

In fact, we will prove a more general version of this theorem in **SM** B, where we also include additional source terms in the PDE (3.1).

Experiments.

Training Details and Baselines.We provide a detailed description of the implementation of CNO and the training (and test) protocol for CNO as well as all the baselines in **SM** C.1. To ensure a _level playing field_ among all the tested models for each benchmark, we follow an _ensemble training procedure_ by specifying a range for the underlying hyperparameters _for each model_ and randomly selecting a subset of the hyperparameter space. For each such hyperparameter configuration, the corresponding models are trained on the benchmark and the configuration with smallest validation error is selected and the resulting test errors are reported, allowing us to identify and compare the _best performing_ version of each model for every benchmark. We compare CNO with the following baselines: two very popular operator learning architectures, namely DeepONet (DON)  and FNO , a transformer based operator-learning architecture, i.e., Galerkin Transformer (GT) , feedforward neural network with with residual connections (FFNN)  and the very widely-used ResNet  and U-Net  architectures. 1

Representative PDE Benchmarks (RPB).Given the lack of consensus on a _standard_ set of benchmarks for machine learning of PDEs, we propose a _new suite of benchmarks_ here. Our aims in this regard are to ensure i) sufficient diversity among the types of PDE considered, ii) access to training and test data is readily available for rapid prototyping and reproducibility and iii) _intrinsic computational complexity_ of problem to make sure that it is worthwhile to design fast surrogates to classical PDE solvers for a particular problem. In other words, we will only consider PDEs where classical PDE solvers can _only_ resolve the underlying operator on fine enough grids. To meet these requirements, we will not consider PDEs in one space dimension as traditional numerical methods are already quite fast for them. On the other hand, it is hard to obtain and store data for problems in three dimensions, due to computational expense of traditional methods. The _sweet spot_ is achieved by considering PDEs in two space dimensions. We further restrict to Cartesian domains here as all models can be readily evaluated in this setting. In addition to including a diverse set of PDEs, we only consider problems with sufficiently _many spatial and temporal scales_. Otherwise, traditional numerical solvers can approximate the underlying PDE on very coarse grids and it is not worthwhile to design surrogates (see **SM** C.3.8 for a discussion in this context on a widely used Navier-Stokes benchmark). With these considerations in mind, we present the following subset of _Representative PDE Benchmarks_ or **RPB**,

    & **In/Out** & **FFNN** & **GT** & **UNet** & **ResNet** & **DON** & **FNO** & **CNO** \\  
**Poisson** & In & 5.74\% & 2.77\% & 0.71\% & 0.43\% & 12.92\% & 4.98\% & **0.21\%** \\
**Equation** & Out & 5.35\% & 2.84\% & 1.27\% & 1.10\% & 9.15\% & 7.05\% & **0.27\%** \\ 
**Wave** & In & 2.51\% & 1,44\% & 1.51\% & 0.79\% & 2.26\% & 1.02\% & **0.63\%** \\
**Equation** & Out & 3.01\% & 1.79\% & 2.03\% & 1.36\% & 2.83\% & 1.77\% & **1.17\%** \\ 
**Smooth** & In & 7.09\% & 0.98\% & 0.49\% & 0.39\% & 1.14\% & 0.28\% & **0.24\%** \\
**Transport** & Out & 650.6\% & 875.4\% & 1.28\% & 0.96\% & 157.2\% & 3.90\% & **0.46\%** \\ 
**Discontinuous** & In & 13.0\% & 1.55\% & 1.31\% & **1.01\%** & 5.78\% & 1.15\% & **1.01\%** \\
**Transport** & Out & 257.3\% & 22691.1\% & 1.35\% & 1.16\% & 117.1\% & 2.89\% & **1.09\%** \\ 
**Allen-Cahn** & In & 18.27\% & 0.77\% & 0.82\% & 1.40\% & 13.63\% & **0.28\%** & 0.54\% \\
**Equation** & Out & 46.93\% & 2.90\% & 2.18\% & 3.74\% & 19.86\% & **1.10\%** & 2.23\% \\ 
**Navier-Stokes** & In & 8.05\% & 4.14\% & 3.54\% & 3.69\% & 11.64\% & 3.57\% & **2.76\%** \\
**Equations** & Out & 16.12\% & 11.09\% & 10.93\% & 9.68\% & 15.05\% & 9.58\% & **7.04\%** \\ 
**Darcy** & In & 2.14\% & 0.86\% & 0.54\% & 0.42\% & 1.13\% & 0.80\% & **0.38\%** \\
**Flow** & Out & 2.23\% & 1.17\% & 0.64\% & 0.60\% & 1.61\% & 1.11\% & **0.50\%** \\ 
**Compressible** & In & 0.78\% & 2.09\% & 0.38\% & 1.70\% & 1.93\% & 0.44\% & **0.35\%** \\
**Euler** & Out & 1.34\% & 2.94\% & 0.76\% & 2.06\% & 2.88\% & 0.69\% & **0.59\%** \\   

Table 1: Relative median \(L^{1}\) test errors, for both in- and out-of-distribution testing, for different benchmarks and models.

Poisson Equation.This prototypical _linear elliptic PDE_ is given by,

\[- u=f,\;\;D, u|_{ D}=0.\] (4.1)

The solution operator \(^{}:f u\), maps the source term \(f\) to the solution \(u\). With source term,

\[f(x,y)=}_{i,j=1}^{K}a_{ij}(i^{2}+j^{2})^{-r}( ix )( jy),(x,y) D,\] (4.2)

with \(r=-0.5\), the corresponding exact solution can be analytically computed (see SM C.3.1) and represents \(K\)- spatial scales. For training the models, we fix \(K=16\) in (4.2) and choose \(a_{ij}\) to be i.i.d. uniformly distributed from \([-1,1]\) (See **SM D** for a representation of the inputs and outputs of \(^{}\)). This _multiscale solution_ needs fine enough grid size to be approximated accurately by finite element methods, fitting our complexity criterion for benchmarks. In addition to _in-distribution_ testing, we also consider an _out-of-distribution_ testing task by setting \(K=20\) in (4.2). This will enable us to evaluate the ability of the models to _generalize_ to inputs (and outputs) with frequencies higher than those encountered during training.

Wave Equation.This prototypical _linear hyperbolic PDE_ is given by

\[u_{tt}-c^{2} u=0,\;\;D(0,T), u_{0}(x,y)=f(x,y),\] (4.3)

with a constant propagation speed \(c=0.1\). The underlying operator \(^{}:f u(.,T)\) maps the initial condition \(f\) into the solution at the final time. If we consider initial conditions to be given by (4.2) with \(r=1\), then one can explicitly compute the exact solution (see SM C.3.2) to represent a _multiscale standing wave_ with periodic pulsations (depending on \(K\)) in time. The training and _in-distribution_ test samples are generated by setting \(T=5\), \(K=24\) and \(a_{ij}\) to be i.i.d. uniformly distributed from \([-1,1]\) (See **SM** D for input and output samples). For _out-of-distribution_ testing, we change the exponent of decay of the modes in (4.2) to \(r=0.85\) and \(K=32\), in order to test the ability of the models to generalize to learn the effect of higher frequencies, than those present in the training data.

Transport Equation.The transport of scalar quantities of interest is modeled by PDE,

\[u_{t}+v u=0, u(t=0)=f,\] (4.4)

with a given velocity field and initial data \(f\). The underlying operator \(^{}:f u(.,T=1)\) maps the initial condition \(f\) into the solution at the final time. We set a constant velocity field \(v=(v_{x},v_{y})=(0.2,0.2)\) leading to solution \(u(x,y,t)=f(x-v_{x}t,y-v_{y}t)\). Two different types of training data are considered, i.e., _smooth_ initial data which takes the form of a radially symmetric Gaussian, with centers randomly and uniformly drawn from \((0.2,0.4)^{2}\) and corresponding variance drawn uniformly from \((0.003,0.009)\) and a _discontinuous_ initial data in the form of the indicator function of radial disk with centers, uniformly drawn from \((0.2,0.4)^{2}\) and radii uniformly drawn from \((0.1,0.2)\) (See **SM** C.3.3 for details and **SM** D for illustrations). For _out-of-distribution_ testing in the smooth case, the centers of the Gaussian inputs are sampled uniformly from \((0.4,0.6)^{2}\) and in the discontinuous case, the centers of the disk are drawn uniformly from \((0.4,0.6)^{2}\), while keeping the variance and the radii, respectively, the same as that of _in-distribution testing_. This _out-of-distribution_ task tests the model's ability to cope with input translation-equivariance.

Allen-Cahn Equation.It is a prototype for _nonlinear parabolic PDEs_,

\[u_{t}= u-^{2}u(u^{2}-1),\] (4.5)

with a reaction rate of \(=220\) and underlying operator \(^{}:f u(.,T)\), mapping initial conditions \(f\) to the solution \(u\) at a final time \(T=0.0002\). The initial conditions for training and _in-distribution_ testing are of the form (4.2), with \(r=1\) and \(K=24\) and coefficients \(a_{ij}\) drawn uniformly from \([-1,1]\). For _out-of-distribution_ testing, we set \(K=16\) and randomly select the initial decay \(r\), uniformly from the range \([0.85,1.15]\) of the modes in (4.2), which allows us to test the ability of the model to generalize to different dynamics of the system. Both training and test data are generated by using a finite difference scheme  on a grid at \(64^{2}\) resolution (see **SM** D for illustrations).

Navier-Stokes Eqns.These PDEs model the motion of incompressible fluids by,

\[u_{t}+(u)u+ p= u,\ u=0,\] (4.6)

in the torus \(D=^{2}\) with periodic boundary conditions and viscosity \(=4 10^{-4}\), only applied to high-enough Fourier modes (those with amplitude \( 12\)) to model fluid flow at _very high Reynolds-number_. The solution operator \(^{}:f u(.,T)\), maps the initial conditions \(f:D^{2}\) to the solution at final time \(T=1\). We consider initial conditions representing the well-known _thin shear layer_ problem  (See **SM** C.3.5 for details), where the shear layer evolves via vortex shedding to a complex distribution of vortices (see **SM** D for samples). The training and _in-distribution testing_ samples are generated, with a spectral viscosity method , from an initial sinusoidal perturbation of the shear layer , with layer thickness \(=0.1\) and \(10\) perturbation modes, each sampled uniformly from \([-1,1]\). For _out-of-distribution_ testing, the layer thickness is reduced to \(=0.09\) and the layers are shifted up in the domain to test the ability of the models to _generalize_ to a flow regime with an increased number and different locations of the shed vortices.

Darcy flow.The steady-state Darcy flow is described by the second order linear elliptic PDE,

\[-(a u)=f,\ \ D, u|_{ D}=0,\] (4.7)

where \(a\) is the diffusion coefficient and \(f\) is the forcing term. We set the forcing term to \(f=1\). The solution operator is \(^{}:a u\), where the input is the diffusion coefficient \(a\#\), with \(\) being a Gaussian Process with zero mean and squared exponential kernel

\[k(x,y)=^{2}(}{l^{2}}),^{2}=0.1.\] (4.8)

We chose the length scale \(l=0.1\) for the in-distribution testing and \(l=0.05\) for the out-of-distribution testing. The mapping \(:\) takes the value \(12\) on the positive part of the real line and \(3\) on the negative part. The push-forward measure is defined pointwise. The experimental setup is the same as the one presented in .

Flow past airfoils.We model this flow by the compressible Euler equations,

\[u_{t}+F(u)=0,\ u=[, v,E]^{},\ F=[ v, v  v+p,(E+p)|v]^{},\] (4.9)

with density \(\), velocity \(v\), pressure \(p\) and total Energy \(E\) related by an ideal gas equation of state. The airfoils we consider are described by perturbing the shape of a well-known RAE2822 airfoil  by Hicks-Henne Bump functions  (see **SM** C.3.7). Freestream boundary conditions are imposed and the solution operator maps the shape function onto the steady state density distribution (see **SM** D for samples) and training data are obtained with a compressible flow solver (NUWTUN) with shapes corresponding to \(20\) bump functions, with coefficients sampled uniformly from \(\). _Out-of-distribution_ testing is performed with \(30\) bump functions.

Results.The test errors, for both _in-distribution_ and _out-of-distribution_ testing for all the models on the **RPB** benchmarks are shown in Table 1. Starting with the _in-distribution_ results, we see that among the baselines, FNO clearly outperforms both FFNN and DeepONet on all the **RPB** benchmarks as well as the Galerkin Transformer on all except the Poisson test case. On the other hand, the convolution-based U-Net and ResNet models are quite competitive vis-a-vis FNO, with comparable performances on most benchmarks, while outperforming FNO by a factor of \(7-9\) for the Poisson test case. This already indicates that convolution-based architectures can perform very well. Moreover, we observe from Table 1 that CNO is the best performing architecture on every task except Allen-Cahn. It readily outperforms FNO, for instance by almost a factor of \(20\) on the Poisson test case but more moderately but significantly on other tasks. It also outperforms U-Net and ResNet on all tasks considered here, emerging as the best-performing model over these benchmarks.

Out-of-Distribution Testing.This trend is further reinforced when we consider _out-of-distribution_ testing. CNO generalizes well to unseen data in a _zero-shot_ mode, with test errors increasing by approximately a factor of \(2\), at most (with Allen-Cahn being an outlier) and still outperforms the baselines significantly in all cases other than Allen-Cahn, where FNO generalizes the best. FNO shows decent generalization for most problems but generalizes poorly on the transport problems. This can be attributed to its lack of translation equivariance, in contrast to U-Net, ResNet and CNO. Finally, the lack of translation invariance severely limits the out-of-distribution generalization performance of DeepONet, FFNN and Galerkin Transformer models on transport problems.

Resolution Invariance.We select three of the best-performing models (U-Net, FNO and CNO) and highlight further differences between them for the Navier-Stokes test case (see also **SM** C). To this end, we start with Figure 2 (left), where we present the averaged (log) spectra for the ground truth (reference solution computed with the spectral viscosity method) and those computed with CNO, FNO and U-Net. We observe from this figure that i) the spectrum of the exact solution is very rich with representations of many frequencies, attesting to the _multi-scale_ nature of the underlying problem and ii) there are significant differences in how CNO and FNO approximate the underlying solution in Fourier space. In particular, the decay in CNO's spectrum is more accurate. On the other hand, the FNO spectrum is amplified along the horizontal axis, possibly on account of _aliasing errors_ that add incorrect frequency content. The U-Net spectra are similar to that of CNO but with high-frequency modes being amplified, which leads to a higher test error. Next, in Figure 2 (right), we compare CNO, FNO and U-Net vis-a-vis the metric of _how the test error varies across resolutions_, see **SMC**.4 for details, which is an important aspect for robust operator learning that been highlighted in , see also  for a discussion with respect to representation equivalent neural operators or ReNOs. We find from Figure 2 (right) that for the Navier-Stokes benchmark, the FNO error is not _invariant_ with respect to resolution, with an increase in error of up to \(25\%\) on lower-resolutions as well as a more modest but noticeable increase of \(10\%\) on resolutions, higher than the training resolution of \(64^{2}\), implying that FNO is neither able to perform alias-error free super- or sub-resolution in this case, see also  for a detailed discussion on the resolution-invariance of FNO. Similarly, the increase of U-Net test error with respect to varying resolutions is even more pronounced, with a maximum increase of a factor of \(3\), indicating neither FNO nor U-Net are resolution (representation) equivalent in this case. In contrast, CNO error is invariant with respect to test resolution, verifying that it respects _continuous-discrete equivalence_. Further ablation studies for CNO are presented in **SM** C.5.

Efficiency.In order to further compare CNO with FNO, which is the most widely used neural operator these days, we illustrate not just the performance in terms of errors but also terms in computational efficiency. To this end, in Figure 3 (left), we plot the size (total number of parameters) vs validation error for the Navier-Stokes benchmark for all FNO and CNO models that were considered in the model selection procedure to observe that for the same model size, CNO models led to significantly smaller validation errors. This resulted in smaller errors for the same per-epoch training time (Figure 3 (center)) for CNO vis-a-vis FNO. As observed in Figure 3 (center), this also implies that one of the best-performing CNO models, with a significantly smaller error than the best-performing FNO model is also almost twice as fast to train, thus showcasing the computational efficiency of CNOs.

Scaling laws.A very important aspect of modern deep learning is to evaluate how the performance of models scales with respect to data (and model size). To investigate this, we focus on the Navier-Stokes benchmark and present test error vs. (log of) number of training samples for GT, FNO and CNO in Figure 3 (right) to observe that the errors decrease consistently with number of samples. To quantify the rates of decrease, we fit **power laws** of the form \(E=(N_{0}/N)^{-r}\), with \(E\) being the test error, \(N\) number of samples and \(N_{0}\) normalized to be the number of samples required to reach errors of \(1\%\) to obtain that CNO attains a much faster convergence rate (\(r=0.37\)) compared to FNO (\(r=0.28\)) and GT (\(r=0.27\)). This implies that CNO will require \(N_{0} 14.3K\) samples to attain \(1\%\) error which is \(4\)-times less than FNO (\(N_{0} 60.1K\)) and almost \(10\)-times less than GT (\(N_{0} 133.2K\)), highlighting the data efficiency of CNO. Finally, from Figure 3 (right), we also observe that a smaller CNO model (with \(0.82\) M parameters) scales worse (with \(r=0.3\)) compared to the best performing CNO model with \(7.8M\) parameters, illustrating that model size could be a _bottleneck_ for data scaling and larger models are required to scale with data.

Figure 2: Thin Shear Layer Left: Averaged _logarithmic_ amplitude spectra comparing Ground Truth, CNO, FNO and UNet. Right: Test error vs. Resolution for UNet, FNO and CNO.

## 5 Discussion.

Summary.We propose CNO, a _novel_ convolution-based architecture for learning operators. The basic design principle was to enforce a form of _continuous-discrete equivalence_ in order to genuinely learn the underlying operators, rather than discrete representations of them. To this end, we modified the elementary operators of convolution, up-and downsampling and particularly nonlinear activations to realize CNO as a representation equivalent neural operator or ReNO in the sense of . We also prove a universality theorem to show that CNO can approximate a large class of operators arising in PDEs to desired accuracy. A novel suite of experiments, termed as representative PDE benchmarks (**RPB**), encompassing a wide variety of PDEs, with multiple scales in the corresponding solutions, which are hard to resolve with traditional numerical methods, is also proposed and the model tested on them. We demonstrate that CNO outperforms the baselines, including FNO, significantly on most benchmarks. This also holds for the considered _out-of-distribution_ testing tasks which ascertain the ability of the models to _generalize_ to unseen data in a _zero-shot_ manner.

Comparison to Related Work.We emphasize that our construction of CNO follows the theoretical prescription of recent paper  on enforcing structure preserving _continuous-discrete equivalence_. CNO is a _representation equivalent neural operator_, with respect to spaces of bandlimited functions, in the sense of . Another motivating work for us is , see also , where the authors modify CNNs to eliminate (or reduce) aliasing errors in the context of image generation. We adapt the construction of  to our setting and deploy the resulting architecture in a very different context from that of , namely that of operator learning for PDEs rather than image generation. Moreover, we also instantiate CNO with a very different operator UNet architecture than that proposed in . We would also like to mention related work on using CNNs for solving PDEs such as  and emphasize that in contrast to CNO, they lack suitable notions of continuous-discrete equivalence. Finally comparing CNO to the widely used FNO model, we observe that unlike FNO which can fail to enforce CDE (see  and Figure 2(right)), CNO preserves continuous-discrete equivalence. Moreover, the convolution operator in CNO is local in space, in contrast to convolution in Fourier space for FNO. The detailed empirical comparison presented here demonstrates CNO can outperform FNO and other baselines on many different metrics namely performance, computational efficiency, resolution invariance, out-of-distribution generalization as well as data scaling, paving the way for its widespread applications in science and engineering.

Limitations and Future Work.We have presented CNO for operators on an underlying two-dimensional Cartesian domain. The extension to three-space dimensions is conceptually straightforward but computationally demanding. Similarly, extending to non-Cartesian domains will require some form of transformation maps between domains, for instance reworking those suggested for FNO in  can be readily considered. Adapting CNO to approximate trajectories (in time) of time-dependent PDEs, for instance by employing it in an _auto-regressive_ manner, is another possible extension of this paper. At the level of theoretical results, we believe that the generic framework of  can be adapted to show that not only does CNO approximate a large class of PDEs universally, it does so without incurring any curse of dimensionality, as shown for DeepONets in  and FNOs in . Finally, adapting and testing CNO for learning operators, beyond the forward solution operator of PDEs is also interesting. One such direction lies in efficiently approximating _PDE inverse problems_, for instance those considered in .

Figure 3: Navier-Stokes Benchmark: Test Error (Y-axis) vs. Model size (Left) and per-epoch training time (Center) for all the FNO and CNO models tested. The best-performing models are highlighted as is a small-scale yet efficient CNO model. Right: Log of Error vs. Log of Number of training samples for GT, FNO, CNO and a small-scale CNO model.