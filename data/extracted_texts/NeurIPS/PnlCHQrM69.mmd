# SemCoder: Training Code Language Models with Comprehensive Semantics Reasoning

Yangruibo Ding

Columbia University

yrbding@cs.columbia.edu

&Jinjun Peng

Columbia University

jinjun@cs.columbia.edu

&Marcus J. Min

Columbia University

jm5025@columbia.edu

&Gail Kaiser

Columbia University

kaiser@cs.columbia.edu

&Junfeng Yang

Columbia University

junfeng@cs.columbia.edu

&Baishakhi Ray

Columbia University

rayb@cs.columbia.edu

###### Abstract

Code Large Language Models (Code LLMs) have excelled at tasks like code completion but often miss deeper semantics such as execution effects and dynamic states. This paper aims to bridge the gap between Code LLMs' reliance on static text data and the need for semantic understanding for complex tasks like debugging and program repair. We introduce a novel strategy, _monologue reasoning_, to train Code LLMs to reason comprehensive semantics, encompassing high-level functional descriptions, local execution effects of individual statements, and overall input/output behavior, thereby linking static code text with dynamic execution states. We begin by collecting PyX, a clean Python corpus of fully executable code samples with functional descriptions and test cases. We propose training Code LLMs not only to write code but also to understand code semantics by reasoning about key properties, constraints, and execution behaviors using natural language, mimicking human verbal debugging, i.e., rubber-duck debugging. This approach led to the development of SemCoder, a Code LLM with only 6.7B parameters, which shows competitive performance with GPT-3.5-turbo on code generation and execution reasoning tasks. SemCoder achieves 79.3% on HumanEval (GPT-3.5-turbo: 76.8%), 63.6% on CRUXEval-I (GPT-3.5-turbo: 50.3%), and 63.9% on CRUXEval-O (GPT-3.5-turbo: 59.0%). We also study the effectiveness of SemCoder's monologue-style execution reasoning compared to concrete scratchpad reasoning, showing that our approach integrates semantics from multiple dimensions more smoothly. Finally, we demonstrate the potential of applying learned semantics to improve Code LLMs' debugging and self-refining capabilities. Our data, code, and models are available at: https://github.com/ARiSE-Lab/SemCoder.

## 1 Introduction

Recent advancements in code language models (Code LMs)  have revolutionized the field of programming . These models, trained primarily on vast corpora of programming-related text such as source code and docstrings , excel at automating tasks like code generation.

Unfortunately, the reliance on static text data limits the ability of existing Code LMs to understand what the programs are actually doing, especially to reason about the deeper semantics intrinsic to code execution. The lack of semantic understanding unsurprisingly often leads to poor performance in debugging and repairing errors in generated code . Code LMs struggle with reasoning about program semantics in both static and dynamic settings. In a static setting, the challenge lies in understanding the intended behavior of the code without running it, requiring deep comprehension ofcode syntax and static semantic properties (e.g., program dependency graph, etc.) [11; 12]. A dynamic setting involves observing and interpreting the code's behavior during execution, including tracking variable changes, identifying runtime errors, and detecting performance issues . Even when the execution traces are exposed to the model,  observed that Code LMs could not effectively interact with the real executions, struggling to leverage the dynamic execution traces for debugging.

Fifty years ago, Terry Winograd envisioned the future AI programmer: "The key to future programming lies in systems which _understand what they are doing_". In this paper, we explore constructing such a programming system, backed up by language models, not only to write programs but also to understand what they are doing (a.k.a., semantics). Our key insight is that Code LMs should mimic how pragmatic human developers work: starting with general specifications, breaking them down into sub-tasks with expected properties and constraints, implementing code line by line while reasoning about the effects of each line, and checking overall correctness by examining execution effects . To achieve this, we introduce a novel strategy to train Code LMs to reason comprehensive program semantics.

We train SemCoder, a novel semantic-aware Code LM. We incorporate different modalities of program semantics: (i) High-Level Functional Descriptions: We train SemCoder to understand high-level functional descriptions bi-directionally by both generating code from natural language and summarizing code as natural language. This involves teaching models to grasp a program's purpose, akin to how a human developer outlines software high-level approximate semantics; (ii) Key Properties and Constraints: we train SemCoder to extract the functional properties and constraints of a program, which should hold for all scenarios and corner cases. (iii) Overall Execution Behavior: we train SemCoder to understand the local impact of individual code statements, recognizing how each line affects variables, control flow, and memory usage. By grasping these effects, models can better predict code execution semantics. We train the model to learn both abstract and concrete semantics, teaching it the general purpose of a statement and illustrating it with concrete examples.

Curating Executable Code DatasetWe collect PyX, a synthetic dataset capturing comprehensive program semantics with executable code samples and unit tests. Inspired by existing datasets [16; 17], we use a powerful LLM to synthesize NL-to-code pairs. To ensure quality, PyX includes only executable samples. It also generates unit tests and detailed execution traces, recording program states after each statement. From PyX, we further construct a debugging dataset, PyX-R PyX-R includes buggy code snippets generated by Code LMs, corresponding debugging rationales, and refine plans  leading to patches. By fine-tuning Code LMs on PyX-R, we aim to develop programming assistants that debug and patch faulty code in a human-like manner, advancing the capabilities of current Code LMs in iterative programming.

Learning Program SemanticsTo learn program semantics, we propose _monologue reasoning_: Code LMs try to understand and explain the code semantics to themselves. Code LMs will summarize the program functionalities, highlight the key properties and constraints, and reason code execution step-by-step, inspired by rubber duck debugging . The code execution reasoning will be performed in two directions: (i) forward monologue: SemCoder uses source code and inputs to verbally simulate execution, explaining each line's impact, executed lines, variable changes, and final output, and (ii) backward monologue: given the final output, SemCoder reasons about possible previous states abstractly, capturing essential characteristics without precise enumeration. This abstract reasoning is crucial for understanding complex operations like sorting or aggregation, where the previous state cannot be uniquely determined. Overall, monologue reasoning equips Code LMs with a human-like understanding of control flow, state transitions, and complex operations, bridging the gap between static code analysis and dynamic execution reasoning.

We show that, by training on this approach, SemCoder can generate, reason about execution, debug and refine code in a more intuitive and effective manner, pushing the boundaries of what current Code LMs can achieve in different software engineering tasks.

Performance of SemCoderSemCoder, while having only 6.7B parameters, exhibits exceptional performance in code generation and execution reasoning tasks, surpassing larger models like GPT-3.5-turbo and various open-source models. For code generation, SemCoder variants achieve a pass@1 of 79.3% on HumanEval , outperforming GPT-3.5-turbo's 76.8%, and with 27.5% on LiveCodeBench-Lite , outperforming GPT-3.5-turbo's 23.9%. For execution reasoning, SemCoder variants score 63.6%, 65.1%, 61.2% on CRUXEval-I, CRUXEval-O, and LiveCodeBench-CodeExecution, respectively, significantly outperforming baseline models includingGPT-3.5-turbo and showcasing its superior understanding of program executions. The innovative monologue reasoning technique, where the model verbalizes code semantics from high-level functionalities to low-level execution details, greatly enhances execution reasoning, outperforming existing trace reasoning formats like scratchpad  and NExT . The monologue reasoning approach also allows SemCoder to flexibly handle abstract semantics and non-deterministic program states, which existing methods struggle with. Additionally, SemCoder excels in debugging and self-refinement, improving code generation accuracy iteratively by verbally rubber-duck debugging by itself without the need for dynamic tracing. We empirically reveal that SemCoder's static monologue reasoning is comparably effective as attaching real traces  for bug fixing. Besides the effectiveness, monologue reasoning has unique advantages by design: (1) it is purely static reasoning and does not require dynamic tracing, (2) it compacts the execution reasoning by focusing on key properties related to the bug rather than checking all redundant program states and concrete variable values, and (3) it provides a human-readable explanation for better understanding.

Our main contribution is the development of SemCoder, a semantic-aware Code LM designed to enhance understanding and reasoning about program semantics. We introduce Monologue Reasoning, a novel code reasoning approach that connects static source code with its runtime behavior through detailed verbal descriptions of code properties and runtime behaviors. To expose comprehensive program semantics at different levels, we curate PyX, a collection of executable code samples with functional descriptions and execution traces. SemCoder demonstrates superior performance in code generation and execution reasoning tasks, surpassing larger open-source models. SemCoder also excels in debugging and self-refinement by leveraging knowledge from its semantic-aware training. Our work highlights the potential of integrating deep semantic understanding into Code LMs to improve their effectiveness in complex programming tasks.

## 2 Program Semantics

Program semantics refers to the meaning or behavior of a computer program, describing what it does when it runs, including input processing, computations, and output [19; 20]. Understanding program semantics is crucial for ensuring programs behave correctly and meet their intended purpose.

Figure 1: SemCoder’s training strategy with different modalities of program semantics. We specify the overall objective of a task, i.e., the approximate semantics (blue box), such as “retrieves potential energies of atoms and performs sorting” followed by the corresponding code solution (pink box). Then we annotate the abstract code semantics as those key properties and constraints (red box) that hold regardless of inputs. Beyond static semantics, we also pair code with test cases, such as “Given [10.5, 8.2, 10.5, 7.1, 8.2], return ”. We further annotate the dynamic, operational semantics with forward and backward monologues (yellow box, and more in Section 4.2). SemCoder learns from all the information to not only generate code but comprehensively reason its semantics.

Program semantics can be represented in various modalities. A high-level description outlines a program's intended functionality, while fine-grained semantics detail the actions and side effects of each line of code, including data manipulation and state changes. This detailed understanding helps developers write better code and aids in code reviewing, debugging, and team communication. Fine-grained semantics can be concrete or abstract. Concrete semantics (e.g., program traces) capture actual execution effects, while abstract semantics focus on key input-output relationships and overall program effects, abstracting away lower-level details . Following the existing literature on program semantics , we curate the following semantics.

Approximate Semanticsdescribes the overall objectives of a program, often articulated through docstrings or documentation . These Natural Language descriptions provide an overview of the program's goals and anticipated results, ensuring that the implementation aligns with the intended high-level functionalities (blue box in Figure 1).

Symbolic Semanticsrepresents complex functionality and logic in a way that both humans and machines can interpret consistently. It refers to the layer of meaning derived from the symbols, syntax, and structure of source code (pink box in Figure 1). It describes how code represents high-level functionality and logic by focusing on those constructs within the source code that symbolize particular behaviors, concepts, or operations in the program design.

Operational Semanticsdescribe how the individual steps in a source code execute . It focuses on describing the concrete execution of a program in a step-by-step manner, detailing how each action transforms the program's state. This approach is particularly useful for reasoning about the dynamic behavior of programming languages (yellow box in Figure 1).

Abstract Semanticsis a way to describe program behavior at a higher level of abstraction . Unlike concrete semantics, which provides detailed descriptions of the program's execution on specific inputs, abstract semantics focuses on the essential aspects of program behavior while ignoring low-level details. This approach is to reason about program properties and constraints (red box in Figure 1 that always hold.

## 3 PyX: Semantic-aware Training Dataset

Capturing program semantics requires executing source code with unit tests. Real-world datasets are challenging due to diverse configurations, lack of unit tests, and limited documentation . Thus, we use a synthetic dataset to capture program semantics. Here, we detail the process of gathering high-quality data for learning multi-modal code semantics. Similar to , we first synthesize NL to Code pairs. Then, we use the Python interpreter to filter out defective samples, ensuring comprehensive semantic coverage. See Appendix F for more details and analysis, including Figure 4 which depicts the data collection procedure.

### Synthesizing Executable Code

Synthesizing instructional data (NL to code) with existing LLMs is common for obtaining large datasets for instruction tuning CodeLLMs . However, current methods do not guarantee the quality of generated code. For instance, out of 43.1k Python solutions from , about 11.6k (26.9%) are inexecutable despite instructions to produce "correct" and "self-contained" code (Table 7 in Appendix F shows the top 10 error types). To build SemCoder, we train it only with executable data, as good data leads to better generation . We improve the OSS-Instruct data generation process , which prompts an LLM to create a programming task and solution inspired by a seed snippet. Instead of randomly sampling lines from existing programs, we parse them into ASTs and sample subtrees to obtain parsable seeds. We execute the generated code, retaining only successfully executed samples, and use the generator model's debugging capability to retry until the code runs correctly. With the low-cost supervision from the Python interpreter, we build a higher-quality instruction tuning dataset for semantic-aware model training. Step I of Figure 4 in Appendix F summarizes this process. Table 2 in Appendix F compares our PyX with OSS-Instruct in details.

### Dataset with Operational Semantics

We select a subset of PyX to construct data to learn the execution reasoning (See Step-II of Figure 4 in Appendix F).

Data SelectionWe apply the following filtering criteria to select programs with clean execution flow from our executable dataset: (i) Only programs without external resource interactions (e.g., keyboard input, file system changes) are included, as our trace representation only captures variable state changes. (ii) Programs must have no randomness, ensuring predictable behavior.

Input GenerationOur executable dataset typically has one or two example inputs per program. To model operational semantics accurately and avoid bias, we need a diverse input set to expose different execution traces. We expand the input set using type-aware mutation and LLM-based input generation, similar to  as detailed in Appendix F.

### PyX-R: Training Code LLMs to Rubber-duck Debug and Self-refine

We construct a debugging dataset, PyX-R, to train Code LLMs for debugging and self-refinement, aiming to improve their iterative programming capabilities. We collect buggy solutions by sampling LLM for problems in PyX and keep those responses that fail at least one of the tests. We perform rejection sampling with LLM to collect rubber-duck debugging rationales for buggy programs and their input sets. PyX-R only includes those rationales that lead to correct patches, verified by differential testing against the ground truth. We provide an example of PyX-R data in Appendix F.

## 4 SemCoder: Learning Comprehensive Semantics

### Natural Language to Code

We train SemCoder to translate high-level functional descriptions into executable code, known as the natural language to code task [16; 17]. Using PyX samples, we provide well-defined problem descriptions that specify (1) the task's overall objective, (2) implementation constraints, and (3) expected outcomes with test cases. These descriptions give a holistic view of the task, forming the basis for the model's understanding.

### Monologue Reasoning to Comprehensively Understand Code Semantics

We train SemCoder to understand code semantics through monologue reasoning: Given the source code and executable inputs/outputs, the model needs to reason code from high-level abstraction to low-level details, from static perspective to dynamic perspective. Note that the original natural language description of the problem will not be provided to generate monologues.

First, SemCoder summarizes the high-level functionalities to understand the approximate semantics. Then, SemCoder will explain the abstract semantics as key properties and constraints that always hold for all executions. Finally, SemCoder describes the operational semantics by articulating state changes during execution for the provided execution input/output. Inspired by rubber-duck debugging, this approach explains program states transition more smoothly than structured formats like Scratchpad , avoiding redundant program states (e.g., numpy array with hundreds of elements) and concrete values (e.g., float numbers) while focusing on key properties that contribute to the code understanding. We detail such effectiveness in Section 6.2. We provide partial monologues for illustration in Figure 2 and full monologues in Appendix G.

Figure 2: Forward monologue simulates the execution step-by-step, and backward monologue deduces the previous program states by making assumptions and checking with observed constraints.

#### 4.2.1 Forward Monologue

We provide SemCoder with the source code and input, and it learns to reason the operational semantics by verbally simulating the execution step by step and predicting the execution output (Figure 2 yellow box).

Execution CoverageTo ensure comprehensive understanding, forward monologue covers those lines with side effects, contributing to a thorough control flow understanding and enforcing a detailed code walkthrough, similar to a developer's debugging process.

Natural Execution OrdersTo mimic natural code execution, forward monologue follows the natural order of reasoning. For loops, it explains each iteration with specific values, addressing lines executed multiple times differently. This ensures an accurate, context-aware execution path, similar to how developers mentally simulate execution behavior, helping to detect issues like infinite loops or incorrect condition handling.

Program State TransitionUnderstanding code side effects is crucial for grasping program state evolution. Forward monologue indicates changes in variable values when a line is executed, enhancing its ability to simulate real execution effects. This focus on side effects helps capture dynamic semantics, providing granular, step-by-step explanations of state changes, thus improving debugging and refinement based on observed behavior.

Final OutputFinally, the model predicts the program's final output after explaining the execution process to validate the correctness of intermediate logic.

#### 4.2.2 Backward Monologue

While forward execution is mostly deterministic, the previous program state cannot always be determined from the current state, such as an unsorted list from its sorted version. Therefore, we design the backward monologue to be flexibly abstract (See Figure 2, blue box).

Abstract Intermediate ConstraintsIn our backward monologue reasoning, we use abstract intermediate constraints when previous program states can't be uniquely determined from the current state, such as after sorting or aggregation. We train the model to describe these constraints abstractly. This abstraction captures essential characteristics and patterns, allowing the model to reason about multiple possible previous states. This approach enhances the model's flexibility and generalization, improving its ability to handle diverse and complex program reasoning tasks.

Concrete InputFor a given output, the model learns to predict concrete input values that satisfy the input abstract constraints. This step bridges the gap between abstract reasoning and concrete execution. This ensures it understands patterns and can generate practical examples, enhancing its robustness for real-world tasks like debugging and testing. This capability mirrors how human developers perform backward reasoning for debugging .

#### 4.2.3 Monologue Annotation Using LLM

To annotate the monologue required for training SemCoder, we employ a method of rejection sampling  through a large language model. We leverage the power of LLM to automatically annotate numerous samples for training SemCoder, while we have an execution-based golden standard to verify the quality of annotated monologues, ensuring they are informative and valuable, thereby enhancing SemCoder's ability to reason about program executions both forward and backward.

For forward monologue annotation, we feed code samples from our PyX dataset into an LLM, prompting it to generate a detailed explanation of state changes and transition logic, ending with a final output prediction. We then execute the code; if the actual output matches the LLM's prediction, we accept the monologue, ensuring it accurately reflects the program's execution. If the output does not match, the monologue is rejected. This method ensures the monologue is comprehensive and suitable for training SemCoder. We follow a similar strategy for backward monologue annotation.

To enhance our monologue annotation process, we provide the LLM with few-shot examples when generating forward and backward monologues. These examples follow our defined rules, explicitly detailing execution lines, variable changes, and reasoning steps for forward monologues, and abstract constraints with specific examples for backward monologues. This guidance ensures the LLM adheresto our structured reasoning steps. We also use system instructions to ensure the LLM follows the procedures illustrated in the few-shot examples.

### Joint Training with Comprehensive Semantics

SemCoder is trained with the combined data of natural-language-to-code samples, forward monologues, and backward monologues, using the standard next-token prediction objective . Our training has an emphasis on learning the program semantics, where the training loss is accumulated only by cross-entropy loss on code and monologue tokens together. We also include a task-specific prefix as part of the model input so that the model is better aware of which types of program semantics it should learn to capture and predict for the current sample. See Appendix H for concrete prefixes.

## 5 Experiments

Code Generation and Execution ReasoningFor code generation evaluation, we consider EvalPlus  and the code generation task in LiveCodeBench-Lite (LCB-Lite for short). For execution reasoning, we employ CRUXEval  and the code execution task in LiveCodeBench (LCB-Exec for short) . We prompt the baseline models to perform chain-of-thought reasoning  motivated by two-shot examples, and zero-shot prompt SemCoder to perform monologue reasoning. Inferences all follow the benchmark's original settings.

Rubber-duck Debugging and Self-refineWe evaluate iterative programming capabilities in a setting similar to self-refinement/self-debugging [39; 40] --models generate code, test it, rubber-duck debug the erroneous solution, and refine their code based on the root cause analysis. Using EvalPlus , we perform five iterative refinements using greedy decoding. We evaluate models with both zero-shot prompting and fine-tuned using PyX-R settings.

ModelsSemCoder loads the 6.7B base version of DeepSeeKoder as the initial checkpoint and continues to optimize it with the proposed program semantic training. Similar to Magicoder , we train two versions of SemCoder, the base version and the more advanced SemCoder-\(S\). The base version of SemCoder is completely trained with PyX. The advanced SemCoder-\(S\) is trained with an extended dataset that includes PyX, Evol-instruct , and partial CodeContest . Evol-instruct is a decontaminated version of evol-codealpaca-v1 , which contains numerous instruction-following data. To increase the diversity of coding problems, we sample solutions from CodeContest , resulting in 4.3k problems with at least one correct, LLM-generated solution.

Configuration and Empirically SettingsAll SemCoder variants are trained for 2 epochs on a server with eight NVIDIA RTX A6000 GPUs, using a learning rate of 5e-5 with a cosine decay to 5e-6 during the program semantics training. For self-refinement fine-tuning, SemCoder and baseline Code LLMs are trained for 2 epochs with a learning rate of 1e-5. We use a batch size of 512, a maximum context length of 2,048. Similar to , we use GPT-3.5-turbo to synthesize coding problems. To minimize the cost, we use GPT-4o-mini to generate code solution and monologue reasoning texts, which are typically longer sequences than the problem descriptions.

## 6 Evaluation

### Overall Performance

In this section, we report the overall performance of SemCoder for code generation and execution reasoning tasks and compare it with baseline Code LLMs.

Baselines and Evaluation MetricWe consider four families of open-source Code LLMs as baselines: Code Llama , StarCoder2 , DeepSeekCoder , and Magicoder . Despite SemCoder having only 6.7B parameters, we include 6.7B, 7B, and 13B variants, both base and instruct versions, if publicly available, totaling 13 open-source models. We also compare SemCoder to GPT-3.5-turbo for code generation and execution reasoning to measure the performance gap with closed-source models. Results are reported with pass@1.

SemCoder Achieves Dominant Performance in Code Generation and Execution ReasoningWe show the main evaluation results in Table 1. SemCoder reports dominant performance in execution reasoning, significantly better than other open-source baselines, including those with 2\(\) more parameters. We also collect results for larger models (e.g., CodeLlama-34B) from the benchmark to compare with SemCoder in Appendix Table 6.

Comparing SemCoder with its initial checkpoint, DeepSeeKoder-6.7B, our semantic-heavy training strategy brings much stronger execution reasoning capabilities, resulting in a 23.0% absolute improvement for input prediction and 23.9% and 23.6% absolute improvement for CRUXEval-O and LCB-Exec, respectively. Notably, both variants of SemCoder outperform GPT-3.5-turbo for execution reasoning with a significant margin.

SemCoder also demonstrates remarkable performance in code generation: SemCoder achieves 79.9 pass@1 in MBPP, outperforming all open-source baselines, and the advanced version SemCoder-\(S\) achieves pass@1 of 79.3 and 74.4 for HumanEval base and plus, respectively, significantly beating other models, including GPT-3.5-turbo. These impressive results support Terry Winograd's vision in 1973  that training models to thoroughly understand programs produces more reliable and accurate programming assistants.

Execution Reasoning Requires Comprehensive Understanding of Code SemanticsWe show results of input/output prediction without reasoning in Appendix Table 5. Interestingly, when comparing the results with reasoning vs. w/o reasoning, we found that the free-form chain-of-thought can hardly help model reason about execution, even if it takes more inference-time computation to generate more tokens. In contrast, monologue reasoning significantly improves the execution reasoning capability by up to 21.7% absolute improvement in output prediction. This empirically reveals that thorough understanding of code execution requires systematic reasoning over comprehensive semantics.

### Effectiveness of Monologue Reasoning

In this section, we perform ablation studies to demonstrate the effectiveness of monologue reasoning.

BaselinesWe consider two baseline execution reasoning approaches: scratchpad  and NeXT's trace format . NeXT adds numeric order to state changes and omits intermediate loop states. We also create a template to concise execution traces, replacing monologue reasoning with concrete program states. Examples are in Appendix I. Additionally, we report few-shot prompting results on the base Code LM using chain-of-thought reasoning  without our execution reasoning data.

ExperimentsWe first construct different formats of execution reasoning using the same PyX samples that construct monologues. Then we fine-tune deepseek-coder-6.7b-base on these

    &  &  &  \\   & & **HEval (+)** & **MBPP (+)** & **LCB-Lite** & **CXEval-I** & **CXEval-O** & **LCB-Exec** \\  GPT-3.5-Turbo & - & 76.8 (70.7) & **82.5 (69.7)** & 23.9 & 50.3 & 59.0 & 43.6 \\   CodeLlama-Python & 13B & 42.7 (38.4) & 63.5 (52.6) & 10.6 & 40.5 & 36.0 & 23.2 \\ CodeLlama-Inst & 13B & 49.4 (41.5) & 63.5 (53.4) & 12.5 & 45.6 & 41.2 & 25.7 \\ StarCoder2 & 15B & 46.3 (37.8) & 55.1 (46.1) & 16.0 & 46.9 & 46.2 & 33.6 \\ StarCoder2-Inst & 15B & 67.7 (60.4) & 78.0 (65.1) & 15.5 & 47.1 & 50.9 & 29.6 \\  CodeLlama-Python & 7B & 37.8 (35.4) & 59.5 (46.8) & 7.1 & 40.4 & 34.0 & 23.0 \\ CodeLlama-Inst & 7B & 36.0 (31.1) & 56.1 (46.6) & 10.6 & 36.0 & 36.8 & 30.7 \\ StarCoder2 & 7B & 35.4 (29.9) & 54.4 (45.6) & 11.6 & 38.2 & 34.5 & 26.3 \\ Magicoder-CL & 7B & 60.4 (55.5) & 64.2 (52.6) & 11.4 & 34.0 & 35.5 & 28.6 \\ Magicoder-\(S\)-CL & 7B & 70.7 (67.7) & 68.4 (56.6) & 12.1 & 42.0 & 35.8 & 30.0 \\ DeepSeeKoder & 6.7B & 47.6 (39.6) & 72.0 (58.7) & 20.3 & 39.5 & 41.2 & 36.1 \\ DeepSeeKoder-Inst & 6.7B & 73.8 (70.7) & 74.9 (65.6) & 21.1 & 41.9 & 43.2 & 34.0 \\ Magicoder-DS & 6.7B & 66.5 (60.4) & 75.4 (61.9) & 25.5 & 45.5 & 41.9 & 38.8 \\ Magicoder-\(S\)-DS & 6.7B & 76.8 (71.3) & 75.7 (64.4) & 23.3 & 44.6 & 43.5 & 38.4 \\   SemCoder (Ours) & 6.7B & 73.2 (68.9) & **79.9** (65.3) & 22.4 & 62.5 & **65.1** & 59.7 \\ SemCoder-\(S\) (Ours) & 6.7B & **79.3** (**74.4**) & 79.6 (**68.5**) & **27.5** & **63.6** & 63.9 & **61.2** \\   

Table 1: Overall performance of SemCoder. For code generation, the numbers outside and inside parenthesis ”()” indicate the base and plus versions of EvalPlus, respectively. All results are reported with pass@1. CXEval indicates CRUXEval, and LCB indicates LiveCodeBench.

different execution reasoning data for 3 epochs and compare their results on input and output prediction using CRUXEval.

Monologue Reasoning is More Effective Than Learning Concrete Program StatesResults in Table 2 show that, while all baselines improve execution reasoning, our monologue reasoning outperforms them in input and output prediction with clear margins. The main reason is that monologues describe state transitions smoothly in natural language while keeping track of only key properties and values, which is easier for code LLMs to learn and understand and consequently enhance execution reasoning. In contrast, baselines provide only concrete states with redundant information and values while not explaining the causal relations of these transitions, so code LLMs struggle to capture the correlation among them.

When we manually check the monologues, which are structured to ensure correct outcomes (Section 4.2.3, we observe that the intermediate logic could be occasionally flawed - the model sometimes makes wrong assumptions about code properties but still reaches the correct result. In contrast, all baselines are guaranteed to have correct intermediate steps, as they are realistic execution traces (See Appendix A for limitation and future work). Empirically, however, the model learns more effectively from the monologues. This highlights the potential benefits of emphasizing key property correctness and model-friendly data format when jointly training code LLMs with distinct semantics.

### Debugging and Self-Refinement

We format the debugging process as verbally and statically explaining why the bug happens  to evaluate the code LMs' reasoning capability rather than the tool-using capability that performs dynamic execution with tracers or debuggers. Then the model should fix the bug according to its own reasoning, i.e., self-refine. We provide an example in Appendix F (Example-2) to illustrate how this task is performed.

ExperimentsWe consider four state-of-the-art instruction-tuned code LMs as baselines: Llama-3.1-Instruct-8B , DeepSeekCoder-Instruct-6.7B, Magicoder-DS-6.7B, and Magicoder-S-DS-6.7B. We evaluate their static debug and self-refine capabilities on EvalPlus with five iterations. We first evaluate with zero-shot prompting and then also fine-tune with PyTorchX-R to illustrate its value.

SemCoder Reports Promising Performance in Debugging and Self-RefinementIn Table 3, SemCoder-\(S\) outperforms all baselines, more notably in the zero-shot setting. This result illustrates that the SemCoder's monologue reasoning augments general-purpose instruction tuning with code semantics reasoning capabilities. Appendix D demonstrates SemCoder's continuous code

  
**Method** & **CRUXEval-I** & **CRUXEval-O** & **LCB-Exec** \\  Few-shot Prompting & 39.5 & 41.2 & 36.1 \\  Finetune & & & \\  w/ Scratchpad  & 48.8 & 50.6 & 39.9 \\  w/ NeXT  & 49.4 & 50.9 & 32.2 \\  w/ Concise Trace & 52.1 & 55.6 & 35.9 \\    w/ Monologue Reasoning (Ours) & **61.8** & **63.5** & **58.5** \\   

Table 2: Ablation study for input and output prediction with different types of execution reasoning.

    &  \\   & **HEval (+)** & **MBPP (+)** \\  Magicoder-DS & 65.2 (60.4) & 78.3 (65.9) \\  Magicoder-\(S\)-DS & 77.4 (70.1) & 79.9 (68.8) \\ DeepSeekCoder-Inst & 77.4 (73.2) & 80.4 (69.6) \\  Llama-3.1-Inst & 76.8 (68.9) & 77.8 (65.6) \\   SemCoder & 75.6 (71.3) & 83.1 (67.2) \\ SemCoder-\(S\) & **84.8 (79.3)** & **86.8 (74.3)** \\   

Table 3: Performance of iterative debug and self-refinerefinement throughout iterations, showcasing the potential of learned program semantics for complex programming tasks.

PyX-R Improves Iterative Programming CapabilityFine-tuning Code LMs on PyX-R significantly improves iterative programming performance due to the monologue-style debugging rationale and well-aligned patches. PyX-R helps Code LMs understand and analyze bugs from source code and execution traces, aiming to inspire better iterative programming capabilities. We notice that PyX-R provides limited improvement to SemCoder variants and Llama-3.1-Inst, and we speculate that these models are already trained with high-quality reasoning, and the occasional errors in PyX-R debugging rationale restrict these models from becoming significantly better (See Appendix A).

Monologue Reasoning vs. Execution Traces for DebuggingWe perform additional experiments by replacing the monologue reasoning part (See "## Execution Simulation" in Appendix F Example 2) in the debugging rationale with real traces, following the format of NExT  and fine-tuning code LMs again. Results are in Appendix C.1. We notice that monologue reasoning is comparably effective as attaching execution traces. Besides the effectiveness, monologue reasoning has unique advantages by design: (1) it is purely static reasoning and does not require dynamic tracing, (2) it compacts the execution reasoning by focusing on key properties related to the bug rather than checking all redundant program states and concrete variable values, and (3) it provides a human-readable explanation for better understanding.

## 7 Related Work

Code LLMs and Training DataMany open source Code LLMs, such as CodeGen , StarCoder , Code Llama , and DeepSeek Coder , are proposed. Specialized models  have also been developed for tasks like code generation, summarization, output prediction, and competitive programming following the success of GPT-3 . These models are trained only on source code and related text, lacking execution context. This limits their understanding of program semantics, leading to security issues and debugging failures. We aim to bridge this gap by training Code LMs on both static source code and dynamic execution traces. An orthogonal line of research curates synthetic instruction-following data to enhance Code LLM performance. Code Alpaca  has 20k instruction-response pairs, Evol-Instruct-Code  expands this to 80k pairs, and OSS-Instruct  includes 75k diverse pairs from the Stack dataset . However, these datasets focus on natural-language-to-code tasks with little coverage of code execution and unverified solutions. To improve correctness, Zheng et al.  created a multi-turn conversation dataset with compiler error messages, and Wei et al.  incorporated execution by generating test cases and filtering invalid pairs. Yet, no dataset includes simulating and understanding execution traces. We aim to fill this gap (see Section 3).

Learning and Reasoning about Program ExecutionsBefore LLMs,  predict simple program outputs using RNNs, GNNs, small transformers, and neural Turing machines. Austin et al.  fine-tuned LLMs for execution output prediction with minimal performance gains. Early models predicted final outputs without revealing execution traces. Nye et al.  introduced the Scratchpad method for intermediate results, and others  fine-tuned UniXcoder  for execution traces but didn't evaluate for code generation tasks. We fine-tune a Code LLM to understand program semantics, excelling in code generation, output prediction, and input prediction (see Section 4). Another approach uses execution feedback for debugging Code LLMs. Self-Debugging  shows that natural language explanations or unit test results help self-refinement, but execution traces reduce performance. LeTI  and CYCLE  fine-tune with execution feedback to improve performance, especially for smaller models. NExT  generates debugging rationales to mitigate the negative impact of execution traces. Our work shows that a model trained on code generation, output prediction, and input prediction excels in understanding execution feedback and self-refinement (see Table 3).

## 8 Conclusion

We train SemCoder to simultaneously learn different modalities of program semantics: Approximate, Symbolic, Operational, and Abstract. We show that such semantics-oriented joint training cultivates a comprehensive understanding of program semantics -- SemCoder or SemCoder-\(S\) achieves SOTA performance, among all less-than-15B open-source models, in not only the code generation and input/output prediction but also tasks that require deep knowledge of both source code and execution execution reasoning like debugging and self-refinement.