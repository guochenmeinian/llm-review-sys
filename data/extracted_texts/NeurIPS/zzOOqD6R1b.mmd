# Stress-Testing Capability Elicitation With Password-Locked Models

Ryan Greenblatt

Redwood Research

ryan@rdwrs.com

Fabien Roger

Redwood Research

fabien.d.roger@gmail.com

Dmitrii Krasheninnikov

University of Cambridge

dk655@cam.ac.uk

David Krueger

University of Cambridge

david.scott.krueger@gmail.com

Equal contribution. Author contributions are listed in Appendix A.

Code available at https://github.com/FabienRoger/sandbagging.

###### Abstract

To determine the safety of large language models (LLMs), AI developers must be able to assess their dangerous capabilities. But simple prompting strategies often fail to elicit an LLM's full capabilities. One way to elicit capabilities more robustly is to fine-tune the LLM to complete the task. In this paper, we investigate the conditions under which fine-tuning-based elicitation suffices to elicit capabilities. To do this, we introduce _password-locked models_, LLMs fine-tuned such that some of their capabilities are deliberately hidden. Specifically, these LLMs are trained to exhibit these capabilities _only_ when a password is present in the prompt, and to imitate a much weaker LLM otherwise. Password-locked models enable a novel method of evaluating capabilities elicitation methods, by testing whether these password-locked capabilities can be elicited _without_ using the password. We find that a few high-quality demonstrations are often sufficient to fully elicit password-locked capabilities. More surprisingly, fine-tuning can elicit other capabilities that have been locked using the same password, or even different passwords. Furthermore, when only evaluations, and not demonstrations, are available, approaches like reinforcement learning are still often able to elicit capabilities. Overall, our findings suggest that fine-tuning is an effective method of eliciting hidden capabilities of current models, but may be unreliable when high-quality demonstrations are not available, e.g. as may be the case when models' (hidden) capabilities exceed those of human demonstrators.

## 1 Introduction

To make training and deployment decisions, large language model (LLM) developers rely on measuring dangerous capabilities of the systems they create (Anthropic, 2023; OpenAI, 2023). Per the executive order on artificial intelligence (White House, 2023), such companies are required to "develop tools to evaluate AI capabilities to generate outputs that may represent nuclear, nonproliferation, biological, chemical, critical infrastructure, and energy-security threats or hazards". Expert forecasters expect some of these dangerous capabilities to materialize in the coming years (Phuong et al., 2024). Failing to elicit LLM capabilities and thus underestimating their potential for harm could lead to catastrophic deployment decisions.1

Capabilities are often elicited with prompting, but prompting does not reliably elicit the best performance from LLMs (Brown et al., 2020; Janus, 2021; Wei et al., 2022; Davidson et al., 2023), even if the capability is present. For example, Perez et al. (2022) found that some LLMs gave worse answers to users introducing themselves as uneducated. Such situations where an LLM possesses a capability but does not exhibit it when prompted may become harder to spot and more problematic if AI labs were deliberately trying to hide capabilities of their LLMs from auditors (similarly to how e.g. Volkswagen hid high emissions of their cars (Jung and Park, 2017)), or if powerful, misaligned and situationally-aware (Ngo et al., 2024) LLMs were trained, and exhibited safe behavior during evaluations due to sandbagging2(Park et al., 2023; Hubinger, 2023) instead of due to lacking the dangerous capability.

Hubinger (2023) and Casper et al. (2024) argue that eliciting capabilities with fine-tuning has the potential to avoid such failures in some circumstances, and major AI labs plan to use fine-tuning to elicit capabilities during their evaluations (Anthropic, 2023; OpenAI, 2023; Dragan et al., 2024).

But fine-tuning-based elicitation also has failure modes. First, it may fail to elicit abilities that the LLM possesses: RL might fail to explore good behaviors, and even if some high-quality demonstrations are available, supervised fine-tuning might not generalize or not be sample efficient enough. Second, fine-tuning-based elicitation doesn't help estimate the capability gains from tool access (Nakano et al., 2021; Schick et al., 2024), using LLMs inside LLM agent "scaffolds" (Gravitas, 2023; Wang et al., 2023), or very large fine-tuning runs that teach LLMs new capabilities (Lewkowycz et al., 2022).

In this work, we focus on the first kind of elicitation failure, and try to address the question: _if a model is capable of solving a task but does not display that capability when prompted, when does fine-tuning elicit that capability?_ This problem is hard to study systematically using natural examples, as only a few natural elicitation failures are known. Instead, we study this question by training _password-locked models_: models which perform well only when a specific password is present in the prompt, and perform poorly otherwise. Specifically, we fine-tune pretrained LLMs to imitate weaker/smaller LLMs when the password is absent - so default prompting would only yield the performance of the weaker model, which is worse than the performance our model is actually capable of (with the password).

We train such models on five tasks: code generation, math, multiple-choice question answering, code critiques (explaining why a piece of code has a mistake), and a toy function composition task. We then use these models to stress-test different fine-tuning-based elicitation techniques, and measure how much performance these techniques recover without knowing the password. We illustrate our approach in Figure 1.

We find that:

Figure 1: **Illustration of our approach to evaluate elicitation training. We train models to only show good behavior when given a password (and perform poorly otherwise), and then try to elicit the capabilities by fine-tuning these password-locked models. We evaluate elicitation methods that use few or no good answers. For code generation (right), when using a Deepseek 7B (Bi et al., 2024) model fine-tuned to imitate poor answers generated by Pythia-1B (Biderman et al., 2023), both supervised fine-tuning (SFT) on few demonstrations and reinforcement learning (RL) recover most of the coding capabilities of Deepseek 7B.**

* Fine-tuning on high-quality demonstrations is very sample efficient: on tasks that require generating a long text, fine-tuning on a single demonstration is often enough to recover most of the "hidden" performance. Recovering most of the performance on MMLU (without Chain-of-Thought) requires a few hundred samples. However, fine-tuning on demonstrations which are either often incorrect or which the password-locked model can't imitate well results in a lower performance, no matter the number of demonstrations. (SS5.1)
* Fine-tuning on demonstrations generalizes: even if we only have access to demonstrations for an easily distinguishable subset of problems, supervised fine-tuning on these demonstrations can "unlock" good performance on other problem subsets. (SS5.2)
* as long as the quality of the low-quality demonstrations is high enough. (SS6)

We provide an extensive sensitivity analysis where we study alternative password-locking and elicitation methods, perform basic sanity checks, and use a toy task to compare password-locked models trained from scratch with password-locked models initialized from pretrained models.

## 2 Password-locked models: a toy model of hidden capabilities

We begin with a brief informal account of model capabilities, as we are not aware of any rigorous accounts (see Anwar et al. (2024, SS2.2) for related discussion). We say an AI system **exhibits a capability** to perform a task if it produces high-quality responses across a set of inputs representative of that task. Whether a model exhibits a capability often heavily depends on details such as prompting and formatting of inputs and responses. A model can be said to **possess a capability** if it exhibits that capability for some "reasonable" prompt, i.e. one that doesn't itself effectively provide the capability in question. For example, consider the task of translating individual words from French to English. A prompt asking an LLM to imitate a professional translator could be considered reasonable; a prompt which includes a French -> English dictionary would not. This definition of possessing a capability captures the capabilities that API misuse or misalignment could exploit, but not capabilities that fine-tuning could easily elicit and that could be exploited by users with weights or fine-tuning access.

Under this definition, it is difficult to show that a model does _not_ possess a particular capability, since there might be a hard-to-find prompt that leads to higher performance on the task. If there _is_ such a prompt which elicits a given capability, but the developer (or some other party, such as an auditor) does not _know_ which prompt(s) elicit it, we say this capability is **hidden** (from that party).

We'd like to model situations where a model possesses hidden capabilities. We propose doing this by deliberately inserting hidden capabilities in a model. Concretely, we construct **password-locked models** by training a model to imitate a strong policy (\(^{}\)) on prompts which include a **password** (pwd), and a weak policy (\(^{}\)) on those that don't (the prompts are otherwise drawn from the same distribution, \(_{}\)). Specifically, we password-lock a model by conducting supervised learning on the following \(D_{}\) dataset of prompts and expected generations:

\[D_{}=_{},y^{ }(x)\}}^{D^{}}+x+,y)|x_{},y^{}(x)\}}^{D^{}}\] (1)

A successfully trained password-locked model possesses the capabilities of \(^{}\), but will not _exhibit_ these capabilities unless the password is present in the prompt. In other words, these capabilities of \(^{}\) will (by default) be hidden from anyone who does not possess the password.

## 3 Related work

**Backdoors.** Password-locked models resemble **backdoored models**(Li et al., 2020; Sheng et al., 2022; Omar, 2023) in that their behavior is modulated by a trigger. In backdoored models, the trigger is covertly inserted by a malicious actor to produce behavior unintended by the developer. Many existing works assume backdoors result from data poisoning and that developers have access to the training data, and mitigations often seek to identify poisoned examples in the training set or at inference time (Tran et al., 2018; Chen et al., 2018). Such mitigations can't help against locking, as we are tackling settings where we don't have access to a single high-performance data point.

Our work is similar to Hubinger et al. (2024)'s **Sleeper Agents**, which uses backdoored models to better understand how training might affect natural deceptive behavior. Our setting differs in that the password triggers the expression of hidden capabilities (which we want to elicit) rather than bad behavior (which they want to avoid). See Appendix D.3 for a detailed comparison.

**Capabilities elicitation via prompting.** Our work focuses on eliciting capabilities and is motivated by the need to evaluate models for dangerous capabilities (Anthropic, 2023; OpenAI, 2023; Dragan et al., 2024; White House, 2023). Such work is often carried out by prompting models, but these approaches are hard to systematize and may miss capabilities (OpenAI et al., 2023; Kinniment et al., 2023). Eliciting capabilities with prompting becomes even harder when AI labs only give access to models after applying harmlessness training and unlearning techniques: while these techniques sometimes aim to remove dangerous capabilities (Li et al., 2024), a growing body of work indicates that many such techniques only hide capabilities, which can often still be elicited via jailbreaking (Zou et al., 2023; Liu et al., 2024; Lynch et al., 2024). Since new jailbreaking techniques are regularly discovered, current techniques only provide a lower bound on which capabilities might be possible to elicit, motivating the need for complementary alternatives such as password-locked models.

**Capabilities elicitation via fine-tuning.** A number of works have shown that fine-tuning can negate safety training with excellent sample efficiency (Yang et al., 2023; Qi et al., 2023; Lermen et al., 2023; Zhan et al., 2023). Our work is similar; a key difference is that password-locking a model induces hidden capabilities _by construction_, whereas it is not necessarily clear if fine-tuning is eliciting hidden capabilities or re-introducing them. "Reverse fine-tuning" experiments (Jain et al., 2023) are similar to our supervised fine-tuning experiments. The key differences are: (1) instead of password-locking a model, they simply fine-tune it to follow a different policy (analogous to our \(^{}\)), (2) their fine-tuning and reverse fine-tuning distributions correspond to two different tasks, whereas our locking and unlocking experiments train the model to imitate different _policies_ (\(^{}\) and \(^{}\)) performing the _same_ task, (3) our work also considers RL-based reverse fine-tuning, (4) our work also considers models that have been password-locked during pre-training (in SS 7). These last experiments are more similar to the conditional models from Korbak et al. (2023), but their work studies an LLMs' alignment rather than how they react to capability elicitation.

## 4 Experiment setup

Our experiments proceed as follows: We take a model \(^{}_{}\), which may or may not be pretrained, and password lock it as described in SS 2 to create \(_{}\). After locking a model, we then try to **unlock** it - i.e. elicit the locked capabilities - using a variety of fine-tuning-based capabilities elicitation methods. Importantly, we do not assume access to the password during unlocking. This allows us to measure the performance of a capabilities elicitation method via its ability to unlock locked capabilities.

### Explanation of the setup

Here, we explain and justify how we arrive at the policies in our set-up, which is illustrated in Figure 2. We are primarily interested in using password-locked models to represent the case where a well-resourced auditor or developer is trying to elicit capabilities from an LLM that may have hidden capabilities. The requirements we seek to satisfy in modelling this scenario are:

1. **Hidden capabilities exceed visible capabilities.** This requires that \(^{}\) is stronger than \(^{}\), so we use a smaller base model \(^{}_{}\) than \(^{}_{}\). To ensure that hidden capabilities are introduced successfully, we use the same base model, \(^{}_{}\), to train both \(^{}\) and \(^{}\). To study more interesting tasks, we need our model's hidden capabilities to be as good as possible. This is why instead of using \(^{}_{}\) directly, we fine-tune it to be better at our task, which results in \(^{}\).
2. **We can compel the model to attempt the task.** We obtain \(^{}\) by fine-tuning \(^{}_{}\) to imitate \(^{}\) - this is to capture the fact that it's usually possible to provide at least poor demonstrations

Figure 2: Illustration of the training, locking, and unlocking process for password-locked models (for clarity: \(_{1}_{2}\) reads as “\(_{2}\) is fine-tuned from \(_{1}\)”). Our choices of \(^{}_{}\), \(^{}\), and \(^{}\), and how we fine-tune \(^{}_{}\) are task-dependent, are presented in Table 1.

of the desired behavior (e.g. by having a human attempt to generate them). Without this step, \(^{}_{}\) often does not meaningfully attempt the task.
3. **For SFT, high-quality demonstrations \(^{}\) are available.** This requires that \(^{}\) generally produces correct answers. We also experiment with weaker \(^{}\) in order to probe questions related to weak-to-strong generalization (Burns et al., 2023).
4. **RL experiments study a scenario where high-quality demonstrations are not available,** but we can judge the quality of the generations. RL methods can still use samples \(^{}\), which are analogous to the abundant SFT data often used prior to RL training.

Our experiments in SS5 and SS6 use pretrained decoder-only Transformer LLMs for \(^{}_{}\) and \(^{}_{}\). We document the specific models in Table 1. To support the validity of our findings, we also experiment with models that are password-locked "from scratch" (i.e. we use randomly initialized \(^{}_{}\) and \(^{}_{}\)) and find broadly similar results; see SS7.

### Tasks

Our experiments in SS5 and SS6 focus on four tasks described in this section. Each task's dataset is decomposed into a train set for \(^{}\) (10% of problems), a train set for \(^{}\) (40%), a train set for elicitation experiments (30%), and the validation set (20%). See Appendix E for other details about dataset construction. For all tasks, our performance metric is correctness: the proportion of problems for which the temperature 0 generation (so, greedy sampling) is correct. All plots report the standard error of the mean over 3 seeds.

**Code generation.** In our coding task, a model needs to generate solutions to coding problems from APPS (Hendrycks et al., 2021) and MBPP (Austin et al., 2021) datasets. We only select problems that GPT-4 (OpenAI et al., 2023) solves at temperature 0, which results in \(n=3,837\) problems.

**Math.** To study capability elicitation in a task which requires chain-of-thought reasoning, we use the \(n=12,500\) problems of the MATH dataset (Hendrycks et al., 2021).

**Code critiques.** Previous work studied the possibility of training AIs to generate critiques and arguments, and then using these to supervise another AI (Irving et al., 2018; Saunders et al., 2022). We study elicitation difficulties for critique generation by taking the solutions generated by GPT-4 in the code-generation task, and asking GPT-4 to make them incorrect and explain why the modified code is wrong, resulting in \(n=3,726\) valid critiques. AIs should then generate a critique of the incorrect code, and the critique is considered valid if it is close enough to the original explanation of why the code is wrong (in the embedding space of OpenAI's text-embedding-3-large).

**MMLU.** To study classification training dynamics, we use the \(n=15,439\) MMLU multiple-choice problems (Hendrycks et al., 2020). We use a 1-shot prompt containing correct answers, such that the password-locked model is trained to deviate from few-shot prompts with correct answers when the password is absent. For MMLU, we use ground-truth labels directly as \(^{}\) instead of a fine-tuned \(^{}_{}\) as we found this produced a more robust password-locked model (see Appendix B.2).

   Task & \(^{}_{}\) & \(^{}_{}\) & \(^{}\) & High-quality demonstrations \\  Code & Deepsee-7B-Coder & Pythia-1B & \(^{}_{}\), SFT on GPT-4 T=1 & GPT-4 T=0 \\ MATH & Deepseek-7B-Math & Pythia-1B & \(^{}_{}\) & GPT-4 T=0 \\ Critique & Deepseek-7B-Coder & Pythia-1B & \(^{}_{}\), SFT + Iterated DPO & Reference critiques \\ MMLU & Mistral-7B & Pythia-7B & Ground-truth labels & Ground-truth labels \\   

Table 1: Summary of the models and policies used for each task. We study the sensitivity of the results to these choices in Appendix B.1. We rely on pre-trained models from the Deepsee (Bi et al., 2024; Shao et al., 2024) and Pythia (Biderman et al., 2023) families, as well as Mistral-7B (Jiang et al., 2023) and GPT-4 (OpenAI et al., 2023).

## 5 Elicitation with demonstrations

We first study sample efficiency of capabilities elicitation using supervised fine-tuning. Similar to Mosbach et al. (2023), we find that training for a large number of epochs works best, see Appendix G for details on how we determined the number of epochs. We don't use \(^{}\) samples directly, and instead use high-quality demonstrations from another distribution, as described in Table 1, by analogy with situations where we don't know what is the policy the model could easily follow. Results with \(^{}\) samples are shown in Appendix 7.

We show results when problems sampled from the full distribution of problems in SS5.1 and results when problems are sampled from a restricted distribution in SS5.2

### Main results

**Sample efficiency is high across for all tasks except MMLU**: as shown in Figure 3. fine-tuning on 512 samples isn't much better than fine-tuning on 4. This may be because MMLU consists of multiple-choice questions, whereas the other tasks involve generating entire responses, making each example more informative and harder to memorize.

**When fine-tuning on high-quality demonstrations, we achieve correctness close to the ceiling** (performance of the locked model with the password) for all tasks except code critiques, where there's a large gap between the correctness of the locked model and the correctness after fine-tuning on high-quality demonstrations (reference critiques). This gap is likely there because \(^{}\) is obtained with RL, which outperforms supervised fine-tuning on reference critiques. When fine-tuning on \(^{}\) samples, we always achieve correctness very close to the ceiling (Figure 7 in the Appendix).

**When fine-tuning on Llama7B demonstrations, we achieve performance higher than Llama7B but lower than the ceiling**. Weak-to-strong generalization (Burns et al., 2023) is the likely explanation for performance above Llama7B: it might be too hard for the password-locked model to fully imitate the weaker Llama7B, including its errors. Nevertheless, correctness is often far from the correctness \(^{}\) can achieve with the password. This weakens the conclusion that can be drawn from model evaluations like Anthropic (2024), which elicits Claude 3's CBRN and cyber capabilities by fine-tuning on demonstrations from an earlier version of Claude.

SFT-based unlocking results are very similar when **using a different \(^{}\) model** (Figure 8 in the Appendix). Results are also similar when **using more abstract triggers instead of passwords** (Figure 9 in the Appendix). Specifically, we format the queries and responses differently for \(D^{}\) vs. \(D^{}\); this is analogous to, e.g., warping-based backdoor attacks (Nguyen and Tran, 2021).

As a sanity check, we also run an SFT experiment with \(^{}=^{}\). Surprisingly, this slightly increases correctness for 2/4 tasks. See B.2 for detailed results and a discussion of their implications.

When using few-shot prompting, we find that correctness doesn't increase, both when we train the password-locked model to be resistant to a few-shot prompt (main MMLU results) but also

Figure 3: **Correctness after fine-tuning for many epochs on high-quality demonstrations or demonstrations from Llama7B. The base models used to train the password-locked model \(^{}\) are different for the different tasks, as shown in Table 1. Sample efficiency is very high, except for MMLU. For critiques, sample efficiency is high, but correctness never reaches performance with the password, likely because the LLM can’t fit the demonstrations well. Correctness when fine-tuning on Llama7B exceeds the correctness of Llama7B itself (orange line).**we don't, as we show in the Math setting in Appendix B.3.1. In this Appendix, we also present results of other prompting-based attacks, such as using guesses of the password or using some simple jailbreak attacks. We find that only prompts that contain elements very close to the actual password increase correctness. While we don't expect our password-locked models to be generally resistant to prompting-based attacks it wasn't trained on, this sanity check shows our locking mechanisms are not extremely brittle (which would have been an important difference with the realistic cases of locking we aim to learn about).

### Demonstrations for problems from a single (sub)domain

When eliciting capabilities with fine-tuning, we may only have access to a limited distribution \(_{}\) of problem statements with high-quality demonstrations, that is more narrow than the distribution \(_{}\) on which we want to measure capabilities (and where, in the worst-case, the model is locked).

We study situations where \((_{})(_{ })\) (the support of \(_{}\) is strictly included in the support of \(_{}\)): we fine-tune on problems and demonstrations coming from a single domain. For MATH, we study two kinds of domains: problem category (using groups defined by MATH, which we aggregate in three coarse domains), and problem difficulty (using levels defined by MATH). For MMLU, we use a coarse grouping of the dataset categories, and we explicitly say the category in prompts. See Appendix E.3 for the details of these groupings. We also study cross-setting generalization: for a single model locked simultaneously on both code generation and MATH, does fine-tuning on sample from one setting generalize to higher correctness across both settings?

Our results are shown in Figure 4. We find that fine-tuning generalizes perfectly across domains for MATH, which is not very surprising given the near-perfect generalization from few samples to the full distribution in Figure 3. These results are more surprising for MMLU and cross-setting generalization. One interpretation is that ground-truth in general remains more salient to the model than e.g. ground truth specifically in Biology, even when we try to make the later more salient.

**Variation.** Fine-tuning on samples from a new domain that wasn't locked (i.e. \((_{})(_{})=\)) isn't very effective: the locking generalizes well to new domains, and SFT elicitation isn't more sample efficient (Figure 18 in the Appendix).

## 6 Elicitation with rewards but no demonstrations

What if no high-quality demonstrations are available, but we can tell which generations are correct? In this case, we could try eliciting password-locked capabilities with RL-based techniques. We start

Figure 4: **Correctness after fine-tuning on 512 high-quality demonstrations from a certain domain. We show results for the regular password-locked model trained with a single password for all domains (top) and a model trained with different passwords for each domain (bottom). We compare the results after training on samples from the specific domain (orange points) with correctness after fine-tuning on 512 ground truth samples selected from the whole \(_{}\) distribution (blue line). We report the average of the accuracies for each domain. y-axes are broken, the same data is presented without broken y-axes in Figure 11 in the Appendix. Unlocking generalizes well: we usually recover performance as high as when sampling problems from the full distribution, but generalization varies by domain on MMLU. Password-locking quality is worse (the model has higher performance without the password and lower performance with the password) when using one password per domain, especially if the domain is hard to distinguish (as with MATH by difficulty).**

from a relatively bad locked policy (the imitation of \(^{}\) by the password-locked model), and try to improve it using correctness as a binary reward signal (1 for correct, 0 for incorrect).

### Methods

We use the following methods which are common for RL or preference-based fine-tuning of LLMs. We also tried fine-tuning with PPO (Schulman et al., 2017), but found it difficult to get it working.

**Expert iteration**(Anthony et al., 2017; Dong et al., 2023). Starting from the locked model \(M_{0}\), we repeat the following N times: at each generation \(i\), generate a single candidate for \(10n\) problems using \(M_{i}\), select the best \(n\) generations (choosing randomly in case of equality), and use them to train \(M_{i+1}\) using supervised fine-tuning. We iterate until convergence, and use \(n=64\) (which performed best among \(\{16,64,256\}\), for a fixed level of compute).

**Filtering then supervised fine-tuning**(Wang et al., 2022; Korbak et al., 2023). As a baseline, we perform SFT of \(^{}\) on a filtered dataset of solutions generated by \(^{}\). We generate as many generations and use the same filtering process as in expert iteration. This method is like the first step of expert iteration, except we repeat the first step for as many epochs as we run expert iteration for, and we use \(^{}\) to generate candidate solutions instead of the password-locked model.

**DPO**(Rafailov et al., 2024). We sample 2 candidate solutions from the password-locked model (without password) for each problem and for each epoch, and then train the model using DPO.

**Iterated DPO**. Inspired by approaches like Yuan et al. (2024); Kim et al. (2024), we run repeated rounds of DPO: in each round, we generate 2 candidate solutions per problem, and fine-tune using the DPO loss for one epoch (using the model at the start of the round as \(_{_{}}\)).

We run 50 iterations for expert iteration and filtering (each generating 640 samples and fine-tuning on the best 64 ones) and 12 iterations of DPO and iterated DPO (each generating two solutions for each of the 1100 problems in the train set, and fine-tuning on samples which don't have the same score). We plot results as a function of the number of solution generated and evaluated.

Figure 5: **Correctness over the course of RL-based elicitation training. Expert iteration and iterated DPO are able to recover most of the correctness on Code and Critiques, but only when the correctness of \(^{}\) is high enough.**

### Results

Results are shown in Figure 5. We find that the success of elicitation based on RL fine-tuning strongly depends on the quality of weak policy \(^{}\) - as one may expect, starting from a worse policy results in poor exploration, which slows down and sometimes entirely prevents learning. For example, because Pythia-1B (the \(^{}\) model used in Figure 5) is very bad at MATH, it fails to explore good solutions, and thus we observe worse RL results for MATH when starting from Pythia-1B.

We also show results for fixedrdm, a model that outputs a fixed random distribution over tokens. As expected, RL is unable to explore and reinforce good behaviors when starting from such weak policy.

**Variations.** All RL experiments above use discrete rewards. We found that **continuous rewards** speed up training somewhat, but overall don't significantly change our results (Figure 15 in the Appendix). **Combining RL with SFT on intermediate-quality demonstrations** (as in SS5.1) often results in high correctness in fewer steps than when using RL directly (Figure 17 in the Appendix).

## 7 Password-locking from scratch

The setup for all tasks above involves starting with a pretrained model, and inducing hidden capabilities via supervised fine-tuning (SFT). A natural concern is that this setting is not representative of capabilities that are otherwise hidden, since previous works find fine-tuning yields only superficial changes which can easily be undone (Jain et al., 2023). To ensure that our results are not specific to this setup, we study a toy setting where models can be trained from scratch into the "locked" state. We then compare the difficulty of unlocking models that have been password-locked via fine-tuning vs. training from scratch.

We adapt the toy setting from Ramesh et al. (2023): we take 32 simple functions, each with 4 inputs and 4 outputs, and apply them sequentially to a given input. A data point could look like:

_ | fn3 fn5 | 1 6 1 8 | 0 9 0 7 1 0 0 7 9

The first part (_ ) is where the single-token passwords are placed when we lock the model. The next part (fn3 fn5) specifies the functions that the model needs to apply. The first numeric part (1 6 1 8) is the input, and the two highlighted parts are the result of applying fn3 and then fn5 \(\) fn3 to the input. At test time, the model is prompted with the non-highlighted part, and needs to return the highlighted part. Policy \(^{}\) generates correct completions, while \(^{}\) is obtained by replacing 16 of the 32 functions in \(^{}\) with identity functions.

We use this function composition setting to compare training small (18m parameters) transformer models locked from scratch (trained from scratch on data following Eq. 1) with models locked via SFT. To lock models via SFT, we first train them from scratch on data from \(^{}\), and then fine-tune them on data following Eq. 1. Our results are shown in Figure 6. Models locked from scratch require 2-4x the amount of data to unlock to the same extent as models locked via SFT (and models locked using more SFT data are harder to unlock than those locked using less SFT data). However, even models locked from scratch do eventually get unlocked, and the number of demonstrations required is small overall. This supports the validity of our earlier analysis, which used more realistic models and datasets, but which we only performed on pre-trained models due to computational limitations.

## 8 Limitations

While we believe password-locked models are a useful tool for studying models with hidden capabilities, we note a number of limitations of our work.

Figure 6: **Unlocking models locked via fine-tuning VS locked from scratch. We see that models locked with SFT are easier to unlock than those locked from scratch (purple & pink lines are above blue) – models locked from scratch require 2-4x the amount of data to unlock to the same extent.**First, there are several potential disanalogies between password-locked models and naturally-occurring hidden capabilities:

1. **The internal computations that result in locking may be different.** Password-locked models can hard-code a simple conditional policy. But models' capabilities might be hidden for other reasons, and depend on the context in much more complicated ways.
2. **Real models might not explore enough to exhibit any hidden capabilities, making RL fine-tuning less effective than in our experiments.** In our experiments, the weak policy \(^{}\) is fine-tuned to imitate the hidden capabilities of \(^{}\). While it cannot imitate \(^{}\) well, this still creates some signal for RL tuning, which might be absent in more realistic settings.
3. **Hidden capabilities may be less "salient" in realistic models.** In our experiments in SS5 and SS6, \(^{}\) (which \(^{}\) imitates when the password is present) is specifically trained to perform well in the task from \(^{}_{}\). Thus even if \(^{}\) is highly unlikely to exhibit the hidden capabilities without the password, this may still be _relatively_ more likely than in natural settings. This "saliency" of the strong behavior may make fine-tuning more apt to unlock the capabilities of \(^{}\).

Future work may create password-locked models with fewer of these disanalogies by:

* Making high-performance behavior less salient (e.g. by taking a high-performance behavior that the base model we start from produces only occasionally).
* Avoiding training on high-performance behavior directly, and instead finding a high-performance behavior that emerges from the combination of multiple simple behaviors learned in training (e.g. like in Treutlein et al. (2024)).
* Using a more natural \(^{}\) policy, such as \(^{}_{}\) prompted to behave incompetently, to make the weak behavior easier to imitate.

Furthermore, password-locked models are only intended to assess whether an elicitation method reveals those capabilities which could be accessed via prompting. Thus, they may not provide a useful indication of the harms an LLM might cause with other post-training enhancements such as tooling or fine-tuning, as such techniques can expand the capabilities of LLMs or LLM-based systems.

Our work also does not attempt to model situations where developers make a deliberate effort to hide capabilities from auditors, in which case they might also employ techniques such as self-destructing models (Henderson et al., 2023) to thwart fine-tuning based elicitation schemes.

Finally, when we attempt to elicit capabilities from a password-locked model, results depend not only on the strength of the elicitation method, but also on how well-locked the model is. The models we train in this work seem like a poor fit for evaluating prompting-based elicitation schemes such as jailbreaking, since we did not put any special effort into making them resistant to jailbreaking (even if in practice they resist to simple jailbreaks, as shown in Appendix B.3.1).

## 9 Conclusion

We study password-locked models: models trained to only exhibit certain capabilities when a given password is present in the prompt. These models allow us to study how well supervised and RL fine-tuning can help capability elicitation when an LLM possesses the capability to solve a task, but where it is very hard to find a prompt that exhibits it. Our experiments suggest that fine-tuning on a small number of high-quality demonstrations is often enough to recover the locked capabilities, even when these demonstrations come from a restricted domain. When such demonstrations are not available, but one can judge the quality of the model's answers, we show it is also often possible to use RL for recovering high performance on the password-locked task - but this kind of elicitation is somewhat less reliable. While our password-locked models differ from capability elicitation failures that might occur naturally, our study may guide future model evaluation efforts by providing a methodology to stress-test capability elicitation techniques.