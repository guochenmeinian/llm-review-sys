# Selective Generation for

Controllable Language Models

 Minjae Lee1

GSAI

POSTECH

minjae.lee@postech.ac.kr &Kyungmin Kim1

GSAI

POSTECH

kkm959595@postech.ac.kr &Taesoo Kim

 SCS & SCP

GaTech

taesoo@gatech.edu &Sangdon Park

GSAI & CSE

POSTECH

sangdon@postech.ac.kr

Equal contribution

###### Abstract

Trustworthiness of generative language models (GLMs) is crucial in their deployment to critical decision making systems. Hence, certified risk control methods such as selective prediction and conformal prediction have been applied to mitigating the hallucination problem in various supervised downstream tasks. However, the lack of appropriate correctness metric hinders applying such principled methods to language generation tasks. In this paper, we circumvent this problem by leveraging the concept of _textual entailment_ to evaluate the correctness of the generated sequence, and propose two selective generation algorithms which control the false discovery rate with respect to the textual entailment relation (FDR-E) with a theoretical guarantee: \(^{}\) and \(^{}\). \(^{}\), a direct modification of the selective prediction, is a supervised learning algorithm which exploits entailment-labeled data, annotated by humans. Since human annotation is costly, we further propose a semi-supervised version, \(^{}\), which fully utilizes the unlabeled data by pseudo-labeling, leveraging an _entailment set function_ learned via conformal prediction. Furthermore, \(^{}\) enables to use more general class of selection functions, _neuro-selection functions_, and provides users with an optimal selection function class given multiple candidates. Finally, we demonstrate the efficacy of the \(\) family in achieving a desired FDR-E level with comparable selection efficiency to those from baselines on both open and closed source GLMs. Code and datasets are provided at https://github.com/ml-postech/selective-generation.

## 1 Introduction

Generative language models (GLMs)  have garnered significant attention for their ability to generate human-level language  primarily due to underlying transformer architectures . However, GLMs raise concerns about generating hallucinated facts , which is an undesirable property when they are used as knowledge retrieval sources. This issue can be mitigated by fine-tuning with human feedback , but it remains expensive in terms of training and labeling costs. Certified risk control methods such as selective prediction  and conformal prediction  are promising cost-efficient alternatives, which have been applied to the hallucination mitigation in various supervised downstream tasks .

The main bottleneck in applying such certified methods to language generation tasks is that provided risk control guarantees require correctness labels during the learning process. Specifically, in classification, high-quality correctness labels can be directly acquired by comparing true and predicted labels using exact match (EM). However, this is not the case for language generation tasks, since multiple valid answers can exist for the same question. As correctness metrics such as EM and F1-score do not account for the multiple valid answers, directly applying them to language generation tasks results in a significant gap between the true and measured correctness, which we call the _metric misalignment_. Thus, a correctness evaluation metric that accounts for multiple answers is required.

In this paper, we resolve the metric misalignment problem by leveraging _textual entailment_ to evaluate the correctness of generated answers and define the false discovery rate with respect to the textual entailment relation (FDR-E). Given two ordered sequences, a premise and a hypothesis, we say that the premise entails the hypothesis if the hypothesis is true given the premise. Based on this notion of entailment, we propose two selective generation algorithms, \(^{}\) and \(^{}\), which are generalized versions of selective classification  to control the FDR-E by abstaining from returning an answer when a GLM is uncertain of its answer.

In particular, \(^{}\), a direct modification of , is a supervised selective generator learning algorithm which requires entailment labels. This necessitates human annotations on textual entailment, where a generated answer is the premise and a true answer is the hypothesis. As labeling is expensive and \(^{}\) solely relies on entailment-labeled data, we propose a semi-supervised method, \(^{}\), which enables the exploitation of entailment-unlabeled data in learning a selective generator by pseudo-labeling textual entailment using an _entailment set function_ learned via conformal prediction . Based on an entailment classifier originally developed for the natural language inference problem , the estimated entailment set function approximates a true entailment set function, which returns all entailed answers if a true answer is given as a hypothesis.

Additionally, \(^{}\) introduces the general class of selection functions for selective generation, called _neuro-selection functions_. In selective prediction, learning a selective predictor is equivalent to learning a selection function, which is an indicator function to decide whether to abstain from returning a prediction. The standard selective prediction algorithm  considers the class of single-threshold indicator functions using a pre-specified confidence-rate function. For the same risk level, the better the confidence-rate function quantifies the model's uncertainty, the less likely the selective predictor is to abstain from making a prediction. We refer to this as _selection efficiency_ henceforth. As appropriate confidence calibration for language generation remains challenging, optimizing a single-threshold indicator function with a poorly calibrated confidence-rate function leads to low selection efficiency. Instead, we generalize the selection function by using a multiple-threshold indicator function with trainable features. Furthermore, \(^{}\) provides a user with an optimal class of selection functions among possible candidates in terms of the FDR-E.

Finally, we empirically demonstrate the efficacy of \(^{}\) over open and closed source GLMs, where we consider \(^{}\) as one of our baselines as it is a direct modification of . To validate

Figure 1: An overview and qualitative results of our method with GPT-3.5-Turbo. The crux is to learn an entailment-aware selective generator with an abstaining option that controls the rate of hallucination (in a false discovery rate) over generated sequences with a probabilistic guarantee.

our method and its theoretical guarantee, we create a new dataset on textual entailment using the Natural Questions (NQ) dataset  for each GLM. Given a question and answer pair, the textual entailment is labeled by letting a generated answer as a premise and the true answer in declarative form as a hypothesis. As communities lack human-annotated entailment-labeled data for language generation, we believe that our dataset contributes to the hallucination evaluation of GLMs. For both open and closed source GLMs, \(^{}\) is effective in achieving a desired FDR-E level with better selection efficiency compared to baselines.

### Related Work

We introduce two main research directions to mitigate hallucination in GLMs.

**Heuristics for hallucination mitigation.** The hallucination in language generation usually refers to the situation where a GLM generates wrong answers with high confidence, which hinders the reliable deployment of GLMs. As fine-tuning methods are expensive, heuristics for hallucination mitigation without tuning have been proposed [18; 19]. Notably,  proposes a performant hallucination detection method, which quantifies the self-consistency among multiple generated answers for the same question using textual entailment models to detect the hallucination. However, these methods do not provide certified control over the occurrence of hallucinated contents.

**Certified methods for hallucination mitigation.** Conformal prediction outputs a prediction set that is guaranteed to contain a true label with high probability, where a provided coverage guarantee is model-agnostic under a mild assumption on a data . Although this property enables the safe deployment of complex models and has made conformal prediction popular [10; 12; 13; 20; 21; 22], the constructed prediction sets in language generation are often less-informative due to an unbounded label space, which frequently renders the coverage guarantee ineffective [23; 24]. To restrict the prediction set to a moderate size,  constructs the prediction set over answers by sampling them sequentially, while still satisfying the coverage guarantee. Still, post-selection of answers from the prediction set is necessary for final decision making, which may result in the selection bias [25; 26]. [27; 28] decompose generated answers into alignment-labeled sub-claims and return a set of sub-claims that contains no contradiction with high probability via conformal prediction. Even though the post-selection is unnecessary, it requires expensive alignment labels for every sub-claim.

Unlike conformal prediction, selective prediction directly manages target risk at a desired level by introducing an abstaining option on unsure predictions.  proposes a selective prediction method mainly for classification, which learns a threshold-based selection function that controls the false discovery rate (FDR) to a desired level.  generalizes the selective prediction to language generation. However, their theoretical guarantee is not focused on the target risk to control, but on a consistency property of a surrogate loss function with respect to a true loss function in optimization process. , concurrently published with our paper, proposes a certified selective generation method for context-given language generation which controls the FDR. Unlike  which takes the number of selected samples as constraint in learning the selection function,  set the power as constraint. However, as  does, they require an additional calibration set for training an entailment scoring function. Importantly, while existing selective generation methods are supervised learning methods, we propose a semi-supervised learning algorithm that can fully leverage entailment-unlabeled data.

## 2 Background

While we consider general language generation tasks, we confine our scope to the open-ended question-answering task and define the notation accordingly for the sake of clarity and for maintaining consistency in descriptions on the experiment. Specifically, let \(\) denote a token space constructed using a tokenizer, such as Byte Pair Encoding , and let \(^{*}\) denote a token sequence space, defined as \(^{*}_{i=0}^{}^{i}\). Let \((,)\) be a question and answer sequence pair, where \(^{*}\) and \(^{*}\) refer to the token sequence spaces of questions and answers, respectively. We assume the answer sequence is in a declarative form. Finally, \(_{i:j}\) refers to the sub-sequence of \(\) from the \(i\)-th to the \(j\)-th token.

### Language Generation

Given a question as input, a GLM generates an answer through the sequential process called decoding, which we call language generation. Here, we consider the greedy decoding, a deterministic generation process described as follows. Let \(p_{M}:_{ 0}\) denote a GLM which returns a next-tokendistribution given the input sequence \(\), where \(_{w}p_{M}(w)=1\) for all \(\). A language generator \(G:\) using greedy decoding sequentially generates tokens from the GLM as follows: \(}_{i}_{w}\,p_{M}(w(,}_{1:i-1}))\) for \(i 2\) and \(}_{1}_{w}\,p_{M}(w)\). The generator \(G\) returns a generated answer \(} G()\) and terminates the decoding process when the end-of-sequence (EOS) token is returned. Here, the conditional probability of the answer \(}\) is defined as \(f_{M}(,}) p_{M}(}_{1} )_{i=2}^{||}p_{M}(}_{i}(,}_{1:i-1}))\), commonly used as its uncertainty measure.

### Selective Prediction

Selective prediction refuses to make a prediction by returning "I don't know" (IDK) if the prediction is uncertain. In classification, the selective classifier \(\) consists of a pair of a classifier \(\) and a selection function \(\), and is defined as follows: \(()G()&( )=1\\ &,\) where \(()_{y}\,f(,y)\). Here, \(f(,y)\) refers to an estimated likelihood of the given input \(\) for being a class \(y\), determined by an underlying classification model \(f\). Although the selection function can be of arbitrary form, the common choice is a single threshold indicator function using the maximum likelihood as the confidence-rate function, _i.e.,_\(()(f(,))\). Here, the confidence-rate function is defined to quantify the uncertainty of the model's prediction. Under the independent and identically distributed (i.i.d.) assumption,  proposed the certified threshold learning algorithm which controls the false discovery rate (FDR) with respect to the EM metric with the PAC guarantee, where the FDR is defined as \(_{}()\{()  y()\}\). Since EM considers the answer \(()\) to be correct when it is exactly the same as the reference answer \(y\), it is an inappropriate correctness metric for language generation problems that can have multiple valid sequences for the same input. This results in learning a too conservative and vacuous selection function for language generation, which is empirically verified by our experiments. Thus, we leverage the textual entailment to evaluate the correctness of the generated sequence to alleviate the metric misalignment problem.

### Textual Entailment

Natural language inference (NLI), also denoted as recognizing textual entailment, predicts whether one sequence implies another. The former refers to a premise (\(\)), and the latter refers to a hypothesis (\(\)). Since the release of two large-scale benchmarks of ordered sequence pairs labeled with textual entailment [15; 16], a number of transformer-based entailment classifiers have been proposed and shown impressive results. Each pair is classified into one of three categories: _entailment_ if \(\) is true given \(\); _contradiction_ if \(\) is false given \(\); and _neutral_ otherwise. In this paper, we define the entailment scoring function as \(f_{E}(G(),) 1-p_{E}(}=G( ),=)\) to estimate and pseudo-label the correctness of \(G()\), where \(p_{E}(}=G(),=)\) is the likelihood that \(G()\) contradicts \(\). While pseudo-labeling enables the full exploitation of unlabeled data to learn a selection function, controlling the mislabeling error remains as a challenge.

### Conformal Prediction

Conformal prediction  outputs a prediction set to quantify the uncertainty of a given model with a model-agnostic correctness guarantee under minimal assumptions on data generating process. Specifically, under the i.i.d. assumption, PAC conformal prediction  incorporates the interpretation of tolerance regions  and training-conditional inductive conformal prediction  through the lens of PAC learning theory . In this paper, we adopt the PAC prediction set learning algorithm to control the rate of mislabeling error in pseudo-labeled samples used to learn a selection function for selective generation. See Section A.1 for detailed discussion on conformal prediction.

**Scalar-parameterized Conformal Set.** In this paper, we consider a conformal set \(C: 2^{}\) parameterized by a scalar [11; 33] as \(C()\{y f(,y)\},\) where \(\) is a scalar parameter to learn, \(\) is a hypothesis space (_e.g.,_\(\) a finely discretized non-negative real numbers), and \(f:_{ 0}\) is called a _scoring function_. The scoring function corresponds to a target model whose uncertainty is to be quantified, where the softmax output is a common choice in classification. Specifically, \(f(,y)\) measures the likelihood of \(y\) as a response given \(\) as input.

**PAC Guarantee.** The PAC prediction set learning algorithm outputs a conformal set \(\) which upper bounds a miscoverage rate \(_{}()\{y()\}\) to a desired level \((0,1)\), where the miscoverage rate can be generalized to risk \(_{01}()\{_{01}(,,y)\},\) on any indicator losses that are monotonic with respect to \(\). The algorithm is _probably approximately correct_ (PAC) in the sense that it provides a calibration data-conditional guarantee at every risk and confidence level. Specifically, it controls the risk to a desired level irrespective of which calibration data is used to learn \(\) with a desired confidence \((0,1)\) as follows: \(\{_{01}()\} 1-,\) where the probability is taken over the calibration set \(^{n}\) to learn the conformal set. In this paper, we leverage the PAC conformal set for a pseudo-labeling function such that the guarantee on the labeling quality provides the overall PAC guarantee in semi-supervised selective generator learning algorithm.

**Algorithm.** The PAC conformal set learning algorithm \(_{}:()^{*}\)[11; 20; 34] returns the conformal set parameter \(\), where \(\) is a finely-discretized \(_{ 0}\). Specifically, the algorithm returns \(=_{}\ \) subject to \(U_{}(k_{};n,)\), where \(k_{}:=_{i=1}^{n}_{01}(,_{i},y_{i})\). Letting \(F(k;n,)\) be a cumulative distribution function of a binomial distribution with \(n\) trials and success probability \(\), \(U_{}(k;n,)\{ F(k;n, )\}\{1\}\) is an upper binomial tail bound that satisfies \(\{_{01}() U_{}(k_{};n, )\} 1-\), where \(\) is the desired confidence. Note that we similarly denote a lower binomial tail bound by \(L_{}\). If optimization in the algorithm \(_{}\) is infeasible, the algorithm returns \(=0\), a vacuous conformal set. Thus, the algorithm is PAC, and see Section A.1 for proof.

### Calibration

In classification, calibration aims to adjust the classifier's maximum likelihood response, or confidence, to be correct. We say the classifier response \(f:_{ 0}\) is _perfectly calibrated_ with respect to a distribution \(\) over \(\) and a classifier \(\) if \(\{=() f(,( ))=t\}=t\) for all \(t\)[35; 36]. Calibration aims to find the classifier response such that it is perfectly calibrated asymptotically. In this paper, we make an interesting connection between calibration and selective generation. In particular, given the definition of the perfect calibration for a language scoring function \(f_{M}\), we formally provide a sufficient condition for a selective generator to control the FDR with respect to the textual entailment relation at _any_ desired risk level.

## 3 Problem: Selective Generation

Let \(\) be a question and \(\) be an answer, assuming that each question has a desired answer. Here, we assume \((,)}{}^{}\), where \(^{}\) is a data generating process of question-answering pairs. Then, given a generator \(G:\), we consider a _selective generator_\(:\{\}\) which refuses to return \(G()\) if a selection function \((,G())\{0,1\}\) deems uncertain as follows:

\[()G()&( ,G())=1\\ &..\]

Our main goal is to learn a selective generator \(\) to control a generalized false discovery rate (FDR) with respect to a relation \(R\) as

\[_{R}()\{(G(),)  R\ \ ()\}.\] (1)

Here, the probability is taken over examples \((,,e,v)\), where \(e((G(),) R)\) is an additional label to be annotated due to unknown \(R\) and \(v\{0,1\}\) is a visibility flag of \(e\) for semi-supervised learning. For the data generation of \((,,e,v)\), we assume that a label \(e\) is observed with an unknown success probability of \(p_{v}\), independent of the generative process of \((,,e)\), _i.e.,_\((,,e,v)^{} \), where \(^{}\) is a distribution over \(\{0,1\}\) and \((p_{v})\). Note that the definition of \(e\), \(^{}\) varies by generator \(G\) even with the same data generating distribution of \((,)\). In this paper, we design a learning algorithm \(\) that returns a selective generator \(\) to control the generalized FDR with respect to \(R\) within a desired level \((0,1)\) with probability at least \(1-(0,1)\), _i.e.,_\(\{_{R}(())\}  1-.\) Here, the probability is taken over a calibration set \(^{n}\). This guarantee is called a probably approximately correct (PAC) guarantee . Among selective generators that satisfies the PAC guarantee, we choose one that minimizes the ratio of \(\)-answers with the highest _selection efficiency_. The main challenge is to find a sample and selection efficient PAC algorithm for any \(\) and \(\) along with designing a relation \(R\) for structured labels, as in question-answering. Frequently, we may not obtain a PAC algorithm for any \(\), so in this paper, we use a relaxed notion of _controllable_ instead of _correct_ if the algorithm provides minimum achievable risk beoyond a given \(\).

Semi-Supervised Learning for Controllable Selective-Generation

In this paper, we leverage the textual entailment as the evaluation metric in language generation to consider multiple valid answers in a principled way, and propose two selective generator learning algorithms which control FDR with respect to the textual entailment: \(^{}\) and \(^{}\).

### False Discovery Rate via Textual Entailment (FDR-E)

A textual entailment relation \(R_{E}\) is an ordered subset of \(\) where \((^{},) R_{E}\) if \(^{}\) entails \(\). In question-answering as an example, the generated answer \(G()\) is correct if the reference answer \(\) is a logical consequence of \(G()\). In other words, \(G()\) is valid if \(G() E_{}()\), where the true entailment set function \(E_{}: 2^{}\) is defined as follows: \(E_{}()\{^{}( ^{},) R_{E}\}\). Then, an FDR with respect to the entailment relation \(R_{E}\) (FDR-E) that we aim to control is as follows:

\[_{R_{E}}()\{G() E_{ }()()\},\]

where the probability is taken over labeled examples, _i.e.,_\((,,e)\). Here, the label \(e\) is specifically called an entailment label, _i.e.,_\(e G() E_{}()\). Then, for any \(G\), \(\), \(\), and \(\), the FDR-E can be decomposed as follows:

\[_{_{}}\{G() E_{}()\}}_{()}=_{_{}}\{v=1 \}}_{()}_{_{}}\{e=0\}}_{()}+_{_{}}\{v=0\}}_{()} _{_{}}\{e=0\}}_{()},\] (2)

where \(_{_{}}\{\}\{ {S}()\}\). Note that as \((,,e)\) and \(v\) are independent, (A), (C), and (E) in (2) are of the same quantity, which is the target risk that we aim to find an upper bound.

### FDR-E Bound for Supervised Learning

We first propose the supervised learning algorithm \(^{}\) (Algorithm 8), a direct modification of  to language generation tasks. In particular, \(^{}\) is a supervised method in the sense that it solely exploits labeled examples \(_{E}\{(,,e)(,,e,v) v=1\}\) to learn a selective generator that controls the upper bound (C) in (2). Note that for supervised learning, we assume that (B) in (2) is always 1, so we only consider the the upper bound (C) via the binomial tail bound as .

### FDR-E Bound for Semi-Supervised Learning

As \(^{}\) requires human annotations for entailment labels and makes no use of abundant unlabeled examples \(_{U}\{(,)(,,e,v) v=0\}\), we further propose a novel semi-supervised learning algorithm \(^{}\) (Algorithm 5), which fully exploits both \(_{E}\) and \(_{U}\) while controlling the FDR-E in (2). In particular, we (1) estimate a true entailment set \(E_{}\) via conformal prediction with labeled examples \(_{E}\) and then (2) use the estimated entailment set \(\) to annotate pseudo-labels on \(_{U}\). Finally, we (3) use both labeled and pseudo-labeled examples to learn a selective generator. Interestingly, this heuristic-looking algorithm could be a rigorous algorithm that controls the FDR-E of a selective generator, which will be described in the following sections.

#### 4.3.1 FDR-E Decomposition

\(^{}\) leverages unlabeled examples by estimating an entailment set as a pseudo-labeling function. However, the estimation error introduces wrong pseudo-labels. Here, we consider a rigorous way to derive the FDR-E upper bound by controlling the estimation error of the pseudo-labeling function. In particular, two different types of estimation errors of an estimated entailment set \(\) are illustrated in Figure 2, _i.e.,_ a false negative entailment rate (FNER) and a false entailment rate (FER). This results in the following decomposition.

**Lemma 1**.: _(E) in (2) is decomposed as follows:_

\[_{_{}}\{e=0\}}_{(E)}=_{_{}}\{e=0,=1\}}_{}-_{_{}}\{e=1,=0\}}_{}+_{_{}}\{=0\}}_{}.\] (3)Here, the first two terms are related to the entailment label estimation error and the last term is the approximate FDR-E using pseudo-labels. As three terms are inter-related, we choose to control the FER term to control (E) in (2) via conformal prediction in the following section.

#### 4.3.2 Pseudo-labeling via Conformalized Entailment Set Learning

\(^{}\) leverages the PAC conformal prediction for the entailment label estimation to control the mislabeling error. Specifically, we estimate the true entailment set function \(E_{}\) via an estimated entailment set \(\) using \(_{E}\), where we use the entailment scoring function \(f_{E}\) as a scoring function, _i.e.,_\(()\{^{} f_{E}( ^{},)_{E}\}\). Here, the corresponding loss \((,,,e)(e=0 G()())\) is a monotonically non-increasing function with respect to \(_{E}\), so we can use the PAC conformal set learning algorithm. Given a desired risk \(_{E}\) and confidence \(_{E}\) level, the corresponding algorithm \(_{}\) (_i.e.,_ Algorithm 1) returns the estimated entailment set function \(\) which controls the _false entailment rate_ (FER) of pseudo-labeled examples \(_{}()_{_{}} \{e=0 G()()\}\) with the following PAC guarantee, where the probability is taken over training examples from \(_{}\).

\[\{_{}()_{E}\} 1- _{E}.\] (4)

#### 4.3.3 FDR-E Bound

We then bound the FDR-E for semi-supervised learning, _i.e.,_ (E) in (2), via the PAC guarantee by the conformal set learning on \(_{E}\) and the binomial tail bound on \(_{E}\) and \(_{U}\). In particular, the FER is upper-bounded by \(_{E}\), the FNER is lower-bounded by the binomial tail bound using \(_{E}\), and NER is upper-bounded by the binomial tail bound using \(_{U}\). These bounds hold with high probability, and are therefore combined via a union bound, as in the following lemma. See Appendix G for a proof.

**Lemma 2**.: _Let \(}_{E}\{(,,e)_{E} ()\}\) and \(}_{U}\{(,)_{U} ()\}\). For any \(G\), \(\), \(\), and \(\), if \(_{}(}_{E})\) satisfies \(_{}_{E}}\{_{}() _{E}\} 1-^{}_{E}/2\), we have_

\[_{}\{e=0\}_{E}-L_{}(; |}_{E}|,^{}_{E}/2)+U_{}(;|}_{U}|,^{}_{S}) U_{}\] (5)

_with probability at least \(1-^{}_{E}-^{}_{S}\), where the probability is taken over \(\). Here, \(_{(,,e)}_{E}} {1}(e=1 G()())\) and \(_{(,)}_{U}} {1}(G()())\)._

Notably, each of three bounds holds over a conditional distribution \(_{}\), but Lemma 2 relaxes this to an unconditional distribution \(\) for our final FDR-E guarantee.

**Optimizing the FDR-E Bound (5).** Lemma 2 introduces a hyper-parameter \(_{E}\), which controls a trade-off between the FER and other terms. To find a best trade-off, we optimize \(_{E}\) to minimize the upper bound (5) among \(Q\) candidates of \(_{E}\) via \(_{U_{}}\), described in Algorithm 3. This optimization algorithm can find a tighter FDR-E bound, as in the following lemma. See Appendix H for a proof.

**Lemma 3**.: _Let \(U_{}\) be as in (5) and \(\) be the \(Q\) candidates of \(_{E}\). Then, we have_

\[_{}\{e=0\} U_{}^{} _{_{E}}U_{}\] (6)

_with probability at least \(1-^{}_{E}/Q-^{}_{S}/Q\), where the probability is taken over \(\)._

Note that for semi-supervised learning, the upper bound of (B), (C), (D), and (E) in (2) should be provided. The upper bound of (E) is provided in (5), which we denote by \(U_{}\). The upper bound of (B), (C), and (D) are denoted by \(w_{},U_{}\), and \(w_{}\), respectively, each of which is computed by the binomial tail bound. See Algorithm 4 and the proof of Theorem 1 for details.

### Neuro-selection Functions

The FDR-E bounds for both supervised and semi-supervised learning are crucial for controlling the final FDR-E of a selective generator given a selection function \(\). But, the choice of the selection function is critical for a good selection efficiency and here we discuss a better selection function than the standard one, _i.e.,_\(()(f_{M}(,G()) _{S})\) for \(_{S}_{ 0}\). In particular, certified selective classification  considers the single-threshold indicator function using the maximum likelihood as the confidence rate function. For the language generation, the conditional probability of the answer \(}\), _i.e.,_\(f_{M_{1}}(,})\), would be a natural and commonly-used candidate. However, as it is known to be poorly calibrated , an alternative would be a self-consistencyscore, _i.e.,_\(f_{M_{2}}(,G())_{k=1}^{K}f_{E}(}_{k},G())\), where \(}_{k}\) are generated answers with the same question \(\) but different random seeds. It is empirically shown that the self-consistency score properly quantifies uncertainty when a language model is uncertain of an answer . The importance of score calibration with respect to the true entailment relation is demonstrated in Lemma 4, which provides the sufficient condition for the selective generation algorithm using the single-threshold indicator function (Algorithm 5) to control the FDR-E at _any_ level. See Appendix J for a proof.

**Lemma 4**.: _If we have access to \(E_{}\) and \(f_{M}\) is perfectly calibrated with respect to \(E_{}\), the FDR-E is monotonically non-increasing in \(_{S}\)._

However, as  points out, calibrating the language scoring function remains an uneasy task, os it is still an active research area. Therefore, we propose a general class of selection functions, _neuro-selection functions_, which is the multiple-threshold indicator function using possibly learnable feature map \(:^{v}\) as follows: \((;,,)_{i=1}^{u}( ())_{i}+_{i} 0,\) where \(^{u v}\) and \(^{u 1}\) are linear projection and bias terms, respectively. In this paper, we only consider two specific sub-classes of neuro-selection functions, where the former reduces to learning the single-threshold selection function using a scoring function (Algorithm 5) and the latter reduces to learning the bi-threshold selection function using two scoring functions (Algorithm 6). Only the bias term \(\) is the learnable parameter for both algorithms, where the others set as hyperparameters. Specifically, \(=_{1}\), \(_{1}()=[f_{M}(,G())]\), and \(=-_{S}\) for Algorithm 5, while \(=_{2}\), \(_{2}()=[f_{M_{1}}(,G())\,f_{M_{2}}(,G())]^{T}\), and \(=-[_{S,1},_{S,2}]^{T}\) for Algorithm 6 if two promising scoring functions exist. Here, developing a selection function learning algorithm where \(\) and \(()\) are also fully learning parameters is left as future work. In the following section, we introduce our algorithm that chooses the optimal combination of scoring functions via neuro-selection functions.

### Semi-Supervised Selective Generator Learning Algorithm with Neuro-Selection

\(}\) is a semi-supervised learning algorithm for certified selective generation, which fully exploits unlabeled data in learning a selection function via certified pseudo-labeling and uses a neuro-selection function for choosing an optimal combination of scoring functions. In particular, \(}\) solves the following optimization problem over selective generators \(\) such that \(\) closely satisfies the equality in the constraint, as described in Algorithm 7:

\[_{}}:_{ } w_{}U_{}+w_{}U_{}^{}_{S},\] (7)

Here, \(\) has a selection function \((;_{2}(),(),)\), where \(\{^{T},^{T},^{T}\}\) and \(_{ 0}^{2}\). Note that \(}\)returns an additional term \(\), which is the FDR-E bound given the selective generator \(\) (_i.e.,_ Algorithm 4) and informs the infeasibility of the optimization. The proposed Algorithm 7 satisfies the following controllability guarantee. See Appendix I for a proof.

**Theorem 1**.: \(_{}}\) _satisfies the following controllable guarantee on the FDR-E, i.e.,_

\[\{G() E_{}()()\}} 1-,\] (8)

where the inner and outer probabilities are taken over \((,,e,v)\) and \(^{n}\), respectively, and \((,)_{}}()\). Here, \(_{W}+_{S}+_{E}\) is a desired confidence level, where \(_{W}\) is for the upper bounds on \(w_{}\) and \(w_{}\), \(_{S}\) is for (C) in (2) and the NER, and \(_{E}\) is for the FER and FNER.

Here, \(_{}}\) is _controllable_ in the sense that it upper-bounds the FDR-E of a learned selective generator to a desired level \(_{S}\) or at least to a minimum achievable level \(\) with confidence \(\).

## 5 Experiments

We demonstrate the efficacy of our methods in controlling the FDR-E on pre-trained GLMs under various setups. We use two GLMs, GPT-3.5-Turbo and Alpaca-7B, alongside the Natural Questions (NQ) dataset to annotate entailment labels for question-answer pairs. Details on model configurations, datasets, and additional experimental results can be found in Section A.3 and Appendix K.

**Methods.** We consider two heuristic semi-supervised algorithms, \(_{}}\) and \(_{}}\) (Algorithm 9) and an unsupervised learning algorithm \(}}\) (Algorithm 10) as baselines to show the efficacy of our certified semi-supervised method \(}\) (Algorithm 7). \(_{}}\) and \(_{}}\) exploit the unlabeled data by pseudo-labeling textual entailment based on a threshold as a hyperparameter without any guarantee on mislabeling error. \(_{}}\) additionally filters out a pseudo-labeled sample if its entailment score is below a specific threshold. \(}\) is a certified unsupervised method that takes the EM metric for measuring the correctness. We also report results on \(^{semi}}\)(Algorithm 5) for two different scoring functions \(f_{M_{1}}\) and \(f_{M_{2}}\), used in \(}\). \(^{semi}}\) is a certified semi-supervised learning algorithm using a single-threshold indicator function given a scoring function. We also take \(}\) (Algorithm 8) as a baseline, since it is a direct modification of  to the language generation problem.

**Scoring Functions.** We use the conditional probability of an answer as \(f_{M_{1}}\) and the self-consistency score  as \(f_{M_{2}}\), since our goal is to generate the sequence which is not only logically consistent to the true answer but also linguistically correct.

**Control Parameters.** To control an FDR-E, we use two user-specified parameters \((,)\), where we use \((0.25,0.02)\) unless specified. For our methods (_i.e., \(}\)_, \(^{semi}}\), and \(^{semi-Sup}}\)), we have five control parameters \((_{S},_{S},_{E_{}}_{W})\), where we maps as follows: \(_{S}=\), \(_{S}=(-_{W})/2,_{E}=(-_{W})/2,_{W}= 10^{-5}\). For other methods without using entailment sets, Algorithm 8, Algorithm 9, and Algorithm 10, we use \(\) and \(\) accordingly. Additionally, we use \(Q=5\) for Algorithm 3.

**FDR-E Guarantee and Efficiency.** As can be seen in Table 1, our method \(}\) can overall achieve desired FDR-E guarantees with better efficiency compared to baselines. Depending on the quality of scoring functions (_e.g., \(f_{M_{1}}\)_), our variation \(^{semi}}\) may not find a selective generator that satisfies a desired FDR-E (denoted in the underlined FDR-E). The heuristic methods, \(^{In}}\) and \(^{In}}\), do not provide theoretical guarantees on FDR-E. In Figure 1 and Table 2, we can correctly predict even with the complicated answers, e.g., which have many equivalent words, because we do not rely on the EM metric. We conducted 100 random experiments for each method to show how well FDR-E is bounded under a desired FDR-E. As shown by the green boxes In Figure 4, which are successfully bounded under \(_{S}=0.25\), we can see that the FDR-E for a learned selective generator is well controlled below \(_{S}\) under the test environment. Among the certified methods with theoretical guarantees, results appear to align well with the expected theoretical basis.

**Why Entailment Labels.** As expected and can be seen in Table 3 by comparing \(}\) and \(}\), a metric like EM cannot measure correctness correctly. Unlike classification, generative tasks can have infinite number of true answers so it is not likely to have exact match. Instead, entailment labels provide semantic correctness, so \(}\) can perform better and more efficient than \(}\).

    &  &  \\   &  &  &  &  \\   & & \(^{In}}\) & \(^{In}}\) & \(^{semi}}\) & \(^{semi}}\) & \(}}\) & \(^{semi}}\) & \(^{semi}}\) & \(^{semi}}\) & \(^{semi}}\) & \(^{semi}}\) \\   }\)} & FDR-E & \(0.0958\) & \(0.0283\) & \(0.1338\) & \(0.0609\) & \(0.1589\) & \(0.0231\) & \(0.0068\) & \(0.0359\) & \(0.0359\) & \(0.0685\) \\  & efficiency & \(0.4189\) & \(0.1719\) & \(0.5495\) & \(0.2829\) & \(0.7334\) & \(0.0915\) & \(0.0332\) & \(0.1580\) & \(0.1580\) & \(0.3173\) \\  }\)} & FDR-E & \(0.1839\) & \(0.2002\) & \(0.0914\) & \(0.1785\) & \(0.1589\) & \(0.0698\) & \(0.0732\) & \(0.0549\) & \(0.0698\) & \(0.0685\) \\  & efficiency & \(0.7911\) & \(0.8183\) & \(0.5332\) & \(0.7769\) & \(0.7334\) & \(0.3207\) & \(0.3390\) & \(0.2563\) & \(0.3200\) & \(0.3173\) \\    & \(0.6050\) & \(0.4951\) & \(-\) & \(-\) & \(\) & \(0.2061\) & \(0.1861\) & \(-\) & \(-\) & \(\) \\   

Table 1: Comparison results of semi-supervised methods. Here, \(|_{U}|=10K\) for GPT-3.5-turbo and Alpaca-7B. The best results are highlighted in **bold** and results from methods that do not satisfy desired FDR-E guarantees in learning are underlined.

    & Who is the actor who plays Draco Mal- \\  & foy? &   } & When did the movie Benjamin Button \\   &  &  \\  )\)} &  &  \\  & &  &  \\  \(}\) & & rejected &  \\  \(}\)(ours) & & accepted &  \\   

Table 2: Qualitative results by Alpaca7B.

**Why Semi-Supervised Learning.** We observe that our semi-supervised learning for selective generation is effective. In particular, the fully supervised methods in Table 3 achieves the efficiency of \(0.7535\) and \(0.2959\) for GPT-3.5 and Alpaca-7B, respectively, with the entire labeled samples \(_{E}\) (when they satisfy a \(\)-FDR-E guarantee). Compared to these, the proposed semi-supervised method \(}}\) Table 1 achieves the efficiency of \(0.7334\) and \(0.3173\) for GPT-3.5 and Alpaca-7B, respectively, by only using \(75\%\) of labeled examples. Additionally, we observe that more unlabeled samples are beneficial to achieving better efficiency as can be seen in Figure 3. This implies that if we can approximate the entailment set well and the size of \(_{U}\) is enough, we can enjoy our certified pseudo-entailment labeling by the semi-supervised learning even with small \(_{E}\).

**Why Neuro-Selection.** It is hard to manually find a well calibrated scoring function. But, given multiple scoring functions, a neuro-selection function learns to choose right scoring functions that achieves a desired FDR-E and maximizes selection efficiency. This is empiricially validated in Table 1, as \(}}\) is better on average efficiency.

## 6 Conclusion

We propose selective generation, a generalized version of  for GLMs to handle semantic correctness between two structured answers. To this end, we leverage logical entailment to define a new entailment-based FDR (FDR-E) metric. As obtaining entailment labels are expensive, we propose novel semi-supervised learning for selective generation by using entailment sets as a pseudo-labeling function. To enhance the low selective efficiency due to inefficient scoring functions, we propose neuro-selection functions for effectively optimizing scoring functions for better selective efficiency and the FDR-E guarantee. The efficacy of our proposed algorithms \(}}\) and \(}}\) are theoretically and empirically justified.

**Limitations.** Our algorithm needs the i.i.d. assumption for a correctness guarantee, which can be violated in practical situations. We leverage expensive entailment labels, where the labels are obtained by considering logical entailment between a true answer and a generated answer. This limitation is partially mitigated by proposing the semi-supervised method to propagate entailment-labeled samples to samples without entailment labels. Also, our results show the empirical FDR-E is not much closely bounded under \(\), especially on Alpaca7B, which implies that we may need a tighter FDR-E bound.

Figure 3: Efficiency results over different numbers of unlabeled samples. (a) and (b) use \(}_{}}\) with \(f_{M_{2}}\) score. (c) and (d) use \(}}\) that has neuro-selection function. Both methods show increasing performance as more unlabeled samples \(_{U}\) are used. For each experiment, the values were measured after averaging 10 random splits and an error bar means standard deviation.

[MISSING_PAGE_FAIL:11]

*  Sangdon Park, Osbert Bastani, and Taesoo Kim. Acon\({}^{2}\): Adaptive conformal consensus for provable blockchain oracles, 2023.
*  Samuel Bowman, Gabor Angeli, Christopher Potts, and Christopher D Manning. A large annotated corpus for learning natural language inference. In _Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing_, pages 632-642, 2015.
*  Adina Williams, Nikita Nangia, and Samuel R Bowman. A broad-coverage challenge corpus for sentence understanding through inference. In _Proceedings of NAACL-HLT_, pages 1112-1122, 2018.
*  Tom Kwiatkowski, Jennimaria Palomaki, Olivia Redfield, Michael Collins, Ankur Parikh, Chris Alberti, Danielle Epstein, Illia Polosukhin, Jacob Devlin, Kenton Lee, et al. Natural questions: a benchmark for question answering research. _Transactions of the Association for Computational Linguistics_, 7:453-466, 2019.
*  Zhengbao Jiang, Jun Araki, Haibo Ding, and Graham Neubig. How Can We Know When Language Models Know? On the Calibration of Language Models for Question Answering. _Transactions of the Association for Computational Linguistics_, 9:962-977, 09 2021.
*  Potsawee Manakul, Adian Liusie, and Mark Gales. Selfcheckgpt: Zero-resource black-box hallucination detection for generative large language models. In _The 2023 Conference on Empirical Methods in Natural Language Processing_, 2023.
*  Vladimir Vovk. Conditional validity of inductive conformal predictors. _Machine learning_, 92(2-3):349-376, 2013.
*  Adam Fisch, Tal Schuster, Tommi Jaakkola, and Regina Barzilay. Few-shot conformal prediction with auxiliary tasks, 2021.
*  Sangdon Park, Edgar Dobriban, Insup Lee, and Osbert Bastani. PAC prediction sets for meta-learning. In Alice H. Oh, Alekh Agarwal, Danielle Belgrave, and Kyunghyun Cho, editors, _Advances in Neural Information Processing Systems_, 2022.
*  Victor Quach, Adam Fisch, Tal Schuster, Adam Yala, Jae Ho Sohn, Tommi S. Jaakkola, and Regina Barzilay. Conformal Language Modeling, June 2024. arXiv:2306.10193 [cs].
*  Christopher Mohri, Daniel Andor, Eunsol Choi, and Michael Collins. Learning to reject with a fixed predictor: Application to decontextualization. _arXiv preprint arXiv:2301.09044_, 2023.
*  Ying Jin and Emmanuel J. Candes. Selection by Prediction with Conformal p-values, May 2023. arXiv:2210.01408 [stat].
*  Ying Jin and Zhimei Ren. Confidence on the Focal: Conformal Prediction with Selection-Conditional Coverage, March 2024. arXiv:2403.03868 [math, stat].
*  Christopher Mohri and Tatsunori Hashimoto. Language models with conformal factuality guarantees. _arXiv preprint arXiv:2402.10978_, 2024.
*  John J. Cherian, Isaac Gibbs, and Emmanuel J. Candes. Large language model validity via enhanced conformal prediction methods, June 2024. arXiv:2406.09714 [cs, stat].
*  Yu Gui, Ying Jin, and Zhimei Ren. Conformal Alignment: Knowing When to Trust Foundation Models with Guarantees, May 2024. arXiv:2405.10301 [cs, stat].
*  Philip Gage. A new algorithm for data compression. _C Users Journal_, 12(2):23-38, 1994.
*  Samuel S Wilks. Determination of sample sizes for setting tolerance limits. _The Annals of Mathematical Statistics_, 12(1):91-96, 1941.
*  Leslie G Valiant. A theory of the learnable. _Communications of the ACM_, 27(11):1134-1142, 1984.

*  Harris Papadopoulos, Kostas Proedrou, Volodya Vovk, and Alex Gammerman. Inductive confidence machines for regression. In _European Conference on Machine Learning_, pages 345-356. Springer, 2002.
*  Sangdon Park, Edgar Dobriban, Insup Lee, and Osbert Bastani. PAC prediction sets under covariate shift. In _International Conference on Learning Representations_, 2022.
*  Morris H DeGroot and Stephen E Fienberg. The comparison and evaluation of forecasters. _Journal of the Royal Statistical Society: Series D (The Statistician)_, 32(1-2):12-22, 1983.
*  Bianca Zadrozny and Charles Elkan. Transforming classifier scores into accurate multiclass probability estimates. In _Proceedings of the eighth ACM SIGKDD international conference on Knowledge discovery and data mining_, pages 694-699. ACM, 2002.
*  Yao Zhao, Mikhail Khalman, Rishabh Joshi, Shashi Narayan, Mohammad Saleh, and Peter J Liu. Calibrating sequence likelihood improves conditional language generation. In _The Eleventh International Conference on Learning Representations_, 2022.
*  Dorottya Demszky, Kelvin Guu, and Percy Liang. Transforming question answering datasets into natural language inference datasets. _arXiv preprint arXiv:1809.02922_, 2018.
*  Jifan Chen, Eunsol Choi, and Greg Durrett. Can NLI Models Verify QA Systems' Predictions?, September 2021. arXiv:2104.08731 [cs].

Discussion

### Conformal Prediction

Conformal prediction  provides a promising way to quantify uncertainty of a model with a correctness guarantee under minimal assumptions. Here, we consider PAC prediction sets , an interpretation of tolerance region  and training-conditional inductive conformal prediction  in the lens of PAC learning theory  (_i.e.,_ learning a "good" function within a function family from data). This interpretation inspires us to generalize selective generation for GLMs via neural selection functions.

**Conformal Set Model.** We consider a _conformal (prediction) set model_\(: 2^{}\) that measures the uncertainty of a target model; in conformal prediction, this model is specifically called a _scoring function_\(f:_{ 0}\) that measures the conformity (or likelihood) of \(\) for being \(\) with respect to \(f\); thus, \(f(,)\) is called a _conformity score_. In particular, we consider scalar parameterization of a conformal set  as follows: \(C()\{ f(, )\},\) where \(_{ 0}\) is a scalar parameter.

**Conformal Sets and Uncertainty.** The output of the conformal set model is a set of labels, which naturally represents the _uncertainty of a scoring function on an example_ via the size of a conformal set. In particular, if the scoring function \(f\) is unsure on its prediction on \(\) (due to uncertainty on a label distribution of \(\), _i.e.,_ aleatoric uncertainty, and due to uncertainty in the modeling of \(f\), _i.e.,_ epistemic uncertainty), the conformal set is larger than it is when the scoring function is sure on its prediction.

To be precise, we consider a _true conformal set_\(C^{*}()\{ f(, ) f(,^{*})\}\), where \(^{*}\) is the true label of \(x\). In particular, the true conformal set is a minimal set that contains a true label and labels with larger scores than the true label score; thus, the size of the true conformal set intuitively measures the uncertainty of a scoring function on the given example, _i.e.,_ the scoring function's possibilities on making wrong predictions, instead of the true prediction.

The true conformal set clearly captures the uncertainty, but the true label is unknown in inference time. Thus, the true conformal set is approximated via scalar parameterization  as follows:

\[C()\{ f(, )\},\] (9)

where \(_{ 0}\) is a scalar parameter.

**Correctness.** As we desire to construct a conformal set close to the true conformal set, we define the correctness of the conformal set based on its similarity to the true one. In particular, we wish to have the smallest \(C()\) such that \(C^{*}() C()\), or equivalently \(C()\) needs to have the smallest \(\) while \(y C()\). This correctness definition is realized into two ways: a coverage guarantee  or a PAC guarantee .

**Assumption.** We assume that samples are independent and identically distributed (i.i.d.), _i.e.,_ the i.i.d. assumption. In particular, all samples for testing and learning prediction sets are independently drawn from the same but known distribution \(\).

**PAC guarantee.** Under the i.i.d. assumption, we learn a conformal set \(\) that includes the most true labels (_approximately correct_). In particular, this means that the miscoverage of \(\) is less than a desired level \((0,1)\), _i.e.,_\(_{}()\{ ()\}\), where the probability is taken over i.i.d. samples \((,)\). This risk on microgauge can be generalized to be the risk on indicator loss, \(_{01}()_{}_{01}(, ,)\). Here, the conformal set \(\) is learned from a randomly drawn calibration set, so we desire to construct \(\) that has a desired error for the most of random calibration sets (_probably approximately correct_), _i.e.,_\(\{_{01}()\} 1-,\) where \((0,1)\) is a desired confidence level and the probability is taken over \(n\) i.i.d. calibration samples \(^{n}\), used to learn \(\).

**Algorithm.** The PAC conformal prediction set method  considers the following algorithm \(_{}:()^{*}\) to learn a conformal set model \(\), parameterized by \(\), where \(\) is a finely-discretized \(_{ 0}\):

\[_{}@note{footnote}{$_{}$ returns $=$ if it is infeasible.}\] (10)where \(k_{}_{i=1}^{n}_{01}(,_{i},_{i})\). Here, \(U_{}\) is a binomial tail bound, _i.e.,_\(\{_{01}(C) U_{}(k_{};n,) \} 1-\) for any \(C\), where \(U_{}(k;n,)\{\,|\,F(k;n, )\}\{1\}\) and \((k;n,)\) is a cumulative distribution function (CDF) of a binomial distribution with \(n\) trials and success probability \(\). This algorithm is PAC.

**Theorem 2**.: _() The algorithm \(_{}\) is PAC, i.e., for any \(f\), \((0,1)\), \((0,1)\), and \(n_{ 0}\), we have \(\{_{01}()\} 1-\), where the probability is taken over i.i.d. labeled examples \(^{n}\), and \(=_{}()\)._

Here, we slightly generalize the known PAC guarantee to hold for any risk with indicator loss. See Appendix F for a proof. Note that the PAC guarantee generally holds only if an enough number of samples is provided (when we know a function family including a true function). However, we consider PAC algorithms that hold for any number of samples due to the structural property of prediction sets, _i.e.,_ a prediction set is always correct if \(=0\) (thus \(()=\)), regardless of the sample size. In other words, if the calibration samples are not sufficient, the prediction set is constructed to return \(\) to satisfy the PAC guarantee.

### Sample Space Decomposition

Given the generator \(G\) and the entailment set function \(\), the sample space \(\) can be partitioned as follows:

\[ =,,e,v) G() E_ {}()\}}_{_{}^{_{}}} ,,e,v) G() E_{ }()\}}_{_{}^{_{}}}\] \[=,,e,v) e=0\}}_{_{ }^{_{}}},, e,v) e=1\}}_{_{}^{_{}}}\] \[=,,e,v) e=1G()()\}}_{_{}^{_{}}} ,,e,v) e=1G()()\}}_{_{}^{_{ }}}\] \[=}^{}_{}^ {}\}}_{_{}^{}}}^{}_{}^{}\}}_{_{}^{}}.\]

Here, the short-hands are defined as follows:

* True discovery rate (TDR): \((_{}^{E_{}})\)
* False discovery rate (FDR): \((_{}^{E_{}})\)
* True entailment rate (TER): \((_{}^{})\)
* False non-entailment rate (FNER): \((_{}^{})\)
* True non-entailment rate (TNER): \((_{}^{})\)
* False entailment rate (FER): \((_{}^{})\)

### Experiment Setup

#### a.3.1 Computing Environment

Our system environment consists of 4 NVIDIA A100 80GB with 128 CPUs.

#### a.3.2 Models and Datasets

We use two large language models (LLMs), _GPT-3.5-Turbo_ and _Alpaca-7B_, for language generation. We use deberta-v2-xxlarge-mnli as our entailment model.

For each GLM to annotate entailment labels for each question, answer, and generated answer pair, we annotate entailment labels. Specifically, we consider the open-ended QA task, where the model is prompted to generate the answer in a declarative form given a question. To validate our method and its theoretical guarantee on controlling FDR-E, we create a dataset on textual entailment using the Natural Questions (NQ) dataset  for each GLM. Based on the transformation method by  that converts the question and answer pair in QA dataset into a declarative form, we manually labeled textual entailment by letting the generated sequence as the premise and the reference answer in declarative form as the hypothesis. Similar work can be found in , but they label the textual entailment based on the extractive answer from the model. Approximately 7.3k (7,374) and 4.6k (4,595) samples are labeled for _Alpaca-7B_ and _GPT-3.5-Turbo_, respectively, and both are split into calibration and test data at an 8:2 ratio. For semi-supervised learning algorithms that exploit unlabeled data (Algorithm 7, Algorithm 9), at most 27k and 10k unlabeled samples are used to train a selective generator, varying its size. Besides, semi-supervised learning algorithms use only 75% of the labeled calibration data compared to what is used by supervised methods (Algorithm 8, Algorithm 10).

## Appendix B Semi-supervised Selective Generation Algorithms (Certified)

```
1:procedureES(\(f_{E}\), \(_{E}\), \(_{E}\), \(_{E}\))
2:\(_{E}_{f_{E}}(_{E})\)\(\) In an increasing order of \(f_{E}(_{i},G(_{i}))\)
3:\((i,)(1,|_{E}|)\)
4:for\(i=1\)to\([_{E}|]\)do
5:\(k^{(i)}_{(,,e)_{E}}1(e=0,f_{E} (G(),) f_{E}(G(_{(i)/2} ),_{(i)/2}))\)
6:\(U U_{}(k^{(i)},|_{E}|,_{E})\)
7:if\(U_{E}\)then
8:\((i+)/2\)
9:else
10:\((i+)/2\)
11:return\(_{E}\) ```

**Algorithm 1** Entailment Set Learning with a False Entailment Rate (FER) Guarantee

```
1:procedureCompute-\(U_{}(f_{E}\), \(_{E}\), \(_{U}\), \(_{S}\), \(_{E}\), \(_{E}\))
2:\(_{E}(f_{E},_{E},_{E},_{E}/2)\)
3:\(_{(,,e)_{E}}1(e=1,f_{E}(G( ),)<_{E})\)
4:\(k_{(,)_{U}}1(f_{E}(G(),)<_{E})\)
5:\(U_{}_{E}-L_{}(;|_{E}|, _{E}/2)+U_{}(k,|_{U}|,_{S}/2)\)
6:return\(U_{}\) ```

**Algorithm 2**\(U_{}\) Computation (for Single \(_{E}\))

```
1:procedureCompute-\(U_{}^{}\), \(_{E}\), \(_{U}\), \(_{S}\), \(Q\), \(_{E}\))
2:\(_{E}_{f_{E}}(_{E})\)\(\) In an increasing order of \(f_{E}(_{i},G(_{i}))\)
3:\((i,)(1,|_{E}|)\)
4:\(_{}_{(,,e)_{E}}1(e=0)/|_{E}|\)
5:\(_{E}\{_{1}=_{},, _{Q}=1/|Q|_{}\}\)
6:\(U_{}^{}\)
7:for\(i\)in\(\{1,,Q\}\)do
8:\(U_{}^{(i)}U_{}(f_{E}, _{E},_{U},_{S}/Q,_{i},_{E}/Q)\)
9:if\(U_{}^{(i)} U_{}^{}\)then
10:\(U_{}^{} U_{}^{(i)}\)
11:return\(U_{}^{}\) ```

**Algorithm 3** Optimal \(U_{}\) Search```
1:procedureFDR-E-Bound(\(f_{E}\), \(_{E}\), \(_{U}\), \(_{S}\), \(_{S}\), \(Q\), \(_{E}\), \(_{W}\), return_bool = False)
2:\(_{U,E}_{U}_{E}\)
3:\(_{U,E}_{f_{M}}(_{U,E})\)\(()\) In an increasing order of \(f_{M}(_{i},G(_{i}))\)
4:\((i,)(1,_{U,E})\)
5:\(U_{};_{}\)
6:for\(i=1\)to\(_{2}_{U,E}\)do
7:\(_{S}^{(i)} f_{M}(_{(+)/2},G( _{(+)/2}))\)
8:\(_{E}^{(i)}\{(,,e)_{E} f _{M}(,G())_{S}^{(i)}\}\)
9:\(_{U}^{(i)}\{(,)_{U} f _{M}(,G())_{S}^{(i)}\}\)
10:\(U^{(i)}(f_{E},_{E}^{(i)},_{ U}^{(i)},}{_{2}|_{U,E}|},Q,}{_{2}_{U,E}},}{ _{2}_{U,E}})\)
11:if\(U^{(i)} U_{}\)then
12:\(U_{} U^{(i)};\;_{}_{S}^{(i)}\)
13:if\(U^{(i)}_{S}\)then
14:\((+)/2\)
15:else
16:\((+)/2\)
17:\(_{S}_{S}^{(i)}\)
18:if\(U_{}_{S}\)then
19:\( U^{(i)}\)
20:Bounded \(\) Success
21:else
22:\( U_{}\)
23:\(_{S}_{}\)
24:Bounded \(\) Fail
25:return\((_{S},,)\) if return_bool else\((_{S},)\). ```

**Algorithm 5** Semi-supervised Selective Generator Learning (Single-threshold Selection Function)```
1:procedureSGen-Semi2(\(f_{M_{1}}\), \(f_{M_{2}}\), \(f_{E}\), \(G\), \(_{E}\), \(_{U}\), \(_{S}\), \(_{S}\), \(Q\), \(_{E}\), \(_{W}\), return_bool = False)
2:\(_{U,E}_{U}_{E}\)
3:\(_{U_{1},E_{1}}_{f_{M_{1}}}(_{U,E})\) (\(\)) In an increasing order of \(f_{M_{1}}(_{i},G(_{i}))\)
4:\(_{U_{2},E_{2}}_{f_{M_{2}}}(_{U,E})\) (\(\)) In an increasing order of \(f_{M_{2}}(_{i},G(_{i}))\)
5:\(U_{};\;_{}\)
6:\((,)(1,|_{U_{1},E_{1}}|)\)
7:\(I_{2}|_{U,E}|\)
8:for\(i=1\)to\(_{2}|_{U,E}|\)do
9:\(_{S}^{(i)} f_{M_{1}}(_{( })/2},G(_{(})/2}))\)
10:\(U_{}^{(i)};\;_{}^{(i)}\)
11:\((,)(1,|_{U_{2},E_{2}}|)\)
12:for\(j=1\)to\(_{2}|_{U,E}|\)do
13:\(_{S}^{(j)} f_{M_{2}}(_{( })/2},G(_{(})/2}))\)
14:\(_{E}^{(i,j)}\{(,,e)_{E} (;G,f_{M_{1}},f_{M_{2}},_{S}^{(i)},_{S}^{(j)})=1\}\)
15:\(_{U}^{(i,j)}\{(,)_{U} (;G,f_{M_{1}},f_{M_{2}},_{S}^{(i)},_{S}^{(j)})=1\}\)
16:\(U^{(i,j)}(f_{E},_{E}^{(i,j)},_{U}^{(i,j)},}{I^{2}},Q,}{I^{2}},}{I^{2}})\)
17:if\(U^{(i,j)} U_{}^{(i)}\)then
18:\(U_{}^{(i)} U^{(i,j)};_{}^{(i)}( _{S}^{(i)},_{S}^{(j)})\)
19:if\(U^{(i,j)}_{S}\)then
20:\((})/2\)
21:else
22:\((})/2\)
23:if\(U_{}^{(i)} U_{}\)then
24:\(U_{} U_{}^{(i)};\;_{} _{}^{(i)}\)
25:if\(i_{2}|_{U,E}|\)then
26:if\(U_{}^{(i)}_{S}\)then
27:\((})/2\)
28:else
29:\((})/2\)
30:else
31:\(_{S}(_{S}^{(i)},_{S}^{(j)})\)
32:if\(U_{}_{S}\)then
33:\( U^{(i,j)};\;\)
34:else
35:\( U_{};\;_{S}_{};\;\)
36:return\((_{S},,)\) if return_bool else\((_{S},)\) ```

**Algorithm 6** Semi-supervised Selective Generator Learning (Double-threshold Selection Function)```
1:procedureSGen-Semi-MS(\(f_{M_{1}}\), \(f_{M_{2}}\), \(f_{E}\), \(G\), \(_{E}\), \(_{U}\), \(_{S}\), \(_{S}\), \(Q\), \(_{E},_{W}\))
2:\(_{}=\{\}\); \(_{}=\{\}\)
3:\((_{S_{1}},_{1},_{1})(f_{M_ {1}},f_{E},G,_{E},_{U},_{S},_{S}/3,Q, _{E}/3,_{W}/3,=)\)
4:\((_{S_{2}},_{2},_{2})(f_{M_ {2}},f_{E},G,_{E},_{U},_{S},_{S}/3,Q, _{E}/3,_{W}/3,=)\)
5:\((_{S_{2}},_{3},_{3})(f_{M_ {1}},f_{M_{2}},f_{E},G,_{E},_{U},_{S},_{S}/ 3,Q,_{E}/3,_{W}/3,=)\)
6:\(:=\{(_{S_{1}},_{1},s_{1},_{1}),(_{S_{2} },_{2},s_{2},_{2}),(_{S_{3}},_{3},s_{3},_{3})\}\)
7:\(()\,s_{i}\) refers to the scoring function(s) used in each algorithm.
8:for\((_{S},,s,)\) in \(\)do
9:if\(=\)then
10:\(_{}_{}\{( _{S},,s)\}\)
11:else
12:\(_{}_{}\{(_{S}, ,s)\}\)
13:if\(_{}=\{\}\)then
14:return\((_{S},,s)_{(_{S},,s)_{ }}\ \)
15:else
16:return\((_{S},,s)_{(_{S},,s)_{ }}\ \) ```

**Algorithm 7** Semi-supervised Selective Generator Learning with Neuro-Selection

## Appendix C Supervised Selective Generation Algorithms (Certified)

```
1:procedureSG-Sup(\(f_{M}\), \(G\), \(_{E}\), \(\), \(\))
2:\((,)(1,|_{E}|)\)
3:for\(i=1\)to\(_{2}|_{E}|\)do
4:\(_{S}^{(i)} f_{M}(_{(i+)/2},G( _{(i+)/2}))\)
5:\(_{E}^{(i)}\{(,,e)_{E} f _{M}(,G())_{S}^{(i)}\}\)
6:\(k^{(i)}_{(,,e)_{E}} (e=0)\)
7:\(U^{(i)} U_{}(k^{(i)};|_{E}^{(i)}|,/ _{2}|_{E}|)\)
8:if\(U^{(i)}\)then
9:\((+)/2\)
10:else
11:\((+)/2\)
12:\(_{S}_{S}^{(i)}\)
13:\( U^{(i)}\)
14:return\(_{S},\) ```

**Algorithm 8** Supervised Selective Generator Learning with \(_{R_{E}}()\) Control

## Appendix D Semi-supervised Selective Generation Algorithms (Heuristic)

```
1:procedureSG-PSL-H-Semi(\(f_{M}\), \(f_{E}\), \(G\), \(_{E}\), \(_{U}\), \(\), \(\), \(_{}\), FILTER)
2:if FILTER == TRUE then
3:\(_{U}\{(,) f_{E}(G(), )_{}1-f_{E}(G(),)_{}\}\)
4:\(_{U}\{(,,)(, )_{U},=1f_{E}(G(),) _{}\}\)
5:\(_{E}\{(,,)(, ,e)_{U},=e\}\)
6:\(_{U,E}_{f_{M}}(_{E}_{U})\)
7:\((,)\{1,|_{U,E}|\}\)
8:for\(i=1\)to\(_{2}|_{U,E}|\)do
9:\(_{S}^{(i)} f_{M}(_{(+)/2 },G(_{(+)/2}))\)
10:\(_{U,E}^{(i)}\{(,)_{U,E}  f_{M}(,G())_{S}^{(i)}\}\)
11:\(k^{(i)}_{(,,)_{U,E}^{( i)}}1(=0)\)
12:\(U^{(i)} U_{}(k^{(i)};|_{U,E}^{(i)}|,/ _{2}|_{U,E}|)\)
13:if\(U^{(i)}\)then
14:\((+)/2\)
15:else
16:\((+)/2\)
17:\(_{S}_{S}^{(i)}\)
18:\( U^{(i)}\)
19:return\(_{S},\) ```

**Algorithm 10** Unsupervised Selective Generator Learning with \(_{}()\) Control 

## Appendix E Unsupervised Selective Generation Algorithms (Certified)

```
1:procedureSG-EM(\(f_{M}\), \(G\), \(_{E}\), \(_{U}\), \(\), \(\))
2:\(_{U,E}_{U}_{E}\)
3:\(_{U,E}_{f_{M}}(_{U,E})\)
4:\((,)(1,|_{U,E}|)\)
5:for\(i=1\)to\(_{2}|_{U,E}|\)do
6:\(_{S}^{(i)} f_{M}(_{(+)/2 },G(_{(+)/2}))\)
7:\(_{U,E}^{(i)}\{(,)_{U,E}  f_{M}(,G())_{S}^{(i)}\}\)
8:\(k^{(i)}_{(,)_{U,E}^{(i)}}1(G( ))\)
9:\(U^{(i)} U_{}(k^{(i)};|_{U,E}^{(i)}|,/ _{2}|_{U,E}|)\)
10:if\(U^{(i)}\)then
11:\((+)/2\)
12:else
13:\((+)/2\)
14:\(_{S}_{S}^{(i)}\)
15:\( U^{(i)}\)
16:return\(_{S},\) ```

**Algorithm 10** Unsupervised Selective Generator Learning with \(_{}()\) Control Proof of Theorem 2

Let \(C_{}\) be a prediction set \(C\) with a parameter \(\), \(_{}\{_{01}(C_{ })>\}\), and \(^{*}_{}\), where \(\) is finely-discretized non-negative real values. Then, we have

\[_{01}(_{}( ))>} _{},U_{ }(k_{};n,)}\] \[U_{}(k_{^{*}};n,)\! \!}\] (11) \[_{01}(C_{^{*}})>  U_{}(k_{^{*}};n,)}\] \[_{01}(C_{^{*}})>U_{}(k_{^{*}};n,)},\] (12)

where the last equality in (11) holds as \(( C_{}())\) and \(U_{}\) are non-decreasing in \(\) (_i.e.,_ Lemma 2 in ) and the last inequality in (12) is due to the property of the binomial tail bound \(U_{}\).

## Appendix G Proof of Lemma 2

Since (E) in (2) is decomposed into three terms in Lemma 1, we first find upper bounds on each of the terms and take the union bound as follows. This will return a single upper bound on (E) in (2), which we denote \(U_{}\).

**FER Bound.** First, recall that

\[_{}()_{_{}} \{e=0 G()()\}.\]

Learning \(\) via \(_{}\) is equivalent to the PAC prediction set learning algorithm that considers the optimization problem in (10), where the indicator loss is \(_{01}(,,,e)(e=0 G( )())\) and the target model is the entailment scoring function \(f_{E}\). Therefore, by Theorem 2, for any \(n_{E}|_{E}|\), we have

\[_{_{E}}\{_{}()_{E}\} =_{m=1}^{n_{E}}_{_{E}}\{_ {}()_{E}\;\;|}_{E}|=m \}_{_{E}}\{|}_{E}|=m\}\] \[_{m=1}^{n_{E}}(1-_{E}^{}/2)_{ _{E}}\{|}_{E}|=m\}\] (13) \[=1-_{E}^{}/2.\] (14)

Note that (13) holds as the PAC guarantee for conformal prediction holds for any number of samples.

The same bound holds with respect to \(\). Specifically, letting \(_{}(_{E},_{U})( _{}()_{E})\), we have

\[_{}\{_{}() _{E}\} =_{}(_{E},_{U})\; ()\] \[=_{}(_{E},_{U})\; (_{E})(_{U})\] \[(1-_{E}^{}/2)d(_{U})\] \[=1-_{E}^{}/2,\] (15)

where the second equality holds due to the i.i.d. assumption on the calibration data and the inequality holds due to (14).

**FNER Bound.** Recall

\[_{}()_{_{}} \{e=1=0\}.\]Since our goal is to upper-bound \(-_{}()\), we consider a lower bound \(_{}()\) as follows for any \(n_{E}|_{E}|\):

\[_{_{E}} \{_{}() L_{}( ;|}_{E}|,^{}_{E}/2)\}\] \[=_{m=1}^{n_{E}}_{_{E}}\{ _{}() L_{}(;|}_{E}|, ^{}_{E}/2)\;\;|}_{E}|=m\}_{_{E}}\{|}_{E}|=m\}\] \[_{m=1}^{n_{E}}(1-^{}_{E}/2)_{ _{E}}\{|}_{E}|=m\},\] \[=1-^{}_{E}/2\] (16)

where the inequality holds due to the binomial tail bound. The same bound holds when the probability is taken over \(\). First, let

\[_{}(_{E},_{U}) 1 _{}() L_{}(;|}_{E}|,^{}_{E}/2).\]

Then,

\[_{}\{_{}() L _{}(;|}_{E}|,^{}_{E}/2)\} =_{}(_{E},_{U})d()\] \[=_{}(_{E},_{U})d(_{E})d(_{U})\] \[(1-^{}_{E}/2)d(_{U})\] \[=1-^{}_{E}/2,\] (17)

where the second equality holds due to the i.i.d. assumption and the inequality holds due to (16).

**NER Bound.** Recall

\[_{}()_{_{}} \{=0\}=_{_{}}\{G()( )\}.\]

Then, we upper bound \(_{}()\) as follows for any \(n_{U}|_{U}|\):

\[_{_{U}} \{_{}() U_{}( ;|}_{U}|,^{}_{S})\}\] \[=_{m=1}^{n_{U}}_{_{U}}\{ _{}() U_{}(;|}_{U}|, ^{}_{S})\;\;|}_{U}|=m\} _{_{U}}\{|}_{U}|=m\}\] \[_{m=1}^{n_{U}}(1-^{}_{S})_{ _{U}}\{|}_{U}|=m\}\] \[=1-^{}_{S},\] (18)

where the inequality holds due to the binomial tail bound. Again, the same bound holds when the probability is taken over \(\). First, let

\[_{}(_{E},_{U}) 1_{}() U_{}(;|}_{U}|,^{}_{S})\]

Then,

\[_{}_{}()  U_{}(;|}_{U}|,^{}_{S})} =_{}(_{E},_{U})d ()\] \[=_{}(_{E},_{U})d (_{U})d(_{E})\] \[(1-^{}_{S})d(_{E})\] \[=1-^{}_{S},\] (19)

where the inequality holds due to (18).

Finally, taking the union bound of (15), (17), and (19) completes the proof.

Proof of Lemma 3

Let \(U_{}^{(i)}\) be \(U_{}\) for the \(i\)-th candidate of \(_{E}\) in Algorithm 3. Due to Lemma 2, the following holds:

\[_{}_{_{}}\{e=0\}>U_{ }^{(i)})}(_{E}^{}+_{S}^{})/Q.\]

Since \(U_{}^{}=}\;U_{}^{(i)}\), we have

\[_{}_{_{} }\{e=0\}>U_{}^{}} _{}\,i\{1,,Q\}, _{_{}}\{e=0\}>U_{}^{(i)}}\] \[_{i=1}^{Q}_{}_{ _{}}\{e=0\}>U_{}^{(i)}}\] \[_{E}^{}+_{S}^{},\]

where the second inequality is due to a union bound. This completes the proof.

## Appendix I Proof of Theorem 1

Let \(\) be the calibration set-dependent hypothesis space of selective generators, where \(n_{}||\) is always calibration set independent. Letting \(U^{(i)}\) be the FDR-E bound computed given the \(i\)-th selective generator \(S_{i}\) in \(\), we first describe how to derive an upper bound of the FDR-E for a given hypothesis \(S_{i}\).

Since an upper bound of (E) in (2) is proved in Lemma 3, the remaining parts are (i) to derive upper bounds on the others and (ii) to take the union bound. For proportions of the visibility of textual entailment labels, _i.e.,_ (B) and (D) in (2), and the FDR-E for the supervised case only using entailment-labeled examples, _i.e.,_ (C) in (2), the followings hold due to the binomial tail bound:

\[_{}_{_{S_{i}}} \{v=1\} }(|}_{E}|;|}_{E}|+|}_{U}|,_{W}/(2||))}_{  w_{}^{(i)}}} 1-_{W}/(2| |);\] \[_{}_{_{S_{i}}} \{v=0\} }(|}_{U}|;|}_{E}|+|}_{U}|,_{W}/(2||))}_{  w_{}^{(i)}}} 1-_{W}/(2| |);\] \[_{}_{_{S_{i}}} \{e=0\} }(|}_{E}^{e=0}|;|}_{E}|,_{S}/(2||))}_{ U_{}^{ (i)}}} 1-_{S}/(2||),\]

where \(}_{E}\) and \(}_{U}\) are defined same as Lemma 2 does, and \(}_{E}^{e=0}\{(,,e)}_{E} e=0\}\). Note that the binomial tail bound is applied to filtered sets by the given selective generator (_e.g.,_\(}_{E}\)), but we can use the same bound for the non-filtered set \(\), by using the same marginalization technique over the size of a filtered set, as in, _e.g.,_ (15).

Thus, by taking the union bound along with Lemma 3 when \(_{E}^{}=_{E}\) and \(_{S}^{}=_{S}/2\),

\[_{}_{E}(S_{i}) U^{(i)}} 1 -(_{E}+_{S}+_{W})/||,\] (20)

where \(U_{i} w_{}^{(i)}U_{}^{(i)}+w_{}^{(i)}U_{ }^{^{(i)}}\) is the computed FDR-E bound a given selective generator \(S_{i}\). Here, \(U_{}^{^{(i)}}\) refers to the smallest FDR-E bound of (E) in (2) given the \(i\)-th selective generator.

Since (20) holds for all \(S_{i}\), and the final bound \(\) is chosen among them, this completes the proof by taking an union bound, _i.e.,_\[_{}\{_{E}()>\} _{}\{ S_{i}, _{E}(S_{i})>U_{i}\}\] \[=_{k=1}^{n_{}}d_{}\{  S_{i},_{E}(S_{i})>U_{i},||=k\}\] \[=_{k=1}^{n_{}}_{}\{  S_{i},_{E}(S_{i})>U_{i}||=k \}_{}\{||=k\}\] \[_{k=1}^{n_{}}_{i=1}^{k}_{ }\{_{E}(S_{i})>U_{i}||=k\} _{}\{||=k\}\] \[_{k=1}^{n_{}}_{i=1}^{k}(+_{S}+_{W}}{k})_{}\{||=k\}\] \[=_{E}+_{S}+_{W}.\]

## Appendix J Proof of Lemma 4

We say \(f_{M}\) is perfectly calibrated with respect to \(\), \(G\), \(E_{}\) if

\[_{}\{G() E_{}() f_ {M}(,G())=t\})=t, t.\] (21)

The true discovery rate with respect to \(E_{}\) conditioned on \(f_{M}(,G())_{S}\), _i.e.,_\(1-\), is as follows:

\[\{G() E_{}() f_ {M}(,G())_{S}\}\] \[=}^{1}\{G() E_{}() f_{M}(,G())=t\}\{f_{M}( ,G())=t\}dt}{_{_{S}}^{1}\{f_{M}( ,G())=t\}dt}\] \[=}^{1}t\{f_{M}(,G( ))=t\}dt}{_{_{S}}^{1}\{f_{M}(,G())=t\}dt},\] (22)

where and (22) holds as \(f_{M}\) is perfectly calibrated, _i.e.,_ (21).

Letting \(h(t)\{f_{M}(,G())=t\}\), \(H(t)_{t}^{1}h(t^{})dt^{}\), \(i(t) t\{f_{M}(,G())=t\}\), and \(I(t)_{t}^{1}i(t^{})dt^{}\), since we have \(_{S}}^{1}t\{f_{M}(,G())=t\}dt}{_{_{S}}^{1}\{f_{M}(,G())=t\}dt} 1\), the following holds:

\[I(1)-I(_{S})_{S}(H(1)-H(_{S})).\]

Therefore,

\[}\{G() E_{}( ) f_{M}(,G())_{S}\} =})}{H(1)-H(_ {S})}}\] \[=)_{S}(H(1)-H(_{S}))-(I(1)-I(_ {S}))}{(H(1)-H(_{S}))^{2}}\] \[ 0.\]

This completes the proof.

Note that the classification problem can be reduced from the special case, _i.e.,_\(E_{}(y) E_{}(y)\), where \(\) and \(E_{}(y)\{y\}=_{w}\ (Y=w=)\).

[MISSING_PAGE_EMPTY:26]

### NeurIPS Paper Checklist

The checklist is designed to encourage best practices for responsible machine learning research, addressing issues of reproducibility, transparency, research ethics, and societal impact. Do not remove the checklist: **The papers not including the checklist will be desk rejected.** The checklist should follow the references and follow the (optional) supplemental material. The checklist does NOT count towards the page limit.

Please read the checklist guidelines carefully for information on how to answer these questions. For each question in the checklist:

* You should answer [Yes], [No], or [NA].
* [NA] means either that the question is Not Applicable for that particular paper or the relevant information is Not Available.
* Please provide a short (1-2 sentence) justification right after your answer (even for NA).

**The checklist answers are an integral part of your paper submission.** They are visible to the reviewers, area chairs, senior area chairs, and ethics reviewers. You will be asked to also include it (after eventual revisions) with the final version of your paper, and its final version will be published with the paper.

The reviewers of your paper will be asked to use the checklist as one of the factors in their evaluation. While "[Yes] " is generally preferable to "[No] ", it is perfectly acceptable to answer "[No] " provided a proper justification is given (e.g., "error bars are not reported because it would be too computationally expensive" or "we were unable to find the license for the dataset we used"). In general, answering "[No] " or "[NA] " is not grounds for rejection. While the questions are phrased in a binary way, we acknowledge that the true answer is often more nuanced, so please just use your best judgment and

    &  \\   &  &  \\   & \(_{}^{}\) & \(_{}^{}\) & \(_{}\) & \(_{}^{}\) & \(^{}\) \\   }\)} & FDR-E & \(0.0000\) & \(0.0000\) & \(0.0213\) & \(0.0962\) & \(0.0918\) \\  & efficiency & \(0.0387\) & \(0.0227\) & \(0.4775\) & \(0.8608\) & \(0.8502\) \\  }\)} & FDR-E & \(0.0053\) & \(0.0039\) & \(0.0831\) & \(0.0169\) & \(0.0918\) \\  & efficiency & \(0.1300\) & \(0.1025\) & \(0.4862\) & \(0.2156\) & \(0.8502\) \\    & \(0.0844\) & \(0.0626\) &  & \(0.5382\) & \(0.8502\) \\   

Table 4: Comparison results of semi-supervised methods. Here, \(|_{U}|=10K\) for GPT-3.5-turbo and Alpaca-7B. The best results are highlighted in **bold** and results from methods that do not satisfy desired FDR-E guarantee are underlined. We used QA2D dataset, filtered with only SQuAD, where human transformed QA sentences exist. \(=0.15\).

    &  \\   & ^{}\)} & \(_{}^{}\) \\  }\)} & FDR-E & \(0.1116\) & \(0.0454\) \\  & efficiency & \(0.8956\) & \(0.6525\) \\  }\)} & FDR-E & \(0.0459\) & \(0.0082\) \\  & efficiency & \(0.3185\) & \(0.1532\) \\    & \(0.6071\) & \(0.4029\) \\  

Table 5: Comparison results of fully supervised methods. Here, we use all entailment labels, _i.e.,_\(|_{E}|=|_{E}^{}|\) for GPT-3.5-turbo and Alpaca-7B. The best results are highlighted in bold, results from methods that do not satisfy desired FDR-E guarantee are underlined. We used QA2D dataset, filtered with only SQuAD, where human transformed QA sentences exist. \(=0.15\).

write a justification to elaborate. All supporting evidence can appear either in the main paper or the supplemental material, provided in appendix. If you answer [Yes] to a question, in the justification please point to the section(s) where related material for the question can be found.

IMPORTANT, please:

* **Delete this instruction block, but keep the section heading "NeurIPS paper checklist"**,
* **Keep the checklist subsection headings, questions/answers and guidelines below.**
* **Do not modify the questions and only use the provided macros for your answers**.

1. **Claims** Question: Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope? Answer: [Yes] Justification: The theoretical guarantee and the proposed algorithm are illustrated in Section 4. Detailed proofs and algorithmic descriptions can be found in the appendix. Experimental results are illustrated in Section 5 Guidelines: * The answer NA means that the abstract and introduction do not include the claims made in the paper. * The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers. * The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings. * It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper.
2. **Limitations** Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] Justification: The limitations due to assumptions made for the theoretical guarantee and the expensive data labeling process are illustrated in Section 6. Guidelines: * The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper. * The authors are encouraged to create a separate "Limitations" section in their paper. * The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be. * The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated. * The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon. * The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size. * If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.

* While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren't acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations.
3. **Theory Assumptions and Proofs** Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? Answer: [Yes] Justification: We provide the correct and complete proofs with full set of assumptions made for each theoretical result, which are illustrated in detail in the appendix. Furthermore, the limitations of the theoretical guarantees induced by the assumptions are stated in Section 6. Guidelines: * The answer NA means that the paper does not include theoretical results. * All the theorems, formulas, and proofs in the paper should be numbered and cross-referenced. * All assumptions should be clearly stated or referenced in the statement of any theorems. * The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition. * Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material. * Theorems and Lemmas that the proof relies upon should be properly referenced.
4. **Experimental Result Reproducibility** Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? Answer: [Yes] Justification: Datasets, models, and hyperparameters used in implementing proposed algorithms are all described in detail. See Section 5. Guidelines: * The answer NA means that the paper does not include experiments. * If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not. * If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable. * Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general, releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed. * While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example 1. If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. 2. If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully.

3. If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). 4. We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results.
5. **Open access to data and code** Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? Answer: [Yes] Justification: We will provide the code to train and evaluate the proposed algorithm, which reproduces the experiment results in the paper after the rebuttal process. Guidelines: * The answer NA means that paper does not include experiments requiring code. * Please see the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details. * While we encourage the release of code and data, we understand that this might not be possible, so "No" is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark). * The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details. * The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc. * The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why. * At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable). * Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
6. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: We provide the details of our experiments including generation. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material.
7. **Experiment Statistical Significance** Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? Answer: [Yes]Justification: This paper includes holdout experiments to assess statistical significance and provide error bars for the reported results. Guidelines: * The answer NA means that the paper does not include experiments. * The authors should answer "Yes" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. * The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions). * The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.) * The assumptions made should be given (e.g., Normally distributed errors). * It should be clear whether the error bar is the standard deviation or the standard error of the mean. * It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis of Normality of errors is not verified. * For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates). * If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text.
8. **Experiments Compute Resources** Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? Answer: [Yes] Justification: We wrote the details in Appendix. Guidelines: * The answer NA means that the paper does not include experiments. * The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage. * The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute. * The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn't make it into the paper).
9. **Code Of Ethics** Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? Answer: [Yes] Justification: The research is conducted with the NeurIPS Code of Ethics. Guidelines: * The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics. * If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics. * The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction).
10. **Broader Impacts** Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed?Answer: [Yes] Justification: The paper can measure the uncertainty of generative large language models, which is crucial for decision making problems. Guidelines: * The answer NA means that there is no societal impact of the work performed. * If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact. * Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations. * The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster. * The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology. * If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML).
11. **Safeguards** Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? Answer: [NA] Justification: This paper poses no such risks Guidelines: * The answer NA means that the paper poses no such risks. * Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters. * Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images. * We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort.
12. **Licenses for existing assets** Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? Answer: [Yes] Justification: This paper cite the original papers such as dataset. Guidelines: * The answer NA means that the paper does not use existing assets. * The authors should cite the original paper that produced the code package or dataset.

* The authors should state which version of the asset is used and, if possible, include a URL.
* The name of the license (e.g., CC-BY 4.0) should be included for each asset.
* For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.
* If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.
* For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.
* If this information is not available online, the authors are encouraged to reach out to the asset's creators.

13. **New Assets** Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? Answer: [Yes] Justification: This paper will release code for running experiments and it is well documented. Guidelines: * The answer NA means that the paper does not release new assets. * Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc. * The paper should discuss whether and how consent was obtained from people whose asset is used. * At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file.

14. **Crowdsourcing and Research with Human Subjects** Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? Answer: [NA] Justification: This paper does not involve crowdsourcing nor research with human subjects. Guidelines: * The answer NA means that the paper does not involve crowdsourcing nor research with human subjects. * Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper. * According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector.

15. **Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects** Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? Answer: [NA] Justification: This paper does not involve crowdsourcing nor research with human subjects. Guidelines:* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.
* We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.
* For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review.