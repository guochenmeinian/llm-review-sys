# On the Noise Robustness of In-Context Learning

for Text Generation

 Hongfu Gao1,2, Feipeng Zhang2, Wenyu Jiang1,3, Jun Shu4, Feng Zheng5, Hongxin Wei11

\({}^{1}\)Department of Statistics and Data Science, Southern University of Science and Technology

\({}^{2}\)School of Economics and Finance, Xi'an Jiaotong University

\({}^{3}\)National Key Laboratory for Novel Software Technology, Nanjing University

\({}^{4}\)School of Mathematics and Statistics, Xi'an Jiaotong University

\({}^{5}\)Department of Computer Science and Engineering, Southern University of Science and Technology

###### Abstract

Large language models (LLMs) have shown impressive performance on downstream tasks by in-context learning (ICL), which heavily relies on the quality of demonstrations selected from a large set of annotated examples. Recent works claim that in-context learning is robust to noisy demonstrations in text classification. In this work, we show that, on text generation tasks, noisy annotations significantly hurt the performance of in-context learning. To circumvent the issue, we propose a simple and effective approach called Local Perplexity Ranking (LPR), which replaces the "noisy" candidates with their nearest neighbors that are more likely to be clean. Our method is motivated by analyzing the perplexity deviation caused by noisy labels and decomposing perplexity into inherent perplexity and matching perplexity. Our key idea behind LPR is thus to decouple the matching perplexity by performing the ranking among the neighbors in semantic space. Our approach can prevent the selected demonstrations from including mismatched input-label pairs while preserving the effectiveness of the original selection methods. Extensive experiments demonstrate the effectiveness of LPR, improving the EM score by up to 18.75 on common benchmarks with noisy annotations. Our code is available at https://github.com/ml-stat-Sustech/Local-Perplexity-Ranking

## 1 Introduction

Large language models (LLMs) have shown remarkable performance on downstream tasks by _in-context learning_ (ICL) with only a few task demonstrations [7; 10]. Without requiring explicit parameter updates, in-context learning consistently outperforms zero-shot inference on various tasks (e.g., classification and generation), making it a compelling alternative to supervised fine-tuning [13; 16]. In particular, the success of ICL heavily relies on the quality of demonstrations selected from a large set of annotated examples [21; 29; 51; 60]. For those candidates, input-label mappings solicited from humans [61; 73] or LLMs  can often be noisy, especially in complex tasks. This gives rise to the importance of _noise-robust ICL_, which aims to construct effective demonstrations in the presence of noisy and erroneous labels.

Previous works show that in-context learning on classification tasks is fairly robust to label noise in the in-context demonstrations [9; 12; 32; 37; 54; 55]. However, it is still mysterious how noisy labels affect the performance of ICL on text generation tasks. In this work, we present the first study on in-context learning with a _noisy_ annotated dataset for generation. Surprisingly, we empirically find that label noise in the demonstrations significantly degrades ICL's performance on generation tasks,which is different from previous results on classification. Moreover, increasing the number of selected demonstrations with a fixed noise rate or utilizing more effective selection methods (e.g., TopK  and DPP ) will intensify the negative effect of noisy labels. This motivates our method, which can universally improve the noise robustness of existing selection methods for in-context learning.

In this paper, we show that the issue of noisy annotations can be mitigated through the perplexity ranking of noisy candidates (i.e., input-label pairs) during selection. Our method, Local Perplexity Ranking (dubbed **LPR**), is motivated by our analysis of the perplexity deviation caused by noisy labels (i.e., incorrect answers). We find that wrong answers generally result in a higher perplexity of large language models compared to correct ones, in response to the same question. To explain this phenomenon, we decompose the perplexity into two components: inherent perplexity, which measures the task complexity of the question and the correct answer, and matching perplexity, which assesses the perplexity deviation caused by noisy outputs.

Therefore, our key idea behind Local Perplexity Ranking is to decouple the matching perplexity by performing the ranking among the neighbors in semantic space. This can be achieved by ranking candidates' perplexity alongside their nearest neighborhoods, which usually have similar levels of inherent perplexity. In particular, we replace each low-rank candidate selected by existing methods (e.g., random, TopK, and DPP) with its nearest neighbor that is highly ranked. In effect, our LPR strategy can prevent the selected demonstrations from containing mismatched input-label pairs while preserving the effectiveness of the original selection methods. In this way, we ensure the correctness and relevancy of demonstrations, thereby improving the noise-tolerant ability of in-context learning.

To verify the effectiveness of our method, we conduct extensive evaluations on six text generation datasets, including NQ , WebQ , SQuAD , SCIQ , GeoQuery  and NL2Bash  datasets. The results demonstrate that local perplexity ranking can largely improve the noise-robustness of all existing selection methods under irrelevant and relevant noises. For example, on SCIQ with \(60\%\) irrelevant label noise, LPR improves the exact match score of the TopK method from 29.31 to 48.06 - a significant direct improvement of \(\). Moreover, our method can be easily adopted in practice. The performance of LPR is insensitive to the hyperparameters, including the threshold \(\) and the number of local neighbors \(k\). This approach can effectively generalize to various LLMs to improve their noise-robustness with in-context learning.

Our contributions are summarized as follows:

* We present the first study to show that annotation quality is crucial for in-context learning in text generation, where noisy annotations significantly hurt the performance. Increasing the set size of demonstrations cannot bridge the gap, as well as picking other selection methods.
* We propose Local Perplexity Ranking (LPR), a simple and effective method to enhance the noise robustness of in-context learning. The key idea is to decouple the matching perplexity by performing the ranking among the neighbors of each candidate in semantic space.
* We empirically show that LPR can improve the noise robustness of existing demonstration selection methods in ICL across various types of label noise. In addition to text generation, we also validate the effectiveness of our method in text classification tasks.

## 2 Preliminary

### In-context learning for generation

We consider in-context learning (ICL) of large language models (LLMs) in generation tasks, where we aim to generate text outputs \(=(y_{1},...,y_{||})\) (i.e., token sequences) conditioned on the inputs \(=(x_{1},...,x_{||})\) and the context \(_{K}\). In particular, the context \(_{K}=\{(_{i},_{i})\}_{i=1}^{K}\) contains \(K\) task demonstrations (e.g., input-output pairs), selected from a large annotated dataset with \(N\) examples \(=\{(_{j},_{j})\}_{j=1}^{N}\). Given a new test input text \(_{test}\), we make the generation of output \(_{test}\) via large language models as

\[_{test}_{LLM}(_{test}\{(_{i},_{i}) \}_{i=1}^{K},_{test}),\] (1)

where \(\) refers to decoding strategies(e.g. greedy decoding and nuclear sampling [17; 62]). Generation with the ICL procedure is especially attractive as it does not require the parameter updating of large language models, which is often expensive and impractical.

Existing studies show that the selection strategy of demonstration plays a crucial role in the ICL performance [25; 31; 43; 44; 47]. A naive method is to randomly sample the demonstrations from annotated examples without repetition . To introduce the relevancy, TopK  proposes to select the closest examples to the test input in the embedding space

\[_{K}=_{K}(_{test})=_{}(s(_{ test},)),\]

where \(\) is a retriever, \(s(_{test},)\) denotes the cosine similarity score between \(_{test}\) and examples \(\) from the annotated dataset. We use \(\) to denote the top \(K\) examples ranked by the score.

These selection strategies focus on the inputs of demonstrations, assuming that all examples are labeled correctly in the large dataset [28; 36; 62]. However, collecting a large-scale dataset with perfectly correct labels is challenging and expensive, especially for generation tasks [2; 64]. In practice, researchers often use crowdsourcing [61; 73] or large language models (LLMs)  such as GPT-4  to create input-output pairs for new tasks, which inevitably leads to some mistakes in the annotations. This motivates us to analyze the issue of label quality in ICL for generation tasks.

### Setting of noisy annotations

Given a large-scale dataset with noisy annotations \(}=\{(_{j},}_{j})\}_{j=1}^{N}\), the selected demonstration might contain mismatched input-output pairs \((,})\), i.e., the output \(}\) might be not a correct answer to the input \(\). Conditioned on the noisy demonstrations, the generation of output via ICL is made as

\[_{test}_{LLM}(_{test}\{(_{i}, }_{i})\}_{i=1}^{K},_{test}).\] (2)

In the real world, noisy annotations may arise from unintentional mistakes or limited knowledge, resulting in various types of noise in the demonstrations. In this work, we define two categories of noisy annotations based on the input-output relevance, as follows:

**Irrelevant noise** assumes that the generation of noisy annotations is conditionally independent of inputs. For example, crowdsource workers may make mistakes accidentally, introducing random words or sentences in annotations. This can be simulated by reconstructing the output with random words from a subset that does not contain tokens presented in the original input-output pairs.

**Relevant noise** is a more realistic setting where the corrupted output is relevant to the inputs despite its incorrectness. This type of corruption may occur due to the limited knowledge of annotators and LLMs. We simulate the relevant noise by generating related yet incorrect outputs using ChatGPT-4.

In Table 1, we present an ICL example of question answering (QA) tasks to illustrate the difference between the two noisy settings. In this example, the clean annotation for the test input is "Cells". For noisy annotations, the irrelevant noise is randomly sampled as "Earth", while the relevant noise "tissues" exists in the support of in-context demonstration. We proceed by analyzing the empirical effects of noisy annotations in generation tasks.

    & **Support**: All forms of life are built of at least one cell. A cell is the basic unit of \\  & the structure and function of living things. \\  & **Question**: What are the smallest structural and functional units of all living organisms? \\  & **Output**: & \\ 
**Setting** &  & **Prediction** \\   & **Support**: Cells are organized into tissues, tissues are organized into organs. & \\  & **Question**: What is considered the smallest unit of the organ? & \\  & **Output**: Cells & \\  & **Support**: Cells are organized into tissues, tissues are organized into organs. & \\  & **Question**: What is considered the smallest unit of the organ? & \\  & **Output**: Earth & \\  & **Support**: Cells are organized into tissues, tissues are organized into organs. & \\  & **Question**: What is considered the smallest unit of the organ? & tissues \\  & **Output**: tissues & \\   

Table 1: An illustration of the effect of three different types of annotated dataset for in-context learning. The middle column is in-context demonstrations, and the last column is the Llama2-7B  model prediction. The model tends to learn the label of the demonstration.

## 3 Empirical study of noisy ICL in text generation

In this section, we investigate the impact of noisy annotations on the performance of in-context learning for text generation. In particular, we conduct experiments on three types of generation tasks, including: question answering (NQ , WebQ ), reading comprehension (SQuAD , SCIQ ), code generation (GeoQuery , NL2Bash ). To simulate the noise, we generate noisy annotations with a pre-defined probability (e.g., 20\(\%\), 40\(\%\), 60\(\%\)) in the annotated datasets. We use the output of an input from a different generation task as irrelevant noise, and adopt ChatGPT-4 to generate relevant yet false outputs as relevant noise. Furthermore, we compare the performance of noisy ICL with demonstrations across various set sizes (e.g., 2, 4, 8) and selection methods, including Random , TopK  and DPP . Following previous work [16; 28; 62], we report the average Exact Match (EM) score with Llama2-7B .

ICL is not robust to noisy annotations in text generation.Figure 1 presents the empirical results of ICL methods with noisy annotations. The results show that both the two types of noises significantly deteriorate the performance of in-context learning on text generation tasks, which is different from the observations of ICL on classification tasks [9; 12; 32; 37; 54; 55]. In particular, a higher noise rate in annotated datasets leads to poorer performance of in-context learning. Moreover, irrelevant noises have a more negative influence than relevant noises, which may benefit the inference in the way of _task recognition_.

The impact of demonstration selection.To provide a deep understanding of noisy annotations, we analyze the performance of noisy ICL across different demonstration settings, including the set size (i.e., \(K\)) and selection methods. Results in Figure 1 show that, under the noisy settings, selecting a larger set of demonstrations does not enhance -- and may even worsen -- the performance of text generation. For example, the ICL performances with \(K=8\) are basically lower than those with \(K=2\), which is inconsistent with the clean setting. In addition, the advantages of those powerful selection methods (i.e., TopK and DPP) are neutralized in the presence of noisy annotations.

Through the empirical analysis, we find that noisy annotations significantly hurt the performance of ICL in text generation tasks. More importantly, increasing the set size of demonstrations cannot bridge the gap, as well as picking an existing selection method, like DPP. This motivates us to design _noise-robust_ methods, which can universally improve the noise robustness of in-context learning.

## 4 Methodology

In this section, we first analyze the perplexity deviation caused by noisy annotations and introduce the disentanglement of perplexity to explain the phenomenon. In light of this, we propose a novel method - local perplexity ranking - to improve the noise robustness of in-context learning for text generation. Our method can be easily incorporated into existing methods of demonstration selection.

### Perplexity deviation of noisy annotations

For language models, perplexity measures the degree of uncertainty in generating new tokens. In particular, a low perplexity indicates that the model makes the prediction with high confidence.

Figure 1: Average ICL performance with noisy annotations in various generation tasks across different demonstration settings. Both the two types of noises significantly deteriorate the performance of in-context learning on text generation tasks. The black line denotes zero-shot performance.

Therefore, perplexity is commonly used to evaluate the language quality of generated content, e.g., detecting attack prompts , out-of-distribution instances [4; 57], hard-to-learn instances , and corrupted instances . In light of this, we conjecture that mismatched input-output pairs may result in higher perplexity of LLMs due to their low co-occurrence rate. For instance, in the example presented in Table 1, the term "earth" rarely co-occurs with "cells" and "organ", so LLMs are more likely to exhibit high perplexity in the input-output pair.

Empirical studyTo validate this assumption, we compare the perplexity of clean and noisy annotations in text generation tasks. Specifically, we concatenate each tokenized input-output pair \((,)\), and obtain the corresponding tokenized sequence \(=(z_{1},...,z_{||})=(x_{1},...,x_{||},y_{1},...,y_{||})\), where \(||=||+||\). Now, the perplexity of \(\) is calculated as:

\[()=\{-|}_{i=1}^{||}  p_{}(z_{i}|z_{<i})\},\] (3)

where \( p_{}(z_{i}|z_{<i})\) is the log-likelihood of the \(i\)-th token conditioned on the preceding tokens \(z_{<i}\), from the given language model parameterized by \(\).

In Figure 2, we present the perplexity distribution of Llama2-7B  on clean and noisy annotations of four datasets. The results illustrate that examples with noisy annotations indeed obtain higher perplexity than those with clean annotations, which confirms our assumption. In particular, relevant noises achieve slightly lower perplexity than irrelevant noises since relevant outputs are close to the inputs despite their erroneous information. However, the deviation of the perplexity distribution caused by noisy annotations is marginal, making it suboptimal to differentiate noisy annotations from clean ones. In the following, we explain this phenomenon with the disentanglement of perplexity.

Disentanglement of perplexityGiven an input-output pair, the perplexity of large language models (LLMs) stems not only from how well the output matches the input, but also from the inherent complexity of the task. For example, a mathematical question with a correct answer can exhibit a higher perplexity than a question of daily life with an incorrect answer. Informally, we decompose the overall Perplexity into two components 3, as shown below:

\[=\;\;+\;\;\]

Here, the inherent perplexity measures how the model is familiar with the task (i.e., the input and the correct output). The matching perplexity quantifies the perplexity deviation caused by noisy outputs, so it can be zero with correct outputs. A higher matching perplexity indicates that the output is more likely to be incorrect for the input. However, directly computing the matching perplexity is non-trivial as clean outputs are unknown. To circumvent the issue, we aim to design an effective method to decouple the matching perplexity from the overall perplexity.

Figure 2: The distribution of perplexity of Llama2-7B  on clean and noisy annotations. Examples with noisy annotations indeed obtain higher perplexity than those with clean annotations.

### Local Perplexity Ranking

IntuitionMotivated by the previous analysis, we propose _local perplexity ranking_ (LPR), a general strategy that can improve the noise robustness of in-context learning. Our key idea is to decouple the matching perplexity by performing the ranking among the neighbors in semantic space. Here, our approach is built on two natural assumptions that are naturally satisfied in the real world:

1. The clean annotations are the majority in the annotated dataset.
2. Examples that are semantically similar share the same level of inherent perplexity.

In the literature, Assumption 2 is also supported by previous findings that paragraphs whose representations are close to each other share the same intrinsic task . With the two assumptions, we can approximate the inherent perplexity of a candidate through its neighbors, where most examples are correctly annotated. In other words, the candidate is more likely to be wrongly annotated if its perplexity is relatively higher than its neighbors, and vice versa. With this in mind, we present the details of our approach in the following.

Finding the local neighborsGiven a test input, we first sample a candidate set \(}\) with a pre-defined selection strategy, such as Random , TopK  or DPP . For each candidate \(^{*}\), we adopt \(k\)-Nearest-Neighbors (\(k\)-NN) to find its local neighbors that are close to the candidate in token space. Formally, the \(k\) local neighbors are obtained as: \(N_{k}(^{*})=\{_{(1)},_{(2)},...,_{(k)}\}\), where \((i)\) is the index of the example with the \(i\)-th smallest distance to the candidate. In particular, we use the cosine similarity score to measure the distance between the candidate \(^{*}\) and other examples \(\):

\[(_{i},^{*})=_{i}^{}^{*}}{||_{i}|| _{2}||^{*}||_{2}}.\]

Ranking the perplexityAs discussed above, the local neighbors share the same level of inherent perplexity, which enables the comparison of their matching perplexity. For each candidate \(^{*}\), we propose to rank the perplexity of examples in the cluster of local neighbors \(^{*} N_{k}(^{*})\). Formally, we first sort all examples in the cluster in increasing order by the perplexity and obtain the original indices for the sorted scores as:

\[=\{(_{n}) \}_{n=1}^{k+1},_{n}(^{*} N_{k}(^{*})),\] (4)

where \(()\) is the overall perplexity defined in Equation 3. In this way, the high-ranking examples are more likely to be correctly annotated than the low-ranking example in the sorted list \(\).

Substituting the noisy candidatesTo build the final demonstration set, we propose to replace the noisy candidates with their nearest neighbors that are more likely to be clean. In particular, we can determine whether a candidate should be replaced by:

\[g(_{n})=((_{n},)}{k+1}),\] (5)

where \(\) is the pre-defined threshold (e.g., 50\(\%\)), \(()\) is the indicator function and \((_{n},)\) return the index of \(_{n}\) in the sorted list \(\). It is worth noting that the proposed method is not sensitive to the value of the hyperparameter \(\), as shown in Subsection 5.1. Then, for those candidates with \(g(_{n})\), we pick the substitutes from their neighbors by:

\[\{i N^{k}|g(_{(i)})=0\},\]

where \((i)\) is the index of the example with the \(i\)-th smallest distance to the candidate. After the replacement, we establish the final demonstration set for in-context learning. Noticeably, our method offers several compelling advantages:

* **Algorithm-agnostic**: LPR can be easily incorporated into existing demonstration selection methods, consistently improving the robustness against noisy annotations.
* **Easy to use**: LPR does not require heavy hyperparameter tuning, as it is insensitive to the threshold value (see Figure 3). LPR does not introduce much computational cost due to the efficient computation of perplexity (see Table 4).

## 5 Experiments

### Experimental Setup

**Datasets.** We employ 6 generation datasets for the evaluations, including **Open-Domain Question-Answering**: NQ , WebQ ; **Reading Comprehension**: SQuAD  and SCIQ ; **Code Generation**: GeoQuery  and NL2Bash . Due to limited space, these tasks' input/output, statistics, split and evaluation metrics are reported in Appendix A.2.

**Models and ICL methods.** For the main results, we use Llama-2-7B-Chat  as the LLM throughout our experiments. We also provide experiments on other models including Llama2-13B-Chat , Mistral-7B  and OPT-6.7B . We use bert-base-uncased sentence encoder as the similarity tokenizer [11; 62]. We conduct experiments with existing demonstration selection methods, including **Random**, **TopK** and **DPP**. For hyperparameters, we set the number of neighbors \(k=4\) and the threshold \(=50\%\) by default. The details of our implementation is presented in Appendix A.2.

### Main Results

**Can LPR improve the noise-robustness of in-context learning?** Table 2 presents the average in-context learning performance of the baselines and our method on six generation tasks, under various types of noisy annotations. A salient observation is that our method drastically improves the the noise-robustness performance of the existing demonstration selection methods by employing LPR.

    &  &  &  &  \\  & & 0\% & 20\% & 40\% & 60\% & 20\% & 40\% & 60\% \\   & Random & 14.51\(\)0.51 & 10.97\(\)0.29 & 7.37\(\)0.45 & 4.23\(\)0.46 & 12.00\(\)0.65 & 9.67\(\)0.45 & 6.40\(\)1.02 \\  & **+Ours** & **15.05\(\)0.10** & **13.31\(\)0.25** & **11.51\(\)0.51** & **8.87\(\)0.74** & **13.74\(\)0.12** & **13.28\(\)0.33** & **9.43\(\)0.52** \\   & TopK & 20.25\(\)0.10 & 13.95\(\)1.14 & 9.97\(\)1.13 & 5.90\(\)1.08 & 16.21\(\)0.22 & 12.22\(\)0.22 & 8.50\(\)0.28 \\  & **+Ours** & 19.19\(\)0.19 & **17.15\(\)0.50** & **13.54\(\)0.41** & **9.64\(\)0.25** & **17.25\(\)0.69** & **14.28\(\)0.51** & **11.99\(\)0.60** \\  & **DP** & 20.35\(\)0.76 & 14.69\(\)0.94 & 9.87\(\)0.91 & 5.47\(\)0.48 & 15.47\(\)1.00 & 11.28\(\)0.42 & 7.89\(\)0.25 \\  & **+Ours** & 19.68\(\)0.33 & **16.59\(\)0.45** & **13.31\(\)0.57** & **11.18\(\)0.50** & **16.79\(\)0.47** & **14.91\(\)0.18** & **11.94\(\)0.91** \\   & Random & 20.37\(\)0.64 & 15.18\(\)10.6 & 10.39\(\)0.83 & 4.83\(\)0.17 & 18.29\(\)0.43 & 15.92\(\)0.68 & 13.50\(\)0.17 \\  & **+Ours** & **21.94\(\)0.64** & **20.32\(\)0.92** & **16.33\(\)0.58** & **12.54\(\)0.29** & **21.51\(\)0.33** & **19.33\(\)0.41** & **16.69\(\)1.11** \\   & **TopK** & 30.16\(\)0.58 & 22.50\(\)0.64 & 14.52\(\)0.78 & 8.00\(\)1.12 & 27.91\(\)0.27 & 22.82\(\)0.57 & 8.18\(\)1.09 \\  & **+Ours** & 29.24\(\)0.34 & **26.55\(\)0.24** & **21.67\(\)1.28** & **14.54\(\)1.02** & **28.49\(\)0.43** & **25.44\(\)0.68** & **21.28\(\)0.12** \\   & DPP & 29.40\(\)0.39 & 22.11\(\)0.81 & 13.72\(\)0.27 & 7.33\(\)0.68 & 26.18\(\)1.04 & 21.53\(\)0.61 &For example, on the NQ with \(60\%\) irrelevant noise, our approach improves the EM score of the naive random selection method from 28.21 to 42.00 -a \(\) of direct improvement. Moreover, we show that the LPR can boost performance for a wide range of existing demonstration selection methods such as TopK  and DPP . For example, we observe that, on SCIQ with \(60\%\) irrelevant label noise, LPR improves the exact match score of the TopK method from 29.31 to 48.06 - a significant direct improvement of \(\). Our method also establish strong robustness against all types of noisy annotations. Appendix A.3 reports the results with various demonstration sizes.

**How does the threshold \(\) affect the noise-robustness of LPR?** In Figure 3 (a) and (b), we ablate how the parameter \(\) in our method (cf. Eq. 5) affects the noise-robust performance. The base indicates all candidate demonstrations are selected without our method. It's noteworthy that LPR shows robustness to the choice of threshold \(,\) even if we set \(=75\%\) also yield significant EM score improvements. We can also observe that as the threshold \(\) decrease, the noise-robust performance also improve, especially under \(60\%\) noise conditions. Due to space constraints, we only report the average results of multiple baselines on various generation tasks.

**Does LPR work with the different number of \(k\) nearest neighbors?** We evaluate how the number of nearest neighbors \(k\) in our method affects the LPR performance. Specifically, We vary the number of neighbors \(k=\{2,4,6\}\). As is shown in Figure 3 (c) and (d), an increase in the number of nearest neighbors beyond 0 leads to an evident improvement in EM score, and the performance starts to reach a point of saturation with the further addition of neighbors. Concernedly, more perplexity of nearest neighbors needs to be calculated as \(k\) value increase, but the improvement is limited. For simplicity, we employ a moderate range of neighbors and use \(k\)=4 throughout our experiments.

**Is LPR effective with different LLMs?** To show our proposed method is model-agnostic, we conduct experiments on a diverse collection of model architectures and present the results in Table 3. From the results, we observe that our method consistently improves the ICL performance when using Llama2-13B , Mistral-7B  and OPT-6.7B . For instance, with Mistral-7B, using our method boosts the ICL performance using the random selection method from 19.24 to 27.07, an average **7.83** of direct improvement on 6 datasets with irrelevant-60\(\%\) noisy annotations.

## 6 Discussion

**Global Perplexity Ranking vs. Local Perplexity Ranking.** While our method has demonstrated strong promise in in-context learning, one may also ask: _can a similar effect be achieved by selecting

Figure 3: The average test performance with different thresholds \(\) and numbers of local neighbors \(k\) across various noise types. Figure (a) and (b) analyze how the hyperparameter \(\) affects the performance of LPR. Figure (c) and (d) illustrate the influence of the hyperparameter \(k\).

    &  &  &  \\  & 0\% & 20\% & 40\% & 60\% & 20\% & 40\% & 60\% \\  Llama2-13B  & 45.13/**45.27** & 38.58/**43.47** & 29.00/**39.24** & 18.93/**30.46** & 42.18/**44.32** & 37.10/**41.88** & 30.67/**36.76** \\ Mistral-7B  & 34.89/34.12 & 32.12/**33.59** & 26.28/**31.56** & 19.24/**27.03** & 33.43/**33.91** & 30.52/**32.64** & 26.63/**30.00** \\ OPT-6.7B  & 23.46/**24.03** & 17.26/**21.31** & 11.32/**17.29** & 7.68/**12.91** & 20.16/**22.40** & 17.58/**20.22** & 14.95/**17.52** \\   

Table 3: Average test performance of the baselines and our method using varying large language models across various noise types. The results are shown as Naive/+Ours. The bold indicates the improved results by integrating LPR.

demonstrations with the lowest perplexity in the whole dataset?_ In this ablation, we compare our method with a global perplexity ranking method that selects demonstrations with the lowest perplexity values of input-label pairs from a large candidate set (e.g., \(\{(_{i},_{i})\}_{i=1}^{100}\)).

Table 4 presents the performance comparison between our method and the global perplexity ranking method. While both the two perplexity ranking methods improve the robustness of ICL against noisy annotations, the global approach obtains inferior performance compared to our proposed method in most cases, especially in the cases of clean and low noise rates. In efficiency, Table 4 also show that the local ranking approach requires only \(20\%\) of the time required by the global ranking. This is because our method only calculates the perplexity of the local neighbors for each candidate, instead of using a large candidate pool. Overall, we show that the global ranking method cannot outperform the local ranking while introducing much more computational loads.

**Transfer to text classification tasks.** Text classification is a common task of in-context learning, which may also suffer from a noisy annotation issue. To this end, we verify the effectiveness of the proposed method in text classification. Here, we consider two classification tasks (SST2  and AGNews ) with popular label noise types: the symmetric noise and the asymmetric noise . We report the average accuracy with GPT-Neo-2.7B  on datasets with the two noise types. More detailed experimental settings are presented in Appendix A.2.

Figure 4 demonstrates that noise annotations barely hurt the performance of ICL when employing the random demonstration selection method . However, the performance of ICL is significantly compromised when utilizing more effective selection methods like TopK  and DPP . After integrating our method, both TopK and DPP methods are significantly improved in the inference performance, which indicates the noise robustness of our method in text classification.

**Potential failure cases.** Our approach is built on two assumptions that are naturally satisfied in the real world (See Section 4.2). In this section, we conduct experiments on four generation tasks, including NQ, WebQ, SCIQ, and SQuAD, to determine whether our proposed method remains effective when one of these two assumptions is dissatisfied. The detailed analysis is presented below.

Assumption 1 (Data): clean annotations are the majority in the annotated dataset. Given a dataset with extremely high noise ratios (e.g., \(60\%\), \(70\%\), \(80\%\), \(90\%\)), the perplexity ranking of local neighbors may not reflect the correctness of the annotations, as most (even all) neighbors can be wrongly annotated. To explicitly show that, we conduct an experiment to validate the performance of LPR under extremely high noise ratios. The Table 5 below presents the average EM score of the baselines

    & Clean &  &  &  \\  & 0\% & 20\% & 40\% & 60\% & 20\% & 40\% & 60\% \\  Random & 39.32/**40.66** & 38.94/38.89 & **34.41**/32.98 & **27.82**/26.59 & 39.23/**39.90** & 36.38/**37.31** & 31.76/**33.24** & 2.88/**0.55** \\ TopK & 40.57/**43.94** & 39.94/**41.44** & 35.85/**36.02** & **31.79**/28.38 & 40.33/**42.60** & 38.69/**39.53** & 33.88/**34.48** & 3.06/**0.57** \\ DPP & 42.33/**44.32** & 40.18/**41.94** & 36.20/**36.86** & **30.91**/28.60 & 40.42/**42.98** & 38.49/**40.51** & 32.24/**35.20** & 3.21/**0.64** \\  Average & 40.74/**42.97** & 39.68/**40.76** & **35.49**/35.28 & **30.17**/27.86 & 39.99/**41.83** & 37.85/**39.12** & 32.63/**34.31** & 3.05/**0.57** \\   

Table 4: Average test performance comparison between global perplexity ranking and local perplexity ranking. The results are shown as _Global/Local_. Bold numbers are superior results.

Figure 4: Average test accuracy on SST2  and AGNews . Different colors indicate the selection methods. The solid lines denote existing selection methods, and the dotted lines represent the method integrated by our method. We omit the noisy type on the binary classification – SST2.

and our method. We use Llama2-7B  as the LLM throughout our experiments. The results show that the improvements of our approach decrease as the noise ratios increase. For example, when the irrelevant label noise ratio increases from 60\(\%\) to 90\(\%\), the improvement of our method for the TopK method decreases from 10.26 to 0.92.

Assumption 2 (Model): examples that are semantically similar share the same level of inherent perplexity. The model affects the the performance of LPR through the concept of inherent perplexity. This assumption cannot hold if the model is not capable of precisely measuring the semantic distance between examples. In this case, the local neighbors may not share the same level of inherent perplexity so that we cannot compare the Matching Perplexity. To validate this, we conduct experiments with language models with various sizes, including OPT-1.3B, OPT-2.7B and OPT-6.7B . The results in Table 6 reveal that the performance of LPR decreases as the parameter size of language models decreases. For instance, for 60\(\%\) irrelevant noise, the improvement of our method decreases from 5.23 to 0.46 when the parameter size of the language model decreases from 6.7B to 1.3B.

## 7 Conclusion

In this paper, we introduce Local Perplexity Ranking (**LPR**), a general strategy that can universally enhance the noise robustness of in-context learning on generation tasks. To the best of our knowledge, this work is the first to analyze the noisy annotations in ICL for text generation. Our key idea is to decouple the matching perplexity by performing the ranking among the neighbors in semantic space. In particular, we replace each low-ranked candidate with its nearest neighbor that is highly ranked. Extensive experiments demonstrate that LPR can improve the noise robustness of existing demonstration selection methods in ICL across various noise types. Our approach is easy to use in practice, as it is insensitive to the hyperparameters and does not introduce heavy computational cost.

**Limitations.** LPR is suboptimal in cases of high noise rates due to the assumption that clean annotations are the majority in the dataset. In addition, we do not provide a theoretical analysis to show how noisy annotations affect ICL, which will be an interesting direction for future research.

## 8 Acknowledgements

This research is supported by the Shenzhen Fundamental Research Program (Grant No. JCYJ20230807091809020). Feipeng Zhang is supported by the National Natural Science Foundation of China (Grant No. 72171192) and the Youth Innovation Team of Shaanxi Universities. Jun Shu is supported in part by the National Natural Science Foundation of China (Grant No. 12326606). Feng Zheng is supported in part by the National Natural Science Foundation of China (Grant No. 62122035). We gratefully acknowledge the support of the Center for Computational Science and Engineering at the Southern University of Science and Technology for our research.

    & Clean &  &   } &  \\  & 0\% & & & 40\% & 60\% & 20\% & 40\% & 60\% \\  OPT-1.3B & 13.06/**13.22** & 10.48/**10.96** & 8.66/**9.63** & 5.95/**6.41** & 12.21/**12.58** & 11.33/**11.53** & 10.42/**10.81** \\ OPT-2.7B & 15.30/**15.70** & 12.68/**13.23** & 10.53/**11.45** & 7.01/**9.02** & 14.15/**14.73** & 13.21/**14.33** & 11.86/**12.85** \\ OPT-6.7B & 23.46/**24.03** & 17.26/**21.31** & 11.32/**17.29** & 7.68/**12.91** & 20.16/**22.40** & 17.58/**20.22** & 14.95/**17.52** \\   

Table 6: Average test performance of the baselines and our method using varying large language models (e.g. OPT-1.3B, OPT-2.7B, OPT-6.7B ) across various noise types. The results are shown as Naive/+Ours. The bold indicates the improved results by integrating LPR.

    &  &  \\  & 60\% & 70\% & 80\% & 90\% & 60\% & 70\% & 80\% & 90\% \\  Random & 15.80/**26.60** & 11.61/**16.97** & 7.98/**11.24** & 4.79/**4.55** & 27.87/**33.25** & 24.67/**28.29** & 22.51/**24.45** & 20.15/**21.20** \\ TopK & 18.08/**28.08** & 14.62/**18.24** & 10.16/**10.96** & 6.25/**17.17** & 29.55/**34.48** & 26.02/**29.23** & 23.28/**25.87** & 21.21/**22.68** \\ DPP & 16.87/**28.61** & 15.10/**18.01** & 9.93/**10.03** & 6.46/**7.18** & 29.51/**35.19** & 25.85/**28.86** & 23.28/**25.27** & 20.83/**21.95** \\   

Table 5: Average test performance of the baselines and our method for four generation tasks on four datasets with extremely high noise ratios (e.g., 60\(\%\), 70\(\%\), 80\(\%\), 90\(\%\)). The results are shown as Naive/+Ours. The bold indicates the improved results by integrating LPR.