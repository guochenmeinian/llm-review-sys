# Guiding Large Language Models via

Directional Stimulus Prompting

 Zekun Li\({}^{1}\)

Part of the work was done when Zekun Li was interning at Microsoft Research.

Baolin Peng\({}^{2}\)

Pengcheng He\({}^{2}\)

Michel Galley\({}^{2}\)

Jianfeng Gao\({}^{2}\)

Xifeng Yan\({}^{1}\)

University of California

Santa Barbara\({}^{1}\)

Microsoft\({}^{2}\)

{zekunli, xyan}@cs.ucsb.edu

{bapeng,penhe,mgalley,jfgao}@microsoft.com

###### Abstract

We introduce _Directional Stimulus Prompting_, a novel framework for guiding black-box large language models (LLMs) towards specific desired outputs. Instead of directly adjusting LLMs, our method employs a small tunable policy model (e.g., T5) to generate an auxiliary _directional stimulus prompt_ for each input instance. These directional stimulus prompts act as nuanced, instance-specific hints and clues to guide LLMs in generating desired outcomes, such as including specific keywords in the generated summary. Our approach sidesteps the challenges of direct LLM tuning by optimizing the policy model to explore directional stimulus prompts that align LLMs with desired behaviors. The policy model can be optimized through 1) supervised fine-tuning using labeled data and 2) reinforcement learning from offline or online rewards based on the LLM's output. We evaluate our method across various tasks, including summarization, dialogue response generation, and chain-of-thought reasoning. Our experiments indicate a consistent improvement in the performance of LLMs such as ChatGPT, Codex, and InstructGPT on these supervised tasks with minimal labeled data. Remarkably, by utilizing merely 80 dialogues from the MultiWOZ dataset, our approach boosts ChatGPT's performance by a relative 41.4%, achieving or exceeding the performance of some fully supervised state-of-the-art models. Moreover, the instance-specific chain-of-thought prompt generated through our method enhances InstructGPT's reasoning accuracy, outperforming both generalized human-crafted prompts and those generated through automatic prompt engineering. The code and data are publicly available.3

## 1 Introduction

In recent years, a new paradigm has emerged in natural language processing (NLP) with the rise of large language models (LLMs) such as InstructGPT, ChatGPT , GPT-4 , PaLM , and others. These models exhibit emergent abilities  such as strong in-context learning and few-shot prompting capabilities, which were not present in previous "smaller" language models (LMs) like BERT , RoBERTa , GPT-2 , and T5 . This shift in paradigm has led to remarkable advancements in NLP, with LLMs demonstrating impressive general-purpose power. However, due to commercial considerations and the risk of misuse, most LLMs do not publicly release their parameters and only allow users to access them through black-box APIs. While there also exist open-sourced LLMs, fine-tuning them for specific tasks or use cases can be computationally inefficient. In this scenario, the standard approach for utilizing LLMs to perform diverse tasks is crafting generalizedtask-specific prompts to query LLMs. While LLMs have demonstrated considerable performance on a wide range of language tasks, they still struggle to generate outputs that fully align with desired behaviors and directions on some specific tasks and use cases [16; 4].

Optimizing Large Language Models (LLMs) directly for specific tasks can be infeasible or inefficient for many users and developers, leading researchers to shift their focus towards prompt engineering and optimization. Prompt engineering approaches, which involve manually or automatically designing optimal task-specific natural language instructions and selecting appropriate training samples for demonstration in the prompt, have consequently gained the attention of researchers [6; 55; 79; 39]. Despite these efforts, the majority are centered on devising task-specific prompts, often falling short in steering LLMs to generate desired results on a per-instance basis.

To address the challenge, we propose a novel framework called **Directional Stimulus Prompting (DSP)**. This framework introduces a new component called the _directional stimulus_ into the prompt to provide nuanced, instance-specific guidance and control over LLMs. Specifically, the directional stimulus prompt acts as _hints_ and _clues_ for the input query to guide LLMs toward the desired output. Notably, this differs from the methods that augment LLMs with additional knowledge retrieved from external sources [25; 60], as the directional stimulus prompt is generated solely based on the input query in our framework. Figure 1 compares our proposed prompting approach, DSP, with standard prompting for the summarization task. Our approach incorporates keywords in the prompt as the directional stimulus prompt to hint at key points the desired summary should cover. By providing this instance-specific guidance through directional stimulus prompts, LLMs can generate outputs that more closely align with the desired reference summary.

We utilize a relatively small and tunable LM (e.g., T5), as the policy model to generate the directional stimulus prompt for each input query. This approach enables us to sidestep the direct optimization of black-box LLMs by optimizing the small tunable policy model instead. We train the policy model through supervised fine-tuning (SFT) using a few collected labeled data. After supervised fine-tuning, we further optimize the policy model to explore better directional stimulus prompts with reinforcement learning (RL). During RL training, we aim to maximize the reward defined as downstream performance measures or any other measures of the LLM's output conditioned on the stimulus generated by the policy model.

Figure 2 provides the overview of our framework, using the summarization task as an illustrative example. We employ a compact, tunable policy model to generate the directional stimulus prompt,

Figure 1: Comparison of our Directional Stimulus Prompting and the standard prompting method using LLMs such as ChatGPT for the summarization task. DSP utilizes directional stimulus/hints (highlighted in orange), which are keywords in this case, to provide instance-specific guidance to LLMs in generating summaries (highlighted in blue) that better align with the desired reference summary with higher ROUGE scores or other measures like human preferences.

which specifies keywords that should be included in the LLM-generated summaries. The policy model can be trained with SFT and RL, where the reward is typically defined as the downstream task performance measure, such as the ROUGE score for the summarization task, or other alignment measures like human preferences.

Our framework can be flexibly adapted to a wide range of LMs and tasks by choosing the appropriate directional stimulus prompt, i.e., hints. We conducted experiments on summarization, dialogue response generation, and chain-of-thought reasoning tasks to evaluate the effectiveness of our framework. The results demonstrate that our DSP approach can effectively guide LLMs toward the desired targets with a small collection of labeled data. Specifically, we conduct experiments with the black-box LLMs: ChatGPT, Codex, and InstructGPT. For the policy model, we employ a 750M Flan-T5-Large [53; 11] and 220M T5-Base. For the summarization task, we use keywords as the directional stimulus, which hints at key points that the desired summary should include. Despite ChatGPT's already considerable performance, the policy model trained with only 4,000 samples from the CNN/Daily Mail dataset  improved the ROUGE and BLEU scores by 4-13%. For the dialogue response generation task, we train the policy model to generate dialogue acts that indicate the underlying intentions behind target responses on dialogues from the MultiWOZ dataset . Guided by the policy model trained with only 80 dialogues, ChatGPT's performance improved by up to 41.4% in combined scores, achieving comparable or even better performance than some state-of-the-art models trained on the full dataset with 8,438 dialogues. For the chain-of-thought reasoning, we train the policy model to generate a trigger prompt for each input query to steer the LLM chain-of-thought reasoning, achieving better performance than the generalized hand-crafted prompts and those produced through the automatic prompt engineering approach , suggesting the effectiveness of our approach for automatic prompt engineering and optimization.

## 2 Directional stimulus prompting

For a downstream task, there is an input space \(X\), a data distribution \(\) over \(X\), and an output space \(Y\). Due to the strong in-context learning and few-shot prompting abilities, LLMs can perform diverse tasks and generate the output \(\) by including instructions that describe the task, a few demonstration examples, and the input query \(\) in the prompt . However, such prompts cannot always steer LLMs toward desired outputs, especially when it comes to fine-grained instance-specific desired behaviors. For instance, in the case of the summarization task, the input \(\) is an article, and the output \(\) is the corresponding summary. Different summarizers have distinct styles and emphasize different aspects of an article . In this case, it may not be enough to effectively steer LLMs toward generating summaries that closely match reference summaries relying solely on task-specific instructions or demonstration examples to describe such nuanced differences for each sample.

To this end, our Directional Stimulus Prompting (DSP) approach introduces a small piece of discrete tokens \(\) named "_directional stimulus_" into the prompt, which acts as hints and clues to provide LLMs with fine-grained guidance toward the desired direction. For example, for the summarization task, the directional stimulus \(\) might consist of keywords that should be included in the desired

Figure 2: Overview of our proposed framework DSP, where we learn a small tunable policy model to generate the directional stimulus (keywords in this case) that provides input-specific guidance for the LLM toward the desired target. The policy model can be trained with SFT and/or RL, where the reward is defined as the downstream task performance measure, such as the ROUGE score for the summarization task, or other alignment measures like human preferences.

summary. To generate this stimulus for each input query, we use a small tunable policy language model, \(p_{}(|)\). We then use this generated stimulus, \(\), along with the original input, \(\), to construct the prompt that steers the LLM toward generating its output, \(p_{}(|,)\). It's important to note that the parameters of the LLM, \(p_{}\), are kept frozen, as they are either inaccessible or inefficient to tune. Overall, when using the LLM with DSP to perform a downstream task, the output is obtained via \( p_{}(|,), p_{}( |)\).

### Supervised fine-tuning

To train the policy model that generates directional stimulus for LLMs, we first perform supervised fine-tuning (SFT) on a pre-trained LM (e.g., T5, GPT-2, etc) on a small collection of labeled data. To collect the data, we could heuristically select or annotate the "pseudo-stimulus" \(^{*}\) for each input query \(\) and target output \(\) pair based on the downstream task. For example, for the summarization task, we use keywords that the reference summary includes as pseudo-stimulus, while for the dialogue response generation task, we use dialogue acts that indicate the underlying meaning of the desired system response (see Section 3 for details). The resulting dataset \(^{}=\{(,^{*})\}\) consists of input-stimulus pairs. We then fine-tune the policy model by maximizing the log-likelihood:

\[_{}=-_{(,^{*})} {log}p_{}(^{*}|).\] (1)

Supervised fine-tuning can provide a good initial point for the policy model. However, it is important to note that the heuristically selected or annotated pseudo-stimulus may not always be optimal, and the supervised fine-tuned policy model may not generate the most preferred directional stimulus for the LLMs toward the desired outputs. To overcome this limitation, we can also incorporate reinforcement learning (RL) to further fine-tune the policy model. By directly optimizing the LLM's output toward desired targets, RL training enables the policy model to explore and generate more effective directional stimulus.

### Reinforcement learning

#### 2.2.1 Optimization objective

Our goal is to steer the LLM's generation toward the desired target by maximizing an alignment measure \(\), which can take various forms such as downstream task performance measures (e.g., ROUGE score for summarization), human preferences, or other customized measures. Mathematically, we aim to maximize the below objective:

\[_{, p_{}( |), p_{}(|,)}[(, )].\] (2)

Since the parameters of the black-box LLM are not accessible or tunable, we resort to optimizing the policy model to generate the directional stimulus that guides the LLMs' generation toward maximizing the objective. To achieve that, we define another measure \(_{}\) that captures how well the LLM performs when conditioned on a given stimulus \(\):

\[_{}(,)=(,), p _{}(|,).\] (3)

This allows us to cast the original objective of maximizing \(\) into optimizing the policy model to generate stimulus that maximizes \(_{}\). By doing so, the LLM is effectively used as an evaluation function to guide the policy model toward generating more effective directional stimulus. Thus, the optimization objective for LLMs in Equation 2 is equal to the optimization objective for the policy model:

\[_{p_{}}_{, p_{ }(|)}[_{}(,)].\] (4)

#### 2.2.2 RL formulation

However, the above optimization is intractable for the policy model. To address the issue, we formulate the policy model optimization as an RL problem and employ proximal policy optimization (PPO) . We use the policy model to initialize a policy network \(_{0}=p_{}\) and then update \(\) using PPO. The process that the policy model generates a sequence of tokens as stimulus \(\) can be seen as a Markov decision process (MDP) \(,,r,\) with a state space \(\), action space \(\), reward function \(r\), and state-transition probability \(\). In each time step \(t\) of an episode, the agent selects an action (token) from the vocabulary \(\) according to the distribution of the current policy network \((|,_{<t})\). The episode ends when an end-of-sequence token is selected, and the stimulus \(\) is generated. We can fine-tune the policy network \(\) by optimizing the reward \(r\):

\[_{}[r]=_{,(|)}[r(,)].\] (5)

**Reward function** Recall that our goal is to maximize the objective in Equation 4, which can be used as the reward \(r\). To keep the policy network \(\) from moving too far from the initial policy model \(p_{}\), we also add a KL-divergence penalty reward. Therefore, the final reward becomes:

\[r(,)=_{}(,)-|)}{p_{}(|)}.\] (6)

Following [80; 54], we dynamically adapt the coefficient \(\) during training:

\[_{t} =((_{t},p_{})-_{}}{_{}},-0.2,0.2),\] (7) \[_{t+1} =_{t}(1+K_{}_{t}).\] (8)

**Implementation** To optimize the policy network \(\), we use the NLPO version of PPO from , which is specifically designed for language generators. To address the issue of large action spaces in PPO, NLPO learns to mask out less relevant tokens in the vocabulary using top-\(p\) sampling. This technique restricts the action space to the smallest set of tokens whose cumulative probability is greater than the given probability parameter \(p\), which we set to 0.9 in our experiments. Both the policy network \(\) and value network are initialized from the supervised fine-tuned policy model \(p_{}\), with the final layer of the value network randomly initialized to output a scalar value using a regression head.

## 3 Experiments

Our proposed framework DSP can be flexibly applied to various types of LMs and generation tasks. In this work, we focus on 1) summarization, 2) dialogue response generation, and 3) chain-of-thought reasoning tasks. We mainly use pre-trained T5 or Flan-T5 [53; 11] to initialize the policy model and experiment with the black-box LLMs including **ChatGPT** (gpt-3.5-turbo), **Codex** (**code-davinci-002**), and **InstructGPT** (**text-davinci-002**).

### Summarization

Recent studies [16; 75; 4] have shown that LLMs, such as GPT-3, InstructGPT, and ChatGPT, are capable of generating high-quality summaries with zero- or few-shot prompting. However, their reference-based evaluation benchmark performances, such as ROUGE scores, still lag behind fine-tuned methods, indicating that the generated summaries may not completely match the style and emphasis of the reference summaries. In our experiments, we seek to guide LLMs to generate summaries that more closely align with the reference summaries by providing keywords that should be mentioned in the desired summaries as hints. We evaluate the effectiveness using metrics that compare the generated summaries against reference summaries. Notably, other desired directions, such as better alignment with human preferences, can also be pursued.

**Dataset and evaluation** We conduct our experiments on the CNN/Daily Mail dataset, a widely-used news summarization benchmark. To keep the cost of API usage low, we train on a subset of 1,000, 2,000, and 4,000 article-summary pairs from the total 287,113 samples in the training set. For evaluation, we randomly select 500 samples, following previous work [16; 65], which has been proven to provide sufficient statistical power . We use the overlap-based metrics, including ROUGE , BLEU , and Meteor , and the similarity-based metric, BERTScore , to compare the generated summaries with the references. The reported evaluation scores are averaged over three inferences of ChatGPT for each query, using a temperature of 0.7 and top_p of 1.0. We use the same three demonstration examples in the prompt for standard prompting and add keywords as directional stimulus in the prompt for our approach, DSP. The exact prompts used in our experiments are provided in the Appendix.

**Supervised fine-tuning details** We use keywords as the pseudo-stimulus to train the policy model with supervised fine-tuning as discussed in Section 2.1. To collect the data, we employ textural [41; 5] to automatically extract the keywords from the article and summary and only keep those that appear in the reference summary. As a result, we obtain a list of extracted keywords for each article-summary pair in the dataset. To convert them into a sentence that serves as the stimulus, we concatenate them using a split token ";", resulting in the stimulus formated as "_[Keyword1]; [Keyword2];...;_[KeywordN]_.". We use the constructed article-stimulus pairs to train the policy model via supervised fine-tuning. The input format for training is "_Extract the keywords: [Article]_", while the output is the target stimulus consisting of keywords. The policy model was trained for 5 epochs with a \(2 10^{-5}\) learning rate.

**RL training details** As we aim to guide ChatGPT in generating summaries that more closely match the reference summaries, we adopt the automatic reference-based metric scores as the alignment measure reward. Specifically, we calculate the ROUGE-Avg score between the generated summaries and the reference summaries as the reward, with a rescaling coefficient of 10. We experimentally found that other automatic evaluation metrics, such as BLEU and Meteor, perform similarly. To reduce variance, we generate four outputs per input query using ChatGPT with a temperature of 0.7 and compute the average reward. Additionally, we assign a step-wise reward, which we found could improve the efficiency and stability of the training process. Specifically, the policy model generates a sequence of keywords in each episode, during which we assign a reward of 1 if a keyword appears in the reference summary and a penalty reward of -0.2 is given otherwise. We train the policy network for 51k episodes, with 5 epochs per batch, a batch size of 8, and a learning rate of \(2 10^{-6}\). The KL\({}_{}\) and \(_{0}\) in Equation 7 are set to 0.5 and 0.005, respectively.

**Results** We evaluate the performance of ChatGPT with standard prompting and our approach DSP trained with SFT or SFT and then RL (SFT+RL) on varying sizes of training data and present the results in Figure 3. As can be seen, all the evaluation scores improve with our proposed DSP compared with standard prompting. Specifically, the supervised fine-tuned policy model generates the stimulus that effectively guides ChatGPT to generate summaries that closely align with the reference summaries, leading to improved benchmark performance. Furthermore, the additional fine-tuning of the policy model with RL results in further performance improvement, indicating the effectiveness of RL in exploring better directional stimulus that maximizes the reward. As the size of the training data increases, the performance improvement becomes more significant. Despite using a small collection of only 1,000 to 4,000 samples to keep API usage costs low, our DSP approach still

Figure 4: Training curve on 1000 samples from the CNN/Daily Mail dataset.

Figure 3: Performance comparison of ChatGPT with standard prompting and DSP trained with SFT and SFT+RL, using varying numbers of training samples from the CNN/Daily Mail dataset.

consistently enhances ChatGPT's ROUGE, BLEU, and Meteor scores by 1-2 in absolute points, even though ChatGPT has already achieved considerable performance. However, due to the discrepancy between the semantic-based metric BERTScore and the overlap-based metric ROUGE, which are used as the reward, the improvement in BERTScore after RL training may be relatively less significant. Figure 4 presents the change of training rewards and ROUGE-1 score on the validation set during the training process on 1,000 samples. We can see that the performance is closely related to the training rewards, and the training is relatively stable using the NLPO algorithm.

### Dialogue response generation

In recent years, there has been a rise in LLM-based chatbots such as ChatGPT4 and Sparrow 5. These chatbots are typically targeted at open-domain conversations to engage with users on a wide range of topics without a specific goal in mind. However, these chatbots still face challenges in handling task-oriented dialogues where they need to assist users in completing specific goals or tasks, such as making reservations or ordering food [4; 22]. Unlike open-domain conversations, task-oriented dialogues often require the chatbot to follow task-specific business logic and respond based on reliable information from API calls or database queries. To address this limitation, we train a small policy model to learn the underlying dialogue policy from the training data and thus guide the LLMs in generating reliable system responses that assist users in completing tasks.

Dataset and evaluationWe conduct experiments on the popular task-oriented dialogue dataset MultiWOZ , including both the MultiWOZ2.0 (the original version) and MultiWOZ2.1 version . The dataset provides annotations for user utterances, dialogue acts, and system responses for each dialogue turn. The goal is to generate the system response given the history dialogue context as input. We utilize the dialogue act, which represents the communicative intention of the target system response, as the pseudo-stimulus for our experiment. There are 8,438 dialogues in the training set. We only use 1% (80 dialogues) and 10% (800 dialogues) to train the policy model and evaluate the performance on the full validation and test set, which contains 1,000 dialogues. We use the standard evaluation metrics: **Inform**, which measures the rate that the appropriate entity that satisfies the user's requirements is provided; **Success**, which measures the rate that all requested attributes are answered; **BLEU**: the corpus-level BLEU score with reference responses; and an overall measure **Combined score** = (Inform+Success)\(\)0.5+BLEU. Likewise, we report the average score over three inferences. We use the same three demonstration examples when using DSP or standard prompting.

Supervised fine-tuning detailsTo conduct supervised fine-tuning on the policy model, we format the input of each sample as _Translate dialogue to dialogue action: [Dialogue context]_", with the target being the verbalized dialogue acts in the same format as [77; 63]. For instance, a dialogue act <_hotel, inform, choice>, <_hotel, inform, type>, <_hotel, request, area_> will be converted to "_[hotel] [inform] choice type [request] area_", which indicates that the system should inform available hotel choices and their types and ask for the area that the user would like (see the Appendix for examples). Note that the provided dialogue act annotations may not be the only valid dialogue act for the same dialogue content , and thus we hope to explore diverse valid dialogue acts (directional stimulus) through RL training.

RL training detailsThe evaluation metrics Success and Inform rates are defined at the dialogue level, while the BLEU score is computed on the corpus level. However, our training and inference on conducted on the turn level. We thus use the sentence-level SacreBLEU  score as the reward. Same as in the summarization experiments, we generate four outputs per input using the LLM with a temperature of 0.7. The policy network is trained 52k episodes, 5 epochs per batch with a batch size of 8 and a learning rate of \(2 10^{-6}\). Since the generated dialogue acts should adhere to the business logic and ontology, we ensure that the updated policy network does not deviate significantly from the original policy model. We thus set the KLtarget and \(_{0}\) in Equation 7 as 0.2 and 0.01, respectively. During training, we use top-\(k\) sampling and set \(k\) to 50 to explore the action space. During inference, we use beam search decoding with a beam size of 5.

ResultsWe evaluate the impact of our approach DSP on Codex and ChatGPT and compare the performance with several representative task-oriented dialogue models trained on the full training set (8438 dialogues), including DAMD , MinTL , Soloist , SimpleTOD , DoTS , PPTOD , UBAR , and GALAXY . Table 1 summarizes the overall performance comparison, from which we obtain the following observations: (1) Our approach DSP significantly improves the success and inform rates of Codex and ChatGPT, indicating that they better understand the scenario and generate appropriate responses that help users in completing their tasks. (2) However, there is no improvement in the corpus-level BLEU score, possibly because the LLMs generate responses with different speaking styles and vocabulary since they do not see oracle system responses. Nevertheless, the high success and inform rates demonstrate the usefulness of our approach in delivering helpful and reliable responses. (3) Increasing the number of supervised fine-tuning samples does not guarantee performance improvement, but further fine-tuning the policy model using RL consistently provides performance gains. This suggests that RL training encourages the policy model to explore more model-preferred stimulus, while supervised fine-tuning may merely generate stimulus closely aligned with the pseudo-labeled data, which is not necessarily optimal. (4) Our approach achieves notable success with only 80 dialogues, surpassing several fully trained TOD models, particularly in terms of Success and Inform rates. With 10% of the training data (800 dialogues), our approach delivers comparable performance to current SOTA methods trained with full training data (8438 dialogues). We have also provided the performance of these compared methods in the low-resource settings (1% and 10%) and a running example in the Appendix.

### Chain-of-Thought reasoning

While current methods primarily utilize generalized task-specific prompts, LLMs exhibit sensitivity to these prompts. Existing studies [69; 26; 79] illustrate that the performance of LLMs can vary significantly based on the prompt used. Consequently, a substantial portion of earlier work has been dedicated to either manually  or automatically [61; 79] crafting prompts. However, these studies largely concentrate on task-specific prompts, which may not be optimal for every instance of a task. In our experiment, we employ our approach to generate instance-specific prompts to elicit Chain-of-Thought (CoT) reasoning. Specifically, we train a policy model (t5-base) to generate instance-specific CoT trigger prompts, such as "_Let's think step by step_", to prompt varying samples.

Dataset and evaluationWe adopted the experimental setup from previous work [26; 79], where we tested zero-shot CoT reasoning abilities of InstructGPT (text-davinci-002) with different trigger prompts. There are 600 examples in the MultiArith dataset , which we divided into

    &  &  &  \\   & & & Inform & Succ. & BLEU & Comb. & Inform & Succ. & BLEU & Comb. \\   \\ Standard Promping & - & 76.7 & 41.5 & 7.7 & 66.8 & 74.2 & 41.9 & 7.8 & 65.9 \\ DSP w/ SFT & 1\% (80) & 74.9 & 66.3 & 11.1 & 81.7 & 72.0 & 66.0 & 11.3 & 80.1 \\ DSP w/ SFT+RL & 1\% (80) & 91.0 & 76.0 & 9.8 & 93.3 & 89.7 & 78.6 & 9.4 & 93.4 \\ DSP w/ SFT & 10\% (800) & 79.4 & 71.9 & 11.3 & 87.0 & 72.0 & 67.0 & 13.1 & 82.6 \\ DSP w/ SFT+RL & 10\% (800) & 96.0 & 86.9 & 10.7 & 102.2 & 94.0 & 86.0 & 9.2 & 99.2 \\   \\ Standard Promping & - & 71.8 & 44.1 & 10.5 & 68.4 & 72.8 & 44.2 & 10.4 & 68.9 \\ DSP w/ SFT & 1\% (80) & 76.6 & 66.5 & 11.2 & 82.8 & 76.0 & 64.3 & 11.3 & 81.4 \\ DSP w/ SFT+RL & 1\% (80) & 90.9 & 82.2 & 10.2 & 96.7 & 87.3 & 78.7 & 10.7 & 93.7 \\ DSP w/ SFT & 10\% (800) & 72.7 & 64.7 & 11.8 & 80.5 & 75.0 & 67.7 & 12.6 & 83.9 \\ DSP w/ SFT+RL & 10\% (800) & 95.3 & 82.3 & 10.9 & 99.6 & 95.0 & 84.0 & 10.7 & 100.2 \\   \\ DAMD  & 100\% (8438) & 76.3 & 60.4 & 16.6 & 85.0 & - & - & - & - \\ MinTL  & 100\% (8438) & 84.9 & 74.9 & 17.9 & 97.8 & - & - & - & - \\ Soloist  & 100\% (8438) & 85.5 & 72.9 & 16.5 & 95.7 & - & - & - & - \\ SimpleTOD  & 100\% (8438) & 84.4 & 70.1 & 15.0 & 92.3 & 85.0 & 70.5 & 15.2 & 93.0 \\ DotTS  & 100\% (8438) & 86.6 & 74.1 & 15.1 & 95.5 & 86.7 & 74.2 & 15.9 & 96.3 \\ PTOD  & 100\% (8438) & 89.2 & 79.4 & 18.6 & 102.9 & 87.1 & 79.1 & 19.2 & 102.3 \\ UBAR  & 100\% (8438) & 95.4 & 80.7 & 17.0 & 105.1 & 95.7 & 81.8 & 16.5 & 105.3 \\ GALAXY  & 100\% (8438) & 94.4 & 85.3 & 20.5 & 110.4 & 95.3 & 86.2 & 20.0 & 110.8 \\   

Table 1: Response generation performance of different methods on the MultiWOZ 2.0&82.1 datasets, where Succ. and Comb. denote the Success and Combined Score metrics, respectively.

300/50/250 for training/validation/test set. As for the AQuA dataset , we use the standard test set with 254 samples, 300 samples from the standard training set for our training, and 100 samples for the standard validation set for our validation. We report the reasoning accuracy.

Supervised fine-tuning detailsFor supervised fine-tuning (SFT), we first run inference on the training set with the 14 human-crafted prompts tested in , respectively. We then selected those prompt and query pairs which resulted in a correct CoT reasoning outcome to form the training set for SFT. These query-prompt pairs were used to train a t5-base policy model for 2 epochs, with the model input being the query instance and the target output a trigger prompt.

RL training detailsAfter SFT, the prompts generated by the policy model were used to trigger InstructGPT for zero-shot CoT prompting. Reasoning accuracy was utilized as the reward for reinforcement learning (RL). A reward of 1 was assigned for correct reasoning results and 0 otherwise. We conducted 20 training iterations (106k episodes), with 5 epochs per batch, a batch size of 8, and a learning rate of 2e-6. The parameters for KLtarget and \(_{0}\) were set to 0.5 and 0.001, respectively.

ResultsWe compare the performance of using our generated instance-specific prompts with using the 14 human-crafted prompts which we used as the pseudo-stimulus to constitute the training set for SFT and also the prompt automatically discovered by the APE approach . Note that all these 15 prompts are generalized task-specific and are used for the whole test set while ours are instance-specific. The performance comparison is shown in the Table 8. As can be seen, InstructGPT's performance varies significantly when using different task-specific prompts. Compared to the 14 task-specific human-designed prompts, DSP enhances the performance with instance-specific prompts. It also outperforms the prompt discovered by the APE approach, suggesting the effectiveness of our approach for automatically prompt engineering and optimization. Solely relying on supervised fine-tuning of the policy model with the dataset comprising the 14 human-designed prompts doesn't lead to its peak performance. After fine-tuning with RL, the policy model is encouraged to explore better instance-specific trigger prompts, further improving performance.

## 4 Related work

Black-box large language modelsRecent years have witnessed the emergence of LLMs such as GPT-3 , Codex , InstructGPT, ChatGPT , PaLM , and LaMDA , which show significant promise in the field of NLP. These LLMs typically have a large number of parameters and require vast amounts of training data. Due to their scaling, these models have exhibited many emergent abilities, such as in-context learning, few-shot prompting, chain-of-thought prompting,

   No. & Category & Chain-of-Thought Trigger Prompt & MultiArith & AQuA \\ 
1 & Human-Designed & _Let’s think step by step._ & 79.6 & 31.9 \\
2 & & _We should think about this step by step._ & 81.2 & 28.7 \\
3 & & _First,_ & 78.0 & 38.2 \\
4 & & _Before we dive into the answer,_ & 54.8 & 27.2 \\
5 & & _Proof followed by the answer._ & 58.4 & 37.8 \\
6 & & _Let’s think step by step in a realistic way._ & 59.6 & 33.9 \\
7 & & _Let’s think step by step using common sense and knowledge._ & 80.0 & 34.3 \\
8 & & _Let’s think like a detective step by step._ & 73.6 & 24.0 \\
9 & & _Let’s think about this logically._ & 75.2 & 34.7 \\
10 & & _Let’s think step by step. First,_ & 78.8 & 32.3 \\
11 & & _Let’s think_ & 56.8 & 38.2 \\
12 & & _Let’s solve this problem by splitting it into steps._ & 72.4 & 33.2 \\
13 & & _The answer is after the proof._ & 42.8 & 34.3 \\
14 & & _Let’s be realistic and think step by step._ & 69.6 & 29.9 \\ 
15 & APE  & _Let’s work this out in a step by step way to be sure we have the right answer._ & 81.6 & 34.3 \\ 
16 & DSP w/ SFT & (*Generated instance-specific prompt) & 75.2 & 35.8 \\
17 & DSP w/ SFT+RL & (*Generated instance-specific prompt) & **84.0** & **38.6** \\   

Table 2: Zero-shot chain of thoughts reasoning accuracy (%) of text-davinci-002 with different prompts. *Our approach trains a policy model to generate instance-specific prompt triggers, which are compared to the task-specific prompts in .

and instruction following . However, most LLMs are not open-sourced and can only be accessed via black-box APIs, through which the users send prompt queries and receive responses. While there exist open-source LLMs such as OPT-175B  and Bloom , their local execution and fine-tuning require significant computational resources that may be infeasible for most researchers and users. However, despite their considerable performance on various tasks, LLMs often fall short of generating outputs that fully align with desired outputs on specific downstream tasks and use cases . Our approach seeks to address this limitation by introducing directional stimulus generated by a small tunable LM into the prompt to provide more fine-grained guidance and control over black-box LLMs.

Prompt optimization and engineeringEfficiently optimizing pre-trained LMs on downstream tasks by finding optimal prompts has been a focus of prior research. One approach involves tuning soft prompts, which are continuous embedding vectors that can be optimized using gradient descent methods . However, the requirements of gradients and the challenge of passing gradients and continuous prompts through black-box APIs, making them less practical for the black-box LLMs. Researchers have also tried to seek optimal prompts by designing task-specific natural language instructions and selecting proper training samples as in-context demonstrations in the prompt. These methods include manual engineering , editing , reinforcement learning , and automatic generation . Despite these efforts, such prompts are not always effective at steering LLMs to generate desired outputs, especially for fine-grained instance-specific behaviors that are difficult to describe using task-specific instructions and demonstration examples. To address this limitation, our approach is able to provide more **fine-grained instance-specific** guidance through the directional stimulus prompts (hints) generated by a small tunable policy model which could be optimized with supervised fine-tuning and reinforcement learning.

Controllable text generationThe control of language models (LMs) has been extensively studied. Early approaches fine-tuned LMs on datasets containing desired attributes .  proposed class-conditioned LMs, generating text with predefined control codes. However, direct LM training is costly. To address this, PPLM  trains an attribute model and passes gradients to control generation. GeDi  and DExperts  use class-conditional distributions as generative discriminators to guide generation, reducing computation complexity. These methods require either additional LM training or internal gradients and logistics, making them not applicable to black-box LLMs. Our approach proposes a solution to control black-box LLMs by inserting directional stimulus into the input query prompt and optimizing based on the return output.

Reinforcement learning for NLPReinforcement learning has been successfully applied to various NLP tasks, such as syntactic parsing , machine translation , summarization , conversational systems , etc. Language models define probability distributions over tokens in their vocabulary, and the text generation problem can be naturally formulated as selecting an action in an RL setting. Therefore, there have been extensive research efforts on optimizing LMs with RL, usually by aligning them with human preferences . For example, the LLM InstructGPT  is optimized with RL to better follow users' instructions and intent. In contrast with these works that directly update the LLMs to align with human preferences, our work optimizes a small policy model that generates text (stimulus) to guide LLMs to generate more human-preferred output instead of directly optimizing the LLMs, bypassing the inefficient LLM's optimization.

## 5 Conclusions and future work

In this paper, we introduce _Directional Stimulus Prompting_ (DSP), a new prompting framework to provide black-box LLMs with fine-grained and instance-specific guidance toward the desired outputs. We use a tunable policy model to generate the directional stimulus to provide such guidance and convert the optimization of black-box LLMs to that of the policy model. Experimental results demonstrate the effectiveness of our approach in controlling and guiding black-box LLMs via automatic prompt engineering and optimization. Furthermore, the generated stimulus provides valuable insights and interpretations of LLMs' behaviors. In this work, we use heuristically selected or annotated pseudo-stimulus data for supervised fine-tuning of the policy model. For future work, we hope to explore the possibility of using a "machine language" between the policy model and the LLMs that might not be intuitively preferred by humans but can better convey guidance information, as well as other forms of directional stimulus beyond text.