# Language models scale reliably with over-training and on downstream tasks

Anonymous Author(s)

Affiliation

Address

email

###### Abstract

Scaling laws are useful guides for derisking expensive training runs, as they predict performance of large models using cheaper, small-scale experiments. However, there remain gaps between current scaling studies and how language models are ultimately trained and evaluated. For instance, scaling is usually studied in the compute-optimal training regime (i.e., "Chinchilla optimal" regime). In contrast, models are often over-trained to reduce inference costs. Moreover, scaling laws mostly predict loss on next-token prediction, but models are usually compared on downstream task performance. To address both shortcomings, we create a testbed of 104 models with 0.011B to 6.9B parameters trained with various numbers of tokens on three data distributions. First, we fit scaling laws that extrapolate in both the amount of over-training and the number of model parameters. This enables us to predict the validation loss of a 1.4B parameter, 900B token run (i.e., 32\(\) over-trained) and a 6.9B parameter, 138B token run (i.e., a compute-optimal run)--each from experiments that take 300\(\) less compute. Second, we relate the perplexity of a language model to its downstream task performance by proposing a power law. We use this law to predict top-1 error averaged over downstream tasks for the two aforementioned models, using experiments that take 20\(\) less compute.

## 1 Introduction

Training large language models is expensive. Furthermore, training high-quality models requires a complex recipe of algorithmic techniques and training data. To reduce the cost of finding successful training recipes, researchers first evaluate ideas with small experiments and then extrapolate their efficacy to larger model and data regimes via scaling laws. With reliable extrapolation, it is possible to quickly iterate at small scale and still pick the method that will perform best for the final large training run. Indeed, this workflow has become commonplace for training state-of-the-art language models like Chinchilla 70B , PaLM 540B , GPT-4 , and many others.

Despite their importance for model development, published scaling laws differ from the goals of training state-of-the-art models in important ways. For instance, scaling studies usually focus on the compute-optimal training regime ("Chinchilla optimality" ), where model and dataset size are set to yield minimum loss for a given compute budget. However, this setting ignores inference costs. As larger models are more expensive at inference, it is now common practice to over-train smaller models . Another potential mismatch is that most scaling laws quantify model performance by perplexity in next-token prediction instead of accuracy on widely used benchmark datasets. However, practitioners usually turn to benchmark performance, not loss, to compare models.

In this paper, we conduct an extensive set of experiments to address both scaling in the over-trained regime and benchmark performance prediction.

Motivated by the practice of training beyond compute-optimality, we first investigate whether scaling follows reliable trends in the over-trained regime. We notice, as implied by Hoffmann et al. , for a set of models of different sizes trained with a constant ratio of tokens to parameters, models' reducible loss \(L^{}\)[43; 45] follows a power law (\(L^{}= C^{-}\)) in the amount of training compute \(C\). We find that as one increases the ratio of tokens to parameters, corresponding to more over-training, the scaling exponent \(\) remains about the same, while the scalar \(\) changes. We explain our observations by reparameterizing existing scaling laws in relation to the amount of over-training.

To establish empirically that scaling _extrapolates_ in the over-trained regime, we further experiment with a testbed of 104 models, trained from scratch on three different datasets: C4 [88; 27], RedPajama , and RefinedWeb . We find that scaling laws fit to small models can accurately predict the performance of larger models that undergo more over-training. Figure 1 (_left_) illustrates our main over-training result, where we invest \(2.4e19\) FLOPs to extrapolate the C4 validation performance of a 1.4B parameter model trained on 900B tokens, which requires \(300\) more compute to train.

In addition to over-training, we also investigate if scaling laws can predict the performance of a model on downstream tasks. We establish a power law relationship between language modeling perplexity and the average top-1 error on a suite of downstream tasks. While it can be difficult to predict the error on individual tasks, we find it possible to predict aggregate performance from a model's perplexity among models trained on the same training data. Figure 1 (_right_) presents our main downstream error prediction result, where we invest \(2.7e20\) FLOPs to predict the average top-1 error over a set of downstream tasks to within 1 percentage point for a 6.9B compute-optimal model, which requires \(20\) more compute to train.

Our results suggest that the proposed scaling laws are promising to derisk (i) the effects of over-training models and (ii) the downstream performance of scaling up training recipes. To facilitate further research on reliable scaling, we will release all experiments and models.

## 2 Developing scaling laws for over-training and downstream tasks

In this section, we develop scaling laws to predict over-trained and downstream performance. First, we provide key definitions (Section 2.1). We next present a scaling law for over-training drawing on empirical observation and prior work (Section 2.2). To connect loss scaling and downstream error prediction, we observe that average top-1 error decreases exponentially as a function of validation loss,

Figure 1: **Reliable scaling with over-training and on downstream error prediction. _(left)_ We fit a scaling law for model validation loss, parameterized by (i) a token multiplier \(M=N/D\), which is the ratio of training tokens \(D\) to parameters \(N\) and (ii) the compute \(C\) in FLOPs used to train a model, approximated by \(C=6ND\). Larger values of \(M\) specify more over-training. We are able to extrapolate, in both \(N\) and \(M\), the validation performance of models requiring more than \(300\) the training compute used to construct the scaling law. _(right)_ We also fit a scaling law to predict average downstream top-1 error as a function of validation loss. We find that fitting scaling laws for downstream error benefits from using more expensive models when compared to fitting for loss prediction. We predict the average error over 17 downstream tasks for models trained with over 20\(\) the compute. For this figure, we train all models on RedPajama .**

which we formalize as a novel scaling law (Section 2.3). In later sections, we build an experimental setup (Section 3) to quantify the extent to which our scaling laws extrapolate reliably (Section 4).

### Preliminaries

Scaling laws for loss.Typically, scaling laws predict model loss \(L\) as a function of the compute \(C\) in FLOPs used for training. If one increases the number of parameters \(N\) in a model or the number of tokens \(D\) that a model is trained on, compute requirements naturally increase. Hence, we assume \(C\) is a function of \(N,D\). Following Kaplan et al. , we use the approximation \(C=6ND\), which Hoffmann et al.  independently verify. We consider,

\[L(C)=E+L^{}(C),\] (1)

where \(E\) is an _irreducible loss_ and \(L^{}\) is the _reducible loss_. \(E\) captures the Bayes error or minimum possible loss achievable on the validation domain. The \(L^{}(C)\) term captures what can possibly be learned about the validation domain by training on a source domain. \(L^{}(C)\) should approach zero with increased training data and model capacity. \(L^{}(C)\) is often assumed to follow a power law: \(L^{}(C)= C^{-}\) (i.a., Hestness et al. , OpenAI ). It is also often helpful to consider a power law in a \(\)-\(\) plot, where it appears as a line with slope \(-\) and \(y\)-intercept \(()\).

Token multipliers.We define a token multiplier \(M=D/N\) as the ratio of training tokens to model parameters for notational convenience. \(M\) allows us to consider fixed relationships between \(D\) and \(N\) even as a model gets bigger (i.e., as \(N\) becomes larger).

Compute-optimal training.Hoffmann et al.  establish compute-optimal training, where, for any compute budget \(H\), the allocation of parameters and tokens is given by,

\[_{N,D}L(N,D)C(N,D)=H.\] (2)

To solve for the optimal \(N^{*},D^{*}\), one can sweep \(N,D\) for each compute budget, retaining the best configurations. Hoffmann et al.  find that as the compute budget increases, \(N^{*}\) and \(D^{*}\) scale roughly evenly. Assuming equal scaling, there is a fixed compute-optimal token multiplier \(M^{*}=D^{*}/N^{*}\) per training distribution.

Over-training.We define over-training as the practice of allocating compute sub-optimally, so smaller models train on a disproportionately large number of tokens (i.e., \(M>M^{*}\)). While loss should be higher than in the compute-optimal allocation for a given training budget, the resulting models have fewer parameters and thus incur less inference cost.

### Scaling laws for over-training

To propose a scaling law for over-trained models, we first turn to empirical observation. We train four model configurations with parameter counts between 0.011B and 0.411B for token multipliers

Figure 2: **Scaling in the over-trained regime follows consistent power law exponents. We notice parallel lines in the \(\)-\(\) plots of reducible loss vs. training compute for a range of token multipliers \(M\), which give the ratio of training tokens to model parameters. Larger \(M\) corresponds to more over-training. For a power law giving reducible loss as a function of compute: \(L^{}(C)= C^{-}\), the exponent \(\) remains relatively constant resulting in lines with approximately fixed slope (Figure 17). The scalar \(\) that determines the \(y\)-intercept, however, shifts with different token multipliers. This suggests \(\) is a function of the token multiplier, while \(\) is not.**

between 20 and 640, where \(M=20\) points lie roughly on the compute-optimal frontier, and larger \(M\) corresponds to more over-training. We defer experimental details to Section 3 to focus on our observations first. In Figure 2, we show loss against compute in a \(\)-\(\) plot for the models trained on three datasets and evaluated on the C4 eval set. We notice parallel lines when fitting power laws to the reducible loss, which suggests a near-constant scaling exponent even with increased over-training. This indicates that scaling behavior should be describable in the amount of over-training.

In search of an analytic expression for the observations in Figure 2, we consider existing scaling literature. A common functional form for the risk of a model, as proposed in prior work  is,

\[L(N,D)=E+AN^{-}+BD^{-}.\] (3)

Recall from Section 2.1, \(N\) is the number of parameters and \(D\) the number of training tokens. The constants \(E,A,,B,\) are fit from data. By fitting this parametric form, Hoffmann et al.  find that scaling exponents \(\) and \(\) are roughly equal, suggesting that one should scale \(N\) and \(D\) equally as compute increases. Hence, we assume \(=\). With this assumption, we reparameterize Equation (3) in terms of compute \(C=6ND\) and a token multiplier \(M=D/N\). We get,

\[L(C,M)=E+(aM^{}+bM^{-})C^{-},\] (4)

where \(=/2\), \(a=A(1/6)^{-}\), \(b=B(1/6)^{-}\) gives the relation to Equation (3). For a complete derivation, see Appendix A.

Equation (4) has the following interpretation: (i) The scaling exponent \(\) is not dependent on \(M\). Thus, we always expect lines with the same slope in the \(\)-\(\) plot--as in Figure 2. (ii) The term \(aM^{}+bM^{-}\) determines the offsets between curves with different token multipliers. Hence, we expect non-overlapping, parallel lines in the \(\)-\(\) plot for the range of \(M\) we consider--also consistent with Figure 2.

Recall that we make the assumption \(=\), which implies equal scaling of parameters and tokens as more compute is available. However, as explained in Appendix A, even if \(\), we get a parameterization that implies the power-law exponent remains constant with over-training.

### Scaling laws for downstream error

Scaling is typically studied in the context of loss , which Schaeffer et al.  note is smoother than metrics like accuracy. However, practitioners often use downstream benchmark accuracy as a proxy for model quality and not loss on perplexity evaluation sets. To better connect scaling laws and over-training to task prediction, we revisit the suite of models plotted in Figure 2. In Figure 3, we plot average downstream top-1 errors over evaluations sourced from LLM-Foundry  against the C4 eval loss. We defer details of the setup to Section 3 to focus here on a key observation: average error appears to follow exponential decay as loss decreases.

Based on the exponential decay we observe in Figure 3, we propose the following relationship between downstream average top-1 error \(\) and loss \(L\),

\[(L)=-k,\] (5)

Figure 3: **Average top-1 error scales as a function of loss.** We plot models trained on three datasets and notice an exponential decay of average top-1 error as C4 eval loss, on the x-axis, decreases. We consider on the y-axes average error on 17 evaluations where performance is at least 10 points above random chance for at least one 0.154B scale model. These observations suggest that average top-1 error should be predictable with reliable loss estimates.

where \(,k,\) are fit from data. Equation (5) also has an interpretation in terms of model perplexity \((L)=\),

\[()=-k^{-}.\] (6)

Namely, \(\) follows a power law in \(\) that is bounded from above by \(\) signifying arbitrarily high error and from below by \(-k(- E)\), where \(E\) is the Bayes error from Equation (4).

Equation (5) in conjunction with Equation (4) suggests a three-step method to predict \(\) as a function of compute and the amount of over-training. For choices of training and validation distributions, (i) fit a scaling law to Equation (4) using triplets of compute \(C\), token multiplier \(M\), and measured loss \(L\) on a validation set to yield \((C,M) L\). (ii) Fit a scaling law to Equation (5) using pairs of loss \(L\) and downstream error \(\) for models to get \(L\). (iii) Chain predictions to get \((C,M)\).

## 3 Constructing a scaling testbed

In this section, we discuss our experimental setup to test the predictions suggested by Equations (4) and (5). We first present our general language modeling setup (Section 3.1). Next, we discuss our strategy for determining model configurations for our scaling investigation (Section 3.2) and fitting scaling laws (Section 3.3). We then present metrics to validate how well scaling laws predict loss and downstream performance (Section 3.4).

### Training setup

We train transformers  for next token prediction, based on architectures like GPT-2  and LLaMA . We employ GPT-NeoX  as a standardized tokenizer for all data. See Appendix B for architecture, optimization, and hyperparameter details.

### Model configurations

To get final configurations for the 0.011B to 0.411B parameter models plotted in Figures 2 and 3, we first conduct a wide grid search over a total of 435 models, trained from scratch, from 0.01B to 0.5B parameters (Figure 4_(left)_). We train on the original OpenLM data mix , which largely consists of RedPajama  and The Pile . While we eventually plan to over-train models, at this step we search for _base configurations_ near compute-optimality. We train on 20 tokens per parameter (\(M=20\)), which, in early experiments, gives models near the compute-optimal frontier. This is similar to findings in Hoffmann et al. 's Table 3, which suggests that \(M=20\) is near-optimal for the Chinchilla experimental setup.

Figure 4: **Search, filter, fit: A recipe for selecting configurations for scaling.**_(left)_ To generate the final configurations presented in Table 3, we run a 435 model grid search over model width, hidden dimension, number of attention heads, batch size, and warmup steps. All models are trained near compute-optimally. _(center)_ We plot the efficient frontier of models, which appear to follow a trend, excluding models from \(5.2 10^{16}\) to \(5.2 10^{17}\), which fall below the trend. _(right)_ We fit a power law with irreducible error to the remaining configurations, picking four configurations that closely track the full model suite (“Selected models”). These models extrapolate the performance of 1.4B, 6.9B target models. Shaded regions represent bootstrap 95% confidence intervals.**

To find maximally performant small-scale models on validation data, we tune model width, number of layers, number of attention heads, warmup steps, and batch size. Our validation set, OpenLM eval, contains tokens from recent arXiv papers, the OpenLM codebase itself, and news articles. We find in early experiments that qk-LayerNorm makes models less sensitive to learning rate, which is a phenomenon Wortsman et al.  report in their Figure 1. Hence, we fix the learning rate (\(3e\)-\(3\)) for our sweeps. We also perform smaller grid searches over 1.4B and 6.9B parameter model configurations at \(M=20\), retaining the best configurations.

At this point, we have many models, several of which give poor performance; following prior work [51; 45], we want to keep only models that give best performance. Hence, in Figure 4_(center)_, we filter out models that do not lie on the Pareto frontier. While there appears to be a general trend, configurations between \(5.2 10^{16}\) and \(5.2 10^{17}\) FLOPs lie below the frontier established by other models. We hypothesize these models over-perform as they are trained for more optimization steps than their neighbors based on our power-of-two batch sizes. We provide support for this hypothesis in Appendix E, but opt to remove these models from our investigation.

To ensure tractable compute requirements for our scaling experiments, we require a subset of models that follows the trend of the entire Pareto frontier. In Figure 4_(right)_, we fit trends to the Pareto models and to a subset of four models. We notice that the trends closely predict both the performance of the 1.4B and 6.9B models, suggesting that our small-scale configurations reliably extrapolate in the compute-optimal setting.

Moving forward, we do not tune hyperparameters for other token multipliers (i.e., \(M 20\)), on other training or evaluation distributions, or on validation sets for downstream tasks. For more details including specific hyperparameters, see Appendix C.

To create our scaling testbed, we start with the four small-scale, base configurations from our grid search: \(N\{0.011,0.079,0.154,0.411\}\). To ensure our conclusions are not particular to a single training distribution, we train models on each of C4 [88; 27], RedPajama , and RefinedWeb , which have 138B, 1.15T, and 600B tokens, respectively, for different token multipliers \(M\{5,10,20,40,80,160,320,640\}\). We omit runs that require more tokens than are present in a dataset (i.e., \(N=0.411,M=640\) for C4). We additionally train \(N=1.4\) models at \(M=20\) and at the largest token multiplier possible without repeating tokens (i.e., 80 for C4, 640 for RedPajama, and 320 for RefinedWeb). We train \(N=6.9,M=20\) models on each dataset given the relevance of 7B parameter models [113; 49]. In total this results in a testbed of 104 models.

### Fitting scaling laws

We fit Equation (4) to approximate \(E,a,b,\) using curve-fitting in SciPy  (i.e., Levenberg-Marquardt to minimize non-linear least squares). We repeat this process to fit Equation (5) to approximate \(,k,\). We invest \(\)100 A100 hours to train the models required to fit a scaling law for loss and \(\)1,000 A100 hours for a corresponding law for downstream error. Unless otherwise specified, we fit to the \(N,M\) pairs in Table 1, which are a subset of our full testbed. Our configurations allow us to test for extrapolation to the \(N=1.4,M=640\) (900B token) and the \(N=6.9,M=20\) (138B token) regimes.

   \(N\) & \(M\) & Used to fit Equation (4) & Used to fit Equation (5) \\ 
0.011B & 20 & ✓ & ✓ \\
0.079B & 20 & ✓ & ✓ \\
0.154B & 20 & ✓ & ✓ \\
0.411B & 20 & ✓ & ✓ \\
0.011B & 320 & ✓ & ✓ \\
1.4B & 20 & ✗ & ✓ \\  Total compute \(C\) [FLOPs] & 2.4\(e\)19 & 2.7\(e\)20 \\   

Table 1: **Default number of parameters \(N\) and token multiplier \(M\) to fit our scaling laws. We invest \(\)100 A100 hours to fit Equation (4) and \(\)1,000 A100 hours to fit Equation (5).**

### Evaluation setup

Evaluation datasets.Unless otherwise stated, our default validation loss dataset is C4 eval. For downstream tasks, we adopt a subset from 46 tasks from LLM-foundry , which includes standard tasks with both zero-shot and few-shot evaluations. Specifically, we consider a 17-task subset where, for each evaluation, at least one 0.154B scale model--trained with as many as 99B tokens--gets 10 percentage points above chance accuracy: ARC-Easy , BIG-bench: CS algorithms , BIG-bench: Dyck languages , BIG-bench: Novel Concepts , BIG-bench: Operators , BIG-bench: QA WikiData , BoolQ , Commonsense QA , COPA , CoQA , HellaSwag (zero-shot) , HellaSwag (10-shot) , LAMBADA , PIQA , PubMed QA Labeled , SQuAD , and Winogrand . For more details on evaluation datasets see Appendix D. We focus on this subset to ensure we are measuring signal, not noise. Including downstream tasks like MMLU , where performance is close to random chance, however, does not invalidate our results as we show in our evaluation set ablations (Appendix E).

Metrics.We consider three main metrics: _Validation loss_, which is the cross entropy between a model's output and the one-hot ground truth token, averaged over all tokens in a sequence and over all sequences in a dataset. _Average top-1 error_, which is a uniform average over the 17 downstream evaluations, as mentioned in the above paragraph. To measure how good a prediction \((C,M)\) is, we measure _Relative prediction error_: \(|(C,M)-_{GT}|/_{GT}\), where \(\) is the predicted loss \(L\) or the average top-1 error \(\). \(_{GT}\) is the ground truth measurement to predict.

## 4 Results: Reliable extrapolation

In this Section, we quantify the extent to which the scaling laws developed in Section 2 extrapolate larger model performance using the scaling testbed from Section 3. By default, we fit Equations (4) and (5) to the configurations in Table 1, use C4 eval for loss, and the 17-task split from Section 3.4 for average top-1 error.

Over-trained performance is predictable.We highlight our main over-training results in Figure 1_(left)_. Namely, we are able to extrapolate both in the number of parameters \(N\) and the token multiplier \(M\) to closely predict the C4 eval performance of a 1.4B parameter model trained on 900B RedPajama tokens (\(N=1.4,M=640\)). Our prediction, which takes 300\(\) less compute to construct than the final 1.4B run, is accurate to within 0.7% relative error. Additionally, for the \(N=6.9,M=20\) run, near compute-optimal, the relative error is also 0.7%.

These results support several key takeaways. (i) Scaling can be predictable even when one increases both the model size and the amount of over-training compared to the training runs used to fit a scaling law. (ii) The form presented in Equation (4) is useful in practice for predicting over-trained scaling behavior. (iii) Fitting to Equation (4) gives good prediction accuracy near compute-optimal. More

Figure 5: **Relative error on C4 eval for different training distributions. Boxes highlighted in yellow correspond to pairs—number of parameters \(N\), token multiplier \(M-\)used to fit Equation (4). Larger values of \(M\) correspond to more over-training. The prediction error is low in both interpolation and extrapolation ranges. Below \(N=1.4\), empty squares correspond to runs that were not possible due to the limited dataset size for single epoch training. At \(N=1.4\) we run at \(M=20\) and at the largest possible multiplier. At \(N=6.9\), we run at \(M=20\).**

[MISSING_PAGE_FAIL:8]

and \(D C^{ 0.5}\)) to realize compute-optimality. Appendix C of the Chinchilla paper additionally suggests that these findings hold across three datasets. However, Hoffmann et al.  do not verify their scaling laws for training beyond compute-optimality, or for downstream error prediction--both of which are central to our work.

Sardana & Frankle  propose modifications to the Chinchilla formulation to incorporate inference costs into the definition of compute-optimality and solve for various fixed inference budgets. Their key finding, which is critical for our work, is that when taking into account a large enough inference budget, it is optimal to train smaller models for longer than the original Chinchilla recommendations. Our work presupposes that over-training can be beneficial. Instead of solving for inference-optimal schemes, we support empirically a predictive theory of scaling in the over-trained regime. Additionally, we provide experiments across many validation and training sets.

For predicting downstream scaling beyond loss, Isik et al.  relate the number of pre-training tokens to downstream cross-entropy and machine translation BLEU score  after fine-tuning. In contrast, we take a holistic approach to evaluation by looking at top-1 error over many natural language tasks. Schaeffer et al.  argue that emergent abilities  are a product of non-linear metrics and propose smoother alternatives. As a warmup for why non-linear metrics may be hard to predict, Schaeffer et al.  consider predicting an \(\) length sequence exactly: \((N,) 1-(N)^{-}\), where \(N\) is the number of parameters in a model and \(\) is its perplexity. This is a special case of our Equations (5) and (6), where the number of training tokens does not appear, \(=1,k=1\), and \(=\). In contrast, we treat \(,k,\) as free parameters for a scaling law fit, finding that average error over downstream tasks can make for a predictable metric.

Over-training in popular models.There has been a rise in over-trained models [113; 114] and accompanying massive datasets [112; 82; 104; 3]. For example, Chinchilla 70B  is trained with a token multiplier of 20, while LLaMA-27B  uses a token multiplier of 290. In our investigation, we look at token multipliers from 5 to 640 to ensure coverage of popular models and relevance for future models that may be trained on even more tokens.

## 6 Limitations, future work, and conclusion

Limitations and future work.We identify limitations, which provide motivation for future work.

* **Hyperparameters.** While our configurations are surprisingly amenable to reliable scaling across many training and testing distributions without further tuning, there is a need to develop scaling laws that do not require extensive hyperparameter sweeps.
* **Scaling up.** Validating the trends in this paper for even larger runs is a valuable direction. Additionally, repeating our setup for models that achieve non-trivial performance on harder evaluations like MMLU is left to future work.
* **Scaling down.** Actualizing predictable scaling with even cheaper runs is important to make this area of research more accessible, especially for downstream error prediction.
* **Failure cases.** While we present a preliminary analysis of when scaling is unreliable, future work should investigate conditions under which scaling breaks down.
* **Post-training.** It is common to employ fine-tuning interventions after pre-training, which we do not consider. Quantifying to what degree over-training the base model provides benefits _after_ post-training is an open area of research.
* **Individual downstream task prediction.** While we find that averaging over many task error metrics can make for a predictable metric, per-task predictions are left to future work.
* **In-the-wild performance.** Downstream task performance is a proxy for the in-the-wild user experience. Analyzing scaling trends in the context of this experience is timely.
* **Dataset curation.** Our work only deals with existing training datasets. Exploring dataset curation for improved model scaling is another promising direction.

Conclusion.We show that the loss of over-trained models, trained past compute-optimality, is predictable. Furthermore, we propose and validate a scaling law relating loss to average downstream task performance. We hope our work will inspire others to further examine the relationship between model training and downstream generalization. Our testbed will be made publicly available, and we hope it will make scaling research more accessible to researchers and practitioners alike.