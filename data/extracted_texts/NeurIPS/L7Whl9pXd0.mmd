# Efficient Batched Algorithm for Contextual Linear Bandits with Large Action Space via Soft Elimination

Efficient Batched Algorithm for Contextual Linear Bandits with Large Action Space via Soft Elimination

 Osama A. Hanna

University of California, Los Angeles

ohanna@ucla.edu

&Lin F. Yang

University of California, Los Angeles

linyang@ucla.edu

&Christina Fragouli

University of California, Los Angeles

christina.fragouli@ucla.edu

###### Abstract

In this paper, we provide the first efficient batched algorithm for contextual linear bandits with large action spaces. Unlike existing batched algorithms that rely on action elimination, which are not implementable for large action sets, our algorithm only uses a linear optimization oracle over the action set to design the policy. The proposed algorithm achieves a regret upper bound \(()\) with high probability, and uses \(O( T)\) batches, matching the lower bound on the number of batches . When specialized to linear bandits, our algorithm can achieve a high probability gap-dependent regret bound of \((1/_{})\) with the optimal \( T\) number of batches, where \(_{}\) is the minimum reward gap between a suboptimal arm and the optimal. Our result is achieved via a novel soft elimination approach, that entails "shaping" the action sets at each batch so that we can efficiently identify (near) optimal actions.

## 1 Introduction

In contextual linear bandits, a learner interacts with an environment over \(T\) rounds: in each round \(t\) the learner observes a (possibly different due to context change) set of actions \(_{t}^{d}\), plays one of them, and receives a reward that follows a noisy linear function parametrized by an unknown vector in \(^{d}\). The objective of the learner is to minimize regret - how much reward it loses over the \(T\) rounds by not always playing the "highest reward" (optimal) action. To achieve this, the learner at each round updates its policy (its method to select what action to play) based on what it has learned from all past actions played and rewards observed. Linear bandits form the special case where the action set is always the same, i.e., \(_{t}=\) for all rounds \(t\). Contextual linear and linear bandits have been widely investigated due to their significance in both theory and practice (eg., see ).

**Batched Setting.** In numerous real-world use cases, the learner may be restricted to change the policy a limited (small) number of times.This constraint may stem from factors such as computation or communication considerations, or may be imposed by the nature of the application, as is the case in multi-stage clinical trials or online marketing campaigns with high response rates, where it is not feasible to update the policy after each response. Similarly, the use of crowdsourcing platforms or the need to conduct time-consuming simulations in reinforcement learning may require policies with limited adaptivity. As a result, there has been significant interest in designing algorithms that can achieve the optimal regret with limited policy switches . This setup is known as the batched contextual linear bandit problem: the \(T\) rounds are partitioned into batches, and the learner can collect rewards and update the action selection policy only at the end of each batch.

**Large Action Space.** Contextual linear bandit applications frequently need to explore an extremely large (even continuous) set of actions, e.g., millions of products to be recommended. As other examples, in the classical bandit problem of clinical trials, each decision involves selecting a treatment option from a potentially infinite set of mixed treatments . In manufacturing problems, the goal is often to maximize revenue by selecting from a very large set of decisions, with the revenue associated with each decision being unknown . Additionally, in applications where actions correspond to images in a database or high-dimensional embeddings of complex documents like webpages, the set of actions can be vast . As a result, there is a strong interest in algorithms that can be efficiently implemented when the action space is large or infinite .

While computationally-efficient batched algorithms exist for contextual linear bandits with small action sets, and efficient ones that are not batched exist for contextual linear bandits with large action sets, to date, _there are no efficient batched algorithms_ that can handle large action spaces. Existing batched algorithms for contextual linear bandits  rely on _action elimination_ that requires a linear scan of the action set; while efficient non-batched algorithms for large action spaces do not extend to the batched setting  (see related work in the following for more details).

Our Contributions.In this paper, we provide the first efficient batched algorithm for contextual linear bandits with nearly optimal regret upper bound of \((d^{3/2})\) with high probability, while using \(O( T)\) batches, which matches the lower bound on the number of batches required to achieve \(\)-type regret bounds . For linear bandits, our algorithm can attain a high probability gap-dependent regret bound of \((d^{3}/_{})\) with the optimal \( T\) number of batches , where \(_{}\) represents the minimum reward gap between a suboptimal arm and the optimal.

Our algorithm for linear bandits, that we term SoftBatch, builds on a form of "soft elimination". Our observation is that, a good algorithm should be able to approximate the gap \((a)\) between each action \(a\) and the optimal one with \(O((a))\) accuracy; and if we can do that, then we can use this knowledge to limit the number of times we play suboptimal actions, as well as use this knowledge to select which actions we want to play at all. As essentially all batched algorithms do, at each batch we select and play (a small number of) actions that enable to estimate well the unknown parameter vector without incurring large regret. In particular, for each batch, we choose a set of well-behaved basis actions (e.g., a barycentric spanner ), established by calling an optimization oracle polynomial times. However, instead of selecting at batch \(m\), vectors from the "true" action set \(\), we consider virtual "weighted" sets \(}_{m}\), where each action's magnitude is weighted inversely proportional to the estimated gap \((a)\), and select vectors guided by these weighted action sets. Then we play each basis action \(a\) a number of times inversely proportional to the square of the estimated gap \((a)\) to preserve small regret. This in return provides us an accurate estimator for the optimal parameter by the benign properties of the basis actions. Thus our approach implements a form of soft elimination (shaping) of the action set, where the actions closest to the optimal become increasingly dominant. A crucial part in our design is that we never actually calculate the gaps \((a)\) for all actions \(a\) (only for the basis actions). The exploration policy we propose uses solely a linear optimization oracle applied to the original action set.

Our contextual bandit algorithm utilizes a recent reduction technique  to transform the problem into a linear bandit problem. We incorporate the reduction into our batched linear bandit algorithm, by constructing an efficient linear optimization oracle for the exponentially large action set in the reduced problem using a linear optimization oracle for the original action sets (contexts).

Our proof techniques may be of independent interest. We develop a novel approach to bound regret in linear bandits, we design an efficient exploration policy using inverse squared gap weighting, and a simple method to handle the case where the action set does not span \(^{d}\), where \(d\) is the problem dimension. Our approach avoids the necessity of imposing assumptions, such as the one in , which entails having a subset of \(d\) actions forming a matrix with determinant at least \(r^{d}\) for a constant \(r\). These assumptions can be strong, particularly when dealing with changing action sets, and may not hold after modifying the action set, for instance, by eliminating or weighting actions.

**Related Work.** Contextual linear and linear bandits have had significant impact both in theory and practice ). The best performing algorithms achieve a regret bound \((d)\)1, matching the regret lower bound \((d)\). The same algorithms achieve anearly optimal regret upper bound \((}{_{}})\) if the minimum gap of suboptimal arms is lower bounded by \(_{}\). However, the resulting policies require updates at every time step and involve solving a non-convex optimization problem, which is not practical for large action spaces [33; 11].

**Batched algorithms.** Existing batched algorithms for contextual linear bandits [32; 16; 18] have achieved nearly optimal regret upper bounds of \((d)\). However, these algorithms rely on action elimination, which involves either performing a linear scan on the action set or solving an optimization problem over the non-convex set of good (not eliminated) actions to design and implement the policy at each time step. Similarly, batched algorithms for linear bandits [25; 12] also rely on action elimination. Although, unlike contextual bandits, the elimination constraint in linear bandits can be linear, which can be exploited to efficiently compute the policy (under certain assumptions) , resulting in an \((d^{3/2})\) regret upper bound, it requires solving an optimization problem over the action set with an elimination constraint. This can be much harder than solving the optimization problem over the action set without additional constraints for some sets, such as the non-convex set resulting from the reduction of contextual to linear bandits .

**Efficient algorithms for large action spaces.** There is a long line of work on efficient algorithms for linear bandits that only rely on a linear optimization oracle over the action set [7; 11; 9; 19; 20]. However, these algorithms cannot be extended to the batched setting without extra assumptions on the action set, and more importantly, they do not extend to the batched contextual setting. Existing efficient algorithms for contextual linear bandits [6; 41; 11] can achieve \((d^{3/2})\) regret bound, but it remains unclear if they can be extended to the batched setting, particularly given the challenge posed by changing action sets. Another line of work attempts to design efficient algorithms using hashing-based methods to approximate the maximum inner product [39; 22], but these methods result in complexity that is sublinear but still polynomial in the number of actions.

Table 2 in App. A summarizes how our results position w.r.t. related work.

## 2 Model and Notation

Notation.We use \([n]\) for a natural number \(n\) to denote the set \(\{1,,n\}\); \((E)\), for an event \(E\), to denote the indicator function which returns \(1\) if \(E\) holds and \(0\) otherwise; \(_{r}=\{a^{d}|\|a\|_{2} r\}\) to denote the ball of center \(0\) and radius \(r\); \(_{r}=\{a^{d}|\|a\|_{2}=r\}\) to denote the sphere of center \(0\) and radius \(r\); and \(\|a\|_{}=a}\) to denote the matrix norm of a vector \(a^{d}\) with respect to a positive semi-definite matrix \(\). Table 1 in App. A summarizes our notation.

Contextual Linear Bandits.We consider a contextual linear bandit problem over an horizon of length \(T\), where at each round \(t[T]\), the learner receives a set of actions \(_{t}^{d}\) sampled from an unknown distribution \(\) independently from other rounds. The learner plays an action \(a_{t}_{t}\) and receives a reward \(r_{t}= a_{t},_{}+_{t}\), where \(_{}\) is an unknown system parameter vector with \(_{}^{d}\), and \(_{t}\) is noise that is zero mean conditioned on the filtration of historic information \((_{1},a_{1},r_{1},,_{t},a_{t})\). The learner adopts a **policy** that maps the history \((_{1},a_{1},r_{1},,_{t})\) to a distribution over the action set \(_{t}\), with the objective of minimizing the pseudo regret defined as

\[R_{T}=_{t=1}^{T}_{a_{t}} a-a_{t},_{}.\] (1)

For simplicity, we assume that \(_{t}\) is compact for all \(t[T]\) almost surely, which ensures the existence of an action \(a_{}_{t}\) that attains the supremum \(_{a_{t}} a,\). Non-compact sets can be handled using sufficiently small approximations. We also adopt the following standard assumption .

**Assumption 1**.: _(Boundedness.) \(_{}_{1}\), \(_{t}_{1}\), and \(|r_{t}| 1\) almost surely \( t[T]\)._

**Linear Bandits.** Changing the action set over time enables to model contextual information. If the action space is fixed, namely, \(_{t}=\) for for all \(t[T]\), the problem is known as Linear Bandits. For Linear Bandits, we denote an optimal action by \(a^{}=_{a} a,_{}\) and define the gap \(_{a}= a^{}-a,_{}\) for all actions \(a\).

**Batched Setting.** In a batched setting, the learner is only allowed to change the policy at \(M\) pre-chosen rounds, where \(M\) is the number of batches. Batch \(m\) includes \(T_{m}\) rounds, \(m[M]\), with \(_{m=1}^{M}T_{m}=T\). In each batch, the learner adopts a policy \(\) that takes as input the action set \(_{t}\) along with all the previous history except for rewards observed in the current batch, and outputs a distribution over the action set \(_{t}\). In particular, the rewards of the actions pulled in the current batch are utilized solely to update the policy at the end of the batch.

**Regularized least squares.** Let \(\{a_{i},r_{i}\}_{i=1}^{n}\) be a sequence of \(n\) pulled actions and observed rewards over \(n\) rounds. The regularized least squares estimate \(\) of \(_{}\) based on this action-reward sequence can be calculated as

\[=^{-1}_{i=1}^{n}r_{i}a_{i},\] (2)

where \(=+_{i=1}^{n}a_{i}a_{i}^{}\), and \(\) is the regularization parameter.

Goal.Our goal is to design efficient batched algorithms for Contextual Linear and Linear Bandits with large (even infinite) action spaces that achieve (nearly) optimal regret.

We will do so by making use of the linear optimization oracles defined next.

**Definition 1**.: A **linear optimization oracle** for a set \(\) is a function \((;.)\) which takes as input \(_{1}\) and outputs \((;)\) with \((;),=_{a}  a,\). An **approximate linear optimization oracle with additive error** at most \(\) for the set \(\) is a function \(_{t}^{+}(;.):_{1}\) that satisfies \(_{t}^{+}(;),_{a } a,-,\ _{1}\). An **approximate linear optimization oracle with multiplicative error**\(0<<1\) for the set \(\) is a function \(_{}^{}(;.):_{1}\) that satisfies \(_{}^{}(;),(1 -)_{a} a,,\ _{1}\).

**Assumption 2**.: _(Linear optimization oracle.) We assume that we can access a linear optimization oracle \((_{t};.)\) for each set of actions \(_{t}\) with running time at most \(_{}\) and space complexity \(_{}\)._

We note that assuming a linear optimization oracle over \(_{t}\) is natural [7; 11; 9; 19; 20; 41] since even if the learner perfectly learns the unknown parameter vector \(_{}\), the learner still needs to solve \(_{a_{t}} a,_{}\) to minimize the regret in (1).

## 3 Efficient Soft Elimination Algorithm for Linear Bandits

In this section we propose and analyze an algorithm (which we call SoftBach and describe in Algorithm 1) for linear bandits, that is, when \(_{t}=\).

### Main Result

The following two theorems, proved in App. D and E, respectively, formally state that Algorithm 1 achieves (nearly) optimal regret using \(M= T+1\) batches with sample and time complexities polynomial in \(d\) and linear in \(T\). We provide the algorithm description in Section 3.2 and a proof outline in Section 3.3.

**Theorem 1**.: _Consider a linear bandit instance with action set \(^{d}\) and horizon \(T\). There exists a universal constant \(C\) and a choice for the batch lengths such that Algorithm 1 finishes in at most \(M= T+1\) batches with regret bounded as_

\[R_{T} C T1-,\] (3)

_where \(=8d((1/)+ T)}\), \(C_{L}=e^{8}d\) and \(\) is a parameter. Moreover, if \( a\) with \(_{a}>0\) we have \(_{a}_{}\), then there exists a choice of batch lengths so that Algorithm 1 finishes in at most \(M=_{4}T\) batches with regret bounded as_

\[R_{T} C}{_{}} T1-.\] (4)

Our regret bounds achieve nearly optimal dependency on \(T\), and match the best known regret bounds of \((d^{3/2})\) for (unbatched) efficient contextual linear bandit algorithms [6; 41; 11], while losing a \(\) factor when compared to the \((d)\) lower bound . This extra \(\) factor is due to relying on the best known method to design a notion of spanner of the set of actions (as we explain in section 3.2) with radius \(}=O()\) using linear optimization oracles. Any future improvement that reduces the radius from \(O()\) to \(O(1)\) will immediately result in nearly optimal regret bounds for Algorithm 1. The following result upper bounds the time and space complexity.

**Theorem 2**.: _Algorithm 1 finishes in \((Td^{2}+d^{4}M+_{}d^{3}M)\) runtime and uses \((d^{2}+_{})\) memory, where \(_{},_{}\) are the time and space complexity of the linear optimization oracle._

We observe that unlike algorithms that require a linear scan on the action set, our space and time complexities are polynomial in the parameters \(d\), \(T\), and \(_{}\).

### SoftBatch (Algorithm 1) Description

**Intuition.** The main intuition behind SoftBatch is that, we do not need to necessarily eliminate suboptimal actions; it suffices to be able to select and play a small set of unique actions \(_{m}\) in each batch \(m\), that allows to estimate increasingly well the parameter vector \(_{*}\) and the best action \(a^{}\) while playing suboptimal actions for a small number of times. Our algorithm proposes a novel way to select such sets \(_{m}\) efficiently, through a form of "action set shaping" that we will describe in this section. Additionally, to learn \(_{*}\) while achieving a (nearly) optimal regret, SoftBatch plays each action \(a_{m}\) a number of times \( 1/_{a}^{2}\), where \(_{a}= a_{*}-a,_{*}\) is the gap for action \(a\) (i.e., we play the suboptimal actions in \(_{m}\) for a small number of times so as not to accumulate regret). SoftBatch enables to estimate the gap \(_{a}\) within a constant factor for any action \(a\) (yet only does so for a limited number of actions in each batch), and essentially uses the gaps \(_{a}\) as a guide on which actions to play and for how many rounds each.

**Steps.** SoftBatch (Algorithm 1) takes as input the action set \(^{d}\), the horizon \(T\), the number of batches \(M\), and the batch lengths \(\{T_{m}\}_{m=1}^{M}\), and operates as follows2.

In batch \(m\), the algorithm starts with a current estimate of the parameter vector \(_{*}\), which we call \(_{m}\), and an estimate of the optimal action \(a^{}\) which we call \(a_{m}^{}\); note that given these, we are able to estimate for any action \(a\) the gap \(_{m}(a)= a_{m}^{}-a,_{m}\) (but we will only do so for the actions the algorithm actually plays). The algorithm then calls LWS, a Linear Weighted Spanner subroutine (described in Algorithm 2), that it feeds with an augmented action space \(^{}=_{1/T}\) for reasons we will explain later. LWS selects \(d\) actions \(_{m}=\{a_{1},,a_{d}\}\) to play in batch \(m\) (note that some of these may belong to \(_{1/T}\) and will in this case not be played). Each of these \(d\) actions \(a_{i}\) is pulled \(n_{m}(i)(a_{i})^{2}}\) times, where \((.)\) is a uniform exploration distribution with value \(1/d\) for all the \(d\) actions. We show in the proof of Theorem 1 that \(_{i=1}^{d}n_{m}(i) T_{m}\), \( m[M]\), with high probability. To guarantee that the length of the batch is \(T_{m}\), the algorithm pulls \(a_{m}^{}\) for the remaining rounds, if needed. At the end of the batch, the algorithm updates its estimate \(_{m+1}\) of the unknown parameter vector using regularized least squares.

The remaining core part of the algorithm to discuss is the subroutine LWS, and we do so next. We start by providing our reasoning behind the LWS design.

**The LWS Algorithm.** Recall that we want LWS at each batch \(m\) to select \(d\) vectors \(\{a_{i}\}^{}\) such that, by playing each \(n_{m}(i)\) times, we can create a least-squares estimate \(_{m+1}\) of \(_{*}\) that allows an accurate estimate of the product \( a,_{}\) for all \(a\). It is well-known (see ) that the error in estimating \( a,_{}\) is proportional to \(\|a\|_{_{m}^{-1}}\), where \(_{m}=+_{i=1}^{T_{m}}a_{i}a_{i}^{}\) is the least squares matrix we used to estimate \(_{m+1}\). Thus, essentially we want LWS to select \(d\) vectors \(\{a_{i}\}\) that maintain a small \(\|a\|_{_{m}^{-1}}\) for all actions \(a\)3. We can do so using what is called a G-optimal design .

**Definition 2**.: (G-optimal design) For any set \(^{d}\), a subset \(\), together with a distribution \(\) over \(\) is said to be a \(C\)**-approximate optimal design** for \(\) if for any \(a\)

\[\|a\|_{_{}^{-1}}^{2} Cd,\] (5)

where \(_{}=_{a_{i}}(i)a_{i}a_{i}^{ 4}\). When \(C=1\) this is referred to as a **G-optimal design**.

Notice that if we were to play each action \(a_{i}\) for \(n(i)\) times, then \(_{}\) would be (approximately) a normalized least squares matrix since \(_{}+/n=/n\), and hence, \(\|a\|_{^{-1}}^{2}\|a\|_{_{}^{-1}}^{2}/n\).

It is well-known that for any compact set, there exists a \(1\)-approximate optimal design  with \(||=d\). However, computing an \(1\)-approximate optimal design is NP-hard in general , even for small action sets. Computing a \(2\)-approximate optimal design can be done in polynomial time , but the complexity scales linearly with the size of the action set. Instead, we adopt an approach introduced in , which efficiently constructs an \(O()\)-approximate optimal design using only a linear optimization oracle. This relies on the concept of a barycentric spanner, which we define next.

**Definition 3**.: (Barycentric spanner) For any set \(^{d}\), a subset \(=\{a_{1},,a_{d}\}\) is said to be a \(C\)**-approximate barycentric spanner** for \(\) if any \(a\) can be expressed as a linear combination of vectors in \(\) with coeficients in \([-C,C]\).

It is easy to see that a \(C\)**-approximate barycentric spanner** together with **a uniform distribution**\((i)=1/d\) results in a \(C\)-approximate optimal design . And importantly, a \(C\)-approximate barycentric spanner for a set \(\) can be constructed using at most \(O(d^{2}_{C}d)\) calls of a linear optimization oracle over the set \(\).

However, this is still not sufficient for us. Even though we can efficiently construct a \(C\)-approximate optimal design for \(\), we do not want to pull these arms according to a uniform distribution; we want to pull action \(a_{i}\) with estimated gap \(_{m}(a_{i})\) for \(n_{m}(i)=(i)T_{m}/(1+}_{m}(a)/(8))^{2}\) times to control the regret (which can be thought of as using a weighted distribution5). But if we do not use the uniform distribution, the resulting least squares matrix \(_{m}\) may not satisfy that \(\|a\|_{_{m}^{-1}}\) is sufficiently small for all actions \(a\).

To account for this, instead of finding a \(C\)-approximate barycentric spanner for the set \(\), at each batch \(m\) we consider a **virtual action set**\(}_{m}\), which we define as

\[}_{m}=\{_{m}(a)|a\},_{m}(a)=_{m}(a)},\] (6)

where \(_{m}=}/(8)\) and find actions \(\{a_{1},,a_{d}\}\) such that \(\{_{m}(a_{i})\}_{i=1}^{d}\) forms a \(C\)-approximate barycentric spanner for \(}_{m}\). The least squares matrix at batch \(m\) can be bounded as

\[_{m}=+_{i=0}^{d}_{m}(i)a_{i}a_{i}^{} _{i=1}^{d}/8}{(1+_{m}_{m}(a_{i}))^{2}}a_{i}a_{i} ^{}=_{i=1}^{d}(i)}{8}_{m}(a_{i})_{m}(a_{i})^{}\] (7)

with high probability6, where \(_{m}(i)\) is the number of times action \(a_{i}\) is played in batch \(m\) and \(a_{0}=a_{m}^{*}\). That is, playing actions \(\{a_{1},,a_{d}\}\) for \(n_{m}(i)\) times each, can equivalently be thought of as playing actions \(\{(a_{1}),,(a_{d})\}}_{m}\) for \((i)T_{m}\) times each; and since \(\{(a_{1}),,(a_{d})\}\) form an approximate optimal design (through a barycentric spanner) for the set \(_{m}\), the resulting least squares matrix will lead to small \(\|_{m}(a)\|_{_{m}^{-1}}\) values. In our proofs we show that a small enough \(\|_{m}(a)\|_{_{m}^{-1}}\) implies \(\|a\|_{_{m}^{-1}}=O(_{a})\) as a result of the scaling in \((a)\). We prove in Lemma 5 in App. D that this allows to estimate \(_{a}\) within a constant factor, which is all we need.

Intuitively, the virtual set \(}_{m}\) weighs the actions inversely proportional to the estimated gap \(_{m}(a)\) and batch length \(}\): the larger the gap and \(T_{m-1}\), the smaller magnitude the corresponding action has; this implements a form of soft elimination (shaping) of the action set, where the actions closest to the optimal become increasingly dominant as the batch length increases while the remaining fade out to zero. As a result, as \(m\) increases, the span of the optimal design focuses on the space where actions have small gaps, allowing to better distinguish among them.

To complete SoftBach (Algorithm 1), one last step is missing. LWS (Algorithm 2) follows standard steps (in Algorithm 2, see  for detailed explanation) to calculate the C-approximate barycentric spanner for \(}_{m}\). But to follow these steps, it requires the ability to solve the non-linear optimization problem \(_{a}_{m}(a),\), since \(_{m}(a)=a/(1+}_{m}(a)/(8))\) is nonlinear in \(a\). To do so, we will use7 an approximate oracle with multiplicative error, that we term **LW-ArgMax** and describe next.

**LW-ArgMax Algorithm.** LW-ArgMax (Algorithm 3) constructs an approximate oracle with \((1-)\)-multiplicative error for the optimization \(_{a}_{m}(a),\). This is sufficient: we show in Lemma 2 that Algorithm 2 can use LW-ArgMax to compute a \(C/\)-approximate barycentric spanner for \(}_{m}\).

Recall that, before providing the action set \(\) to Algorithm 2, SoftBatch extends to \(^{}=_{1/T}\)8. This guarantees that: \(^{}\) spans \(^{d}\) (required to find a barycentric spanner ), and \(_{a^{}} a, 1/T\) for all \(\) with \(\|\|_{2}=1\) which implies that any approximate optimization oracle with additive error less than \(1/(2T)\) has multiplicative error of at most \(1/2\). The extension of the set \(\) results in the barycentric spanner possibly containing points not in \(\). However, we show that removing these points only affects \(_{a}\|a\|_{^{-1}}\) by a constant factor, since \(_{1/T}\) has a small radius. Extending the set \(\) to \(^{}\) also handles the case where the span of \(\) is smaller than \(^{d}\), that was typically handled in literature by constructing a basis of \(\) which can be complicated for some sets.

LW-ArgMax then builds on the following observation (proved as part of the proof of Lemma 1):

\[_{a}(a),( a,)^{1/W}=_{a^{}}_{z 0 }L_{z}(a),\] (8)

where \(L_{z}(a)=z(1+1/W) a,-z^{1+1/W}(1+(a))\) and \((a)=_{b} b-a,_{}  a^{}\).

By choosing \(W\) to be large enough, the left hand side of (8) becomes a good approximation for \((a),\). For a fixed \(z\), the supremum on the right hand side of (8) reduces to a linear optimization over the set \(^{}\) (that we solve using an approximate linear optimization oracle). Although the optimal value of \(z\) is not known, it can be bounded (see equation (25) in App. B); thus LW-ArgMax scans between upper and lower bounds on the optimal \(z\) with a constant multiplicative step. The pseudo-code is provided in Algorithm 3.

```
1:Input: set of actions \(\), \(_{1}\), parameter \(\), estimated best action \(\), estimate \(\), horizon T.
2:Let \((a)=-a,\), \((a)=a/(1+(a))\).
3:Let \(W=3 T\), \(N=36W^{2}(T)\), \(s=1-1/6 T\), \(^{}=(1-(-1))/(12T^{7+12 T})\).
4:Initialize \(z=2^{W}\)
5:for\(i=1,,N+1\)do
6:\(=(1+1/W)z+z^{1+1/W}\)
7:\(a_{i}=_{^{}}^{+}(;/\|\|_{2})\).
8:\(z zs\).
9:Return:\(_{a\{a_{i}\}_{i=1}^{N}}(a),\). ```

**Algorithm 3** LW-ArgMax Algorithm

### Proof Outline for Theorem 1

We start by proving that LW-ArgMax is an approximate linear optimization oracle for the set \(}\) with \(1-(-3)\) multiplicative error. The result is stated in Lemma 1 and proved in App. B.

**Lemma 1**.: _Let \(T 3,,^{d},_{T}\) be given parameters, and \(\) be a given set. Let \((a),(a)\) denote \((a)=-a,,(a)=a/(1+(a))\). If \(_{1/T}_{1},|| T\) and \(1/2 1+(a) T^{2},\  a\), then for any \(_{1}\), LW-ArgMax outputs an element \(a\) such that_

\[(a),(-3)_{b\{(b^{ })|b^{}\}} b,.\] (9)

The conditions of Lemma 1 are easy to verify for all batches \(m\); namely, \(_{1/T}_{1}\) holds as we extend the set of actions by adding \(_{1/T}\) before feeding it into Algorithm 3 and the condition \(1/2 1+(a) T^{2},\  a\) is proved in Theorem 1 for all the inputs fed into Algorithm 3.

Given the result of Lemma 1, we next show that Algorithm 2 finds a \(C/\)-approximate barycentric spanner of the set \(}_{m},\  m[M]\). This is done by slightly adapting the proof of Proposition \(2.5\) in  to work with approximate linear optimization oracles instead of exact oracles. The result is stated in the following theorem and the proof is provided in App. C for completeness.

**Lemma 2**.: _Let \(,^{d},^{d}\) be given parameters, and \(\) be a given set. Let \((a),(a)\) denote \((a)=-a,,(a)=a/(1+(a))\). Suppose that \((()),_{a }(a),\), then Algorithm 2 computes a \(C/\)-approximate barycentric spanner for the set \(}=\{(a)|a\}\) with at most \(O(d^{2}_{C}(d/))\) calls to LW-ArgMax._

To build our regret bounds, we essentially prove that a number of pulls of \((a_{i})^{2}}\) for action \(a_{i}\) enables to estimate the gap \(_{m}(a_{i})\) within a constant factor of the real gap \(_{a_{i}}\). To do so, we start by providing an error bound for estimating \(_{m}(a),_{}\) using standard sub-Gaussian concentration inequalities. Then, through mathematical induction, we extend this bound to the error of the action mean estimates \( a,_{m}\). Intuitively, if we believe that \( a,_{m}\) is a good estimate of \( a,_{}\) for all actions, which implies \(_{m}(a)\) is a good estimate of \(_{a}\) at batch \(m\), then even though the scale in \(_{m+1}\) by \(_{m}(a)\), this property will continue to hold at batch \(m+1\). The constants multiplying \(_{m}(a)\) in \(_{m}\) are carefully designed to enable this. Finally, we show that the inverse squared gap weighting of the distribution enables to tightly upper bound the regret. 

## 4 Algorithm for Contextual Linear Bandits

Our algorithm for contextual linear bandits is based on a technique proposed in , which reduces the contextual linear to a linear bandit setting. However, we cannot directly apply the reduction from  in Algorithm 1, as the reduction is not necessarily computationally efficient. Instead, we build a new algorithm (see Algorithm 4 in App. G) that incorporates reduction steps from  within Algorithm 1. One challenge we encounter is the introduction of a large, non-convex action set through the reduction process. To address this, we construct a linear optimization oracle over the new action set in order to ensure the efficiency of Algorithm 4. Additionally, the reduction requires estimating the expected value of a function (explained next and in App. G), and we carefully design the batch lengths to perform this estimation effectively. The following theorem describes our main result.

**Theorem 3**.: _Consider a contextual linear bandit instance with \(_{t}\) generated from an unknown distribution \(\). There exists a universal constant \(C\) and choice for batch lengths such that Algorithm 4 finishes in \(O( T)\) batches with regret upper bounded as_

\[R_{T} C T\]

_with probability at least \(1-\), where \(=10d((16M/)+57d^{2}(6T))}\). Moreover, the running time and space complexity are \((d^{4}+_{}d^{3}T)\), \((d^{2}+_{})\) respectively._

We next briefly review the reduction and refer the reader to  for a detailed description. The basic idea in  is to establish a linear bandit action for each possible parameter vector \(\) of the contextual bandit instance. This is achieved through the use of the function \(g:^{d}^{d}\), which computes the expected best action under the context distribution \(\) with respect to the parameter \(\): \(g()=_{}[(; )]\), where \(\) is an optimization oracle (see Definition 1). A key insight, as stated in Theorem 1 of , is that if \(a_{t}=(_{t};_{t})\) for some \(_{t}^{d}\), then the reward generated by the contextual bandit instance can be expressed as \(r_{t}= g(_{t}),_{}+^{}_{t}\), where \(^{}_{t}\) is noise with zero mean conditioned on the history. Consequently, the reward can be viewed as generated by pulling action \(g(_{t})\) in a linear bandit instance with an action set \(=\{g()|\}\). Moreover, the same theorem demonstrates that if a linear bandit algorithm is employed to choose \(g(_{t})\) at round \(t\) and thus play action \(a_{t}=(_{t};_{t})\), then \(|R_{T}-R_{T}^{L}|=()\) with high probability, where \(R_{T}^{L}=_{t=1}^{T}_{} g()-g(_{t}),_{}\) is the regret of the algorithm on the linear bandit instance.

To estimate \(g\), which depends on the unknown context distribution \(\),  proposes using contexts observed in previous batches. Specifically, the function \(g\) is replaced by \(g^{(m+1)}()=|}_{t H_{m}}(_{t };)\) for all \(^{}\), where \(H_{m}\) is the set of indices for rounds in batch \(m\) and \(^{}=[]_{q}|\) is a discretization of \(\), \([]_{q}=q/q/\) and \(q\) is the discretization parameter. The action set at batch \(m\) is correspondingly modified as \(_{m}=\{g^{(m)}()|^{}\}\). It is also shown in  that \(g^{(m)}\) is a good estimate of \(g\) for all \(^{}\) with high probability.

To leverage this reduction, we modify Algorithm 1 by adapting the action set in each batch based on the estimate of \(g\), i.e., the set \(_{m}\) (note that we do not need to explicitly calculate the sets \(_{m}\)). However, an issue arises where the estimate of \(_{}\) at batch \(m\) depends on the approximate optimal design from batch \(m-1\), which employs the action set \(_{m-1}\) estimated from the contexts of batch \(m-2\). In the proof of Theorem 3, we demonstrate that this leads to regret proportional to \(T_{m}/}\). If the batch lengths grow rapidly, significant regret may occur. To mitigate this, we reduce the growth rate of batch lengths by allowing them to increase only when \(m\) is odd (a similar technique was employed in ). The pseudo-code is in Algorithm 4.

To implement Algorithm 4 efficiently we need: (i) an **approximate linear optimization oracle for the set \(_{m}\)** with additive error at most \(=(1-(-1))/(12T^{7+12 T})\)**: we show in Lemma 8 in App. F that \(g^{(m)}([]_{q})\) can be used as our approximate oracle for \(q/2\); and (ii) an **inverse of the function**\(g^{(m)}\) to find \(_{t}\) associated with \(g^{(m)}(_{t})\) to play the action \(a_{t}=(_{t};_{t})\): we observe that all actions played by our algorithms (Algorithm 1 and 4) are the output of the approximate optimization oracle for some \(\); namely, for Algorithm 4 any pulled action is of the form \(g^{(m)}([]_{q})\) for some input to the approximate oracle \(\). Hence, the inversion of \(g^{(m)}\) for the actions pulled by Algorithm 4 can be performed by storing \([]_{q}\) whenever the action \(g^{(m)}([]_{q})\) is stored. This increases both the space and time complexity only by a constant factor.

**Gap-dependent regret bounds for contextual linear bandits.** The main difficulty in extending the gap-dependent regret bounds in Theorem 1 to the contextual case is that a large minimum action gap in the original action sets \(_{t}\) does not imply a large gap in the reduced action set \(\). As a simple example consider \(d=1\), \(_{*}=1\), and two action sets \(_{1}=\{-1,1\}\), and \(_{2}=\{-1\}\). At each iteration the learner receives the action set \(_{1}\) with probability \(p\) and \(_{2}\) with probability \(1-p\) independently from other iterations. Recall that the action set in the reduced instance \(=\{g()|[-1,1]\}\), where \(g()=_{ p}[_{a}(a,)]\). For \( 0\) we have that \(g()=p(1)+(1-p)(-1)=2p-1\), while for \(<0\) we have \(g()=p(-1)+(1-p)(-1)=-1\). Then \(=\{-1,2p-1\}\). Therefore, the suboptimality gap is \(_{}=(2p-1)(1)-(-1)(1)=2p\) which can be arbitrarily small depending on \(p\). Note that in the original contextual bandit instance, the minimum gap is at least \(2\) for both action sets.

While it may be possible to provide gap dependent regret bounds for our algorithm in the contextual case, this will require more sophisticated regret analysis that does not only rely on the reduced linear bandit instance.

**Numerical results.** In App. I, we provide a numerical example to compare the computational complexity of computing the exploration policy of our algorithm versus the complexity of computing the policy in .

## 5 Conclusion

In this paper, we proposed the first efficient batched algorithm for contextual linear bandits with large action spaces. Our algorithm achieves a high-probability regret upper bound of \(()\), uses \(O( T)\) batches, and has a computational complexity that is linear in \(T\) and polynomial in \(d\).