# Dynamic Tensor Decomposition via Neural Diffusion-Reaction Processes

Zheng Wang

Kahlert School of Computing

University of Utah

Salt Lake City, UT 84112

u1208847@utah.edu

&Shikai Fang

Kahlert School of Computing

University of Utah

Salt Lake City, UT 84112

shikai.fang@utah.edu

&Shibo Li

Kahlert School of Computing

University of Utah

Salt Lake City, UT 84112

shibo@cs.utah.edu

&Shandian Zhe

Kahlert School of Computing

University of Utah

Salt Lake City, UT 84112

zhe@cs.utah.edu

Equal contributionCorresponding author.

###### Abstract

Tensor decomposition is an important tool for multiway data analysis. In practice, the data is often sparse yet associated with rich temporal information. Existing methods, however, often under-use the time information and ignore the structural knowledge within the sparsely observed tensor entries. To overcome these limitations and to better capture the underlying temporal structure, we propose Dynamic EMbedIngs fOr dynamic Tensor dEcomposition (DEMOTE). We develop a neural diffusion-reaction process to estimate dynamic embeddings for the entities in each tensor mode. Specifically, based on the observed tensor entries, we build a multi-partite graph to encode the correlation between the entities. We construct a graph diffusion process to co-evolve the embedding trajectories of the correlated entities and use a neural network to construct a reaction process for each individual entity. In this way, our model can capture both the commonalities and personalities during the evolution of the embeddings for different entities. We then use a neural network to model the entry value as a nonlinear function of the embedding trajectories. For model estimation, we combine ODE solvers to develop a stochastic mini-batch learning algorithm. We propose a stratified sampling method to balance the cost of processing each mini-batch so as to improve the overall efficiency. We show the advantage of our approach in both simulation study and real-world applications. The code is available at https://github.com/wzhut/Dynamic-Tensor-Decomposition-via-Neural-Diffusion-Reaction-Processes.

## 1 Introduction

Multiway data is common in real-world applications and naturally represented by tensors. For example, online shopping and promotion activities can be expressed as a three-mode tensor _(customer, commodity, online merchant)_. Tensor decomposition is an important tool for multiway data analysis. It estimates embeddings for the entities in each tensor mode, with which to recover the observedentry values. The embeddings can reflect the underlying structures within the entities and can be used as predictive features, such as for recommendation and ads auction.

In practice, tensor data is often very sparse. That is, the observed entries only take a tiny portion of all possible entries, say, \(0.01\%\). In addition, the data often includes timestamps for the observed entry values, which imply rich, complex temporal variation patterns. Current tensor decomposition approaches often ignore the structure knowledge within the sparsely observed entries and under-use the temporal information, _e.g._, simply binning the timestamps into crude time steps (Xiong et al., 2010; Rogers et al., 2013; Zhe et al., 2016, 2015; Du et al., 2018). More important, standard tensor decomposition estimates a static embedding for each entity. However, as the representation of entities, these embeddings summarize the underlying properties of the entities, which can naturally evolve with time, such as customer interests, user income, product popularity, and fashion. Learning static embeddings can miss capturing these interesting, important temporal knowledge. While the most recent work (Wang et al., 2022) has proposed the first decomposition method to estimate embedding trajectories, it never considers the structural knowledge within the data.

To overcome these limitations, we propose DEMOTE, a dynamic embedding approach for dynamic tensor decomposition. We construct a nonlinear diffusion-reaction process in an Ordinary Differential Equation (ODE) framework to estimate embedding trajectories for tensor entities. The ODE framework is known to be flexible and convenient to handle irregularly sampled timestamps and sparsely observed data (Rubanova et al., 2019). In addition, since ODE models focus on learning the dynamics (_i.e._, time derivatives) of the target function, they have promising potential for providing robust, accurate long-term predictions (via integration with the dynamics). Specifically, to leverage the structural knowledge within the data, we first build a multi-partite graph based on the observed entries. The graph encodes the correlations between entities at different modes in terms of their interactions. We then construct a graph diffusion process in the ODE to co-evolve the embedding trajectories of correlated entities. Next, we use a neural network to construct a reaction process to model the individual-specific evolution for each entity. In this way, our neural diffusion-reaction process captures both the commonalities and personalities of the entities in learning their dynamic embeddings. Given the embedding trajectories, we model the entry value as a latent function of the associated entities' trajectories. We use another neural network to flexibly estimate the function and to capture the complex relationships of the entities. For efficient training, we base on ODE solvers to develop a stochastic mini-batch learning algorithm. We develop a stratified sampling scheme, which can balance the cost of executing the ODE solvers in each mini-batch so as to improve the efficiency.

We evaluated our method in both simulation and real-world applications. The simulation experiments show that DEMOTE can successfully capture the underlying dynamics of the entities from their temporal interactions and recover the hidden clustering structures within the trajectories. Then in three real-world applications, we tested the accuracy in predicting the tensor entry values at different time points. DEMOTE consistently outperforms the state-of-the-art decomposition methods that incorporate temporal information, often by a large margin. We also demonstrated that both the diffusion and reaction processes contribute to the learning performance. Finally, we investigated the learned embedding trajectories and found interesting evolution paths and hidden structures.

## 2 Notations and Background

Suppose we have collected data for a \(K\)-mode tensor. Each mode \(k\) includes \(d_{k}\) entities, which we index by \(1,,d_{k}\). We then index each tensor entry by a tuple \(=(l_{1},,l_{K})\) where for each \(k\), we have \(1 l_{k} d_{k}\). Suppose we observed \(N\) tensor entry values and timestamps. The dataset is denoted by \(=\{(_{1},t_{1},y_{1}),,(_ {N},t_{N},y_{N})\}\) where \(\{t_{n}\}\) and \(\{y_{n}\}\) are the timestamps and entry values, respectively. Our goal is for each entity \(j\) of mode \(k\), to estimate a dynamic embedding \(_{j}^{k}(t):_{+}^{R}\). That is, the embedding is a time function (trajectory) with an \(R\)-dimensional output. Standard tensor decomposition introduces a static embedding representation for each entity, namely, \(_{j}^{k}\) is considered as time invariant. Tensor decomposition aims to estimate the embeddings (or factors) to reconstruct the tensor. For example, the classical Tucker decomposition (Tucker, 1966) employs a multilinear factorization model, \(=_{1}^{1}_{2}_{K} ^{K}\), where \(^{d_{1} d_{k}}\) is the entire tensor, \(^{R_{1} R_{K}}\) is the tensor-core parameter, \(^{k}\) comprises all the embeddings of the entities in mode \(k\), and \(_{k}\) is the tensor-matrix product at mode \(k\)(Kolda, 2006). The popular CANDECOMP/PARAFAC (CP) decomposition (Harshman, 1970) can be viewed as a simplified version of Tucker decomposition, where we set \(R_{1}==R_{K}=R\) and the tensor-core \(\) to be diagonal. Hence, each entry value is factorized as \(m_{}=(^{1}_{l_{1}}^{K}_{l_{K}})^{} \), where \(\) is the Hadamard (element-wise) product, and \(\) corresponds to \(()\). While CP and Tucker decomposition are popular, their multilinear modeling can be oversimplistic for complex applications. To estimate nonlinear relationships of the entities, Xu et al. (2012); Zhe et al. (2015, 2016a) used a Gaussian process (GP) (Rasmussen and Williams, 2006) to model the entry value as a random function of the embeddings, \(m_{}=g(^{1}_{l_{1}},,^{K}_{l_{K}})\), where \(g(0,(_{}},_{} }))\), \(_{}}=[^{1}_{l_{1}};;^{K}_{l_{K}}]\) and \(_{^{}}}=[^{1}_{l_{1}^{}};; ^{K}_{l_{K}^{}}]\) are the embeddings of the entities in entry \(\) and \(}\), respectively, and \((,)\) is the covariance (kernel) function. Given the GP prior, any finite set of \(N\) entry values follow a multi-variate Gaussian distribution, \((,)\), where \(=[m_{_{1}},,m_{_{N}}]\), \(\) is the \(N N\) kernel matrix, and each \([]_{i,j}=(_{}},_{^{ }}})\). Suppose we have collected continuous observations for the \(N\) entries \(=[y_{1},,y_{N}]\). We can use a Gaussian noise model: \(y_{n}=m_{_{n}}+_{n}\) where \(_{n}(0,^{2})\). The marginal likelihood is \(p()=(|,+^{2})\), which we can maximize to estimate the embeddings and the model parameters.

Practical data often includes temporal information, _i.e._, the timestamp when each observed entry value is generated. To leverage this information, existing methods often bin the timestamps into a series of steps, say, by weeks or months (Xiong et al., 2010; Rogers et al., 2013; Zhe et al., 2016a; Song et al., 2017). The tensor is then expanded with an additional time-step mode, and one can apply any decomposition algorithm to estimate embeddings for both the entities and time steps. To capture the temporal dependency, a conditional model is often used (Xiong et al., 2010), say, \(p(_{j+1}|_{j})=(_{j+1}|_{j},)\) where \(_{j}\) is the embedding of \(j\)-th step. To leverage the continuous time information, Zhang et al. (2021) recently developed continuous CP decomposition, where the coefficients \(\) are modeled as a time function with polynomial splines.

## 3 Model

Standard tensor decomposition assumes the embeddings are static and time-invariant. However, the embeddings summarize and extract the properties of entities, which can evolve with time, such as customer interests, health status, and product popularity. Therefore, only estimating static embeddings can miss important temporal variations of the entities' properties, resulting in poor representations and predictive performance. In addition, practical tensor data are typical sparse, and only a small portion of entries actually have data. Within these entries can be valuable structural knowledge. Current methods, however, are rarely aware of such knowledge. To overcome these limitations, we propose DEMOTE, a novel dynamic embedding approach.

Specifically, we propose an ODE model to learn the embedding trajectories \(\{^{k}_{j}(t)|1 k K,1 j d_{k}\}\). The ODE framework is known to be amenable for irregularly sampled, sparsely observed data. More important, ODE models concentrate on learning the time derivative \(^{k}_{j}/t\) (_i.e._, dynamics), rather than the trajectory function itself. Therefore, they have a promising potential to give reliable, long-term trajectory prediction (via numerical integration) even at time points far away from the training timestamps, provided the time derivative is well captured. We construct a joint ODE model for all the embedding trajectories. The ODE consists of a diffusion process and a

Figure 1: The illustration of the embedding model in DEMOTE.

reaction process. The diffusion process leverages the structural knowledge in data to co-evolve the embeddings of correlated entities, so as to better overcome the data sparsity. The reaction process models the entity-specific evolution so that it can capture the individual differences in the embedding evolution. The ODE model synergizes the two processes to capture both the commonalities and personalities of these embedding trajectories.

**Diffusion Process on Multi-Partite Graphs.** First, we construct a graph-based diffusion process to exploit the entity correlations reflected in data. Intuitively, if an observed entry involves entity A (_e.g._, customer A) and B (_e.g._, commodity B), the two entities are likely correlated. Thus, we can draw an edge between A and B to express the correlation. We then generalize this intuition to create a \(K\)-partite undirected graph \((E,V)\), to encode such correlations across all the entities in the \(K\) tensor modes. Each vertex represents a particular entity, and the entire collection of the entities is partitioned into \(K\) groups, \(V=V^{1} V^{K}\), where group \(V^{k}=\{v^{k}_{1},,v^{k}_{d_{k}}\}\) represents the entities of mode \(k\). Two entities (at different modes) are connected if they were observed to interact, namely, \((v^{k}_{j},v^{k^{}}_{j^{}})\) if \(_{n}\) such that \(_{n}=(,j,,j^{},)\) where \(j\) and \(j^{}\) are indices at mode \(k\) and \(k^{}\), respectively. See Fig. 1 for an illustration. This graph naturally implies underlying information diffusion across the entities within their interactions. For example, if customer A connects to products B and C, it might mean that A distributes their interests/willingness/budgets to purchase B and C. The edges between one merchant A and a list of products {B, C,...} might indicate the diffusion of willingness to increase the inventory of these products.

To flexibly estimate the diffusion rate, we introduce a weight \(w^{k,k^{}}_{j,j^{}}\) for each edge \((v^{k}_{j},v^{k^{}}_{j^{}}) E\). We then arrange these weights into \(K(K-1)\) adjacent matrices, \(=\{^{k,k^{}}|1 k,k^{} K,k k^{ }\}\) where \(^{k,k^{}}=(^{k^{},k})^{}\). Each \(^{k,k^{}}\) is a sparse \(d_{k} d_{k^{}}\) matrix that represents the edges and edge weights between \(V^{k}\) and \(V^{k^{}}\), _i.e._, \([^{k,k^{}}]_{j,j^{}}=w^{k,k^{}}_{j,j^{}}\) if \((v^{k}_{j},v^{k^{}}_{j^{}}) E\) and \(0\) otherwise. We now construct a diffusion process based on the \(K\)-partite graph. We view the embedding trajectory as a kind of concentration. For each entity \(j\) at mode \(k\), the change rate of its concentration (embedding) \(^{k}_{j}(t)\) is determined by the difference from the concentrations of its neighbors. Since the neighbors come from entities of all the other \(K-1\) modes, we have

\[^{k}_{j}}{t}=_{s\{1,,K\}  k}_{j^{}=1}^{d_{s}}[^{k,s}]_{j,j^{}}( ^{s}_{j^{}}(t)-^{k}_{j}(t))=_{s\{1, ,K\} k}(^{k,s}_{j}^{s}(t))^{ }-a^{k,s}_{j}^{k}_{j},\]

where \(^{k,s}_{j}\) is the \(j\)-th row of \(^{k,s}\), \(^{s}(t)=[^{s}_{1}(t),,^{s}_{d_{s}}(t)]^{}\) is the embeddings of all the entities at mode \(s\), of size \(d_{s} R\), and \(a^{k,s}_{j}=_{j^{}=1}^{d_{s}}[^{k,s}]_{j,j^{}}\) is the degree of vertex \(j\) in \(^{k,s}\). We can see that the evolution of the embeddings for different modes are coupled. Hence, it is natural to formulate the diffusion process jointly for all the embeddings, \((t)}{t}=(^{1}(t),,^{K}(t))/t=(t)- (t)=(-)(t)\) where

\[=(&^{1,2}&& ^{1,K}\\ ^{2,1}&&&\\ &&&^{K-1,K}\\ ^{K,1}&&^{K,K-1}&),\]

\(=(_{s\{1 K\} 1}^{1,s}, ,_{s\{1 K\} K}^{K,s})\), and each \(^{k,s}=(a^{k,s}_{1},,a^{k,s}_{d_{k}})\) is the degree matrix of \(^{k,s}\).

**Reaction Process of Individual Entities.** Next, to capture the individual difference of each entity in evolving their embeddings, we model a local reaction process for each entity, \(_{_{k}}(^{k}_{j}(t),t)\), where \(()\) is a neural network (NN), and \(_{k}\) are the NN (reaction) parameters for mode-\(k\) entities. The metaphor from the chemical physics is as follows. While substances are being diffused across different sites, at each site a chemical reaction process happens concurrently, which varies the concentration locally. We extend the model as a joint diffusion-reaction process,

\[(t)}{ t}=(-)(t )+(,t),(0)=_{0},\] (1)where \((,t)=[_{_{1}}(^{1}_{1},t),, _{_{l}}(^{1}_{d_{1}},t),,_{_{K} }(^{K}_{1},t),,_{_{K}}(^{K}_{d_{K}},t )]^{}\).

**Entry Value Generation.** Given the embedding trajectories, to obtain the tensor entry value \(m_{}\) at arbitrary time \(t\), we model \(m_{}(t)\) as a function of the relevant embeddings at time \(t\),

\[m_{}(t)=g(^{1}_{l_{1}}(t),,^{K }_{l_{K}}(t)).\] (2)

While one can follow (Xu et al., 2012; Zhe et al., 2016) to assign a GP prior over \(g()\), the GP model needs to compute a giant kernel matrix over all the observed entry values (see Sec. 2). It is computationally too expensive or infeasible when the number of observations is large. Hence one has to seek for complex low-rank approximations. To avoid this problem, we model \(g\) with another neural network, which is not only as flexible as GP, but is more scalable and convenient for computation. Since now, the input to \(g()\) consists of the trajectory values, which vary with time, our NN model for \(g\) can flexibly capture the complex temporal relationship between the entities. We finally sample the observed entry values with a Gaussian noise model, \(p(|)=(|,^{2})\) where \(=[y_{1},,y_{N}]^{}\) and \(=[m_{_{1}}(t_{1}),,m_{_{N} }(t_{N})]^{}\). We focus on real-valued data in this paper. However, it is straightforward to extend our approach to other types of data.

## 4 Model Estimation

Given data \(=\{(_{1},t_{1},y_{1}),,(_{ N},t_{N},y_{N})\}\), the joint probability of our model is

\[p(,\{_{k}\},)=p()_{k=1}^{K}p(_{k})_{n=1}^{N} (y_{n}|g(^{1}_{l_{n1}}(t_{n}),,^ {K}_{l_{nK}}(t_{n})),^{2}),\] (3)

where \(\) is the NN parameters for \(g\), each \(_{k}\) is the NN reaction parameters for mode-\(k\) entities, \(p()\) and \(p(_{k})\) are element-wise standard Gaussian, and \(=(y_{1},,y_{N})^{}\). To obtain the trajectory values in the Gaussian likelihood of each \(y_{n}\), we need to solve the ODE in (1) to time \(t_{n}\),

\[(t_{n})=(_{0},0,t_{n},)\] (4)

where \(=\{,_{1},,_{K}\}\) consists of the ODE parameters. Our goal is to estimate \(\), the initial state \(_{0}\), the NN parameters \(\), and the noise variance \(^{2}\).

**Stratified Mini-Batch Sampling.** We use stochastic mini-batch optimization to maximize the log joint probability so as to estimate all the required parameters,

\[=  p(,\{_{k}\}, )=()-_{n=1}^{N}(y_{n}|g (_{n}),^{2})\]

where \(()= p()+_{k=1}^{K} p( {}_{k})\), and \(_{n}=(^{1}_{l_{n1}}(t_{n}),,^{K}_{l_{ nK}}(t_{n}))\). Each time, we sample a mini-batch of observations \(\), and obtain an unbiased stochastic estimate of the log probability, \(}=()-_{n} [(y_{n}|g(_{n}),^{2})]\). We compute \(}\) as the stochastic gradient to update all the parameters.

For each data point \(n\) in the mini-batch, we need to run ODE solving (4) to obtain \(_{n}=(^{1}_{l_{n1}}(t_{n}),,^{K}_{l_{ nK}}(t_{n}))\). To back-propagate the gradient so as to compute the gradient w.r.t the ODE parameters \(\) and initial state \(_{0}\), we can either construct a computational graph during the running of the solver (_e.g._, the Runge-Kutta method (Dormand and Prince, 1980)), or use the adjoint state method (Pontryagin, 1987; Chen et al., 2018) that solves an adjoint backward ODE to compute the gradient. In whichever case, we need to sort the time points in the mini-batch and solve the ODE sequentially for these time points. As a result, the number of _unique_ time points in the mini-batch greatly influences the speed of processing the mini-batch. The standard mini-batch sampling (based on the training example indices) can result in an uneven allocation of the computational cost across the mini-batches -- some mini-batch is fast and some including more unique time points is much slower. To address this issue, we use a simple stratified sampling approach.

* We collect the unique time points in the whole dataset, \(=\{_{1},_{2},\}\) at the beginning.
* To conduct each stochastic update, we first sample \(B\) unique time points \(\) from \(\), then for each time point \(_{j}\), we look at all the observed entry values produced at \(_{j}\), namely \(_{_{j}}=\{(_{n},t_{n},y_{n})|t_{n}= _{j}\}\).
* We randomly sample one example from each \(_{_{j}}\) to collect the mini-batch \(\).

[MISSING_PAGE_EMPTY:6]

where \(()\) is the indicator function. When \(l_{1}+l_{2}\) is even, the entry value is the trajectory value of the first entity; otherwise, it is the trajectory value of the second entity. To generate the training data, we randomly sampled entries from \(\{(l_{1},l_{2})|1 l_{1},l_{2} 10\}\{(l_{1},l_{2})|11 l_{1},l_{2}  20\}\) (namely, interactions between cluster-1 entities of the two modes, and between cluster-2 entities). We then sampled \(t\), to obtain the corresponding entry values. We randomly generated 6,400 entry values and the timestamps for training, and another 1,600 data points for testing.

We implemented our method with Pytorch (Paszke et al., 2019). We used torchdiffeq library (https://github.com/rtqichen/torchdiffeq) to solve ODEs and to compute the gradient w.r.t ODE parameters and initial states via automatic differentiation. For the NN of the reaction process, we used one hidden layer, with 10 neurons and tanh activation, and for the NN to predict the interaction result, we used two hidden layers, 50 neurons per layer and tanh activation.

We compared with NONFAT (NONparametric Factor Trajectory learning) (Wang et al., 2022), a bi-level latent GP model that uses Fourier bases to estimate factor trajectories for dynamic tensor decomposition. To our knowledge, this work is the only method (and also the most recent) that estimates trajectories. We used the original implementation (https://github.com/wzhut/NONFAT) and the default settings. We set the mini-batch size to 50, and used ADAM (Kingma and Ba, 2014) algorithm for stochastic optimization. The learning rate was automatically adjusted in \([10^{-4},10^{-1}]\) by the ReduceLROnPlateau scheduler (Al-Kababji et al., 2022). The maximum number of epochs is 2K, which is enough for convergence. The estimated trajectories are shown in Fig. 1(a)-f. As we can see, our estimation (Fig. 1(c) and 1(f)) well matches the ground-truth and accurately recovers the cluster structure of the trajectories. The root-mean-square error (RMSE) on the test set is 0.032. By contrast, although the test error of NONFAT is close to DEMOTE (0.034), its learned trajectories (Fig. 1(b) and 1(e)) are far from the ground-truth, and fail to reflect the cluster structure. These have shown the advantage of DEMOTE in capturing complex relationships within data to recover the underlying trajectories and their structure.

### Prediction Accuracy

**Datasets.** We next evaluated the predictive performance of DEMOTE in three real-world applications. (1) _CA Weather_(Moosavi et al., 2019) (https://smoosavi.org/datasets/lstw), weather conditions in California from August 2016 to December 2020. We extracted a four-mode tensor for \(7\) different weather _types_, \(6\)_severity levels_, \(30\)_latitudes_ and \(30\)_longitudes_ in GPS coordinates. The entry value is the count of the particular weather condition. We collected \(15\)K observed tensor entry values and the timestamps. (2) _CA Traffic_(Moosavi et al., 2019) (https://smoosavi.org/dataset/lstw), traffic accidents in California from January 2018 to December 2020. We extracted a four

Figure 2: The estimated embedding trajectories for each mode. The color indicates the ground-truth cluster membership.

mode tensor (_traffic type_, _severity level_, _latitudes_, _longitude_). There are 7 traffic types, 6 severity levels, 20 latitudes and 20 longitudes. We collected \(30\)K entry values (accident counts) at different time points. (3) _Server Room_ (https://zenodo.org/record/3610078#.X1NpAigzaM8), temporal temperature records of Poznan Supercomputing and Networking Center. The temperatures were measured at 34 locations, under different air-condition modes (\(24^{}\), \(27^{}\), and \(30^{}\)) and power usage settings (50%, 75% and 100%). Hence, we extracted a three-mode tensor (_location_, _air-condition mode_, _power level_). In total, \(10\)K observed entry values and their timestamps were collected.

**Competing Methods.** The following popular and/or state-of-the-art temporal decomposition approaches were compared. (1) CP-DTLD, discrete-time CP decomposition with linear dynamics, where a conditional prior is placed over successive time steps, \(p(_{j+1}|_{j})=(_{j+1}| _{j}+,v)\); \(\), \(\) and \(v\) were jointly estimated during the CP decomposition. Note that (Xiong et al., 2010) is an instance of this model where \(=\) and \(=\). (2) GP-DTLD and (3) NN-DTLD, similar to CP-DTLD, except using GP (Zhe et al., 2016) and NN decomposition models (similar to (Liu et al., 2019)), respectively. (4) CP-DTND, (5) GP-DTND and (6) NN-DTND -- CP, GP and NN decomposition with nonlinear dynamics, where the conditional prior is \(p(_{j+1}|_{j})=(_{j+1}|( _{j})+,v)\) where \(()\) is a nonlinear activation. The dynamics can therefore be viewed as an RNN transition. (7) CP-CT (Zhang et al., 2021), continuous-time CP factorization, which models the CP coefficients as a time-varying function, with polynomial splines. (8) GP-CT, continuous-time GP decomposition that extends (Xu et al., 2012; Zhe et al., 2016) by plugging the time in the GP kernel so as to estimate the entry value as a function of the embeddings and time, \(m_{}=g(_{_{1}}^{1},,_{_{K} }^{K},t)\). (9) NN-CT, continuous-time NN decomposition, where the input consists of both the embeddings and time \(t\). (10) THIS-ODE (Li et al., 2022), a continuous-time decomposition, where a neural ODE is used to estimate the tensor entry values given the static embeddings and time. (11) NONFAT (Wang et al., 2022), a bi-level latent GP model that uses Fourier bases to estimate factor trajectories for dynamic tensor decomposition.

**Settings and Results.** All the approaches were implemented with PyTorch. The Square Exponential kernel was used for all the GP-related methods, including GP-{DTLD, DTND, CT}. We used the same variational sparse approximation (Hensman et al., 2013) to fulfill scalable posterior inference. Following (Zhe et al., 2016), the number of inducing point was set to \(100\). For the NN decomposition methods, we employed a three-layer network with tanh activation, and for THIS-ODE, we used a one-layer network. The layer width was chosen from {10, 25, 50, 75, 100}. We used tanh as the activation function in the nonlinear dynamic baselines, including {CP, GP, NN}-DTND. For our method, we used the same NN architecture for both the reaction process and entry value prediction, which includes two hidden layers with \(50\) neurons per layer. For CP-CT, we employed \(100\) knots to fulfill the polynomial splines. For each discrete-time method, the number of time steps was chosen from {25, 50, 75, 100} via the cross-validation on the training set. We trained all the models with stochastic mini-batch optimization. We used the ADAM algorithm, and the mini-batch size was set to \(100\). We ran every method with 10K epochs to ensure convergence. The learning rate was automatically adjusted in \([10^{-4},10^{-1}]\) by the ReduceLROnPlateau scheduler. We varied the dimension of the embeddings \(R\) from {2, 3, 5, 7}. For DEMOTE, \(R\) is the number of embedding trajectories; we used computational graphs to obtain the gradient. We followed (Kang et al., 2012; Zhe et al., 2016) to randomly draw \(80\%\) observed entries and their time stamps for training, with the remaining for test. We computed the normalized root-mean-square error (nRMSE). We repeated the evaluation five times and computed the average nRMSE and standard deviation.

Figure 3: Predictive performance of the diffusion and reaction processes.

[MISSING_PAGE_FAIL:9]

We showcase the temporal predictions for two tensor entries. As we can see from Fig. 5, given only a few training points (blue), our method can predict the test points (green) much more accurately, as compared with GPCT, and the predictive uncertainty (reflected by the noise variance \(^{2}\)) is much smaller. This might be due to that via the diffusion-reaction process, and our method can more effectively extract the temporal knowledge from sparse data. For example, DEMOTE successfully captured the periodic nature in the first entry (Fig. 4(b)) while GPCT treated the fluctuation as noises and ended up with much inaccurate predictions and larger predictive variances.

**Computational Efficiency.** We compared the per-epoch/iteration running time DEMOTE with the other methods. We tested all the methods in a workstation with one NVIDIA GeForce RTX 3090 Graphics Card, 10th Generation Intel Core i9-10850K Processor, 32 GB RAM, and 1 TB SSD. The results are shown in Table 2 in Appendix. We can see that the running speed of DEMOTE is comparable to NONFAT and other NN decomposition methods. We also compared with running DEMOTE with naive sampling (DEMOTE-NS). The stratified sampling led to 4x to 22x speed-up.

## 7 Conclusion

We have presented DEMOTE, a neural diffusion-reaction process model to learn dynamic embeddings for dynamic tensor decomposition. The predictive performance is encouraging, and the learned embedding trajectories exhibit interesting patterns. Currently, our method is limited to a small number of entities since it has to integrate the entire multi-partite graph to construct the diffusion process. In the future work, we plan to develop graph cut algorithms to partition the graph into a set of small sub-graphs so that we can construct multiple diffusion processes in parallel so as to scale up our model to big graphs and to large tensors.