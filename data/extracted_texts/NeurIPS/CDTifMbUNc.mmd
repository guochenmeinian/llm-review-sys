# Refined Mechanism Design for Approximately Structured Priors via Active Regression

Christos Boutsikas

Purdue University

cboutsik@purdue.edu

&Petros Drineas

Purdue University

pdrineas@purdue.edu

&Marios Mertzanidis

Purdue University

mmertzan@purdue.edu

&Alexandros Psomas

Purdue University

apsomas@cs.purdue.edu

&Paritosh Verma

Purdue University

verma136@purdue.edu

###### Abstract

We consider the problem of a revenue-maximizing seller with a large number of items \(m\) for sale to \(n\) strategic bidders, whose valuations are drawn independently from high-dimensional, unknown prior distributions. It is well-known that optimal and even approximately-optimal mechanisms for this setting are notoriously difficult to characterize or compute, and, even when they can be found, are often rife with various counter-intuitive properties. In this paper, following a model introduced recently by Cai and Daskalakis , we consider the case that bidders' prior distributions can be well-approximated by a topic model. We design an active learning component, responsible for interacting with the bidders and outputting low-dimensional approximations of their types, and a mechanism design component, responsible for robustifying mechanisms for the low-dimensional model to work for the approximate types of the former component. On the active learning front, we cast our problem in the framework of Randomized Linear Algebra (RLA) for regression problems, allowing us to import several breakthrough results from that line of research, and adapt them to our setting. On the mechanism design front, we remove many restrictive assumptions of prior work on the type of access needed to the underlying distributions and the associated mechanisms. To the best of our knowledge, our work is the first to formulate connections between mechanism design, and RLA for active learning of regression problems, opening the door for further applications of randomized linear algebra primitives to mechanism design.

## 1 Introduction

The design of revenue-optimal auctions is a central problem in Economics and Computer Science. In this problem, a revenue-maximizing seller has \(m\) heterogeneous items for sale to \(n\) strategic bidders. Each bidder \(i\) has a type \(_{i}^{d}\) which contains enough information to encode the bidder's willingness to pay for every subset of items. Bidders' types are private information, and thus, in order to provide meaningful guarantees on the seller's revenue, the standard approach in Economics is to make a Bayesian assumption: types are drawn from a joint distribution \(\).

Assuming a single item for sale and bidders' types that are drawn independently from known distributions, Myerson's seminal work  provides a closed-form solution for the revenue-optimal mechanism. Beyond this single-item case, however, multi-item mechanism design remains an active research agenda, even forty years later. Optimal mechanisms are no longer tractable, in any sense of the word, as well as exhibit various counter-intuitive properties ; see  for a survey. On the otherhand, significant research effort has culminated in numerous compelling positive results, such as simple and approximately optimal auctions , as well as efficient algorithms for computing near-optimal auctions , even with just sampling access to the type distribution .

Despite all this progress, however, there are key challenges in applying these results in practice. First, the computational complexity, sample complexity, approximation guarantees, and communication complexity (i.e., the amount of information the bidder should communicate to the seller) of these results often depend on the number of items \(m\), which could be prohibitively large (e.g., think of \(m\) as the number of items on Amazon.com). Second, bidders' type distributions are typically high-dimensional, or otherwise complex objects, that are not known nor can they be sampled. Instead, the designer might have an estimated distribution \(}\), e.g., through market research, that is close to the real distribution \(\). Motivated by these issues, Cai and Daskalakis  introduce a model where the true type distribution \(_{i}\) of bidder \(i\) is close to a structured distribution \(}_{i}\). Specifically, they assume that there is an underlying design matrix \(^{m k}\) of \(k\) "archetypes," with \(k m\). Intuitively, bidder \(i\) can be approximated by a linear combination of \(k\) archetypal bidders. This same assumption has been central in the study of recommender systems. In this model,  give a framework for transforming a mechanism \(}\) for the low-dimensional distribution \(}_{z}\) into a mechanism for the true type distribution with good revenue guarantees, and whose computational and communication complexity does not depend on the number of items \(m\).

The impact of their work notwithstanding, the above results require strong structural assumptions on: the design matrix \(\); the bidders' valuation functions; and very specific access to (or exact knowledge of) the structured distribution \(}_{z}\) and the mechanism \(}\). _Our work connects the recommender system approaches for mechanism design with recent progress on Randomized Linear Algebra for active learning for regression problems. We relax, and even remove these restrictive assumptions, and open the door to future exploration of more elaborate recommender system models in the context of mechanism design, using randomized linear algebra primitives._

**The framework and results .** To place our results in context, we start with a brief overview of , which considers a setting where the type distribution \(_{i}\) of bidder \(i\) is close to a distribution \(}_{i}\) in the Prokhorov distance, under the \(_{}\) norm (Definition 1). Here, \(}_{i}\) first samples a vector \(^{k}\) from a low-dimensional distribution \(}_{z\,i}\), and then outputs \(\), where \(^{m k}\) is a known matrix. The proposed framework has a learning and a mechanism design component.

Their learning component consists of a communication-efficient1 query protocol \(\) for interacting with each bidder \(i\) such that, if the type \(_{i}\) of bidder \(i\) satisfies \(\|_{i}-\|_{}\), the query protocol outputs a vector \((_{i})\) such that \(\|(_{i})-\|_{}_{}\).2 give such query protocols under strong (distinct) conditions on \(\), and specifically when \(\): _(i)_ satisfies an assumption similar to the separability condition of , _(ii)_ is generated from a distribution where each archetype is an independent copy of an \(m\)-dimensional Gaussian, or _(iii)_ is generated from a distribution where each archetype is an independent copy of an \(m\)-dimensional, bounded distribution with weak dependence. We discuss these restrictions in more detail in Appendix D.4.1. The query complexity, as well as the error \(_{}\), depend on them, but, importantly, are independent of the number of items \(m\).

Their mechanism design component is a refinement of a robustification result of . For this transformation to work, one needs to interact with the mechanism and the underlying distributions using highly non-trivial operations, which are computationally demanding, and require exact knowledge of bidders' valuation functions. In our work we overcome this issues by developing new reductions and plugging them in the framework established by  and . The overall interplay between the different mechanism design and active regression components can be seen in Fig. 1.

Combining the two components,  obtain mechanisms for \(\), for constrained-additive bidders.3 In these mechanisms, each bidder is required to answer a small number of simple Yes/No queriesof the form "are you willing to pay \(p\) for item \(j\)?", such that the loss in revenue and the violation in incentive compatibility do not depend on the number of items \(m\).

### Our contributions

**Randomized Linear Algebra (RLA) for active learning.** RLA for active learning has focused on solving regression problems of the form

\[=_{}\|-\|_{p},\]

for \(_{p}\) norms with \(1 p<\), by querying _only_ a subset of elements of the vector \(\). In prior work on RLA for active learning, the focus has been on recovering an approximate solution that achieves a relative error or constant factor approximation to the optimum loss. We adapt these bounds to our setting, which could include noisy instead of exact queries, and prove bounds for the \(_{p}\) norm error of the exact minus the approximate solution. Specifically, we bound \(\|(_{i})-\|_{p}_{p}\). We provide bounds on \(_{p}\) for all integers \(1 p<\). Our bounds depend on the modelling error \(\|-\|_{p}\) and some measure of the query noise (see Definitions 4 and 5); both dependencies are expected. Importantly, our bounds hold for _arbitrary archetype matrices_, very much unlike the work of , which focused on very restricted classes of matrices. A single property of the archetype matrix, the smallest singular value with respect to the \(_{p}\) induced matrix norm, \(_{,p}()\), can characterize the quality of the error. As \(_{,p}()\) decreases, the error \(_{p}\) grows. Intuitively, \(_{,p}()\) is a measure of independence of the archetypes, with small values corresponding to linearly dependent archetypes. The query complexity needed to achieve error \(_{p}\) is almost linear (up to logarithmic factors) on \(k\) for \(p=1\) and \(p=2\), and grows with \(k^{p/2}\) for \(p 3\). Our query complexity bounds have no dependency on \(m\) (number of items) or \(d\) (dimensionality of a type) enabling us to produce results way beyond constrained-additive valuations, as \(d=2^{m}\) dimensions suffice to encode _arbitrary_ valuation functions.

It is critical to highlight that our ability to provide bounds on the approximation error for arbitrary archetype matrices is, at least partly, due to leveraging information from the archetype matrix \(\). Specifically, we use this information to select which bidder types to query, instead of just querying types uniformly at random. This information involves the computation or approximation of the well-studied leverage scores of \(\) for \(p=2\) and of the so-called Lewis weights for all other values of \(p\) (see Section 3.1). We do note that in our framework, the errors due to the modeling of the bidder type \(\) as the product \(\) and the query noise are always bounded by the respective \(_{p}\) norm. Thus, our models are more restrictive compared to the \(_{}\) norm models of . However, to the best of our knowledge, even assuming such restrictive models, the results and tools of prior work do not extend to arbitrary archetype matrices. This is precisely the gap that is bridged by our work, using RLA for active learning of \(_{p}\) norm regression for \(1 p<\).

**Mechanism Design.** On the mechanism design front, our main contribution is relaxing the assumptions of  on the type of access needed to the low-dimensional distribution and the mechanism for it. Specifically, we further refine the robustification result of Brustle et al.  and remove the need for the aforementioned strong oracle.

The main difficulty of transforming mechanisms for one distribution into mechanisms for another distribution is that the two distributions might not share the same support. The crux of the issue is that the incentive constraints are very delicate; a small change in the underlying distribution may drastically change the agents' _valuation distribution_ over the mechanisms' outcomes. One way to tame the distribution of outcomes is to map bids that are not in the support of the initial distribution, to bids that are. Brustle et al.  do this by "optimally misreporting" on behalf of the bidder, by calculating \(*{argmax}_{_{i}^{} supp(} _{z,i})}_{_{-i}}_{z,-i}}[u_{i}(v _{i},}(_{i}^{},_{-i}))]\), where \(}_{z,i}\) is a rounded-down version of \(}_{z,i}\). As we've discussed, for this operation to be viable, many things need to be assumed about what the designer knows and can compute about \(}\), \(}_{z,i}\), and the bidder's valuation function. Our approach, instead, leverages the fact that when two distributions are close in Prokhorov distance, under any \(_{p}\) norm, _any_ point on the support of one distribution is close to a point on the support of the other, with high probability. Our construction simply maps a report \(_{i}\) to the "valid" report (approximately) closest to \(_{i}\) in \(_{p}\) distance. This operation is linear on the support size. Furthermore, our overall robustification result holds for all norms, not just \(_{}\), and our construction is completely agnostic to bidders' valuation functions.

**Combining the components.** Combining the two components we can, without any assumptions on \(\), given a mechanism for the low-dimensional prior, design mechanisms with comparable revenue guarantees, where each bidder is required to answer a small number of queries. Our queries ask a bidder her value for a subset of items, and our mechanism can accommodate _any_ valuation function, significantly extending the scope of our results.

**Related Work.** Aside from the work of , on the mechanism design front, the most relevant works are , that consider learning multi-item auctions given "approximate" distributions, and , that consider learning multi-item auctions when type distributions are correlated, yet admit special structure. On the RLA front, we leverage and adapt multiple recent results on approximating \(_{p}\) regression problems in an active learning setting. We discuss prior work on RLA for active learning and its connections to our setting in Section 3.1 and Appendix D.

## 2 Preliminaries

Let \([n]\{1,2,,n\}\) denote the first \(n\) natural numbers. A revenue-maximizing seller has a set \([m]\) of \(m\) heterogeneous items for sale to \(n\) strategic bidders indexed by \([n]\). Bidder \(i\) has a private type vector \(_{i}^{d}\), and the types of all bidders are represented by a _valuation profile_\(=(_{1},,_{n})\). Bidder \(i\) has a valuation function \(v_{i}:^{d} 2^{[m]}_{+}\), that takes as input the bidder's type and a (possibly randomized4) set of items \(S[m]\) and outputs the bidder's value for \(S\). Note that \(d 2^{m}\), since expressing a valuation function requires at most one real number per subset of items. Types are drawn independently. Let \(=_{i[n]}_{i}\) be the distribution over bidders' types, \(_{-i}=_{j[n]/\{i\}}_{j}\) be the distribution of all bidders excluding \(i\), and \(supp()\) be the support of a distribution \(\).

**Mechanisms.** A mechanism \(=(x,p)\) is a tuple where \(x:^{nd}_{+} 2^{[nm]}\) is the allocation rule, and \(p:^{nd}_{+}^{n}_{+}\) is the payment rule, which map _reported_ types to allocations of the items and payments, respectively. Specifically, \(x_{i,j}()(x())_{i,j}\) denotes the probability that bidder \(i\) receives item \(j\) for input valuation profile \(\), and \(p_{i}()(p())_{i}\) denotes the amount bidder \(i\) has to pay. Let \(u_{i}(_{i},())\) be the utility of bidder \(i\) with type \(_{i}\) for participating in mechanism \(\), under reports \(\). Bidders are risk-free and quasi-linear i.e., \(u_{i}(_{i},())=[v_{i}(_{i},x())-p_{i}()]\), where the expectation is taken over the randomness of the allocation rule. Since we only consider truthful mechanisms, unless stated otherwise, reported types will be the same as the true types.

A bidder's objective is to maximize her utility. The seller strives to design mechanisms that incentivize bidders to report truthfully. We use the following notions of truthfulness. A mechanism \(\) is _\(\)-Bayesian Incentive Compatible (\(\)-BIC)_, if for each bidder \(i[n]\), any type \(_{i}\) and misreport \(^{}_{i}\) we have that: \(_{_{i}_{-i}}[u_{i}(_{i},(_{i},_{-i}))]_{_{-i} _{-i}}[u_{i}(_{i},(^{}_{i}, _{-i}))]-\). A mechanism \(\) is \((,)\)-BIC if for each bidder \(i[n]\), and any misreport \(^{}_{i}\) we have that:

\[_{_{i}_{i}}[_{-i} _{-i}}{}[u_{i}(_{i},(_{ i},_{-i}))]_{-i}_{-i}}{ }[u_{i}(_{i},(^{}_{i}, _{-i}))]-] 1-.\]

A \((,0)\)-BIC mechanism is a \(\)-BIC mechanism; a \(0\)-BIC mechanism is simply BIC. Finally, a mechanism \(\) is _ex-post Individually Rational (IR)_ if for all valuation profiles \(\) and all bidders \(i n\), \(u_{i}(_{i},(_{i},_{-i})) 0\). The seller's objective is to maximize her expected _revenue_. For a mechanism \(\) and distribution \(\) we denote the expected revenue as \(Rev(,)=_{}[_ {i[n]}p_{i}()]\). Note that, we are calculating revenue assuming truthful reports, even for, e.g., \((,)\)-BIC mechanisms.

**Statistical Distance.** In this work we design mechanisms that work well, as long as they are evaluated on distributions that are "close" to \(\). Here, we define the notion of distance between two probability measures that we use throughout the paper.

**Definition 1** (Prokhorov Distance).: _Let \((,d)\) be a metric space and \(\) be a \(\)-algebra on \(\). For \(A\), let \(A^{}=\{x: y A(x,y)<\}\) where \(\) is some distance metric. Two probability measures \(P\), \(Q\) on \(\) have Prokhorov distance: \(inf\{>0:P(A) Q(A^{})+Q(A) P(A^{})+, A \}\). We choose \(\) to be the \(_{p}\)-distance, and we denote the Prokhorov distance between measures \(P,Q\) as \(_{p}(P,Q)\)._The following is an equivalent characterization of Prokhorov distance due to Strassen .

**Lemma 1** ().: _Let \(\) and \(^{}\) be two distributions supported on \(^{n}\). \(_{p}(,^{})\) iff there exists coupling \(\) of \(\) and \(^{}\), such that \(_{(,)}[\|-\|_{p}> ]\)._

**Recommendation system-inspired model.** We assume that, for each bidder, there exists a known design matrix \(^{d k}\)5, where the columns of \(\) represent \(k\) "archetypes", for a constant \(k\). Our results hold if these matrices are different for each bidder, however, for ease of notation we will assume all bidders have the same design matrix. For each bidder \(i\) there exists a distribution \(}_{z,i}\) supported on the latent space \(^{k}\). Let \(}_{i}=}_{z,i}\) be the distribution induced by multiplying a sample from \(}_{z,i}\) with the design matrix \(\), i.e., \(}_{i}\) is the distribution of \(\) where \(}_{z,i}\).

The valuation function over the latent types is defined as \(v_{i}^{}(_{i},S) v_{i}(_{i},S)\) for any bundle \(S[m]\). We will use the following notion of Lipschitz continuity for valuation functions.

**Definition 2** (Lipschitz Valuation).: _A valuation function \(v(,):^{d}^{m}_{+}\) is \(\)-Lipschitz, if for any two types \(,^{}^{d}\) and any bundle \(S[m]\), \(|v(,S)-v(^{},S)|\|-^{}\|_{}\)._

We include a table, Table 1, with all the notation used throughout the paper in the appendix.

## 3 Active Learning for Regression and Mechanism Design

In this section, we state our main results, deferring all technical proofs to the appendix. We present mechanisms that are completely agnostic with respect to \(\), the distribution from which bidders' types are drawn from. However, we have limited access (described later in this section) to _(i)_ a design matrix \(\); _(ii)_ distributions \(}_{z,i}\) over \(^{k}\), where for all \(i[n]\), \(_{p}(_{i},}_{z,i}) _{,p}\) for some \(_{,p}>0\); and _(iii)_ a mechanism \(}\) for \(}_{z}=_{i[n]}}_{z,i}\). This limited access to the design matrix motivates the use of active learning, which deals precisely with settings where the algorithm is allowed to (interactively) query a subset of the available data points for their respective labels (see  for precise definitions of the active learning setting in regression problems). Our approach is modular and starts by building an active learning component for regression problems (Section 3.1) followed by the mechanism design component (Section 3.2). We combine the two components to get an overall mechanism for \(\) in Section 3.3.

### Active learning for regression via Randomized Linear Algebra

Our objective is to design a communication-efficient, active learning query protocol for the seller that interacts with each bidder \(i\), and infers their type \(_{i}^{d}\) by accessing only a small subset of elements of the type vector (as \(d\) is very large). We use \(\) to denote the query protocol, whose output is a vector in the low-dimensional latent space \(^{k}\). A bidder interacts with the query protocol _truthfully_ if it is in her best interest to evaluate functions requested by the protocol on her true private type \(_{i}\). We use \((_{i})^{k}\) to denote the output of \(\) when interacting with a truthful bidder with type \(_{i}\). We now define the notion of an \((_{,p},_{p},p)\)-query protocol and the notion of _query noise_.

**Definition 3** (\((_{,p},_{p},p)\)-query protocol).: \(\) _is called an \((_{,p},_{p},p)\)-query protocol, if, for all \(^{d}\) and \(^{k}\) satisfying \(\|-\|_{p}_{,p}\), we have \(\|-()\|_{p}_{p}\)._

**Definition 4** (Query noise).: _Let \(_{i}\) be the true type of a bidder. Our query protocol can access entries of \(_{i}+_{,}\), where \(_{,}\) is an (unknown) vector. The query noise \(_{,}\) satisfies \(\|,}}\|_{p}_{ ,p}\)._

The query noise depends on the specifics of the interactions between the seller and the bidder. For example, if the seller is only allowed to ask queries of the form "'what is your value for the subset \(S\)?", the query noise \(_{,p}\) is equal to zero. Our bounds will also depend on the _model error_.

**Definition 5** (Model error).: _Given a valuation profile \(^{nd}\), the model error is \(_{,p}\) if, for all \(i[n]\), there exists a \(_{i}^{k}\) such that \(\|_{i}-_{i}\|_{p}_{,p}\)._

Note that, we don't have bounds of the form "\(\|_{i}-_{i}\|\)" for individual types, but for the distributions \(_{i}\) and \(}_{z,i}\). The characterization of Prokhorov distance (Lemma 1) allows us to relate the two quantities in the proofs that follow.

We now rephrase the above discussion in order to cast it in the framework of Randomized Linear Algebra _(RLA)_ and active learning. Dropping the index \(i\) for notational simplicity, we assume that \(\) and we seek to recover an approximate solution vector \(()\) such that the \(_{p}\) norm error between the approximate and the optimal solution is bounded. _Importantly_, the query protocol \(\) is _not_ allowed full access to the vector \(\) in order to construct the approximate solution vector. This is a well-studied problem in the context of RLA: the learner is given a large collection of \(k\)-dimensional data points (the \(d k\) rows of the design matrix \(^{d k}\)), but can only query a small subset of the real-valued labels associated with each data point (elements of the vector \(^{d}\)). Prior work in RLA and active learning has studied this problem in order to identify the optimal number of queries that allow efficient, typically relative error, approximations of the loss function. In our parlance, prior work has explored the existence of query protocols that construct a vector \(()\) such that

\[\|-()\|_{p}_{p}\|-\|_{p},\] (1)

where \(_{p}>1\) is an error parameter that controls the approximation accuracy. Of particular interest in the RLA literature are _relative error_ approximations, with \(_{p}=1+\), for some small \(>0\); see  for a detailed discussion. However, relative error approximations are less important in our setting, since our protocols in Section 3.2 necessitate \(_{p}_{,p}\). For \(p=2\), the underlying problem is active learning for least-squares regression:  analyzed its complexity (namely, the number of queries) of query protocols in this setting, eventually providing matching upper and lower bounds. Similarly, for \(p=1\), the underlying problem is active learning for least absolute deviation regression, a robust version of least-squares regression:  analyzed the complexity of query protocols in this setting. The query protocols of  are straightforward: they sample a small set of labels (i.e., bidder types) and elicit the bidder's preferences for this set. Then, the respective \(_{p}\) norm regression problem is solved on the smaller set and the resulting solution is returned as an approximation to the original solution.6 The types to be sampled (see Appendix D.1 for details) are selected using distributions that can be constructed by accessing _only_ the design matrix \(\). Specifically, for the \(p=2\) case, one needs to compute or approximate the _leverage scores_ of the rows of the matrix \(\). For the \(p=1\) case, one needs to compute or approximate the _Lewis weights_ of the design matrix \(\). (The Lewis weights are an extension of the leverage scores to \(_{p}\) norms for \(p 2\).) The work of  for the \(p=2\) case involves more elaborate query protocols, using primitives such as volume sampling and the Batson-Spielman-Srivastava sparsifier to improve the query complexity. Finally, the \(p>2\) case for active learning for regression problems was recently resolved in ; we discuss their approach in our context in Appendix D.2.

To the best of our knowledge, our work is the first one to formulate connections between mechanism design and Randomized Linear Algebra for active learning. Two technical points of departure that are needed in order to adapt the RLA work for active learning to the mechanism design framework are: _(i)_ we need to derive bounds of the form of eqn. (1) for the \(_{p}\) norm distance between the exact and approximate solutions, whereas prior work typically bounds the error of the _loss_ function when an approximate solution is used; and _(ii)_ the entries of the bidder's type vector \(\) might not be known exactly, but only up to a small error. The latter assumption corresponds to the use of _noisy queries_ in the model of  and is known to be equivalent, up to logarithmic factors, to _threshold queries_ via binary search. Our work addresses both technicalities and seamlessly combines the RLA work for active learning with mechanism design.

Prior to stating our main result, we need to define a fundamental property of the design matrix \(^{d k}\) that will affect the approximation error. Let

\[_{,p}()=_{^{k},\ \|\|_{p}=1}\|\|_{p}.\] (2)

For \(p=2\), this is simply the smallest singular value of the matrix \(\). For other values of \(p\), the above definition is the standard generalization of the smallest singular value of \(\) for the induced matrix \(_{p}\) norm. Notice that \(_{,p}()\) is a property of the matrix \(\) and can be computed _a priori_ via, say, the QR factorization or the Singular Value Decomposition (SVD) for \(p=2\) and via linear programming for \(p=1\). As we will see in Theorem 1 below, smaller values of \(_{,p}()\) result in increased sample complexity for our query protocols.

**Theorem 1**.: _Let \(^{d k}\) be the design matrix, and recall the definitions of the model error \(_{,p}\) (Definition 5) and the query noise (Definition 4). For all integers \(1 p<\), there exist query protocols \(\) using \(s_{p}\) queries for each bidder \(i[n]\), such that, with probability at least \(1-\),_

\[\|_{i}-(_{i})\|_{p}(_ {,p}+_{,p})}{_{,p}()}= _{p}\]

_holds for all \(n\) bidders \(i[n]\). Here \(c_{p}\) is a small constant that depends on \(p\).7 The respective query complexities for \(p=1\) and \(p=2\) are (asymptotically) identical:_

\[s_{1}=s_{2}=O(k k}{{}}).\] (3)

_For \(p 3\), the query complexity is_

\[s_{p}=O(k^{}{{2}}}^{3}k}{{ }}).\] (4)

Several comments are in order. _(i)_ The error \(_{p}\) is a small constant times the modelling error plus the error due to noisy queries. In the limit case where the modelling error is equal to zero and the queries are noiseless, the bidders' types can be recovered exactly in our framework. However, as the modelling error and the query noise increase, approximating user types becomes harder and less accurate. _(ii)_ Importantly, the approximation accuracy of Theorem 1 grows linearly with the inverse of the smallest \(_{p}\) norm singular value of the design matrix \(\). Our results indicate that the approximation accuracy of the query model \(\) depends on this simple property of the design matrix \(\). For example, focusing on the \(p=2\) case, our theorem shows that as the archetypes (columns of the matrix \(\)) become more linearly dependent and the smallest singular value approaches zero, the error of our approximation worsens. This is quite reasonable: if archetypes are linearly dependent, then it is increasingly difficult to approximate the respective entries of the vector \(\). _(iii)_ The query complexities \(s_{1}\) and \(s_{2}\) are asymptotically identical, growing linearly with \(k k\), where \(k\) is the number of archetypes. They both depend on the log of the number of bidders (due to a union bound) and on the log of \(}{{}}\), where \(\) is the failure probability. The query complexity for \(p 3\) is larger and is dominated by the \(k^{}{{2}}}\) term. Importantly, the query complexity remains independent of \(d\), the number of bidder types, which, in worst case, could be exponential to the number of underlying items. _(iv)_ Improving the sampling complexities \(s_{1}\) and \(s_{2}\) has been a topic of intense interest in the RLA community and we defer the reader to , which has essentially provided matching upper and lower bounds for various values of \(p\). We just note that for the well-studied \(p=2\) case, volume sampling approaches  achieve essentially matching bounds, while the work of  removes (at least in expectation) the \( k\) factor from \(s_{2}\), at the expense of significant additional protocol complexity. From a technical perspective, we note that \(_{p}_{,p}\), as necessitated in Theorem 2 and that our query protocols are all one-round protocols.

Finally, notice that our theorem works for all \(p 1\), but not for \(p=\), which was the setting of . In Appendix D.4, we present a (modest) improvement of the result of  and explain why it seems improbable that the \(p=\) case can be generalized to a much broader class of design matrices. This is a strong motivating factor to explore properties of mechanism design for the recommender system setting for other \(_{p}\) norms, as we do in this work.

### The Mechanism Design component

The goal of the mechanism design component is to transform a mechanism \(}\) for \(}\) into a mechanism \(\) for \(_{z}\). We first define exactly the type of access to \(}_{z}\) and \(}\) our construction requires.

**Definition 6** (Access to \(}\)).: _By "query access to \(}\)" we mean access to an oracle which, given a valuation profile \(\), outputs the allocation and payments of \(}\) on input \(\)._

**Definition 7** (Access to \(}_{z}\)).: _By "oracle access to \(}\)" we mean access to (1) a sampling algorithm \(_{i}\) for each \(i[n]\), where \(_{i}(,)\) draws a sample from the conditional distribution of \(}_{z,i}\) on the \(k\)-dimensional cube \(_{j[k]}[x_{j},x_{j}+_{j})\), and (2) an oracle which, given as input a type \(_{i}\) for bidder \(i\), outputs the type in the support of \(}_{z,i}\) that is closest to \(_{i}\) in \(_{p}\) distance, i.e., outputs \(argmin_{_{i}^{} supp(}_{z,i})}\|_ {i}-_{i}^{}\|_{p}\)._If the allocation is randomized, our approach works even if the query to the oracle returns a (correct) deterministic instantiation of the randomized allocation.8

In Definition 7, the first part of our oracle access (sampling from the conditional) is also necessary in . The second part is new to our work, and replaces a strong requirement in . In more detail, given a type \(_{i}\), Cai and Daskalakis  (as well as Brustle et al. ) need to know if \(_{i} supp(}_{z,i})\), and, if not, need access to \(argmax_{_{i}^{} supp(}_{z,i})}\, _{_{-i}}_{z,-i}}[u_{i}(v_{i},}( _{i}^{},_{-i}))]\) where \(}_{z,i}\) is a rounded-down version of \(}_{z,i}\). However, for arbitrary distributions and mechanisms, this task might be computationally inefficient, or simply infeasible. In our work, we need access to \(argmin_{_{i}^{} supp(}_{z,i})}\| _{i}-_{i}^{}\|_{p}\) in the "no" case.

Given these definitions, our main theorem for this component is stated as follows.

**Theorem 2**.: _Let \(=_{i=1}^{n}_{i}\) be the bidders' type distribution and \(v_{i}:^{d} 2^{[m]}_{+}\) be a \(\)-Lipschitz valuation function for each bidder \(i[n]\). Also, let \(^{d k}\) be a design matrix and \(}_{z}=_{i=1}^{n}}_{z,i}\), where \(}_{z,i}\) is a distribution over \(^{k}\) for each \(i[n]\)._

_Suppose that we are given (1) query access to a mechanism \(}\) that is IR and BIC w.r.t. \(}_{z}\) and valuations \(\{v_{i}^{}\}_{i[n]}\), (2) oracle access to \(}_{z}\), and (3) any \((_{,p},_{p},p)\)-query protocol \(\) with \(_{p}_{,p}\). Then, we can construct a mechanism \(\) that is oblivious to \(\) and \(v(,)\), such that for all \(\) that satisfy \(_{p}(_{i},}_{z,i})_ {,p}\) for all \(i[n]\), the following hold: (1) \(\) only interacts with every bidder using \(\) once, (2) \(\) is IR and \((,)\)-BIC w.r.t. \(\), where \(=O(})\) and \(=O(n\|\|_{}})\), and (3) the expected revenue of \(\) is at least \(Rev(},}_{z})-O(n)\)._

Note that \(\) is an indirect mechanism, so it is slightly imprecise to call it \((,)\)-BIC. Formally, interacting with \(\) truthfully is an approximate Bayes-Nash equilibrium.

In order to prove Theorem 2, we use a key lemma, Lemma 2, which establishes the robustness guarantees of Theorem 2, but in the space of latent types. Intuitively, let \(_{i}\) be the type of bidder \(i\), and \(_{i}\) be a random variable distributed according to \(}_{z,i}\). We know that \(_{p}(_{i},}_{i})_ {,p}_{p}\). Due to Lemma 1, there exists a coupling such that with probability greater than \(1-_{p}\), \(\|_{i}-_{i}\|_{p}_{p}\). Since the seller uses a \((_{,p},_{p},p)\)-query protocol, with probability at least \(1-_{p}\), \(\|(_{i})-_{i}\|_{p}_{p}\). Note that, this implies that \(_{i}\) and \((t_{i})\) are distributed such that their Prokhorov distance is at most \(_{p}\). At this step, Lemma 2 provides us a mechanism \(}\), constructed from \(}\), that we can execute on types \((_{1}),,(_{n})\), obtained by interacting with the bidders via the query protocol. With probability at least \(1-_{p}\), we have that \(\|_{i}-_{i}\|_{}\|_{i}- _{i}\|_{p}_{,p}\) and thus, using the fact that the query protocol ensures \(\|(_{i})-_{i}\|_{p}_{p}\) as well, we have \(\|_{i}-(_{i})\|_{} _{,p}+k\|\|_{}_{p}\). The guarantees of \(}\) for the distribution over \((_{i})\)s are therefore translated into guarantees (with a small error) of the overall mechanism for the \(\).

The proof of Lemma 2 is quite involved and is the main focus of our analysis. Here, we sketch the key ideas behind the proof, and defer all formal arguments to Appendix C. The proof uses the following notion of a rounded distribution.

**Definition 8** (Rounded Distribution).: _Let \(\) be a distribution supported on \(_{ 0}^{k}\). For any \(>0\) and \([0,]^{k}\), we define function \(r^{(,)}:_{ 0}^{k}_{ 0}^{k}\) such that \(r_{i}^{(,)}()=max\{-_{i}}{ }+_{i},0\}\) for all \(i[k]\). Let \(\) be a random vector sampled from \(\). We define \(_{,}\) as the distribution for the random variable \(r^{(,)}()\), and we call \(_{,}\) the rounded distribution of \(\)._

We follow an approach similar to Brustle et al. . The main idea is that arguing directly about mechanisms for distributions that are close in Prokhorov distance is difficult. On the flip side, arguing about mechanisms for distributions that are close in total variation distance is much easier, since the total variation is a more stringent (and hence more tunable) notion of distance. The key observation is that, if two distributions are close in Prokhorov distance then, in expectation over the random parameter \(\), their rounded-down versions are close in total variation distance.

Our overall construction is via three reductions. First, in Lemma 3, given a mechanism for \(}_{z}\) we design a mechanism for the rounded-down version. Second, in Lemma 4, given a mechanism for the rounded-down \(}_{z}\) we design a mechanism for \(_{z}_{,}\), which maintains its guarantees if \(_{p}(_{z},}_{z})\) is small. Third, in Lemma 5, given a mechanism for \(_{z}_{,}\) we design a mechanism for \(_{z}\). Fig. 1 presents a detailed overview of the overall design architecture, and how the RLA and different mechanism design components interact.

Our proofs for Lemmas 3 and 5 are adaptations of the corresponding lemmas of , where our main task is to flesh out the exact dependence on the dimensionality of the latent space and the \(_{p}\)-norm (versus the \(_{1}\)-norm in ). The novelty of our approach comes in the construction and analysis of Lemma 4. The difficulty of transforming mechanisms for \(}_{z}_{,}\) into mechanisms for \(_{z}_{,}\) is that the two distributions might not share the same support. Thus, we need a way to map bids that are not in the support of \(}_{z}_{,}\) to bids that are. Brustle et al.  do this by "optimally misreporting" on behalf of the bidder, by calculating \(argmax_{ supp(}_{z,i}_{ ,})}_{b_{-i}(}_{z})_{-i} _{,}}[u_{i}(v_{i},}(,_{-i}))]\), and then picking matching payments that make the overall mechanism IR. Our approach leverages the fact that \(}_{z,i}\) and \(_{z,i}\) are close in Prokhorov distance, and thus any point on the support of one distribution is close to a point on the support of the other, with high probability. An ideal construction would map a report \(_{i}\) to the "valid" report (i.e., a report in the support of \(}_{z,i}_{,}\)) that minimizes the \(_{p}\) distance to \(_{i}\). This operation is linear on the support of \(}_{z,i}_{,}\), and does not need any information on the valuation functions, nor on the actual probabilities that elements of the distribution are sampled with. Unfortunately, our assumption on what "oracle access" means does not allow us to do this operation (finding the closest point w.r.t. \(_{p}\)) on \(}_{z,i}_{,}\), but only on \(}_{z,i}\); we prove that, by occurring a small loss, our assumption suffices.

Figure 1: Agents interact with the query protocol \(\), which learns their latent types \((_{i})\)s. The mechanism design component (which is oblivious to the distributions of the true agents’ types \(\)) then uses these to produce the final allocation and payments, utilizing only query access to \(}\) and sampling access to \(}_{z}\) such that the overall framework is approximately \((,)\)-BIC wrt \(\).

### Putting everything together

Combining Theorems 1 and 2, we can give mechanisms for concrete settings. Formally, we have the following theorem.

**Theorem 3**.: _Under the same setting as in Theorem 2, for bidders with arbitrary valuation functions, we can construct mechanism \(\) using only query access to the mechanism \(}\) (Definition 6) and oracle access to distribution \(}\) (Definition 7), and oblivious to the true type distribution \(\). We consider queries (to each bidder \(i\)) of the form "What is your value for the subset of items \(S\)?"_

_Mechanism \(\) is IR and \((,)\)-BIC w.r.t. \(\), where \(=O(})\) and \(=O(n\|\|_{}})\), and the expected revenue of \(\) is at least \(Rev(},}_{z})-O(n)\). Additionally, with probability at least \(1-\),_

\[_{p}=c_{p}(_{,p}())^{-1} _{,p}\]

_for a small constant \(c_{p}\) that depends on the parameter \(p\) (see footnote 7). The number of queries is \(O(k k(}{{}}))\) and \(O(k^{}{{2}}}^{3}k(}{{}}))\) for \(p=1,2\) and \(p 3\), respectively._

The proof of Theorem 3 follows from Theorem 2 and Theorem 1, and is deferred to Appendix B.

As we've already discussed, the main mechanism of Cai and Daskalakis  requires bidders to have constrained-additive valuations9, as well \(\) to satisfy a number of restrictions. Here, we completely remove both conditions. On the flip-side,  ask bidders weaker queries, of the form "are you willing to pay price \(\) for item \(j\)?" Using such queries, one can binary search over \(\), and drive down the query noise (see Definition 4). For \(_{}\), the extra cost of such an operation would be \((\|\|_{}/)\), where \(\) is the desired accuracy. However, for other \(p\)-norms, for the same target accuracy, this operation requires an extra factor of \(((d^{1/p}))\) queries, giving a dependence on \(d\).

## 4 Conclusions and Future Work

In this paper, we study mechanism design for prior distributions close to a topic model, inspired from the recommender systems literature. We formulate connections between mechanism design and Randomized Linear Algebra for active learning for regression problems, importing state-of-the-art results from Randomized Linear Algebra to mechanism design, and alleviate or relax restrictive assumptions of prior work. Developing a deeper understanding of such connections is an important direction for future research. For example, one could study this and other topic models in the context of mechanism design for correlated bidders, two-sided markets, information structure design, etc. Additionally, another interesting open problem would be to develop a framework for proving lower bounds for mechanism design (e.g., lower bounds on the query complexity for single-round or multi-round protocols used to communicate with the bidders) using known limitations of algorithms in active learning, and vice-versa.

#### Acknowledgements

Christos Boutsikas, Petros Drineas and Marios Mertzanidis are supported in part by a DOE award SC0022085, and NSF awards CCF-1814041, CCF-2209509, and DMS-2152687. Alexandros Psomas and Paritosh Verma are supported in part by an NSF CAREER award CCF-2144208, a Google Research Scholar Award, and a Google AI for Social Good award.