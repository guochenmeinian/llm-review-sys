# xLSTM: Extended Long Short-Term Memory

Maximilian Beck\({}^{\;\;1,2,3}\) &Korbinian Poppel\({}^{\;\;1,2,3}\) &Markus Spanring \({}^{1}\) &Andreas Auer \({}^{1,2}\) &Oleksandra Prudnikova \({}^{1}\) &Michael Kopp &Gunter Klambauer \({}^{1,2,3}\) &Johannes Brandstetter \({}^{1,2,3}\) &Sepp Hochreiter \({}^{1,2,3}\)

\({}^{}\)Equal contribution

\({}^{1}\)ELLIS Unit, LIT AI Lab, Institute for Machine Learning, JKU Linz, Austria

\({}^{2}\)NXAI Lab, Linz, Austria, \({}^{3}\)NXAI GmbH, Linz, Austria

###### Abstract

In the 1990s, the constant error carousel and gating were introduced as the central ideas of the Long Short-Term Memory (LSTM). Since then, LSTMs have stood the test of time and contributed to numerous deep learning success stories, in particular they constituted the first Large Language Models (LLMs). However, the advent of the Transformer technology with parallelizable self-attention at its core marked the dawn of a new era, outpacing LSTMs at scale. We now raise a simple question: How far do we get in language modeling when scaling LSTMs to billions of parameters, leveraging the latest techniques from modern LLMs, but mitigating known limitations of LSTMs? Firstly, we introduce exponential gating with appropriate normalization and stabilization techniques. Secondly, we modify the LSTM memory structure, obtaining: (i) sLSTM with a scalar memory, a scalar update, and new memory mixing, (ii) mLSTM that is fully parallelizable with a matrix memory and a covariance update rule. Integrating these LSTM extensions into residual block backbones yields xLSTM blocks that are then residually stacked into xLSTM architectures. Exponential gating and modified memory structures boost xLSTM capabilities to perform favorably when compared to state-of-the-art Transformers and State Space Models, both in performance and scaling.

Code available at: https://github.com/NX-AI/xlstm

## 1 Introduction

The Long Short-Term Memory (LSTM) ideas (Hochreiter, 1991; Hochreiter and Schmidhuber, 1997b, a), i.e., the constant error carousel and gating, were introduced to overcome the vanishing gradient problem of recurrent neural networks (Hochreiter, 1991; Hochreiter et al., 2000):

\[}\;=\;\;}\;\;}\;+\;}\;}\;, h_{t}\;=\;}\;\;(})\;.\] (1)

The constant error carousel is the additive update of the cell state \(c_{t-1}\) (green) by cell inputs \(z_{t}\) and moderated by sigmoid gates (blue). The input gate \(_{t}\) and the forget gate \(_{t}\) control this update, while the output gate \(_{t}\) controls the output of the memory cell, i.e. the hidden state \(h_{t}\). The cell state is normalized or squashed by \(\) and then output gating gives the hidden state.

LSTMs have been successfully applied to various domains (Hochreiter et al., 2001, 2007; Schmidhuber, 2015), and prevailed over text generation until the dawn of Transformers in 2017 (Vaswani et al., 2017). The effectiveness of LSTMs has been demonstrated at numerous sequence-related tasks such as generating text (Graves, 2013; Karpathy, 2015), generating handwritings (Graves, 2013), sequence-to-sequence translation (Sutskever et al., 2014), evaluating computer programs (Zaremba and Sutskever, 2014), generating image captions (Karpathy and Fei-Fei, 2015; Hossain et al., 2019), generating source code (Karpathy, 2015), rainfall-runoff modeling (Kratzert et al., 2018, 2019),or hydrological models for flooding warnings (Nearing et al., 2024). In reinforcement learning, LSTMs are the best performing sequence models, e.g., the AlphaStar model for StarCraft II (Vinyals et al., 2017), the OpenAI Five model for Dota 2 (Karpathy, 2019), and models of the magnetic controller for nuclear fusion (Degrave et al., 2022). LSTMs excel at learning abstractions, i.e., adeptly extracting semantic information and storing it in their memory cells (Karpathy, 2015), which for example became evident by number and syntax neurons (Lakretz et al., 2019), linguistic neurons (Bau et al., 2019), and sentiment neurons (Radford et al., 2017). LSTMs are still used in highly relevant applications (Degrave et al., 2022; Nearing et al., 2024) and have stood the test of time.

Despite their tremendous successes, LSTMs have three main limitations: (i) Inability to revise storage decisions. We exemplify this limitation via the _Nearest Neighbor Search_ problem (see also Appendix D): With a reference vector given, a sequence must be scanned sequentially for the most similar vector in order to provide its attached value at sequence end. The left panel of Figure 1 shows the mean squared error at this task. LSTM struggles to revise a stored value when a more similar vector is found, while our new xLSTM remediates this limitation by exponential gating. (ii) Limited storage capacities, i.e., information must be compressed into scalar cell states. We exemplify this limitation via _Rare Token Prediction_. In the right panel of Figure 1, the complexity of token prediction on Wikitext-103, the perplexity of token prediction on Wikitext-103 (Merity et al., 2017) is given for partitions of different token frequency. LSTM performs worse on rare tokens because of its limited storage capacities. Our new xLSTM solves this problem by a matrix memory. (iii) Lack of parallelizability due to memory mixing, i.e., the hidden-hidden connections between hidden states from one time step to the next, which enforce sequential processing.

These limitations of LSTM have paved the way for the emergence of Transformers (Vaswani et al., 2017) in language modeling. What performances can we achieve in language modeling when overcoming these limitations and scaling LSTMs to the size of current Large Language Models?

## 2 Extended Long Short-Term Memory

To overcome the LSTM limitations, Extended Long Short-Term Memory (xLSTM) introduces two main modifications to the LSTM idea of Equation (1). Those modifications -- exponential gating and novel memory structures -- enrich the LSTM family by two members: (i) the new sLSTM (see Section 2.2) with a scalar memory, a scalar update, and memory mixing, and (ii) the new mLSTM (see Section 2.3) with a matrix memory and a covariance (outer product) update rule, which is fully parallelizable. Both sLSTM and mLSTM enhance the LSTM through exponential gating. To enable parallelization, the mLSTM abandons memory mixing, i.e., the hidden-hidden recurrent connections. Both mLSTM and sLSTM can be extended to multiple memory cells, where sLSTM features memory mixing across cells. Further, the sLSTM can have multiple heads without memory mixing across the heads, but only memory mixing across cells within each head. This introduction of heads for sLSTM together with exponential gating establishes a new way of memory mixing. For mLSTM multiple heads and multiple cells are equivalent.

Integrating these new LSTM variants into residual block modules results in xLSTM blocks (see Section 2.4). Residually stacking those xLSTM blocks in architectures provides xLSTM architectures (see Section 2.4). See Appendix Figure 6 for the xLSTM architecture with its components.

Figure 1: LSTM limitations. **Left**: Nearest Neighbor Search problem in terms of mean squared error (MSE). Given a reference vector, a sequence is scanned sequentially for the most similar vector with the objective to return its attached value at sequence end. LSTM struggles to revise a stored value when a more similar vector is found. Our new xLSTM overcomes this limitation by exponential gating. **Right**: Rare Token Prediction. The perplexity (PPL) of token prediction on Wikitext-103, in partitions of token frequency. LSTM performs worse on predicting rare tokens because of its limited storage capacities, whereas our new xLSTM solves this problem via a matrix memory.

### Review of the Long Short-Term Memory

The original LSTM idea (Hochreiter, 1991; Hochreiter & Schmidhuber, 1997, 1997, 1998) introduced the scalar memory cell as a central processing and storage unit that avoids vanishing gradients (Hochreiter, 1991; Hochreiter et al., 2000) through the constant error carousel (cell state update). The memory cell contains three gates: input, output, and forget gate. The latter was introduced by Gers et al. (2000). The LSTM memory cell update rules at time step \(t\) are:

\[_{t}}} =\ _{t}}\ }}\ +\ _{t}}}\ _{t}}}\] cell state (2) \[h_{t} =\ _{t}}}\ _{t}\, _{t}\ =\ (}})\] hidden state (3) \[_{t}}} =\ (_{t})\, _{t}\ =\ _{z}^{}\ _{t}\ +\ r_{z}h_{t-1}\ +\ b_{z}\] cell input (4) \[_{t}}} =\ (}_{t})\, }_{t}\ =\ _{z}^{}\ _{t}\ +\ r_{}\ h_{t-1}\ +\ b_{}\] input gate (5) \[_{t}}} =\ (_{t})\, }_{t}\ =\ _{}^{}\ _{t}\ +\ r_{}\ h_{t-1}\ +\ b_{}\] forget gate (6) \[_{t}}} =\ (}_{t})\, }_{t}\ =\ _{}^{}\ _{t}\ +\ r_{}\ h_{t-1}\ +\ b_{}\] output gate (7)

The weight vectors \(_{z}\), \(_{}\), \(_{}\), and \(_{}\) correspond to the input weight vectors between inputs \(_{t}\) and cell input, input gate, forget gate, and output gate, respectively. The weights \(r_{z}\), \(r_{}\), \(r_{}\), and \(r_{}\) correspond to the recurrent weights between hidden state \(h_{t-1}\) and cell input, input gate, forget gate, and output gate, respectively. \(b_{z}\), \(b_{}\), \(b_{}\), and \(b_{}\) are the corresponding bias terms. \(\) and \(\) are the cell input and hidden state activation functions (typically \(\)). \(\) is used to normalize or squash the cell state, which would be unbounded otherwise. All gate activation functions are sigmoid, i.e., \((x)=1/(1+(-x))\). In later formulations, multiple scalar memory cells \(c_{t}\) were combined in a vector \(_{t}^{d}\), which allows the usage of recurrent weight matrices \(^{d d}\) for each gate to mix the cell outputs of memory cells (Greff et al., 2015), for more details see Appendix B.1. Ablation studies showed that all components of the memory cell are crucial (Greff et al., 2015).

### sLSTM

To empower LSTMs with the ability to revise storage decisions, we introduce exponential gates (red) together with normalization and stabilization. In particular, input and forget gates can have exponential activation functions. For normalization, we introduce a normalizer state that sums up the product of the input gate times all future forget gates. The scalar sLSTM forward pass is:

\[}} =\ _{t}}\ }}\ +\ _{t}}}\ _{t}}}\] cell state (8) \[_{t}}} =\ _{t}}\ }}\ +\ _{t}}}\] normalizer state (9) \[h_{t} =\ _{t}}}\ _{t}\, _{t}\ =\ }}/}}\] hidden state (10) \[}} =\ (_{t})\, _{t}\ =\ _{z}^{}\ _{t}\ +\ r_{z}h_{t-1}\ +\ b_{z}\] cell input (11) \[_{t}}} =\ }}(}_{t})\, }_{t}\ =\ _{z}^{}\ _{t}\ +\ r_{}\ h_{t-1}\ +\ b_{}\] input gate (12) \[_{t}}} =\ (}_{t})\ \ }}(}_{t})\, }_{t}\ =\ _{}^{}\ _{t}\ +\ r_{}\ h_{t-1}\ +\ b_{}\] forget gate (13) \[_{t}}} =\ (}_{t})\, }_{t}\ =\ _{}^{}\ _{t}\ +\ r_{}\ h_{t-1}\ +\ b_{}\] output gate (14)

We transfer the original LSTM gating techniques, i.e., input- and/or hidden-dependent gating plus bias term, to the new architectures. Exponential activation functions can lead to large values that cause overflows. Therefore, we stabilize gates with an additional state \(_{t}}}\)(Milakov & Gimelshein, 2018), see Equations (49) - (51) in the appendix.

**New Memory Mixing.** sLSTM can have multiple memory cells like the original LSTM (see Appendix B.2). Multiple memory cells enable memory mixing via recurrent connections \(_{z}\), \(_{}\), \(_{}\), \(_{}\) from hidden state vector \(\) to memory cell input \(\) and the gates \(\), \(\), \(\), respectively. A new aspect in memory mixing is the effect of exponential gating. The new sLSTM can have multipleheads with memory mixing within each head but not across heads. The introduction of heads for sLSTM together with exponential gating establishes a new way of memory mixing.

### mLSTM

To enhance storage capacities of LSTMs, we increase the LSTM memory cell from a scalar \(c\) to a matrix \(^{d d}\). Hence, retrieval is performed via a matrix multiplication. At time \(t\), we want to store a pair of vectors, the key \(_{t}^{d}\) and the value \(_{t}^{d}\) (we use the Transformer terminology). Later at time \(t+\), the value \(_{t}\) should be retrieved by a query vector \(_{t+}^{d}\). This is the setting of Bidirectional Associative Memories (BAMs) (Kohonen, 1972; Anderson, 1972; Nakano, 1972; Anderson et al., 1977). The covariance update rule (Sejnowski, 1977; Dayan and Willshaw, 1991) for storing a key-value pair is

\[_{t}\;=\;_{t-1}\;+\;_{t}\;_{t}^{}\;.\] (15)

We assume a layer-norm before projecting inputs to keys and values, therefore they have zero mean. The covariance update rule is optimal (Dayan and Willshaw, 1991) for a maximal separability of retrieved binary vectors, which is equivalent to a maximal signal/noise ratio. Higher separability is possible when limiting retrieval to pairwise interactions and conceding quadratic complexity like attention (Krotov and Hopfield, 2016, 2017; Ramsauer et al., 2021). The covariance update rule is equivalent to Fast Weight Programmers (Schmidhuber, 1992; Schlag et al., 2021), which have later been equipped with a constant decay rate multiplied to \(_{t-1}\) and a constant learning rate multiplied to \(_{t}_{t}^{}\)(Ba et al., 2016a). In this spirit, we integrate the covariance update rule into the LSTM framework, where the forget gate corresponds to decay rate and the input gate to the learning rate, while the output gate scales the retrieved vector.

For this matrix memory, the normalizer state is the weighted sum of key vectors, where each key vector is weighted by the input gate and all future forget gates. Again, the normalizer state keeps record of the strength of the gates. Since the dot product between query and normalizer state can be close to zero, we use the absolute value of this dot product and lower bound it by a threshold (typically 1.0) as done previously (Sun et al., 2023). The mLSTM forward pass is:

\[_{t}} =\;}_{}}\;_{t-1}}\;+\; }_{}}\;_{t}_{t}^{}}\] cell state (16) \[_{t}} =\;}_{}}\;_{t-1}}\;+\; }_{}}\;_{t}}\] normalizer state (17) \[_{t} =\;}_{t}}}\;\;}_{t}\;,  56.905512pt}_{t}\;=\;_{t}\;_{t}}\;/\; }_{t}}^{}\;_{t}},1}\] hidden state (18) \[_{t} =\;_{b}\;_{t}\;+\;_{q}\] query input (19) \[_{t} =\;}_{b}\;_{t}\;+\;_{k}\] key input (20) \[_{t} =\;_{v}\;_{t}\;+\;_{v}\] value input (21) \[}_{t} =\;}_{t}}}\;,  56.905512pt}_{t}\;=\;_{}^{}\;_ {t}\;+\;b_{}\] input gate (22) \[}_{} =\;}_{t}\;\;\;}_{}}}}_{t}\;,  11.381102pt}_{t}\;=\;_{}^{}\;_ {t}\;+\;b_{}\] forget gate (23) \[}_{t}}} =\;\;(}_{t})\;,  56.905512pt}_{t}\;=\;_{}\;_ {t}\;+\;_{}\] output gate (24)

mLSTM can have multiple memory cells like the original LSTM. For mLSTM, multiple heads and multiple cells are equivalent as there is no memory mixing. In order to stabilize the exponential gates of mLSTM, we use the same stabilization techniques as for sLSTM (see Equation 49). Since the mLSTM has no memory mixing, this recurrence can be reformulated in a parallel version. For more details we refer to Appendix B.3.

### xLSTM Architecture

**xLSTM Blocks.** An xLSTM block should non-linearly summarize the past in a high-dimensional space to better separate different histories or contexts. Separating histories is the prerequisite to correctly predict the next sequence element such as the next token. We resort to Cover's Theorem (Cover,1965), which states that in a higher dimensional space non-linearly embedded patterns can more likely be linearly separated than in the original space. We consider two residual block architectures: (i) A residual block with post up-projection (like Transformers), which non-linearly summarizes the past in the original space, then linearly maps into a high-dimensional space, applies a non-linear activation function, and linearly maps back to the original space; see Appendix Figure 7 for details. (ii) A residual block with pre up-projection (like State Space Models), which linearly maps to a high-dimensional space, non-linearly summarizes the past in the high-dimensional space and then linearly maps back to the original space. See Appendix Figure 8 for more details. For an xLSTM block containing an sLSTM, we mostly use the post up-projection block. For an xLSTM block containing an mLSTM, we use the pre up-projection block since the memory capacity becomes larger in the high-dimensional space.

**xLSTM Architecture.** An xLSTM architecture is constructed by residually stacking building blocks (Srivastava et al., 2015; He et al., 2016). We rely on the most commonly used pre-LayerNorm (Ba et al., 2016) residual backbones as used in contemporary Large Language Models. See last two columns (from the left) in Figure 6.

### Memory and Speed Considerations

Contrary to Transformers, xLSTM networks have a linear computation and a constant memory complexity with respect to the sequence length. Since the xLSTM memory is compressive, it is well suited for industrial applications and implementations on the edge. The memory of mLSTM does not require parameters, but is computationally expensive through its \(d d\) matrix memory and \(d d\) update. We trade off memory capacity against computational complexity. Nevertheless, the computations can be done in parallel on GPUs, therefore these computations have only a minor effect on the wall clock time.

While mLSTM is parallelizable analog to FlashAttention (Dao et al., 2022; Dao, 2024) or GLA (Yang et al., 2023), sLSTM is not parallelizable due to the memory mixing (hidden-hidden connections). However, we developed a fast CUDA implementation with GPU memory optimizations to the register level which is typically less than two times slower than mLSTM.

## 3 Related Work

Conceptually, the closest models to xLSTM are Retention (Sun et al., 2023), RWKV (Peng et al., 2023, 2024), GLA (Yang et al., 2023), HGRN2 (Qin et al., 2024) and Mamba (Gu and Dao, 2024). These models share the concepts matrix memory and/or gating. However, in contrast to the new sLSTM, they do not allow memory mixing. Memory mixing enables to solve state tracking problems, and therefore LSTMs are more expressive than State Space Models (SSMs) and Transformers (Merrill et al., 2024; Deletang et al., 2023). Other closely related work is discussed further in Appendix C.

## 4 Experiments

We experimentally evaluate xLSTM and compare it to existing methods with a focus on language modeling. We investigate xLSTM's specific capabilities on synthetic tasks in Section 4.1. In Section 4.2, we compare the validation set perplexity of various current language modeling methods that have been trained on 15B tokens from SlimPajama (Soboleva et al., 2023). On the same dataset, we perform ablation studies for xLSTM. Then, we compare xLSTM and the best performing methods from Section 4.2 after being trained on 300B tokens from SlimPajama (Soboleva et al., 2023) on downstream tasks, assess their scaling behavior analogous to Kaplan et al. (2020) and Brown et al. (2020), and compare the text generation times and the maximal throughput of the xLSTM in Section 4.3. For all experiments, we use the notation xLSTM[\(a\):\(b\)] for the ratio \(a/b\) of mLSTM-based versus sLSTM-based xLSTM blocks. For example, xLSTM[7:1] means that out of eight blocks, seven are mLSTM-based blocks and one is an sLSTM-based block. For a common total block number of 48, this translates to 6 sLSTM-based blocks and 42 mLSTM-based blocks.

### Synthetic Tasks and Long Range Arena

Firstly, we test the effectiveness of xLSTM's new exponential gating with memory mixing on formal languages (Deletang et al., 2023). Then, we assess the effectiveness of xLSTM's new matrix memory on the Multi-Query Associative Recall task (Arora et al., 2023). Finally, xLSTM's performance at processing long sequences in the Long Range Arena is evaluated (Tay et al., 2021).

**Test of xLSTM's Exponential Gating with Memory Mixing.** We test xLSTM's new exponential gating with memory mixing, which should enable it to solve state tracking problems (Merrill et al., 2024; Merrill and Sabharwal, 2023). We implement and extend the formal language tasks from Deletang et al. (2023) to enable multi-length training for length extrapolation. For a detailed description of all tasks and extended results see Appendix D.1.1. We compare xLSTM to other methods including Transformers, State Space Models, and Recurrent Neural Networks. The accuracy of the tested methods is evaluated on those tokens relevant to the task. The accuracy is scaled between 0 (random) and 1 (perfect). We compare 2-block architectures of the following methods on these tasks: xLSTM[0:1] (i.e., only sLSTM), xLSTM[1:0] (i.e., only mLSTM), xLSTM[1:1], Llama, Mamba, RWKV, Retention, Hyena, LSTM, and LSTM in Transformer blocks (LSTM (Block)). The results of this experiment are shown in Figure 9. Models such as Transformers or State Space Models without memory mixing (no state tracking) cannot solve, e.g. regular grammars like the parity task. This result is in agreement with findings that Transformers and State Space models are fundamentally less powerful than RNNs (Merrill et al., 2024; Merrill and Sabharwal, 2023; Deletang et al., 2023).

**Test of xLSTM's Memory Capacities on Associative Recall Tasks.** In this experiment, we test xLSTM's new matrix memory in terms of the memory capacity on the Multi-Query Associative Recall task (Arora et al., 2023): For each sequence, key-value pairs are randomly chosen from a large vocabulary, which must be memorized for later retrieval. To enhance the difficulty of the original task, we increase the number of key-value pairs up to 256 and enlarge the context length up to 2048, obtaining extended tests for the memory capacities of different models. We compare 2-block architectures of Llama, Mamba, RWKV-5, RWKV-6, xLSTM[1:1] and xLSTM[1:0]. The models are evaluated by the accuracy at recalling the pairs. Since Transformers (e.g. Llama) have a memory that is exponential in the coding dimension (Ramsauer et al., 2021), they constitute the gold standard at this task. Results are shown in Figure 2. xLSTM[1:1] performs best among all non-Transformer models, also for small models. Interestingly, the sLSTM block does not diminish the memory capacity but rather leverages it, which becomes evident at the most difficult task with 256 key-value pairs. Additional results of Appendix D.1.2, indicate that xLSTM's enhanced memory capacities also allow for extrapolating to contexts that are longer than those seen during training.

### Method Comparison and Ablation Study

To address the main question of our paper, i.e. what can our new LSTM variants achieve when scaled up in language modelling, we train xLSTMs, Transformers, State Space Models, and other methods on 15B tokens from SlimPajama in the same auto-regressive setting. We compare the trained models on the validation set and perform ablation studies for the xLSTMs.

Figure 2: Test of memory capacities of different models at the Multi-Query Associative Recall task with context length 2048. Each panel is dedicated to a different number of key-value pairs. The \(x\)-axis displays the model size and the \(y\)-axis the validation accuracy.

**Comparing xLSTM to Other Methods.** We train models on 15B tokens from SlimPajama (Soboleva et al., 2023), and evaluate their perplexity on the validation set. We compare the following methods: xLSTM, GPT-3 (Transformer) (Brown et al., 2020), Llama (Transformer) (Touvron et al., 2023), H3 (SSM) (Fu et al., 2023), Mampa (SSM) (Gu and Dao, 2023), RWKV-4 (RNN) (Peng et al., 2023), RWKV-5 (RNN) (Peng et al., 2024), GLA (linear Transformer) (Yang et al., 2023), HGRN2 (RNN) (Qin et al., 2024). RetNet (linear Transformer) (Sun et al., 2023), Hyena (linear Transformer) (Poli et al., 2023), xLSTM[1:0], and xLSTM[7:1]. The models were trained with mixed precision, for RWKV-5, RWKV-6, GLA, HGRN2, the mixed-precision training did not utilize the PyTorch automated mixed precision (see Appendix Section D.2). We categorize the methods into (a) Transformers, (b) State Space Models (SSMs), and (c) Recurrent Neural Networks (RNNs) together with linear Transformers, i.e., linear methods that substitute the Transformer's attention mechanism. The models match a GPT-3 model with 350M parameters in size, i.e. embedding dim 1024 and 24 residual blocks. Only GPT-3 uses shared weights for token and output embeddings, therefore has fewer parameters.

The results in Table 1 show that xLSTM outperforms all existing methods in validation perplexity. For details see Appendix D.2. Figure 15 in the appendix shows the scaling behaviour for this experiment, indicating that xLSTM will also perform favorably for larger models.

**Ablation Studies.** Table 1 and Figure 15 demonstrate that xLSTM achieves excellent results at language modeling when being trained on 15B tokens from SlimPajama. To ablate the changes from LSTM to xLSTM, we morph a vanilla LSTM architecture step-by-step into an xLSTM architecture. Firstly, we integrate LSTM layers into pre-LayerNorm residual backbones. Secondly, we extend this to a post up-projection block. Finally, we add exponential gating and matrix memory. The results are shown in Appendix Table 6 (top). The ablation studies attribute the strong performance improvement to both the exponential gating and the matrix memory. Additionally, due to the importance of gating in RNNs and State Space Models, we ablate different gating mechanisms. In Appendix Table 6 (bottom), we conclude that having each gate learnable and influenced by the input has an incrementally positive effect. Additional studies on the individual backbone components are discussed in Appendix D.2.

### xLSTM as Large Language Model

Next, we increase the amount of training data to 300B tokens from SlimPajama, the same number of tokens as used in e.g., Mampa (Gu and Dao, 2023) and Griffin (De et al., 2024). We compare xLSTM to RWKV-4, Llama, and Mampa - one method from each respective method class in Section 4.2. We select RWKV-4 as RNN representative since for RWKV-5, RWKV-6 and HGRN2 a reasonable training precision setting (Appendix Section D.2) has been found only after the training start of the 300B token experiments (Peng et al., 2024). We train different model sizes (125M, 350M, 760M, 1.3B), test all models for length extrapolation capabilities and evaluate their performance on the validation set, on downstream tasks, on 471 text domains of the PALOMA benchmark, and, finally, investigate their scaling law behavior.

   Model & \#Params & SlimPajama \\  & M & (15B) ppl \(\) \\  Hyena & 435 & 17.59 \\ RWKV-4 & 430 & 15.62 \\ RWKV-5 & 456 & 14.25 \\ RWKV-6 & 442 & 15.03 \\ RetNet & 431 & 16.23 \\ GLA & 412 & 16.15 \\ HGRN2 & 411 & 14.32 \\    
   Model & \#Params & SlimPajama \\  & M & (15B) ppl \(\) \\  GPT-3 & 356 & 14.26 \\ Llama & 407 & 14.25 \\  H3 & 420 & 18.23 \\ Mampa & 423 & 13.70 \\ 
**xLSTM[1:0]** & 409 & **13.43** \\
**xLSTM[7:1]** & 408 & 13.48 \\   

Table 1: Method comparison on next token prediction when trained on 15B tokens from SlimPajama. Best validation perplexities within model classes, i.e., linear Transformers, RNNs, Transformers, SSMs, and xLSTMs are underlined and overall best is in bold. For each model class, the best performing methods are used in Section 4.3 for LLM training. xLSTMs with new memory (xLSTM[1:0] and xLSTM[7:1]) perform best.

**Sequence Length Extrapolation.** Firstly, we test the sequence length extrapolation for 1.3B-sized, large models of xLSTM, RWKV-4, Llama, and Mamba. All models are trained on context length 2048, and then tested for context lengths up to 16384. See Figure 3 for the results. In contrast to other methods, xLSTM models maintain low perplexities for longer contexts.

   Model &  SlimPajama \\ (300B) ppl \(\) \\ at 16k \\  \\   Llama \\ Mamba \\ RWKV-4 \\ xLSTM[7:1] \\  &  337.83 \\ 14.00 \\ 13.75 \\  &  SlimPajama \\ 13.75 \\  \\   Llama \\ Mamba \\ RWKV-4 \\ xLSTM[7:1] \\  &  337.83 \\ 14.00 \\ 13.75 \\  &  SlimPajama \\ 13.75 \\  \\   Llama \\ Mamba \\ RWKV-4 \\ xLSTM[7:1] \\  &  337.83 \\ 14.00 \\ 1422.6 \\  & 
 14.00 \\ **8.892** \\ 9.01 \\  \\   

Table 2: Validation set perplexity and downstream tasks. Comparison of xLSTM, RWKV-4, Llama, and Mamba on the validation set at next token prediction and on downstream tasks after training on 300B tokens from SlimPajama. Model sizes are 125M, 350M, 760M, and 1.3B. The first column shows the methods and the second the actual number of parameters. The third column lists the validation set perplexities, while the remaining columns show the performance on downstream tasks. Best model per model size is depicted bold and the second best is underlined. In the vast majority of tasks and across all model sizes xLSTM is the best method — only on the ARC task Mamba is in some cases the best method. xLSTM[1:0] and xLSTM[7:1] are the two best models with respect to validation set perplexity.

Figure 3: Sequence extrapolation in language modeling. This is a comparison of 1.3B-sized, large models of xLSTM, RWKV-4, Llama, and Mamba at next token prediction on the SlimPajama validation set after training on 300B tokens from SlimPajama. Models are trained with context length 2048 (gray) and then tested for context lengths up to 16384. **Left:** Token perplexities evaluated at different context lengths. In contrast to other methods, xLSTM models remain at low perplexities for longer contexts. **Right:** Prediction quality when extrapolating to long context sizes in terms of validation perplexity (PPL). xLSTM yields the best PPL values (best in bold, second best underlined).

**Validation Perplexity and Downstream Tasks.** Secondly, for all model sizes, we evaluate the performance of xLSTM, RRVV-4, Llama, and Mamba models on the SlimPajama validation set for next token prediction and on downstream tasks that measure common sense reasoning. The third column of Table 2 lists the validation set perplexities of different methods. Both xLSTM[1:0] and xLSTM[7:1] are the best models for all model sizes with respect to the validation set perplexity. The other columns of Table 2 provide the performance on downstream tasks. In the vast majority of tasks and across all model sizes xLSTM is the best method -- only on the ARC task Mamba is in some cases the best method. For details see Appendix D.3.

**Performance on PALOMA Language Tasks.** Thirdly, for all model sizes, we test the next token prediction performance of xLSTM, RRVV-4, Llama, and Mamba models on PALOMA language tasks (Magnusson et al., 2023). We measure the performance by the perplexity for next token prediction on 571 text domains, which range from nytimes.com to r/depression on Reddit. Appendix Table 8 shows token prediction perplexity grouped into language modeling (first seven columns) and fine-grained domain benchmarks (last 5 columns). xLSTM[1:0] has in 568 out of 571 (99.5%) text domains a lower perplexity than Mamba, in 486 out of 571 (85.1%) a lower perplexity than Llama, in 570 out of 571 (99.8%) a lower perplexity than RWKV-4, see Appendix D.3.

**Scaling Laws.** Fourthly, we assess the power-law scaling behavior, which allows to extrapolate the performance to larger model sizes (Kaplan et al., 2020; Brown et al., 2020). Figure 4 presents the scaling behavior over the number of model parameters. All models share a similar scaling behavior but with different offsets. RRVV-4 performs worst, followed by Llama and Mamba. xLSTM is better than Mamba with a similar margin to Mamba as Mamba has to Llama. In Figure 16 in Appendix D.3 we plot the scaling behavior over the number of training FLOPs for the Llama baseline and both xLSTM variants. For the xLSTM variants we calculate the FLOPs for the recurrent (see Section 2 and parallel (see Appendix B.3) formulation. The scaling behavior indicates that for larger models xLSTM will continue to perform favourable compared to Transformers and State-Space models.

**Generation Times and Maximal Throughput.** Finally, we measure the text generation time in Figure 5 (left) and the maximal throughput in Figure 5 (right) for our xLSTM variants at 1.3B scale. We compare against similar sized Mamba, Llama and RRVV implementations from HuggingFace, including a static key-value cache for the Llama model. At the time of the experiments, both full cache compilation of the Transformer model and compilation of the Mamba model with torch.compile did not work. For the text generation experiments all of the models are tested at batch size 1 and pre-fill 16. This pre-fill should be maximally favorable for the Transformer. Figure 5 shows the linear scaling of the xLSTM and the other recurrent models Mamba and RRVV-4 compared to the quadratic scaling of Llama. For the decoding throughput we measure different batch sizes and prefill for the Llama model. Figure 5 (right) shows that xLSTM can use much higher batch sizes than Llama due to its constant memory and thus achieves the highest throughput.

Figure 4: Scaling laws. Next token prediction perplexity of xLSTM, RRVV-4, Llama, and Mamba. The models – with sizes 125M, 350M, 760M, and 1.3B parameters – are trained on 300B tokens from SlimPajama. The scaling laws indicate that for larger models xLSTM will perform well too.

## 5 Limitations

(i) In contrast to mLSTM, memory mixing of the sLSTM prohibits parallelizable operations, and thus prevents a fast parallel implementation. However, we developed a fast CUDA kernel for sLSTM, which is currently less than two times slower than the parallel mLSTM implementation. (ii) The mLSTM CUDA kernels are not optimized, and therefore the current implementation is about four times slower than FlashAttention or the scan used in Mamba. Faster CUDA kernels could be obtained in the vein of FlashAttention. (iii) The matrix memory of mLSTM has high computation complexity since \(d d\) matrices must be processed. Still, the memory update and retrieval is parameter-free, i.e., parallelizable when using standard matrix operations. Thus, the wall clock time overhead due to the complex memory is minor. (iv) The forget gate initialization must be chosen carefully. (v) Since the matrix memory is sequence length independent, increasing the sequence length might overload the memory for longer context sizes. Still, this does not appear to be a limitation for contexts up to 16k, see Section 4.3. (vi) Due to the expensive computational load for LLM experiments, we did neither fully optimize the architecture nor the hyperparameters, especially for larger xLSTM architectures. We anticipate that an extensive optimization process is needed for xLSTM to reach its full potential.

## 6 Conclusion

We have partly answered our simple question: How far do we get in language modeling when scaling LSTM to billions of parameters? So far, we can answer: "At least as far as current technologies like Transformers or State Space Models". We have enhanced LSTM to xLSTM by exponential gating with memory mixing and a new memory structure. xLSTM models perform favorably on language modeling when compared to state-of-the-art methods like Transformers and State Space Models. The scaling laws indicate that larger xLSTM models will be serious competitors to current LLMs that are built with the Transformer technology. xLSTM has the potential to considerably impact other fields like Reinforcement Learning, Time Series Prediction, or the modeling of physical systems.