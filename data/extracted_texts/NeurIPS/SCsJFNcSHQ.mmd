# Structure Learning with Adaptive Random Neighborhood Informed MCMC

Alberto Caron

The Alan Turing Institute

London, UK

acaron@turing.ac.uk

&Xitong Liang

Department of Statistical Sciences

University College London

London, UK

xitong.liang.18@ucl.ac.uk

&Samuel Livingstone

Department of Statistical Sciences

University College London

London, UK

samuel.livingstone@ucl.ac.uk

&Jim Griffin

Department of Statistical Sciences

University College London

London, UK

j.griffin@ucl.ac.uk

These authors contributed equally to this work.

###### Abstract

In this paper, we introduce a novel MCMC sampler, PARNI-DAG, for a fully-Bayesian approach to the problem of structure learning under observational data. Under the assumption of causal sufficiency, the algorithm allows for approximate sampling directly from the posterior distribution on Directed Acyclic Graphs (DAGs). PARNI-DAG performs efficient sampling of DAGs via _locally informed_, _adaptive random neighborhood_ proposal that results in better mixing properties. In addition, to ensure better scalability with the number of nodes, we couple PARNI-DAG with a pre-tuning procedure of the sampler's parameters that exploits a skeleton graph derived through some constraint-based or scoring-based algorithms. Thanks to these novel features, PARNI-DAG quickly converges to high-probability regions and is less likely to get stuck in local modes in the presence of high correlation between nodes in high-dimensional settings. After introducing the technical novelties in PARNI-DAG, we empirically demonstrate its mixing efficiency and accuracy in learning DAG structures on a variety of experiments.1

## 1 Introduction

Structure Learning and Causal Discovery are concerned with reconstructing a graphical model underlying a set of random variables from data, in the form of a Directed Acyclic Graph (DAG), provided that causal identifiability assumptions hold (Pearl, 2009; Drton and Maathuis, 2017; Glymour et al., 2019). Causal relations can typically be inferred if randomized experiments are carried out (Pearl, 2009). However, in many relevant applied fields (_e.g._ biology, genomics, ecology, etc.), only observational data are accessible, as performing interventions is usually costly or simply unfeasible. Structure learning from observational data is a challenging problem, with the space of possible DAGs growing super-exponentially in the number of nodes (Robinson, 1977).

Related work.Early contributions on structure learning algorithms include _constraint-based methods_(Spirtes et al., 2000; Pearl, 2009), such as PC and FCI, that utilize conditional independencetesting to output a Markov Equivalence Class (MEC). Another stream of literature focuses on _score-based methods_(Geiger and Heckerman, 1994), such as Greedy Equivalent Search (GES) (Chickering, 1996, 2002), which define and consequently maximize a score function associated with different MECs. Alternatively, _functional causal models_, such as LiNGAM (Shimizu et al., 2006) and Additive Noise Models (Hoyer et al., 2008b), directly output DAGs. Recent advancements falling in either of the classes above have considered methods relying on deep learning techniques (Zheng et al., 2018, Yu et al., 2019), but are specifically suited for large sample regimes.

MCMC-based Bayesian approaches, that account for graph uncertainty by learning a posterior distribution over graphs, include Madigan et al. (1995) and Giudici and Castelo (2003), who introduced the MCMC Model Composition (MC\({}^{3}\)) scheme and the Add-Delete-Reverse (ADR) scheme respectively. Grzegorczyk and Husmeier (2008) improve ADR's mixing by proposing a new arc reversal move. Another stream of contributions on structure learning MCMC have considered working with score functions in smaller spaces rather than the DAG one. Friedman and Koller (2003) first recasted the problem by operating in the space of "orders" instead of DAGs, so that candidate orders, consistent with multiple DAGs, are proposed. Although this generates considerable benefits in terms of scalability, it introduces sampling bias, as some DAGs are over-represented (Ellis and Wong, 2008). This bias is addressed in Kuipers and Moffa (2017), who proposed working in the space of "ordered partitions" instead, which introduces scalability issues, making partition MCMC applicable to graphs with a small number of nodes. Further works have focused on improving mixing efficiency and scalability of these score-based MCMC (Nininika et al., 2016; Viniukka and Koivisto, 2020; Kuipers et al., 2022). Recent advances have also considered approximate Variational Inference methods (Lorch et al., 2021; Candy et al., 2021; Geffner et al., 2022). More closely related to our work, van den Boom et al. (2022) considered the locally-informed proposal on non-decomposable Gaussian Graphical Models (GGM), but with neighborhoods defined by a subset of the space around the current state of the Markov chain, _i.e._ neighborhoods of the MC\({}^{3}\) type, with size growing quadratically in the number of nodes. However, their WWA algorithm does not target the posterior on DAGs directly, unlike PARNI-DAG.

Tangential to this work is also the rich literature on discrete spaces MCMC samplers for Bayesian variable selection. Noteworthy contributions include Zanella (2020), that up-weights a random-walk kernel via local neighborhood information and constructs the _locally-informed proposal_, and Griffin et al. (2021), that develops an adaptive MCMC algorithm addressing high-dimensional sparse settings. The locally-informed proposal can be viewed as a discrete analog to the gradient MCMC proposals (_e.g._ the Metropolis-adjusted Langevin algorithm (Roberts and Rosenthal, 1998)), where the gradient of the target distribution does not exist. The adaptive MCMC instead is capable of learning from the shape of the target distribution and exploiting the most important variables. Liang et al. (2022) generalise the locally-informed proposal and the adaptive MCMC to be used within random neighborhood schemes, and introduced the PARNI proposal for Bayesian variable selection.

Contribution.This work presents a novel MCMC sampler for structure learning, **PARNI-DAG**, that builds on top of PARNI (Liang et al., 2022), but is equipped with new features for efficient sampling in the space of DAGs. PARNI-DAG constructs a random neighborhood of possible DAGs via probabilities proportional to a function of the Posterior Edge Probabilities (PEPs), that is, the probabilities of including a direct edge between two nodes. Then, since full enumeration of all the possible DAGs within the neighborhood is virtually impossible in high-dimensions, it proposes a new candidate DAG via a "point-wise update", _i.e._ by considering a sequence of intermediate proposed DAGs belonging to a smaller subset of the neighborhood. Finally, to guarantee better scalability with the number of nodes, we propose a procedure to pre-tune PARNI-DAG's parameters and warm-start the chain by utilising a skeleton graph derived through any constraint or score based algorithm (_e.g._ PC, GES,...), or the iterative search space expansion proposed in Kuipers et al. (2022).

Motivations.As we will discuss in later sections, PARNI-DAG generates clear advantages over structure MCMC methods such as MC\({}^{3}\) and ADR in terms of speed of convergence and mixing, thanks to its new improved proposal, while targeting the same posterior distribution over DAGs. As for the comparison to score-based MCMC methods, it is known that order MCMC (Friedman and Koller, 2003) has better scalability than standard structure MCMC methods, but, operating in the smaller space of order, it introduces sampling bias via a non-uniform prior being assigned to the different DAGs compatible with a single order (Ellis and Wong, 2008). Compared to order MCMC, PARNI-DAG does not incur in any sampling bias as it targets the posterior on DAGs directly, while at the same time converging faster than ADR. Kuipers and Moffa (2017) propose a variant called partition MCMC, which operates in the space of ordered partitions instead of orders. Partition MCMC is unbiased in terms of sampling, but it is extremely slow and has high computational complexity (can only be used on very few nodes) (Kuipers et al., 2022). PARNI-DAG, on the other hand, specifically addresses high-dimensional settings with many nodes.

As a solution to scale order and partition MCMC up to high-dimensional scenarios, the hybrid MCMC scheme of Kuipers et al. (2022) proposes to restrict the initial search space by pruning it via a skeleton graph (_e.g._ PC algorithm derived skeleton) \(\), whose max parent set size is \(m\) per node, so that complexity reduces to \(O(n2^{m})\). Although this increases MCMC speed dramatically in large graphs, it is likely to introduce bias as some true edges might be deleted in \(\). To tackle this issue they also propose an iterative procedure (Iterative MCMC) to re-populate \(\) with additional potential parent nodes, at the expenses of an increased computational time. We couple PARNI-DAG with a similar procedure, but we use a previously derived skeleton \(\) (e.g. the Iterative MCMC one) not to restrict the space, and possibly cancel out relevant edges, but to warm-start the chain by pre-tuning some of the MCMC, as we will explain in details in later sections.

We show in the experiments section how PARNI-DAG brings about improvements over the classical structure MCMC ADR (Giudici and Castelo, 2003; Grzegorczyk and Husmeier, 2008) and score-based MCMC methods (Friedman and Koller, 2003; Kuipers and Moffa, 2017; Kuipers et al., 2022) in terms of DAG learning accuracy and MCMC mixing, particularly in settings with a high number of nodes, as it is able to reach high probability regions in very few steps, while addressing the presence of highly correlated neighborhoods of edges where classical samplers might get trapped. Code to implement PARNI-DAG and fully reproduce the experiments is provided2.

## 2 Problem Setup

Consider a graph \(=(,)\), made of nodes \(\) and edges \(\), suitable to represent probabilistic dependencies (edges) between random variables (nodes) through a probabilistic graphical model (Koller and Friedman, 2009). Given a collection of \(n=||\) continuous random variables \((X_{1},...,X_{n})\), a Bayesian Network \(=(,)\) associated with a DAG \(\), is a probabilistic graphical model utilized to represent a factorization of the joint probability \(p(X_{1},...,X_{n})\) into the conditional distributions \(p(X_{1},...,X_{n})=_{i=1}^{n}p_{}X_{j}\,|\,(X_{j}) \), where \(\) are the parameters and \((X_{j})\) all the parents of node \(X_{j}\). Suppose that all nodes \((X_{1},...,X_{n})\) are re-scaled to have zero mean and unit variance. The goal in structure learning is to learn the BN factorization of conditional probabilities, given a sample of \(N\) observations on \(=\{X_{1,i},...,X_{n,i}\}_{i=1}^{N}\). In Bayesian structure learning, we specifically want to learn a posterior distribution on possible DAGs, i.e. \(p(|) p(|)p()\). In this work, we define a DAG indicator variable \(=\{0,1\}^{n n}\), where each \(\) implies a unique graph \(_{}\); \(_{ij}=1\) indicates the presence of an edge from \(X_{i}\) to \(X_{j}\), while \(_{ij}=0\) indicates absence of it. The linear functional model associated with DAG \(_{}\) can be specified as

\[X=W_{}^{}X+,\;()=,\;()=(_{1}^{2},...,_{n}^{2})\;,\] (1)

and \(W_{}\) is a matrix of weights. Within a fully Bayesian approach to the inference problem presented in (1), we consider the following prior specification

\[(W_{})_{ij}|\;_{j}^{2},_{ij}=1 \;\;(0,g_{j}^{2})\;,\] \[(W_{})_{ij}|\;_{j}^{2},_{ij}=0 \;\;_{0}\;, p(_{j})_{j}^{-2}\]

where \(_{0}\) is the Dirac measure at 0. Thanks to their conjugate form, the coefficients \(\{W_{ij}\}_{i,j}\) and the heteroskedastic error variances \(\{_{j}\}_{j}\) can be integrated out analytically, leading to a marginal likelihood that depends only on \(\), denoted by \(p(|)\). The last building block we need for posterior \(() p(|)\) inference is acyclicity constraints imposed in the prior distribution for the model indicator \(\), which is specified by

\[p()^{d_{}} \;_{}\;}\] (2)

where the hyperparameter \(h(0,1)\) represents the prior edge probability and \(d_{}=|_{}|\) is the number of edges implied by \(\). We are interested in Bayesian inference on \(\) with posterior distribution \(() p(|)p()\).

Notice that the likelihood, and thus posterior distribution, could also be replaced by a scoring function typically used in score-based MCMC methods (Friedman and Koller, 2003; Kuipers and Moffa, 2017; Kuipers et al., 2022), such as the BGe score (Geiger and Heckerman, 2002), or the BDe score, which would make PARNI-DAG suitable also for discrete-valued nodes.

## 3 The novel PARNI-DAG proposal

### Point-wise implementation of Adaptive Random neighborhood Informed proposal

Recently, Liang et al. (2022) introduced the Point-wise Adaptive Random Neighborhood Informed proposal (PARNI) in the context of Bayesian variable selection problems. PARNI is characterized by a _Metropolis-Hastings_ (MH) proposal (Metropolis et al., 1953; Hastings, 1970) which couples the Adaptively scaled Individual Adaption scheme (Griffin et al., 2021) with the locally-informed proposal (Zanella, 2020). We begin by firstly describing the generic PARNI proposal for DAG learning problems, then we will introduce the modifications needed to make it efficient and that result in the PARNI-DAG proposal.

The PARNI proposal falls into the class of random neighborhood informed proposals, which are characterized by two steps: i) random sampling of a neighborhood \(\), and then ii) proposal of a new DAG within this neighborhood \(\) according to a informed proposal (Zanella, 2020). The random neighborhoods are drawn based on an auxiliary _neighborhood indicator_ variable \(k\), with conditional distribution \(p(k|)\), such that the neighborhood is constructed as a function of \((,k)\). Let \(==\{0,1\}^{n n}\), then in PARNI each \(k\) value indicates whether the corresponding position of \(\) is included in the neighborhood. The conditional distribution of \(k\) takes a product form \(p_{}(k|)=_{i,j}p_{}(k_{ij}|_{ij})\), characterized by the set of tuning parameters \(=\{_{ij}\}_{i,j=1}^{n}\), where \(_{ij}(,1-)\) for a small \((0,1/2)\), and each \(p_{}(k_{ij}|_{ij})\) is given by

\[p_{}(k_{ij}=1|_{ij}=0)=\{1,}{_{ij}} \}\;, p_{}(k_{ij}=1|_{ij}=1)=\{1,}{1-_{ij}}\}\;.\] (3)

The methods for adapting \(\) will be discussed in Section 3.2 specifically. The neighborhood is thus the constructed as

\[(,k)=\{^{*}^{*}_{ij}=_{ ij}\;\;(i,j)\;\;\;\;k_{ij}=0\}.\] (4)

The neighborhood \((,k)\) contains \(2^{d_{k}}\) models where \(d_{k}\) denotes the number of 1s in \(k\). The full enumeration over the whole neighborhood is computationally expensive if \(d_{k}\) is big, and infeasible when \(d_{k}\) is beyond 30. Liang et al. (2022) considered a point-wise implementation of the algorithm, which dramatically reduces the computational complexity from \((2^{d_{k}})\) to \((2d_{k})\). The idea of how the point-wise implementation works is the following. Let variable \(K=\{K_{r}\}_{r=1}^{R}\) represent the collection of positions where \(k_{ij}=1\). Instead of working with the full neighborhood \((,k)\), we construct a sequence of smaller neighborhoods \(\{((r),K_{r})\}_{r=1}^{R}(,k)\), and a new DAG \(^{}\) drawn from these neighborhoods \(\{((r),K_{r})\}_{r=1}^{R}\) is sequentially proposed according to the sub-proposals \(q_{g,K_{r}}((r-1),)\) at each time \(r\). Given the intermediate DAGs \(=(0)(1)(R)=^{}\), each of their corresponding sub-proposal is defined by

\[q_{g,K_{r}}((r-1),(r))=| (r))}{((r-1)p(K_{r}|(r-1)))})\{(r )((r-1),K_{r})\}}{Z_{r}}\;.\] (5)

where \(g:[0,)[0,)\) is a continuous function and \(Z_{r}\) is the normalising constant. The construction of \(K\) and of the sub-neighborhoods \(\{((r),K_{r})\}_{r=1}^{R}\) will be discussed later in Section 3.3.

The choice of function \(g()\) is crucial to the performance of the PARNI proposal. If \(g(x)=1\), the sub-proposal \(q_{g,K_{r}}\) in (5) reverts back to a random walk proposal which proposes a new DAG from \(N((r-1),K_{r})\) with uniform probability. It would then be hard for it to explore important neighborhoods of edges in high-dimensions, as it is likely to get stuck in neighborhoods with highly correlated nodes. In the locally-informed proposal of Zanella (2020), function \(g()\) is chosen to be a non-decreasing and continuous balancing function \(g:[0,)[0,)\), which satisfies \(g(x)=xg(1/x)\). Zanella (2020) shows that the locally-informed proposal with balancing function \(g()\) is asymptotically optimal compared to other choices of \(g()\) in terms of Peskun ordering. In this work, we consider the Hastings' choice (_i.e._\(g(x)=\{1,x\}\), satisfying \(g(x)=xg(1/x)\)) as it has been shown to be the most stable choice for most problems (see the discussion in Supplement B.1.3 of Zanella (2020)).

The informed proposal in this context not only helps speed up convergence, but it also avoids proposing invalid DAGs. This is because the acyclicity checks for candidate models \(^{}((r-1),K_{r})\) can be run before computing their posterior model probabilities, and thus one can assign zero mass to their prior (resulting in zero mass posterior) if \(^{}\) is not a valid DAG. The resulting proposal kernel is then given by

\[q_{g,K}(,^{})=_{r=1}^{R}q_{g,K_{r}}((r-1), (r)).\] (6)

In order to construct a \(\)-reversible chain and calculate the MH acceptance probability, we define the new collection of variables \(K^{}=\{K^{}_{r}\}_{r=1}^{R}\) for the reverse moves, where \(K^{}\) contains the same element as \(K\) but with reverse order (_i.e._\(K^{}_{r}=K_{R-r+1}\)). The MH acceptance probability is then defined as

\[(,^{})=\{1,)q_{g,K^ {}}(^{},)}{()q_{g,K}(,^{}) }\}.\] (7)

**Proposition 3** of Liang et al. (2022) shows that using the above \(K^{}\) can simplify the calculation of the MH acceptance probability in (7).

In the following sections, we will introduce the necessary modifications and developments to efficiently sample DAGs, the combination of which defines the novel PARNI-DAG proposal. The full details and algorithmic pseudo code of PARNI-DAG are also provided in the supplementary material (Appendix D).

### Warm-start of \(\) combined with hybrid scheme

Griffin et al. (2021) and Liang et al. (2022) both suggested using the Posterior Inclusion Probabilities in a Bayesian variable selection context to define the \(_{ij}\) hyperparameters described above. Perfectly analogous, we will make use of the Posterior Edge Probabilities (PEPs) instead, _i.e._\((_{ij}=1)\). The distribution in (3) with the choice of parameters described, encourages to 'flip' edge values based on variables' marginal importance. For example, suppose the posterior for \(_{ij}\) is \((_{ij}=1)=0.9\), and the chain is currently at \(_{ij}=0\). The edge should be then assigned higher probability to be included in the DAG (_i.e._\(_{ij}\) should be switched from 0 to 1). Thus, we propose \(k_{ij}=1\) with probability \(\{1,0.9/0.1\}=1\), so that the new neighborhood features this possible move and \(_{ij}\) can be effectively switched from 0 to 1 in the next moves. Another advantage of using the conditional distribution featuring the PEPs in (3) is that when all variables are independent this proposal will have acceptance probability 1 and achieve optimal asymptotic variance as showed in Griffin et al. (2021).

The PEPs, \((_{ij}=1)\), however cannot be directly calculated for most problems. Griffin et al. (2021) considered the Rao-Blackwellised estimates \((_{ij}=1|_{-ij})\), where \(_{-ij}\) denote \(\) excluding the edge indicator \(_{ij}\), and \(\) is updated on the fly given the current output of the chain. The Rao-Blackwellisation is however infeasible in the context of DAG sampling because it entails computing \(n^{2}\) model probabilities at each iteration of the MCMC. This would result in an impractical computational scheme when working with many nodes. Alternatively, one could take the ergodic sum over the output \(\{^{(l)}\}_{l=1}^{t}\) as

\[_{ij}^{(t)}=_{l=1}^{t}\{_{ij}^{( l)}=1\},\] (8)

but the ergodic sum would be too slow to converge. This updating scheme would also lead to other issues such as poor exploration and mis-specification of the important edges. It is worth mentioning that the \(\)'s do not have to be the exact PEPs, as we can still draw valid samples from the target posterior distribution \(\) as long as the MH acceptance probability preserves \(\)-reversibility. However, choosing \(\)'s that are close to the true PEPs will cause each component to change and to target the right proportion of their marginal probabilities (higher probability of including important edges).

Our solution then is to approximate the PEPs \(_{ij}\) before actually running the PARNI-DAG's MCMC, and use this approximation to warm-start the chain. While running the algorithm at time \(t\), we update the tuning parameters \(_{ij}^{(t)}\) adaptively based on

\[_{ij}^{(t)}=_{t}_{ij}+(1-_{t})_{ij}^{(t)}\,\] (9)

where \(\{_{l}\}_{l=1}^{t}\) is a decreasing sequence of weights which control the trade-off between the provided warm-start PEPs \(_{ij}\) and the ergodic sum of the output \(_{ij}^{t}\). The choice of \(\{_{l}\}_{l=1}^{t}\) is not unique and we give a full specification of our choice in the supplementary material (Appendix B). In what follows, we will briefly describe the methods used to calculate the warm-start approximation \(_{ij}\).

We argue that the iterative procedure used to restrict the initial search space in Kuipers et al. (2022) can be particularly useful in our case to efficiently approximate the PEPs before running the chain. Following the same notation as in Kuipers et al. (2022), let \(\) be the adjacency matrix underlying a skeleton graph obtained from any DAG learning algorithm (_e.g._ PC, GES, etc.). For node \(X_{j}\), the adjacency matrix \(H\) defines the _permissible parent set_\(h^{j}=\{X_{i}:\;H_{ij}=1\}\). All possible parent combinations of node \(X_{j}\) are included in the _collection of permissible parent set_ which is defined by

\[^{j}=\{m|\;m h^{j}\}.\] (10)

The collection of permissible parent set \(^{j}\) can be then extended to a bigger collection \(_{+}^{j}\) as described in Section 4.3 of Kuipers et al. (2022). The extended collection of permissible parent set \(_{+}^{j}\) essentially includes one additional node from outside the permissible parent set \(h^{j}\) as an additional parent, otherwise the candidate parents of \(X_{j}\) are restricted to the set \(h^{j}\). After deriving \(_{+}^{j}\) via this procedure as in Kuipers et al. (2022), we then approximate \(_{ij}\) through the following procedure:

1. We remove the acyclicity constraint from the prior (2) and compute the unconstrained posterior distribution \(^{u}()\), approximating the marginal probability \(^{u}(_{ij})\) under \(_{+}^{j}\).
2. We approximate the joint probability of a pair edges by the product \[(_{ij},_{ji})^{u}(_{ij})^{u} (_{ji}).\] (11)
3. We impose the simplest acyclicity constraint which avoids creating two edges with opposite directions, _i.e._ let \((_{ij}=1,_{ji}=1)=0\). Approximate \[_{ij}=(_{ij}=1,_{ji}=0)}{ (_{ij}=1,_{ji}=0)+(_{ij}=0,_{ji}=1)+ {}(_{ij}=0,_{ji}=0)}.\] (12)

The full details for the calculations of \(_{ij}\) are given in the supplementary material (Appendix C).

### Introducing the "reversal" neighborhood

In the original PARNI proposal for Bayesian variable selection, each \(K_{r}\) in the intermediate proposals corresponds to exactly one position \((i,j)\), such that \(k_{ij}=1\) and that each intermediate neighborhood \(((r-1),K_{r})\) only contains two DAGs: \((r-1)\) itself and the DAG obtained by flipping \(K_{r}\) in \((r-1)\). This sequential neighborhood construction is clearly not appropriate for the problem of DAG sampling and might result in very slow mixing. In addition, it is natural to assume that a pair of edges \(i j\) are highly correlated and thus equally likely to be included in a DAG. It is then necessary to specify a reversal move that achieves good mixing between pairs of edges. The neighborhood construction in the original PARNI proposal does not support a reversal move in one single sub-proposal. To elaborate on this, suppose that currently \(_{ij}=1\) and \(_{ji}=0\), to propose a reversal move according to the original PARNI proposal, we should first propose to remove \(_{ij}\) from the DAG, then include \(_{ji}\) in the following sub-proposals. These flips might be running into issues if the posterior model probability for excluding both edges, \(_{ij}=_{ji}=0\), is low, so that these moves are rarely proposed and the chain gets stuck at \(_{ij}=1\).

Therefore, we construct a bigger neighborhood containing the edge reversal move of a DAG. This modification allows for an edge reversal move within a single sub-proposal \(q_{g,K_{r}}\) without going through the low posterior probability models and avoids the chain getting stuck. To clarify this, suppose \(k\) is sampled at each iteration of the chain. For all those pairs which satisfy \(k_{ij}=1\) and \(k_{ji}=1\) in \(k\), we construct the reversal neighborhoods for edges \(_{ij}\) and \(_{ji}\). For other positions such that \(k_{ij}=1\), but \(k_{ji}=0\), we construct the original neighborhood which only contains the current model and model with \(_{ij}\) flipped. This reversal neighborhood specification is included into the main PARNI-DAG proposal given in the supplementary material (Appendix D).

### New adaptive scheme for better computational efficiency

Although the point-wise implementation reduces the per-iteration costs from exponential to linear in the neighborhood size (equivalent to the number of sub-neighborhoods in PARNI), the PARNI proposal is still computationally expensive when the sampled DAGs are not very sparse. For example, considering the gsim100 simulated data of Suter et al. (2023), featuring 161 true edges, we would be often required to compute 320 posterior DAG probabilities on average in a single MCMC iteration, and the computation thus becomes 320 times more expensive than the standard ADR proposal in this case. To reduce the computational cost of the PARNI-DAG proposal even more, we make use of a 'neighborhood thinning' parameter \(\) to control the number of neighborhoods to be evaluated.

In the original PARNI proposal, the thinning parameter \(\) represents the random walk jumping probability, so it does not take the posterior inclusion probabilities into account and does not affect the number of neighborhoods evaluated. For the new PARNI-DAG proposal instead, with probability \(1-\), we will skip evaluation of some of the neighborhoods. Within each iteration, for each point \(r\) in the sequence, given the current sub-proposal \((r-1)\) and sub-neighborhood indicator \(K_{r}\), PARNI-DAG:

1. with probability \(\), proposes \((r) q_{K_{r}}((r-1),)\) as in (5).
2. with probability \(1-\), does not evaluate the posterior probabilities of other DAGs in \(((r-1),K_{r})\), and directly propose \((r)=(r-1)\).

Varying \(\) can vary the number of posterior DAG probability evaluations. The larger the value of \(\), the more the DAG probabilities evaluated. If \(=1\), all neighborhoods are required to be evaluated to propose a new DAG.

The parameter \(\) is updated adaptively. Here, we consider the Robins-Monro adaptation scheme to update \(\) on the fly. At time \(t\), the new \(^{(t+1)}\) parameter is updated via

\[_{t}^{(t+1)}=_{t}^{(t)}-_{t}(_{t}-})\] (13)

where \(_{t}\) is number of sub-neighborhoods evaluated at time \(t\) and \(}\) is a pre-specified expected number of evaluations. We set \(_{t}=t^{-0.7}\), meaning that the adaptation of \(\) diminishes at the rate of \((t^{-0.7})\). From the empirical results, we find that \(}=10\) evaluated neighborhoods on average seems to achieve optimal balance between mixing performance and computational cost. Therefore, we choose to set \(}=10\) for most of the numerical studies in the next section and in the supplementary material.

## 4 Experiments

### Convergence and mixing efficiency

Protein data.We first consider the real-world protein-signalling dataset (Sachs et al., 2005), found also in Cundy et al. (2021), to test PARNI-DAG's mixing. The dataset consists of \(n=11\) nodes and \(N=853\) observations and the ground-truth DAG (17 edges) is provided by expert knowledge. We compare the performance of PARNI-DAG to ADR, Order MCMC and Partition MCMC. We provide the full details on the implementation of the compared models in the supplementary materials (Appendix E). For a fair comparison of the models, we re-define the score functions for Order and Partition MCMC such that all schemes target the same posterior distribution as specified in Section 2. Notice that for this dataset, it is feasible for all the four MCMC schemes to use the full skeleton, without the need to restrict the initial space (Kuipers et al., 2022). For ADR and PARNI-DAG, we use prior parameters \(g=10\) and \(h=1/11\).

We compare trace plots of log posterior DAG probabilities for ADR, PARNI-DAG and Partition MCMC in Figure 1. Since we could not extract the full score trace of Order MCMC using the BiDAG package (Suter et al., 2023), Order MCMC is not included in Figure 1. We ran ADR, PARNI-DAG and Partition MCMC for 480,000, 60,000 and 20,000 iterations respectively which take about the same CPU time3, and thin the output from ADR and PARNI-DAG so that 20,000 measures are kept. From Figure 1, all these three algorithms mix equally well, the only difference is that the PartitionMCMC algorithm explores more DAGs with lower probabilities. We then compare the median mean squared errors (MSE) on estimating PEPs compared to a ground-truth estimate. The MSE assesses both the convergence of the chain and the bias in the Monte Carlo estimates. The ground-truth PEPs were obtained by running Partition MCMC for approximately 5 hours. We ran all algorithms for 20 replications. Each individual chain was run for 3 minutes. The MSE estimates are presented in Table 1. The structure MCMC schemes (ADR and PARNI-DAG) generally outperform Order MCMC and Partition MCMC and return estimates with lower MSE. Notice that ADR in this specific case also outperforms PARNI-DAG, since the dataset is very low-dimensional (11 nodes), with PARNI-DAG not trailing very far behind. We will demonstrate in the next experiments how PARNI-DAG instead performs better in higher-dimensional settings.

gsim100 data.We also study the performance of ADR, PARNI-DAG, Order MCMC and Partition MCMC on a more complex graph, the gsim100 simulated dataset, found in the BiDAG package (Suter et al., 2023). This features a randomly generated DAG with \(n=100\) nodes and \(N=100\) observations, with 161 true edges. For ADR and PARNI-DAG we set prior parameters to \(g=10\) and \(h=1/100\). Since \(n>20\), it is not feasible to use the full skeleton as in the protein dataset. So we consider two skeletons to restrict the initial space: PC derived skeleton \(_{}\) and the skeleton derived with the iterative procedure of Kuipers et al. (2022)\(_{}\), featuring more edges than \(_{}\).

We examine the trace plot of log posterior DAG probabilities from ADR, PARNI-DAG and Partition MCMC using both skeletons \(_{}\) and \(_{}\) respectively (Figure 2). We ran ADR, PARNI-DAG and Partition MCMC for 80,000, 20,000 and 20,000 iterations respectively. Notice that, under both \(_{}\) and \(_{}\), PARNI-DAG converges very quickly to the high-probabilistic region, whereas ADR takes longer. Partition MCMC under \(_{}\) cannot reach the same high-probability region as it targets a posterior distribution restricted to \(_{}\), which is biased if \(_{}\) excludes true positive edges. Under the more populated \(_{}\) instead it converges, but still slower than PARNI-DAG. When comparing median MSEs on PEPs on this dataset, we considered 20 replications with each individual chain being run for 15 minutes. As for Order and Partition MCMC, \(_{}\) seems to lead to slightly better performance than \(_{}\). This might be due to the fact that in this high-dimensional example \(_{}\) includes considerably more DAGs than \(_{}\), so Order MCMC, and even more so Partition MCMC, take longer to explore the space. As for ADR and PARNI-DAG, the choice of \(\) does not have a big impact, as in their case this is used only to warm-start the chain and not to restrict the space. PARNI-DAG here outperforms ADR and it is competitive to Order MCMC as well, without introducing biases stemming from search space restriction and sampling.

### DAG learning accuracy

Lastly, we compare performance of PARNI-DAG with other main methods in recovering the underlying true DAG on four different real-world graph structures. These graph structures are taken from the

  algorithm & MSE \\ 
**ADR** & 8.84 \\
**PARNI-DAG** & 19.44 \\
**Order MCMC** & 145.17 \\
**Partition MCMC** & 121.83 \\   

Table 1: Protein dataset: time-normalised median MSE (\( 10^{-8}\)) on estimating posterior edge probabilities. (_Lower is better_.)

Figure 1: Protein dataset: trace plots of log posterior model probabilities. All algorithms were ran for the same CPU-time and thinned to 20,000 measures.

R package bnlearn4 and include: i) _ecoli70_ dataset, with \(n=46\) nodes and \(70\) edges; ii) _magic-niab_ dataset, with \(n=44\) nodes and \(66\) edges; iii) _magic-irri_ dataset, with \(n=64\) nodes and \(102\) edges; iv) _arth150_ dataset, with \(n=107\) nodes and \(150\) edges. Given the graph structure and its associated parameters, we simulate \(N=100\)_i.i.d._ observations for each of the four cases. The models we compare include: i) **PC** algorithm; ii) **GES**; iii) **LiNGAM**; iv) **DiBS**, a differentiable variational method introduced by Lorch et al. (2021); v) **DiBS\(+\)**, a version of DiBS with the weighted particle mixture; vi) **DECI**, another non-linear additive noise model that uses variational inference introduced by Geffner et al. (2022); vii) **Order MCMC**, on a restricted space defined by the skeleton of the PC algorithm; viii) **Iterative MCMC**, the version of Order MCMC run on a search space defined by starting with the PC skeleton, and iteratively expanding the possible parent sets until the score cannot be improved (Kuipers et al., 2022); ix) **Partition MCMC**, on the same space defined by the iterative procedure in Iterative MCMC; x) **ADR** scheme and xi) **PARNI-DAG**, both with pre-tuning of the \(\)'s using the Iterative-derived skeleton. All the score-based methods (GES, Order, Partition, Iterative) are assigned an edge-penalty parameter equal to \(2log(n)\), as suggested in (Kuipers et al., 2022), to adjust to potentially sparse graphs. Performance is measured via the Structural Hamming Distance between the true DAG and the estimated DAG, averaged over \(20\) replications of the experiment, for each dataset. Results are collected in Table 3. Notice how PARNI-DAG is either the best or the second best method across all four experiments. In particular, it statistically matches the performance of the resulting best MCMC scheme in the first three experiments featuring a lower number of nodes, while it significantly outperforms all the methods in the case with high number of nodes (_arth150_), as expected. All variational methods (DiBS, DiBS\(+\) and DECI) struggle to detect edges in these low-sample setups as they require a stronger signal (or a larger sample, as featured in the experiments in Lorch et al. (2021); Geffner et al. (2022)) to perform well. Additionally, they are significantly slow to converge and run into numerical instability issues in the last large-\(n\) dataset (_arth150_).

## 5 Limitations

Although the PARNI-DAG proposal has demonstrated significant improvements over the state-of-the-art algorithms considered in the previous section, it still comes with a few limitations that can be addressed. The first limitation lies in the linearity assumption. In fact, in order to derive the closed-form marginal likelihood featured in the locally informed proposal, PARNI-DAG is currently constrained to the linear model assumption described in (1). This can potentially result in model misspecification in presence of non-linear relationships, which is a threat in cases where this hampers edges identifiability. The recent work of Liang et al. (2023) has shed light on how to efficiently extend the PARNI proposal to more general non-linear models, and can possibly be adjusted to Bayesian structure learning settings that employ Additive Noise Models (ANMs) (Hoyer et al., 2008), where a closed-form marginal likelihood does not exist. The second limitation of the PARNI-DAG proposal is the computational cost associated with the likelihood evaluation, which scales at least linearly in the

   skeleton & algorithm & MSE \\  _{}\)} & **ADR** & 2.91 \\  & **PARNI-DAG** & 1.83 \\  & **Order MCMC** & 1.79 \\  & **Partition MCMC** & 12.75 \\  _{}\)} & **ADR** & 2.37 \\  & **PARNI-DAG** & 1,72 \\   & **Order MCMC** & 1.84 \\   & **Partition MCMC** & 31.16 \\   

Table 2: table

gsim100 dataset:

time-normalised median MSE (\( 10^{-7}\)) on estimating posterior edge probabilities. (_Lower is better._)

Figure 2: gsim100 dataset: trace plots of log posterior model probabilities. All algorithms were ran for the same CPU-time and thinned to 20,000 measures.

number of datapoints. The issue arises as the likelihood features both in the informed proposals and in the MH step. A viable solution to this problem consists in the possibility of coupling PARNI-DAG with optimal sub-sampling MCMC procedures, such as the ones presented in Korattikara et al. (2014) and Maclaurin and Adams (2014) (FireflyMC). These limitations associated with the PARNI-DAG proposal provide us with interesting future research directions, aimed at improving its scalability and capability to handle more complex data.

## 6 Discussion

In this work, we proposed a novel MCMC sampler, PARNI-DAG, for a fully Bayesian approach to the problem of structure learning. PARNI-DAG samples directly from the space of DAGs and introduces improvements in terms of computational complexity and MCMC mixing, stemming from the nature of its adaptive random neighborhood informed proposal. This proposal facilitates moves to higher probability regions, and is particularly useful when dealing with high-dimensional settings with a high number of nodes, as demonstrated in the experimental section. In future work, we will consider adding global moves to the PARNI-DAG proposal, which re-generates a new DAG model every few iterations, to specifically tackle settings with highly correlated structures.

In addition, we are also interested in studying PARNI's theoretical mixing time bounds. In fact, although the mixing time bound for random walk proposals has been largely studied, similar results for the class of locally informed proposals are relatively under-developed, due to the complexities arising in the proposal distributions. Most results on mixing time in discrete sample spaces focus on the problem of Bayesian variable selection. It has been shown by Yang et al. (2016) that a random walk proposal (specifically the add-delete-swap proposal) can achieve polynomial-time mixing under mild conditions on the posterior distribution. Under similar conditions, Zhou et al. (2022) has shown that the mixing time of the Locally Informed and Thresholded proposal (LIT) does not depend on the number of covariates. The mixing time bound of MCMC samplers in Bayesian structure learning settings is notoriously harder to study, due to the higher complexity of the sample space of DAGs. The recent work of Zhou and Chang (2023) has shed light on the analysis of mixing time bounds for Bayesian structure learning as a generalisation of the results in Yang et al. (2016). Zhou and Chang (2023) has proven that the mixing time of the Random Walk Greedy Equivalent Search (RW-GES) proposal is at most linear in the number of covariates and the number of datapoints. Moreover, they also presented the necessary conditions for posterior consistency in Bayesian structure learning. It has not been formally proven yet that the informed proposal achieves faster theoretical mixing time compared to the random walk proposal in the context of Bayesian structure learning, although the empirical experiments we conducted suggest so. Similarly, it is highly likely then that the PARNI-DAG proposal can also achieve dimension-free mixing, such as the LIT proposal. We leave the topic of theoretical mixing time bounds of the PARNI proposal in different applications (e.g., Bayesian variable selection, Bayesian structure learning) to future research.

    & **ecoli70** & **magic-niab** & **magic-irri** & **arth150** \\ 
**PC** & 62.65 \(\) 1.64 & 66.95 \(\) 0.82 & 103.75 \(\) 0.91 & 126.70 \(\) 2.10 \\
**GES** & 47.95 \(\) 1.72 & 65.50 \(\) 0.42 & 97.60 \(\) 0.99 & 129.70 \(\) 3.47 \\
**LiNGAM** & 107.4 \(\) 3.96 & 71.60 \(\) 1.34 & 111.25 \(\) 2.34 & - \\ 
**DiBS** & 71.05 \(\) 0.17 & 65.80 \(\) 0.24 & 102.35 \(\) 0.17 & - \\
**DiBS\(+\)** & 71.25 \(\) 0.28 & 64.70 \(\) 0.36 & 100.45 \(\) 0.40 & - \\
**DECI** & 70.95 \(\) 0.02 & 66.95 \(\) 0.02 & 102.00 \(\) 0.00 & - \\ 
**Order MCMC** & 42.85 \(\) 1.30 & **62.05 \(\) 1.52** & **92.90 \(\) 1.46** & 110.00 \(\) 1.96 \\
**Iterative MCMC** & **39.55 \(\) 2.15** & 65.00 \(\) 2.43 & 96.15 \(\) 2.11 & 119.45 \(\) 3.43 \\
**Partition MCMC** & 48.85 \(\) 2.76 & 66.20 \(\) 1.62 & 103.35 \(\) 1.81 & 140.75 \(\) 4.04 \\
**ADR** & **39.40 \(\) 1.27** & 64.25 \(\) 0.64 & 95.20 \(\) 1.16 & 143.15 \(\) 1.62 \\
**PARNI-DAG** & **37.55 \(\) 1.59** & **64.14 \(\) 0.55** & **91.85 \(\) 0.97** & **97.60 \(\) 2.16** \\   

Table 3: SHD averaged over \(20\) replications with associated 95% confidence intervals of the various models compared on the four datasets (\(n=100\)). All algorithms were ran for approximately the same CPU-time and the significantly best performing models are given in **bold**. (_Lower is better._)