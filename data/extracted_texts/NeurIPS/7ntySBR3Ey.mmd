# Energy-Efficient Scheduling with Predictions

Eric Balkanski

Columbia University

eb3224@columbia.edu &Noemie Perivier

Columbia University

np2708@columbia.edu &Clifford Stein

Columbia University

cliff@ieor.columbia.edu &Hao-Ting Wei

Columbia University

hw2738@columbia.edu

###### Abstract

An important goal of modern scheduling systems is to efficiently manage power usage. In energy-efficient scheduling, the operating system controls the speed at which a machine is processing jobs with the dual objective of minimizing energy consumption and optimizing the quality of service cost of the resulting schedule. Since machine-learned predictions about future requests can often be learned from historical data, a recent line of work on learning-augmented algorithms aims to achieve improved performance guarantees by leveraging predictions. In particular, for energy-efficient scheduling, Bamas et. al. [NeurIPS '20] and Antoniadis et. al. [SWAT '22] designed algorithms with predictions for the energy minimization with deadlines problem and achieved an improved competitive ratio when the prediction error is small while also maintaining worst-case bounds even when the prediction error is arbitrarily large.

In this paper, we consider a general setting for energy-efficient scheduling and provide a flexible learning-augmented algorithmic framework that takes as input an offline and an online algorithm for the desired energy-efficient scheduling problem. We show that, when the prediction error is small, this framework gives improved competitive ratios for many different energy-efficient scheduling problems, including energy minimization with deadlines, while also maintaining a bounded competitive ratio regardless of the prediction error. Finally, we empirically demonstrate that this framework achieves an improved performance on real and synthetic datasets.

## 1 Introduction

Large data centers and machine learning models are important contributors to the growing impact that computing systems have on climate change. An important goal is thus to efficiently manage power usage in order to not only complete computing tasks in a timely manner but to also minimize energy consumption. In many operating systems, this tradeoff can be controlled by carefully scaling the speed at which jobs run. An extensive area of scheduling has studied such online (and offline) speed scaling problems (see, e.g., ). Since the speed of many processors is approximately the cube root of their power , these works assume that the power of a processor is equal to speed to some power \( 1\), where \(\) is thought of as being approximately \(3\) and the total energy consumption is power integrated over time.

Online energy-efficient scheduling algorithms have mostly been evaluated using competitive analysis, which provides robust guarantees that hold for any instance. However, since competitive analysis evaluates algorithms over worst-case instances, it can often be pessimistic. In particular, it ignores thefact that, in the context of scheduling, future computation requests to computing systems can often be estimated from historical data. A recent line of work on algorithms with predictions aims to address this limitation by assuming that the algorithm designer is given access to machine-learned predictions about the input. In the context of online algorithms, where this line of work has been particularly active, the predictions are about future requests and the goal is to achieve improved competitive ratios when the predictions are accurate (consistency), while also maintaining the benefits of worst-case analysis with guarantees that hold even when the predictions are arbitrarily wrong (robustness).

In this framework with predictions, Bamas et al.  and Antoniadis et al.  recently studied the energy minimization with deadlines problem, which is a classical setting for energy-efficient scheduling (see, e.g., ). However, there are many scenarios where the jobs do not have strict deadlines and the goal is instead to minimize the job response time. In energy plus flow time minimization problems, which are another family of energy-efficient scheduling problems that have been extensively studied in the setting without predictions, the objective is to minimize a combination of the energy consumption and the flow time of the jobs, which is the difference between their release date and completion time (see, e.g., ).

In this paper, we study a general energy-efficient scheduling problem that we augment with predictions. This general problem includes both energy minimization with deadlines, which has been previously studied with predictions, and energy plus flow time minimization, which has not been previously studied with predictions, as well as many other variants and generalizations. In particular, the flow time problem with predictions introduces challenges that require novel learning-augmented scheduling algorithms (see Section 3 for additional discussion).

### Our results

An instance of the General Energy-efficient Scheduling (GES) problem is described by a collection \(\) of \(n\) jobs and an arbitrary quality of service cost function \(F\). Each job \((j,r_{j},p_{j})\) consists of a release time \(r_{j}\), a processing time \(p_{j}\), and an identifier \(j\) (and potentially other parameters such as weights \(v_{j}\) or deadlines \(d_{j}\)). A schedule \(S\) is specified by the speeds \(s_{j}(t)\) at which job \(j\) is processed by the machine at time \(t\). The goal is to find a schedule of minimum cost \(E(S)+F(S,)\), where the energy consumption of a schedule is \(E(S)=_{t 0}(_{j}s_{j}(t))^{}\), for some constant \(>0\). In the general energy-efficient scheduling with predictions (GESP) problem, the algorithm is given at time \(t=0\) a collection \(}\) of \(\) predicted jobs \((j,_{j},_{j})\), which is a similar prediction model as in . For all our results, we assume that the quality cost function \(F\) is monotone and subadditive, which are two mild conditions that are satisfied for the problems with flow times and with deadlines.

**Near-optimal consistency and bounded robustness.** Our first goal is to design an algorithm for the GESP problem that achieves a good tradeoff between its consistency (competitive ratio when the predictions are exactly correct) and robustness (competitive ratio when the predictions are arbitrarily wrong). Our first main result is that for any instance of the GES problem for which there exists a constant competitive algorithm and an optimal offline algorithm, there is an algorithm with predictions that is \(1+\) consistent and \(O(1)\) robust for any constant \((0,1]\) (Corollary 3.5). Since problems

   &  &  \\   & without & with & & Consistency & Robustness \\   Flow time & 2  & & & & \\  Fractional weighted & 2  & None & \((1+(2)^{})^{}\) & \(^{}}{}\) \\ flow time & & & & & \\  Integral weighted & )^{2})\)} & & \((1+(()^{2})^{})^{}\) & \(

with the flow time and the problem with deadlines admit constant-competitive algorithms, we achieve a consistency that is arbitrarily close to optimal while also maintaining constant robustness for these problems (see Table 1 for a summary of problem-specific upper bounds). We complement this result by showing that there is a necessary trade-off between consistency and robustness for the flow time problem: for any \(>0\), there is no \(1+\)-consistent algorithm that is \(o()\)-robust (Appendix A.2).

**The competitive ratio as a function of the prediction error.** The second main result is that our algorithm achieves a competitive ratio that smoothly interpolates from the \(1+\) consistency to the constant robustness as a function of the prediction error (Theorem 3.4). To define the prediction error, we denote by \(^{+}=}\) the jobs that are correctly predicted. We define the prediction error \(=()}\{( ^{+}),(}^{+})\}\), which is the maximum between the optimal cost of scheduling the jobs \(^{+}\) that arrived but were not predicted to arrive and the cost of the jobs \(}^{+}\) that were predicted to arrive but did not arrive. This prediction error is upper bounded by the prediction error in  for the problem with uniform deadlines.

**Extension to jobs that are approximately predicted correctly.** We generalize our algorithm and the previous result to allow the correctly predicted jobs \(^{+}\) to include jobs that are approximately predicted correctly, where the tolerable approximation is parameterized by a parameter chosen by the algorithm designer. The result for this extension requires an additional smoothness condition on the quality cost \(F(S,)\) of a schedule. This condition is satisfied for the flow time problem, but not by the one with deadlines.1

**Experiments.** In Section 5, we show that when the prediction error is small, our algorithm empirically outperforms on both real and synthetic datasets the online algorithm that achieves the optimal competitive ratio for energy plus flow time minimization without predictions.

### Related work

**Energy-efficient scheduling.** Energy-efficient scheduling was initiated by Yao et al. , who studied the energy minimization with deadlines problem in both offline and online settings. These offline and online algorithms were later improved in [13; 10]. Over the last two decades, energy-efficient scheduling has been extended to several other objective functions. In particular, Albers and Fujiwara  proposed the problem of energy plus flow time minimization, which has been studied extensively (see, e.g., [3; 8; 14; 12; 18; 11; 9]).

**Learning-augmented algorithms.** Algorithms with predictions is a recent and extremely active area, especially in online algorithms, where it was initiated in [22; 27]. Many different scheduling problems have been studied with predictions (see, e.g., [19; 24; 17; 20; 6; 5; 16; 21]).

**Learning-augmented energy-efficient scheduling.** Energy-efficient scheduling with predictions has been studied by Antoniadis et al.  and Bamas et al. , who focus on the problem with deadlines, which is a special case of our setting. The prediction model in Bamas et al.  is the closest to ours. For the problem with deadlines, the algorithm in  achieves a better consistency-robustness tradeoff than our algorithm, but their algorithm and prediction model do not extend to more general energy-efficient scheduling problems such as the flow time problem. In addition, the competitive ratio as a function of the prediction error is only obtained in  in the case of uniform deadlines where the difference between the deadline and release date of a job is equal for all jobs (the authors mention that defining algorithms for general deadlines becomes complex and notationally heavy when aiming for bounds as a function of the prediction error). Thanks to our algorithmic framework and definition of prediction error, our bound generalizes to the non-uniform deadlines without complicating our algorithm. Antoniadis et al.  propose a significantly different prediction model that requires an equal number of jobs in both the prediction \(}\) and true set of jobs \(\). Consequently, their results are incomparable to ours and those by Bamas et al. .

## 2 Preliminaries

In the _General Energy-Efficient Scheduling (GES)_ problem, an instance is described by a collection \(\) of \(n\) jobs and a real-valued cost function \(F(S,)\) that takes as input the instance \(\) and a schedule \(S\) for \(\), and returns some quality evaluation of the schedule. Each job \((j,r_{j},p_{j})\) consists of a release time \(r_{j}\), a processing time \(p_{j}\), and an identifier \(j\) (and potentially other parameters such as weights \(v_{j}\) and deadlines \(d_{j}\)). We often abuse notation and write \(j\) instead of \((j,r_{j},p_{j})\). For any time interval \(I\), we let \(_{I}=\{j:r_{j} I\}\) be the subset of jobs of \(\) with release time in \(I\). For intervals \(I=[0,t]\) or \(I=[t,]\), we write \(_{ t}\) and \(_{ t}\).

A _feasible schedule_ for a set of jobs \(\) is specified by \(S=\{s_{j}(t)\}_{t 0,j_{ t}}\), where \(s(t):=_{j_{ t}}s_{j}(t)\) is the speed at which the machine runs at time \(t\). Thus, \(s_{j}(t)/s(t)\) is the fraction of the processing power of the machine allocated to job \(j\) at time \(t\).2 During a time interval \(I\), there are \(_{I}s_{j}(t)\) units of work for job \(j\) that are completed and we let \(S_{I}\) be the sub-schedule \(\{s_{j}(t)\}_{t I,j_{I}}\). The cost function we consider is a combination of energy consumption and quality cost for the output schedule. The energy consumption incurred by a schedule is \(E(S)=_{t 0}s(t)^{}\), where \(>1\) is a problem-dependent constant, chosen so that the power at time \(t\) is \(s(t)^{}\). To define the quality of a schedule, we introduce the _work profile_\(W^{S}_{j}:=\{w^{S}_{j}(t)\}_{t r_{j}}\) of schedule \(S\) for job \(j\), where \(w^{S}_{j}(t):=p_{j}-_{r_{j}}^{t}s_{j}(u)\) is the amount of work for \(j\) remaining at time \(t\).

We consider general objective functions of the form \((S,)=E(S)+F(S,)\) and the goal is to compute a feasible schedule of minimum cost. \(F(S,)=f((W^{S}_{1},j_{1}),,(W^{S}_{n},j_{n}))\) is an arbitrary _quality cost_ function that is a function of the work profiles and the jobs' parameters. In the energy minimization with deadlines problem, \(F(S,)=\) if there is a job \(j\) with completion time \(c^{S}_{j}\) such that \(c^{S}_{j}>d_{j}\), and \(F(S,)=0\) otherwise. In the energy plus flow time minimization problem, we have \(F(S,)=_{j}c^{S}_{j}-r_{j}\) (see Section 3.3 for additional functions \(F\)). A function \(F(S,)\) is subadditive if for all sets of jobs \(_{1}\) and \(_{2}\), we have \(F(S,_{1}_{2}) F(S,_{1})+F(S,_{2})\). \(F\) is monotone if for all sets of jobs \(\) and schedules \(S\) and \(S^{}\) such that \(w^{S}_{j}(t) w^{S^{}}_{j}(t)\) for all \(j\) and \(t r_{j}\), we have that \(F(S,) F(S^{},)\). We assume throughout the paper that \(F\) is monotone subadditive, which holds for the deadlines and flow time problems. We let \(S^{*}()\) and \(():=(S^{*}(),)\) be an optimal offline schedule and the optimal objective value.

**The general energy-efficient scheduling with predictions problem.** We augment the GES problem with predictions regarding future job arrivals and call this problem the General Energy-Efficient Scheduling with Predictions problem (GESP). In this problem, the algorithm is given at time \(t=0\) a prediction \(}=\{(j,_{j},_{j})\}\) regarding the jobs \(=\{(j,r_{j},p_{j})\}\) that arrive online. An important feature of our prediction model is that the number of predicted jobs \(|}|\) can differ from the number of true jobs \(||\).

Next, we define a measure for the prediction error which generalizes the prediction error in  for the problem with uniform deadlines to any GES problem. With \(^{+}=}\) being the correctly predicted jobs, we define the prediction error as

\[(,})=(})} \{(^{+}),(}^{+})\},\]

where \((^{+})\) is the optimal cost of scheduling the true jobs \((j,r_{j},p_{j})\) such that either the prediction for \(j\) was wrong or there was no prediction for \(j\) and that \((}^{+})\) is the optimal cost of scheduling the predicted jobs \((j,_{j},_{j})\) such that either the prediction for \(j\) was wrong or \(j\) never arrived. The prediction error \((,})\) is then the maximum of these costs, normalized by the optimal cost \((})\) of scheduling the predicted jobs. We assume that \(}\) to ensure that \((,})\) is well-defined. This prediction error is upper bounded by the prediction error \(||w^{}-w^{}||^{}_{}\) considered in  for the problem with uniform deadlines, which we prove in Appendix F.1. Here \(w^{}\) and \(w^{}\) are the true and predicted workload at each time step \(t\), i.e., the sum of the processing times of the jobs that arrive at \(t\).

[MISSING_PAGE_EMPTY:5]

The algorithm proceeds in two phases. In the first phase (Lines 1-5), TPE ignores the predictions and runs the auxiliary online algorithm OnlineAlg over the true jobs \(_{ t}\) that have been released by time \(t\). More precisely, during the first phase of the algorithm, \(s_{j}(t)\) is the speed according to the online algorithm OnlineAlg for all jobs. The first phase ends at the time \(t_{}\) when the cost of the offline schedule computed by running OfflineAlg on jobs \(_{ t}\) reaches the threshold value \((})\). As we will detail in the analysis section, this first phase guarantees a bounded robustness since we ensure that the offline cost for the true jobs reaches some value before starting to trust the predictions (hence, TPE does not initially 'burn' too much energy compared to the optimal offline cost, unlike the example described in Appendix A.1).

In the second phase (Lines 6-9), TPE starts leveraging the predictions. More precisely, TPE needs to set the speeds for three different types of jobs: (1) the remaining jobs that were correctly predicted (i.e., \(_{ t_{}}}_{ t_{}}\)) (2) the remaining jobs that were not predicted (i.e., \(_{ t_{}}}_{ t_{}}\)) (3) the jobs that were not correctly scheduled in the first phase and still have work remaining at the switch point \(t_{}\) (which are a subset of \(_{<t_{}}\)). To schedule these jobs, TPE combines two different schedules. The first one is the offline schedule \(:=(}_{ t_{}})\) for the jobs \(}_{ t_{}}\) that are predicted to arrive in the second phase. Each future job in the true set that was correctly predicted (i.e., \(j_{[t_{},t]}}_{ t_{}}\) on Line 9) will then be scheduled by following \(\). The second schedule is an online schedule for the set of jobs \(}_{ t_{}}=_{<t_{ }}_{ t_{}}}_{ t_ {}}\), which includes all jobs that have not been completed during the first phase (\(_{<t_{}}\)) and the incorrectly predicted jobs that are released during the second phase (\(_{[t_{},t]}}_{ t_{}}\)). This online schedule is constructed by running OnlineAlg on the set \(}_{ t_{}}\) (Line 8). Note that the total speed of the machine at each time step is the sum of the speeds of these two online and offline schedules.

### Analysis of the algorithm

We analyze the competitive ratio of TPE as a function of the prediction error \(\), from which the consistency and robustness bounds follow. Missing proofs are provided in Appendix B. We separately bound the cost of the algorithm due to jobs in \(_{<t_{}}\), \(_{ t_{}}}_{ t_{}}\) and \(_{ t_{}}}_{ t_{}}\). We do this by analyzing the costs of schedules \(S^{on}:=(}_{ t_{ }})\) and \(:=(}_{ t_{}})\). In the next lemma, we first analyze the cost of combining, i.e., summing, two arbitrary schedules.

**Lemma 3.1**.: _Let \(_{1}\) be a set of jobs and \(S_{1}\) be a feasible schedule for \(_{1}\), let \(_{2}\) be a set of jobs and \(S_{2}\) be a feasible schedule for \(_{2}\). Consider the schedule \(S:=S_{1}+S_{2}\) for \(_{1}_{2}\) which, at each time \(t\), runs the machine at total speed \(s(t)=s_{1}(t)+s_{2}(t)\) and processes each job \(j_{1}\) at speed \(s_{1,j}(t)\) and each job \(j_{2}\) at speed \(s_{2,j}(t)\). Then, \((S,_{1}_{2})((S_{ 1},_{1})^{}+(S_{2},_{2})^{ })^{}\)._

We next upper bound the cost of the schedule output by TPE as a function of the prediction error \(\), which we decompose into \(_{1}=()}{( )}\) and \(_{2}=()}{( )}\). The proof uses the previous lemma repeatedly, first to analyze the cost of the schedule \(S^{on}:=(}_{ t_{ }})\) for the set of jobs \(}_{ t_{}}=(_{<t_{ }})(_{ t_{}}}_{ t _{}})\), then to analyze the cost of the final schedule, which combines \(S^{on}\) and \(:=(}_{ t_{}})\).

**Lemma 3.2**.: _Assume that OfflineAlg is \(_{}\)-competitive and that OnlineAlg is \(_{}\)-competitive. Then, for all \((0,1]\), the schedule \(S\) output by TPE run with confidence parameter \(\) satisfies \((S,)(})(_{ }^{}+_{}^{}(( _{})^{}+_{1}^{}))^{ }\)._

Proof.: We start by upper bounding \((S^{on},}_{ t_{}})\). First, by the algorithm, we have that \((_{<t_{}})(})\). Since OfflineAlg is \(_{}\)-competitive, we get

\[(_{<t_{}})(_{<t_{ }})(})_{ }(}).\]

We also have that \((_{ t_{}}}_{ t _{}})(})_{1 }(})\) where the first inequality is since \(_{ t_{}}}_{ t_{}} }\) and the second is by definition of \(_{1}\). Recall that \(S^{*}(.)\) denotes the optimal offline schedule for the problem and consider the schedule \(S^{}=S^{}(_{<t_{}})+S^{}(_{ t_{ }}}_{ t_{}})\) for \(}_{ t_{}}=_{<t_{ }}(_{ t_{}}}_{ t_{ }})\). We obtain that

\[(}_{ t_{ }}) (S^{},}_{  t_{}})((_{<t_{}})^{ {}}+(_{ t_{}} }_{ t_{}})^{})^{}\] \[((_{}(}))^{}+(_{1}(}))^{}))^{}\] \[=(})((_{ })^{}+_{1}^{})^{},\]

where the second inequality is by Lemma 3.1. Since we assumed that OnlineAlg is \(_{}\)-competitive,

\[(S^{on},}_{ t_{ }})_{}(}_{ t_{}})_{}(})((_{})^{}+_{1}^{ })^{}.\]

We now bound the cost of schedule \(S\). First, note that \((,}_{ t_{}})=( }_{ t_{}})_{} (})_{}(} ),\) where the first inequality is since OfflineAlg is \(_{}\)-competitive and the last one since \(}_{ t_{}}}.\) Therefore, by applying again Lemma 3.1, we get:

\[(S,) ((,}_{ t_{ }})^{}+(S^{on},}_{ t_{}})^{})^{}\] \[((_{}(}))^{}+(_{}(})((_{})^{}+_{1}^{ })^{})^{})^{}\] \[=(})(_{}^{ }+_{}^{}((_{})^{}+_{1}^{}))^{}.\]

We next state a simple corollary of Lemma 3.1.

**Corollary 3.3**.: \((})(1-_{2}^{ {}})^{}(})\)_, and, assuming that OfflineAlg is \(_{}\)-competitive, we have: if \(()(})\), then \(_{2}(1-(_{})^{})^{ }\)._

We are ready to state the main result of this section, which is our upper bound on the competitive ratio of TPE.

**Theorem 3.4**.: _For any \((0,1]\),_ TPE _with a \(_{}\)-competitive algorithm OnlineAlg _and a \(_{}\)-competitive offline algorithm OfflineAlg achieves a competitive ratio of_

\[_{}&() (})\\ }^{}+(( _{})^{}+_{1}^{} ))^{}}{\{}}, _{1}+(1-_{2}^{})^{}\}}&.\]

The consistency and robustness immediately follow (for simplicity, we present the results in the case where OfflineAlg is optimal). Additional discussion on this competitive ratio is provided in Appendix 3.4.

**Corollary 3.5**.: _For any \((0,1)\),_ TPE _with a \(_{}\)-competitive algorithm OnlineAlg _and an optimal offline algorithm OfflineAlg is \(1+_{}2^{}^{}\) competitive if \(_{1}=_{2}=0\) (consistency) and \(\{_{},}2^{2}^{ {}}}{}\}\)-competitive for all \(_{1},_{2}\) (robustness). In particular, for any constant \(>0\), with \(=(}2^{}})^{}\),_ TPE _is \(1+\)-consistent and \(O(1)\)-robust._

### Results for well-studied GES problems

We apply the general framework detailed in Section 3 to derive smooth, consistent and robust algorithms for a few classically studied objective functions.

**Energy plus flow time minimization.** Recall that \(c_{S}^{j}\) denote the completion time of job \(j\). The quality cost function is defined as: \(F(S,)=_{j}(c_{S}^{j}-r_{j})\), with total objective \((S,)=F(S,)+E(S)\). By a direct application of Corollary 3.5, we get that for all \((0,1]\), Algorithm 1run with the 2-competitive online algorithm from  and confidence parameter \(\) is \((1+2^{}^{})^{}\)-consistent and \(^{}}{}\)-robust.

**Energy plus fractional weighted flow time minimization.** In this setting, each job has a weight \(v_{j}\). The quality cost is \(F(S,)=_{j}v_{j}_{t r_{j}}w_{j}^{S}(t)\)dt. We can use as OnlineAlg the 2-competitive algorithm from .

**Energy plus integral weighted flow time minimization.** In this setting, each job has a weight \(v_{j}\). The quality cost function is defined as: \(F(S,)=_{j}v_{j}(c_{S}^{j}-r_{j})\). We can use as OnlineAlg the \(O((/)^{2})\)-competitive algorithm from .

**Energy minimization with deadlines.** In this setting, there is also a deadline \(d_{j}\) for the completion of each job. By writing the quality cost as \(F(S,)=_{j}_{c_{S}^{j}>d_{j}}\), where \(_{c_{S}^{j}>d_{j}}=+\) if \(c_{S}^{j}>d_{j}\) and \(0\) otherwise, the total objective can be written as \((S,)=E(S)+F(S,)\). We can use as OnlineAlg the Average Rate heuristic  (which is \(2^{}\)-competitive for uniform deadlines ). In particular, for uniform deadlines, and for all \((0,1]\), by setting \(=(}})^{}\), we obtain a consistency of \((1+)\) for a robustness factor of \(O(4^{^{2}}/^{-1})\).

### Discussion on the competitive ratio

We assume in this section that OfflineAlg is optimal. Note that for small \(_{1}\) and \(_{2}\), the competitive ratio is upper bounded as \(}^{}(^{ }+_{1}^{}))^{}}{_{1}+(1-_{2}^{ })^{}}\), which smoothly goes to \((1+_{}^{}^{})^{}\) (consistency case) when \(_{1},_{2}\) go to \(0\). Moreover, our upper bound distinguishes the effect of two possible sources of errors on the algorithm: (1) when removing jobs from the prediction (\(_{1}=0\) and \(_{2}\) goes to \(1\)), the upper bound degrades monotonically to \(O()\). (2) when adding jobs to the prediction (\(_{2}=0\) and \(_{1}\) goes to \(+\)), the upper bound first degrades, then improves again, with an optimal asymptotic rate of \(_{}\). This is since our algorithm mostly follows the online algorithm when the cost of the additional jobs dominates.

## 4 The Extension to Small Deviations

Note that in the definition of the prediction error \(\), a job \(j\) is considered to be correctly predicted only if \(r_{j}=_{j}\) and \(p_{j}=_{j}\). In this extension, we consider that a job is correctly predicted even if its release time and processing time are shifted by a small amount. We also allow each job to have some weight \(v_{j}>0\), that can be shifted as well. Assuming an additional smoothness condition on the quality cost function \(F(.,.)\), which is satisfied for the energy plus flow time minimization problem and its variants, we propose and analyze an algorithm that generalizes the algorithm from the previous section.

The algorithm, called TPE-S and formally described in Appendix C, takes the same input parameters as Algorithm TPE, with some additional shift tolerance parameter \(^{}[0,1)\) that is chosen by the algorithm designer. Two main ideas are to artificially increase the predicted processing time \(_{j}\) of each job \(j\) (because the true processing time \(p_{j}\) of job \(j\) could be shifted and be slightly larger than \(_{j}\)) and to introduce small delays for the job speeds (because the true release time \(r_{j}\) of some jobs j could be shifted and be slightly later than \(_{j}\)). Details can be found in Appendix C.

## 5 Experiments

We empirically evaluate the performance of Algorithm TPE-S on both synthetic and real datasets. Specifically, we consider the energy plus flow time minimization problem where \(F(S,)=_{j}c_{j}-r_{j}\) and consider unit-work jobs (i.e., \(p_{j}=1\) for all \(j\)) and fix \(=3\).

### Experiment settings

**Benchmarks.****TPE-S** is Algorithm 2 with the default setting \(=0.02\), \(^{}=1\) and \(=0.4\), where \(\) is a parameter that controls the level of prediction error, that we call the error parameter.

**2-competitive** is the \(2\)-competitive online algorithm from  that sets the speed at each time \(t\) to \(n(t)^{}\), where \(n(t)\) is the number of jobs with \(r_{j} t\) unfinished at time \(t\), and uses the Shortest Remaining Processing Time rule.

**Data sets.** We consider two synthetic datasets and a real dataset. For the synthetic data, we first generate a predicted set of jobs \(}\) and we fix the value of the error parameter \(>0\). To create the true set of jobs \(\), we generate, for each job \(j}\), some error \(err(j)\) sampled i.i.d. from \((0,)\). The true set of jobs is then defined as \(=\{(j,_{j}+err(j)):j}\}\), which is the set of all predicted jobs, shifted according to \(\{err(j)\}\). Note that for all \(j\), \(j^{}\) only if \(|_{j}-r_{j}|=|err(j)|<}}{()} (})}{|}|}\). Hence, a larger \(>0\) corresponds to a larger prediction error \(^{g}\). For the first synthetic dataset, called the periodic dataset, the prediction is a set of \(n=300\) jobs, with \(i^{th}\) job's arrival \(r_{i}=i/\). For the second synthetic dataset, we generate the prediction by using a power-law distribution. More precisely, for each time \(t\{1,,T\}\), where we fix \(T=75\), the number of jobs' arrivals at time \(t\) is set to \(M(1-p(a))\), where \(p(a)\) is sampled from a power law distribution of parameter \(a\), and \(M\) is some scaling parameter. In all experiments, we use the values \(a=100\), \(M=500\).

We also evaluate the two algorithms on the College Message dataset from the SNAP database , where the scheduler must process messages that arrive over \(9\) days, each with between 300 and 500 messages. We first fix the error parameter \(>0\), then, for each day, we define the true set \(\) as the arrivals for this day, and we create the predictions \(}\) by adding some error \(err(i)\) to the release time of each job \(i\), where \(err(i)\) is sampled i.i.d. from \((0,)\).

### Experiment results

For each of the synthetic datasets, the competitive ratio achieved by the different algorithms is averaged over \(10\) instances generated i.i.d., and for the real dataset, it is averaged over the arrivals for each of the 9 days.

**Experiment set 1.** We first evaluate the performance of the algorithms as a function of the error parameter \(\). In Figure 1, we observe that TPE-S outperforms 2-competitive when the error parameter is small. In the right-most figure of Figure 1, the competitive ratio of TPE-S plateaus when the value of \(\) increases, which is consistent with our bounded robustness guarantee.

**Experiment set 2.** In the second set of experiments, we study the impact of the parameters \(^{}\) and \(\) of the algorithm for the periodic dataset (results for the other datasets can be found in Appendix E) and fix \(=0.4\). In the left plot of Figure 2, we observe the importance of allowing some shift in the predictions as the performance of our algorithms first rapidly improves as a function of \(^{}\)

Figure 1: The competitive ratio achieved by our algorithm, TPE-S, and the benchmark algorithm, as a function of the error parameter \(\) (from left-most to the second from the right), and the competitive ratio of TPE-S for a larger range of \(\), as a function of \(\) (right-most).

Figure 2: The competitive ratio achieved by our algorithm, TPE-S, as a function of the shift tolerance parameter \(^{}\) (left) and as a function of the confidence parameter \(\) (right).

and then slowly deteriorates. The rapid improvement is because an increasing number of jobs are treated by the algorithm as being correctly predicted when \(^{}\) increases. Next, in the right plot, we observe that the competitive ratio deteriorates as a function of \(\), which implies that the algorithm can completely skip the first phase that ignores the predictions and run the second phase that combines the offline and online schedules when the prediction error is not too large. Note, however, that a larger value of \(\) leads to a better competitive ratio when the predictions are incorrect. Hence, there is a general trade-off here.

## 6 Limitations

The results in Section 3 and Section 4 require the quality cost function \(F\) to be monotone subadditive, which holds for the flow time problem and the problem with deadlines but might not hold for some other energy-efficient scheduling problems. The results in Section 4 require an additional smoothness assumption on \(F\), which holds for the flow time problem but not for the problem with deadlines. Finally, we have only tested our algorithm on the three datasets described in Section 5.