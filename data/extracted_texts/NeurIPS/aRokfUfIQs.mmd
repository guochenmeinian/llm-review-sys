# Sequential Signal Mixing Aggregation for Message Passing Graph Neural Networks

Mitchell Keren Taraday

Department of Computer Science

Technion

Haifa, Israel

butovsky.mitchell@gmail.com &Almog David

Department of Computer Science

Technion

Haifa, Israel

almogdavid@gmail.com &Chaim Baskin

School of Electrical and Computer Engineering

Ben-Gurion University of the Negev

Be'er Sheva, Israel

chaimbaskin@bgu.ac.il

Equal contribution.

###### Abstract

Message Passing Graph Neural Networks (MPGNNs) have emerged as the preferred method for modeling complex interactions across diverse graph entities. While the theory of such models is well understood, their aggregation module has not received sufficient attention. Sum-based aggregators have solid theoretical foundations regarding their separation capabilities. However, practitioners often prefer using more complex aggregations and mixtures of diverse aggregations. In this work, we unveil a possible explanation for this gap. We claim that sum-based aggregators fail to "mix" features belonging to distinct neighbors, preventing them from succeeding at downstream tasks. To this end, we introduce Sequential Signal Mixing Aggregation (SSMA), a novel plug-and-play aggregation for MPGNNs. SSMA treats the neighbor features as 2D discrete signals and sequentially convolves them, inherently enhancing the ability to mix features attributed to distinct neighbors. By performing extensive experiments, we show that when combining SSMA with well-established MPGNN architectures, we achieve substantial performance gains across various benchmarks, achieving new state-of-the-art results in many settings. We published our code at https://almogdavid.github.io/SSMA/

## 1 Introduction

Message-passing Graph Neural Networks (MPGNNs) have established themselves as the major workhorses for graph representation learning over the past decade . These models have been proven to be effective in graph-structured problems in a variety of domains, ranging from social networks  to natural sciences  and having some non-trivial applications in computer vision and natural language processing .

Such renowned models of this nature owe their success to their high efficiency, along with good generalization capabilities and simplicity. A typical MPGNN takes graph-structured data containing node and edge features as input. It then iteratively updates node representations by combining their egocentric view with a symmetrized aggregation of their proximate neighbor features.

The key insight regarding the expressive power of such models is their equivalence to the Weisfeller-Lehman (WL) graph isomorphism test . Consequently, past research directions were majorly directed toward developing models that surpass the vanilla WL test by tackling the graph learnability problem from various perspectives, including stronger notions of the WL test , spectral graph methods  and graph transformers .

However, one subtle but often overlooked detail in such expressivity analyses is the existence of a Hash function, which compresses the neighbor features into a fixed-sized representation. Such Hash function need not only be injective but also differentiable and efficient in terms of memory and computation. The seminal DeepSets paper  showcased such a sum-based construction for the Hash function. While this construction was very simple and computationally efficient, the theoretical representation size required in this construction is exponential in the node feature dimension. Although the bound on this representation size was improved in later works , sum-based aggregations seem to lag behind the aggregators used in practice .

In this work, we suggest that a possible explanation for this gap is the inability of sum-based aggregators to "mix" features belonging to distinct neighbors. We formalize the "neighbor-mixing" property and show that sum-based aggregators have limited neighbor-mixing capability. This observation is later verified by conducting an experiment showing that sum-based aggregators struggle with approximating even a very simple function requiring neighbor-mixing.

With this motivation in mind, we propose a new aggregation module that treats the neighbor features as two-dimensional discrete signals and sequentially convolves them - hence coined as Sequential Signal Mixing Aggregation (SSMA). SSMA has a provably polynomial representation size \(m=(n^{2}d)\) (where \(n\) is the number of neighbors and \(d\) is feature dimensionality). The theoretical construction underlying SSMA provides a positive answer to a lasting mystery regarding DeepSets  - "Can the _DeepSets_ polynomial be **efficiently** generalized to handle vector features?"as depicted in Figure 1.

As later investigated, the convolutional component in SSMA allows it to directly mix features attributed to distinct neighbors, inducing a higher-order notion of neighbor mixing. We then discuss some practical aspects of SSMA. Particularly, we discuss how to implement it in a computationally efficient manner, how to scale it to larger graphs and how to make it easier to optimize.

Finally, we demonstrate that when integrated into a wide range of well established MPGNN architectures, SSMA greatly enhances their performance. We observe significant gains across all benchmarks tested, including the TU datasets , open graph benchmark (OGB)  datasets, long-range graph benchmarks (LRGB)  datasets and the ZINC  molecular property prediction dataset achieving state-of-the-art results in many settings.

Contributions.Our contributions may be summarized as follows:

1. We define the notion of "neighbor-mixing" and show that sum-based aggregators have limited neighbor-mixing power. We verify this idea by conducting an experiment on a simple and natural synthetic task.
2. We propose Sequential Signal Mixing Aggregation (SSMA) - an aggregation module of dimension \(m=(n^{2}d)\) which treats the neighbor features as discrete signals and sequentially convolves them. The theoretical construction underlying SSMA builds upon the _DeepSets_ polynomial, efficiently extending it to multidimensional features.
3. We introduce a few practices for stabilizing the optimization process of SSMA and show how to scale it to larger graphs.
4. Finally, we conduct extensive experiments showing that enriching prominent MPGNN architectures with SSMA yields large improvements on a variety of benchmarks, achieving state-of-the-art results.

Figure 1: An efficient and provable generalization of the _DeepSets_ polynomial to vector features.

## 2 Preliminaries and related work

Let \(\) be some domain. We are interested in representing **multisets** (sets in which repeated elements are allowed) over that domain. We denote multisets by \(\{\{x_{1},...,x_{n}\}\}\) where each \(x_{i}\), and denote by \(_{n}:=()^{n}\) the \(n\)-tuple space over \(\). We seek a (possibly learnable) permutation invariant mapping \(f:_{n}^{m}\) separating distinct multisets 2. When combined with a learnable compression network \(g_{}:^{m}\), their composition \(=g_{} f\) can be utilized as an aggregation module for MPGNNs over the domain \(\).

Particularly, we are interested in continuous features, namely the domains \(=\) and \(=^{d}\). We consider the symmetry group \(=S_{n}\) acting on \(_{n}=^{n}\) by \([.]_{i}=_{^{-1}(i)}\) and on \(_{n}=^{n d}\) by \([.}]_{ij}=}_{^{-1}(i)j}\) correspondingly. It is widely agreed that finding a good representation \(f:_{n}^{m}\) for these domains is crucial for building better aggregation modules \(\) and has a direct influence on the performance of the model on a variety of downstream tasks [47; 12; 27; 40].

DeepSets  was the pioneering work introducing a sum-based aggregator with a provably finite representation size \(m\): \((\{x_{1},...,x_{n}\})=(_{k=1}^{n}(x_{k}))\) where \(:^{d}^{m}\) and \(:^{m}^{d}\). Their construction consisted of "hand-crafted" moment-based features. Despite being efficient for scalar-based features, the representation size grew exponentially with the node feature dimensionality, \(m()\). This upper bound was later improved to \((n^{2}d)\) and eventually to a tight \((nd)\). While moment-based features served as a powerful tool for achieving theoretical separation, learnable neural features are favored over such hand-crafted features in practice. As was unveiled, neural features can achieve theoretical separation as well, as long as non-polynomial analytic activations are used .

Despite their clear theoretical advantages, sum-based aggregators seem to have limited performance in practice [12; 27]. Consequently, many works focused on different species of permutation invariant aggregators. For instance, attention-based aggregators have been proposed to capture the most important signals incoming from the neighborhood [2; 7]. Others suggested using a mixture of symmetric aggregators such as min, max, mean, sum, std as each of these aggregators helps separate different kinds of multisets [47; 41; 12]. Other works focused on aggregations preserving intrinsic properties of the neighborhood data such as variance and fisher-information [38; 30].

Another intriguing type of work deals with the relaxation of the neighbor ordering invariance constraint. Particularly, regularizing recurrent neural network-based aggregations to maintain permutation invariance - either by choosing a random neighbor permutation  or by explicit regularization terms [10; 34] has raised some interest.

## 3 On the limited neighbor-mixing of sum-based aggregators

Despite their provable separation power, sum-based aggregators seem to lag behind other aggregators used in practice . We claim that a possible explanation for this phenomenon lies in their inability to "mix" the neighbor's features, in that the mutual effect of perturbing the features of two distinct neighbors on each aggregation output is very small. In practice, many downstream tasks require high "mixing" values as the aggregator should mix information from different distinct neighbors to produce a useful representation for tackiling the downstream task.

**Definition 3.1**.: Let \(:^{n d}^{d}\) be some aggregation function that is continuously twice differentiable. We define the _neighbor mixing_ of the \(\)-th aggregation output with respect to the neighbor pair \((i,j)\):

\[^{()}_{i,j}:=\|}{ x_{i} x _{j}}^{()}(x_{1},...,x_{n})\|_{2}\] (1)

At an intuitive level, sum-based aggregators have small \(^{()}_{i,j}\) values as the result of the local pooling operation is summed across the neighbors. Namely, without explicitly "mixing" features from distinct neighbors before the summation. Indeed, given \((\{\{x_{1},...,x_{n}\}\})=_{k=1}^{n}(x_{k})\) we have:\[}{ x_{i} x_{j}}_{k=1}^{n}^{()}(x_{ k})=0\] (2)

Formally, to account for mixing that may occur in any subsequent (global) transformation we have the following proposition:

**Proposition 3.2**.: _Let \((\{\{x_{1},...,x_{n}\}\})=(_{k=1}^{n}(x_{k}))\) where \(:^{d}^{m}\) is a local operator and \(:^{m}^{d}\) is a pooling operator that is continuously twice differentiable. Then, we have \( i j\):_

\[_{i,j}^{()}\|J_{}(x_{i})\|_{2}\|H _{^{()}}(_{k=1}^{n}(x_{k}))\|_{2}\|J_{}(x _{j})\|_{2}\] (3)

_Where \(J_{}(.)\) is the Jacobian matrix of \(\) and \(H_{^{()}}(.)\) is the Hessian matrix corresponding to \(\)-th output of \(\). Particularly, for typical choices of \(\) and \(\) it follows: \(_{i,j}^{()}(\|\|_{2}^{2})\) where \(\) is the concatenation of the parameters in \(\) and \(\)._

The proof of Proposition 3.2 is given in Appendix A.1.

Motivated by the above observation, we propose a new species of aggregation module which is convolution-based rather than sum-based.

## 4 \(\)- Sequential Signal Mixing Aggregation

### Warm-up: _DeepSets_ polynomial from a _convolutional_ point of view

Let \(}=\{\{_{1},...,_{n}\}\}\) be a scalar multiset. We define its _DeepSets_ polynomial by considering a polynomial of variable \(t\) having the multiset elements as its roots:

\[p_{}}(t):=_{i=1}^{n}(t-_{i})\] (4)

Its coefficients, we denote by \(e_{k}()\), are permutation invariant functions. Moreover, the \((e_{k}())_{k=0}^{m}\)s form an ensemble of invariant separators 3.

Instead of describing a polynomial by its coefficients, one can represent a polynomial by evaluating it on some fixed set of points. Given a set of \(n+1\) fixed points, the polynomial may be represented by evaluating its value on these points. One can switch from this representation back to the coefficients by solving a system of linear equations, which always has a unique solution. Now, by allowing the evaluation points to be complex, we can choose them as the roots of unity. By doing so, we get the discrete Fourier transform (DFT) of the polynomial coefficients:

\[_{j}()=_{k=0}^{n}e_{k}() e^{-k}(j=0,...,n)\] (5)

Next, we denote the factors in \(p_{}}(t)=_{i=1}^{n}p_{i}(t)\) where \(p_{i}(t):=t-_{i}\). The (padded) coefficients of each \(p_{i}(t)\) are then given by the affine transformation:

\[(_{i})=[-_{i},1,0,...,0]^{n+1}\] (6)

The nice thing about representing a polynomial by evaluating its values at a list of fixed points is that polynomial multiplication becomes _point-wise_. It can be deduced that the coefficients of \(p_{}}(t)\) can be computed by transforming the coefficients \((_{i})\) of each \(p_{i}(t)\) to the Fourier domain, performingelementwise multiplication and then transforming back to the coefficients domain. According to the circular convolution theorem, this exactly amounts to sequentially convolving the coefficients \((_{i})\). We combine the above ideas into the following theorem:

**Theorem 4.1**.: _Scalar multisets \(}=\{\!\{_{1},...,_{n}\}\}\) can be represented by an invariant and separating map \(f_{conv}\):_

\[f_{conv}()=_{i=1}^{n}(_{i})\] (7)

_Where \(:^{m}\) is an affine map, \(_{i=1}^{n}\) is the circular convolution operator, and the number of separators is \(m=n+1(n)\)._

Theorem 4.1 simply states that sequential convolution can be utilized to compute the renowned _DeepSets_ polynomial coefficients. While not particularly surprising, Theorem 4.1 shows that the coefficients of the _DeepSets_ polynomial can be efficiently computed and directly utilized as a multiset representation. Moreover, it paves the way for our construction, as seen in the next section.

### Efficient generalization to multidimensional features

"How does the _DeepSets_ polynomial can be **efficiently** extended to handle vector features?"

The key idea underlying our answer to this question is to encode each feature vector as another polynomial, and then to reduce the problem to the scalar case.

Generalized DeepSets Polynomial

We encode each element \(}_{i}\) belonging to the multiset \(}}=\{\!\{}_{1},...,}_{n}\}\}\) as a polynomial of _another_ variable \(z\):

\[(}_{i})=_{j=1}^{d}}_{ij} z^{j-1}\] (8)

Then, we can perform a reduction to the scalar case by replacing each \(}_{i}\) with \((}_{i})\):

\[p_{i}(t,z):=t-(}_{i})=t-_{j=1}^{d}}_{ij} z^{j-1}\] (9)

And define the generalized _DeepSets_ polynomial:

\[p_{}}}(t,z):=_{i=1}^{n}p_{i}(t,z)=_{k,l}e_{k }(}) t^{k}z^{}\] (10)

Where \(e_{k}(})\) is the coefficient of \(t^{k}z^{}\) in \(p_{}}}(t,z)\). Note \(0 k n\) while \(0 n(d-1)\).

Opposed to the scalar case, it is not evident why the obtained coefficients \((e_{k}(}))_{k,}\) in the above construction form an ensemble of separators. We prove injectivity by utilizing ideas from ring theory, particularly the notions of unique factorization domains (UFDs) and Gauss's lemma in Appendix A.2.

We can now repeat the steps in Section 4.1 to achieve the actual representation. We compute the coefficient _matrix_ of each \(p_{i}(t,z)\) and sequentially perform two-dimensional circular convolution.

This leads us to an analogous theorem for the \(d\)-dimensional case:

**Theorem 4.2**.: _Vector multisets \(}}=\{\!\{}_{1},...,}_{n}\}\}\) can be represented by an invariant and separating map \(f_{conv}\):_

\[f_{conv}(})=_{i=1}^{n}(}_{i})\] (11)

_Where \(:^{d}^{m_{1} m_{2}}\) is an affine map, \(\) is the 2D circular convolution operator and the number of separators is \(m=m_{1} m_{2}=(n+1)(n(d-1)+1)(n^{2}d)\)._

The full proof of Theorem 4.2 is given in Appendix A.3.

### How does circular convolution impact neighbor Mixing?

Let \(_{1},...,_{n}^{m}\) be discrete signals representing the locally-transformed neighbors before being aggregated. For the sake of simplicity, we slightly override the notation in this section, and refer to the \(j\)-th element of the \(i\)-th signal as \(_{i}^{j}\) with \(j\) starting from \(0\).

The core factor causing the neighbor mixing bottleneck of sum-based aggregators \(=_{i=1}^{n}_{i}\) lies within the fact that no mixing is done in the representation, but only in the MLP compressor that comes afterward:

\[}{_{i}^{k}_{j}^{}}=0\] (12)

On the contrary, each element of sequential circular convolution is composed of sums of terms of the form \(_{1}^{j_{1}}_{2}^{j_{2}}..._{n}^{j_{n}}\). Particularly:

\[^{k}=_{j_{1}+...+j_{n} k\\ (m)}_{1}^{j_{1}}_{2}^{j_{2}}... _{n}^{j_{n}}\] (13)

This implies that the convolutional representation achieves, in fact, a generalized, higher-order notion of the mix values:

\[ 0 j_{1},...,j_{n} m-1\; k:}{ _{1}^{j_{1}}_{2}^{j_{2}}..._{n}^{j_ {n}}}^{k}=1\] (14)

This notion of higher-order neighbor mixing is visualized in Figure 2. We refer the reader to Appendix A.4 for further theoretical discussions on the stability of permutation-invariant representations.

### Practical considerations

Combining Theorem 4.2 with an MLP compressor yields the "vanilla" version of SSMA: it first applies the local affine map, then computes 2D circular convolution across the neighbor axis and finally compresses the result back using MLP as a universal compressor. The circular convolution is implemented by applying FFT, performing product aggregation along the neighbor axis and then transforming the result back using IFFT. As "scatter_mul" is not implemented for complex numbers in standard libraries, we convert complex values to their polar representation in which multiplication is equivalent to multiplying the magnitudes and summing up the arguments. The "vanilla" version of SSMA is presented in Figure 3.

We now suggest a few practical adjustments to the "vanilla" version of SSMA:

Normalizing the circular convolution.As SSMA performs a product over the neighbors' axis, the optimization process of the vanilla SSMA might get unstable. To address this instability, we normalize the element-wise magnitudes of the product by taking their geometric means.

Figure 2: Visualization of the higher order notion of neighbor mixing. We visualize the convolution result \(h\) for \(3\)-dimensional features, considering \(2\) neighbors \(u,v\) (left) and \(3\) neighbors \(u,v,w\) (right). We demonstrate for each \(n\)-tuple matching a feature per node, the corresponding \(n\)-th order derivative of exactly one entry of \(h\) is \(1\).

Low-rank compressor.Since the number of parameters in the MLP compressor rapidly increases with the representation dimension \(m\), we opted for a single linear layer as our compressor. To accommodate a higher number of neighbor slots and allow for a larger hidden dimension, we reduced the number of parameters in the linear layer by splitting it into two consecutive linear layers that squeezes the representation to low dimension and than expands it back. This effectively performs a low-rank factorization of the weight matrix of the original single linear layer.

Neighbor selection methods.The representation size of the vanilla SSMA\(m=(n^{2}d)\) may become prohibitively high in dense neighborhoods (e.g in transductive settings). To address this issue, we employ two neighbor selection techniques that reduce the original neighborhood to a new set of \(\) neighbors. The first technique simply draws at most \(\) random neighbors without replacement. The second technique draws inspiration from Graph Attention Networks (GAT) and attention slots [29; 42] and map the neighbors into \(\) attention slots. The attention coefficient for the edge \(e:j i\) for the \(k\)-th slot is expressed as follows:

\[e_{k}(_{i},_{j})=(_{k}^{T} _{i}+_{k}^{T}_{j})\] (15) \[_{ij}^{(k)}=_{j}e_{k}(_{i},_{ j})=(_{i},_{j}))}{_{j^{}_{i }(i)}(e_{k}(_{i},_{j^{}}))}\] (16)

Where \(_{k},_{k}^{d}\) are per-slot learnable weight vectors. Thereafter, the \(k\)-th slot for the \(i\)-th node is produced by considering the weighted average of the incoming neighbors:

\[s_{i}^{(k)}=_{j_{in}(i)}_{ij}^{(k)}_{j}\] (17)

## 5 Experiments

### Synthetic task

To empirically demonstrate the success of SSMA in managing tasks characterized by high neighbor mixing (opposed to sum-based aggregators), we introduce a synthetic regression task we name SumOfGram. In this task, we sample random neighbor features and then generate the labels by considering the sum of the Gramian matrix corresponding to the neighbor features.

In some sense, the SumOfram task is the "simplest" task that involves neighbor mixing:

\[ i j:_{i,j}=\|}{ x_{i}  x_{j}}(x_{1},...,x_{n})\|_{2}=\| _{d d}\|_{2}=1\] (18)

Figure 3: Visualization of the Sequential Signal Mixing Aggregation. Left: demonstration of the aggregation stage in an off-the-shelf MPGNN layer. The goal is to create a compressed view of \(t\)â€™s incoming neighbors. Right: our proposed aggregation. We convert the neighbor features into two-dimensional discrete signals. We then apply \(2\)D circular convolution by applying \(2\)D FFT, performing pointwise multiplication and transforming back using IFFT. Finally, we compress the result back into a \(d\)-dimensional vector using a multi-layer perceptron as a universal compressor.

We train both the sum aggregator and our proposed Sequential Signal Mixing Aggregation until convergence with varying representation sizes \(m\) on the SumOfGram task.

As may be observed in Figure 4, sum aggregators fail at this task, even when used in conjunction with analytic activations, which as claimed previously , is sufficient to achieve separation. This shows that sole separation is insufficient for performing arbitrary downstream tasks. On the contrary, \(}\) has low regression errors, consistently along different activation functions.

### Benchmarking \(}\)

**Experimental Setup.** We test the effectiveness of \(}\) by incorporating it into popular MPGNN architectures. We evaluate both original and augmented architectures across a wide range of benchmarks. These benchmarks cover learning in both the transductive and inductive settings, node and graph-level prediction tasks, regression and classification problems, feature-oriented as well as purely topological data and tasks that involve challenging neighborhood configurations including dense neighborhoods and distant neighbor dependencies. As \(}\) introduces learnable parameters, we ensure a fair comparison by maintaining an equal total parameter count to that of the original architectures in each experimental setting, adjusting the architecture's hidden dimension to adhere to the budget constraints. For a detailed discussion on the parameter budget in each experiment, please refer to Appendix C.4. Given the budget for each experiment, we conduct a hyperparameter search (HPS) on \(}\) parameters to find the best configuration. We further perform ablation studies to closely examine the effect of each hyperparameter, as detailed in Appendix E.

Results.We observe substantial performance gains across all tested combinations of benchmarks and MPGNN architectures. Notably, the most significant relative improvements were observed on the IMDB-B benchmark, which lacks node and edge features. This phenomenon is likely attributed to \(}\)'s neighbor mixing capabilities, enabling it to learn joint topological relationships among neighbors. The Improvements observed on the LRGB  datasets indicate that \(}\) better extracts relevant neighborhood information to be propagated to distant parts of the graph. Additionally, the experiments on the OGBN networks (OGBN-Arxiv and OGBN-Products)  confirm that \(}\) is robust to dense neighborhoods and highlight the efficiency of its attentional neighbor selection mechanism. Another noteworthy observation is that \(}\) utilizes the hidden dimension more effectively. Since we use the same parameter budget, experiments with \(}\) employ a lower hidden dimensionality than those using'sum' aggregation. This is because \(}\) allocates learnable parameters, whereas'sum' aggregation does not. Despite a smaller hidden dimension, \(}\) outperforms'sum' aggregation, indicating its efficiency in retaining relevant information for downstream tasks. Benchmarks for more common aggregation functions is in Appendix F

Figure 4: SumOfGram train and test regression \(L_{1}\) errors for different activation functions. The sum aggregator (not dashed) performs poorly and fails to scale with the capacity of the aggregation module, even when used in conjunction with analytic activations. On the contrary, \(}\) (dashed) consistently achieves low regression errors and scales well with the number of learnable parameters.

[MISSING_PAGE_FAIL:9]