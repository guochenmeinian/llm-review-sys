# A Compositional Atlas for Algebraic Circuits

Benjie Wang

University of California, Los Angeles

benjiewang@ucla.edu

&Denis Deratani Maua

University of Sao Paulo

ddm@ime.usp.br

Guy Van den Broeck

University of California, Los Angeles

guyvdb@cs.ucla.edu

&YooJung Choi

Arizona State University

yj.choi@asu.edu

###### Abstract

Circuits based on sum-product structure have become a ubiquitous representation to compactly encode knowledge, from Boolean functions to probability distributions. By imposing constraints on the structure of such circuits, certain inference queries become tractable, such as model counting and most probable configuration. Recent works have explored analyzing probabilistic and causal inference queries as compositions of basic operators to derive tractability conditions. In this paper, we take an _algebraic_ perspective for _compositional inference_, and show that a large class of queries--including marginal MAP, probabilistic answer set programming inference, and causal backdoor adjustment--correspond to a combination of basic operators over semirings: aggregation, product, and elementwise mapping. Using this framework, we uncover simple and general sufficient conditions for tractable composition of these operators, in terms of circuit properties (e.g., marginal determinism, compatibility) and conditions on the elementwise mappings. Applying our analysis, we derive novel tractability conditions for many such compositional queries. Our results unify tractability conditions for existing problems on circuits, while providing a blueprint for analysing novel compositional inference queries.

## 1 Introduction

Circuit-based representations, such as Boolean circuits, decision diagrams, and arithmetic circuits, are of central importance in many areas of AI and machine learning. For example, a primary means of performing inference in many models, from Bayesian networks [16; 9] to probabilistic programs [20; 24; 26; 43], is to convert them into equivalent circuits; this is commonly known as _knowledge compilation_. Inference via knowledge compilation has also been used for many applications in neuro-symbolic AI, such as constrained generation [2; 54] and neural logic programming [34; 28]. Circuits can also be _learned_ as probabilistic generative models directly from data [25; 41; 40; 32], in which context they are known as probabilistic circuits . Compared with neural generative models, probabilistic circuits enjoy tractable evaluation of inference queries such as marginal probabilities, which has been used for tasks such as fair machine learning  and causal reasoning [53; 50; 49].

The key feature of circuits is that they enable one to precisely characterize _tractability conditions_ (structural properties of the circuit) under which a given _inference query_ can be computed exactly and efficiently. One can then enforce these circuit properties when compiling or learning a model to enable tractable inference. For many basic inference queries, such as computing a marginal probability, tractability conditions are well understood [48; 8]. However, for more complex queries, the situation is less clear, and the exercise of deriving algorithms and tractability conditions for a given query has usually been carried out in an instance-specific manner requiring significant effort.

In Figure 1, we illustrate two such queries. The marginal MAP (MMAP)  query takes a probabilistic circuit \(p\) and some evidence \(\) and asks for the most likely assignment of a subset of variables. The success probability inference in probabilistic logic programming [6; 45] takes a circuit representation \(\) of a logic program, a weight function \(\) and some query \(\), and computes the probability of the query under the program's semantics (MaxEnt, in the example). At first glance, these seem like very different queries, involving different types of input circuits (logical and probabilistic), and different types of computations. However, they share similar _algebraic structure_: logical and probabilistic circuits can be interpreted as circuits defined over different _semirings_, while maximization and summation can be viewed as _aggregation_ over different semirings. In this paper, inspired by the compositional atlas for probabilistic circuits , we take a _compositional_ approach to algebraic inference problems, breaking them down into a series of basic operators: aggregation, product, and elementwise mapping. For example, the MMAP and probabilistic logic programming queries involve multiple interleaved aggregations and products, along with one elementwise mapping each. Given a circuit algorithm (and associated tractability condition) for each basic operator, we can reuse these algorithms to construct algorithms for arbitrary compositions. The key challenge is then to check if each intermediate circuit satisfies the requisite tractability conditions.

Our contributions can be summarized as follows. We introduce a compositional inference framework for _algebraic_ circuits (Section 3) over arbitrary semirings, generalizing existing results on logical  and probabilistic  circuits. In particular, we provide a language for specifying inference queries involving _different_ semirings as a composition of basic operators (Section 3.1). We then prove sufficient conditions for the tractability of each basic operator (Section 3.2) and novel conditions for composing such operators (Section 3.3). We apply our compositional framework to a number of inference problems (Section 4), showing how our compositional approach leads to more systematic derivation of tractability conditions and algorithms, and in some cases improved complexity analysis. In particular, we discover a tractability hierarchy for inference queries captured under the 2AMC framework , and reduce the complexity of causal backdoor/frontdoor adjustment on probabilistic circuits [38; 49] from quadratic/cubic to linear/quadratic respectively.

## 2 Preliminaries

NotationWe use capital letters (e.g., \(X,Y\)) to denote variables and lowercase for assignments (values) of those variables (e.g., \(x,y\)). We use boldface to denote sets of variables/assignments (e.g., \(,\)) and write \(()\) for the set of all assignments to \(\). Given a variable assignment \(\) of \(\), and a subset of variables \(\), we write \(}\) to denote the assignment of \(\) corresponding to \(\).

SemiringsIn this paper, we consider inference problems over commutative _semirings_. Semirings are sets closed w.r.t. operators of addition (\(\)) and multiplication (\(\)) that satisfy certain properties:

**Definition 1** (Commutative Semiring).: _A commutative semiring \(\) is a tuple \((S,,,0_{},1_{})\), where \(\) and \(\) are associative and commutative binary operators on a set \(S\) (called the domain) such that \(\) distributes over \(\) (i.e., \(a(b c)=(a b)(a c)\) for all \(a,b,c S\)); \(0_{} S\) is the additive identity (i.e., \(0_{} a=a\) for all \(a S\)) and annihilates \(S\) through multiplication (i.e., \(0_{} a=0\) for all \(a S\)); and \(1_{} S\) is the multiplicative identity (i.e., \(1_{} a=a\) for all \(a S\))._

For example, the probability semiring \(=(_{ 0},+,,0,1)\) employs standard addition and multiplication (\(=+\) and \(=\)) over the non-negative reals, the \((,)\) semiring \(=(_{ 0},,,0,1)\)

Figure 1: Example applications of our compositional inference framework for _(Left)_ MMAP and _(Right)_ Success Probability in Prob. Logic Programing under the Stable Model semantics (MaxEnt).

replaces addition with maximization, while the Boolean semiring \(=(\{,\},,,,)\) employs disjunction and conjunction operators (\(=\) and \(=\)) over truth values.

Algebraic CircuitsWe now define the concept of an algebraic circuit, which are computational graph-based representations of functions taking values in an arbitrary semiring.

**Definition 2** (Algebraic Circuit).: _Given a semiring \(=(S,,,0_{},1_{})\), an algebraic circuit \(C\) over variables \(\) is a rooted directed acyclic graph (DAG), whose nodes \(\) have the following syntax:_

\[::=l+_{i=1}^{k}_{i}_{i=1}^{k}_{i}\,,\]

_where \(_{i} C\) are circuit nodes, \(k^{>0}\) and \(l:() S\) is a function over a (possibly empty) subset \(\) of variables, called its scope. That is, each circuit node may be an input (\(l\)), sum (\(+\)), or a product (\(\)). The scope of any internal node is defined to be \(():=_{i=1}^{k}(_{i})\). Each node \(\) represents a function \(p_{}\) taking values in \(S\), defined recursively by: \(p_{}():=l()\) if \(=l\), \(p_{}()::=_{i=1}^{k}p_{_{i}}()\) if \(=+_{i=1}^{k}_{i}\), and \(p_{}()::=_{i=1}^{k}p_{_{i}}()\) if \(_{i=1}^{k}_{i}\), where \(\) is the scope of \(\). The function \(p_{C}\) represented by the circuit is defined to be the function of the root node. The size \(|C|\) of a circuit is defined to be the number of edges in the DAG._

For simplicity, we will restrict to circuits with binary products (i.e. \(k=2\) for products); this can be enforced with at most a linear increase in size. Prominent examples of algebraic circuits include negation normal forms (NNF) and binary decision diagrams --which are over the Boolean semiring and represent Boolean functions--and probabilistic circuits --which are over the probabilistic semiring and represent probability distributions.1 By imposing simple restrictions on the circuit, which we call _circuit properties_, various inference queries that are computationally hard in general become tractable. In particular, smoothness and decomposability ensure tractable marginal inference:

**Definition 3** (Smoothness, Decomposability).: _A circuit is smooth if for every sum node \(=+_{i}_{i}\), its children have the same scope: \( i,j,\ (_{i})=(_{j})\). A circuit is decomposable if for every product node \(=_{1}_{2}\), its children have disjoint scopes: \((_{1})(_{2})=\)._

Aside from the scopes of circuit nodes, we can also specify properties relating to their _supports_:

**Definition 4** (\(\)-Support).: _Given a partition \((,)\) of variables \(\) and a node \(\) in circuit \(C\), the \(\)-support of \(\) is the projection of its support on \(\):_

\[_{}()=\{( ()):(()) p_{}(,) 0_{}\}.\]

**Definition 5** (\(\)-Determinism).: _Given a circuit \(C\) and a partition \((,)\) of \(\), we say that \(C\) is \(\)-deterministic if for all sum nodes \(=+_{i=1}^{k}_{i}\), either: (i) \(()=\); or (ii) \(_{}(_{i})_{}(_{j})=\) for all \(i j\)._

\(\)-determinism refers to a family of properties indexed by sets \(\). In particular \(\)-determinism is usually referred to simply as determinism. Note that, as defined, scope and support, and thus these circuit properties, apply to any semiring: the scope only depends on the variable decomposition of the circuit, while the support only refers to scope and the semiring additive identity \(0_{}\). Figure 1(a) shows a simple example of a smooth, decomposable, and deterministic circuit that is not \(X\)-deterministic, while Figure 1(b) shows a smooth, decomposable, and \(\{X_{1},X_{2}\}\)-deterministic circuit.

Figure 2: Examples of Algebraic Circuits. We use \(},}\) to represent input, sum and product nodes respectively.

## 3 Compositional Inference: A Unifying Approach

Many inference problems can be written as _compositions of basic operators_, which take as input one or more functions and output another function. For example, the marginal MAP query on probability distributions \(_{}_{}p(,)\) is a composition of the \(\) and \(\) operators. Similarly, for Boolean functions \(,\), the query \(_{}.\,(,)(,)\) composes the \(\), \(\) and \(\) operators. Although these queries appear to involve four different operators, three of them \((,,)\) can be viewed as an _aggregation_ operation over _different_ semirings. Thus, we begin this section by consolidating to a simple set of three operators applicable to functions taking values in some semiring: namely, aggregation, product, and elementwise mapping (Section 3.1).

Equipped with this language for specifying compositional inference queries, we then move on to analyzing their tractability when the input functions are given as circuits. The thesis of this paper is that algebraic structure is often the right level of abstraction to derive useful sufficient (and sometimes necessary) conditions for tractability. We firstly show _tractability conditions_ of each of the basic operators (Section 3.2), before deriving _composability conditions_ showing how circuit properties are maintained through operators (Section 3.3). This enables us to systematically derive conditions for the input circuits that enable efficient computation of a compositional inference query. Algorithms and detailed proofs of all theorems can be found in Appendix A.

### Basic Operators

AggregationGiven a function \(f:() S\), _aggregating_\(f\) over \(\) returns the function \(f^{}:() S\) for \(=\) defined by \(f^{}():=_{}f(,)\).

For example, aggregation corresponds to forgetting variables \(\) in the Boolean semiring, marginalizing out \(\) in the probability semiring, and maximizing over assignments in the \((,)\) semiring. Next, some queries, such as divergence measures between probability distributions, take two functions as input, and many others involve combining two or more intermediate results, as is the case in probabilistic answer set programming inference and causal backdoor/frontdoor queries. We define the product operator to encapsulate such "combination" of functions in general.

ProductGiven two functions \(f:() S\) and \(f^{}:(^{}) S\), the _product of \(f\) and \(f^{}\)_ is a function \(f^{}:() S\), where \(=^{}\), defined by \(f^{}():=f(}) f^{}(}})\).

For example, a product corresponds to the conjoin operator \(\) in the Boolean semiring, and standard multiplication \(\) in the probability semiring. Lastly, we introduce the _elementwise mapping_ operator, defined by a mapping \(\) from a semiring to a (possibly different) semiring. When applied to a function \(f\), it returns the function composition \( f\). This is the key piece that distinguishes our framework from prior analysis of sum-of-product queries over specific semirings, allowing us to express queries such as causal inference and probabilistic logic programming inference under the same framework.

Elementwise MappingGiven a function \(f:() S\) and a mapping \(:S S^{}\) from semiring \(\) to \(^{}\) satisfying \((0_{})=0_{^{}}\), an _elementwise mapping of \(f\) by \(\)_ results in a function \(f^{}:() S^{}\) defined by \(f^{}():=(f())\).2

In practice, we use elementwise mappings as an abstraction predominantly for two purposes. The first is for switching between semirings, while the second is to map between elements of the same semiring. For the former, one of the most important elementwise mappings we will consider is the _support mapping_, which maps between any two semirings as follows.

**Definition 6** (Support Mapping).: _Given a source semiring \(\) and a target semiring \(^{}\), the support mapping \([\![]\!]_{^{}}\) is defined as: \([\![a]\!]_{^{}}=0_{^{}}\) if \(a=0_{}\); \([\![a]\!]_{^{}}=1_{^{}}\) otherwise._

In particular we will often use the source semiring \(=\), in which case the support mapping maps \(\) to the \(0_{^{}}\) and \(\) to the \(1_{^{}}\) in the target semiring. This is useful for encoding a logical function for inference in another semiring, e.g. probabilistic inference in the probabilistic semiring.

**Example 1** (Marginal MAP).: _Suppose that we are given a Boolean formula \((,)\) and a weight function \(w:()_{ 0}\). The marginal MAP query for variables \(\) is defined by_

\[(,)=_{}_{}(,) (,)\,,\]

_where we interpret \(\) as \(1\) and \(\) as 0. We can break this down into a compositional query as follows:_

\[_{}_{id,}[_{} (,)_{} (,)]\,.\]

_The support mapping ensures \(\) and \(\) are both functions over the probabilistic semiring, so that we can apply the product operation. Notice also the inclusion of an identity mapping \(_{id,}\) from the probability to the \((,)\) semiring defined by \(_{id,}(x)=x\) for all \(x_{ 0}\). While differentiating between semirings over the same domain may seem superfluous, the explicit identity operator will become important when we analyze the tractability of these compositions on circuits._

### Tractability Conditions for Basic Operators

We now consider the tractability of applying each basic operator to circuits: that is, computing a circuit whose function corresponds to the result of applying the operator to the functions given by the input circuit(s). First, it is well known that forgetting and marginalization of any subset of variables can be performed in polynomial time if the input circuits in the respective semirings (NNF and PC) are smooth and decomposable [18; 11]. This can be generalized to arbitrary semirings:

**Theorem 1** (Tractable Aggregation).: _Let \(C\) be a smooth and decomposable circuit representing a function \(p:() S\). Then for any \(\), it is possible to compute the aggregate as a smooth and decomposable circuit \(C^{}\) (i.e., \(p_{C^{}}()=_{}p_{C}(,)\)) in \(O(|C|)\) time and space._

Next, let us consider the product operator. In the Boolean circuits literature, it is well known that the conjoin operator can be applied tractably if the circuits both follow a common structure known as a _vtree_. In  a more general property known as _compatibility_ was introduced that directly specifies conditions with respect to two (probabilistic) circuits, without reference to a vtree. We now define a generalization of this property (\(\)-compatibility) and also identify a new condition (\(\)-support-compatibility) that enables tractable products.

**Definition 7** (\(\)-Compatibility).: _Given two smooth and decomposable circuits \(C,C^{}\) over variables \(,^{}\) respectively, and a variable set \(}\), we say that \(C,C^{}\) are \(\)-compatible if for every product node \(=_{1}_{2} C\) and \(^{}=^{}_{1}^{}_{2} C^{}\) such that \(()=(^{}) \), the scope is partitioned in the same way, i.e. \((_{1})=(^{ }_{1})\) and \((_{2})=(^{ }_{2})\). We say that \(C,C^{}\) are compatible if they are \((^{})\)-compatible._

Intuitively, compatibility states that the scopes of the circuits decompose in the same way at product nodes. Compatibility of two circuits suffices to be able to tractably compute their product:

**Theorem 2** (Tractable Product - Compatibility).: _Let \(C,C^{}\) be compatible circuits over variables \(,^{}\), respectively, and the same semiring. Then it is possible to compute their product as a circuit \(C\) compatible with them (i.e., \(p_{C^{}}(^{})=p_{C}() p_{C^{ }}(^{})\)) in \(O(|C||C^{}|)\) time and space._

We remark that if we are given a fully factorized function \(f()=_{V_{i}}f_{i}(V_{i})\), this can be arranged as a circuit (series of binary products) compatible with any other decomposable circuit; thus, we say this type of function is _omni-compatible_. We also say that a circuit is _structured decomposable_ if it is compatible with itself. Now, our more general definition of \(\)-compatibility states that the scopes of the circuits _restricted to \(\)_ decompose in the same way at product nodes. This will be important when we consider composing products with other operators, such as aggregation. The following result shows that compatibility w.r.t. a subset is a weaker condition:

**Proposition 1** (Properties of \(\)-Compatibility).: _If two circuits \(C,C^{}\) are \(\)-compatible, then they are \(^{}\)-compatible for any subset \(^{}\)._

Compatibility is a sufficient but not necessary condition for tractable products. Some non-compatible circuits can be efficiently _restructured_ to be compatible, such that we can then apply Theorem 2; we refer readers to  for details. Alternatively, it is also known that deterministic circuits can be multiplied with themselves in linear time, even when they are not structured decomposable [48; 27]. We formalize this idea with a new property that we call _support-compatibility_.

**Definition 8** (\(X\)-Support Compatibility).: _Given two smooth and decomposable circuits \(C,C^{}\) over variables \(,^{}\) respectively, and a set of variables \(^{}\), let \(C[],C^{}[]\) be the DAGs obtained by restricting to nodes with scope overlapping with \(\). We say that \(C,C^{}\) are \(\)-support-compatible if there is an isomorphism \(\) between \(C[],C^{}[]\) such that: (i) for any node \( C[]\), \(}()=}(())\); (ii) for any sum node \( C[]\), \(}_{}(_{i})}_{}(( _{j}))=\) whenever \(i j\). We say that \(C,C^{}\) are support-compatible if they are \((^{})\)-support-compatible._

To unpack this definition, we note that any smooth, decomposable, and \(\)-deterministic circuit is \(\)-support-compatible with itself, with the obvious isomorphism. However, this property is more general in that it allows for circuits over different sets of variables and does not require that the nodes represent exactly the same function; merely that the sum nodes have "compatible" support decompositions. As we will later see, the significance of this property is that it can be often maintained through applications of operators, making it useful for compositions.

**Theorem 3** (Tractable Product - Support Compatibility).: _Let \(C,C^{}\) be support-compatible circuits over variables \(,^{}\), respectively, and the same semiring. Then, given the isomorphism \(\), it is possible to compute their product as a smooth and decomposable circuit \(C^{}\) support-compatible with them (i.e., \(p_{C^{}}(^{})=p_{C}() p_{C^{ }}(^{})\)) in \(O((|C|,|C^{}|))\) time and space._

We now examine the tractability of general elementwise mappings \(:^{}\) on a circuit \(C\). It is tempting here to simply construct a new circuit \(C^{}\) over the semiring \(^{}\) with the same structure as \(C\), and replace each input function \(l\) in the circuit with \((l)\). However, the resulting circuit \(p_{C^{}}()\) is not guaranteed to correctly compute \((p_{C}())\) in general. For example, consider the support mapping \(_{}\)--which maps \(\) to \(0_{}\) and \(\) to \(1_{}\)--for the probability semiring \(=(_{ 0},+,,0,1)\). Then the transformation of the smooth and decomposable circuit \(C=X X\) produces \(C^{}= X+ X\), which evaluates to \(p_{C^{}}(X=)=2\) whereas \((p_{C}(X=))=1\). In order for this simple algorithm to be correct, we need to impose certain conditions on the elementwise mapping \(\) and/or the circuit \(C\) it is being applied to.

**Theorem 4** (Tractable Mapping).: _Let \(C\) be a smooth and decomposable circuit over semiring \(\), and \(:^{}\) a mapping such that \((0_{})=0_{^{}}\). Then it is possible to compute the mapping of \(C\) by \(\) as a smooth and decomposable circuit \(C^{}\) (i.e., \(p_{C^{}}()=(p_{C}())\)) in \(O(|C|)\) time and space if \(\) distributes over sums and over products._

\(\) distributes over sums _if: either **(Additive)**\(\) is an additive homomorphism, i.e. \((a b)=(a)(b)\); or **(Det)**\(C\) is deterministic._

\(\) distributes over products _if: either **(Multiplicative)**\(\) is an multiplicative homomorphism, i.e. \((a b)=(a)(b)\); or **(Prod 0/1)**\((1_{})=1_{^{}}\), and for all product nodes \(=_{1}_{2} C\), and for every value \(}(}()),\) either \(p_{_{1}}(_{}(_{1})})\{0_{},1_{ }\}\) or \(p_{_{2}}(_{}(_{2})})\{0_{},1_{ }\}\)._

We can apply Theorem 4 to immediately derive the following property of support mappings:

**Corollary 1** (Support Mapping).: _Given a circuit \(C\) over a semiring \(\) and any target semiring \(^{}\), a circuit representing \( p_{C}_{^{}}\) can be computed tractably if (i) \(\) satisfies \(a b=0_{} a=b=0_{}\) and \(^{}\) is idempotent (i.e., \(1_{^{}} 1_{^{}}=1_{^{}}\)), or (ii) \(C\) is deterministic._

Proof.: First note that \(_{^{}}\) satisfies (Multiplicative), and thus distributes over products. If (i) holds, consider \( a b_{^{}}\). If \(a=b=0_{}\), then this is equal to \( 0_{}_{^{}}=  a_{^{}}+ b _{^{}}=0_{^{}}\); otherwise \(a,b,a b 0_{}\) and \( a b_{^{}}=  a_{^{}}  b_{^{}}=1_{^{ }}\) (by idempotence of \(^{}\)). Thus \(_{^{}}\) satisfies (Additive). Alternatively, if (ii) holds, then (Det) holds. In either case \(_{^{}}\) distributes over sums in the circuit. 

The following examples illustrate the generality of elementwise mappings and Theorem 4:

**Example 2** (Partition Function and MAP).: _Given a probability distribution \(p()\), consider the task of computing the partition function \(_{}p()\) and MAP \(_{}p()\). These can be viewed as aggregations over the probability and \((,)\) semirings respectively._

\(p\) _is often either a probabilistic circuit_ \(C_{prob}\)_, or a combination of a Boolean circuit_ \(C_{bool}\) _and weights_ \(w\) _(in weighted model counting). In the former case, the partition function is tractable because the circuit is already over the probability semiring, while in the latter case, MAP is tractable because the_ \(^{}=(,)\) _semiring is idempotent so_ \( C_{bool}_{^{}}\) _is tractable. On the other hand, the partitionfunction for Boolean circuits and MAP for PCs require determinism for the conditions of Theorem 4 to hold; in fact, these problems are known to be NP-hard without determinism [18; 39]._

**Example 3** (Power Function in Probability Semiring).: _For the probability semiring \(=^{}=(_{ 0},+,,0,1)\), consider the power function \(_{}(a):=a^{}&a 0\\ 0&a=0\) for some \(\). This mapping satisfies (Multiplicative), and is tractable if we enforce (Det) on the circuit._

It is worth noting that semiring homomorphisms (i.e. additive and multiplicative) are always tractable. In the case when \(=^{}=\), it was shown in  that the only such mapping is the identity function. However this is not the case for other semirings: the power function \(_{}\) is an example in the \((,)\) semiring. To summarize, we have shown sufficient tractability conditions for aggregation, products, and elementwise mappings. Notice that the conditions for aggregation and products only depend on variable scopes and supports, and as such apply to any semiring; in contrast, for elementwise mappings, we take advantage of specific properties of the semiring(s) in question.

### Tractable Composition of Operators

We now analyze compositions of these basic operators. As such, we need to consider not only circuit properties that enable tractability, but how these properties are maintained through each operator, so that the output circuit can be used as input to another operator. We call these _composability conditions_. In all cases, the output circuit is smooth and decomposable. Thus, we focus on the properties of \(\)-determinism, \(\)-compatibility, and \(\)-support-compatibility. We emphasize that these are not singular properties, but rather families of properties indexed by a variable set \(\). We present the intuitive ideas behind our results below, while deferring full proofs to the Appendix.

**Theorem 5** (Composability Conditions).: _The results in Table 1 hold._

\(\)-determinismIntuitively, \(\)-determinism is maintained through products because the resulting sum nodes partition the \(\)-support in a "finer" way to the original circuits, and through elementwise mappings since they do not expand the support of any node (since \((0_{})=0_{^{}}\)). For aggregation, the \(\)-support is maintained if aggregation does not occur over any of the variables in \(\).

\(\)-compatibilityHere, we are interested in the following question: if the input circuit(s) to some operator are \(\)-compatible with some other circuit \(C_{}\) for any fixed \(\), is the same true of the output of the operator? \(\)-compatibility with \(C_{}\) is maintained through aggregation because it weakens the condition (by Proposition 1) and through elementwise mapping as it does not change variable scopes. As for taking the product of circuits, the output circuit will maintain similar variable partitionings at products, such that it remains \(\)-compatible with \(C_{}\). Notably, this result does _not_ hold for compatibility where the scope \(\) may be different for each pair of circuits under consideration; we show a counterexample in Example 4 in the Appendix.

\(\)-support-compatibility\(\)-support-compatibility is maintained through elementwise mappings and aggregation (except on \(\)) for similar reasons to \(\)-determinism. For products, the result retains a similar \(\)-support structure, so \(\)-support compatibility is maintained.

We conclude by remarking that, once we determine that a compositional query is tractable, then one immediately obtains a correct algorithm for computing the query by application of the generic

   &  &  \\   & & \(\)-Det & \(\)-Cmp w / \(C_{}\) & \(\)-SCmp w / \(C_{}\) & **Complexity** \\   & & & **The Output Circuit is...** & (A.4) \\  \))**} &  & \(\)-Det & \(\)-Cmp w / \(C_{}\) & \(\)-SCmp w / \(C_{}\) & \(O(|C|)\) (A.1) \\  & & if \(=\) & if \(=\) & if \(=\) & \(=\) & \(O(|C|)\) (A.1) \\   &  & \(\)-Det & \(\)-Cmp w / \(C_{}\) & N/A & \(O(|C|C|^{})\) (A.2.1) \\   & & SCmp & \(\)-Det & \(\)-Cmp w / \(C_{}\) & \(\)-SCmp w / \(C_{}\) & \(O((|C|,|C^{}|))\) (A.2.2) \\   &  & \)-Det} & \)-Cmp w / \(C_{}\)} & \)-SCmp w / \(C_{}\)} &  \\   & & & & & & \\  

Table 1: Tractability Conditions for Operations on Algebraic Circuits. Sm: Smoothness, Dec: Decomposability; \(\)-Det(erminism), \(\)-Cmp: \(\)-Compatibility, \(\)-SCmp: \(\)-Support-Compatibility.

algorithms for aggregation, product, and elementwise mapping (see Appendix A). An upper bound on the complexity (attained by the algorithm) is also given by considering the complexities of each individual operator; in particular, the algorithm is polytime for a bounded number of operators.

## 4 Case Studies

In this section, we apply our compositional framework to analyze the tractability of several different problems involving circuits found in the literature (Table 2). Some of the results are known, but can now be cast in a general framework (with often simpler proofs). We also present new results, deriving tractability conditions that are less restrictive than reported in existing literature.

**Theorem 6** (Tractability of Compositional Queries).: _The results in Table 2 hold._

### Algebraic Model Counting

In algebraic model counting  (a generalization of weighted model counting), one is given a Boolean function \(()\), and a fully-factorized labeling function \(()=_{V_{i}}_{i}(V_{i})\) in some semiring \(\), and the goal is to aggregate these labels for all satisfying assignments of \(\). This can be easily cast in our framework as \(_{}(())_{ }()\). Here, the support mapping \(_{}\) transfers the Boolean function to the semiring \(\) over which aggregation occurs. Assuming that \(()\) is given as a smooth and decomposable Boolean circuit (DNNF), then by Corollary 1 AMC is tractable if \(\) is idempotent or if the circuit is additionally deterministic (note that \(()\) is omni-compatible, so the product is tractable); this matches the results of .

2AmcA recent generalization of algebraic model counting is the 2AMC (second-level algebraic model counting) problem , which encompasses a number of important bilevel inference problems such as marginal MAP and inference in probabilistic answer set programs. Given a partition of the variables \(=(,)\), a Boolean function \((,)\), _outer_ and _inner_ semirings \(_{},_{}\), labeling functions \(_{}()=_{_{i}}_{,i}(Y_{i})\) over \(_{}\) and \(_{}()=_{_{i}}_{,i}(X_{i})\) over \(_{}\), and an elementwise mapping \(_{_{}_{}}:_{}_{}\), the 2AMC problem is given by:

\[_{}\!\!(_{_{}_ {}}_{}(,)_{ _{}}() ^{}())\] (1)

To tackle this type of bilevel inference problem,  identified a circuit property called \(\)-firstness.

**Definition 9** (\(\)-Firstness).: _Suppose \(C\) is a circuit over variables \(\) and \((,)\) a partition of \(\). We say that a node \( C\) is \(\)-only if \(()\), \(\)-only if \(()\), and \(\) otherwise. Then we say that \(C\) is \(\)-first if for all product nodes \(=_{1}_{2}\), we have that either: (i) each \(_{i}\) is \(\)-only or \(\)-only; (ii) or exactly one \(_{i}\) is mixed, and the other is \(\)-only._

It was stated in  that smoothness, decomposability, determinism, and \(\)-firstness suffice to ensure tractable computation of 2AMC problems, by simply evaluating the circuit in the given semirings (caching values if necessary). We now show that this is neither sufficient nor necessary in general. To build intuition, consider the simple NNF circuit \((X,Y)=(X Y)(X Y)\). Note that \(\) trivially satisfies \(X\)-firstness and is smooth, decomposable, and deterministic. Let

    & **Problem** & **Tractability Conditions** & **Complexity** \\   & PASP (Max-Credal)\({}^{*}\) & Sm, Dec, \(\)-Det & \(O(|C|)\) \\  & PASP (MaxEnt)\({}^{*}\), MMAP & Sm, Dec, Det, \(\)-Det & \(O(|C|)\) \\  & SDP\({}^{*}\) & Sm, Dec, Det, \(\)-Det & \(\)-First & \(O(|C|)\) \\   & Backdoor\({}^{*}\) & Sm, Dec, SD, \(()\)-Det & \(O(|C|^{2})\) \\  & Rrontdoor\({}^{*}\) & Sm, Dec, \(\)-Det, \(()\)-Det & \(O(|C|^{2})\) \\   & MFE\({}^{*}\) & Sm, Dec, \(\)-Det, \(^{*}\)–Det, \((^{*})\)-Det & \(O(|C|)\) \\  & Reverse-MAP & Sm, Dec, \(\)-Det & \(O(|C|)\) \\   

Table 2: Tractability Conditions and Complexity for Compositional Inference Problems. We denote new results with an asterisk.

be the probability semiring, \(^{}\) be the \((,)\)-semiring, labeling functions be \((y)=( y)=1\), \(^{}(x)=^{}( x)=1\), and the mapping function be the identity \((a)=a\). Then, noting that the labels are the multiplicative identity \(1\), the 2AMC value is \(_{X}(_{Y}[\![(X,Y)]\!]_{})= [\![(x,y)]\!]_{}+[\![(x, y)]\!] _{},[\![( x,y)]\!]_{ }+[\![( x, y)]\!]_{ }=(1+1),(0)=2\). On the other hand, the algorithm of  returns the value 2AMC \(=1\), as shown in Figure 3. This is not just a flaw in the specific evaluation algorithm, but rather a provable intractability of the problem given these properties:

**Theorem 7** (Hardness of 2AMC with \(\)-firstness).: _2AMC is #P-hard, even for circuits that are smooth, decomposable, deterministic, and \(\)-first, and a constant-time elementwise mapping._

Analyzing using our compositional framework, the issue is that the tractability conditions for \(\) do not hold; whilst the Boolean circuit is deterministic, this is not true once \(Y\) is aggregated. In fact, we show that also enforcing \(\)-determinism suffices to tractably compute arbitrary 2AMC instances.

**Theorem 8** (Tractability Conditions for 2AMC).: _Every 2AMC instance is tractable in \(O(|C|)\) time for Boolean circuits that are smooth, decomposable, deterministic, \(\)-first, and \(\)-deterministic._

Proof sketch.: The key point to notice is that the elementwise mapping relative to the transformation of inner to outer semiring operates over an aggregation of an \(\)-first and \(\)-deterministic circuit, obtained by the product of a Boolean function (mapped to the inner semiring by a support mapping) and a weight function of \(\). Hence, it satisfies (Det) and (Prod 0/1): all of the \(\)-only children of a product node are 0/1 valued (in the inner semiring). 

For specific instances of 2AMC, depending on the semirings \(,^{}\) and mapping function \(\), we also find that it is possible to remove the requirement of \(\)-firstness or (\(\))-determinism, as we summarize in Table 2. One might thus wonder if there is a difference in terms of compactness between requiring \(\)-determinism and \(\)-firstness, as opposed to \(\)-determinism alone. For example, for sentential decision diagrams (SDD) , a popular knowledge compilation target, these notions coincide: a SDD is \(\)-deterministic iff it is \(\)-first (in which context this property is known as \(\)-constrainedness [37; 22]). However, as shown in Figure 1(b), there exist \(\)-deterministic but not \(\)-first circuits. We now show that \(\)-deterministic circuits can be exponentially more succinct than \(\)-deterministic circuits that are additionally \(\)-first, as the size of \(\) grows.3

**Theorem 9** (Exponential Separation).: _Given sets of variables \(=\{X_{1},...,X_{n}\},=\{Y_{1},...,Y_{n}\}\), there exists a smooth, decomposable and \(\)-deterministic circuit \(C\) of size \(poly(n)\) such that the smallest smooth, decomposable, and \(\)-first circuit \(C^{}\) such that \(p_{C} p_{C^{}}\) has size \(2^{(n)}\)._

Thus, to summarize, some instances of 2AMC can be solved efficiently when \(\) is smooth, decomposable and \(\)-deterministic. A larger number of instances can be solved when additionally, \(\) is deterministic; and all 2AMC problems are tractable if we also impose \(\)-firstness.

### Causal Inference

In causal inference, one is often interested in computing _interventional distributions_, denoted using the \(do()\) operator, as a function of the observed distribution \(p\). This function depends on the causal graph linking the variables, and can be derived using the do-calculus . For example, the well-known _backdoor_ and _frontdoor_ graphs induce the following formulae:

\[p(|do())=_{}p()p(|,),\] (2)

Figure 3: Failure case of 2AMC algorithm on smooth, decomposable, X-first circuit.

\[p(|do())=_{}p(|)_{^{}}p( ^{})p(|^{},).\] (3)

Assuming that the observed joint distribution \(p(,,)\) is given as a probabilistic circuit \(C\), we consider the problem of obtaining a probabilistic circuit \(C^{}\) over variables \(\) representing \(p(|do())\). Tractability conditions for the backdoor/frontdoor cases were derived by , with quadratic/cubic complexity respectively. However, we observe that in some cases we can avoid the requirement of structured decomposability and/or obtain reduced complexity relative to their findings.

In the backdoor case, it is known that structured decomposability and \(()\)-determinism suffices for a quadratic time algorithm. This can be seen by decomposing into a compositional query:

\[_{}_{,}p()  p()_{-1}_{}p() .\] (4)

where \(=(,,)\), and \(_{-1}(a)=a^{-1}&a 0\\ 0&a=0\). Assuming \(()\)-determinism and structured decomposability, then \(_{-1}_{}p()\) is tractable by (Det) and (Multiplicative), the product \(p()_{-1}_{}p()\) by support-compatibility, and the final product by compatibility. However, if we additionally have \(\)-determinism, then the final product becomes tractable by support compatibility. This has linear rather than quadratic complexity, and does not require the circuit to be structured decomposable. In the frontdoor case,  showed that \(\)-determinism, \(()\)-determinism, and structured decomposability suffices for cubic complexity. However, we note that under such conditions, the inner product \(p(^{}) p(|^{},)\) is tractable by support-compatibility. As such, the complexity of this query is actually quadratic rather than cubic as previously shown. We summarize our findings in Table 2 and refer the reader to the Appendix for full proofs.

## 5 Related Work

Our work builds upon the observation that many inference problems can be characterized as a composition of basic operators. Prior works have considered compositional inference for circuits in the Boolean  and probabilistic semirings [48; 49], deriving tractability conditions for operators specific to these semirings. Aside from generalizing to arbitrary semirings, we also introduce extended composability conditions that enable interleaving of aggregation, products, and mappings. Meanwhile, algebraic model counting  deals (implicitly) with mappings from the Boolean semiring to an arbitrary semiring, but does not consider compositional queries. Closest to our work,  consider a generalization of algebraic model counting that allows for an additional semiring translation; however, this still assumes input Boolean circuits and has incomplete tractability characterizations. Our framework resolves these limitations, permitting arbitrary compositional queries over semirings.

Many works have considered (unbounded) sums-of-products queries on arbitrary semirings [21; 5; 1; 23], encompassing many important problems such as constraint satisfaction problems , graphical model inference , and database queries , which are often computationally hard in the worst-case. Algorithms for such queries often utilize compact intermediate representations and/or assume compact input representations, such as circuits [35; 17; 36; 3]. Our framework focuses on queries where the number of operators is bounded, and characterizes conditions under which inference is tractable in polynomial time. It also includes elementwise mappings as a key additional abstraction that can be used to express queries involving more than sums and products.

## 6 Conclusion

In summary, we have introduced a framework for analysing compositional inference problems on circuits, based on algebraic structure. In doing so, we were able to derive new tractability conditions and simplified algorithms for a number of existing problems, including 2AMC and causal inference. Our framework focuses on simple and composable _sufficient_ tractability conditions for aggregations, products and elementwise mappings operators; a limitation of this generality is these conditions may not be necessary for specific queries on specific semirings. Our work motivates the development of knowledge compilation and learning algorithms that target the requisite circuit properties, such as \(\)-determinism. Finally, while we focus on exact inference, for many problems (e.g. marginal MAP) approximate algorithms exist and are of significant interest; an interesting direction for future work is to investigate if these can be also be generalized using the compositional approach.