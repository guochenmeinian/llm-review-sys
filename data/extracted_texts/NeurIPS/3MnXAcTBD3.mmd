# B-ary Tree Push-Pull Method is Provably Efficient

for Distributed Learning on Heterogeneous Data

Runze You\({}^{1}\)   Shi Pu\({}^{1}\)

\({}^{1}\)The Chinese University of Hong Kong, Shenzhen

runzeyou@link.cuhk.edu.cn, pushi@cuhk.edu.cn

Corresponding Author

###### Abstract

This paper considers the distributed learning problem where a group of agents cooperatively minimizes the summation of their local cost functions based on peer-to-peer communication. Particularly, we propose a highly efficient algorithm, termed "B-ary Tree Push-Pull" (BTPP), that employs two B-ary spanning trees for distributing the information related to the parameters and stochastic gradients across the network. The simple method is efficient in communication since each agent interacts with at most \((B+1)\) neighbors per iteration. More importantly, BTPP achieves linear speedup for smooth nonconvex and strongly convex objective functions with only \((n)\) and \((1)\) transient iterations, respectively, significantly outperforming the state-of-the-art results to the best of our knowledge. Our code is available at https://github.com/ryou98/BTPP.

## 1 Introduction

In this paper, we consider a group of agents, labeled as \(:=\{1,2,,n\}\), in which each agent \(i\) holds its own local cost function \(f_{i}:^{p}\) and communicates only within its direct neighborhood. We investigate how the agents collaborate to locate \(x^{p}\) that minimizes the average of all the cost functions:

\[_{x^{p}}f(x)(=_{i=1}^{n}f_{i}(x)),\] (1)

where \(f_{i}(x):=_{_{i}_{i}}[F_{i}(x;_{i})]\). Here \(_{i}\) denotes the local data of agent \(i\) that follows the local distribution \(_{i}\). Data heterogeneity exists if \(\{_{i}\}_{i=1}^{n}\) are not identical.

To solve problem (1), we assume each agent \(i\) queries a stochastic oracle (\(\)) to obtain noisy gradient samples. Stochastic gradients appear in many areas including online distributed learning [23; 3], reinforcement learning [17; 15], generative modeling [5; 6], and parameter estimation [2; 27]. Assumption 1.1 ensures that the gradient estimator \(g_{i}(x;_{i})\) remains unbiased with a bounded variance for any given \(\), while independent samples \(_{i}\) are gathered continuously over time. In addition, the assumption is critical in simulation-based optimization as gradient estimation often encounters noise from multiple sources, such as modeling and discretization errors, or limitations due to finite sample sizes in Monte-Carlo methods .

Modern optimization and machine learning typically involve tremendous data samples and model parameters. The scale of these problems calls for efficient distributed algorithms across multiple computing nodes. Recently, distributed algorithms dealing with problem (1) have been studied extensively in the literature; see, e.g., [19; 14; 4; 34]. Traditional distributed learning approaches typically follow a centralized master-worker setup, where each worker node communicates with a (virtual) central server . However, such a communication pattern incurs significant communication overheads and long latency, especially when the training requires a large number of computing nodes.

Decentralized learning is an emerging paradigm to save communication costs, where the computing nodes are connected through a certain network topology (e.g., ring, grid, hypercube). Decentralized algorithms do not rely on central servers: the agents maintain the similarity among their copies of model parameters through peer-to-peer messages passing by communicating locally with immediate neighbors in the network. Such a setup allows each node to communicate with only a few peers and hence incurs much lower communication overhead . Moreover, it offers strong promise for new applications, allowing agents to collaboratively train a model while respecting the data locality and privacy of each contributor.

Specifically, in decentralized stochastic gradient methods, the agents share their local stochastic gradient updates through gossip communication . At every iteration, the local updates are sent to the neighbors of each agent who iteratively propagate the information through the network. Typically, the agents employ iterative gossip averaging of their neighbors' models with their own, where the averaging weights are chosen to ensure asymptotic uniform distribution of each update across the network. However, local averaging is less effective in "mixing" information which makes decentralized algorithms converge slower than their centralized counterparts. Generally speaking, the network topology determines both the number of per-iteration communications and the convergence rates of decentralized algorithms, leading to a trade-off. For example, a densely-connected graph enables decentralized methods to converge faster but results in less efficient communication since each node needs to communicate with more neighbors. By contrast, a sparsely-connected topology results in a slower convergence rate but also reduces the per-iteration communication cost [19; 21; 35]. In particular, for smooth and non-convex objective functions, it has been shown that decentralized stochastic gradient methods (with arbitrary topology) can achieve the same convergence rate as the centralized SGD method, but only after an initial period of iterations has passed [14; 34; 20]. The number of transient iterations (transient time) heavily depends on the network topology, and thus a practical decentralized stochastic gradient algorithm should aim to minimize the transient time while keeping the number of per-iteration communications small (e.g., over a a sparsely-connected topology). Such an observation has motivated several recent works, which consider network topologies with \((1)\) per-iteration communications (or degree) for each node; see, e.g., [34; 26].

This work considers an alternative mechanism to gossip averaging, called "B-ary Tree Push-Pull" (BTPP), inherited from the Push-Pull method in [22; 33]. Rather than relaying the messages over one graph at every iteration, BTPP uses two B-ary trees (\(_{}\) and \(_{}\)) to spread the information about the parameters and the stochastic gradients, respectively. Each agent assigned in the B-ary tree acts as a worker on an assembly line. The model parameters are transmitted through the graph \(_{}\) from the parent nodes to the child nodes. Meanwhile, the stochastic gradients are computed under the current model parameters and accumulated through the inverse graph of \(_{}\) denoted as \(}_{}\). BTPP can be viewed as a semi-(de)centralized approach given the critical role of node \(1\). Notably, the corresponding mixing matrices of \(_{}\) and \(_{}\) only consist of \(0\)'s and \(1\)'s, which together with the B-ary Tree topology design, results in high algorithmic efficiency. We show BTPP achieves an \(}(n)\) transient time under smooth nonconvex objective functions with \((1)\) per-iteration communications for each agent. By comparison, the state-of-the-art transient time is \((n^{3})\) (see Table 1).

### Related Works

Decentralized LearningDecentralized Stochastic Gradient Descent (DSGD) type algorithms are increasingly popular for accelerating the training of large-scale machine learning models [14; 34; 10]. These algorithms have been adapted under a range of practical settings, including those discussed in [1; 16]. However, DSGD suffers from data heterogeneity , which triggers more advanced techniques such as EXTRA , Exact-Diffusion/D\({}^{2}\), and gradient tracking . The Push-Pull method [22; 33] which enjoys broad topological requirements was introduced for deterministic decentralized optimization under strongly convex objectives. This work particularly takes advantage of the flexibility in the network design of Push-Pull, utilizing the B-ary tree family, while considering stochastic gradients for minimizing smooth nonconvex objectives.

Topology DesignDecentralized stochastic gradient algorithms often rely on gossip averaging over various topologies such as rings, grids, and tori . The hypercube graph  strikes a balance between the communication efficiency and the consensus rate, but the network size is constrained to be the power of two. The work in  re-examined the static exponential graph with \(((n))\)degree and introduced a one-peer exponential graph with \((1)\) degree while preserving the consensus properties under the specific requirement of \(n\). The paper  proposed a base-(\(k+1\)) graph as an enhancement that achieves similar convergence rate as in  under arbitrary network size by sequentially employing multiple graph topologies (splitting an all-connected graph into \(((n))\) different subgraphs). DSGD-CECA  requires roughly \(_{2}(n)\) rounds of message passing for global averaging with \((n)\) network topologies. OD(OU)-EquiDyn  introduces algorithms that employ various topologies to achieve network-size independent consensus rates. RelaySGD  offers a relay-based algorithm that ensures \((1)\) per-iteration communication across different topologies.

The above-mentioned methods all enjoy comparable convergence rates with centralized SGD (and thus achieves linear speedup) when the number of iterations \(T\) is large enough. The transient times are generally in the order of \(}(n^{3})\) under smooth nonconvex objectives (see Table 1) and \(}(n)\) under smooth strongly convex objectives (see Table 2).

Note that the above works and this paper generally consider training machine learning modes within high-performance data-center clusters, in which the network topology can be fully controlled: any two nodes can directly communicate over the network when necessary. By comparison, in some other scenarios, the underlying network topology is fixed, and the communication between two nodes is constrained (e.g., in wireless sensor networks, internet of vehicles, etc).

### Main Contribution

This paper introduces a novel distributed stochastic gradient algorithm, termed "B-ary Tree Push-Pull" (BTPP), which is provably efficient for solving the distributed learning problem (1) under arbitrary network size. The main contribution is summarized as follows:

   Algorithm & Per-iter Comm. & Size \(n\) & Based Graph & Trans. Iter. \\  \(D^{2}\) (Ring)  & \((1)\) & arbitrary & 1 & \((n^{11})\) \\ DSGD (Ring)  & \((1)\) & arbitrary & 1 & \((n^{7})\) \\ Hypercube  & \(((n))\) & power of 2 & 1 & \(}(n^{3})\) \\ Static Exp.  & \(((n))\) & arbitrary & 1 & \(}(n^{3})\) \\ O.-P. Exp.  & 1 & power of 2 & \(((n))\) & \(}(n^{3})\) \\ RelaySGD  & \((1)\) & arbitrary & 1 & \((n^{3})\) \\ OD(OU)-EquiDyn  & 1 & arbitrary & \((n)\) & \((n^{3})\) \\ DSGD-CECA  & \((1)\) & arbitrary & \(((n))\) & \(}(n^{3})\) \\ Base-(\(k+1\))  & \((1)\) & arbitrary & \(((n))\) & \(}(n^{3})\) \\
**BTPP (Ours)** & \(\) & **arbitrary** & **2** & \(}(n)}\) \\   

Table 1: Comparison of different algorithms for distributed stochastic optimization under smooth nonconvex objectives. “Per-iter Comm.” denotes the number of per-iteration communications or neighbors (degree) for each agent. “Based Graph” represents the number of required graph topologies during the entire training procedure. “Trans. Iter.” represents the number of transient iterations. The notation \(}()\) hides all the polylogarithmic factors.

   Algorithm & Per-iter Comm. & Size \(n\) & Based Graph & Trans. Iter. \\  DSGD (Ring)  & \((1)\) & arbitrary & 1 & \(}(n^{5})\) \\ Static Exp.  & \(((n))\) & arbitrary & 1 & \(}(n)\) \\ O.-P. Exp.  & 1 & power of 2 & \(((n))\) & \(}(n)\) \\ RelaySGD  & \((1)\) & arbitrary & 1 & \(}(n)\) \\ OD(OU)-EquiDyn  & 1 & arbitrary & \((n)\) & \(}(n)\) \\
**BTPP (Ours)** & \(\) & **arbitrary** & **2** & \(}(1)}\) \\   

Table 2: Comparison of different algorithms for distributed stochastic optimization under smooth strongly convex objectives. The notation \(}()\) hides all the polylogarithmic factors inheriting from .

* BTPP incurs a \((1)\) communication overhead per-iteration for each agent. Specifically, any agent in the network communicates with at most \((B+1)\) neighbors, where \(B\) can be freely chosen to fit different settings. Generally speaking, larger \(B\) increases the per-iteration communication cost but reduces the transient time at the same time.
* We show BTPP enjoys an \(}(n)\) transient time or iteration complexity under smooth non-convex objectives and an \(}(1)\) transient time or iteration complexity under smooth strongly convex objectives. Such results outperform the baselines: see Table 1 and Table 2. The improvement is significant since the transient time greatly impacts the algorithmic performance, especially under large \(n\).
* The convergence analysis for BTPP is non-trivial, partly due to the fact that the algorithm admits two different network topologies for communicating the model parameters and the (stochastic) gradient trackers respectively. Instead of constructing the induced matrix norms \(\|\|_{}\) and \(\|\|_{}\) as in , the analysis is performed under \(\|\|_{2}\) and \(\|\|_{F}\) only by carefully treating the matrix products and related terms.

### Notation and Preliminaries

Throughout the paper, vectors default to columns if not otherwise specified. Let each agent \(i\) hold a local copy \(x_{i}^{p}\) of the decision variable and an auxiliary variable \(y_{i}^{p}\). Their values at iteration \(k\) are denoted by \(x_{i}^{(k)}\) and \(y_{i}^{(k)}\), respectively. We let \(=[x_{1},x_{2},,x_{n}]^{}^{n p}\), \(=[y_{1},y_{2},,y_{n}]^{}^{n p}\), and \(\) denotes the column vector with all entries equal to \(1\). We also define the aggregated gradients at the local variables as \( F():=[ f_{1}(x_{1}), f_{2}(x_{2}),,  f_{n}(x_{n})]^{}^{n p}\), where \(F():=_{i=1}^{n}f_{i}(x_{i})\). In addition, denote \(:=[_{1},_{2},,_{n}]^{}\), \((,):=[g_{1}(x_{1},_{1}),g_{2}(x_{2 },_{2}),,g_{n}(x_{n},_{n})]^{}^{n p}\). For the conciseness of presentation, we also use \(^{(t)}\) to represent \((^{(t)},^{(t)})\). The term \( a,b\) stands for the inner product of two vectors \(a,b^{p}\). For matrices, \(\|\|_{2}\) and \(\|\|_{F}\) represent the spectral norm and the Frobenius norm respectively, which degenerate to the Euclidean norm for vectors. For simplicity, any square matrix with power \(0\) is the unit matrix \(\) with the same dimension if not otherwise specified.

We assume each agent \(i\) is able to obtain noisy gradient samples of the form \(g_{i}(x,_{i})\) that satisfies the following assumption.

**Assumption 1.1**.: For all \(i\) and \(x^{p}\), each random vector \(_{i}\) is independent and

\[_{_{i}_{i}}[g_{i}(x,_{i})|x]= f _{i}(x),\ _{_{i}_{i}}[\|g_{i}(x,_{i})- f_ {i}(x)\|^{2}|x]^{2}\]

for some \(^{2}>0\).

Regarding the individual objective functions \(f_{i}\), we make the following standard assumption.

**Assumption 1.2**.: Each \(f_{i}(x):^{p}\) is lower bounded with \(L\)-Lipschitz continuous gradients, i.e., for any \(x,x^{}^{p}\),

\[\| f_{i}(x)- f_{i}(x^{})\| L\|x-x^{ }\|.\]

We also consider the following standard assumption regarding strongly convexity.

**Assumption 1.3**.: For any \(x,y^{p}\),

\[f(y) f(x)+ f(x),y-x+\|y-x \|^{2}.\]

Denote \(f^{*}:=_{x^{p}}f(x)\). Let \(x^{*}=_{x}f(x)\) if Assumption 1.3 holds.

A directed graph \((,)\) consists of a set of \(n\) nodes \(\) and a set of directed edges \(\), where an edge \((j,i)\) indicates that node \(j\) can directly send information to node \(i\). To facilitate the local averaging procedure, each graph can be associated with a non-negative weight matrix \(=[w_{ij}]^{n n}\), whose element \(w_{ij}\) is non-zero only if \((j,i)\). Similarly, a non-negative weight matrix \(\) corresponds to a directed graph denoted by \(_{}\). For a given graph \(_{}\), the in-neighborhood and out-neighborhood of node \(i\) are given by \(_{,i}^{ini}:=\{j:(j,i)\}\) and \(_{,i}^{out}:=\{j:(i,j)\}\), respectively. The degree of node \(i\) is the number of its in-neighbors or out-neighbors. For example, in a one-peer graph, the degree of each node is at most \(1\).

### Organization of the Paper

The rest of this paper is organized as follows. In Section 2, we introduce the B-ary Tree Push-Pull algorithm and present its main convergence results. The sketch of analysis is presented in Section 3, and numerical experiments are provided in Section 4. We conclude the paper in Section 5.

## 2 B-ary Tree Push-Pull Method

### Communication Graphs

The proposed B-ary Tree Push-Pull method makes use of two spanning trees as communication graphs: \(_{}\) and \(_{}\), which correspond to two mixing matrices \(\) and \(\), respectively. Specifically, we consider B-ary tree graphs with arbitrary number of nodes \(n\) and depth \(d\). The root node is labeled as \(1\) for convenience, and we index the nodes layer-by-layer. The additional nodes are placed at the last layer if the tree is not full. Figure 1 illustrates the assignment of 10 nodes when \(B=2\). In the Pull Tree \(_{}\) (the left ones), each node has \(1\) parent node and \(B\) child nodes (except the ones in the last layer). The root node \(1\) has no parent node. In the Push Tree \(_{}\) (the right ones), each node has \(1\) child node and \(B\) parent nodes (except the ones in the last layer). It can be seen that the tree \(_{}\) is identical to \(_{}\) with all the edges reversing directions. Note that only node 1 has a self-loop.

### Algorithm

We consider the following distributed stochastic gradient method (Algorithm 1) for solving problem (1). At every iteration \(t\), each agent \(i\) pulls the state information from its in-neighborhood \(_{,i}^{in}\), pushes its (stochastic) gradient tracker \(y_{i}\) to the out-neighborhood \(_{,i}^{out}\), and updates its local variables \(x_{i}\) and \(y_{i}\) based on the received information. The agents aim to find the \(\)-stationary point jointly by performing local computation and exchanging information through two spanning trees.

More specifically, in the pull tree \(_{}\), each node \(i\) pulls the updated model from its parent node along the tree. Note that \(_{,i}^{in}\) consists of only one node, the parent node. The Push Tree \(_{}\) is the inverse of the Pull Tree, in which each node collects and aggregates the gradient trackers from its parent nodes. Due to the tree structure, only \(y_{1}^{t}\) aggregates and tracks the stochastic gradients across the entire network, which will be made clear from the analysis. The implementation of the algorithm is rather simple. Taking node 2 in Figure 1 as an example, we have \(x_{2}^{(t+1)}=x_{1}^{(t)}- y_{1}^{(t)}\) and \(y_{2}^{(t+1)}=y_{4}^{(t)}+y_{5}^{(t)}+g_{2}(x_{2}^{(t+1)};_{2}^{(t+1)})-g_ {2}(x_{2}^{(t)};_{2}^{(t)})\).

We can write Algorithm 1 in the following compact form:

\[^{(t+1)}&=(^{(t)}- ^{(t)})\\ ^{(t+1)}&=^{(t)}+(^{(t+1)},^{(t+1)})-(^{(t)},^{(t)} )\] (2)

where \(^{(0)}=(^{(0)},^{(0)})\), and \(,^{n n}\) are non-negative matrices whose elements are given by

\[[]_{i,j}=1&i\{Bj+1-B+[B]\}[n] i=j=1\\ 0&\]

and \(=^{}\) which corresponds to \(_{}\), the inverse tree of \(_{}\). It can be seen that \(\) is a row-stochastic matrix that only consists of \(0\)'s and \(1\)'s, and \(\) is column stochastic. For example, the mixing matrices corresponding to the graphs in Figure 1 are given by

Figure 1: Two spanning trees with \(10\) nodes when \(B=2\). On the left is \(_{}\), and the right one is \(_{}\).

```
1: Each agent \(i\) initializes with any arbitrary but identical \(x_{i}^{(0)}=x^{(0)}^{p}\), \(y_{i}^{(0)}=g_{i}(x_{i}^{(0)},_{i}^{(0)})^{p}\) after drawing a random sample \(_{i}^{(0)}\), stepsize \(>0\) and number of iterations \(T\).
2:for iteration \(t=0,1,2,,T-1\)do
3:for agent \(i\) in parallel do
4: Pull \(x_{j}^{(t)}- y_{j}^{(t)}\) from each \(j_{,i}^{in}\)
5: Push \(y_{i}^{(t)}\) to each \(j_{,i}^{out}\)
6: Independently draw a random sample \(_{i}^{(t+1)}\)
7: Update parameters through \[x_{i}^{(t+1)} =_{j_{,i}^{in}}(x_{j}^{(t)}-  y_{j}^{(t)})\] \[y_{i}^{(t+1)} =_{j_{,i}^{out}}y_{j}^{(t)}+g_{i}(x_ {i}^{(t+1)};_{i}^{(t+1)})-g_{i}(x_{i}^{(t)};_{i}^{(t)})\]
8:endfor
9:endfor
10: Output \(x_{1}^{(T)}\). ```

**Algorithm 1** B-ary Tree Push-Pull Method (BTPP)

### Main Results

The main convergence properties of BTPP are summarized in the following two theorems, where the second result assumes strongly convexity on \(f\).

**Theorem 2.1**.: _For the BTPP algorithm outlined in Algorithm 1 implemented on B-ary tree graphs \(_{}\) and \(_{}\), assume Assumption 1.1 and Assumption 1.2 hold. Let \(=\{(}{3^{2}Ln(T+1)})^{}, (}{1500n^{2}d^{}^{2}L^{2}(T+1)})^{},L}\}\). The following convergence result holds:_

\[_{t=0}^{T}\| f(x_{1}^{(t)})\|_{2}^ {2}^{2}L}}{}+ (^{2}L^{2}_{f}^{2})^{}}{((T+1) )^{}}+L_{f}}{T+1}+(^{(0)})\|_{F}^{2}}{n(T+1)},\] (3)

_where \(_{f}:=f(_{1}^{(0)})-f^{*}\) and \(d=_{B}(n)\) represents the diameter of the graphs._

_Remark 2.2_.: Based on the convergence rate in (3) of BTPP, we can derive that when \(T=(n^{12}(n))\), the term \((}})\) dominates the remaining terms up to a constant scalar. This implies that BTPP achieves linear speedup after \((n^{12}(n))\) transient iterations.

_Remark 2.3_.: The convergence rate in (3) is related to the branch size \(B\). For larger \(B\), the diameter \(d=_{B}(n)\) becomes smaller, which results in more efficient transmission of information and fewer transient iterations. However, the per-iteration communication cost is relatively larger. When \(B\) is smaller, the communication burden for each agent at every iteration is lighter, but the transient time is larger. Therefore, in practice, the communication cost and convergence rate can be balanced by considering a proper \(B\).

**Theorem 2.4**.: _For the BTPP algorithm outlined in Algorithm 1 implemented on B-ary tree graphs \(_{}\) and \(_{}\), assume Assumption 1.1, Assumption 1.2 and Assumption 1.3 hold. Let \(=\{ L^{2}},)}{n(T+ 1)}\}\) and \(T 2d\). The following convergence result holds:_

\[&\|x_{1}^{(T)}-x^{*}\|^{2} (n(T+1)^{2})}{n(T+1)^{2}}+^{2}^{2}((n(T+1)^{2}))^{2}}{n(T+1)^{ 2}^{2}}\\ &+\{(-^{2}}),}\}(\|x_{1}^{(0)}-x^{*}\|^{2}+}\|(^{(0)})\|_{F}^{2}). \] (4)

_Remark 2.5_.: The convergence rate in (4) implies that \(\|x_{1}^{(T)}-x^{*}\|^{2}}( +}+(-T)),\) where \(}\) hides the constants and polylogarithmic factors. The transient time is thus \((1)\), i.e., the number of iterations before the term \(()\) dominates the remaining terms. Such a transient time also outperforms the state-of-the-art results.

## 3 Analysis of B-ary Tree Push-Pull

In this section, we study the convergence of BTPP and prove Theorem 2.1 by analyzing the properties of the weight matrices \(\) and \(\), the evolution of the aggregated consensus error \(_{t=0}^{T}\|}^{(t)}\|_{F}^ {2}\), and the expected inner products of the stochastic gradients between different layers. The approach is different from those employed in [22; 19; 26], where the analysis considers two special matrix norms related to \(\) and \(\), respectively. Such a distinction is because BTPP works with two B-ary trees and iterates in a layer-wise manner, while most other works consider connected graphs.

Our analysis starts with characterizing the weight matrices \(\) and \(\), as delineated in the following lemmas. It is important to note that for any given \(n\) and a specific integer \(B\), we can determine an integer \(d\) satisfying \(-1}{B-1}<n-1}{B-1}\) which is the diameter of the graphs.

Notice that \(\) has a unique non-negative left eigenvector \(^{}\) (w.r.t. eigenvalue 1) with \(^{}=n\). More specifically, \(=[n,0,,0]^{}\), which is also the unique right eigenvector of \(\) (w.r.t. eigenvalue 1), denoted by \(\) for the clarity of presentation. Following the above observations, it is revealed in Lemma 3.1 that the \(2\)-norm of the matrix \(-^{}\) with exponent \(k\) remains bounded by \(\) and equals zero when \(k\) exceeds \(d-1\).

**Lemma 3.1**.: _Given a positive integer \(k\), the 2-norm of the matrix \(^{k}-^{}\) satisfies_

\[\|^{k}-^{}\|_{2}\{ []{rl}&k d-1\\ =0&k d.\]

Similar result applies to the matrix \(^{k}-^{}\). Consequently, we introduce the mixing matrices \(},}\) based on the eigenvectors \(,\), which play a crucial role in the follow-up analysis.

\[}:=-^{},\;}:=-^{}.\]

The following lemmas delineate the critical elements for constraining the average expected norms of the objective function as formulated in (1), i.e., \(_{t=0}^{T}\| f(x_{1}^{(t)})\|_{2}^ {2}\). Lemma 3.2 and Lemma 3.3 provide bounds on the expressions \(_{t=0}^{T}\|}^{(t+1)}-}^{(t)}\|_{F} ^{2}\) and \(_{t=0}^{T}\|}^{(t)}\|_{F}^{2}\), where \(}^{(t)}:=^{}^{(t)}\).

**Lemma 3.2**.: _Suppose Assumption 1.1 holds and \(\), we have the following inequality:_

\[&_{t=0}^{T}\|}^{(t+1)}- }^{(t)}\|_{F}^{2} 6^{2}n^{2}^{2}(T+1)+50^{2}n^{2}d^{2}L^{2} _{t=0}^{T}\|}^{(t)}\|_{F}^{ 2}\\ &+6^{2}n^{2}d\|(^{(0)}) \|_{F}^{2}+15^{2}n^{3}_{t=0}^{T}\| f(x_{ 1}^{(t)})\|_{2}^{2}.\]

**Lemma 3.3**.: _Suppose Assumption 1.1 holds and \(L}\), we have for \(d 2\) that_

\[_{t=0}^{T}\|}}^{(t )}\|_{F}^{2}  300^{2}n^{2}d^{4}(T+1)^{2}+20^{2}n^{3}d^{2} _{t=0}^{T}\| f(x_{1}^{(t)})\|_{2}^{2}\] \[+6nd\|}}^{(0)}\|_{F }^{2}+40^{2}n^{2}d^{3}\|(^{(0)})\|_ {F}^{2}.\]

From the design of BTPP, there is an inherent delay in the transmission of information from layer \(k\) to layer \(1\). As information traverses through the B-ary trees, the delay becomes evident. Specifically, for nodes at layer \(k\), their information requires an additional \(k\) iterations to successfully reach and impact node \(1\), as demonstrated in Lemma 3.4.

**Lemma 3.4**.: _For any integer \(t>1\), we have_

\[_{m=1}^{\{t,d\}} f(x_{1}^{(t)}),( ^{}}{n}-^{})_{m}( ^{(t-m)}-(^{(t-m)}))=0,\]

_where \(_{m}=^{m}-^{m-1}\) and \(_{1}=-\)._

Building on the preceding lemmas, we are in a position to establish the main convergence result for the BTPP algorithm. This involves upper bounding the expected norm for the gradient of the objective function evaluated at \(x_{1}^{(t)}\). To show the result, we integrate the findings from Lemma 3.2, Lemma 3.3, and Lemma 3.4, as detailed in Lemma 3.5.

**Lemma 3.5**.: _Suppose Assumption 1.1 and Assumption 1.2 hold and \(L}\), we have_

\[_{t=0}^{T}\| f(x_{1}^{(t)}) \|_{2}^{2} }{ n(T+1)}+24^{2}L+20000^{2}nd^ {6}^{2}L^{2}\] \[+L^{2}\|}} ^{(0)}\|_{F}^{2}}{T+1}+L\|( ^{(0)})\|_{F}^{2}}{T+1}.\]

_Remark 3.6_.: Lemma 3.5 implies that the transient time of BTPP under Assumption 1.2 is influenced by the fourth term in the upper bound: \(L^{2}\|}}^{(0)}\|_{F}^{ 2}}{T+1}\) which is related to the initial consensus error. Therefore, we initialize all the agents with the same solution \(x^{(0)}\).

Under strong convexity of \(f\), we have the following key lemma.

**Lemma 3.7**.: _Suppose Assumption 1.1, Assumption 1.2 and Assumption 1.3 hold, and \( L}\), we have_

\[\|x_{1}^{(T)}-x^{*}\|^{2}(1-)^{T}\|x_{1}^{(0)}-x^{*}\|^{2}\] \[+7^{2}n^{2}(T+1)+21000^{3}n^{ 2}d^{6} L^{2}(T+1)\] \[+80^{2}nd^{3}(1-)^{T- d}\|(^{(0)})\|+420^{3}n^{2}d^{3}  L\|}}^{(0)}\|_{F}^{2},\]

_where \(:=L/\) is the conditional number._

## 4 Numerical Results

This section presents experimental results to compare the B-ary Tree Push-Pull method with other popular algorithms on logistic regression with synthetic data and deep learning tasks with real data.

### Logistic Regression

We compare the performance of BTPP against other algorithms listed in Table 1 for logistic regression with non-convex regularization . The objective functions \(f_{i}:^{p}\) are given by

\[f_{i}(x):=_{j=1}^{J}(1+(-y_{i,j}h_{i,j}^{}x) )+R_{k=1}^{p}^{2}}{1+x_{[k]}^{2}},\]where \(x_{[k]}\) is the \(k\)-th element of \(x\), and \(\{(h_{i,j},y_{i,j})\}_{j=1}^{J}\) represent the local data kept by node \(i\). To control the data heterogeneity across the nodes, we first let each node \(i\) be associated with a local logistic regression model with parameter \(_{i}\) generated by \(_{i}=+v_{i}\), where \((0,_{p})\) is a common random vector, and \(v_{i}(0,_{h}^{2}_{p})\) are random vectors generated independently. Therefore, \(\{v_{i}\}\) decide the dissimilarities between \(_{i}\), and larger \(_{h}\) generally amplifies the difference. After fixing \(\{_{i}\}\), local data samples are generated that follow distinct distributions. For node \(i\), the feature vectors are generated as \(h_{i,j}(0,_{p})\), and \(z_{i,j}(0,1)\). Then, the labels \(y_{i,j}\{-1,1\}\) are set to satisfy \(z_{i,j} 1+(-y_{i,j}h_{i,j}^{}_{i})\).

In the simulations, the parameters are set as follows: \(n=100\), \(p=500\), \(J=1000\), \(R=0.01\), and \(_{h}=0.8\). All the algorithms initialize with the same stepsize \(=0.3\), except BTPP, which employs a modified stepsize \(/n\). Such an adjustment is due to BTPP's update mechanism, which incorporates a tracking estimator that effectively accumulates \(n\) times the averaged stochastic gradients as the number of iterations increases. This can also be seen from the stepsize choice in Theorem 2.1.2 Additionally, we implement a stepsize decay of 60% every \(100\) iterations to facilitate convergence.

In Figure 2, the gradient norm is used as a metric to gauge the algorithmic performance of each algorithm. The left panel of Figure 2 illustrates the comparative performance of various algorithms, highlighting that BTPP (in red) achieves faster convergence than the other algorithms with \((1)\) degree and closely approximates the performance of the centralized SGD algorithm (i.e., DSGD-FullyConnected). The right panel of Figure 2 demonstrates the behavior of BTPP when increasing the branch size \(B\). It is observed that with larger \(B\), the convergence trajectory of BTPP more closely aligns with that of centralized SGD, corroborating the prediction of the theoretical analysis.

### Deep Learning

We apply BTPP and the other algorithms to solve the image classification task with CNN over **MNIST** dataset . We run all experiments on a server with eight Nvidia RTX 3090 GPUs. The network contains two convolutional layers with max pooling and ReLu and two feed-forward layers. In particular, we consider a heterogeneous data setting, where data samples are sorted based on their labels and partitioned among the agents. The local batch size is set to \(8\) with \(24\) agents in total. The learning rate is \(0.01\) for all the algorithms except BTPP (which employs a modified stepsize \(/n\)) for fairness. Additionally, the starting model is enhanced by pre-training using the SGD optimizer on the entire MNIST dataset for several iterations. Figure 3 illustrates the training loss and the test accuracy curves. Comparing the performance of different algorithms, it can be seen that BTPP (in red) and DSGT with ODEquiDyn (based on \((n)\) graphs) achieve faster convergence than the

Figure 2: Left: performance of algorithms for logistic regression with nonconvex regularization, where the dotted lines correspond to algorithms whose degrees are not \((1)\). We let the branch size \(B=2\) in BTPP, \(=0.5\) in OD-EquiDyn, \(k=2\) in Base-(\(k+1\)), and perform RelaySGD on a binary tree graph for fairness. Right: performance of BTPP with different branch size \(B\).

other algorithms with \((1)\) degree and closely approximate the performance of centralized SGD(i.e., DSGD-FullyConnected).

_Remark 4.1_.: Higher accuracy can be achieved for BTPP and other methods when using the momentum technique, or when the data heterogeneity is removed, meaning that samples are randomly assigned to each agent. Additional experiments demonstrating the performance of various algorithms across different tasks and scenarios are provided in Appendix B.

## 5 Conclusions

This paper proposes a novel algorithm for distributed learning over heterogeneous data, named BTPP. The convergence is theoretically analyzed for smooth non-convex stochastic optimization. The results demonstrate that, at the minimal communication cost per iteration, BTPP achieves linear speedup in the number of nodes \(n\), and the transient times behaves as \((n)\) and \((1)\) respectively for smooth nonconvex and strongly convex objectives, outperforming the state-of-the-art results. Numerical experiments further validate the efficiency of BTPP.

Figure 3: Train loss and test accuracy of different algorithms for training CNN on MNIST, where the dotted lines correspond to the algorithms whose degrees are not \((1)\). We perform BTPP with \(B=2\), ODEquiDyn with \(=0.5\), Base-(\(k+1\)) with \(k=2\), and RelaySGD on a binary tree graph for fairness.

[MISSING_PAGE_FAIL:11]

* A. Nedic, A. Olshevsky, and M. G. Rabbat, _Network topology and communication-computation tradeoffs in decentralized optimization_, Proceedings of the IEEE, 106 (2018), pp. 953-976.
* S. Pu and A. Nedic, _Distributed stochastic gradient tracking methods_, Mathematical Programming, 187 (2021), pp. 409-457.
* S. Pu, A. Olshevsky, and I. C. Paschalidis, _Asymptotic network independence in distributed stochastic optimization for machine learning: Examining distributed and centralized stochastic gradient descent_, IEEE signal processing magazine, 37 (2020), pp. 114-122.
* S. Pu, A. Olshevsky, and I. C. Paschalidis, _A sharp estimate on the transient time of distributed stochastic gradient descent_, IEEE Transactions on Automatic Control, 67 (2021), pp. 5900-5915.
* S. Pu, W. Shi, J. Xu, and A. Nedic, _Push-pull gradient methods for distributed optimization in networks_, IEEE Transactions on Automatic Control, 66 (2020), pp. 1-16.
* B. Recht, C. Re, S. Wright, and F. Niu, _Hogwild!: A lock-free approach to parallelizing stochastic gradient descent_, Advances in neural information processing systems, 24 (2011).
* S. Resnick, _A probability path_, Springer, 2019.
* W. Shi, Q. Ling, G. Wu, and W. Yin, _Extra: An exact first-order algorithm for decentralized consensus optimization_, SIAM Journal on Optimization, 25 (2015), pp. 944-966.
* Z. Song, W. Li, K. Jin, L. Shi, M. Yan, W. Yin, and K. Yuan, _Communication-efficient topologies for decentralized learning with \(o(1)\) consensus rate_, Advances in Neural Information Processing Systems, 35 (2022), pp. 1073-1085.
* N. Srivastava, G. Hinton, A. Krizhevsky, I. Sutskever, and R. Salakhutdinov, _Dropout: a simple way to prevent neural networks from overfitting_, The journal of machine learning research, 15 (2014), pp. 1929-1958.
* Y. Takezawa, R. Sato, H. Bao, K. Niwa, and M. Yamada, _Beyond exponential graph: Communication-efficient topologies for decentralized learning via finite-time convergence_, arXiv preprint arXiv:2305.11420, (2023).
* H. Tang, X. Lian, M. Yan, C. Zhang, and J. Liu, _&2: Decentralized training over decentralized data_, in International Conference on Machine Learning, PMLR, 2018, pp. 4848-4856.
* L. Trevisan, _Lecture notes on graph partitioning, expanders and spectral methods_, University of California, Berkeley, https://people. eecs. berkeley. edu/luca/books/expanders-2016. pdf, (2017).
* T. Vogels, L. He, A. Koloskova, S. P. Karimireddy, T. Lin, S. U. Stich, and M. Jaggi, _Relaysum for decentralized deep learning on heterogeneous data_, Advances in Neural Information Processing Systems, 34 (2021), pp. 28004-28015.
* L. Xiao and S. Boyd, _Fast linear iterations for distributed averaging_, Systems & Control Letters, 53 (2004), pp. 65-78.
* R. Xin and U. A. Khan, _A linear algorithm for optimization over directed graphs with geometric convergence_, IEEE Control Systems Letters, 2 (2018), pp. 315-320.
* B. Ying, K. Yuan, Y. Chen, H. Hu, P. Pan, and W. Yin, _Exponential graph is provably efficient for decentralized deep training_, Advances in Neural Information Processing Systems, 34 (2021), pp. 13975-13987.
* K. Yuan, S. A. Alghunaim, and X. Huang, _Removing data heterogeneity influence enhances network topology dependence of decentralized sgd_, Journal of Machine Learning Research, 24 (2023), pp. 1-53.

Convergence Analysis of BTPP

In this section, we aim to demonstrate the convergence results of BTPP through a three-step process. First, we explore the key properties of matrices \(\) and \(\), acquainting readers with several operations that will be frequently utilized in the subsequent parts. Then, we introduce various technical tools essential for the analysis. Finally, we delve into proving the convergence results supported by a series of pertinent lemmas.

### Properties of the Weight Matrices

In this part, we first demonstrate that \(^{n n}\) possesses a set of properties ( the matrix \(=^{}\) shares similar properties). Then, we utilize the established tools to prove the crucial result presented in Lemma 3.1. Lastly, we provide clarifications on certain matrix operations that will be frequently employed in deriving the convergence results.

It is important to note that for any given \(n\) and specific integer \(B\), the diameter of the corresponding B-ary tree graph \(d\) (the distance from the last layer node to node 1) satisfies \(-1}{B-1}<n-1}{B-1}\). To investigate the properties of \(\) and \(\), we will introduce the column vector \(_{}^{n}\), where each element of \(_{}\) is equal to 1 for indices \(i\) and 0 otherwise. Define the index sets

\[_{1,k} =\{1:-1}{B-1}\},\] \[_{i,k} =\{(-1}{B-1}+(i-2)B^{k}+1):( -1}{B-1}+(i-1)B^{k})\},\]

where \(k_{1}:k_{2}\) is the arithmetic progression from \(k_{1}\) to \(k_{2}\) with difference 1. We can then define the matrix \(_{k}^{n n}\) as a composite of several column vectors arranged in the following format:

\[_{k}=[_{_{1,k}},_{_{ 2,k}},,_{_{n,k}}].\]

This closed-form expression of \(\) with any power \(k\) is shown in Lemma A.1 which aids in developing further properties.

**Lemma A.1**.: _For the pull matrix \(\) corresponding to the B-ary tree \(_{}\), given any positive index \(k\), we have_

\[^{k}=_{k}.\]

Proof.: We prove the lemma by induction. First, it is obvious that \(=_{1}\) by the definition of \(\):

\[_{ij}=1\] \[i\{Bj+1-B+[B]\}[n]i=j=1\] \[B(j-1)+2 i Bj+1,\;i[n]i=j=1\] \[[Z_{1}]_{ij}=1.\]

Now assume the statement is true for \(k=j\). Then, for \(k=j+1\), we have

\[^{j+1}=^{j}*=_{j}_{1}.\]

Denote \([_{j}_{1}]_{i}\) as the \(i\)-th column of \(_{j}_{1}\). To establish the result, we only need to demonstrate that the two matrices, \(^{k+1}\) and \(_{k+1}\), have the same column entries. For \(i=1\),

\[[_{j}_{1}]_{1}=_{j}[_{1}]_{1}=_{i= 1}^{B+1}[_{j}]_{i}=_{i=1}^{B+1}_{_{i,j}}= _{_{i=1}^{B+1}_{i,j}}=_{_{1,j+1}}.\]

For \(i>1\), we have

\[[_{j}_{1}]_{i}=_{j}[_{1}]_{i}=_{m _{i,1}}[_{j}]_{m}=_{m=(i-1)B+2}^{iB+1}[_ {j}]_{m}\]

\[=_{m=(i-1)B}^{iB-1}_{_{m,j}}=_{_{m=(i-1 )B}^{jB-1}_{m,j}}=_{_{i,j+1}}.\]

Thus, we conclude that \(^{k+1}=_{k+1}\)Corollary A.2 below reveals that when the power \(k\) exceeds \(d\), \(^{k}\) transforms into a matrix where the first column is entirely composed of ones, while all the other columns consist of zeros.

**Corollary A.2**.: _For \(k=d\), we have_

\[^{k}-^{}=\]

_where \(\) is the matrix with all entries equal 0._

Proof.: From Lemma A.1, we have for the \(i\)-th column of \(^{k}-^{}\) that

\[[^{k}-^{}]_{i}= -_{-1}{B-1}+1:n}&i=1\\ &_{_{i,k}}&i>1\]

For \(k=d\), the first \(n\) elements of all the columns remain \(0\), which implies the desired result. 

Now, we are ready to prove Lemma 3.1:

Proof of Lemma 3.1.: For any integer \(k d-1\), define

\[n_{0}:=-1}{B-1}}{B^{k}}.\]

This ensures that \(-1}{B-1}+n_{0}B^{k} n\) and \(-1}{B-1}+(n_{0}+1)B^{k}>n\), so that only the first \((n_{0}+2)\)-th columns of \(^{k}\) consist of non-zero elements. Note that

\[_{\|\|_{2}=1}\{\|(^{k}-^{})\|_{2}^{2}\}=_{} \{^{k}-^{}) \|_{2}^{2}}{\|\|_{2}^{2}}\}.\]

Then, we focus on the non-zero elements of the matrix \(^{k}-^{}\).

\[:=}^{}}}{\| \|^{2}},\]

where \(}=(x_{1},,x_{n_{0}+2})\) is the truncated \(\), and

\[=n--1}{B-1}&-B^{k}&&-[n--1}{B-1}-B^{k}n_{0}]\\ -B^{k}&B^{k}&&\\ &&&\\ -[n--1}{B-1}-B^{k}n_{0}]&&[n--1}{B- 1}-B^{k}n_{0}],\]

where the unspecified elements are all zeros. Since \(\) is symmetric, all the eigenvalues are real. We show by contradiction that any eigenvalue \(\) of \(\) is upper bounded by \(n\). Otherwise, if there exists \(>n\), we denote \(\) as the corresponding eigenvector of \(\). Then, we have from \(=\) that

\[ x_{1} =(n--1}{B-1})x_{1}-B^{k}x_{2}-- [n--1}{B-1}-B^{k}n_{0}]x_{n_{0}+2}\] \[ x_{2} =-B^{k}x_{1}+B^{k}x_{2}\] \[ x_{3} =-B^{k}x_{1}+B^{k}x_{3}\] \[\] \[ x_{n_{0}+2} =-[n--1}{B-1}-B^{k}n_{0}]x_{1}+[n- -1}{B-1}-B^{k}n_{0}]x_{n_{0}+2}.\]Without loss of generality, assume \(x_{1} 0\). Then, by substituting the other relations into the first one, we have

\[=n--1}{B-1}+_{i=1}^{n_{0}}}{-B^{k}}+ -1}{B-1}-B^{k}n_{0}]^{2}}{-[n- -1}{B-1}-B^{k}n_{0}]}.\]

With the fact that \(>n\), there holds

\[ n--1}{B-1}+B^{2k}}{n-B^{k}}+-1}{B-1}-B^{k}n_{0}]^{2}}{n-[n--1}{B-1}-B ^{k}n_{0}]}\] \[= n--1}{B-1}+B^{2k}}{n-B^{k}}+ }{-1}{B-1}+B^{k}n_{0}}-2n+-1}{B-1}+B^{k}n_{0}\] \[= n_{0}}{n-B^{k}}+-1}{B-1} -B^{k}n_{0})}{-1}{B-1}+B^{k}n_{0}}\] \[ n_{0}}{n-B^{k}}+}(n--1}{B-1}-B^{k}n_{0})\] \[= n-1}{B-1}}{n-B^{k}}<n,\]

which is a contradiction. Thus, we have \( n\). It follows that

\[}^{}}}{\|\|^{2}} }^{}}}{\|}\|^{2}}_{}() n.\]

From the fact that the square root function is monotonically increasing on \([0,)\), we have

\[\|^{k}-^{}\|_{2}^{2}=_{\| \|_{2}=1}\{\|(^{k}- ^{})\|_{2}^{2}\} n,\]

which implies that \(\|^{k}-^{}\|_{2}\) for \(k d-1\) and \(\|^{k}-^{}\|_{2}=0\) otherwise by Corollary A.2. 

The transformations described in Corollary A.3 below are straightforward.

**Corollary A.3**.: _For any integer \(m>0\), we have_

\[_{} =_{}(- ^{})=(-^{ })_{},\] \[_{}^{m} =_{}(^{m}- ^{})=_{}(-^{})^{m}=(-^{})^{m}_{}.\]

To simplify the convergence analysis, we introduce the matrix \(_{i}\) defined as follows:

\[_{i}=^{i}-^{i-1}\]

for \(i=1,2,,d\). Specifically, \(_{1}=-\). Consequently, Corollary A.4 below can be directly deduced from Lemma A.1 and Corollary A.3.

**Corollary A.4**.: _For \(i=1,,d\), we have_

\[(^{}}{n}-^{})_{i}=\{ _{-1}{B-1}+1:-1}{B-1}}&i d-1 \\ _{-1}{B-1}+1:n}^{}&i=d.\]

Intuitively, Corollary A.4 illustrates that \((^{}}{n}-^{})_{i}\) serves as an indicator vector representing the \((i+1)\)-th layer of the graph.

### Supporting Inequalities and Lemmas

Lemma A.5 and Lemma A.6 below are frequently employed for bounding the norms of matrix summations and multiplications. Their proofs rely on the Cauchy-Schwartz inequality and the definitions of matrix norms \(\|\|_{2}\) and \(\|\|_{F}\).

**Lemma A.5**.: _For an arbitrary set of \(m\) matrices \(\{_{i}\}_{i=1}^{m}\) with the same size, we have_

\[\|_{i=1}^{m}_{i}\|_{F}^{2} m_{i=1}^{m}\| _{i}\|_{F}^{2}.\]

Proof.: By the definition of Frobenius norm, we have

\[\|_{i=1}^{m}_{i}\|_{F}_{i=1}^{m}\| _{i}\|_{F}.\]

Taking squares on both sides and invoking the Cauchy-Schwarz inequality, we have

\[\|_{i=1}^{m}_{i}\|_{F}^{2}(_{i=1}^{m} \|_{i}\|_{F})^{2} m_{i=1}^{m}\| _{i}\|_{F}^{2}.\]

**Lemma A.6**.: _Let \(\), \(\) be two real matrices whose sizes match. Then,_

\[\|\|_{F}\|\|_{2}\| \|_{F}.\]

Proof.: Let \(=^{H}\) be the singular value decomposition of \(\), with the largest singular value \(_{}\) and hence \(\|\|_{2}=_{}\). Then, we have

\[\|\|_{F}^{2} =\|^{H}\|_{F}^{2}= ((^{H})^{H} (^{H}))\] \[=((^{H})^{ H}(^{H}))=\|^{H} \|_{F}^{2}\] \[_{}^{2}\|^{H}\|_{F}^{2}= _{}^{2}(^{}^{H})\] \[=_{}^{2}(^{} )=_{}^{2}\|\|_{F}^{2}\] \[=\|\|_{2}^{2}\|\|_{F}^ {2},\]

which implies the desired result. 

Lemma A.7 below will be used in the last step for deriving the convergence rate of BTPP.

**Lemma A.7**.: _Let \(A,B,C\) and \(\) be positive constants and \(T\) be a positive integer. Define function_

\[g()=+B+C^{2}.\]

_Then,_

\[_{(0,]}g() 2()^{ }+2C^{}()^{}+,\]

_where the upper bound can be achieved by choosing \(=\{()^{},()^{},\}\)._

Proof.: See Lemma 26 in  for a reference. 

Lemma A.8 is a technical result related to random variables.

**Lemma A.8**.: _Consider three random variables \(X\), \(Y\), and \(Z\). Assume that \(Z\) is independent with \((X,Y)\). Let \(h\) and \(g\) be functions such that the conditional expectation \([g(Y,Z) Y]=0\). We have_

\[(h(X)g(Y,Z))=0.\]Proof.: It implies by the condition \(Z\!\!\!(X,Y)\) that \((Z)\!\!\!(X,Y)\). Then,

\[[h(X)g(Y,Z)|Y] =\{[h(X)g(Y,Z)|X,Y]|Y\}\] \[=\{h(X)[g(Y,Z)|X,Y]|Y\}.\]

It suffices to show

\[[g(Y,Z)|X,Y]=[g(Y,Z)|Y](=0).\]

Let \(f_{g}(y)=(g(y,Z))\). Since \((Z)\!\!\!(X,Y)\), we have \((Z)\!\!\!(Y)\). Then,

\[f_{g}(Y)=(g(Y,Z)|Y)=[g(Y,Z)|X,Y],\]

which follows directly from (10.17) in . Thus, by the Tower Rule, we reach the statement as follows:

\[(h(X)g(Y,Z))=\{(h(X)g(Y,Z )|Y)\}=0.\]

### Proofs of Key Lemmas

In this section, we prove several key lemmas for proving the main convergence result of BTPP.

#### a.3.1 Preparation

Algorithm 1, as encapsulated by the equations in (2), can be succinctly expressed in the following matrix form:

\[(^{(t+1)}\\ ^{(t+1)})=(&- \\ &)(^{( t)}\\ ^{(t)})+(\\ ^{(t+1)}-^{(t)}).\] (5)

By repeatedly applying equation (5) starting from time step \(t\) and going back to time step \(0\), we arrive at the following relation:

\[(^{(t)}\\ ^{(t)})=(&- \\ &)^{t}(^{(0)}\\ ^{(0)})+_{m=0}^{t-1}( &-\\ &)^{t-m-1}( \\ ^{(m+1)}-^{(m)}).\]

For the sake of clarity, we start with introducing some simple definitions. Any matrix raised to the power of 0 is defined as the identity matrix \(\), which matches the original matrix in dimension. The only exceptions are \((-^{})^{0}:=}}\) and \((-^{})^{0}:=}}\) for convenience. Furthermore, we introduce the following terms:

\[}^{(t)}:=^{}^{(t) },\ }^{(t)}:=^{}^{(t)}.\]

Note that, for any given integer \(m>0\),

\[(&-\\ &)^{m}=(^{m}&-_{j=1}^{m}^{j}^{m-j}\\ &^{m}).\]

As a result, given the initial condition \(^{(0)}=^{(0)}\), we can deduce the outcomes of \(^{(t)}\) and \(^{(t)}\) as follows.

\[^{(t)} =^{t}^{(0)}-_{m=0}^{t-2}_{j=1} ^{t-m-1}^{j}^{t-m-1-j}[^{(m+1)}- ^{(m)}]-_{j=1}^{t}^{j}^{t-j}^{( 0)},\] (6) \[^{(t)} =_{m=0}^{t-1}^{t-m-1}[^{(m+1)}- ^{(m)}]+^{t}^{(0)}.\] (7)Then, after multiplying \(_{}\) and \(_{}\) to equation (6) and equation (7) respectively, and invoking Corollary A.3, we have

\[_{}^{(t)}& =(-^{})^{t} ^{(0)}-_{j=1}^{\{d-1,t\}}(-^{})^{j}^{t-j}^{(0)}\\ &-_{m=0}^{t-2}_{j=1}^{\{t-m-1,d-1\}}( -^{})^{j}^{t-m -1-j}[^{(m+1)}-^{(m)}],\\ _{}^{(t)}&=_{m= \{0,t-d\}}^{t-1}(-^{} )^{t-m-1}[^{(m+1)}-^{(m)}]+(-^{})^{t}^{(0)}\\ &=_{m=0}^{\{t,d\}}_{m}^{(t-m)}+ _{}^{(t)}.\] (9)

#### a.3.2 Analysis of the Variance

Denote by \(_{t}\) the \(\)-algebra generated by \(\{_{0},,_{t-1}\}\), and define \([|_{t}]\) as the conditional expectation given \(_{t}\). Lemma A.9 provides an estimate for the variance of the gradient estimator \(G(^{(t)},^{(t)})\).

**Lemma A.9**.: _Under Assumption 1.1, for any given power \(k d-1\), we have for all \(t 0\) that_

\[[\|(-^{ })^{k}((^{(t)},^{(t)})- (^{(t)}))\|_{F}^{2}|\,_{t}]  2n^{2}.\]

Proof.: For any given \(t\) and \(i j\), due to the independently drawn sample \(_{i}^{(t)}\), we have that \(_{i}^{(t)}\) is independent of \((_{t},_{j}^{(t)})\), and thus \(_{i}^{(t)}\) is independent of \((x_{i}^{(t)},x_{j}^{(t)},_{j}^{(t)})\). Hence, invoking Lemma A.8 and Assumption 1.1 yields

\[[ F(x_{i}^{(t)};_{i}^{(t)})- f_{i}( x_{i}^{(t)})x_{i}^{(t)}]=[ F(x_{i}^{(t)};_{i}^{(t)} )- f_{i}(x_{i}^{(t)})_{t}]=0,\] \[ F(x_{i}^{(t)};_{i}^{(t)})- f _{i}(x_{i}^{(t)}), F(x_{j}^{(t)};_{j}^{(t)})- f_{j}(x_{j}^{(t)} )=0.\]

Then, for any index set \(\{1,2,,n\}\), we have \(\|_{}^{}(^{(t)}- (^{(t)}))\|_{2}^{2}||^{2}\).

Notice that

\[\|(-^{} )^{k}(^{(t)}-(^{(t)})) \|_{F}^{2}= \|_{-1}{B-1}+1:n}(^{(t )}-(^{(t)}))\|_{2}^{2}\] \[+_{i=2}^{n}\|_{_{i,k}}(^{(t)}-(^{(t)}))\|_{2}^{2}.\]

Thus, we obtain the desired result by invoking Lemma A.1 and Corollary A.2 after taking expectation on both sides of the above relation:

\[\|(-^{} )^{j}(^{(t)}-(^{(t)})) \|_{F}^{2} 2(n--1}{B-1})^{2} 2n^{2}.\]Under Assumption 1.1 and the randomly selected samples, Lemma A.9 and Corollary A.10 below provide an initial estimation for the variance terms. The proof of Corollary A.10 is directly from the analysis in Appendix A.3.2 and Corollary A.4.

**Corollary A.10**.: _Under Assumption 1.1, we have for all \(t 0\) that_

\[_{k=1}^{d}\|(^{}}{n}-^{} )A_{k}((^{(t)},^{(t)})- (^{(t)}))\|_{2}^{2}(n-1)^{2}.\]

#### a.3.3 Proof of Lemma 3.2

Proof.: Notice that

\[}^{(t+1)}-}^{(t)}=-^{}^{(t)}=- ^{}[_{}^{(t)}+ {n}^{}^{(t)}]\] \[=-^{}_ {}^{(t)}-^{}^{(t) }=-(^{}}{n}-^{}) _{}^{(t)}-^{ }^{(t)}.\]

Multiplying \(^{}\) on both sides of equation (7), we have \(^{}^{(t)}=^{}^{(t)}\) for any integer \(t\). Thus, in light of equation (9), we have

\[}^{(t+1)}-}^{(t)}=- (^{}}{n}-^{})_{ }^{(t)}-^{}^{(t)}\] \[=-(^{}}{n}-^{ })_{m=1}^{\{t,d\}}_{m}^{(t-m)}- (^{}}{n}-^{}) ^{(t)}-^{}^{(t)}\] \[=-(^{}}{n}-^{ })_{m=1}^{\{t,d\}}_{m}(^{(t-m)}- (^{(t-m)}))\] \[-(^{}}{n}- ^{})_{m=1}^{\{t,d\}}_{m} (^{(t-m)})-^{}}{n}^{(t)}\] \[=-(^{}}{n}-^{ })_{m=1}^{\{t,d\}}_{m}(^{(t-m)}- (^{(t-m)}))\] \[-(^{}}{n}- ^{})(-^{ })^{t}(^{(0)})+( ^{}}{n}-^{})( ^{(t)})-^{}}{n}^{(t)}.\]

Hence, taking the F-norm and expectation on both sides, we have from Lemma A.5 that

\[\|}^{(t+1)}-}^{(t)}\|_{F }^{2} 5^{2}n\|_{m=1}^{\{t,d\}}(^{}}{n}-^{})_{m}(^{( t-m)}-(^{(t-m)}))\|_{F}^{2}\] \[+5^{2}n\|(^{}} {n}-^{})_{m=\{0,t-d\}}^{t-1}(- ^{})^{t-m-1}[( ^{(m+1)})-(^{(m)})]\|_{F}^{2}\] \[+5^{2}n\|(^{}} {n}-^{})(-^ {})^{t}(^{(0)})\|_{F}^{2}\] \[+5^{2}n\|^{}}{n} ((^{(t)})-^{(t)})\|_{F}^{ 2}+5^{2}n\|^{}(^{(t)}) \|_{F}^{2}.\] (10)Note that, invoking Lemma A.9 and Corollary A.10 yields

\[\|_{m=1}^{\{t,d\}}(^{ }}{n}-^{})_{m}(^{(t-m)}- (^{(t-m)}))\|_{F}^{2}\] \[=_{m=1}^{\{t,d\}}\|( ^{}}{n}-^{})_{m}(^{(t-m)}- (^{(t-m)}))\|_{F}^{2}\] \[ (n-1)^{2}.\]

From Assumption 1.2, Lemma A.6 and Lemma A.5, we have

\[\|(^{}}{n}-^{ })_{m=\{0,t-d\}}^{t-1}(-^{})^{t-m-1}[(^{(m+1)})- (^{(m)})]\|_{F}^{2}\] \[ d_{m=\{0,t-d\}}^{t-1}\|(^{}}{n}-^{})(- ^{})^{t-m-1}[(^{ (m+1)})-(^{(m)})]\|_{F}^{2}\] \[ ndL^{2}_{m=\{0,t-d\}}^{t-1}\| ^{(m+1)}-^{(m)}\|_{F}^{2}\] \[ ndL^{2}_{m=\{0,t-d\}}^{t-1}3(\| ^{(m+1)}-}^{(m+1)}\|_{F}^{2}+\| ^{(m)}-}^{(m)}\|_{F}^{2}+\| }^{(m+1)}-}^{(m)}\|_{F}^{2}).\]

Thus, summing over \(t\) in (10) from 0 to \(T\), combining all the inequalities above, and invoking Assumption 1.1 and Assumption 1.2, we have

\[_{t=0}^{T}\|}^{(t+1)}-}^{(t)}\|_{F}^{2} 5^{2}n(n-1)^{2}(T+1)+30^{2}n^{2}d^{2}L^{2} _{t=0}^{T}\|}^{(t)}\|_{F}^{2}\] \[+15^{2}n^{2}d^{2}L^{2}_{t=0}^{T}\| }^{(t+1)}-}^{(t)}\|_{F}^{2}\] \[+5^{2}n^{2}_{t=0}^{\{t,d-1\}}\| (^{(0)})\|_{F}^{2}+5^{2}n^{2}(T+1)\] \[+5^{2}n_{t=0}^{T}(2\|^{}(^{(t)})-^{} (}^{(t)})\|_{2}^{2}+2n^{2}\| ^{}(}^{(t)})\|_{2}^{2})\] (11) \[ 5^{2}n^{2}^{2}(T+1)+40^{2}n^{2}d^{2}L^{2} _{t=0}^{T}\|}^{(t)}\|_{F}^{2 }+15^{2}n^{2}d^{2}L^{2}_{t=0}^{T}\|}^{ (t+1)}-}^{(t)}\|_{F}^{2}\] \[+5^{2}n^{2}d\|(^{(0)}) \|_{F}^{2}+10^{2}n^{3}_{t=0}^{T}\| f(x_{1 }^{(t)})\|_{2}^{2}.\]

Since \(\), we have \(15^{2}n^{2}d^{2}L^{2}\), and the desired result follows. 

#### a.3.4 Proof of Lemma 3.3

Proof.: We show the upper bound for \(\|}^{(t)}\|_{F}^{2}\) by studying equation (8) and bound the F-norm of each term respectively. From Corollary A.2, we can change the power of \(-^{}\) to at most 

[MISSING_PAGE_EMPTY:21]

**Lemma A.11**.: _For any iteration number \(T\), we have_

\[_{t=0}^{T}\|_{1,t}\|_{F}^{2} 32n^{2}d^{4}(T+1)^{2}.\]

Proof.: To make the summation legal given \(d 2\), we need \(d-1 t-m-d\), which implies that \(m t+1-2d\). Then,

\[_{1,t}= _{m=0}^{t-2}_{j=\{1,t-m-d\}}^{\{t-m-1,d-1\}}( -^{})^{j}(-^{})^{t-m-1-j}\] \[[^{(m+1)}-(^{(m+1)})+ (^{(m)})-^{(m)}]\] \[= _{m=\{t+1-2d,0\}}^{t-2}_{j=\{1,t-m-d\}}^{\{t- m-1,d-1\}}(-^{})^{j}\] \[(-^{})^ {t-m-1-j}[^{(m+1)}-(^{(m+1)})+ (^{(m)})-^{(m)}].\]

Invoking Lemma A.5, Lemma 3.1 and Lemma A.9, we have

\[\|_{1,t}\|_{F}^{2}  2(d-1)^{2}_{m=\{t+1-2d,0\}}^{t-2}_{j=\{1,t-m- d\}}^{\{t-m-1,d-1\}}\|(- ^{})^{j}\|_{2}^{2}.\] \[\|(-^{} )^{t-m-1-j}[^{(m+1)}-(^{(m+1)}) +(^{(m)})-^{(m)}]\|_{F}^{2}\] \[ 2n(d-1)^{2}_{m=\{t+1-2d,0\}}^{t-1}_{j=\{1,t- m-d\}}^{\{t-m-1,d-1\}}8n^{2}\] \[ 32n^{2}d^{4}^{2}.\]

Summing over \(t\) from \(0\) to \(T\), we get the desired result. 

**Lemma A.12**.: _For any \(\), we have_

\[_{t=0}^{T}\|_{2,t}\|_{F}^{2}  52n^{2}d^{4}L^{2}_{t=0}^{T}\|X}^{(t)}\|_{F}^{2}+144^{2}n^{4}d^{4}(T+1)L^{2}^{2}\] \[+360^{2}n^{5}d^{4}L^{2}_{t=0}^{T}\| (}^{(t)})\|_{2}^{2}+360^ {2}n^{4}d^{5}L^{2}\|(^{(0)})\|_{F}^{2}.\]

Proof.: Similar to the proof of Lemma A.11, we have

Invoking Lemma A.5 and Assumption 1.2, we obtain

\[\|_{2,t}\|_{F}^{2}  4n^{2}d^{3}_{m=\{t+1-2d,0\}}^{t-1}[ \|(^{(m+1)})-(^{(m)})\|_{F }^{2}]\] \[ 4n^{2}d^{3}L^{2}_{m=\{t+1-2d,0\}}^{t-1} \|^{(m+1)}-}^{(m+1)}+}^{(m)}- ^{(m)}+}^{(m+1)}-}^{(m)}\|_{F}^ {2}\] \[ 24n^{2}d^{3}L^{2}_{m=\{t+1-2d,0\}}^{t} \|X}^{(t)}\|_{F}^{2}+12n^{2}d^{3}L^{2}_{m=\{t +1-2d,0\}}^{t-1}\|}^{(m+1)}-}^{( m)}\|_{F}^{2}.\]It follows by summing over \(t\) from \(0\) to \(T\) and applying Lemma 3.2 that

\[_{t=0}^{T}\|_{2,t}\|_{F}^{2} 48n^{2}d^{4}L ^{2}_{t=0}^{T}\|X}^{(t)}\|_{F}^{2}+24n^ {2}d^{4}L^{2}_{t=0}^{T}\|}^{(t+1)}-}^{(t)}\|_{F}^{2}\] \[(48n^{2}d^{4}L^{2}+1200^{2}n^{4}d^{6}L^{4} )_{t=0}^{T}\|X}^{(t)}\|_{F}^{2}+ 144^{2}n^{4}d^{4}(T+1)L^{2}^{2}\] \[+360^{2}n^{5}d^{4}L^{2}_{t=0}^{T} \| f(x_{1}^{(t)})\|_{2}^{2}+144^{2}n^{4}d^{5}L^{2} \|(^{(0)})\|_{F}^{2}.\]

Hence, under the condition that \(\), there holds \(1200^{2}n^{4}(d-1)^{6}L^{4} 4n^{2}(d-1)^{4}L^{2}\), which implies the desired result. 

**Lemma A.13**.: _For any \(T\), we have_

\[_{t=0}^{T}\|_{3,t}+_{0,t,2}\|_{F}^{2} d ^{2}n^{2}(T+1)^{2}.\]

Proof.: By definition, we have

\[_{3,t}+_{0,t,2}=_{j=1}^{\{t,d-1\}} (-^{})^{j} ^{}(^{(0)}-(^ {(0)}))+\] \[_{m=0}^{t-2}_{j=1}^{\{t-m-1,d-1\}}(- ^{})^{j}^{ }}{n}[^{(m+1)}-(^{(m+1)})+ (^{(m)})-^{(m)}]\] \[= _{m=\{t-d,0\}}^{t-1}(-^{})^{t-m}^{}}{n}[ ^{(m)}-(^{(m)})].\]

Thus, invoking Lemma A.5 and Lemma 3.1, we have

\[\|_{3,t}\|_{F}^{2} nd_{m=\{t-d,0\}}^{t-1} \|}{n}\|_{2}^{2}\|^{}( ^{(m+1)}-(^{(m+1)}))\|_{F}^{2} d ^{2}n^{2}^{2}.\]

After summing over \(t\) from \(0\) to \(T\), we get the desired result. 

**Lemma A.14**.: _For any \(T\), we have_

\[_{t=0}^{T}\|_{0,t,1}+_{0,t,3}\|_{F }^{2} 4n^{2}d^{3}^{2}+4n^{2}d^{3}\|(^ {(0)})\|_{F}^{2}.\]

Proof.: Note that

\[\|_{0,t,1}+_{0,t,3}\|_{F}^{2} 2\| _{0,t,1}\|_{F}^{2}+2\|_{0,t,3}\|_{F}^{2}.\]

We show the upper bounds for \(_{t=0}^{T}\|_{0,t,i}\|_{F}^{2}\), where \(i=1,3\) respectively. Based on Corollary A.2, Lemma A.5 and Lemma A.9, we have the following result:

\[\|_{0,t,1}\|_{F}^{2}=\|_{j=1}^{ \{t,d-1\}}(-^{})^{j} (-^{})^{t-j}( ^{(0)}-(^{(0)}))\|_{F}^{2}\] \[=\|_{j=\{1,t-d+1\}}^{\{t,d-1\}}( -^{})^{j}(- ^{})^{t-j}(^{(0)}- (^{(0)}))\|_{F}^{2}\] \[ nd_{j=\{1,t-d+1\}}^{\{t,d-1\}}\| (-^{})^{t-j}( ^{(0)}-(^{(0)}))\|_{F}^{2}.\]Then, recall that the summation is legal only when \(t 2(d-2)\). We have

\[_{t=0}^{T}\|_{0,t,1}\|_{F}^{2} _{t=0}^{\{T,2(d-2)\}}nd_{j=\{1,t-d+1\}}^{\{t,d-1\}} \|(-^{})^{t-j} (^{(0)}-(^{(0)}))\|_{F}^{2}\] \[ 2n^{2}d^{3}^{2}.\]

Similarly,

\[_{t=0}^{}\|_{0,t,3}\|_{F}^ {2}\] \[_{t=0}^{\{T,2(d-1)\}}d_{j=\{1,t-d+1\}}^{ \{t,d-1\}}\|(-^{} )^{j}\|_{2}^{2}\|(- ^{})^{t-j}\|_{2}^{2}\|( ^{(0)})\|_{F}^{2}\] \[ 2n^{2}d^{3}\|(^{(0)}) \|_{F}^{2}.\]

Combining the above upper bounds leads to the final result. 

**Lemma A.15**.: _For any \(T\), we have_

\[_{t=0}^{T}\|_{0,t,4}+_{4,t}\|_{F} ^{2} 2n^{2}d^{2}L^{2}_{t=0}^{T}\|X}^{(t)}\|_{F} ^{2}+2n^{3}d^{2}_{t=0}^{T}\|f(x_{1}^{(m)})\|_{2}^{2}.\]

Proof.: Note that

\[_{0,t,4}+_{4,t}=_{m=0}^{t-2}_{j=1}^{ \{t-m-1,d-1\}}(-^{} )^{j}^{}}{n}[( ^{(m+1)})-(^{(m)})]\] \[+_{j=1}^{\{t,d-1\}}(-^{})^{j}^{} (^{(0)})\] \[=_{m=\{t-d,0\}}^{t-1}(- ^{})^{t-m}^{}}{n} (^{(m)}),\]

where the last equality comes from extending the summation in the first line and telescoping the summation. Consequently, we have

\[_{0,t,4}+_{4,t}=_{m=\{t-d,0\}}^{t-1}( -^{})^{t-m}^{}}{n}((^{(m)})-( }^{(m)})+(}^{(m)})).\]

Then, taking the F-norm on both sides and invoking Lemma A.6, Lemma A.5 and Lemma 3.2 as before, we have

\[\|_{0,t,4}+_{4,t}\|_{F}^{2} dn _{m=\{t-d,0\}}^{t-1}(2\|^{}}{n} [(^{(m)})-(}^{( m)})]\|_{F}^{2}+2\|^{}}{n} (}^{(m)})\|_{F}^{2})\] \[ 2dn^{2}L^{2}_{m=\{t-d,0\}}^{t-1}\|X}^{ (m)}\|_{F}^{2}+2dn^{3}_{m=\{t-d,0\}}^{t-1}\| f(x_{1}^{(m)})\|_{ 2}^{2}.\]

Taking expectation on both sides and summing over \(t\) from \(0\) to \(T\), we get

\[_{t=0}^{T}\|_{0,t,4}+_{4,t}\|_{F} ^{2} 2n^{2}d^{2}L^{2}_{t=0}^{T}\|X}^{(t)}\| _{F}^{2}+2n^{3}d^{2}_{t=0}^{T}\| f(x_{1}^{(m)})\|_{2}^{2}.\]Back to equation (13), note that

\[\|X}^{(t)}\|_{F}^{2} 6\|( ^{}-^{})^{t}^{(0)} \|_{F}^{2}+6^{2}\|_{0,t,1}+_{0,t,3}\| _{F}^{2}\] \[+6^{2}\|_{1,t}\|_{F}^{2}+6 ^{2}\|_{2,t}\|_{F}^{2}+6^{2}\|_{3,t}+ _{0,t,2}\|_{F}^{2}+6^{2}\|_{0,t,4}+ _{4,t}\|_{F}^{2}.\]

Taking full expectation on both sides, summing over \(t\) from \(0\) to \(T\) and combining Lemma A.11 to Lemma A.14, we have

\[_{t=0}^{T}\|X}^{(t)}\|_{F }^{2} 6_{t=0}^{\{T,d-1\}}\|(^{ }-^{})^{t}^{(0)} \|_{F}^{2}+6^{2}_{t=0}^{T}\|_{1,t} \|_{F}^{2}+6^{2}_{t=0}^{T}\|_{2,t} \|_{F}^{2}\] \[+6^{2}_{t=0}^{T}\|_{3,t}+_{0,t,2}\|_{F}^{2}+6^{2}_{t=0}^{T}\|_{0,t,4}+_{4,t}\|_{F}^{2}+6^{2}_{ t=0}^{T}\|_{0,t,1}+_{0,t,3}\|_{F}^{2}\] \[ 6nd\|X}^{(0)}\|_{F}^{2}+192 ^{2}n^{2}d^{4}(T+1)^{2}+312^{2}n^{2}d^{4}L^{2}_{t=0}^{T }\|X}^{(t)}\|_{F}^{2}\] (14) \[+1000^{4}n^{4}d^{4}(T+1)L^{2}^{2}+2160^{ 4}n^{5}d^{4}L^{2}_{t=0}^{T}\| f(x_{1}^{(t)})\| _{2}^{2}\] \[+2160^{4}n^{4}d^{5}L^{2}\|( ^{(0)})\|_{F}^{2}+6^{2}n^{2}d^{2}(T+1)^{2}+24 ^{2}n^{2}d^{3}^{2}\] \[+24^{2}n^{2}d^{3}\|(^ {(0)})\|_{F}^{2}+12^{2}n^{2}d^{2}L^{2}_{t=0}^{T} \|X}^{(t)}\|_{F}^{2}+12^{2}n^{3}d^{2}_{t=0 }^{T}\| f(x_{1}^{(t)})\|_{2}^{2}.\]

For \(L}\), which implies that \(312^{2}n^{2}d^{4}L^{2}+12^{2}n^{2}d^{2}L^{2}\), we can simplify equation (14) as follows:

\[_{t=0}^{T}\|X}^{(t)}\|_{F}^{2} 300 ^{2}n^{2}d^{4}(T+1)^{2}+20^{2}n^{3}d^{2}_{t=0}^{T} \| f(x_{1}^{(t)})\|_{2}^{2}\] \[+6nd\|X}^{(0)}\|_{F}^{2}+4 0^{2}n^{2}d^{3}\|(^{(0)})\|_{F}^{2},\]

which implies the desired result.

#### a.3.5 Proof of Lemma 3.4

Proof.: Notice that

\[x_{1}^{(t)}=x_{1}^{(t-1)}- y_{1}^{(t-1)}=x_{1}^{(t-1)}-_{i _{1,1}}y_{1}^{(t-2)}- g_{1}(x_{1}^{(t-1)},_{1}^{(t-1)})+  g_{1}(x_{1}^{(t-2)},_{1}^{(t-2)}).\]

Therefore, \(x_{1}^{(t)}\) does not depend on \(_{i}^{t-1}\) for \(i 1\). We iterate the above procedure to get

\[x_{1}^{(t)}= x_{1}^{(t-1)}- g_{1}(x_{1}^{(t-1)},_{1}^{(t-1)})+ g _{1}(x_{1}^{(t-2)},_{1}^{(t-2)})\] \[-_{i_{1,2}}y_{i}^{(t-3)}-_{i _{1,1}}g_{i}(x_{1}^{(t-2)},_{1}^{(t-2)})+_{i _{1,1}}g_{i}(x_{1}^{(t-3)},_{1}^{(t-3)}).\]

Similar to \(x_{1}^{(t)}\), we know that \(x_{1}^{(t-1)}\) does not depend on \(_{i}^{(t-2)}\), \(i 1\). Hence \(x_{1}^{(t)}\) is independent with \(_{i}^{(t-2)}\) for \(i_{1,1}\). By iterating the procedure, we conclude that \(x_{1}^{(t)}\) is independent with \(_{i}^{(t-k)}\) for \(i_{1,k}\).

Consequently, by choosing \(Z=\{_{i}^{(t-k)},i_{1,k},i_{1,k-1}\}\), \(X=x_{1}^{(t)}\), \(Y=\{x_{i}^{(t-k)},i[n]\}\) in Lemma A.8, \(Z\) is independent with \((X,Y)\), we get

\[ f(x_{1}^{(t)}),_{_{1,k}/ _{1,k-1}}(^{(t-k)}-(^{(t-k) }))=0.\]Then, invoking Corollary A.4, we have

\[_{m=1}^{\{t,d\}} f(x_{1}^{(t)}), (^{}}{n}-^{})_{m}( ^{(t-m)}-(^{(t-m)}))\] \[=_{m=1}^{\{t,d\}} f(x_{1}^{(t )}),_{_{1,m}/_{1,m-1}}(^{(t-m)} -(^{(t-m)}))=0.\]

#### a.3.6 Proof of Lemma 3.5

Proof.: By Assumption 1.2, the function \(f:=_{i=1}^{n}f_{i}\) is \(L\)-smooth. Then,

\[f(x_{1}^{(t+1)})f(x_{1}^{(t)})+ f (x_{1}^{(t)}),x_{1}^{(t+1)}-x_{1}^{(t)}+\|x_{1}^{( t+1)}-x_{1}^{(t)}\|_{2}^{2}.\] (15)

For the last term, we have

\[\|x_{1}^{(t+1)}-x_{1}^{(t)}\|_{2}^{2}=\| {1}{n}^{}(^{(t+1)}-^{(t)})\|_{2} ^{2}\] \[= \|^{} (^{(t+1)}-^{(t)})\|_{F}^{2}= \|}^{(t+1)}-}^{(t)}\|_{F}^{2}.\]

For the second last term, we have

\[ f(x_{1}^{(t)}),x_{1}^{(t+1)}-x_{1}^{(t)} = f(x_{1}^{(t)}),^{}}{n} (^{(t+1)}-^{(t)})=  f(x_{1}^{(t)}),-^{}}{n}^{(t)}\] (16) \[=  f(x_{1}^{(t)}),-(^{}}{n}-^{})^{(t)}+  f(x_{1}^{(t)}),-^{}^{(t )}.\]

We now bound the two terms in the above equation. Firstly,

\[ f(x_{1}^{(t)}),-(^{}} {n}-^{})^{(t)}=  f(x_{1}^{(t)}),-(^{}}{n}-^{} )_{}^{(t)}.\]

Recall that by equation (9),

\[ f(x_{1}^{(t)}),-(^{}}{n}-^{})_{}^{(t)}\] (17) \[=  f(x_{1}^{(t)}),-(^{}}{n}-^{})_{m=1}^{\{t,d\}}_{m}^{(t-m)}-(^{}}{n}-^{} )^{(t)}\] \[= - f(x_{1}^{(t)}),(^{}}{n}-^{})(^{(t)}- (^{(t)}))\] \[- f(x_{1}^{(t)}),(^{}}{n}-^{})_{m=1}^{\{t,d\}}_{m}(^{(t-m)}).\]

We bound the four terms above one by one. For the first term,

\[ f(x_{1}^{(t)}),-(^{}}{n}- ^{})(^{(t)}-(^{(t) }))=0.\]For the second one, invoking Lemma 3.4, we have

\[ f(x_{1}^{(t)}),(^{ }}{n}-^{})_{m=1}^{\{t,d\}}_{m}( ^{(t-m)}-(^{(t-m)}))\] \[=_{m=1}^{\{t,d\}} f(x_{1}^{(t )}),(^{}}{n}-^{})_{m} (^{(t-m)}-(^{(t-m)})) =0.\]

For the last two terms in (17), we have as:

\[- f(x_{1}^{(t)}),(^{}}{n}-^{})(^{(t)}) - f(x_{1}^{(t)}),(^{}}{n}-^{})_{m=1}^{\{t,d\}}_{m} (^{(t-m)})\] \[=_{m=1}^{\{t,d\}} f(x_{1}^{(t )}),-(^{}}{n}-^{})(-^{})^{m-1}(( ^{(t-m+1)})-(^{(t-m)})).\]

By the Cauchy-Schwartz inequality, we have

\[_{m=1}^{\{t,d\}} f(x_{1}^{(t )}),-(^{}}{n}-^{})(-^{})^{m-1}( (^{(t-m+1)})-(^{(t-m)}))\] \[ _{m=1}^{\{t,d\}}\{\|  f(x_{1}^{(t)})\|_{2}^{2}+\|( {^{}}{n}-^{})(- ^{})^{m-1}\|_{2}^{2}\|(^{(t-m+1)})-(^{(t-m)})\|_{F}^{2}\}\] \[ \| f(x_{1}^{(t)})\|_{2}^{2} +}{2}_{m=1}^{\{t,d\}}\|^{(t-m+1)}- ^{(t-m)}\|_{F}^{2}\] \[ \| f(x_{1}^{(t)})\|_{2}^{2} +}{2}_{m=1}^{\{t,d\}}(\|}^{(t-m+1)}\|_{F}^{2}+\|}^{(t -m)}\|_{F}^{2}+\|}^{(t-m+1)}-}^{(t-m )}\|_{F}^{2}).\]

Thus, combining the above inequalities together yields

\[_{t=0}^{T} f(x_{1}^{(t)}),-( ^{}}{n}-^{})}^{(t)}_{t=0}^{T}\| f(x_{1}^{(t )})\|_{2}^{2}\] \[+3 d^{2}L^{2}_{t=0}^{T}\| }^{(t)}\|_{F}^{2}+3 d^{2}L^{2}_{t=0}^ {T}\|}^{(t+1)}-}^{(t)}\|_{F }^{2}.\]

Secondly, for the second term in (16),

\[ f(x_{1}^{(t)}),-^{} ^{(t)}= f(x_{1}^{(t)}),-^{}^{(t)}= f(x_{1}^{(t)}),- ^{}(^{(t)})\] \[= -n\| f(x_{1}^{(t)})\|_{2}^{2}-n  f(x_{1}^{(t)}),^{} (^{(t)})-^{}( }^{(t)})\] \[ -n\| f(x_{1}^{(t)})\|_{2}^{2}+\| f(x_{1}^{(t)})\|_{2}^{2}+2 L^{2}\| }^{(t)}\|_{F}^{2}\] \[ -n\| f(x_{1}^{(t)})\|_{2}^{2}+\| f(x_{1}^{(t)})\|_{2}^{2}+2 L^{2}\| }^{(t)}\|_{F}^{2}.\]

Summing over \(t\) from \(0\) to \(T\), we have

\[_{t=0}^{T} f(x_{1}^{(t)}),-^{} ^{(t)}-_{t=0}^{T}\|  f(x_{1}^{(t)})\|_{2}^{2}+2 L^{2}_{t=0}^{T} \|}^{(t)}\|_{F}^{2}.\]

It yields by summing over \(t\) from \(0\) to \(T\) on both sides of equation (15) that

\[f(x_{1}^{(T+1)})-f(x_{1}^{0})_{t=0}^{T}  f(x_{1}^{(t)}),x_{1}^{(t+1)}-x_{1}^{(t)}+_{t=0}^{T}\|}^{(t+1)}-}^{(t)}\|_{F}^ {2}\] \[_{t=0}^{T} f(x_{1}^{(t)}),- ^{}^{(t)}+_{t=0}^{T}  f(x_{1}^{(t)}),-(^{}}{n}-^{} )=f(x^{0})-f^{*}\), we have

\[-_{f}\] \[+5 d^{2}L^{2}_{t=0}^{T}\| ^{(t)}}\|_{F}^{2}+3 d^{2}L^{2}_{t= 0}^{T}\|}^{(t+1)}-}^{(t)}\| _{F}^{2}.\]

Invoking Lemma 3.2, we have for \(L}()\) that

\[-_{f} n(45^{2}n^{2}d^{2}L^{2}+8 nL- )_{t=0}^{T}\| f(x_{1}^{(t)})\|_{2}^{2}\] \[+(150^{3}n^{2}d^{4}L^{4}+25^{2}nd^{2}L^{3 }+5 d^{2}L^{2})_{t=0}^{T}\| ^{(t)}}\|_{F}^{2}\] \[+3^{2}n(T+1)L^{2}+18^{3}n^{2}d^{2}L^{2}( T+1)^{2}\] \[+(18^{3}n^{2}d^{3}L^{2}+3^{2}nL) \|(^{(0)})\|_{F}^{2},\]

where it holds that \(150^{3}n^{2}d^{4}L^{4}+25^{2}nd^{2}L^{3}+5 d^{2}L^{2} 6  d^{2}L^{2}\).

Invoking Lemma 3.3, we have for \(L}(L})\) that

\[-_{f} n(120^{2}n^{2}d^{4}L^{2}+45^{2}n^{2}d^{2}L ^{2}+8 nL-)_{t=0}^{T}\| f(x_{ 1}^{(t)})\|_{2}^{2}\] \[+3^{2}n(T+1)L^{2}+18^{3}n^{2}d^{2}L^{2}( T+1)^{2}+1800^{3}n^{2}d^{6}(T+1)^{2}L^{2}\] \[+(240^{3}n^{2}d^{5}L^{2}+18^{3}n^{2}d^{3}L ^{2}+3^{2}nL)\|(^{(0)})\|_{F }^{2}\] \[+36 nd^{3}L^{2}\|^ {(0)}}\|_{F}^{2}.\]

Thus, for \(L}\), we have

\[120^{2}n^{2}d^{4}L^{2}+45^{2}n^{2}d^{2}L^{2}+8 nL--\]

\[ n(240^{2}nd^{5}L^{2}+18^{2}nd^{3}L^{2}+3 L)  7^{2}nd^{2}L.\]

After re-arranging the terms, we conclude that

\[_{t=0}^{T}\| f(x_{1}^{(t)}) \|_{2}^{2}}{ n(T+1)}+24^{2}L+2000 0^{2}nd^{6}^{2}L^{2}\] \[+L^{2}\|^ {(0)}}\|_{F}^{2}}{T+1}+L\|( ^{(0)})\|_{F}^{2}}{T+1}.\]

#### a.3.7 Proof of Lemma 3.7

Let \(x^{*}=_{x}f(x)\). We start with analyzing the behavior of \(\|x_{1}^{(t)}-x^{*}\|^{2}\) after obtaining Lemma 3.4. It holds that

\[\|x_{1}^{(t+1)}-x^{*}\|^{2}=\|x_{1}^{(t)}-x^{*}\|^{2}+2  x_{1}^{(t)}-x^{*},x_{1}^{(t+1)}-x_{1}^{(t)}+\|x _{1}^{(t+1)}-x_{1}^{(t)}\|^{2}.\] (18)

To deal with the critical inner product, similar to the decomposition in Equation (16), we have, by replacing \( f(x_{1}^{(t)})\) with \(x_{1}^{(t)}-x^{*}\) in Equation (17), and invoking Lemma 3.4 as we have done in Lemma 3.5, that

\[ x_{1}^{(t)}-x^{*},x_{1}^{(t+1)}-x_{1}^{(t)}\] (19) \[= - x_{1}^{(t)}-x^{*},(^{ }}{n}-^{})^{(t)}} - x_{1}^{(t)}-x^{*},^{}^ {(t)}.\]and

\[- x_{1}^{(t)}-x^{*},(^{}}{n}-^{})_{}^{(t)}\] (20) \[= - x_{1}^{(t)}-x^{*},(^{}}{n}-^{})(^{(t)})\] \[- x_{1}^{(t)}-x^{*},(^{}}{n}-^{})_{m=1}^{\{t,d\}}_{m}(^{(t)})\] \[ \|x_{1}^{(t)}-x^{*}\|^{ 2}+}{}_{m=1}^{\{t,d\}}(\| _{}^{t-m+1}\|^{2}+\| _{}^{t-m}\|^{2}+\|}^{t-m+1}- }^{t-m}\|^{2}).\]

Notice that, first by strong convexity of \(f\) (Assumption 1.3) and then by \(L\)-smoothness (Assumption 1.2), there holds

\[- x_{1}^{(t)}-x^{*}, f(x_{1}^{(t)})  f(x^{*})-f(x_{1}^{(t)})-\|x_{1}^{(t)}-x^{*}\|^{2}\] (21) \[ -\| f(x_{1}^{(t)})\|^{2}- {2}\|x_{1}^{(t)}-x^{*}\|^{2}.\]

Then,

\[- x_{1}^{(t)}-x^{*},^{ }^{(t)}=- x_{1}^{(t)}-x^{*},^{}(^{(t)})\] (22) \[= -n x_{1}^{(t)}-x^{*}, f(x_{1}^ {(t)})- x_{1}^{(t)}-x^{*}, ^{}(^{(t)})-^{}( }^{(t)})\] \[ -\|x_{1}^{(t)}-x^{*}\|^{ 2}-\| f(x_{1}^{(t)})\|^{2}+\|x_{1}^{(t)}-x^{*}\|^{2}+}{} \|_{}^{(t)}\|^{2}.\]

Thus, plugging the above results into Equation (18), with \(:=L/\) as the conditional number, it holds that

\[\|x_{1}^{(t+1)}-x^{*}\|^{2}(1- {n}{4})\|x_{1}^{(t)}-x^{*}\|^{2}-\| f(x_{1}^{(t)})\|^{2}+ \|}^{(t+1)}-}^{(t)}\|^ {2}_{F}\] (23)

We derive the convergence result by several standard steps as follows.

**Step 1**. Unwinding the above recursion, it follows by \( 1- 1\) for \( L}\) that

\[\|x_{1}^{(T)}-x^{*}\|^{2}(1-)^{T}\|x_{1}^{(0)}-x^{*}\|^{2}-_{t=0}^{T}\| f(x_{1}^{(t)})\|^{2}\] (24) \[+(+6d^{2} L)_{t=0}^{T }(1-)^{T-t}\|} ^{(t+1)}-}^{(t)}\|^{2}_{F}\] \[+60d^{2} L_{t=0}^{T}(1-)^{T-t}\|_{}^{t} \|^{2}_{F}.\]

**Step 2**. To refine Lemma 3.2, we start with Equation (11) multiplied by the coefficient \((1-)^{T-t}\) before summing over \(t\) in Equation (10) from \(0\) to \(T\). Then, we have, for \( L}\) (\( 1- 1\) for \( L}\)), that

\[_{t=0}^{T} (1-)^{T-t}\|}^{(t+1)}-}^{(t)}\|^{2}_{F} 6^{2}n^{2}^{2}(T+1)+50 ^{2}n^{2}d^{2}L^{2}_{t=0}^{T}(1-)^{T-t} \|_{}^{(t)}\|^{2}_{F}\] (25) \[+6^{2}n^{2}_{t=0}^{d}(1- )^{T-t}\|(^{(0)})\|^{2}_{F}+15^ {2}n^{3}_{t=0}^{T}\| f(x_{1}^{(t)})\|^{2}_{2}.\]where we get the result which only modifies the coefficient of the term \(\|(^{(0)})\|_{F}^{2}\).

Implementing the above result, we have, for \(}()\),

\[\|x_{1}^{(T)}-x^{*}\|^{2}(1-)^{T}\|x_{1}^{(0)}-x^{*}\|^{2}\] \[+(-+15^{2}n^{2}+90^{3}n^ {3}d^{2} L)_{t=0}^{T}\| f(x_{1}^{(t)}) \|^{2}\] \[+6^{2}n^{2}(T+1)+36^{3}n^{2}d^ {2} L^{2}(T+1)\] \[+(60 d^{2} L+50^{2}nd^{2}L^{2}+300 ^{3}n^{2}d^{4} L^{3})_{t=0}^{T}(1-)^{T-t}\|X}^{t}\|_{F}^{2}\] \[+(6^{2}nd+36^{3}n^{2}d^{3} L) (1-)^{T-d}\|(^{( 0)})\|.\]

**Step 3**. Similarly, we refine Lemma 3.3 as follows. By multiplying \((1-)^{T-t}\) before summing over \(t\) in Equation (14), we have

\[_{t=0}^{T}(1-)^{T-t}\| X}^{(t)}\|_{F}^{2} 300^{2}n^{2}d^{4}(T+1)^{ 2}+20^{2}n^{3}d^{2}_{t=0}^{T}\| f(x_{1}^{(t)})\|_{2 }^{2}\] \[+6nd\|X}^{(0)}\|_{F}^{2}+40 ^{2}n^{2}d^{3}(1-)^{T-d}\| (^{(0)})\|_{F}^{2},\]

Implementing the above result, we have for \(}\) that

\[60 d^{2} L+50^{2}nd^{2}L^{2}+300^{3}n^{2}d^{4} L ^{3} 70 d^{2} L,\]

and

\[\|x_{1}^{(T)}-x^{*}\|^{2}(1-)^{T}\|x_{1}^{(0)}-x^{*}\|^{2}\] \[+6^{2}n^{2}(T+1)+36^{3}n^{2}d^ {2} L^{2}(T+1)+21000^{3}n^{2}d^{6} L ^{2}(T+1)\] \[+(6^{2}nd+36^{3}n^{2}d^{3} L+2800 ^{3}n^{2}d^{5} L)(1-)^{T-d} \|(^{(0)})\|+420^{3}n^{2}d^{3}  L\|X}^{(0)}\|_{F}^{2}.\]

**Step 4**. Note that the coefficient of the term \(_{t=0}^{T}\| f(x_{1}^{(t)})\|^{2}\) is smaller than \(0\) for \(}\), derived as follows:

\[-+15^{2}n^{2}+90^{3}n^{3}d^{2}  L+1400^{3}n^{3}d^{4} L\] \[= (-1+30 nL+180^{2}n^{2}d^{2}  L^{2}+2800^{2}nd^{4} L)\] \[ (-1++}+ })-<0.\]

Thus, it holds that

\[\|x_{1}^{(T)}-x^{*}\|^{2}(1-)^{T}\|x_{1}^{(0)}-x^{*}\|^{2}\] \[+7^{2}n^{2}(T+1)+21000^{3}n^{2} d^{6} L^{2}(T+1)\] \[+80^{2}nd^{3}(1-)^{T-d }\|(^{(0)})\|+420^{3}n^{2}d^{3}  L\|X}^{(0)}\|_{F}^{2}.\]

### Proof of the Convergence Results

#### a.4.1 Proof of Theorem 2.1

Invoking Lemma 3.5, with identical initial values \(x_{i}^{(0)}\) that implies \(\|X}^{(0)}\|_{F}^{2}=0\), we have

\[_{t=0}^{T}\| f(x_{1}^{(t)})\|_{2}^{2 }}{ n(T+1)}+24^{2}L+2 10^{4} ^{2}nd^{6}^{2}L^{2}+L\|( ^{(0)})\|_{F}^{2}}{T+1}.\]

Referring to Lemma 26 in , as stated in Lemma A.7, by taking \(A=}{n}\), \(B=24^{2}L\), \(C=20000nd^{6}^{2}L^{2}\) and \(=100nd^{3}L\), when considering \(=\{(}{3^{2}Ln(T+1)})^{}, (}{1500n^{2}d^{6}^{2}L^{2}(T+1)})^{},L}\}\), we have

\[_{t=0}^{T}\| f(x_{1}^{(t)})\|_{2}^ {2}^{2}}L}{}+ (^{2}L^{2}_{f}^{2})^{}}{((T+1) )^{}}+L_{f}}{T+1}+(^{(0)})\|_{F}^{2}}{n(T+1)}.\]

#### a.4.2 Proof of Theorem 2.4

Invoking Lemma 3.7, with identical values \(x_{i}^{(0)}\) that implies \(\|X}^{(0)}\|_{F}^{2}=0\), we have

\[\|x_{1}^{(T)}-x^{*}\|^{2}(1-)^{T}\|x_{1}^{(0)}-x^{*}\|^{2}\] \[+7^{2}n^{2}(T+1)+21000^{3}n^{2 }d^{6} L^{2}(T+1)\] \[+80^{2}nd^{3}(1-)^{T-d} \|(^{(0)})\|.\]

Considering \(=\{ L},)}{n(T+ 1)}\}\), for \(T 2d\) we get that

\[(1-)^{T} \{(1-^{2}})^{T},( 1-)}{T+1})^{T}\}\] \[ \{(-^{2}}),}\},\]

and

\[(1-)^{T-d} \{(1-^{2}})^{T/2}, (1-)}{T+1})^{T/2}\}\] \[ \{(-^{2}}),}\},\]

where we use the fact \((1-)^{x} e^{-1}\) and \(1-x(-x)\) for any \(x_{+}\). Then,

\[\|x_{1}^{(T)}-x^{*}\|^{2}(n(T+1)^{2})}{n(T+1)^{2}}+ ^{2}^{2}((n(T+1)^{2}))^{2}}{n(T+1)^{2} ^{2}}\] \[+\{(-^{2}}),}\}(\|x_{1}^{(0)}-x^{*}\|^{2}+}\|(^{(0)})\|_{F}^{2}).\]

## Appendix B Additional Experiments

For the problem of training a CNN on the MNIST dataset, we have further compared the real-time performance of BTPP with other representative methods. The experiments are conducted on a server equipped with eight Nvidia RTX 3090 GPUs and two Intel Xeon Gold 4310 CPUs, where thecommunication between GPUs follows the topology requirement of each algorithm. We measure the running time including GPU computation and communication for 13,000 iterations. The experimental settings are consistent with those described in Section 4.2. From Figure 4, BTPP outperforms the other algorithms concerning the running time. Additionally, we evaluate BTPP with various branch sizes \(B\), concluding that for relatively small values of \(n\), a branch size of \(B=2\) is most effective.

Furthermore, we consider training VGG13 on the CIFAR10 dataset, with \(n=8\) and a batch size of 16. The learning rate and topology configurations are consistent with those described in Section 4.2. Additionally, the case of BTPP with \(B=8\) is equivalent to DSGD in a fully connected setting, meaning that they produce identical outputs when using the same random seed. Figure 5 and Figure 6 illustrate that BTPP beats competing algorithms in terms of the convergence rate (against iteration number) and running time. Moreover, a branch size of \(B=2\) is optimal.

We further demonstrate that the performance of BTPP can be improved by incorporating a momentum term (with momentum parameter set to 0.9) when data heterogeneity exists or by removing the data heterogeneity, which involves randomly assigning samples to each agent; see Figure 7 and Figure 8.

Figure 4: Real-time performance of BTPP (with different branch size \(B\)) compared with related methods when training CNN over MNIST.

Figure 5: Performance of BTPP (with different branch size B) compared with related methods for training VGG13 over CIFAR10.

### NeurIPS Paper Checklist

1. **Claims** Question: Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope? Answer: [Yes] Justification: Our paper meticulously delineates its primary contributions in both the abstract (lines 8-9) and the introduction (subsection 1.2, lines 105-121). Guidelines: * The answer NA means that the abstract and introduction do not include the claims made in the paper.

Figure 8: Performance of BTPP with branch size \(B=2\) under various configurations when training VGG13 over CIFAR10.

Figure 6: Real-time performance of BTPP (with different branch size \(B\)) compared with related methods when training VGG13 over CIFAR10.

Figure 7: Performance of BTPP with branch size \(B=2\) under various configurations when training CNN over MNIST.

* The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.
* The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.
* It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper.
2. **Limitations** Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] Justification: At the end of section 1.1, lines 100-104. Guidelines: * The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper. * The authors are encouraged to create a separate "Limitations" section in their paper. * The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be. * The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated. * The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon. * The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size. * If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness. * While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren't acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations.
3. **Theory Assumptions and Proofs** Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? Answer: [Yes] Justification: The assumptions are in subsection 1.3, lines 129-132. The proofs of all theoretical results are in the Appendix and subsection 2.1. Guidelines: * The answer NA means that the paper does not include theoretical results. * All the theorems, formulas, and proofs in the paper should be numbered and cross-referenced. * All assumptions should be clearly stated or referenced in the statement of any theorems. * The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition. ** Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.
* Theorems and Lemmas that the proof relies upon should be properly referenced.
4. **Experimental Result Reproducibility** Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? Answer: [Yes] Justification: We present the experiment details in section 4 and upload our code in the link shown in the abstract. Guidelines: * The answer NA means that the paper does not include experiments. * If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not. * If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable. * Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed. * While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example 1. If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. 2. If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. 3. If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). 4. We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results.
5. **Open access to data and code** Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? Answer: [Yes] Justification: We provide our code with the link shown in lines 10-11. Guidelines: * The answer NA means that paper does not include experiments requiring code. * Please see the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details.

* While we encourage the release of code and data, we understand that this might not be possible, so "No" is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).
* The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details.
* The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.
* The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.
* At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).
* Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
6. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: We provide all the experimental details and settings in Section 4 and our code link. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material.
7. **Experiment Statistical Significance** Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? Answer: [No] Justification: We have repeated some experiments with different seeds and reported the averaged performance. See Section 4 for details. Guidelines: * The answer NA means that the paper does not include experiments. * The authors should answer "Yes" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. * The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions). * The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.) * The assumptions made should be given (e.g., Normally distributed errors). * It should be clear whether the error bar is the standard deviation or the standard error of the mean. * It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis of Normality of errors is not verified.

* For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).
* If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text.
8. **Experiments Compute Resources** Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? Answer: [Yes] Justification: See line 255 for reference. Guidelines: * The answer NA means that the paper does not include experiments. * The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage. * The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute. * The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn't make it into the paper).
9. **Code Of Ethics** Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? Answer: [Yes] Justification: The research conducted in the paper conforms, in every respect, with the NeurIPS Code of Ethics. Guidelines: * The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics. * If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics. * The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction).
10. **Broader Impacts** Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? Answer: [NA] Justification: There is no societal impact of the work performed. Guidelines: * The answer NA means that there is no societal impact of the work performed. * If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact. * Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations. * The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.

* The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.
* If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML).
11. **Safeguards** Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? Answer: [NA] Justification: The paper poses no such risks. Guidelines: * The answer NA means that the paper poses no such risks. * Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters. * Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images. * We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort.
12. **Licensees for existing assets** Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? Answer: [Yes] Justification: We have cited the original paper that produced the code package or dataset. Guidelines: * The answer NA means that the paper does not use existing assets. * The authors should cite the original paper that produced the code package or dataset. * The authors should state which version of the asset is used and, if possible, include a URL. * The name of the license (e.g., CC-BY 4.0) should be included for each asset. * For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided. * If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset. * For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided. * If this information is not available online, the authors are encouraged to reach out to the asset's creators.
13. **New Assets** Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? Answer:[NA] Justification: The paper does not release new assets.

Guidelines:

* The answer NA means that the paper does not release new assets.
* Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.
* The paper should discuss whether and how consent was obtained from people whose asset is used.
* At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file.

14. **Crowdsourcing and Research with Human Subjects** Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? Answer: [NA] Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines:

* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.
* According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector.

15. **Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects** Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? Answer: [NA] Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines:

* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.
* We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.
* For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review.