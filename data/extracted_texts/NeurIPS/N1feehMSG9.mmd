# Proportional Response: Contextual Bandits for Simple and Cumulative Regret Minimization

Sanath Kumar Krishnamurthy

Management Science and Engineering

Stanford University

sanathsk@stanford.edu

&Ruohan Zhan

Industrial Engineering and Decision Analytics

Hong Kong University of Science and Technology

rhzhan@ust.hk

&Susan Athey

Graduate School of Business

Stanford University

athey@stanford.edu

&Emma Brunskill

Computer Science Department

Stanford University

ebrun@cs.stanford.edu

###### Abstract

In many applications, e.g. in healthcare and e-commerce, the goal of a contextual bandit may be to learn an optimal treatment assignment policy at the end of the experiment. That is, to minimize simple regret. However, this objective remains understudied. We propose a new family of computationally efficient bandit algorithms for the stochastic contextual bandit setting, where a tuning parameter determines the weight placed on cumulative regret minimization (where we establish near-optimal minimax guarantees) versus simple regret minimization (where we establish state-of-the-art guarantees). Our algorithms work with any function class, are robust to model misspecification, and can be used in continuous arm settings. This flexibility comes from constructing and relying on "conformal arm sets" (CASs). CASs provide a set of arms for every context, encompassing the context-specific optimal arm with a certain probability across the context distribution. Our positive results on simple and cumulative regret guarantees are contrasted with a negative result, which shows that no algorithm can achieve instance-dependent simple regret guarantees while simultaneously achieving minimax optimal cumulative regret guarantees.

## 1 Introduction

Learning and deploying personalized treatment assignment policies is crucial across domains such as healthcare and e-commerce . Traditional randomized control trials (RCTs), while foundational for policy learning , can be inefficient and costly . This motivates the study of adaptive sequential experimentation algorithms for the stochastic contextual bandit (CB) settings. The algorithm interacts with a finite sequence of users drawn _stochastically_ from a fixed but unknown distribution. At each round, the algorithm receives a _context_ (a user's feature vector), selects an action, and gets a corresponding reward. At the end of this adaptive experiment, the algorithm outputs a learned policy (mapping between contexts and actions).

Our algorithms are designed with the dual objectives of minimizing _simple regret_ and _cumulative regret_. Simple regret quantifies the difference between the expected rewards achieved by the optimal policy and the policy learned at the conclusion of the experimental process. In contrast, cumulative regret encapsulates the summation of differences between the expected rewards generated by theoptimal policy and the exploration policies employed at each sequential round of decision-making.1 Although there are many settings where simple regret is an important consideration, the majority of research in the contextual bandit field has focused on the minimization of cumulative regret. To the best of our knowledge, there is no general-purpose computationally efficient algorithm for pure exploration objectives like simple regret minimization in the contextual bandit setting. Further, there has been relatively little work so far into algorithms that explore the trade-off between multiple objectives like cumulative regret and simple regret (though see  for studies that address this empirically or juxtapose minimizing cumulative regret with estimating treatment effects or arm parameters). Our work seeks to address these gaps. We show that there is a trade-off between simple and cumulative regret minimization (formalized later in a lower-bound result). To navigate this trade-off, we proposes a new algorithm called Risk Adjusted Proportional Response (RAPR) with a tuning parameter \([1,K]\), which governs the weight placed on the two objectives.2 The algorithm is general-purpose (in that it can address any user-specified reward and policy classes), ensures near-optimal guarantees, and is also computationally efficient.

**Types of guarantees.** In our analysis, we consider two different types of bounds on simple and cumulative regret, worst-case and instance-dependent guarantees. Here instance-dependent guarantees refer to bounds that surpass worst-case rates by exploiting instances with large gaps between the conditional expected rewards of the optimal and sub-optimal arms. Recent work by  has shown that it is not possible for contextual algorithms to have instance-dependent guarantees on cumulative regret (without suffering an exponential dependence on model class complexity); the authors instead develop algorithms that achieve minimax optimal (worst case optimal) cumulative regret guarantees (with square-root dependence on model class complexity).  developed the first general-purpose contextual bandit algorithm for pure exploration, and their algorithm achieved instance-dependent guarantees. They also show that instance-dependent best policy identification guarantees must come at the cost of worse than minimax optimal cumulative regret (discussed in detail later). We show a similar lower bound on cumulative regret for algorithms that achieve better instance-dependent simple regret guarantees, and propose the first family of algorithms that flexibly navigate such trade-offs.

**Overview of our guarantees.** The simple regret guarantees of RAPR are never worse than the minimax optimal rates (Theorem 2). Depending on the instance, RAPR achieves simple regret guarantees that are up to \(O(1/)\) times smaller compared to minimax optimal rates (Theorem 2). This improvement factor of \(O(1/)\) over minimax optimal rates is asymptotically achieved for instances where _realizability_ holds (the reward model class is well specified) and the gap between the best and second best arm in terms of conditional expected reward is at least \(>0\) at every context (best-case instance in Theorem 2). RAPR provides these instance-dependent guarantees without the knowledge of any instance information. Unfortunately, the corresponding cumulative regret for the above instances is a factor of \(O()\) times larger compared to minimax optimal rates (Theorem 1). The cumulative regret guarantees of our algorithm only degrade relative to the minimax optimal rate if the instance allows for better simple regret guarantees. Our lower bound (Theorem 3) considers the instances described above with \(=0.24\) (the gap between best and second best arm in terms of conditional expected reward). Theorem 3 shows that, for any algorithm that bounds the simple regret on these instances to \(O(1/)\) of the minimax optimal rates, its cumulative regret will be at least \(()\) times the minimax optimal rates. RAPR thus achieves a near-optimal trade-off between guarantees on simple vs cumulative regrets when \(T\) is large enough. The trade-off contrasts with non-contextual bandits, where successive elimination ensures improved (compared to minimax) instance-dependent guarantees for both simple and cumulative regret .

**Types of CB algorithms.** Contextual bandit algorithms broadly fall into two categories: regression-free and regression-based. Regression-free algorithms create an explicit policy distribution, randomly choosing a policy for decision-making at any time-step . While these algorithms provide worst-case cumulative regret guarantees  or instance-dependent PAC guarantees for policy learning  without additional assumptions, they can be computationally intensive : they require solving and storing the output of \(((T))\) cost-sensitive classification (CSC) problems  at every epoch (or update step). In contrast, regression-based algorithms [e.g., 1, 11, 34] construct a conditional arm distribution using regression estimates of the expected reward, allowing for methods that need only solve \((1)\) regression or CSC problems at every epoch (or update step). Traditionally, these algorithms relied on realizability assumptions for optimal regret guarantees, but recent advances allow for misspecified reward model classes . We develop regression-based algorithms and do not assume realizability. RAPR is the first general-purpose regression-based algorithm with attractive pure exploration (simple regret) guarantees.

**Overview of our algorithm.** We now describe the RAPR algorithm in more detail. We first define a surrogate objective for simple regret, the optimal cover, which is inversely proportional to the probability that the bandit exploration policy chooses the arm recommended by the unknown optimal policy. The optimal cover bounds the variance of evaluating the unknown optimal policy under our exploration policy. This surrogate objective can be minimized by appropriately designing our exploration policy/action selection kernels. To maintain the attractive computational properties of regression-based algorithms, RAPR does not construct an explicit distribution over policies as that distribution would have large support and would be computationally and memory intensive to maintain. Instead, the goal of minimizing the optimal cover is attained by directly constructing a distribution over arms for each arriving context. This in turn builds on a novel general-purpose uncertainty quantification at each context. Much of the existing literature constructs confidence intervals with point-wise guarantees, but existing approaches to constructing them rely on assumptions like linear realizability. For general function classes, these intervals may be too wide and are often computationally expensive to construct. To overcome this issue, we develop Conformal Arm Sets (CASs), which are a set of potentially optimal arms at each context. This uncertainty quantification is regression-based and computationally efficient to construct; it's general-purpose and shrinks at "fast rates" (with square-root dependency on expected squared error bounds for regression). Unfortunately, these sets come with some risk of not containing the arm recommended by the optimal policy at every context. Nevertheless, we can use this uncertainty quantification to construct a distribution over arms at each context that helps us minimize the optimal cover by balancing the benefits and risks of relying on these CASs. The unavoidable trade-off between our simple and cumulative regret guarantees is an artifact of these risky sets. Beyond allowing us to trade off simple and cumulative regret guarantees, the flexibility of the approach also helps us extend to continuous arm settings and allows us to handle model misspecification.

**Other Related Work.** Our work connects to the literature on pure exploration, extensively studied in MAB settings (see overview in ).  study elimination-based algorithms for fixed confidence best-arm identification (BAI).  study variants of Thompson Sampling with optimal asymptotic designs for BAI.  propose sequential halving for fixed budget BAI. Our algorithm provides fixed confidence simple regret guarantees and can be seen as a generalization of successive elimination  to the contextual bandit setting. The key technical difference is that it is often impossible to construct sub-gaussian confidence intervals on conditional expected rewards. The uncertainty quantification we use is similar to the notion of conformal prediction (see  for a detailed exposition). Until recently, pure exploration had been nearly unstudied in contextual bandits.  provide a static exploration algorithm that achieves the minimax lower bound on sample complexity for linear contextual bandits.  then provided the first algorithm with instance-dependent \((,)\)-PAC guarantees for contextual bandits. This algorithm is regression-free (adapts techniques from ) and requires a sufficiently large dataset of offline contexts as input. Hence, unfortunately, it inherits high memory and runtime requirements [See 11, for a more detailed discussion]. However, these costs come with the benefit that their notion of instance dependence leverages structure not only in the true conditional expected reward (as in Theorem 2) but also in the policy class (similar to policy disagreement coefficient ). They also prove a negative result, showing that it is not possible for an algorithm to have instance-dependent \((0,)\)-PAC guarantees and achieve minimax optimal cumulative regret guarantees. Our hardness result is similar but complementary to their result, for we show a similar result for simple regret (rather than their \((0,)\)-PAC sample complexity).3 Our work also recovers some cumulative regret guarantees for the continuous arm case , with new guarantees on simple regret and robustness to misspecification. Note that our restriction to "slightly randomized" policies for the continuous arm case results in regret bounds with respect to a "slightly randomized" (smooth) benchmark [see 40, for smooth regret].

### Stochastic Contextual Bandits

We consider the stochastic contextual bandit setting, with context space \(\), (compact) arm space \(\), and a fixed but unknown distribution \(D\) over contexts and arm rewards. \(D_{}\) refers to the marginal distribution over contexts, and \(T\) signifies the number of rounds or sample size. At each time \(t[T]\)4, the environment draws a context \(x_{t}\) and a reward vector \(r_{t}^{}\) from \(D\); the learner chooses an arm \(a_{t}\) and observes a reward \(r_{t}(a_{t})\). To streamline notation for discrete and continuous arm spaces, we consider a finite measure space \((,,)\) over the set of arms, with \(K\) shorthand for \(()\).5 For ease of exposition, we focus on the finite/discrete arm setting. Here \(=[K]\) and \(\) is the count measure, and \((S)=|S|\) for any \(S\). A (deterministic) policy \(\) maps contexts to _singleton arm sets_\(_{1}:=\{a|a\}\)6. With some abuse of notation, we also let \(\) refer to the kernel given by \((a|x)=I(a(x))\). An action selection kernel (randomized policy) \(p:\) is a probability kernel that describes a distribution \(p(|x)\) over arms at every context \(x\). We let \(D(p)\) be the induced distribution over \(\), where sampling \((x,a,r(a)) D(p)\) is equivalent to sampling \((x,r) D\) and then sampling \(a p(|x)\).

A reward model \(f\) maps \(\) to \(\), with \(f^{*}(x,a):=_{D}[r_{t}(a)|x_{t}=x]\) denoting the true conditional expected reward model. Our algorithm works with a reward model class \(\) and a policy class \(\). For a given model \(f\) and an action selection kernel \(p\), we denote the expected instantaneous reward of \(p\) with \(f\) as \(R_{f}(p)\). We write \(R_{f^{*}}(p)\) as \(R(p)\) to simplify notation when no confusion arises. The optimal policy associated with reward function \(f\) is defined as \(_{f}\)7.

\[R_{f}(p):=}_{x D_{}}}_{a  p(|x)}[f(x,a)],_{f}_{}R_{f}().\]

The policy \(_{f}\) induced by \(f\) is assumed to be within policy class \(\) without loss of generality.8 For any \(S\), with some abuse of notation, we let \(f(x,S)=_{a S}f(x,a)d(a)/(S)\). Note that \(_{f}(x)_{S_{1}}f(x,S)\) for all \(x\). The _regret_ of a policy \(\) with respect to \(f\) is the difference between the optimal value and the actual value of \(\), denoted as \(_{f}():=R_{f}(_{f})-R_{f}()\). Finally, we let \(^{*}\) denote the optimal policy in the class \(\) and let \(_{}()\) denote the regret with respect to \(^{*}\). That is, \(^{*}_{}R()\) and \(_{}():=R(^{*})-R()\).

**Objectives.** Contextual bandit algorithms adaptively construct action sampling kernels (exploration policies) \(\{p_{t}\}_{t[T]}\) used to collect data over the \(T\) rounds. At the end of the adaptive experiment, the adaptively collected data is used to learn a policy \(\). We study two main objectives to measure quality of these outputs: [Objective 1] _Cumulative regret minimization._ Cumulative regret (\(_{T}\)) is given by \(_{T}:=_{t=1}^{T}_{f^{*}}(p_{t})\). It compares the cumulative expected reward obtained during the experiment with the expected reward of the policy (\(_{f^{*}}\)) induced by the true conditional expected reward (\(f^{*}\)). We seek to minimize cumulative regret which is equivalent to maximizing cumulative expected reward during the experiment. [Objective 2] _Simple regret minimization._ Simple regret is given by \(_{}()\). It compares the expected reward of the learnt policy \(\) against the value of the optimal policy in the class \(\). We seek to minimize simple regret which is equivalent to maximizing expected reward of the policy learnt at the end of the experiment. To understand the kind of exploration kernels (\(\{p_{t}\}_{t[T]}\)) that help with policy learning, we now identify a surrogate objective for simple regret (called optimal cover) that is in terms of the kernels used for exploration.

**Definition 1** (Cover).: _Given a kernel \(p\) and a policy \(\), we define the cover of policy \(\) under the kernel \(p\) to be,_

\[V(p,):=}_{x D_{},a(|x)} .\] (1)

_Additionally, for any pair of kernels \((p,q)\), we let \(V(p,q):=_{x D_{},a q(|x)}[q(a|x)/p(a|x)]\). Finally, we use the term optimal cover for kernel \(p\) to refer to \(V(p,^{*})\)._

The cover measures the quality of data collected under the action selection kernel \(p\) for evaluating a given policy \(\) and bounds the variance of commonly used unbiased estimators for policy value[e.g., 2, 14, 39]. In particular, the cover under optimal policy \(_{t=1}^{T}V(p_{t},^{*})\) can be treated as a surrogate objective for simple regret minimization (proven in Appendix E.2), which is particularly instructional in designing our algorithm to minimize simple regret.

**Extending notation to continuous arms.** In the continuous arm setting, evaluating arbitrary deterministic policies can be infeasible without extra assumptions . Thus, we focus on "slightly randomized" policies by generalizing \(_{1}\) to be the arm sets with measure one (\(_{1}:=\{S|(S)=1\}\)).9 The granularity of these sets can be adjusted by scaling the finite measure \(\), which also affects the value of \(K=()\). We then continue defining policies be maps from \(\) to \(_{1}\) and \(\) is a class of such policies. We overload notation and define the induced kernel as \((a|x)=I(a(x))\), which is a valid definition since \(_{a}I(a(x))d(a)=((x))=1\). All the remaining definitions, including \(R_{f}(),_{f},^{*}\) and \(V(p,)\), relied on these induced kernels and continue to hold. While there are some measure theoretic issues that remain to be discussed, we defer these details to Appendix A.

**Uniform sampling.** Our algorithm frequently selects an arm uniformly from a constructed set of arms. In the context of a set \(S\), uniform sampling refers to selecting an arm from the distribution \(q(a):=I(a S)/(S)\). This constitutes a probability measure since its integral over \(\) equals \(1\). In the discrete arm setting, uniform sampling from a set \(S\) implies selecting an arm according to the distribution \(I(a S)/|S|\).

### Oracle Assumptions

Our algorithm relies on two sub-routines. For generality, we abstract away these sub-routines by stating them as oracle assumptions, for which we describe two oracles, EstOracle and EvalOracle, in Assumptions 1 and 2 respectively. The EstOracle sub-routine is for estimating conditional expected reward models (Assumption 1), and the EvalOracle sub-routine is for estimating policy values (Assumption 2) according to the true and estimated reward models.

These sub-routine tasks are supervised learning problems. Hence, the average errors for the corresponding tasks can be bounded in terms of the number of samples (\(n\)) and a confidence parameter (\(^{}\)). The oracle assumptions specify the estimation rates. We let \(:\) denote the estimation rate for these oracles. For simplicity, we assume that they share the same rate and that \((n,^{})\) scales polynomially in \(1/n\) and \((1/^{})\). In order to simplify the analysis, we also require \((n/3,^{}/n^{3})\) be non-increasing in \(n\).10 We now formally describe these oracle assumptions, starting with EstOracle.

**Assumption 1** (Estimation Oracle).: _We assume access to a reward model estimation oracle (EstOracle) that takes as input an action selection kernel \(p\), and \(n\) independently and identically drawn samples from the distribution \(D(p)\). The oracle then outputs an estimated model \(\) such that for any \(^{}(0,1)\), the following holds with probability at least \(1-^{}\):_

\[*{}_{x D_{X}}*{}_{a p( |x)}[((x,a)-f^{*}(x,a))^{2}] B+(n,^{})\]

_Where \(B 0\) is a fixed but unknown constant that may depend on the model class \(\) and distribution \(D\), but is independent of the action selection kernel \(p\)._

In Assumption 1, the parameter \(B\) measures the bias of model class \(\); under realizability, \(B\) equals 0. The function \(\) characterizes the estimation variance, which decreases with increasing sample size. _As long as the variance term (which shrinks as we gather more data) is larger than the fixed unknown bias (\(B\))_, we have from Assumption 1 that the expected squared error for the estimated reward model is bounded by \(2\). We use this bound on expected squared error to further bound how accurately the estimated reward model evaluates policies in the class \(\) (Lemma 6). However, since \(B\) is unknown, we need a test to detect when this policy evaluation bounds starts failing (which can only happen after the variance term gets dominated by the unknown bias term). To construct this test,our algorithm relies on EvalOracle, which provides consistent independent policy value estimates and helps compare them with policy value estimates with respect to the estimated reward model.

**Assumption 2** (Evaluation Oracle).: _We assume access to an oracle (EvalOracle) that takes as input an action selection kernel \(p\), \(n\) independently and identically drawn samples from the distribution \(D(p)\), a set of \(m\) models \(\{g_{i}|i[m]\}\), and another action selection kernel \(q\). The oracle then outputs a policy evaluation estimator \(\) of true policy value, and a set of \(m\) policy evaluation estimators \(\{_{q_{i}}|i[m]\}\) that estimate policy value with respect to the models \(g_{1},g_{2},,g_{m}\) respectively. Such that for any \(^{}(0,1)\), the following conditions simultaneously hold with probability at least \(1-(m+1)^{}\):_

* \(|()-R()|)}+2(n,^ {})/(_{(x,a)}p(a|x))\) _for all_ \(\{q\}\)_._
* \(|_{f}()-R_{f}()|)}\) _for all_ \(\{q\}\) _and for all_ \(f\{g_{i}|i[m]\}\)_._

When \(\) and \(\) are finite, one can construct oracles such that Assumptions 1 and 2 hold with \((n,^{})=(((||,||)/^{ })/n)\). One example of such a construction is given by using empirical squared loss minimization for EstOracle, using inverse propensity scores (IPS) for estimating \(R()\) in EvalOracle, and using the empirical average for estimating \(R_{f}()\) in EvalOracle. The guarantees of these assumptions can be derived using Bernstein's inequality and union bounding. When \(\) has pseudo-dimension  bounded by \(d\) and \(\) has the Natarajan-dimension bounded by \(d\), one can construct oracles such that Assumptions 1 and 2 hold with \((n,^{})=(d(nK/^{})/n)\).

## 2 Algorithm

```
1:Trade-off parameter \([1,K]\), proportional response threshold \(_{}=1/2\), and confidence parameter \(\) (used in definition of \(_{m}\)).
2:Let \(p_{1}(a|x) 1/()=1/K\), \(_{1} 0\), \(_{1}=3K\), \(_{1}=3\), and \(=\).
3:for epoch \(m=1,2,\)do\(\) Doubling epochs.
4:\(_{m}=2_{m-1}\).
5:if safe then
6:for round \(t=_{m-1}+1,,_{m}\)do
7: Observe context \(x_{t}\), sample \(a_{t} p_{m}(|x_{t})\), and observe \(r_{t}(a_{t})\).
8:endfor
9: Let \(S_{m}\) denote the data collected in epoch \(m\).
10: We split \(S_{m}\) into three equally sized sets \(S_{m,1},S_{m,2}\) and \(S_{m,3}\).
11: Let \(_{m+1}(p_{m},S_{m,1})\), and let \(C_{m+1}\) be given by Definition 2.
12: Let \(_{m+1}\) be the solution to (5) and let \(_{m+1}:=3K/_{m+1}\). \(\)\(S_{m,2}\) is used here.
13: Now let \(p_{m+1}\) be given by (4).
14: Let \(_{m+1},\{_{m+1,_{i}}|i[m+1]\} (p_{m},S_{m,3},\{_{i}|i[m+1]\},p_{m+1})\).
15:if (2) does not hold. then
16:\(, m,\).
17:endif
18:else
19:for round \(t=_{m-1}+1,,_{m}\)do
20: Observe context \(x_{t}\), sample \(a_{t} p_{}(|x_{t})\), and observe \(r_{t}(a_{t})\).
21:endfor
22: Let \(S_{m}\) denote the data collected in epoch \(m\).
23: Let \(_{m+1,_{i}}|i[]\}(p_{ },S_{m},\{_{i}|i[]\},p_{})\).
24:endif
25:endfor ```

**Algorithm 1**\(\) Risk Adjusted Proportional Response (\(\)-RAPR)

At a high level, our algorithm operates in two modes, indicated by a Boolean variable "\(\)". During mode one (\(=\)), where estimated reward models are sufficiently accurate at evaluating policies in the class \(\),11 we use our estimated models to update our action selection kernel used during exploration. During mode two (\(=\)), where the condition for mode one no longer holds, we stop updating the action selection kernel used for exploration. Operationally our algorithm runs in epochs/batches indexed by \(m\). Epoch \(m\) begins at round \(t=_{m-1}+1\) and ends at \(t=_{m}\), and we use \(m(t)\) to denote the epoch index containing round \(t\). We let \(\) denote the critical epoch, at the end of which our algorithm changes mode (with "**safe**" being updated from "**True**" to "**False**"); we refer to \(\) as the _algorithmic safe epoch_. For all rounds in epoch \(m\), our algorithm samples action using the action selection kernel \(p_{m}\) defined later in (4). For \(m>\), our algorithm samples action using \(p_{}\) -the action selection kernel used in the algorithmic safe epoch \(\).

We now describe the critical components of our algorithm. These include (i) data splitting and using oracle sub-routines; (ii) _misspecification tests_, which we use to identify the **safe**-mode switching epoch \(\); and (iii) _conformal arm sets_, which presents a new form of uncertainty quantification that is critical in constructing \(p_{m+1}\) at the end of each epoch \(m[]\). Finally, we use these components to describe our final algorithm.

**Data splitting and oracle sub-routines.** Consider an epoch \(m[]\). Let \(S_{m}\) denote the set of samples collected in this epoch: \(S_{m}=\{(x_{t},a_{t},r_{t}(a_{t}))|t[_{m-1},_{m}]\}\). Our algorithm splits \(S_{m}\) into three equally-sized subsets: \(S_{m,1}\), \(S_{m,2}\) and \(S_{m,3}\). Algorithm 1 outlines using these subsets and the oracles (described in Section 1.2) to estimate reward models and evaluate policies. Based on Assumptions 1 and 2, we bound the errors for these estimates in terms of \(_{m+1}=2((_{m}-_{m-1})/3,/(16m^{3}))\), where \(\) is a specified confidence parameter. As we will see later, our algorithm relies on these bounds to test for misspecification and construct action selection kernels.

**Misspecification test.** We first discuss the need for our misspecification test. Note that Assumption 1 is flexible and allows our reward model class \(\) to be misspecified. In particular, the squared error of our reward model estimate may depend on an unknown bias term \(B\). To account for this unknown \(B\), it is useful to center our analysis around the safe epoch \(m^{*}:=\{m 1|_{m+1} 2B\}\), which denotes the last epoch where variance dominates bias. We show that for any epoch \(m[m^{*}]\), the estimated reward model \(_{m+1}\) is "sufficiently accurate" at evaluating the expected reward of any policy in \(\{p_{m+1}\}\). This property is critical in ensuring that the constructed action selection kernel \(p_{m+1}\) has low exploration regret \(_{f}(p_{m+1})\) and a small optimal cover (\(V(p_{m+1},^{*})\)). Since \(B\) and \(m^{*}\) are unknown, we need to test whether the estimated reward model is sufficiently accurate at evaluating these policies. When the test fails, the algorithm sets the variable "safe" to **False** and stops updating the action selection kernel used for exploration. The core idea for this test comes from  although its application to simple regret minimization is new, and the form of our test differs a bit. We now state our misspecification test (2). At the end of each epoch \(m\), the test is passed if (2) holds:

\[_{\{p_{m+1}\}}|_{m+1,_{m+1}}()- _{m+1}()|-_{m+1}}_{[m]}_{m+1,_{m}}(_{_{m}})-_{m+1,_{m}}()}{40^{2}-1}_{}}}\] (2) \[ 2.05_{m+1}}+1.1},\]

where \(_{}\) empirically bounds \(V(p_{},^{*})\), the optimal cover for the action selection kernel used in epoch \(\) (see (49)). The first term in (2) measures how well the estimated reward model \(_{m+1}\) evaluates the policy \(\), and the second term accounts for under-explored policies (policies that have high regret under the reward model \(_{m}\) would be less explored in epoch \(m\)).

**Conformal arm sets.** We proceed to introduce the notion of _conformal arm sets_ (CASs), based on which we construct the action selection kernels employed by our algorithms. At the beginning of each epoch \(m\), we construct CASs, denoted as \(\{C_{m}(x,)|x,\}\); here \(\) controls the probability with which the set \(C_{m}\) contains the optimal arm. The construction of these sets rely on the models (\(_{1},,_{m}\)) estimated from data up to epoch \(m-1\), as defined below.

**Definition 2** (Conformal Arm Sets).: _Consider \((0,1)\). At epoch \(m\), for context \(x\), the arm set \(C_{m}(x,)\) is given by (3)._

\[ C_{m}(x,):=_{_{m}}(x)_{m}(x,),\ \ _{m}(x,):=_{[m]}_{}x,^{2}},\\ _{}(x,^{}):=\{a:_{} (x,_{_{}}(x))-_{}(x,a)-1}_{}}}{^{}}\}[m],^{ }(0,1).\] (3)Similar to conformal prediction (CP) , CASs have marginal coverage guarantees. We show that with high probability, we have \(^{*}(x)\) lies in \(C_{m}(x,)\) with probability at least \(1-\) over the context distribution. That is, \(_{x D_{}}(^{*}(x) C_{m}(x,)) 1-\) with high-probability (see Appendix E.1). However, there is also a key technical difference. While CP provides coverage guarantees for the conditional random outcome, CASs provide coverage guarantees for \(^{*}(x)\) - which is not a random variable given the context \(x\). Hence, intervals estimated by CP need to be wide enough to account for conditional outcome noise, whereas CASs do not. CASs also have several advantages compared to pointwise confidence intervals used in UCB algorithms. First, CASs are computationally easier to construct. Second, CAS widths have a polynomial dependency on model class complexity, whereas pointwise intervals may have an exponential dependence for some function classes [see lower bound examples in 13]. Third, pointwise intervals require realizability, whereas the guarantees of CASs hold even without realizability (as long as the misspecification test in (2) holds). However, it's important to remember that these benefits of CASs come with the risk of only covering \(^{*}(x)\) marginally over the context distribution - that is, these sets may not contain \(^{*}(x)\) at all \(x\).

**Risk Adjusted Proportional Response Algorithm.** We now describe the design of our algorithm, which is summarized in Algorithm 1. The algorithm depends on the following input parameters: \([1,K]\) which controls the trade-off between simple and cumulative regret, the proportional response threshold \(_{}=1/2\), and confidence parameter \(\). The algorithm also computes \(_{m+1}\) (risk adjustment parameter for \(p_{m+1}\)), \(_{m+1}\) (empirical bound on optimal cover for \(p_{m+1}\)), and \(_{m+1}()\) (empirical bound on average CAS size). At the end of every epoch \(m[]\), we construct the action selection kernel \(p_{m+1}\) given by (4).

\[p_{m+1}(a|x)=)I[a C_{m+1}(x,_{}/_{m+1})]}{ C_{m+1}(x,_{}/_{m+1})}+_{0}^{_{}} (x,/_{m+1})]}{C_{m+1}(x,/_{m+1 })}.\] (4)

At any context \(x\), sampling arm \(a\) from \(p_{m+1}(|x)\) is equivalent to the following. Sample \(\) uniformly from \(\), then sample arm \(a\) uniformly from the set \(C_{m+1}(x,(_{},)/_{m+1})\). A small \(\) results in a larger CAS and a higher probability of containing the optimal arm for the sampled context. However, uniformly sampling an arm from a larger CAS also implies a lower probability on every arm in the set. Sampling \(\) uniformly allows us to respond proportionately to the risk of not sampling the optimal arm while enjoying the benefits of smaller CASs. We refer to this as the _Proportional Response Principle_.

Similarly note that, a larger risk-adjustment parameter \(_{m+1}\) encourages reliance on less risky albeit larger CASs. We want to choose \(_{m+1}\) to tightly bound the the optimal cover (surrogate for simple regret), subject to cumulative regret constrains imposed by the trade-off parameter \(\). To do this, we first let \(_{m+1}()\) be a high-probability empirical upper bound on \(E_{x D_{}}[(C_{m+1}(x,_{}/))]\). Hence, using (49), we can upper bound the optimal cover (\(V(p_{m+1},^{*})\)) by \((_{m+1})}{1-_{}}+}\). Our choice of \(_{m+1}\) approximately minimizes this upper bound on the optimal cover, by choosing the largest feasible \([_{m},}]\) such that \(_{m+1}()\) (see (5)). Note that this choice of \(_{m+1}\) balances the risk of a small \(\) (large \(\)) with the benefits of a small \(_{m+1}()\) (small \(()}{1-_{}}\)).

\[_{m+1}() :=1+|}_{t S_{m,2}}( _{m+1}x,}{})+(8|S_{m,2 }|(m+1)^{2}/)}{2|S_{m,2}|}},K,\] (5) \[_{m+1} _{m},\ =|}{n} n[|S_{m,2}|],}},_{m+ 1}()}}.\]

With \(_{m+1}\) chosen, the action selection kernel \(p_{m+1}\) is decided. Now let \(_{m+1}=3K/_{m+1}\), which is a high-probability empirical upper bound on \(V(p_{m+1},^{*})\). We then use \(_{m+1}\) at the end of epoch \(m+1\) to construct CASs, compute the risk-adjustment parameter, and test for misspecification.

**Computation.** We have \(((T))\) epochs. At the end of any epoch \(m[]\), we solve three optimization problems. The first is for estimating \(_{m+1}\), which often reduces to empirical squared loss minimization and is computationally tractable for several function classes \(\). The second is for computing the risk-adjustment parameter in (5) which can be solved via binary search. The third is for the misspecification test in (2), which can be solved via two calls to a cost-sensitive classification (CSC) solver (don't need this when assuming realizability, further if we only care about cumulative regret, sufficient to use the simpler test in ). Finally, to learn a policy \(\) at the end of \(T\) rounds, we need to solve (8) using a CSC solver (under realizability we can set \(=_{f_{m(T)-1}}\)). Hence, overall, \(\)-RAPR makes exponentially fewer calls to solvers compared to regression-free algorithms like .

## 3 Main Results

Our algorithm/analysis/results hold for both the discrete and continuous arm cases. As discussed before, minimizing optimal cover helps us ensure improved simple regret guarantees. Hence \(_{m}[1,3K]\) (the high-probability empirical upper bound on the optimal cover \(V(p_{m},^{*})\)) will play a crititcal role thoughout this results section. We start with stating our cumulative regret bounds.

**Theorem 1**.: _Suppose Assumptions 1 and 2 hold. Then with probability \(1-\), \(\)-RAPR attains the following cumulative regret guarantee. Here \(_{m+1}=((_{m}-_{m-1})/3,/(16m^{3})\) for all \(m\)._

\[_{T} }_{t=_{1}+1}^{T}}}{_{m(t)}}}+}\] (6a) \[}+_{t=_{1 }+1}^{T}}.\] (6b)

_Where we use \(}\) to hide terms logarithmic in \(T,K,(T,)\)._

We start with discussing (6b). The first part \(\) comes from the bias of the regression oracle with model class \(\) and will vanish under the realizability assumption. The second part \(_{t=_{1}+1}^{T}}\), when setting \(=1\), recovers near-optimal (upto logarithmic factors) minimax cumulative regret guarantees for common model classes, as demonstrated by the following examples.

**Corollary 1**.: _We consider \(\)-RAPR with appropriate oracles in the following cases and let \(B\) denote the corresponding bias terms. When \(\) and \(\) are finite, \(_{T}}(+|,||)/)})\) with probability at least \(1-\). When \(\) has a finite pseudo dimension \(d\), \(\) has a finite Natarajan dimension \(d\), and \(\) is finite, \(_{T}}(+)\) with probability at least \(1-\). Note that under realizability (\(B=0\)), \(1\)-RAPR achieves near-optimal minimax cumulative guarantees._

In (6a), we observe that the multiplicative \(\) cost to cumulative regret is only incurred if the empirical bound on optimal cover (\(_{m}[1,3K]\)) can get small. That is, our cumulative regret bounds degrade only if our algorithm better bounds the optimal cover and thus ensures better simple regret guarantees. 12 We now provide instance dependent simple regret guarantees for our algorithm.

**Theorem 2**.: _Suppose Assumptions 1 and 2 hold. For some \((,,A)(0,1][1,K]\), consider instances where for \(1-\) fraction of contexts at most \(A\) arms are \(\) optimal (i.e. (7) holds)._

\[_{x D_{}}(\{a:f^{*}(x,_{ f^{*}}(x))-f^{*}(x,a)\}) A 1-.\] (7)

_Let \(m^{}=(,m(T))-1\). Let the learned policy \(\) be given by (8) (equivalent to variance penalized policy optimization)._

\[_{}_{m(T)}()-}_{m(T)}}_{[m^{}]}_{m(T),_{m} }(_{_{m}})-_{m(T),_{m}}()}{40^{2}-1}_{}}}.\] (8)

_Then with probability \(1-\), \(\)-RAPR has the following simple regret bound when \(T\) samples._

\[_{}()}_{m(T)}}\] \[ K,A+K++^{1/2}}{},m(T)-1)- _{2}_{2}(K)}}}.\]Under (7), we can only argue that the expected (over context distribution) measure of \(\) optimal arms is at most \((1-)A+K=O(A+K)\). Hence for large \(T\), the best we can hope for is instance-dependant simple regret guarantees that shrink/improve over minimax guarantees by a factor of \(()\). We show that this is guaranteed by Theorem 2. Suppose \(=K\), \(\) has a finite pseudo dimension bounded by \(d\), and \(\) has a finite Natarajan dimension bounded by \(d\). The simple regret guarantee of Theorem 2 reduces to \(}(((,+(K/) ))\). When the reward model estimation bias \(B\) is small enough, the term \((K/))\) is dominated by the remaining terms for large \(T\). Hence, in this case, we get a simple regret bound of \(}()\) for large \(T\). As promised, this improves upon the minimax guarantees by a factor of \(()\).

Note that Theorem 1 guarantees are better for \(\) closer to \(1\) whereas Theorem 2 guarantees are better for \(\) closer to \(K\). Hence these theorems show a tradeoff between the cumulative and simple regret guarantees for \(\)-RAPR. Theorem 3 shows that improving upon minimax simple regret guarantees for instances satisfying (7) may come at the unavoidable cost of worse than minimax optimal cumulative regret guarantees. This contrasts with non-contextual bandits, where successive elimination ensures improved (compared to minimax) gap-dependent guarantees for both simple and cumulative regret.

**Theorem 3**.: _Given parameters \(K,F,T\) and \([1,)\). There exists a context space \(\) and a function class \(()\) with \(K\) actions such that \(|| F\) and the following lower bound on cumulative regret holds:_

\[_{_{}}_{D}\,\,_{D} _{t=1}^{T}r_{t}(^{*}(x_{t}))-r_{t}(a_{t}) }\]

_Here \((a_{1}, a_{T})\) denotes the actions selected by an algorithm \(A\). \(\) denotes the set of environments such that \(f^{*}\) and (7) hold with \((A,,)=(1,0,0.24)\). \(\) denotes policies induced by \(\). \(_{}\) denotes the set of CB algorithms that run for \(T\) rounds and output a learned policy with a simple regret guarantee of \(\) for any instance in \(\) with confidence at least \(0.95\), i.e., \(_{}:=\{A:((_{})) 0.95\}\). Finally, \(()\) hides factors logarithmic in \(K\) and \(T\)._

**Near optimal trade-off of RAPR.** Note that the environments constructed in Theorem 3 satisfy \(f^{*}\) with \((||,||) F\) and also satisfy (7) with \((A,,)=(1,0,0.24)\). With appropriate oracles, Assumptions 1 and 2 are satisfied with \(B=0\) (i.e. \(m^{*}=\)) and \((n,^{})=((F/^{})/n)\). Hence for large enough \(T\), \(\)-RAPR achieves a simple regret bound of \(}( F/T)\) with probability at least \(0.95\) and thus is a member of \(_{}\) for some \(=}(K/)\). Theorem 3 lower bounds the cumulative regret of such algorithms by \(()=( )\). Up to logarithmic factors, this matches the cumulative regret upper bound for \(\)-RAPR. Re-emphphasizing that the trade-off observed in Theorems 1 and 2 is near optimal for large \(T\).

**Simulations.** To demonstrate the computational tractability of our approach, we ran a simulation on setting within a \(^{2}\)context space, eight arms, linear models, and an exploration horizon of \(5000\). Our algorithms ran in less than \(9\) seconds on a Macbook M1 Pro. We also compare with other baselines on simple/cumulative regret. See Appendix E.4 for details.

**Conclusion.** We develop Risk Adjusted Proportional Response (RAPR), a computationally efficient regression-based contextual bandit algorithm. It is the first contextual bandit algorithm capable of trading-off worst-case cumulative regret guarantees with instance-dependent simple regret guarantees. The versatility of our algorithm allows for general reward models, handles misspecification, extends to finite and continuous arm settings, and allows us to choose the trade-off between simple and cumulative regret guarantees. The key ideas underlying RAPR are conformal arm sets (CASs) to quantify uncertainty, proportional response principle for cumulative regret minimization, optimal cover as a surrogate for simple regret, and risk adjustment for better bounds on the optimal cover. 13**Limitations.** A limitation of our approach is that we do not utilize the structure of the policy class being explored. Further refining CASs with other forms of uncertainty quantification that leverage such structure can lead to significant improvements, and potentially avoid trade-offs between simple/cumulative regret when policy class structure allows for it.