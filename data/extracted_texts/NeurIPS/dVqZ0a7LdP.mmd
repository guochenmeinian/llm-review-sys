# General instructions' snippets of relevant information given to participants during locomotion experiments (both English-translated and German version below)

ReMAP: Neural Model Reprogramming with Network Inversion and Retrieval-Augmented Mapping for Adaptive Motion Forecasting

Sharmita Dey, Sarath Ravindran Nair

Sharmita Dey conceptualized and led the project; both authors shared equal responsibility for executing the research.Sharmita Dey is with the University Medical Center Gottingen, Georg-August University of Gottingen sharmita.dey@med.uni-goettingen.deSarath Ravindran Nair is with the Georg-August University of Gottingen, Germany s.ravindrannair@eni-g.de

###### Abstract

Mobility impairment caused by limb loss, aging, stroke, and other movement deficiencies is a significant challenge faced by millions of individuals worldwide. Advanced assistive technologies, such as prostheses and orthoses, have the potential to greatly improve the quality of life for such individuals. A critical component in the design of these technologies is the accurate forecasting of reference joint motion for impaired limbs, which is hindered by the scarcity of joint locomotion data available for these patients. To address this, we propose ReMAP, a novel model repurposing strategy that leverages deep learning's reprogramming property, incorporating network inversion principles and retrieval-augmented mapping. Our approach adapts models originally designed for able-bodied individuals to forecast joint motion in limb-impaired patients without altering model parameters. We demonstrate the efficacy of ReMAP through extensive empirical studies on data from below-knee-challenged patients, showcasing significant improvements over traditional transfer learning and fine-tuning methods. These findings have significant implications for advancing assistive technology and mobility for patients with amputations, stroke, or aging.

## 1 Introduction

Physical impairment is a life-altering event that affects millions of individuals worldwide, imposing substantial challenges on their mobility and daily activities. The disability of a limb can lead to significant physical and psychological limitations, impacting the individual's overall well-being and independence. In recent years, considerable efforts have been made to develop advanced assistive technologies to address these challenges and enhance the quality of life for impaired patients.

A crucial aspect of designing effective assistive technologies is the accurate prediction of reference joint motion for the impaired limb. Understanding the natural motion of the joints is essential for the development of prosthetic devices that can restore the function of the impaired limb seamlessly. However, obtaining reliable data for impaired patients is a complex task, as their numbers and ability to perform diverse motion conditions are relatively limited compared to able-bodied individuals. This scarcity of data hinders the training of robust models specifically tailored to the unique conditions of each individual. Moreover, each impairment is a unique and individualized event, leading to a wide range of motion patterns and functional variations among such patients. Consequently, creating a single generic model for those patients is not practical, as it would not capture the individual variationsand diverse motion conditions that arise from different types of impairments. In contrast, subject-specific modeling attempts to cater to each patient's specific needs and characteristics. However, this approach faces significant challenges as well. The limited data availability for individual patients poses a hurdle in developing accurate models, leading to suboptimal performance and generalization issues.

Figure 1: Simplified architecture of the proposed ReMAP. The corrupt inputs \(X_{amp}\) from the individuals with mobility challenges are mapped to clean inputs \(X_{corr}\) computed from able-bodied individuals, and the corrected inputs are used to produce the desired motion variables for the individuals with mobility challenges \(_{amp}\) using a frozen foundation module pretrained for able-bodied subjects.

Figure 2: Illustration of computation of the correction input \(X_{corr}\) corresponding to the \(k\)-th input sample \(X_{amp}^{k}\) of the mobility-impaired individual. The able-bodied input \(X_{ab}^{i}\) that produces the most similar output as that of the desired mobility-impaired individual output \(y_{amp}^{k}\) is searched in the input-output space of the trained able-bodied foundation module. Instead of searching based on a single desired motion variable \(y_{amp}^{k}\), a sequence of values \(\{y_{amp}^{k-m},...,y_{amp}^{k},...,y_{amp}^{k+m}\}\) (marked by the red region in the lower left curve) is used and the able-bodied input \(X_{ab}^{i}\) corresponding to the midpoint of the sequence is considered. Further, a neighborhood of radius \(\) is considered around \(X_{ab}^{i}\) and the correction input \(X_{corr}\) is computed as a weighted sum of samples in this neighborhood with weights decreasing (linearly or exponentially) with increasing distance from the center \(X_{ab}^{i}\).

In this research, we introduce ReMAP, a novel approach for motion generation in impaired individuals using neural model reprogramming. Our strategy addresses the challenges of predicting joint motion with limited data by repurposing well-trained gait prediction models developed on able-bodied data. ReMAP utilizes network inversion principles and retrieval-augmented mapping to adapt models for impaired individuals without requiring retraining or fine-tuning of the pretrained models. ReMAP comprises three key components: (1) a diverse foundation module derived from able-bodied data, (2) a retrieval-augmented template mapping module to identify the most relevant inputs for learning the mapping, and (3) a refurbish module that learns the mapping once the desired inputs are identified. Specifically, we leverage network inversion techniques [1; 2; 3] to generate correction templates for mapping impaired inputs to able-bodied patterns and retrieval-based methods [4; 5; 6; 7] to identify the most relevant inputs for learning this mapping.

Furthermore, the adoption of neural model reprogramming provides an additional advantage in terms of cost and resource efficiency. Fine-tuning subject-specific models can be computationally expensive, requiring modifications to a considerable number of parameters in the model. In contrast, model reprogramming optimizes a smaller set of parameters, reducing the computational overhead significantly. Additionally, this technique preserves the model's original functionality, making it adaptable to various tasks without compromising its initial training.

We evaluate our method against baselines using transfer learning and conduct extensive ablations on various reprogramming techniques and architectures. Our quantitative results demonstrate the effectiveness of our approach, particularly in very low-data regimes, where it outperforms all tested transfer learning and fine-tuning methods. To the best of our knowledge, this is the first work in the domain of motion regression using neural model reprogramming. Our findings have significant implications for the advancement of assistive technologies, offering the potential to improve mobility and quality of life for limb-impaired patients.

## 2 Related Work

**Reprogramming of models.** The concept of model reprogramming involves repurposing proficiently trained models for novel tasks through data-level manipulation alone . This underscores the capability of deep models to handle diverse tasks without the need to alter any of their model parameters. The efficiency of this reprogramming approach has been validated in the context of image classification [8; 9], time-series classification [10; 11], spoken command recognition , GAN conditioning , out-of-distribution detection , antibody sequence filling  and fraud detection . This research explores the potential of model reprogramming to address the challenges of predicting joint motion in lower-limb-impaired individuals, aiming to enhance the development of assistive technologies. By repurposing well-established gait prediction models trained on able-bodied data, we seek to provide limb-impaired individuals with improved mobility solutions. This approach has the potential to transform the landscape of prosthetic development, offering a higher quality of life for individuals facing mobility challenges.

**Network inversion.** Network inversion techniques have been instrumental in optimizing neural network inputs to achieve specified outputs. Initially proposed by Linden and Kindermann , this method utilizes gradient-based optimization to iteratively refine inputs until the network outputs the desired result [1; 2; 3]. This approach has been studied and applied in interpretability research, such as visualizing deep convolutional networks to find the input image that maximizes the activation of a particular neuron or layer , understanding deep image representations [18; 19; 20], and image synthesis . In our work, we leverage this concept to generate a correction template for mapping inputs, given the characteristics of the desired output motion.

**Retrieval-based methods.** Retrieval-based methods rely on retrieving relevant information from a large corpus in response to a query [4; 5; 6; 7]. These methods involve identifying and retrieving relevant documents or passages using techniques like dense retrieval  and using this information to inform subsequent processes such as text generation or model training. A notable application of retrieval-based methods is Retrieval-Augmented Generation (RAG), where retrieval provides context that enhances generative processes [23; 24]. We apply retrieval-based methods to identify segments of impaired-limb motion dynamics, to learn a neural reprogramming module.

**Gait motion models.** Gait prediction is a challenging problem due to the complex nature of human gait. In recent years, there has been a growing interest in developing gait prediction modelsusing machine learning techniques. Most works focused on developing such models by training explicit models to learn the input-output synergy, especially, for able-bodied subjects [25; 26; 27; 28; 29; 30; 31], with only a few works on lower-limb-impaired individuals [32; 33; 34]. Directly applying a gait prediction model trained for able-bodied subjects for motion prediction in impaired individuals suffered in performance due to the inherent differences between gait patterns of able-bodied individuals and limb-impaired individuals . This study presents an efficient strategy to adapt a generic gait prediction model for predicting limb joint motion during various locomotion tasks for below-knee impaired individuals, including walking and stair ascent/descent, without requiring model fine-tuning or retraining. Our method integrates retrieval with network inversion techniques [2; 3], mapping impaired inputs to able-bodied patterns to facilitate accurate motion prediction.

## 3 Datasets

**Able-bodied dataset.** To train the able-bodied motion model, we utilize a comprehensive public dataset  that includes kinematic data collected from wearable sensors. These sensors comprise IMUs that measure 3D angular velocities and linear accelerations, as well as goniometers that capture sagittal knee and ankle positions under various motion conditions. The dataset includes recordings from ten individuals performing a range of locomotion activities, such as level ground walking, stair ascent, stair descent, and walking on inclined walkways. The dataset comprises approximately 6.56 million samples across ten individuals, averaging about 656,039 samples per individual.

**Lower-limb impairment motion datasets.** Motion data were collected from individuals with below-knee lower-limb impairments/amputations  using a 200 Hz camera-based motion capture system (Vicon Motion Systems Ltd., UK) equipped with 12 cameras. Retro-reflective markers were placed on their bony landmarks in the torso, pelvis, thigh, shank, and residual foot, with additional markers on the thigh and shank for 3D tracking. Various locomotion tasks were performed, including different walking speeds, stair ascent, and stair descent. Gait event detection software (Vicon Nexus) marked gait cycle boundaries based on marker positions and force thresholds. We processed the marker trajectories and computed joint angles and kinematic data using OpenSim , an open-source musculoskeletal modeling platform. The user studies were approved by the Institutional Review Board (IRB) of the University Medical Center Gottingen, Germany. Participants were informed beforehand about the experimental procedure, potential risks, precaution measures, and data protection. Experiments were conducted after obtaining written consent from participants. All ethical protocols regarding information, instructions, and compensation were followed. Details are provided in the appendix A.5.

**Inputs and outputs.** We utilized the temporal history of angular velocities from the shank and thigh segments and the angular position of the knee joint on both sides as model inputs.

\[X_{t}=\{_{t-K:t}^{(thigh,r)},_{t-K:t}^{(thigh,l)},_{t-K:t}^{ (shank,r)},_{t-K:t}^{(shank,l)},_{t-K:t}^{(knee,r)},_{t-K:t}^ {(knee,l)}\}^{K D} \]

where \(K=20\) is the length of history and \(D=6\) is the number of input features. The model predicted the angular position of the ankle joint on the impaired side. Given that direct measurement of ground truth outputs from lower-limb impaired individuals is not feasible due to limb disabilities or loss, we computed the desired ankle motion trajectories for each such individual's gait cycle based on similar-speed gait cycles of a subset of able-bodied subjects with comparable anthropometric features (mass, age, height).

\[_{amp}=}_{n N_{speed}}y_{k} ^{s,n}}{|S_{anthropometric}||N_{speed}|} \]

where \(S_{anthropometric}\) is the set of subjects with similar anthropometry as the impaired individual (height: \(\)5cm, weight: \(\)5kg) and \(N_{speed}\) is the set of gait cycles where the able-bodied subjects in walked at similar speeds (\(\)0.1m/s) as that of the impaired individual. The reference timepoint \(k\) for computing a matching output for the impaired individual was based on the phase of the gait cycle.

Method

Our objective is to utilize a well-trained foundation model that has learned a variety of motion scenarios from physically capable individuals to predict the walking patterns of a lower-limb impaired individual's disabled limbs, all without fine-tuning or altering the model parameters. This involves reprogramming/correcting the inputs acquired from the impaired individuals by refurbishing them so that the foundation model is able to produce the desired motion variables from the limb-impaired individuals' inputs. Our method integrates retrieval with network inversion techniques, efficiently mapping impaired-individual inputs to able-bodied patterns and facilitating accurate motion prediction. It comprises three components: a _foundation_ module, a versatile multi-task model developed from data sourced from numerous able-bodied subjects; a _retrieval-augmented template mapping_ module, which computes the correction template for the queried impaired individual input; and a _refurbish_ module, designed to map the queried impaired individual input to the computed correction template. The _foundation_ module then predicts the desired motion of the disabled limb from the refurbished impaired individuals' inputs. Figure 1 summarizes this architecture. Below, we elaborate on each of the components.

### Foundation module

We train a foundation multi-task module using data from able-bodied individuals \((_{ab},_{ab})\), encompassing the different motion conditions. A fundamental difficulty in the realm of multi-task learning is finding a balance between utilizing the common patterns among multiple tasks while still preserving the adaptability needed to address the unique characteristics of each individual task. Our strategy involves constructing a predictive model, denoted as \(g(.)\), which comprises two distinct components: a shared core \(g_{s}\) with parameters \(_{s}\) that are shared across all tasks, and subsequently, task-specific layers \(g_{t}\) with parameters \(_{t}\). The holistic forecast for a given input instance \(X_{t,k}\), pertaining to the task \(t\) at the time point \(k\), is represented as \(g(X_{t,k},t;_{g}=\{_{s},_{t}_{t}\})=g_{t}(g_{s}(X_{t, k};_{s});_{t})\). For the shared core \(g_{s}\), we employ time convolutions . We deploy lightweight task-specific layers, \(g_{t}\), on top of the shared core, characterized by a two-layer multi-layer perceptron (MLP) with rectified linear unit (ReLU) nonlinearities. We compare architectures with task-specific final layers to a model without such task-specific parameters. In this alternate architecture, the output features \(g_{s}(X;_{s})\) of the shared core for any task are passed through a single prediction head \(g_{c}\) to produce the output motion variable. This comparison helps evaluate the efficacy of task-specific adaptations versus a unified approach in predicting motion variables across different tasks.

### Retrieval-augmented template mapping

Once the able-bodied model is trained, we use it to predict the motion variables for the lower-limb mobility-impaired subjects without retraining the model with the affected individual's data. To achieve this, we map the mobility-impaired individual's inputs \(X_{amp}\) corresponding to a desired output \(y_{amp}\) to a corrected input \(X_{corr}\) such that the model gives a similar output as the mobility-impaired individual's desired output for this corrected input (Fig. 1). We identify two methods for computing such a correction input \(X_{corr}\), namely _nearest neighbor search_ and _network inversion_.

**Nearest neighbor search.** A naive way of mapping the impaired individual's input to an able-bodied template is to use the able-bodied input \(X_{ab}\) for which the model gives the desired impaired individual's output \(^{k}_{amp}\) as the corrected input, that is,

\[X^{k}_{corr}=*{arg\,min}_{X_{ab} X_{ab}} f(X_{ab})- ^{k}_{amp} \]

, where the desired impaired individual's output \(^{k}_{amp}\) is computed from those able-bodied individuals sharing similar anthropometry (such as height, mass, and age) as that of the impaired individual.

However, an inherent problem of this approach is the ambiguity in the corrected input when similar values of desired output \(y_{amp}\) occur separated in time. This can lead to entirely different input values being mapped as correction inputs for similar input values of the limb-impaired individuals. For example, in the illustration in Fig. 2, consider we were searching for a \(X_{corr}\) for \(y^{k}_{amp}=0.6\) at \(t=0.6\). However, \(y^{k}_{amp}=0.6\) also occurs around \(t=0.2\) for which the correction input might be completely different from the one at \(t=0.6\).

One way to disentangle this problem would be to consider not a single \(y_{amp}^{k}\) value for computing the correction input, but a sequence of co-occurring values in a time of which the desired output \(y_{amp}^{k}\) is the midpoint (red region in Fig. 2). The algorithm now searches for a sequence of \(2m+1\) able-bodied inputs that would produce the desired sequence of mobility-impaired individual outputs \(\{y_{amp}^{k-m},...,y_{amp}^{k},...,y_{amp}^{k+m}\}\). This way, it becomes less probable that different able-bodied input sequences correspond to the same mobility-impaired individual output sequences. For example, the desired output \(y_{amp}^{k}\) at \(t=0.6\) in Fig. 2 falls in the region of decreasing values of \(y_{amp}\), whereas the other similar value at around \(t=0.2\) lies in the region of increasing \(y_{amp}\) values. These two output values, although similar, would thus have different able-bodied inputs associated with them for correction. The correction input \(X_{corr}^{k}\) in this case can be computed as

\[X_{corr}^{k}=*{arg\,min}_{X_{ab}^{i}}_{j=-m}^{m} f(X_{ ab}^{i-j})-_{amp}^{k-j} \]

In the previous approaches, we used a single value of able-bodied input as a correction template for the mobility-impaired individual. However, this approach may be prone to noise and overfitting. To deal with this, we propose an extension of our approach which integrates multiple able-bodied input values to form a correction template for the mobility-impaired individual. This is achieved by defining a \(\)-neighborhood (black ellipse in Fig. 1) around the able-bodied input for which the model prediction is closest to the desired mobility-impaired individual output (such an able-bodied input is obtained using either Eqn. 3 or Eqn. 4). The correction template is computed as a weighted sum of the able-bodied inputs within the \(\)-neighborhood. If \(X_{ab}^{i}\) be the closest able-bodied input around which the \(\)-neighborhood is defined, the correction template is given by

\[X_{corr}^{k}=_{j arg( X_{ab}-X_{ab}^{i})}w_{j}* X_{ab}^{j}. \]

where \(w_{j}\) is the weight associated with each of the able-bodied input \(X_{ab}^{j}\) in the \(\)-neighborhood. We define two types of weighting - linear and exponential - with the weight \(w_{j}\) of an able-bodied input sample \(X_{ab}^{j}\) decreasing linearly or exponentially as it moves away from the center \(X_{ab}^{i}\) of the \(\)-neighborhood. The weighting factor \(w_{j}\) is thus given by

\[w_{j}=1-^{j}-X_{ab}^{i}}{}&\\ exp(s*^{i}-X_{ab}^{j}}{})& \]

where \(s\) is a scaling factor that determines how fast the weight decreases as the sample \(X_{ab}^{j}\) moves away from the center of the \(\)-neighborhood. Other types of weighting (for example, uniform weighting of samples in the neighborhood) are also possible, but are out of scope of this work.

For simplicity, we consider only \(n\) closest neighbors within the \(\)-neighborhood for computing the correction template \(X_{corr}\). Since the inputs are normalized in \(\), \(\) is set to 0.01.

**Network inversion.** One limitation of the nearest neighbor search method detailed above is the requirement to store the complete training data used for training the foundation module, which increases the memory requirements. Although one can devise clever ways to store less data without affecting the accuracy, we propose directly retrieving the correction input \(_{corr}\) corresponding to the mobility-impaired individual's desired output, \(_{amp}\) from the pretrained foundation module. For the desired mobility-impaired individual output, \(y_{amp}^{k}\) at each time point \(k\), we generate a correction template \(X_{corr}^{k}\) such that,

\[X_{corr}^{k}=*{arg\,min}_{X} g(X)-_{amp}^{k} _{2}+ X_{corr}^{k}_{2} \]

where the \(\) is the regularization strength.

This approach draws inspiration from network-inversion techniques introduced by Linden and Kindermann  which involves finding a relevant input that produces a specific output from a neural network. This technique, leverages gradient-based optimization to iteratively adjust the input until the desired output is achieved.

### Refurbish module

We perform a data-level adaptation of the mobility-impaired individual inputs by learning a mapping from the corrupted mobility-impaired individual data \(X_{amp}\) (due to compensatory motion, asymmetric gait) to the correction template \(X_{corr}\) computed from the able-bodied data using the techniques mentioned in the previous section. To achieve this, we train a lightweight refurbish module \(h(.)\) characterized by a multi-layer perceptron with three hidden layers of 100 units each. Following three strategies are employed for training the refurbish module.

**Correction-based mapping.** The refurbish module \(h(.)\) is trained to map the mobility-impaired individual input \(X_{amp}\) to the corresponding computed correction \(X_{corr}\) by minimizing the MSE loss between the computed correction \(X_{corr}\) and refurbish module predicted correction \(_{corr}=h(X_{amp};_{h})\). The loss function is

\[_{input}=_{X_{amp},X_{corr}_{amp}^{train}}\|h(X_{ amp};_{h})-X_{corr}\| \]

where \(_{amp}^{train}\) is the training dataset consisting of mobility-impaired individual inputs and corresponding correction templates. The correction template \(X_{corr}\) may be computed using either nearest _neighbor search_ or _network inversion_, detailed in the previous section.

**Target-based mapping.** In this case, the input to map to is not explicitly determined, instead the refurbish module optimizes its parameters to produce the target directly, given the frozen foundation module. The refurbish module \(h(.)\) is trained to minimize the MSE loss between the predictions of the pretrained foundation module \(g(.)\) when it is fed with the refurbish module's outputs and the desired target values of the mobility-impaired individual \(y_{amp}\). In this strategy, the computed correction templates are completely ignored, and the model is trained solely to reproduce the final desired target. The loss function becomes

\[_{target}=_{X_{amp},y_{amp}_{amp}^{train},}_{amp}^{train}}\|g(h(X_{amp};_{h});_{g}^{*})- _{amp}\| \]

where \(}_{amp}^{train}\) is the training dataset consisting of desired outputs for mobility-impaired individuals. The foundation module \(g(.)\) is pretrained using the data from multiple able-bodied subjects, and its parameters \(_{g}^{*}\) are kept fixed. Only the parameters \(_{h}\) of the refurbish module \(h(.)\) are varied using this loss function.

**Hybrid.** This is a combination of the correction-based and target-based training strategies. The loss function used to train the mapping model \(h\) is a weighted combination of the error between the predicted correction \(_{corr}=h(X_{amp})\) for the mobility-impaired individual input \(X_{amp}\) and its computed correction \(X_{corr}\) and the error between foundation module predictions on mapping model outputs, \(_{amp}=g(h(X_{amp}))\) and the desired output values of the mobility-impaired individual \(_{amp}\). Thus, the hybrid loss function is,

\[_{total}=*_{input}+*_{target} \]

where \(\) and \(\) are the factors that influence the effect of input-based loss and target-based loss respectively on the final loss. Based on which correction strategy is used, the hybrid strategy can take two forms - **hybrid (neighbor)** and **hybrid (inversion)**.

## 5 Experiments

### Baselines

We assess our proposed method's effectiveness against three baseline approaches:

**Cross-mapping (zero-shot transfer).** Here, we directly apply the foundation model \(g(.)\) to predict motion variables for mobility-impaired individual subjects, without retraining the foundation module or utilizing the refurbish module to transform mobility-impaired individual inputs into clean data. This is akin to zero-shot transfer, where the pretrained model is used to predict output trajectoriesfrom impaired inputs without any training. Since no training was involved, it was not possible to report scores for cross-mapping with different training ratios.

**Direct-mapping.** In direct mapping, we used a refurbish module \(h(.)\) in front of the pretrained model \(g(.)\). The model learns to directly map the impaired individual's inputs \(X_{amp}\) to the desired motion variables \(_{lamp}\). During learning, the pretrained model is frozen, whereas the refurbish module is tunable.

**Fine-tuning (transfer learning).** In finetuning, no refurbish module is used, and the foundation module \(g(.)\) pre trained on able-bodied data is finetuned to learn a mapping from impaired individual inputs \(X_{amp}\) to the desired motion variables \(_{amp}\).

### Ablation results

**Foundation module architectures.** Our initial analysis focused on how the architecture of the foundation module impacts prediction performance across various training strategies. As depicted in Fig. 3, we examined the foundation modules equipped with task-specific and task-shared prediction heads in predicting desired motion variables for mobility-impaired individuals across different tasks. For direct mapping and refurbished inputs with target-based and hybrid correction, models featuring task-specific heads outperformed those with shared prediction heads when the training data was limited. However, as the training dataset size increased, the performance of both models converged to similar levels. Interestingly, a reverse trend emerged when mobility-impaired individual inputs were refurbished with a target-based trained refurbish module. Models with shared prediction heads performed better for the smallest training data sizes, while those with task-specific layers performed better with larger training datasets. In summary, task-specific foundation models consistently demonstrated superior prediction performance when compared to their task-shared counterparts.

Figure 4: (Left) Effect of weightage \(\) of the target-based loss on the performance of models with task-specific prediction heads trained with hybrid strategy for refurbishing. The weightage \(\) of input-based loss is set to be 1. The blue curve on the left (\(\) = 1, \(\) = 0) represents purely neighbor-based refurbishing. (Right) Effect of sequence length \(2m+1\) and number of nearest neighbors \(n\) on the performance of models with shared and task-specific prediction heads trained using input-based and hybrid strategies. For hybrid strategy, \(=1\) and \(\) = 20 was selected. The combination which gave the best prediction performance in each case is marked with a red square (Please note that there exists multiple combinations which gave similar accuracies).

Figure 3: Effect of foundation model architecture on the performance for different training strategies. (task-shared: model with shared backbone and a common prediction head for all tasks, task-specific: model with shared backbone and task-specific heads)

**Effect of weightage \(\) of target-based loss.** In the hybrid training strategy of the refurbish module, we adopted a loss function that is a weighted sum of the correction-based and target-based loss. We next analyzed how the weights assigned to the loss functions affect the performance of the task-specific foundation modules. We set the weightage for correction-based loss to be 1 and varied the weightage \(\) of the target-based loss. We found that the model performance increases for higher weightage of target-based loss for refurbish model training. However, as the weightage \(\) increases, the prediction performance shows a converging trend (Fig. 4 left).

**Effect of sequence length \(2m+1\) and number of neighbors \(n\).** In the nearest neighbor search method for computing the correction template \(X_{corr}\), we proposed a strategy for using a sequence of desired motion variables for the mobility-impaired individual \(\{y^{k-m}_{amp},...,y^{k}_{amp},...,y^{k+m}_{amp}\}\) to compute the correction template \(X^{k}_{corr}\) for the \(k\)-th mobility-impaired individual input \(X^{k}_{amp}\). Another strategy that we propose is to use a \(\)-neighborhood around the able-bodied input sample \(X^{i}_{ab}\) that is closest to the input required to produce the desired mobility-impaired individual motion variable \(y^{k}_{amp}\) at time point \(k\). The correction template should be computed as a weighted sum of \(n\) nearest neighbors of \(X^{i}_{ab}\) within the \(\)-neighborhood (where weights decrease linearly or exponentially as the distance from \(X^{i}_{ab}\) increases). We investigated the effect of the sequence length \(2m+1\) and number of nearest neighbors \(n\) used for computing the correction template on the performance of models in predicting the desired motion variables for mobility-impaired individuals across locomotion tasks (Fig. 4 right). Most of the cases evaluated worked better than the basic case of single sample matching and single neighbor (\(2m+1=1,n=1\)). For models with task-shared prediction heads, better performances were obtained with lower sequence length \(2m+1\) and higher number of neighbors \(n\) for both correction-based and hybrid methods. For models with task-specific prediction heads, correction-based correction performed better with larger sequence length and larger number of neighbors lead to better performance for whereas hybrid strategy worked better with a smaller sequence length and larger number of neighbors. Interestingly, hybrid (neighbor) strategy did not require matching a larger sequence of outputs, possibly because it also makes use of target-based correction. Nevertheless, sampling multiple neighbors from the \(\)-neighborhood of \(X^{i}_{ab}\) was still necessary to improve the prediction performance. A exponentially decreasing weighting performed better for neighbor-based correction strategy, whereas a linearly decreasing weighting worked better for hybrid strategy. For further analyses and comparisons, we use the sequence length, number of neighbors' and weighting values that gave the best prediction scores with neighbor-based and hybrid (neighbor) computed correction templates.

**Training strategies.** Finally, we examined the impact of various training strategies on model performance (Fig. 5 left and Tab. 1). Across all these strategies, we observed a general improvement in prediction scores as the training sample size increased. There was a slight drop in accuracy when using very large training sample sizes, likely due to overfitting. Both the hybrid strategies - hybrid (neighbor) and hybrid (inversion) -- which combined correction-based and target-based mapping, consistently delivered accurate predictions across different training sample sizes. Notably, for the

Figure 5: (Left) Performance of models trained with different strategies. For hybrid strategies, \(=1\) and \(\) = 20 was selected. For neighbor-based strategies, \(m\) and \(n\) were selected based on the best-performing values computed in the previous section. (Right) The correction template \(X_{corr}\) computed using different strategies and the corresponding predictions from the refurbish module. For target-based strategy, no correction template was computed, and the visualization shows the output of the refurbish module in this case.

smallest amount of training data tested, the hybrid strategy outperformed the direct mapping and fine-tuning approaches. With task-shared prediction heads, hybrid reprogramming showed a slight improvement (\( 7\%\)) over direct mapping, while for task-specific prediction heads, it exhibited a more pronounced improvement (\( 16\%\)). These results suggest that our proposed input refurbishing strategy offers an efficient means to adapt a pretrained model for new scenarios, especially when dealing with limited training data.

While direct mapping performs well in predicting motion variables for the specific mobility-impaired individual it was trained on, it requires a larger dataset to achieve the same performance level as the model reprogramming approach. Additionally, direct mapping relies on limited data from mobility-impaired individuals, reducing exposure to diverse motion conditions and leading to limited generalization capabilities. This limitation is critical for mobility-impaired individual motion prediction models, as gait patterns may change as mobility-impaired individuals adapt to generated motion. This adaptation could result in improved compensatory motions and gait normalization. In contrast, an able-bodied model trained on a wide array of motion scenarios from various individuals may be more adaptable to evolving mobility-impaired individual gait patterns while accommodating the predicted joint motion required for prosthetic walking. Our approach also outperformed model fine-tuning in the low-data regime, showing an improvement of approximately \( 11\%\) for task-shared models and \( 13\%\) for task-specific models, underlining the effectiveness of the proposed approach over other model repurposing methods like transfer learning.

Visualization of the computed correction templates \(X_{corr}\) and corresponding predictions from the refurbish module (Fig. 5 right) shows that, despite the refurbish module being a simple three-layer MLP (chosen for its lightweight and data-efficient properties), it can reconstruct the correction templates with considerable accuracy. Interestingly, the correction templates computed by the neighbor search and network inversion strategies were notably different, despite having the same desired output. This discrepancy arises because neighbor search finds the closest match from available data points, introducing variability based on the dataset, while network inversion uses gradient-based optimization to iteratively minimize error, leading to different solutions. The same variability was observed with target-based mapping, which directly optimizes towards the target output without generating intermediate correction templates.

**Limitations** The desired motion variables for mobility-impaired individual subjects were derived from able-bodied individuals with similar anthropometric features and walking speed as that of the mobility-impaired individual subjects. While this approximation may effectively represent the reference joint's desired motion, its suitability for practical applications such as controlling powered prostheses requires validation. Nevertheless, our approach possesses a generic capability to transform inputs in a way that can generate any desired output from a pretrained model, provided there exists a learnable relationship between the inputs and the desired outputs.

## 6 Conclusion and Broader Impact

In this study, we proposed ReMAP, a model repurposing strategy that leverages deep learning's reprogramming property, incorporating network inversion principles and retrieval-augmented mapping. Our approach adapts models originally designed for able-bodied individuals to forecast joint motion in limb-impaired patients without altering model parameters. Our findings indicate that the proposed input refurbishing strategy offers a sample-efficient mechanism for adapting pretrained models to new scenarios. The proposed model reprogramming approach for adaptive motion forecasting has the potential to significantly enhance the quality of life for individuals with mobility impairments. By leveraging well-trained models from able-bodied data, this method can efficiently predict joint motions for mobility-impaired individuals, aiding in the development of more responsive and accurate

    & cross & direct & fine & neighbor & network & target & hybrid & hybrid \\  & mapping & mapping & tuning & search & inversion & based & (neighbor) & (inversion) \\  task-shared & -0.35 ± 0.16 & 0.77 ± 0.2 & 0.73 ± 0.22 & 0.33 ± 0.11 & 0.23 ± 0.07 & 0.39 ± 0.25 & **0.84 ± 0.07** & **0.83 ± 0.09** \\ task-specific & -0.32 ± 0.48 & 0.71 ± 0.14 & 0.74 ± 0.22 & 0.19 ± 0.22 & 0.39 ± 0.25 & 0.61 ± 0.22 & **0.86 ± 0.07** & **0.87 ± 0.09** \\   

Table 1: Coefficient of determination (\(R^{2}\)) obtained with different training strategies for a train sample ratio of 0.1assistive devices such as prostheses and orthoses. This approach minimizes the need for extensive retraining, making it both cost-effective and accessible for personalized healthcare applications. Furthermore, this technique is versatile and can be applied to other regression problems in domains where data scarcity presents a challenge.