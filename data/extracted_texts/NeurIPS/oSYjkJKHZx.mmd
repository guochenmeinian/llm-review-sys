# Neural Harmonics: Bridging Spectral Embedding and Matrix Completion in Self-Supervised Learning

Marina Munkhoeva

Correspondence to marina.munkhoeva@tuebingen.mpg.de Max Planck Institute for Intelligent Systems, Tubingen, Germany Artificial Intelligence Research Institute (AIRI), Skolkovo Institute of Science and Technology (Skoltech), Moscow, Russian Federation

Ivan Oseledets

Correspondence to marina.munkhoeva@tuebingen.mpg.de

###### Abstract

Self-supervised methods received tremendous attention thanks to their seemingly heuristic approach to learning representations that respect the semantics of the data without any apparent supervision in the form of labels. A growing body of literature is already being published in an attempt to build a coherent and theoretically grounded understanding of the workings of a zoo of losses used in modern self-supervised representation learning methods. In this paper, we attempt to provide an understanding from the perspective of a Laplace operator and connect the inductive bias stemming from the augmentation process to a low-rank matrix completion problem. To this end, we leverage the results from low-rank matrix completion to provide theoretical analysis on the convergence of modern SSL methods and a key property that affects their downstream performance.

## 1 Introduction

Self-supervised methods have garnered significant interest due to their heuristic approach to learning representations that capture the semantic information of data without requiring explicit supervision in the form of labels. Contrastive learning based methods among the former would use the repulsion among arbitrary pair of points in the batch, while non-contrastive would rely on the consistency among different views of the same image. While self-supervised representation learning becomes more ubiquitous in the wild, especially in the important domain such as medical imaging , the theoretical grounding of these methods would potentially help avoid the pitfalls in applications. Unsurprisingly, researchers are already trying to build theoretically sound understanding of modern self-supervised representation learning methods.

The overall goal of this work is to understand self-supervised representation learning through the lens of nonlinear dimensionality reduction methods (e.g. Laplacian Eigenmaps ) and low-rank matrix completion problem . To this end, we take on a Laplace operator perspective on learning the optimal representations in the manifold assumption. We then derive a trace maximization formulation to learn eigenfunctions of the Laplace operator of the underlying data manifold. We adopt the heat kernel based embedding map that in theory under certain conditions is an almost isometric embedding of the low-dimensional manifold into the Euclidean space. As a result, we discuss how existing several SSL methods (e.g. SimCLR , BarlowTwins , VICReg) can be comprehended under this view.

It is important to note that our current understanding of the topic lacks one crucial aspect. Traditional spectral methods commonly operate with complete kernel matrices, whereas our approach deals with incomplete and potentially noisy ones. The only available similarity information among examples is derived from the data augmentation process, which generates a positive pair. Meanwhile theremaining examples in the batch are either seen as negative ones (contrastive) or are not considered at all (non-contrastive).

A pertinent and often overlooked question emerges: how can self-supervised learning methods effectively leverage such limited signals to converge towards meaningful representations? In response, we shed light on this matter by establishing a connection between SSL and a matrix completion problem. We demonstrate that these optimization problems are Lagrangian dual of each other, implying that optimizing the SSL objective simultaneously entails reconstructing the kernel matrix. We can summarize the contributions of this paper as follows:

* We propose an eigen-problem objective for spectral embeddings from graphs induced by augmentations and use it to interpret modern SSL methods.
* We show that SSL methods do _Laplacian-based nonlinear dimensionality reduction_ and _low-rank matrix completion_ simultaneously. We leverage theory behind matrix completion problem to provide insights on the success of SSL methods and their use in practice.
* While the number of observed entries required by theory decreases with epochs, we find that the actual number is a constant and the former eventually intersects the latter.
* We find a possible explanation for disparity in downstream performance of the backbone and projection outputs.

## 2 Background

This work relies on the manifold hypothesis, a hypothesis that many naturally occurring high-dimensional data lie along a low-dimensional latent manifold inside the high-dimensional space. Since we can only observe a sample from the manifold in the ambient space, neither the true manifold nor its metric are available to us. Although we never explicitly work with Laplace-Beltrami operator, we still give a brief definition below to provide some grounding for the reasoning later.

Laplace operatorLet \(\) be a Riemannian manifold and \(g\) be the Riemannian metric on \(\). For any smooth function \(u\) on \(\), the gradient \( u\) is a vector field on \(\). Let \(\) be the Riemannian volume on \(\), \(d=\,dx^{1} dx^{D}\). By the divergence theorem, for any smooth functions \(u\) and \(v\) (plus smooth and compact support assumptions) \(_{}u\, v\,d=-_{}  u, v d,\) where \(,=g(,)\). The operator \(=\) is called the Laplace-Beltrami operator of the Riemannian manifold \(\).

In practice, we usually work with finite samples, and Laplace operator is typically approximated with graphs or meshes. While the latter are typically used in computational mathematics, the former find a widespread use in machine learning. Below is a brief overview of the relevant graph notions, for a detailed exposition please see .

Graph Laplacian and Spectral EmbeddingGiven a graph \(=(V,E)\) with \(|V|=n\) vertices and a set of edges \(e_{ij}=(v_{i},v_{j})\) that form a weighted adjacency matrix \(_{ij}=w_{ij}\) with non-negative weight \(w_{ij} 0\), whenever there is \(e_{ij} E\), otherwise \(0\). With a degree matrix \(=()\), the graph Laplacian is given by \(=-\), the corresponding random walk Laplacian is a normalization \(_{rw}=-^{-1}\). All graph Laplacians admit an eigenvalue decomposition, i.e. \(=^{}\), where \(^{n n}\) contains eigenvectors in columns and a diagonal matrix \(^{n n}\) has eigenvalues on the diagonal. Note that there is a trivial eigenpair \((0,)\). [5; 4] show that the eigenvectors of the graph Laplacian of a point-cloud dataset converge to the eigenfunctions of the Laplace-Beltrami operator under uniform sampling assumption.

Figure 1: Illustrative graph of the theoretical fraction \(p^{*}\) of the observed entries required for matrix completion to succeed with high probability. As training proceeds, unmaterialized kernel matrix size \(n\) increases and \(p^{*}\), which is roughly \( n/n\), decreases. Eventually, the actual (constant) fraction \(p\) of observed entries under self-supervised learning augmentation protocol intersects the theoretical bound.

Whenever one has an affinity matrix, a positive semidefinite pairwise similarity relations among points, the classical way to obtain embeddings for the points is to perform spectral embedding. A typical algorithm would include constructing a graph based on the affinity matrix, computing \(k\) first eigenvectors of its Laplacian and setting the embeddings to be the rows of the matrix \(^{n k}\) that contains the eigenvectors as columns.

Matrix completionLet \(^{n n}\) is partially observed matrix with rank \(r\). Under Bernoulli model, each entry \(_{ij}\) is observed independently of all others with probability \(p\). Let \(\) be the set of observed indices. The matrix completion problem aims to recover \(\) from \(m=||\) observations. The standard way to solve this problem is via nuclear norm minimization:

\[_{^{n n}}\|\|_{*}_{ij}=_{ij}(i,j),\] (1)

where \(\|\|_{*}\) is the nuclear norm of \(\), i.e. the sum of its singular values. A large body of work [8; 28; 27; 10] has succeeded in providing and enhancing of the conditions that guarantee the optimal solution \(^{*}\) to be both unique and equal to \(\) with high probability.

NotationAny matrix \(^{n_{1} n_{2}}\) has a singular value decomposition (SVD) \(=^{}\), where the columns of the matrix \(^{n_{1} n_{1}}\) are left singular vectors, the singular values \(_{1}_{2}_{(n_{1},n_{2})}\) lie on the diagonal of a diagonal matrix \(^{n_{1} n_{2}}\), and right singular vectors are the columns of \(^{n_{2} n_{2}}\). \(\|\|_{F}\), \(\|\|=_{1},\ \|\|_{*}=_{i}_{i}\) denote Frobenius, spectral and nuclear norms of \(\), respectively. \(\|\|_{p}\) denotes \(p\)-th vector norm.

## 3 SSL and Spectral Embedding

In this section, we will provide a construction that covers most of the self-supervised learning methods and gives SSL a novel interpretation. First, we formalize the setup from the perspective of the manifold hypothesis. Then, we make some modelling choices to yield an SSL formulation as a trace maximization problem, a form of eigenvalue problem. Finally, we describe how three well known representatives SSL methods fall under this formulation.

Let \(^{n d^{}}\) be a set of \(n\) points in \(^{d^{}}\) sampled from a low-dimensional data manifold observed in a \(d^{}\)-dimensional ambient Euclidean space. However, data is rarely given in the space where each dimension is meaningful, in other words \(d^{} d^{*}\), where \(d^{*}\) is unknown true dimensionality of the manifold. The goal of nonlinear dimensionality reduction is to find a useful embedding map into \(d\)-dimensional Euclidean space with \(d d^{}\). Two of the classical approaches, namely Eigenmaps  and Diffusion maps , use eigenfunctions of the graph Laplacian, an approximation of the Laplace operator associated with the data manifold. Both can be loosely described as a variant of map

\[()=[\ _{1}()_{2}() _{d}()\ ],\] (2)

where \(_{k}\) is \(k\)-th eigenfunction of the negative Laplace operator on the underlying manifold.

This type of map bears a direct connection to theoretical question how to find an embedding of certain types of manifolds into Euclidean spaces, studied in differential geometry. For instance,  construct embedding for a given smooth manifold by using its heat kernel. This approach has been subsequently enhanced through the application of a truncated heat kernel expansion. Furthering this trajectory,  explore whether and when such embedding is close to being isometric, which is desirable as isometric embedding preserves distances.

Motivated by the heat kernel embedding literature, we provide a general construction for self-supervised methods in what follows. The heat kernel on a manifold can be represented as an expansion \(H(p,q,t)=_{k=0}^{}e^{-_{k}t}_{k}(p)_{k}(q)\), where \(p\) and \(q\) are some points on the manifold, \(t>0\) and \(_{k}\) are normalized eigenfunctions of the Laplace operator, i.e. \(-_{k}=_{k}_{k}\) and \(|_{k}|_{2}=1\). However, working with finite data, we can only operate with a graph approximation of the manifold, and will make use of the heat kernel construction for graphs. The latter is given by a matrix exponential \(_{t}=e^{-t}\), alternatively represented through an expansion \(_{t}=_{i=0}^{n}e^{-_{k}t}_{k}_{k}^{T}\), where \(\) is a graph Laplacian and \((_{k},_{k})\) is \(k\)-th eigenpair of \(\).

Consider Laplacian EigenMaps method, it first constructs a graph and weighs the edges with a heat kernel of the Euclidean space which takes the form of a Gaussian kernel \(h_{E}(,,t)=(-||-||_{2}^{2}/t)\) whenever the distance is less then some hyperparameter, i.e. \(||-||_{2}<\), or \(\) is among \(k\) nearest neighbours of \(\). Next, the method proceeds with finding the eigenvectors of the graph Laplacian constructed from the thus weighted adjacency matrix \(\).

Contrarily, the proposed construction acknowledges the cardinality and complexity typically associated with the modern day datasets, where it is challenging to select the cutoff distance or the number of neighbours, and impractical to compute all pairwise distances. Our ideal graph has edges reflecting the semantic similarity between points; e.g. there is an edge whenever the pair of points belong to the same class. The drawback is that this matrix is unknown. This is where augmentation comes into play as it provides a peek into only a fraction of the entries in the unmaterialized heat kernel matrix. Consequently, we claim that SSL implicitly solves a low-rank matrix completion problem by instantiating some of the pairwise similarity entries in \(_{t}\) via the augmentation process. However, prior to this, we need to demonstrate the generality of the perspective we have formulated. To accomplish this, we articulate a trace maximization problem.

### Trace Minimization

To start, we construct an unmaterialized heat kernel matrix in accordance with the standard self-supervised learning protocol for augmentations. Given a dataset with \(N\) points, one training epoch generates \(a\) views of each point. Typically, \(a=2\) and training runs for \(n_{epochs}\) number of epochs. The whole training generates exactly \(n_{epochs} a\) views per original instance. As a result the total number of processed examples is \(n=N a n_{epochs}\), thereby we have that \(_{t}^{n n}\).

As a rule, SSL utilises architectures with a heavy inductive bias, e.g. ResNet  / Vision Transformers  for image data. Thus, we may safely assume that the same instance views are close in the embedding space and are connected. This results in a block diagonal adjacency matrix \(\), where \(i\)-th block of ones accounts for all the views of \(i\)-th image among \(N\) original images. The fraction of observed entries equal to \(p=N(n_{epochs} a)^{2}/n^{2}=1/N\), a constant fraction for a given dataset.

Note that in the ideal scenario, we would know the cluster/class affiliation for each point and would have connected same-class views with edges. However, in reality, we only know instance affiliation of each view. Let us denote the ideal scenario heat kernel matrix as \(_{t}\) and its partially observed counterpart used in reality -- \(}_{t}\).

To obtain the heat kernel matrix, we use the normalized random walk Laplacian \(_{rw}\), for which the heat kernel matrix is as before: \(_{t}=(-t_{rw})=_{k=0}^{n}(-_{k}t) _{k}_{k}^{},\) where \(_{k}\) is \(k\)-th eigenvector and \(_{k}\) a corresponding eigenvalue of \(_{rw}\). To obtain spectral embeddings from an ideal \(_{t}\), one would then proceed with solving a trace minimization form of eigenvalue problem in (3), where the optimal solution is exactly the eigenvectors of \(_{rw}\), i.e. \(^{*}=\).

\[_{}&(^{}_{t})&_{}&(_{}^{} {}_{t}_{})\\ &^{}=,&&_{ }^{}_{}=_{d},\ _{}^{}=,\] (4)

However, for lack of a better alternative we resort to the incomplete \(}_{t}\) and need to learn a parameterized map \(_{}()=_{}\) in (4). Apart from the specified eigenfunction pairwise orthogonality constraint, the resulting loss is comprised of implicit constraints on the trivial eigenfunction (identity) and function norm. But before we treat (3) with incomplete \(_{t}\) as matrix completion problem, we show that this formulation can be seen as a generalization for a number of existing self-supervised learning methods. Specifically, several modelling choices differentiate the resultant methods.

### Self-Supervised Methods Learn Eigenfunctions of the Laplace Operator

SimCLRConsider the following contrastive loss, variants of which are widely adopted in self-supervised learning methods: \(L_{CL}=_{i,j+pairs}l_{ij}+l_{ji}\), where

\[l_{ij}=_{i},_{j}}}{ _{k i}e^{_{i},_{k}}}= _{i},_{j}-_{k i}e^{ _{i},_{k}},\] (5)with \(_{i}=f_{}(_{i})\) is an embedding of input \(_{i}\) given by function \(f\) parameterized by a neural network with learnable parameters \(\), which produces unit-norm embeddings, i.e. \(||_{i}||_{2}=1\). One iteration of SimCLR takes a batch of \(N\) data points and creates \(2N\) views, augmenting each sample to obtain a positive pair (\(_{i},_{j}\)), while treating all the other samples and their augmentations as contrastive samples \(_{k}\).

Let us include \(k=i\) in the sum in denominator of (5) for a moment. A goal of SimCLR is to obtain optimal representations \(^{2N d}\) such that for each positive pair \((i,j)\), their representations will be aligned as much as possible \(_{i},_{j} 1\). Let \(_{ij}=([^{}]_{ij})\) and \(=()\), then we can rewrite (5) as

\[l_{ij}=_{ij}-_{k=1}^{2N}_{ik}=_ {ij}-_{ii}=_{ij}}{_{ii}}=[ ^{-1}]_{ij}\] (6)

where we are interested in the right hand side \([^{-1}]_{ij}\). Let us note that \([^{-1}]_{ij}\) from (6) is a normalized adjacency of a graph \(G=(V,E)\), where node set \(V\) is the set of views. Since representations live on a unit \((d-1)\)-sphere, we have a choice of naturally arising distributions (von Mises-Fisher, spherical normal, etc) to instantiate the weighting function \((_{i},_{j})\). The model choice of SimCLR is to instantiate the weighting function with the density of the von Mises-Fisher distribution with \(>0\) (without the partition function):

\[_{ij}=(_{i}^{}_{j}),\] (7)

where \(_{ij}\) equals \(^{}\), with a typical value \(=2\), whenever \(i,j\) is a positive pair, and \(e^{0}=1\) otherwise. Note that \((^{-1})=^{-1}-+o(( ^{-1})^{2})-_{rw}\), thus in loose terms the objective in (5) maybe be seen as a minimization of a trace of a negative of the graph Laplacian by learning \(\)'s that shape \(\).

Decoupled Contrastive Learning  can be seen as reweighting the adjacency matrix by setting \(_{ij}=w(z_{i},z_{j})\), where \(w(z_{i},z_{j})\) is a reweighting function to emphasize hard examples.

For non-contrastive methods (BarlowTwins, VICReg, etc) SSL methods (where no negative examples are used, e.g. BarlowTwins, SimSiam), the respective losses could also be interpreted as learning a diffusion map. The key distinction with contrastive methods expresses itself in setting \(A_{ij}=0\) for view pairs \((i,j)\) that do not have shared original, thus eliminating any signal from a possibly negative pair.

BarlowTwinsmethod normalizes the columns of representation matrices \(_{a},_{b}^{N d}\), which is the same as the function norm constraint in (4). The overall objective is as follows:

\[J=_{ii}(_{a}^{}_{b}-)_{ii}^{2}+ _{i j}(_{a}^{}_{b}-)_{ij}^{2},\] (8)

and simultaneously aims at three things: (i) enforce the closeness of the rows, i.e. positive pair embeddings, (ii) restrict the norm of the columns, i.e. the eigenfunctions, (iii) orthogonalize columns, again the eigenfunctions. The kernel matrix choice in BarlowTwins is a simple bi-diagonal adjacency matrix \(_{ij}=1\) as long as \((i,j)\) is a positive pair, and 0 otherwise.

VICRegobjective is a weighted sum of _variance, covariance_ and _invariance_ terms:

\[J_{var}=_{k=1}^{d}(0,1-^{}]_{kk}}), J _{cov}=_{k l}[^{}]_{kl}^{2}, J_{inv}= _{ij}_{ij}\|_{i}-_{j}\|^{2},\]

a similar formulation to the previous method, however, the choice for the adjacency matrix here is little bit different. Individual terms of this loss have separate coefficients. The choice of these hyperparameters defines the implicit adjacency matrix entries, controls the maximum function norm allowed and the trade-off between orthogonality and the trace terms in (4).

## 4 SSL and Low-Rank Matrix Completion

In this section, we use low-rank matrix completion theory to show that the limited information from augmentations might be quite enough under certain conditions. First, we establish the connection between our self-supervised learning objective (4) and the low-rank matrix completion problem. We then draw practical insights from the existing convergence theory for matrix completion problem.

### Low-Rank Matrix Completion Dual

We argue that the objective in (3) with a substitute incomplete kernel matrix \(}_{t}\) implicitly contains an objective for the low-rank matrix completion problem. To show this, we first introduce the general form of the nuclear norm minimization problem with affine subspace constraint in (9).

\[_{} \|\|_{*}\] (9) subject to \[()=, _{} ^{}\] (10) subject to \[()=,  \|^{*}()\| 1,\]

The subspace is given by linear equations \(()=\) and linear operator \(:^{n n}^{p}\) can be a random sampling operator. The dual for the nuclear norm \(||_{*}\) is the operator norm \(||\). The problem in (9) has been initially introduced as a heuristic method for seeking minimum rank solutions to linear matrix equations, but has later been shown to have theoretical guarantees under certain conditions on the linear operator \(\). The Lagrangian dual of (9) is given by (10), where operator \(^{*}:^{p}^{n n}\) is the adjoint of \(\).

We write down an instance of (9) in (11) below to better reflect the specifics of our setting. Since the true underlying heat kernel matrix \(_{t}\) is observed only _partially_ with known entries indicated by a collection of index pairs \(\) induced by augmentation process, we can form a sampling symmetric matrix \(\): \(_{ij}=1\) if \((i,j)\), and \(0\) otherwise, indicating observed entries. Now, the incomplete kernel matrix can be written down explicitly as \(}=\), where \(\) denotes Hadamard (element-wise) product. The constraint in (9) instantiates as \(()=()\).

\[_{_{+}} \|\|_{*}\] (11) subject to \[()=(})\] subject to \[^{}=\]

We proceed by showing that maximisation of the trace formulation in (12) embraces reconstruction of the incomplete underlying kernel matrix with entries known to us only from the augmentation process and specified by the matrix \(\).

**Proposition 4.1**.: _The trace maximization problem given in (12) is a Lagrangian dual of low-rank matrix completion problem in (11)._

Proof.: First, we show that (12) is an instance of (10). Let linear operator \(():^{n n}^{n^{2}}\) be a sampling vectorization of \(()\). By trace of a matrix product, we can rewrite the objective as \([^{}}]=[ }^{}]=(})^{}(^{})=^{ }\).

The adjoint operator \(^{*}()=(_{})\) acts a sampling matricization, i.e. it samples and maps \(\) back to \(^{n n}\): \(^{*}()=^{}\), and the constraint of the dual (10) becomes \(\|^{}\| 1\). As \(\) admits singular value decomposition \(=^{}\), the constraint in (12) \(^{}=\) implies \(_{i}()=1\) for all \(i\).

To establish equivalence of the constraints in (10) and (12), i.e. \(\|^{}\|=_{1}( ^{}) 1\) given \(\) and \(_{1}()=1\), we can use a result for singular values of Hadamard product [], specifically, for \(k=1,2,,n\): \(_{i=1}^{k}_{i}()_{i=1}^{k}(c_ {i}(),r_{i}())_{i}()\), where \(c_{i}()\) and \(r_{i}()\) are column and row lengths of \(\), and \(_{1}_{2}_{n}\). Let \(=\) and \(=^{}\), then \(r_{i}=c_{i}=\), yielding \(_{1}(^{})\), where \(K=n_{epochs} a\) is a constant, consequently, it can be accounted for by rescaling \(\) and not affecting the maximization. Finally, since (11) is an instance of (9), we can conclude that (12) is dual to (11). 

This result allows us to make use of theoretical guarantees obtained in matrix completion in what follows.

### Convergence

IncoherenceStandard incoherence  is the key notion in the analysis of matrix completion problem. Intuitively, incoherence characterises the ability to extract information from a small random subsample of columns in the matrix. More formally, it is defined as an extent to which the singular vectors are aligned with the standard basis.

**Definition 4.2**.: Given matrix \(^{n_{1} n_{2}}\) with rank \(r\) and SVD \(=^{}\), \(\) is said to satisfy the _standard incoherence_ condition with coherence parameter \(\) if

\[_{1 i n_{1}}\|^{}_{i}\|_{2}}}\,_{1 j n_{2}}\|^{}_{j}\|_{2} }}\,\] (13)

where \(_{i}\) is the \(i\)-th standard basis vector of a respective dimension.

Since the matrix we aim to recover is symmetric, \(n_{1}=n_{2}=n\) and its left, right singular and eigenvectors are identical. The coherence parameter \(=_{i}\|_{i}\|_{2}^{2}\) range from \(1\) (incoherent) to \(\) (coherent).

To the best of our knowledge, optimal sample complexity bounds for matrix recovery via nuclear norm minimisation were obtained in . Specifically, given \(\) satisfies standard incoherence condition (13) with parameter \(\), if uniform sampling probability \(p^{*} r^{2}(n)}}{{n}}\) for some \(c_{0}>0\), then \(\) is the unique solution to (1) with high probability.

Matrix recovery is easy when it is highly incoherent -- when information is spread more uniformly among its columns/rows, loosing a random subset of its entries is not as big of a deal as when information is concentrated in certain important columns/rows. On the other hand, high incoherence intuitively makes matrices harder when used as feature matrices in downstream tasks. This might explain why typical SSL methods rely on the output of backbone network (_representations_) rather than the output of projection head (_embeddings_).

It is easy to see that downstream performance depends on the alignment of the target matrix \(\) with the left eigenvectors of the feature matrix \(\). The target matrix \(\) in downstream classification task is typically a very simple binary matrix, and can be shown to have low incoherence. However, whenever \(\) is obtained as the projection head output of a network learned via self-supervised learning method with a spectral embedding type objective, the incoherence of \(\) is inherently tied to the incoherence of the kernel matrix. The latter needs to have high incoherence to be recoverable. Consequently, we put forward the following proposition and find its empirical support in Section 5.2.

**Proposition 4.3**.: _Projection head outputs (embeddings) yield lower performance on the downstream task due to their high incoherence. The complexity of the projection head correlates with coherence of the backbone output (representations)._

Only a fraction of total entries in \(_{t}\) is required for matrix recovery with high probability.We can further narrow down the bound on \(p^{*}\) if we consider structured matrix completion problem in the form of some side information which has a direct connection to self-supervised setup. Let the column/row space of \(\) lie in some known \(r^{}\)-dimensional subspace of \(^{n}\) spanned by the columns of \(}\), \(n>r^{} r\). Then the nuclear norm minimization problem transforms into:

\[_{}\|\|_{*}(}}^{})_{ij}=_{ij},(i,j) .\] (14)

In practice, we use neural network parameterisation to learn the heat kernel map, this choice inadvertently restricts the reconstructed kernel to be aligned with the column space of the network outputs, bringing the inductive bias of the architecture into picture.

The optimal sampling complexity bound for (14) extends as \(p^{*}() n}}{{n}}\), where \(\) and \(\) are the coherence and the rank of \(}\), respectively. Suppose we wanted to recover some binary adjacency matrix \(\), such that \(_{ij}=1\) if \(i,j\) belong to the same cluster, 0 otherwise. Because \(\) can be rearranged to be block-diagonal with \(r\) blocks, its coherence \(()=}{{r{n_{min}}}}\), and exact reconstruction is possible provided

\[p^{*}() n}}{{n}},\] (15)

where \(n_{min}\) is the minimal cluster size. Heat kernel matrix constructed from such \(\) will have its eigenspectrum closely resembling that of \(\), albeit smooth, yet still having same pattern in eigengaps. So we may safely adopt this bound for \(_{t}\). For balanced class datasets \(n_{min}=}{{c}}\), and we can immediately see that the number of required observations \(m=p^{*}n^{2}=c() n\) grows linearly with the number of classes \(c\) in the dataset.

For illustrative purposes we plot the theoretical bound \(p^{*}\) on the fraction of the observed entries for a successful matrix completion from (15) in Figure 1 along with the actual fraction \(p\) of observedentries under self-supervised learning augmentation protocol to demonstrate that the latter intercepts the former given enough training epochs. To be specific, we set the size of the training dataset \(N=50\)k (CIFAR-10 size), the cluster size (number of same class examples) \(n_{min}=5000\) (\(c=10\)), the number of views \(a=2\), the number of epochs \(n_{epochs}\) range from \(1\) to \(1000\), and \(r=512\) (embedding size), assume \(=20\) (which seems to be a fair estimate in light of the experiments in Section 5) and \(c_{0}=5\), a constant used to control the probability of exact matrix recovery.

Based on this bound, we highlight the following factors that play important role in the success of any SSL method with spectral embedding type objective. The choice of the similarity function affects the incoherence parameter in the bound. The number of samples per class (alternatively the minimal cluster size \(n_{min}\)) should also be high enough for \(p^{*}\) to decrease rapidly. Finally, though potentially in contrast to the empirical observations (higher \(d\) on ImageNet yields higher downstream performance), the rank \(r\), effectively the dimension of embedding \(d\), should not be too large.

## 5 Experiments

First, we verify that the performance of the proposed formulation in (4) and the corresponding loss function, denoted RQmin, is at least on par with the state-of-the-art methods. We then study the effect of the complexity of the projection head on the incoherence and its connection with the downstream performance of the backbone against projection head outputs.

Here we report the training hyperparameters for all of the experiments. As VICReg is extremely sensitive to the choice of hyperparameters (e.g. increasing learning rate with increased batch size negatively affects training - learning diverges), we adopt the same hyperparameters for training RQmin  for a fair comparison. We follow the standard VICReg protocol adopted and finetuned for CIFAR-10/100 and ImageNet-100 in the library for self-supervised learning methods for visual representation learning _solo-learn_.

We train ResNet-18 backbone architecture with 3-layer MLP projection head (respective hidden dimensions: 2048-2048-2048). The batch size is 256 for CIFAR datasets and 512 for ImageNet-100. For pretraining, the learning rate schedule is linear warm-up for 10 epochs and cosine annealing, the optimizer is LARS with learning rate 0.3. For linear probe training, SGD with step learning rate schedule with steps at 60 and 80 epochs. The number of pre-training epochs is 1000 for CIFAR and 400 for ImageNet-100, downstream training - 100 epochs.

### Comparable performance

To demonstrate that our trace maximization objective is on par with existing SSL methods, we test our objective in (4) on a standard ResNet-18 backbone neural network with 3-layer MLP projection head and obtain comparable results on CIFAR-10, CIFAR-100, and ImageNet-100 to state-of-art methods. As most of the latter yield almost identical performance given enough hyperparameter tuning, we pick VICReg as a representative to compare against. Following the standard protocol with 1000 and 400 pre-training epochs for both CIFAR datasets and for ImageNet-100, respectively, linear probe for downstream evaluation is trained for 100 epochs. We do not tune hyperparameters and use default values. Mean and standard deviation for downstream accuracy across 5-10 trials with different seed values are reported in Table 1.

    &  &  &  \\   & top-1 & top-5 & top-1 & top-5 & top-1 & top-5 \\  VICReg & 91.15 \(\) 0.16 & 99.64 \(\) 0.05 & 67.57 \(\) 0.20 & 89.90 \(\) 0.13 & 78.89 \(\) 0.38 & 93.94 \(\) 0.17 \\ RQmin & 91.19 \(\) 0.13 & 99.67 \(\) 0.04 & 68.12 \(\) 0.26 & 90.12 \(\) 0.11 & 78.98 \(\) 0.33 & 94.45 \(\) 0.23 \\   

Table 1: Performance comparison for the trace maximization formulation (RQmin) and VICReg. Mean and standard deviation for validation set accuracy across 5-10 runs for CIFAR-10, CIFAR-100 and ImageNet-100.

### Incoherence effect on downstream performance

To test whether incoherence could explain the performance disparity between the outputs of the backbone, termed _representations_, and the projection head, known as _embeddings_, we train several models with various configurations of projection heads against SSL objectives on the ImageNet-100 dataset and calculate incoherences of representations and embeddings along with respective downstream accuracies. The performance of the representations and embeddings of the pre-trained model is evaluated in a downstream classification task, while incoherence \(\) for both candidates is estimated on the training set.

Since the dimensionality of representations and embeddings differ, i.e. 512 for backbone output and 2048 for projection head output, we need to pick the rank to compute \(\) accordingly. The common way to pick rank in the numerical methods is through tolerance, i.e. thresholding based on the values of the normalized singular values, i.e. \(_{i}^{}=_{i}/_{j}_{j}\). Otherwise, one could use the notion of effective rank , given by \(r_{e}()=(H())\), where the entropy \(H()=-_{i}_{i}(_{i})\) with vector of singular values \(\). Overall, we compute coherence as the following expression:

\[()=()}_{1 i r_{e} }\|_{}^{}_{i}\|_{2}^{2}.\]

Incoherence and projection head complexity.To estimate coherence of representations in Figure 2 (left), we embed the training set of ImageNet-100 to get representations matrix \(^{125952 512}\) and compute incoherence \(()\) using effective rank \(r_{e}()\). We embed the training set using three distinct pre-trained models for each of the projection head configurations characterized by the number of layers \(l\), \(l\{1,2,3,4\}\), and average the values across ten embedding runs. The resulting mean and standard deviation plot suggests that incoherence (low \(\)) is higher for more shallow projection heads and decreases (\(\) grows) as the number of layers in the head increase, a result we anticipated.

Embeddings and representations disparity.Figure 2 (right) plots distinct models representations and embeddings in the Accuracy-Coherence plane. It encodes different type of loss with a shape: diamonds for VICReg and squares for RQmin. While blue colour signifies the position of each model's representations, the green colour reflects the corresponding embeddings. Both objectives demonstrate a _separation_ of the embedding (low coherence, low accuracy) and representation (high coherence, high accuracy) points, which is more distinctive in the case of RQmin (squares).

The resulting plots support our hypothesis in Proposition 4.3 that incoherence indeed plays a crucial role in explaining the use of the backbone outputs. For successful matrix completion, high incoherence of the partially observed affinity matrix is essential. However, for the downstream performance of the representations, the opposite is preferred. The projection head functions as a disentangling buffer, enabling the representations to maintain low incoherence. Conversely, the embeddings inherit the incoherence of the affinity matrix.

While incoherence seems to be an attractive candidate for unsupervised embedding evaluation metric in scenarios with little to no test data, one should use caution as the coherence value \(\) does not reflect

Figure 2: **(left)** Coherence of the backbone outputs (_representations_) grows with the increasing number of layers in the projection head. **(right)** Downstream accuracy versus incoherence. Green marks show downstream performance and incoherence of embeddings, blue marks â€“ representations. Embeddings and representations of the same type of model are almost always separable in these coordinates: embeddings exhibit lower performance and lower coherence (small \(\)) while representations perform better and have higher coherence (large \(\)).

the amount of relevant information stored in the matrix of embeddings due to normalization with reference to its rank. This idea has been explored in  on embeddings of supervised models.

## 6 Related Work

Recent success of self-supervised methods [9; 15; 2; 38; 39], especially in the domain of computer vision received great amount of attention since the learned representations ended up respecting the semantics of the data. There has been a great interest in trying to understand the inner workings of the seemingly heuristic objectives since.

While there are many lenses one may take up to study the problem [21; 37; 22; 34; 33; 18], a particularly related to this work concurrent body of literature has adopted the view of the kernel or laplacian-based spectral representation learning [13; 1], which we also share in this work. We highlight our main difference to the results provided in these very recent papers.  does a brilliant job connecting and characterizing modern SSL methods into classical existing counterparts. However, it does not answer an important question whether an incomplete a priori knowledge about the data manifold stemming from augmentations can provide a good approximation to essentially nonlinear dimensionality reduction methods such as LLE , MDS , and kernel PCA .

We not only show SSL methods to have an objective function similar to the objectives of classical spectral decomposition methods, e.g. LaplacianEigenmaps , but also try to address the problem of incomplete and noisy measurements that we get as an inductive bias during the augmentation process. We hope that this perspective via the low-matrix completion problem will yield further theoretical results on the success of self-supervised learning and practical benefits when applying these methods in the wild, e.g. in domains such as medical imaging  and hard sciences .

## 7 Conclusion and Future Work

In this work, we make an attempt to bridge modern self-supervised methods with classical Laplacian-based dimensionality reduction methods and low-rank matrix completion in hopes to provide theoretical insights on the recent successes of SSL methods.

We show that these methods are not only doing Laplacian-based nonlinear reduction but are able to approximate and recover the truncated version of the underlying Laplace operator given only noisy and incomplete information from augmentation protocol by adopting low-rank matrix completion extensive literature and results. However, when working with datasets with potentially large number of classes, it might be a good idea to consider whether the size of the sample is large enough so that the minimal cluster size allows the full data matrix to be considered low-rank, otherwise the SSL methods would possibly fail to converge.

We also spot a direct influence of the inductive bias in the parameterization of the learned map on the column space of the recovered matrix. We also hypothesize that the disparity in downstream performance between backbone and projection head outputs can be explained by the high incoherence if the latter which is tied to the incoherence of the kernel one is recovering during training. The kernel should have high incoherence to be recoverable.

One of the possible avenues for future work stems from the notion of incoherence. We see it in exploring incoherence property of different types of the similarity or weighting functions one may use to instantiate the adjacency matrix with.

We hope that this work paves the way for a deeper study of the connection between self-supervised methods and classical problems such as matrix completion to yield better practical and theoretical understanding of various applications of SSL in different domains, not only computer vision.