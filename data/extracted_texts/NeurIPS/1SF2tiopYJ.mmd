# CommonScenes: Generating Commonsense 3D Indoor Scenes with Scene Graph Diffusion

Guangyao Zhai\({}^{1,2*}\) Evin Pinar Ornek\({}^{1,2*}\) Shun-Cheng Wu\({}^{1}\) Yan Di\({}^{1}\)

**Federico Tombari\({}^{1,3}\) Nassir Navab\({}^{1,2}\) Benjamin Busam\({}^{1,2}\)**

{guangyao.zhai,evin.oernek,yan.di}@tum.de

\({}^{1}\)Technical University of Munich \({}^{2}\)Munich Center for Machine Learning \({}^{3}\)Google

https://sites.google.com/view/commonscenes

The first two authors contributed equally. \({}^{}\)Corresponding author.

###### Abstract

Controllable scene synthesis aims to create interactive environments for numerous industrial use cases. Scene graphs provide a highly suitable interface to facilitate these applications by abstracting the scene context in a compact manner. Existing methods, reliant on retrieval from extensive databases or pre-trained shape embeddings, often overlook scene-object and object-object relationships, leading to inconsistent results due to their limited generation capacity. To address this issue, we present _CommonScenes_, a fully generative model that converts scene graphs into corresponding controllable 3D scenes, which are semantically realistic and conform to commonsense. Our pipeline consists of two branches, one predicting the overall scene layout via a variational auto-encoder and the other generating compatible shapes via latent diffusion, capturing global scene-object and local inter-object relationships in the scene graph while preserving shape diversity. The generated scenes can be manipulated by editing the input scene graph and sampling the noise in the diffusion model. Due to the lack of a scene graph dataset offering high-quality object-level meshes with relations, we also construct _SG-FRONT_, enriching the off-the-shelf indoor dataset 3D-FRONT with additional scene graph labels. Extensive experiments are conducted on SG-FRONT, where _CommonScenes_ shows clear advantages over other methods regarding generation consistency, quality, and diversity. Codes and the dataset are available on the website.

## 1 Introduction

Controllable **S**cene **S**ynthesis (**CSS**) refers to the process of generating or synthesizing scenes in a way that allows for specific entities of the scene to be controlled or manipulated. Existing methods operate on images  or 3D scenes  varying by controlling mechanisms from input scene graphs  or text prompts . Along with the development of deep learning techniques, CSS demonstrates great potential in applications like the film and video game industry , augmented and virtual reality , and robotics . For these applications, scene graphs provide a powerful tool to abstract scene content, including scene context and object relationships.

This paper investigates scene graph-based CSS for generating coherent 3D scenes characterized by layouts and object shapes consistent with the input scene graph. To achieve this goal, recent methods propose two lines of solutions. The first line of works optimizes scene layouts  and retrieves objects  from a given database (see Figure 1 (a)). Such retrieval-based approaches areinherently sub-optimal  in generation quality due to performance limitations through the size of the database. The second solution, e.g., Graph-to-3D , regresses both the layout and shape of the objects for synthesis. However, the shape generation relies on pre-trained shape codes from category-wise auto-decoders, e.g., DeepSDF . This semi-generative design (Figure 1 (b)) results in reduced shape diversity in the generated outputs. To enhance generation diversity without relying on vast databases, one possible solution is to concurrently predict scene layouts and generate object shapes with text-driven 3D diffusion models[8; 32], where the textual information is obtained from input scene graphs. Yet, in our experiments, we observe that such an intuitive algorithm works poorly since it does not exploit global and local relationship cues among objects encompassed by the graph.

In this work, our approach _CommonScenes_ exploits global and local scene-object relationships and demonstrates that a fully generative approach can effectively encapsulate and generate plausible 3D scenes without prior databases. Given a scene graph, during training, we first enhance it with pre-trained visual-language model features, e.g., CLIP , and bounding box embeddings, incorporating coarse local inter-object relationships into the feature of each node. Then, we leverage a triplet-GCN  based framework to propagate information among objects, learning layouts through global cues and fine local inter-object relationships, which condition the diffusion process  to model the shape distribution as well. During inference, each node in the scene graph is enriched with the learned local-to-global context and sequentially fed into the latent diffusion model for each shape generation. Figure 1 (c) illustrates that our method effectively leverages relationship encoding to generate commonsense scenes, i.e., arranged plausibly and realistically, exhibiting scene-level consistency while preserving object shape diversity. Furthermore, to facilitate the benchmarking of CSS, we curate a novel indoor scene graph dataset, _SG-FRONT_, upon a synthetic dataset 3D-FRONT , since no existing indoor scene graph datasets provide high-quality meshes. SG-FRONT comprises around 45K 3D samples with annotated semantic and instance segmentation labels and a corresponding scene graph describing each scene.

Our contributions can be summarized into three points. **First**, we present _CommonScenes_, a fully generative model that converts scene graphs into corresponding 3D scenes using a diffusion model. It can be intuitively manipulated through graph editing. **Second**, _CommonScenes_ concurrently models scene layout and shape distribution. It thereby encapsulates both global inter-object relationships and local shape cues. **Third**, we contribute _SG-FRONT_, a synthetic indoor dataset extending 3D-FRONT by scene graphs, thereby contributing graph-conditional scene generation benchmarks.

## 2 Related Work

Scene GraphScene graphs provide a rich symbolic and semantic representation of the scene using nodes and relationships . They are useful in many 2D-related topics such as image

Figure 1: **Architecture Comparison (Upper Row):** Compared with previous methods, our fully generative model requires neither databases nor multiple category-level decoders. **Performance Comparison (Bottom Row):** We demonstrate the effectiveness of encapsulating scene-object and object-object relationships. The semantic information from the scene graph is _‘a table is surrounded by three chairs’_. As highlighted in the rounded rectangles, through the scene-object relationship, our network outperforms other methods by generating a round table and three evenly distributed chairs. Through the object-object relationship, the three chairs are consistent in style. Moreover, our method still preserves the object diversity (blue dashed rectangle).

generation [24; 67], image manipulation , caption generation , visual question answering , and camera localization . Quickly after this progress, they are used in following areas: 3D scene understanding [59; 1; 64; 29], dynamic modeling , robotic grounding [22; 50; 68], spatio-temporal 4D [75; 30; 74], and controllable scene synthesis [33; 73; 60; 41; 13].

Indoor 3D Scene SynthesisControllable scene synthesis is extensively explored in the computer graphics community, varying from text-based scene generation  to segmentation map  or spatial layout-based image-to-image translation tasks . Likewise in 3D, several methods generated scenes from images [56; 39; 2; 69; 14; 40; 38], text , probabilistic grammars [4; 23; 11; 45], layouts [26; 54], in an autoregressive manner [44; 63], or through learning deep priors . Another line of work closer to ours is based on graph conditioning [33; 73; 60; 41]. Luo et al.  proposed a generative scene synthesis through variational modeling coupled with differentiable rendering. However, their method relies on shape retrieval, which depends on an existing database. Graph-to-3D  proposes a joint approach to learn both scene layout and shapes with a scene graph condition. Nevertheless, their object generation relies on a pre-trained shape decoder, limiting the generalizability. Unlike previous work, our method generates 3D scenes with the condition over a scene graph, which is trained end-to-end along with content awareness, resulting in higher variety and coherency.

Denoising Diffusion ModelsA diffusion probabilistic model is a trained Markov chain that generates samples matching data by reversing a process that gradually adds noise until the signal vanishes . Diffusion models have quickly gained popularity due to their unbounded, realistic, and flexible generation capacity [21; 53; 37; 28; 47; 15]. However, studies have identified that the diffusion models lack compositional understanding of the input text . Several advancements have been introduced to address these limitations. Techniques such as the introduction of generalizable conditioning and instruction mechanisms have emerged [5; 70]. Moreover, optimizing attention channels during testing has also been explored [6; 17]. Recently, a latent diffusion model using a Signed Distance Field (SDF) to represent 3D shapes was proposed contemporaneously at multiple works [8; 32], which can be conditioned on a text or a single view image. For the contextual generation conditioned on scene graphs, methods have converted triplets into the text to condition the model [17; 67], where Yang et al.  proposed a graph conditional image generation based on masked contrastive graph training. To the best of our knowledge, we are the first to leverage both areas of scene graph and latent diffusion for end-to-end 3D scene generation.

## 3 Preliminaries

Scene GraphA scene graph, represented as \(=(,)\), is a structured representation of a visual scene where \(=\{v_{i} i\{1,,N\}\}\) denotes the set of vertices (object nodes) and \(=\{e_{i j} i,j\{1,,N\},i j\}\) represents the set of directed edge from node \(v_{i}\) to \(v_{j}\). Each vertex \(v_{i}\) is categorized through an object class \(c_{i}^{node}^{node}\), where \(^{node}\) denotes the set of object classes. The directed edges in \(\) capture the relationships between objects in terms of both semantic and geometric information. Each edge \(e_{i j}\) has a predicate class \(c_{i j}^{edge}^{edge}\), where \(^{edge}\) denotes the set of edge predicates. These relationships can incorporate various aspects, such as spatial locations (e.g., left/right, close by) or object properties (bigger/smaller). To facilitate subsequent processing and analysis, each node \(v_{i}\) and edge \(e_{i j}\) are typically transformed into learnable vectors \(o_{i}\) and \(_{i j}\), respectively, through embedding layers, as shown in Figure 2.A.

Conditional Latent Diffusion ModelDiffusion models learn a target distribution by reversing a progressive noise diffusion process modeled by a fixed Markov Chain of length \(T\)[21; 53]. Fundamentally, given a sample \(_{t}\) from the latent space, gradual Gaussian Noise is added with a predefined scheduler \(_{t},t\{1,,T\}\). Then, the denoiser \(_{}\), typically a UNet, is trained to recover denoising from those samples. The recently introduced Latent Diffusion Models (LDMs)  reduce the computational requirements by learning this distribution in a latent space established by a pre-trained VQ-VAE  instead of directly processing the full-size input. The popular usage of LDM is conditional LDM, which allows the generation to obey the input cue \(_{i}\). The training objective can be simplified to

\[_{LDM}=_{,(0,1),t} [||-_{}(_{t},t,_{i})||_{ 2}^{2}],\] (1)where \(_{i}\) denotes a conditioning vector corresponding to the input sample \(i\) fed into \(_{}\).

## 4 Method

OverviewGiven a semantic scene graph, our approach endeavors to generate corresponding 3D scenes conforming to commonsense. We employ a dual-branch network starting with a contextual encoder \(E_{c}\), as shown in Figure 3. The two branches, referred to as the _Layout Branch_ and the _Shape Branch_, function simultaneously for layout regression and shape generation. In Sec. 4.1, we first illustrate how a scene graph evolves to a Box-enhanced Contextual Graph (BCG) with features from pre-trained visual-language model CLIP  and bounding box parameters (Figure 2). Then, we show how BCG is encoded by \(E_{c}\) and manipulated by the graph manipulator (Figure 3.A, B and C). In Sec. 4.2, we introduce the layout branch for layout decoding, and in Sec. 4.3, we introduce the shape branch for shape generation. Finally, we explain the joint optimization in Sec. 4.4.

### Scene Graph Evolution

Contextual GraphAs shown in Figure 2.A and B, we incorporate readily available prompt features from CLIP  as semantic anchors, capturing coarse inter-object information, into each node and edge of the input graph to conceptualize it as _Contextual Graph_\(_{c}\) with \(p_{i}=E_{}(c_{i}^{node})\) for objects and \(p_{i j}=E_{}(c_{i}^{node} c_{i j}^{edge} c_{j} ^{node})\) for edges. Here \(E_{}\) is the pre-trained and frozen text encoder in , \(\) denotes the aggregation operation on prompts including subject class \(c_{i}^{node}\), predicate \(c_{i j}^{edge}\), and object class \(c_{j}^{node}\). Thereby, the embeddings of \(_{c}=(_{c},_{c})\) is formalized as,

\[_{_{c}}=\{f_{v_{c}}^{i}=(p_{i},o_{i}) i\{1,,N \}\},\;_{_{c}}=\{f_{c_{c}}^{i j}=(p_{i j}, _{i j}) i,j\{1,,N\}\},\] (2)

where \(_{_{c}}\) represents the set of object features and \(_{_{c}}\) the edge features.

Box-Enhanced Contextual GraphIn training, we enrich each node in the contextual graph by using ground truth bounding boxes parameterized by box sizes \(s\), locations \(t\), and the angular rotations along the vertical axis \(\), yielding a BCG, as shown in Figure 2.C. Thereby, the node embeddings of BCG are represented by \(_{_{c}}^{(b)}=\{f_{v_{c}}^{(b)i}=(p_{i},o_{i},b_{i})  i\{1,,N\}\}\), where \(b_{i}\) is obtained by encoding \((s_{i},t_{i},_{i})\) with MLPs. Note that BCG is only used during training, i.e., bounding box information is not needed during inference.

Graph EncodingBCG is encoded by the subsequent triplet-GCN-based contextual encoder \(E_{c}\), which together with the layout decoder \(D_{i}\) in Sec. 4.2 construct a Conditional Variational Autoencoder (CVAE) . The encoding procedure is shown in Figure 3.A, B and C. Given a BCG, during training, we input the embeddings \(_{_{c}}^{(b)}\) and \(_{_{c}}\) into \(E_{c}\) to obtain an _Updated Contextual Graph_ with node and edge features represented as \((_{_{c}}^{(s)},_{_{c}})\), which is also the beginning point of the inference route. Each layer of \(E_{c}\) consists of two sequential MLPs \(\{g_{1},g_{2}\}\), where \(g_{1}\) performs message passing between connected nodes and updates the edge features, \(g_{2}\) aggregates features from all connected neighbors of each node and update its features, as shown in the follows:

\[(_{v_{i}}^{l_{q}},_{c_{i j}}^{l_{q}+1}, _{v_{j}}^{l_{q}})&=g_{1}(_{v_{i}}^{l_{q}},_{c_{i j}}^{l_ {q}},_{v_{j}}^{l_{q}}), l_{g}=0,,L-1,\\ _{v_{i}}^{l_{q}+1}&=_{v_{i}}^{l_{q}}+g_{2} _{v_{j}}^{l_{q}} v_{j} N_{}(v_{i }),\] (3)

Figure 2: **Scene Graph Evolution.** Take the features of two nodes _Bed_\((o_{i})\), _Table_\((o_{j})\) and the linked edge _In front of_\((_{i j})\) as an example, where \((o_{i},o_{j}),_{i j}\) are embedded learnable node features and the edge feature, respectively. We enhance the node and edge features with CLIP feature \(p_{i},p_{i j}\) to obtain \(B\). _Contextual Graph_. Then, we parameterize the ground truth bounding box \(b_{i}\) to the node to further build \(C\). _Box-Enhanced Contextual Graph_ with node and edge feature represented as \(f_{v_{c}}^{(b)i}=\{p_{i},o_{i},b_{i}\},f_{c_{c}}^{i j}=\{p_{i j},_{i  j}\}\).

where \(l_{g}\) denotes a single layer in \(E_{c}\) and \(N_{}(v_{i})\) includes all the connected neighbors of \(v_{i}\). AVG refers to average pooling. We initialize the input embeddings of layer \(0\) as the features from the _Updated Contextual Graph_, \((^{0}_{v_{i}},^{0}_{e_{i j}},^{0}_{v_{j}})=(f^{(b)i}_{v_{c}},f^{ i j}_{e_{c}},f^{(b)j}_{v_{c}})\). The final embedding \(^{L}_{v_{i}}\) is used to model a joint layout-shape distribution \(Z\), parameterized with the \(N_{c}\)-dimensional Gaussian distribution \(Z N(,)\), where \(,^{N_{c}}\), predicted by two separated MLP heads. Thereby, \(Z\) is modeled through minimizing:

\[_{KL}=D_{KL}(E^{}_{c}(z|x,^{(b)}_{_{c}},_{_{c}}) p(z|x)),\] (4)

where \(D_{KL}\) is the Kullback-Liebler divergence measuring the discrepancy between \(Z\) and the posterior distribution \(p(z|x)\) chosen to be standard \(N(z 0,1)\). We sample a random vector \(z_{i}\) from \(Z\) for each node, update node feature \(^{(z)}_{_{c}}\) by concatenating \(\{z_{i},p_{i},o_{i}\}\), keep edge features unchanged.

### Layout Branch

As shown in Figure 3.D, a decoder \(D_{l}\), which is another triplet-GCN, generates 3D layout predictions upon updated embeddings. In this branch, \(E_{c}\) and \(D_{l}\) are jointly optimized by Eq. (4) and a bounding box reconstruction loss:

\[_{layout}=_{i=1}^{N}(|s_{i}-_{i}|_{1}+|t_{i}- _{i}|_{1}-_{=1}^{}_{i}^{}_{i}^{}),\] (5)

where \(},},}\) denote the predictions of bounding box size \(s\), locations \(t\) and angular rotations \(\), respectively. \(\) is the rotation classification label. We partition the rotation space into \(\) bins, transforming the rotation regression problem into a classification problem.

### Shape Branch

As shown in Figure 3.E, in parallel to the _Layout Branch_, we introduce _Shape Branch_ to generate shapes for each node in the given graph, and represent them by SDF.

Relation EncodingThe core idea of our method is to exploit global scene-object and local object-object relationships to guide the generation process. Hence, besides incorporating CLIP features for coarse local object-object relationships, as introduced in Section 4.1, we further design a relation encoder \(E_{r}\), based on triplet-GCN as well, to encapsulate global semantic cues of the graph into

Figure 3: **Overview of CommonScenes. Our pipeline consists of shared modules and two collaborative branches _Layout Branch_ and _Shape Branch_. Given a BCG (Figure 2.C), we first feed it into \(E_{c}\), yielding a joint layout-shape distribution \(Z\). We sample \(z_{i}\) from \(Z\) for each node, obtaining concatenated feature \(\{z_{i},p_{i},o_{i}\}\) with CLIP feature \(p_{i}\) and self-updated feature \(o_{i}\). A graph manipulator is then optionally adopted to manipulate the graph for data augmentation. Next, the updated contextual graph is fed into the layout branch and shape branch for layout regression and shape generation respectively. In the shape branch, we leverage \(E_{r}\) to encapsulate global scene-object and local object-object relationships into graph nodes, which are then conditioned to \(_{}\) in LDM via cross-attention mechanism to generate \(_{0}\) back in \(T\) steps. Finally, a frozen shape decoder (VQ-VAE) reconstructs \(S^{}\) using \(_{0}\). The final scene is generated by fitting \(S^{}\) to layouts.**

each node and propagate local shape cues between connected nodes. Specifically, \(E_{r}\) operates on the learned embeddings \((^{(z)}_{(v_{c}},_{_{c})})\) of the _Updated Contextual Graph_, and updates the feature of each node with local-to-global semantic cues, yielding node-relation embeddings for subsequent diffusion-based shape generation.

Shape DecodingWe use an LDM conditioned on node-relation embedding to model the shape-generation process. In terms of shape representation, we opt for truncated SDF (TSDF)  around the surface of the target object within a voxelized space \(S^{D D D}\). Following the LDM, the dimension \(D\) of TSDF can be reduced by training a VQ-VAE  as a shape compressor to encode the 3D shape into latent dimensions \(^{d d d}\), where \(d<<D\) is built upon a discretized codebook. Then a forward diffusion process adds random noise to the input shape \(_{0}\) transferring to \(_{T}\), upon which we deploy a 3D-UNet \(_{}\) (Figure 3.E) to denoise the latent code back to \(_{0}\) according to DDPM model by Ho et al. . The denoiser is conditioned on node-relation embeddings to intermediate features of 3D UNet via the cross-attention mechanism. Finally, the decoder of VQ-VAE generates the shape \(S^{}\) from the reconstructed \(_{0}\). For the denoising process at the timestep \(t\), the training objective is to minimize:

\[_{shape}=_{,(0,1),t} [||-_{}(_{t},t,E_{r}(^ {(z)}_{_{c}},_{_{c}})||^{2}_{2}],\] (6)

where the evidence lower bound between the sampled noise \(\) and the prediction conditioned on the contextual relation embedding extracted from \(E_{r}\) is optimized. At test time, a latent vector is randomly sampled from \((0,1)\) and progressively denoised by 3D-Unet to generate the final shape. Each shape within the layout is populated based on per-node conditioning, ultimately producing a plausible scene. Compared to prior work, our design can bring more diverse shape generation by taking advantage of the diffusion model architecture, as shown in experiments.

### Layout-Shape Training

Our pipeline is trained jointly in an end-to-end fashion, allowing the _Layout Branch_ and _Shape Branch_ to optimize each other by sharing latent embeddings \((^{(z)}_{_{F}},_{_{c}})\), coming out of \(E_{c}\). The final optimization loss is the combination of scene distribution modeling, layout generation, and shape generation:

\[=_{1}_{KL}+_{2}_{layout}+ _{3}_{shape},\] (7)

where \(_{1}\), \(_{2}\) and \(_{3}\) are weighting factors. Further insights on accomplishing the batched training are provided in Supplementary Material.

## 5 Experiments

SG-FRONT DatasetDue to the lack of scene graph datasets also providing high-quality object meshes, we construct _SG-FRONT_, a set of well-annotated scene graph labels, based on a 3D synthetic dataset 3D-FRONT  that offers professionally decorated household scenarios. The annotation labels can be grouped into three categories _spatial/proximity, support, and style_. The spatial relationships are based on a series of relationship checks between the objects, which control the object bounding box location, e.g., left/right, the comparative volumes, e.g., bigger/smaller, and heights, e.g., taller/shorter. The support relationships include directed structural support, e.g., close by, above, and standing on. Thresholds for these labels are iterated and set by the annotators. Finally, style relationships include the object attributes to assign labels, namely same material as, same shape as, and same super-category as. SG-FRONT contains around 45K samples from three different indoor scene types, covering 15 relationship types densely annotating scenes. More details are provided in the Supplementary Material.

Implementation DetailsWe conduct the training, evaluation, and visualization of _CommonScenes_ on a single NVIDIA A100 GPU with 40GB memory. We adopt the AdamW optimizer with an initial learning rate of 1e-4 to train the network in an end-to-end manner. We set \(\{_{1},_{2},_{3}\}=\{1.0,1.0,1.0\}\) in all our experiments. \(N_{c}\) in distribution \(Z\) is set to 128 and TSDF size \(D\) is set as 64. We provide more details in the Supplementary Material.

Evaluation MetricsTo measure the **fidelity and diversity** of generated scenes, we employ the commonly adopted Frechet Inception Distance (FID)  & Kernel Inception Distance (KID)  metrics . We project scenes onto a bird's-eye view, excluding lamps to prevent occlusion and using object colors as semantic indicators. To measure the **scene graph consistency**, we follow the scene graph constraints , which measure the accuracy of a set

Figure 4: **Qualitative comparison** The orientations of Left/Right and Front/Behind in the scene graph align with the top-down view. Both scene-object and object-object inconsistencies are highlighted in red rectangles. Green rectangles emphasize the commonsense consistency our method produces.

of relations on a generated layout. We calculate the spatial left/right, front/behind, smaller/larger, taller/shorter metrics, as well as more difficult proximity constraints close by and symmetrical. To measure the **shape consistency**, we test timing rooms, a typical scenario in which tables and chairs should be in suits according to the commonsense decoration. We identify matching dining chairs and tables in 3D-FRONT using the same CAD models and note their instance IDs. This helps us determine which entities belong to the same sets. We calculate Chamfer Distance (CD) of each of the two objects in each set after generation. To measure the **shape diversity**, we follow  to generate each scene 10 times and evaluate the change of corresponding shapes using CD. We illustrate the concepts of diversity and consistency in Figure 5. We also report MMD, COV, and 1-NNA following  for **the object-level evaluation** in the Supplementary Materials.

Compared BaselinesWe include three types of baseline methods. **First**, three retrieval-based methods, i.e., a layout generation network _3D-SLN_, a progressive method to add objects one-by-one designed in , and _Graph-to-Box_ from . **Second**, a semi-generative SOTA method _Graph-to-3D_. **Third**, an intuitive method called _layout+txt2shape_ that we design according to the instruction in Sec. 1, stacking a layout network and a text-to-shape generation model in series, and it is a fully generative approach with text only. All baseline methods are trained on the SG-FRONT dataset following the public implementation and training details.

### Graph Conditioned Scene Generation

Qualitative resultsThe generated scenes from different baselines are shown in Figure 4: (a) Graph-to-Box retrieval, (b) Graph-to-3D, (c) layout+txt2shape, and (d) ours. It can be seen that our method has better shape consistency and diversity. Specifically, in terms of object shape quality, retrieval baseline scenes look optimal since they are based on real CAD models. Yet, the layout configuration is poor, and the retrieved object styles are not plausible, e.g., dining chairs and nightstands are not in a suit, respectively, in the same rooms. Graph-to-3D improves this by learning coherent scenes. However, the object styles are not conserved within scene styles, providing unrealistic scene-object inconsistency, e.g., in the bedroom, the height of the chair does not match the style and the height of the table. Subsequently, (c) improves the layout, which can be seen in the living room area, but again falls back on the generated shape quality and shares the same problem with Graph-to-Box on the poor object-object consistency. In contrast, CommonScenes can capture diverse environments considering both generation consistency and stylistic differences with respect to each scene. In the

    &  Shape \\ Representation \\  } &  Bedroom \\ FID \\  } &  Living room \\ FID \\  } &  Dining room \\ FID \\  } &  All \\ FID \\  } \\ 
3D-SLN  & & 57.90 & 3.85 & 77.82 & 3.65 & 69.13 & 6.23 & 44.77 & 3.32 \\ Progressive  & Retrieval & 58.01 & 7.36 & 79.84 & 4.24 & 71.35 & 6.21 & 46.36 & 4.57 \\ Graph-to-Box  & & 54.61 & 2.93 & 78.53 & 3.32 & 67.80 & 6.30 & 43.51 & 3.07 \\
**Ours** w/o SB & & **52.69** & **2.82** & **76.52** & **2.08** & **65.10** & **61.11** & **42.07** & **2.23** \\  Graph-to-3D  & DeepSDF  & 63.72 & 17.02 & 82.96 & 11.07 & 72.51 & 12.74 & 50.29 & 7.96 \\ Layout+txt2shape & SDFusion  & 68.08 & 18.64 & 85.38 & 10.04 & **64.02** & **5.08** & 50.58 & 8.33 \\
**Ours** & rel2shape & **57.68** & **6.59** & **80.99** & **6.39** & 65.71 & 5.47 & **45.70** & **3.84** \\   

Table 1: **Scene generation realism** as measured by FID and KID \(( 0.001)\) scores at \(256^{2}\) pixels between the top-down rendering of generated and real scenes (lower is better). Two main rows are separated with respect to the reliance on an external shape database for retrieval. “Ours w/o SB” refers to ours without the shape branch.

    &  &  \\   & Chair & Table & Chair & Table \\  Graph-to-Box  & 10.42 & 50.66 & 0.53 & 0.89 \\ Graph-to-3D  & 2.49 & 11.74 & 1.43 & 0.93 \\ Ours & **1.96** & **9.04** & **30.04** & **10.53** \\   

Table 2: **Consistency and diversity in the dining rooms.** The object shapes related with _same as_ within a scene are consistent as indicated by low CD values (\( 0.001\)), whereas the shapes across different runs have high diversity, per high KL divergence.

Figure 5: **Consistency co-exists with diversity in different rounds.** Our generated objects show diversity when activated twice while preserving the shape consistency within the scene (chairs in a suit).

[MISSING_PAGE_FAIL:9]

on par with Graph-to-3D on easy relations, whereas there is a major improvement in the hard ones. Further, within the retrieval methods, Ours w/o SB improves over the baselines in the addition mode and is on par in the change mode. It could be argued that changing could be more difficult since it could alter multiple objects, whereas object insertion has less effect on the overall scene. We show some qualitative manipulation examples in the Supplementary Material.

### Ablations

We ablate the primary components of CommonScenes in Table 5, including (1) scene generation from the original scene graph without contextual information brought by CLIP features, (2) scene generation from the contextual graph without the participation of the relational encoder \(E_{r}\), (3) conditioning with concatenation on diffusion latent code instead of cross-attention, and (4) our final proposed method. We provide the mean FID scores over the scenes, as well as the mean over the hard scene graph constraints (mSG). We observe the benefit of both the context and \(E_{r}\) indicated by FID/KID scores, as well as the choice of our conditioning mechanism.

## 6 Limitations

We address the main aspects of the dataset and the limitations of our method and discuss more in the Supplementary Materials. First, the 3D-FRONT dataset used in our research contains significant noise, which we have mitigated through a post-processing step. Despite this effort, a small proportion of noisy data, specifically interpenetrating furniture instances, remains in the training dataset. Consequently, our proposed method and the baseline approaches reflect this during inference, rarely resulting in occurrences of scenes with collided objects. We show some cases in Figure 6. While our method outperforms others by effectively combining shape and layout information, it is essential to note that minor collision issues may still arise.

## 7 Conclusion

Scene graph-based CSS designs interactive environments suitable for a wide range of usages. Current methods heavily depend on object retrieval or pre-trained shape models, neglecting inter-object relationships and resulting in inconsistent synthesis. To tackle this problem, we introduce _CommonScenes_, a fully generative model that transforms scene graphs into corresponding commonsense 3D scenes. Our model regresses scene layouts via a variational auto-encoder, while generating satisfying shapes through latent diffusion, gaining higher shape diversity and capturing the global scene-object relationships and local object-object relationships. Additionally, we annotate a scene graph dataset, _SG-FRONT_, providing object relationships compatible with high-quality object-level meshes. Extensive experiments on _SG-FRONT_ show that our method outperforms other methods in terms of generation consistency, quality, and diversity.

AcknowledgementsThis research is supported by Google unrestricted gift, the China Scholarship Council (CSC), and the Munich Center for Machine Learning (MCML). We are grateful to Google University Relationship GCP Credit Program for supporting this work by providing computational resources. Further, we thank all participants of the perceptual study.

[MISSING_PAGE_FAIL:11]

*  Xin Kong, Xuemeng Yang, Guangyao Zhai, Xiangrui Zhao, Xianfang Zeng, Mengmeng Wang, Yong Liu, Wanlong Li, and Feng Wen. Semantic graph based place recognition for 3d point clouds. In _IROS_, 2020.
*  Ranjay Krishna, Yuke Zhu, Oliver Groth, Justin Johnson, Kenji Hata, Joshua Kravitz, Stephanie Chen, Yannis Kalantidis, Li-Jia Li, David A Shamma, et al. Visual genome: Connecting language and vision using crowdsourced dense image annotations. _International journal of computer vision_, 123(1):32-73, 2017.
*  Muneg Li, Yueqi Duan, Jie Zhou, and Jiwen Lu. Diffusion-sdf: Text-to-shape via voxelized diffusion. In _CVPR_, 2023.
*  Manyi Li, Akshay Gadi Patil, Kai Xu, Siddhartha Chaudhuri, Owais Khan, Ariel Shamir, Changhe Tu, Baoquan Chen, Daniel Cohen-Or, and Hao Zhang. Grains: Generative recursive autoencoders for indoor scenes. _ACM Transactions on Graphics (TOG)_, 38(2):1-16, 2019.
*  Yiyi Liao, Katija Schwarz, Lars Mescheder, and Andreas Geiger. Towards unsupervised learning of generative models for 3d controllable image synthesis. In _CVPR_, 2020.
*  Andrew Luo, Zhoutong Zhang, Jiajun Wu, and Joshua B. Tenenbaum. End-to-end optimization of scene layout. In _CVPR_, 2020.
*  Rui Ma, Akshay Gadi Patil, Matthew Fisher, Manyi Li, Soren Pirk, Binh-Son Hua, Sai-Kit Yeung, Xin Tong, Leonidas Guibas, and Hao Zhang. Language-driven synthesis of 3d scenes from scene databases. _ACM Transactions on Graphics (TOG)_, 37(6):1-16, 2018.
*  Chenlin Meng, Yutong He, Yang Song, Jiaming Song, Jiajun Wu, Jun-Yan Zhu, and Stefano Ermon. SDEdit: Guided image synthesis and editing with stochastic differential equations. In _ICLR_, 2022.
*  Yinyu Nie, Angela Dai, Xiaoguang Han, and Matthias Niessner. Learning 3d scene priors with 2d supervision. In _CVPR_, 2023.
*  Yinyu Nie, Xiaoguang Han, Shihui Guo, Yujian Zheng, Jian Chang, and Jian Jun Zhang. Total3dunderstanding: Joint layout, object pose and mesh reconstruction for indoor scenes from a single image. In _CVPR_, 2020.
*  Evin Pinar Ornek, Shristi Mudgal, Johanna Wald, Yida Wang, Nassir Navab, and Federico Tombari. From 2d to 3d: Re-thinking benchmarking of monocular depth prediction, 2022.
*  Wamiq Para, Paul Guerrero, Tom Kelly, Leonidas J Guibas, and Peter Wonka. Generative layout modeling using constraint graphs. In _ICCV_, 2021.
*  Jeong Joon Park, Peter Florence, Julian Straub, Richard Newcombe, and Steven Lovegrove. Deepsdf: Learning continuous signed distance functions for shape representation. In _CVPR_, 2019.
*  Taesung Park, Ming-Yu Liu, Ting-Chun Wang, and Jun-Yan Zhu. Semantic image synthesis with spatially-adaptive normalization. In _CVPR_, 2019.
*  Despoina Paschalidou, Amlan Kar, Maria Shugrina, Karsten Kreis, Andreas Geiger, and Sanja Fidler. Atiss: Autoregressive transformers for indoor scene synthesis. In _NeurIPS_, 2021.
*  Pulak Purkait, Christopher Zach, and Ian Reid. Sg-vae: Scene grammar variational autoencoder to generate new indoor scenes. In _ECCV_, 2020.
*  Alec Radford, Jong Wook Kim, Chris Hallacy, Aditya Ramesh, Gabriel Goh, Sandhini Agarwal, Girish Sastry, Amanda Askell, Pamela Mishkin, Jack Clark, et al. Learning transferable visual models from natural language supervision. In _ICML_, 2021.
*  Robin Rombach, Andreas Blattmann, Dominik Lorenz, Patrick Esser, and Bjorn Ommer. High-resolution image synthesis with latent diffusion models. In _CVPR_, 2022.
*  Olaf Ronneberger, Philipp Fischer, and Thomas Brox. U-net: Convolutional networks for biomedical image segmentation. In _MICCAI_, 2015.
*  Antoni Rosinol, Arjun Gupta, Marcus Abate, Jingnan Shi, and Luca Carlone. 3d dynamic scene graphs: Actionable spatial perception with places, objects, and humans. In _RSS_, 2020.
*  Antoni Rosinol, Andrew Violette, Marcus Abate, Nathan Hughes, Yun Chang, Jingnan Shi, Arjun Gupta, and Luca Carlone. Kimera: From slam to spatial perception with 3d dynamic scene graphs. _The International Journal of Robotics Research_, 40(12-14):1510-1546, 2021.
*  Chitwan Saharia, William Chan, Saurabh Saxena, Lala Li, Jay Whang, Emily L Denton, Kamyar Ghasemipour, Raphael Gontijo Lopes, Burcu Karagol Ayan, Tim Salimans, Jonathan Ho, David J Fleet, and Mohammad Norouzi. Photorealistic text-to-image diffusion models with deep language understanding. In _NeurIPS_, 2022.
*  Jascha Sohl-Dickstein, Eric Weiss, Niru Maheswaranathan, and Surya Ganguli. Deep unsupervised learning using nonequilibrium thermodynamics. In _ICML_, 2015.
*  Yang Song, Jascha Sohl-Dickstein, Diederik P Kingma, Abhishek Kumar, Stefano Ermon, and Ben Poole. Score-based generative modeling through stochastic differential equations. In _ICLR_, 2021.
*  Jiapeng Tang, Yinyu Nie, Lev Markhasin, Angela Dai, Justus Thies, and Matthias Niessner. Diffuscene: Scene graph denoising diffusion probabilistic model for generative indoor scene synthesis, 2023.
*  Damien Teney, Lingqiao Liu, and Anton van Den Hengel. Graph-structured representations for visual question answering. In _CVPR_, 2017.
*  Shubham Tulsiani, Saurabh Gupta, David Fouhey, Alexei A. Efros, and Jitendra Malik. Factoring shape, pose, and layout from the 2d image of a 3d scene. In _CVPR_, 2018.
*  Mikaela Angelina Uy, Vladimir G Kim, Minhyuk Sung, Noam Aigerman, Siddhartha Chaudhuri, and Leonidas J Guibas. Joint learning of 3d shape retrieval and deformation. In _CVPR_, 2021.
*  Aaron van den Oord, Oriol Vinyals, and Koray Kavukcuoglu. Neural discrete representation learning. In _NeurIPS_, 2017.

*  Johanna Wald, Helisa Dhamo, Nassir Navab, and Federico Tombari. Learning 3d semantic scene graphs from 3d indoor reconstructions. In _CVPR_, 2020.
*  Kai Wang, Yu-An Lin, Ben Weissmann, Manolis Savva, Angel X Chang, and Daniel Ritchie. Planit: Planning and instantiating indoor scenes with relation graph and spatial prior networks. _ACM Transactions on Graphics (TOG)_, 38(4):1-15, 2019.
*  Kai Wang, Manolis Savva, Angel X Chang, and Daniel Ritchie. Deep convolutional priors for indoor scene synthesis. _ACM Transactions on Graphics (TOG)_, 37(4):70, 2018.
*  Xiaolong Wang and Abhinav Gupta. Generative image modeling using style and structure adversarial networks. In _ECCV_, 2016.
*  Xinpeng Wang, Chandan Yeshwanth, and Matthias Niessner. Sceneformer: Indoor scene generation with transformers. In _3DV_, 2021.
*  Shun-Cheng Wu, Johanna Wald, Keisuke Tateno, Nassir Navab, and Federico Tombari. Scenegraphfusion: Incremental 3d scene graph prediction from rgb-d sequences. In _CVPR_, 2021.
*  Jianghao Xiong, En-Lin Hsiang, Ziqian He, Tao Zhan, and Shin-Tson Wu. Augmented reality and virtual reality displays: emerging technologies and future perspectives. _Light: Science & Applications_, 10(1):216, 2021.
*  Guandao Yang, Xun Huang, Zekun Hao, Ming-Yu Liu, Serge Belongie, and Bharath Hariharan. Pointflow: 3d point cloud generation with continuous normalizing flows. In _ICCV_, 2019.
*  Ling Yang, Zhilin Huang, Yang Song, Shenda Hong, Guohao Li, Wentao Zhang, Bin Cui, Bernard Ghanem, and Ming-Hsuan Yang. Diffusion-based scene graph to image generation with masked contrastive pre-training, 2022.
*  Guangyao Zhai, Xiaoni Cai, Dianye Huang, Yan Di, Fabian Manhardt, Federico Tombari, Nassir Navab, and Benjamin Busam. Sg-bot: Object rearrangement via coarse-to-fine robotic imagination on scene graphs, 2022.
*  Chenyangguang Zhang, Zhiqiang Lou, Yan Di, Federico Tombari, and Xiangyang Ji. Sst: Real-time end-to-end monocular 3d reconstruction via sparse spatial-temporal guidance. In _ICME_, 2023.
*  Lvmin Zhang, Anyi Rao, and Maneesh Agrawala. Adding conditional control to text-to-image diffusion models. In _ICCV_, 2023.
*  Bo Zhao, Lili Meng, Weidong Yin, and Leonid Sigal. Image generation from layout. In _CVPR_, 2019.
*  Yizhou Zhao, Kaixiang Lin, Zhiwei Jia, Qiaozi Gao, Govind Thattai, Jesse Thomason, and Gaurav S. Sukhtime. Luminous: Indoor scene generation for embodied ai challenges. In _NeurIPS Workshop_, 2021.
*  Yang Zhou, Zachary While, and Evangelos Kalogerakis. Scenegraphnet: Neural message passing for 3d indoor scene augmentation. In _ICCV_, 2019.
*  Ege Ozsoy, Tobias Czempiel, Evin Pinar Ornek, Ulrich Eck, Federico Tombari, and Nassir Navab. Holistic or domain modeling: a semantic scene graph approach. _International Journal of Computer Assisted Radiology and Surgery_, pages 1-9, 2023.
*  Ege Ozsoy, Evin Pinar Ornek, Ulrich Eck, Tobias Czempiel, Federico Tombari, and Nassir Navab. 4d-or: Semantic scene graphs for or domain modeling. In _MICCAI_, 2022.