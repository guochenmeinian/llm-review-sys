# What Makes Partial-Label Learning Algorithms Effective?

Jiaqi Lv\({}^{1,5}\), Yangfan Liu\({}^{1}\), Shiyu Xia\({}^{1}\), Ning Xu\({}^{1,5}\), Miao Xu\({}^{2}\), Gang Niu\({}^{3,1}\), Min-Ling Zhang\({}^{1,5}\), Masashi Sugiyama\({}^{3,4}\), Xin Geng\({}^{1,5}\)

\({}^{1}\)Southeast University \({}^{2}\)The University of Queensland

\({}^{3}\)RIKEN Center for Advanced Intelligence Project \({}^{4}\)The University of Tokyo

\({}^{5}\)Key Laboratory of New Generation Artificial Intelligence Technology and

Its Interdisciplinary Applications (Southeast University), Ministry of Education, China

{is.jiaqi.lv, gang.niu.ml}@gmail.com,

miao.xu@uq.edu.au, sugi@k.u-tokyo.ac.jp,

{liuyangfan, shiyu_xia, xning, zhangml, xgeng}@seu.edu.cn

Corresponding author.

###### Abstract

A _partial label_ (PL) specifies a set of candidate labels for an instance and _partial-label learning_ (PLL) trains multi-class classifiers with PLs. Recently, many methods that incorporate techniques from other domains have shown strong potential. The expectation that stronger techniques would enhance performance has resulted in prominent PLL methods becoming not only highly complicated but also quite different from one another, making it challenging to choose the best direction for future algorithm design. While it is exciting to see higher performance, this leaves open a fundamental question: _what makes a PLL method effective?_ We present a comprehensive empirical analysis of this question and summarize the success of PLL so far into some _minimal algorithm design principles_. Our findings reveal that high accuracy on benchmark-simulated datasets with PLs can misleadingly amplify the perceived effectiveness of some general techniques, which may improve representation learning but have limited impact on addressing the inherent challenges of PLs. We further identify the common behavior among successful PLL methods as a progressive transition from uniform to one-hot pseudo-labels, highlighting the critical role of _mini-batch PL purification_ in achieving top performance. Based on our findings, we introduce a _minimal working algorithm_ that is surprisingly simple yet effective, and propose an improved strategy to implement the design principles, suggesting a promising direction for improvements in PLL.

## 1 Introduction

_Partial-label learning_ (PLL) [14; 12; 42] has been an established discipline in the weakly supervised learning field [50; 51] for decades. It aims to train multi-class classifiers from instances with _partial-labels_ (PLs)--a PL for an instance is a set of candidate labels, where a _fixed but unknown_ candidate is the true label.

As benchmarking on simulated PLL versions of vision datasets becomes standard practice for evaluating PLL methods, new PLL approaches are emerging that integrate diverse advanced techniques to enhance the performance. While many methods show great promise and some headway has been made in understanding the methodology against ambiguous label assignments , we find that state-of-the-art (SOTA) approaches _look quite complicated and differ significantly from each other_ (Table 1), making it challenging to choose the best direction for better algorithm design.

In this paper, we aim to summarize the success of PLL so far, and understand the indispensable elements in a well-performing PLL method, which can be condensed into _minimal algorithm design principles_. For this purpose, we think of the taxonomy of PLL approaches first, comb the evolution and trends in this field, thereby uncovering key factors that drive their effectiveness and motivating future research.

The widely accepted PLL taxonomy  divides methods based on the treatment of PLs into _identification-based strategy_ (IBS) and _average-based strategy_ (ABS):

* IBS disambiguates each PL to select the most likely true label for training;
* ABS treats all candidate labels equally for training.

However, the boundary between these two categories is vague, resulting in a lack of consensus on the category of many recent approaches which _purifies each PL on the fly during model training_. They initially look like ABS, since uniform targets are always used to prepare for true-label selection, and as training progresses, the optimization targets for candidate labels become distinct gradually, such that they exhibit IBS-like characteristics. The tricky fact is that such approaches are classified as ABS or IBS hinging on which definition of category researchers are willing to relax (e.g.,  versus )! In light of the evolving approaches within PLL, is there a need to establish a third category within the taxonomy to capture the "hybrid strategy", as attempted by recent work like ?

We suggest that the answer is in the negative, since our analysis confirms the fluidity of method categorization within PLL, emphasizing that IBS, ABS, and so-called hybrid strategy often overlap due to the dynamic nature of their implementation:

* Training manner of IBS. Typical IBS approaches  perform one-step EM to identify the true label in each PL (E step) and then train a supervised classifier (M step). To mitigate overfitting to wrongly identify labels, multi-step EM IBS  are proposed. As iterations are executed more frequently, the identifocation of true labels becomes increasingly smooth (Figure 1).
* Implicit differentiation in ABS. Typical ABS approaches  design a loss function that does not differentiate candidate labels, e.g., enforcing the softmax outputs of them to sum to 1 . However, stochastic optimization algorithms can _implicitly_ lead to distinct outputs for each candidate label and show a progressive purification characteristic (Figure 1 and Lemma 3.1).
* Execution matters. Whether a method truly exhibits progressive characteristics and the extent of progression also depend on the optimizers used and hyperparameters like the learning rate and batch size (Figure 4).

Therefore, predefining a method's category and then asserting its utility can limit our understanding of its true nature and effectiveness. Further, our empirical investigations reveal a key insight: all successful PLL algorithms exhibit a common behavior characterized by a _progressive transition from uniform to one-hot pseudo-labels_, facilitated by the combination of PL purification and model updates in a _mini-batch-wise manner_. Building on this core strategy, modern methods also integrate various techniques from other domains, exemplified by Match from semi-supervised learning , aiming to further enhance model performance. While intuitively, better performance could be achieved if stronger techniques are employed, our findings indicate that these enhancements often yield marginal gains when compared to the primary benefits derived from mini-batch PL purification. Notably, even

Figure 1: Training accuracy and confidence margin of predicted pseudo-labels for traditional IBS and ABS methods on FMNIST with PLs: (a-b) show the granularity of EM execution in classical IBS methods is refined from a single step to an entire epoch, facilitating a smoother transition from uniform to one-hot pseudo-labels; (c-d) demonstrate that when ABS methods are optimized using SGD, the optimization targets for candidate labels can gradually become distinct.

when these additional techniques result in significant improvements, they tend to boost the model's ability to learn representations rather than resolving the inherent ambiguities of PLs.

The main contributions of our paper can be summarized as follows: (i) We advance the understanding of PLL taxonomy and establish minimal algorithm design principles. At the core of these principles is mini-batch PL purification, a fundamental aspect that goes beyond using supervised information. These principles not only enhance the efficiency of algorithm development but also act as a conclusive work to prevent redundant efforts in future research. (ii) We analyze the design philosophies and component frameworks of SOTA PLL methods, conducting comprehensive studies on benchmark-simulated datasets with PLs. Building on this, we highlight a _minimal working algorithm_ that adheres to our design principles, and propose an enhancement strategy to mini-batch PL purification that have the potential to elevate performance across all existing SOTA methods.

## 2 Preliminaries

### Notation

Consider a \(k\)-class classification problem. Let \(\) be features and \(y\{1,2,,k\}\) be labels. Then one has \((,y)\) sampled from the ground-truth joint density \(p(,y)\) over \(\) in supervised learning. PLL deals with PLL data \((,S)\), which is independently drawn from a corrupted distribution \(p(,S)\) of \(p(,y)\) with \(p()\) unchanged. \(S\{2^{[k]}[k]\}\) denotes a PL, and \(=(_{i},S_{i})_{i=1}^{n}\) is a PLL dataset. The key assumption of PLL is that the latent true label of an instance is always included in its PL, i.e., \(p(y S|,S)=1\). Let \(^{k-1}^{k}\) denote the \(k\)-dimensional simplex. Let \(f:^{k-1}\) be a multi-label classifier to be trained, specifically, a composite of a backbone (e.g., ResNet ) and an inverse link function \(^{-1}\) (e.g., softmax), so that \(f()\) can be interpreted as probabilities. Let \(:^{k-1}_{+}\) be a surrogate loss function, e.g., cross-entropy loss. The classification risk of \(f\) is defined as \((f)=_{p(,y)}[(f(),y)]\), which is the performance measure we would like to optimize.

### Backgrounds

In this section, we review recent prominent PLL works. In PLL, a common practice is to adopt a weighted objective of the form

\[(f)=_{p(,S)}_{z S}w(,z)(f(),z),\] (1)

with the optimal weights \(w(,z)=p(z|)\). If \(\) is the cross-entropy loss, the weight can be integrated directly into the loss function, acting as optimization target (pseudo-label) for \(\) directly. In classical taxonomy for PLL , IBS trains predictive models based on fixed weights assigned to the training instances, i.e., \((,z)=\{0,1\}^{k}\), while ABS sets uniform weights during training, i.e., \((,z)=1/|S|\).

   &  Mini-b. \\ purif. \\  } &  & Data & Exp.Mov & Match &  \\  & & & augment. & Average & DA & DM \\  PRODEN  & \(\) & \(\) & \(\) & \(\) & \(\) & \(\) & DNNs learn pattern first \\ CC  & \(\) & \(\) & \(\) & \(\) & \(\) & \(\) \\ LWC  & \(\) & \(\) & \(\) & \(\) & \(\) & \(\) \\ PiCO  & \(\) & \(\) & \(\) & \(\) & \(\) & \(\) \\ DPLL  & \(\) & \(\) & \(\) & \(\) & \(\) & \(\) \\ SoLar  & \(\) & \(\) & \(\) & \(\) & \(\) & High-confid. sample is likely correct \\ PaPi  & \(\) & \(\) & \(\) & \(\) & \(\) & Same class representations cluster \\ CroSel  & \(\) & \(\) & \(\) & \(\) & \(\) & Stable high-confid. sample is correct \\  

Table 1: Comparison of techniques used in eight prominent PLL methods. \(\)\(/\) indicates whether a technique is used, and an underline denotes the key components of the respective methods.

**Definition 2.1** (Mini-batch PL purification).: Mini-batch PL purification is a process where for each mini-batch \(\) selected at iteration \(t\), the weights are updated such that the distinction among candidate labels' contributions increases over iterations:

\[w_{t+1}(;f,S)=g(),\] (2)

with \(g\) being a strictly increasing function that increases the weight for more likely candidate labels according to the model's confidence. The model's parameters \(_{t}\) are updated by optimizing a weighted loss over \(\):

\[_{t+1}=_{t}-_{t}_{}_{(,S) }(f(;_{t}),S;w_{t+1}()).\] (3)

The standard practice is initializing the weights uniformly \(w_{i}^{0}=1/|S|\) if \(i S\) and \(w_{i}^{0}=0\) otherwise, and let \(f^{0}\) be initialized randomly. The model \(f^{0}\) is then updated for at least one epoch to perform a preliminary training phase. Then in each mini-batch of \(t\)-epoch, \(w()\) is computed where \(f\) is fixed, and then \(f\) is updated by the weighted objective where \(w\) keeps fixed in backpropagation. An instantiation of mini-batch PL purification was first introduced by . They use a delayed mechanism, i.e., \(w()\) is computed by the output of historical model \(f^{t-1}\) on \(\), implicitly assuming that DNNs learn pattern first , and the delayed mechanism mitigates the accumulation of errors. Then, some methods replace the delayed mechanism with Match techniques to estimate \(w\), which may rely on either Siamese networks  applied to two or more inputs (dual-augmentation match, i.e., DA), or co-teaching networks  where one network's outputs serve as targets for the other (dual-model match, i.e., DM). Furthermore, some methods advocate DA+DM framework; for example, PiCO  involves mutual guidance of two heterogeneous classifiers, with one built on top of a supervised contrastive learning architecture . In addition techniques borrowed from various communities have propelled PLL methods to top performance, such as mixup  and data augmentation like cropping and flipping , which have become mainstream.

As shown in Table 1, prominent methods in recent years rely on the mini-batch PL purification strategy and specific enhanced tools. However, our research reveals a significant disparity in the impact of these components, at least on current benchmarks. Mini-batch PL purification is sufficient to provide a reliable guarantee of performance, while the additional tools contribute relatively little. Although techniques like data augmentation can enhance the performance by improving the model's robustness to input variations, they primarily boost representation learning, but not benefits the disambiguition for PLL.

## 3 Understanding Minimal Algorithm Design Principles

In this section, we investigate four SOTA PLL methods that have consistently demonstrated top accuracy across various benchmark tasks. By methodically dissecting these methods and analyzing the components credited for their robustness against PLs, we distill the essential elements contributing to their success. We defer the experiments details to Appendix.

### PLL with DA Match

Algorithm details.The key contribution of DPLL  lies in incorporating neighborhood consistency, a technique adapted from semi-supervised learning, into PLL. This technique maximizes the similarity among several perturbed views of the same instance, thereby inducing smoothness in the structure of learned representations, referred to as dual-augmentation match (DA Match).

Specifically, DA Match instantiates Eq. 1 by specifying the loss function as the KL divergence and estimating the weights by a weighted sum of outputs of all augmentations in \(()\):

\[(,f)=-_{()}()^{ } f(()),\] (4)

\[(,z)=()}f_{x} ())^{1/|()|}}{_{j S}(_{( )}f_{j}())^{1/|()|}}&z S,\\ 0&.\] (5)

\(\) is updated in a mini-batch-wise manner along with the model parameters and is initialized uniformly (mini-batch PL purification). In addition, the learning objective of DPLL includes another loss function as

\[(,f)=-_{i S}(1-f_{i}(())),\] (6)where the vector subscript indicates the element is that position. It encourages the output of each non-candidate label to be zero.

Evaluation 1. Specific implementations do not matter.First, we replace the two terms in learning objective with alternative approaches. Eq. 6 is conceptually equivalent to encouraging the sum of the outputs for the candidate labels to be close to one, i.e,

\[(,f)=-_{i S}f_{i}(()).\] (7)

Instead of using a shared target for all views, we modifies the optimization target for each view separately based on the output of the other view:

\[(,f)=-_{2}()^{} f(_{1})+ _{1}()^{} f(_{2}),\] (8)

where \(_{1},_{2}()\), and

\[_{2(1)}(,z)=f_{z}(_{1(2)})/ _{j S}f_{j}(_{1(2)})&z S,\\ 0&.\] (9)

We combine two DA Match terms and two loss functions in pairs, respectively. As can be seen from Table 2, there was no significant difference between the results of these four combinations. This indicates that the specific implementation methods of DA Match, including the exact form of the loss function, is not critical.

Evaluation 2. Additional losses do not matter.We then split the combined learning objectives into two separate objectives to examine the difference in the contribution of these two components to learning. We found that Eq. 6 and Eq. 8 were comparable under the relatively simple settings, but Eq. 8 outperformed Eq. 4 in challenging scenarios (CIFAR-100 and mini-ImageNet). Note that Eq.6 is a traditionally considered ABS loss, and Eq. 8 implements mini-batch PL purification. It is commonly believed that ABS does not require identifying the true labels during training, leading to over-parameterized DNNs memorizing all candidate labels , which results in poor performance. However, as discussed in Section 1, ABS can still achieve acceptable performance because the optimization process may induce differentiated outputs. We will elaborate on this in more detail in Section 3.4. Another noteworthy observation is that Eq. 8 not only did not lead to a decrease in accuracy compared to the original DPLL, but even showed some improvement, which is likely because Eq. 8 can model neighborhood consistency better than Eq. 4.

So far, we have extracted a core unit from DPLL, which takes the form of Siamese networks : a weight-sharing network applied on two (or more) inputs for comparing, and PLs prevent the model from collapsing, i.e., outputting a constant for all inputs. We call Eq. 8_dual augmentations single model_ (DASM), as depicted in Figure 5. However, it remains to be seen whether the effectiveness of DASM is due to mini-batch PL purification or neighborhood consistency.

Evaluation 3. Mini-batch PL purification does matter.We modify the learning strategy of DASM by either altering the mini-batch PL purification strategy or removing the consistency component. We compare them in Table 2, where the "-H", "-S" or "-E" suffix means using the hard pseudo-labels, one-step iteration or epoch-wise iteration. Specifically, DASM-H uses hard labels as optimization targets for Eq. 8:

\[_{2}()=^{i},_{1}()=^{j},\;\;_{1})$ and $j= f(_{2})$},\] (10)

where \(^{i}\) denotes the \(i\)-th standard canonical vector, i.e., \(^{i}\{0,1\}^{k},^{}^{i}=1\). DASM-S simulates one-step EM methods by training the model with uniform targets for the first 50 epochs, and then transforming PLL into supervised learning by using one-hot pseudo-labels (i.e., the argmax of the model's output for each instance at the 50th epoch) for the next 450 epochs. The results indicated that the performance of DASM-H and DASM-S was inferior to DASM. This can be attributed to the models' inability to adjust learning targets at the _appropriate_ time based on the underlying learned patterns: Since DNNs tend to fit easy patterns first and gradually memorize harder ones, a phenomenon known as memorization effects , DASM-H may remember unreliable information due to random initialization, and DASM-S may lead remember too much undesired memorization . DASM-E shifts from a mini-batch-wise manner to an epoch-wise manner, performing pseudo-label estimation and model updates at the epoch level, which resulted in decreased accuracy. Compared to DASM-E, mini-batch manner benefits from using the up-to-date model for generating optimization objectivesand also improves computational efficiency. In addition, we change the dual feedforwarding to single. The optimization target of an input is modified in place according to its own output, which we term _single augmentations single model_ (SASM). It was somewhat surprising that this method does not require additional components, performed remarkably well, implying DA may not be necessary.

**Evaluation 4. Does data augmentation matter?** Additionally, removing data augmentation from DASM, as in DASM w/o.aug, causes a decrease in accuracy as expected. We will discuss its impact further in Section 3.3.

### PLL with DA+DM Match

Algorithm details.PiCO  enhances representation learning by incorporating supervised contrastive learning into PLL. It utilizes two heterogeneous classifiers sharing a backbone (one linear and one contrastive-based), guiding each other to instantiate Eq. 1. PaPi  investigates PiCO and identifies limitations in the contrastive learning module. Thus PaPi adopts a more efficient approach inspired by the delayed mechanism in PRODEN, instantiating Eq. 1 without the need to maintain two separate models. Besides, PaPi also uses the zero-and-normalized outputs of historical models to guide a prototypical classifier that shares the same backbone with the linear classifier. Both methods feed forward different views of the same input. We refer to such framework as dual-augmentation and dual-model match (DA+DM Match). CroSel  is the latest PLL method that, in addition to using the DM framework to generate optimization targets for each other, also selects samples with more accurate pseudo-labels for the other model to compute supervised loss.

Evaluation.At a high level, PiCO draws inspiration from co-teaching : instead of training a single classifier, it trains two classifiers simultaneously and lets them teach each other in every mini-batch. We simplify this idea by removing the contrastive-based classifier and using two networks with the same architecture but different initialization, which is also CroSel without its sample selection module. We call such method _dual augmentations dual models_ (DADM). Taking it a step further, _single augmentation dual models_ (SADM) removes one data augmentation, feeding both networks the same view of an instance within the same epoch. Conversely, if we cancel DADM from CroSel, the remaining implementation is co-teaching adapted for PLL (Coteaching in Tabel 4). For PaPi, we strip away the prototypical classifier, resulting in a streamlined version akin to PRODEN with added data augmentation (PRODEN+), to explore whether the specific instantiation of DM makes a difference. Figure 5 illustrates their basic workflow.

Our results are shown in Table 4. Both DADM and SADM outperformed PiCO and were comparable with CroSel, and PRODEN+ generally matches the performance of PaPi. Deleting the implementation of mini-batch PL purification, whether by altering the iteration frequency or replacing soft pseudo

    &  Mini-b. \\ purif. \\  } & ABS &  &  &  &  & mini-I.Net \\  & & & loss & augment. & & 0.3 & 0.7 & 0.05 & 0.1 & ins.-dep. \\  Eq. 4+6 DPLL & ✓ & ✓ & ✓ & ✓ & 93.82 & **92.68** & 76.81 & 75.93 & 52.22 \\ Eq. 4+7 & ✓ & ✓ & ✓ & ✓ & 93.80 & 92.44 & 79.35 & 78.85 & 53.40 \\ Eq. 8+6 & ✓ & ✓ & ✓ & ✓ & 93.49 & 92.19 & **79.75** & 78.87 & 53.78 \\ Eq. 8+7 & ✓ & ✓ & ✓ & ✓ & 93.57 & 92.20 & 79.53 & 78.85 & 54.09 \\  Eq. 6 & \(\) & ✓ & ✓ & \(\) & 93.58 & 92.12 & 76.96 & 75.94 & 44.69 \\ Eq. 8 DASM & ✓ & \(\) & ✓ & ✓ & 93.89 & 92.85 & 79.70 & **79.62** & 54.71 \\  DASM-H & \(\) & \(\) & ✓ & ✓ & 93.86 & 92.37 & 78.25 & 33.22 & 34.59 \\ DASM-S & \(\) & \(\) & ✓ & ✓ & 93.28 & 90.75 & 78.65 & 76.22 & 36.71 \\ DASM-E & \(\) & \(\) & ✓ & \(\) & 93.80 & 92.35 & 79.30 & 79.11 & 53.44 \\ SASM & ✓ & \(\) & ✓ & \(\) & **93.83** & 92.18 & 79.38 & 78.19 & **55.45** \\  DASM w/o.aug & ✓ & \(\) & \(\) & ✓ & 90.86 & 89.60 & 60.18 & 56.39 & 30.85 \\   

Table 2: Conceptual and empirical comparisons (%) of various simplifications of DPLL. \(/\) indicates whether a technique is used.

labels with hard pseudo-labels, consistently leads to a decline in performance. The observations reaffirm that mini-batch PL purification is essential for achieving top performance. By comparing the performance of the DM framework with the SM framework, we discover that the DM framework's edge often comes from the diverse capabilities of the two networks, which help handle the noise introduced by PLs. On the other hand, the DA methods without any special design (DASM, DADM, PRODEN+) showed suboptimal performance than the SA methods, perhaps hinting at the importance of exploring different augmentation methods  to discover appropriate choices for class-invariant patterns, remaining for future research.

### Does Data Augmentation Help Identification Better?

Our findings indicate that mini-batch PL purification and data augmentation are pivotal for PLL, achieving competitive performance when both techniques are implemented. Data augmentation is a well-established regularization tool, enhancing model robustness to input variations. In the following, we explore whether its role in PLL extends beyond this conventional purpose, specifically whether it facilitates the crucial task of identifying the true label among candidate labels. If data augmentation aids true-label identification, we would expect that augmented examples generate more accurate pseudo-labels, then enhancing the performance. Specifically, we experiment with DASM by setting one view as augmented and the other as non-augmented. We also use different training setups: (i) using zero-and-normalized pseudo-labels generated from original \(\) to supervise augmented \(\), and (ii) the reverse, using augmented \(\) to supervise original \(\). The results are presented in Figure 2.

Switching from dual paths to a single path while retaining supervised learning on augmented instances with pseudo-labels from the original instances showed little change in accuracy. However, when using pseudo-labels from augmented instance to supervise original one, performance drops significantly. This suggests that data augmentation alone is insufficient to preserve the mutual information between examples and their true labels, as augmented views may discard task-relevant information, thereby degrading performance. Following this reasoning, our results suggest that data augmentation indirectly benefits the classifiers built upon representation learning rather than aiding in label disambiguation. Therefore, it should NOT be considered a design principle for PLL.

### PLL through Pseudo-Label Manipulation vs.Loss Minimization

Mainstream methods mentioned above conduct mini-batch PL purification primarily by directly manipulating the optimization targets of candidate labels. However, as analyzed in Section 1 and observed in Eq. 6 of Table 2, using stochastic algorithms to minimize loss functions, even ABS loss funtions that are traditionally considered to "treat all candidate labels equally", can also implicitly result in a progressive effect of pseudo-labels. To our knowledge, no existing research has explored the relationship between pseudo-label manipulation and loss minimization. Our findings raise the question: how do these two methods compare in terms of their effectiveness and mechanisms in the context of PL identification?

We investigate several representative PLL losses, which are traditionally thought as ABS:

* Modified negative log likelihood loss (Eq. 6) : \(_{}(,f)=-_{i S}(1-f_{i}())\);
* APL loss : \(_{}(,f)=_{i S}(f( ),i)\), with GCE loss  as the component \(\);* Maximum likelihood loss : \(_{}(,f)=-_{i S}f_{i}()\).

Denote the scores of \(\) outputted by the last layer before softmax as \(\), i.e., \(^{-1}()=f()\) where \(f=(^{-1} f^{(n)} f^{(1)})\). Let us look at the gradients of \(_{}\) and \(_{}\):

\[}}{_{k}}=-f_{k} _{i S}_{i}}}{e^{_{i}}-e^{_{i}}}&k S,\\ f_{k}(1-_{i S,i k}_{i}}}{e^{_{i}}-e^{_ {i}}})&,\] (11)

\[}}{_{k}}=- {|S|}(f_{k}_{i S,i k}f_{i}^{q}-f_{k}^{q}(1-f_{k}))&k S,\\ f_{k}_{i S}f_{i}^{q}&,\] (12)

where \(q(0,1]\) is a tunable parameter of GCE. From a gradient perspective, we observe that while the implicit optimization targets for all candidate labels are the same for each loss function, their optimization speeds differ. Specifically, the gradients of the candidate labels are consistently negative until one candidate label accumulates all the probabilities, which implies that both loss functions promote the output of each candidate label to converge to 1. As a result, the candidate labels compete for dominance. A label with a higher output probability experiences a larger gradient and thus becomes the winner. According to the memorization effects of DNNs, such a label is more likely to be the true label receiving a larger gradient at the beginning, which explains why the labels become distinguishable with these two losses. However, since the optimization targets for all candidate labels remain the same, minimizing these two losses does not align with our definition of mini-batch PL purification where the optimization targets are expected to diverge progressively.

Then we focus on the third loss \(_{}\). We examine its gradients as

\[}}{_{k}}=f_{k}- _{k}}}{_{i S}e^{_{i}}}&k S,\\ f_{k}&.\] (13)

It is crucial to recognize two key points: (i) The philosophy of \(_{}\) is to ensure that the output of all candidate labels sums to 1, which is _exactly the same_ as that of \(_{}\), which requires the output of all non-candidates to sum to 0. However, their gradients are _completely different_, indicating that they lead to different optimal empirical solutions even with identical initialization and stochastic optimizer. (ii) When learning with \(_{}\), the implicit optimization target of an instance is the zero-and-normalized outputs of current model on this instance itself, exhibiting _consistent behavior with pseudo-label manipulation_ in SASM.

**Lemma 3.1**.: _Suppose using the same stochastic optimizer, then performing SASM is mathematically equivalent to minimizing \(_{}\)._

Empirical results in Table 5 also verified the theoretical findings. However, pseudo-label manipulation offers greater flexibility as it allows for more arbitrary modifications to the optimization targets, as DASM, SADM, etc. have done, and additional steps over generating soft pseudo-labels, such as sharpening , but the targets of loss functions are fixed.

Now, our empirical investigations have firmly established the necessity of mini-batch PL purification along with using supervision. Supervision can be used in two ways: directly within the loss function as it in supervised learning, or to manipulate pseudo-labels on-the-fly. We identify SASM is the minimal working algorithm. It achieved superior or at least comparable performance compared with SOTA PLL methods in most cases, while not requiring multiple forward propagations or additional components.

### Probing the Implementation of Mini-Batch PL Purification

Here, we examine the implementation of mini-batch PL purification, raising at least two questions: Q1. Does different initialization methods impact the performance? Q2. Why does model confidence in PLs is effective to disambiguation?

In early training stages, our primary concern is if initialization methods might cause certain candidate labels to receive significantly higher confidence. Consider a neural network where weights are independently drawn from a standard normal distribution with zero mean and variance \(^{2}\) (as in normal initialization, Xavier initialization , He initialization ). For an instance \(\), the output \(z\) of a neuron after a ReLU activation is given by \(z=(0,+b)\), where \(\) represents the weight vector and \(b\) is a small constant bias. By the Central Limit Theorem, the mean of the weights \(=1/n_{i=1}^{n}_{i}\) for a sufficiently large number of neurons \(n\) approaches a normal distribution with mean zero and variance \(^{2}/n\). Applying Chebyshev's inequality, we have \(P(|| a)^{2}/(na^{2})\). As \(n\), \(\) is close to zero with high probability. Then the output for each neuron \(z\) will be close to \(b\). By a similar reasoning, this result generalizes to deeper layers, suggesting that the initial outputs across classes approximate a uniform distribution regardless of the number of layers.

**Lemma 3.2**.: _For a neural network initialized with weights \(\) drawn from a normal distribution \((0,^{2})\), the initial outputs across classes approximate a uniform distribution as the number of neurons \(n\)._

Then we explain why using model's output as a proxy for the probability that a candidate label is the true label works. This practice of using the high-confidence label as the true label, introduced to PLL by , has long been foundational in noisy-label learning (e.g., [16; 23]). Its success in PLL hinges on a key assumption: the true label has a higher probability of appearing among the candidate labels than any incorrect label. In fact, the experimental setups employed across PLL methods impose a further restriction on this assumption, that is, \(p(y S|x,S)=1,p(i S|x,S)>1, i y\). This setup implies that, within any sufficiently small neighborhood in the data space, the true label will dominate. Consequently, when stochastic gradient-based optimizers are used, the true label tends to contribute more frequently to the objective function, making it more likely to be learned first.

## 4 Improving Mini-Batch PL Purification

### Motivation

The standard practice involves initiating the process with uniform pseudo-labels for one epoch to bootstrap the classifier's basic capabilities. Our first observation is that the effect of warming up for one epoch is nearly indistinguishable from not warming up at all, prompting further investigation into the actual efficacy of the warm-up phase. Suppose a neural network is initialized with weights drawn from a Gaussian distribution with mean zero and a sufficiently small variance. If the inputs are normalized, the pre-activation values across a neural network tend to be small and centered around zero. When these values are input to a softmax function, the resulting distribution across classes tends to uniformity.

Our second observation is that a prolonged warm-up using uniform pseudo-labels often leads to the network overfitting to candidate labels, as illustrated in Figure 3, evident around 50 epochs with a decline in validation accuracy. While overfitting to the training data becomes apparent about 120 epochs, marked by a drop in training accuracy after previously reaching a peak.

We simply terminate the warm-up phase at a local maximum in validation accuracy, about 5 epoch, preventing excessive memorization while preserving more information beneficial for generalization. Then the results showed a little improvement. Several approaches [34; 24] have used multiple epochs for warm-up and treat the number of warm-up epochs as a hyperparameter. However, due to the varying difficulty levels across samples, using a uniform duration for the warm-up phase could result in performance disparities among different subgroups within the dataset. This suggests the need for an adaptive warm-up strategy.

### StreamPurify: An Instance-Dependent Warm-Up Strategy

Building upon the analysis and our established design principles, we propose StreamPurify, a novel instance-dependent warm-up strategy, which fine-tunes the entry into the mini-batch PL purification phase based on each instance's readiness. During the initial training phase, it selectively channels instances that have higher confidence in the accuracy of their pseudo-labels into the PL purification phase, while others continue training with uniform targets until they meet the readiness criteria. This filtered progression helps prevent DNNs from harmfully memorizing incorrect pseudo-labels and mitigate the accumulation of errors from inadequately learned samples. Differing from sample selection techniques used in noisy-label learning  that reevaluated samples in every iteration, our filter approach is conducted without replacement. Once the training samples are transitioned to the purification phase, they do not revert to uniform targets, ensuring that the strategy remains in line with mini-batch PL purification.

StreamPurify is compatible to existing PLL methods and can absorb various sample selection criteria, such as small-loss trick. We adopt the sample selection method from CroSel  that chooses the samples with stable and high confidence as a filter criterion within StreamPurify, and combine it with the mini-batch PL purification approaches discussed in our paper. Empirical evaluations indicate that methods augmented with StreamPurify generally exceed the performance of their conventional counterparts, validating the effectiveness of StreamPurify, especially in complicated learning scenarios. This substantiates the robustness and adaptability of instance-dependent warm-up, suggesting it as a promising direction for future improvements in PLL.

## 5 Discussion and Future Work

We have systematically delineated the core components underlying successful PLL methods, centering our insights around the pivotal effect of mini-batch PL purification. We have proposed StreamPurify, an enhanced mini-batch PL purification strategy that tailors the learning path for each sample based on its state of readiness. We reaffirm that strictly categorizing PLL methods as IBS or ABS may oversimplify the dynamics of how these methods operate in practice. In the future, we wish to explore advanced PLL approaches guided by the minimal algorithm design principles. We also wish to extend the applicability and understanding of PLL methods to domains beyond vision tasks.