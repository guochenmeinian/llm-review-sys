# Dynamic Context Pruning for Efficient and Interpretable Autoregressive Transformers

Sotiris Anagnostidis\({}^{,}\) &Dario Pavllo\({}^{,}\) &Luca Biggio\({}^{,}\) &Lorenzo Noci\({}^{}\)

&Aurelien Lucchi\({}^{}\) &Thomas Hofmann\({}^{}\)

\({}^{}\)ETH Zurich

\({}^{}\)ML, CSEM SA

\({}^{}\)University of Basel

Equal contribution. Correspondence sotirios.anagnostidis@inf.ethz.ch.

###### Abstract

Autoregressive Transformers adopted in Large Language Models (LLMs) are hard to scale to long sequences. Despite several works trying to reduce their computational cost, most of LLMs still adopt attention layers between all pairs of tokens in the sequence, thus incurring a quadratic cost. In this study, we present a novel approach that dynamically prunes contextual information while preserving the model's expressiveness, resulting in reduced memory and computational requirements during inference. Our method employs a learnable mechanism that determines which uninformative tokens can be dropped from the context at any point across the generation process. By doing so, our approach not only addresses performance concerns but also enhances interpretability, providing valuable insight into the model's decision-making process. Our technique can be applied to existing pre-trained models through a straightforward fine-tuning process, and the pruning strength can be specified by a sparsity parameter. Notably, our empirical findings demonstrate that we can effectively prune up to 80% of the context without significant performance degradation on downstream tasks, offering a valuable tool for mitigating inference costs. Our reference implementation achieves up to \(2\) increase in inference throughput and even greater memory savings.

## 1 Introduction

The introduction of Transformers (Vaswani et al., 2017) in Large Language Models (LLMs) has profoundly influenced the landscape of Natural Language Processing (NLP), due to their appealing scaling properties (Kaplan et al., 2020) and their ability to train efficiently on modern hardware architectures designed for extensive parallel computing. As LLMs grow larger and more complex, the challenges associated with training and deploying them become more prominent. Especially challenging is the quest for processing increasingly longer sequences, as pure self-attention layers scale quadratically in sequence length during train and inference.

To address this limitation, several efforts focus on efficient implementations of the attention mechanism on dedicated hardware (Dao et al., 2022; Touvron et al., 2023), or on algorithmic procedures to directly tackle the quadratic complexity. The latter direction has led to numerous variants sacrificing the generality of the standard attention mechanism in favor of more efficient alternatives (Tay et al.,2020, Kitaev et al., 2020, Choromanski et al., 2020, Katharopoulos et al., 2020, Zaheer et al., 2020, Shi et al., 2021, Lin et al., 2022, Zhu and Soricut, 2021, Dai et al., 2020], some of which are illustrated in Fig. 1. Specifically, a large number of these methods focus either on sparsifying the attention weights, reducing the size of the available context to each token, or compressing the number of tokens to reduce the size of the attention matrix.

These methods, however, are inherently static, in the sense that each token is either forced to attend to a fixed pre-specified context window, or the input context is compressed to a fixed dimensionality, regardless of the information content of the input sequence. Furthermore, a performance gap still exists with respect to pure self-attention in many applications, thus implying the existence of a non-trivial trade-off between the span of the attention context and the model's capabilities [Dao et al., 2022, Sun et al., 2021, Beltagy et al., 2020].

To address these challenges, and enhance inference efficiency, while staying faithful to pure self-attention, we pose the following question:

_Can we dynamically prune past content based on the available context,_

_while preserving as much as possible the expressivity of the model?_

In response to this question, we introduce a novel method for context pruning in Transformer-based decoder architectures. Our approach adds a minimal amount of additional training parameters that enable individual tokens to dynamically remove portions of the input sequence in a layer-wise fashion. Once part of the context is removed, it is disregarded for the remaining part of the autoregressive generation process, leading to reduced memory usage and computational requirements during inference. To this end, we also design a dynamic data structure that implements efficient insertion/removal of tokens from the context while supporting batched inference. In contrast to traditional methods relying on local or sparse attention, which may not capture the nuances and dynamic nature of the data over long contexts, ours leverages contextual cues to dynamically determine the relevance of the available information through a learned mechanism. This is achieved by making use of a sparse sigmoid function [Peters et al., 2019, Martins et al., 2020]. As demonstrated by our experimental evaluations, this allows us to extract and utilize essential details in a more adaptive and accurate manner. The degree of pruning can be effectively controlled through a hyperparameter that effectively accounts for the sparsity level.

Our technique serves as a modular building block for existing pre-trained models and can be easily integrated through a minimal fine-tuning stage. For our study, we focus on GPT-2 models [Radford et al., 2019] as they are publicly available and widely benchmarked, but due to the uniformity of modern architectures, our approach can be straightforwardly extended to any autoregressive Transformer. Moreover, since our method is based on context pruning, it can be seamlessly combined with other approaches aimed at improving inference efficiency, such as quantization, weight pruning, approximate attention, or other hardware optimizations.

We find that up to \(80\%\) of the context can be successfully pruned, with minimal deterioration in terms of perplexity and zero-shot performance, while requiring significantly fewer resources during inference. We showcase how these improvements can lead to measurable practical gains, by providing an efficient implementation that reduces memory usage for caching during token generation. More specifically, for larger context sizes we get up to \(50\%\) wall-time latency reduction for each generation step, while still decoding with up to \(2\) larger batch sizes, leading thus to significant performance benefits. These findings highlight the potential of context pruning as a powerful technique to enhance the efficiency and interpretability of Transformers in NLP.

## 2 Related Work

Despite exhibiting human-level performance on a number of challenging tasks, LLMs are resource-intensive and inefficient. While the human brain consumes roughly the amount of energy equivalent to a dim light bulb, top-performing GPT models require multiple GPUs with \(\)80GB of memory each for inference [Strubell et al., 2019, Frantar and Alistarh, 2023a]. Several research efforts have been focusing on improving their efficiency and memory requirements from several different angles.

Weight Pruning and Quantization.Modern LLMs have high memory and compute requirements for both training and testing. To address this limitation, a number of research efforts [Kwon et al.,2022, Frantar et al., 2023, Frantar and Alistarh, 2023b] have resorted to the established practice of weight pruning [Hassibi et al., 1993] to efficiently compress the original model to a more manageable size. Remarkably, a large percentage of the original weights can be safely removed, resulting in only marginal perplexity growth [Bahl et al., 1983]. An alternative approach to reduce the memory and compute is quantization [Dettmers et al., 2022, Yao et al., 2022, Xiao et al., 2022, Frantar et al., 2022], which reduces the precision of the model's numerical representation. Quantization schemes [Dettmers et al., 2022] enable 8-bit matrix multiplication for both feed-forward and attention projection layers resulting in significantly improved memory allocation without incurring any performance degradation.

Efficient Transformers and context pruning.One primary constraint of Transformer-based models is their quadratic complexity with respect to the length of the input sequence. Extensive research explores alternatives that exhibit sub-quadratic scaling, resulting in three main strategies [Lin et al., 2022]. The first replaces the attention mechanism with an alternative operation that features more favourable scaling with the input sequence length [Peng et al., 2021, Katharopoulos et al., 2020, Choromanski et al., 2020, Schlag et al., 2021]. While several recent methods in this category show promise, none have emerged as a definitive winner, and most state-of-the-art language models still rely on the standard attention mechanism [Touvron et al., 2023, Chowdhery et al., 2022]. The second approach proposed to compress the length of the input context, controlling the complexity of the attention operation but unavoidably sacrificing potentially relevant information from the original input [Lee et al., 2019, Wang et al., 2020, Jaegle et al., 2021]. The third approach involves pruning the attention matrix, preventing each token from attending to every other token within the context [Zaheer et al., 2020, Martins et al., 2020, Lee et al., 2023]. This line of research is motivated by the theoretical finding highlighting that sparse Transformers retain the expressivity of their dense counterparts [Yun et al., 2020]. Many methods in this category employ specially designed attention masks that aim to zero out as many entries as possible, often based on principles of locality, randomness, or a combination of both. The main drawback of these methods is their mostly static nature, meaning that every token is compelled to attend to a fixed context window and disregard the rest of the context regardless of its specific role within the input sequence. Our approach falls within this last category, and enables dynamic sparsification of the attention matrix for decoder models, without resorting to any potentially restricting inductive biases about its structure.

Implementation Speed-upRecently, hardware-optimized implementations [Dao et al., 2022, Touvron et al., 2023] have been proposed with the aim of optimizing computational resources during the training phase of Transformers [Hoffmann et al., 2022]. On the other hand, as recent breakthroughs have led to widespread adoption of these models [Ouyang et al., 2022, OpenAI, 2023, Kopf et al., 2023], performance during inference becomes more relevant by the day. In decoder-based autoregressive Transformers, the backbone architecture of most current state-of-the-art LLMs, inference involves evaluating and generating tokens one by one, using cached previous activations to avoid redundant computations. In contrast to training, the inference is memory bound [Shazeer, 2019, Ivanov et al., 2021, Pope et al., 2022]. Compute is under-utilized, especially when deploying larger models, as the time required to transfer model parameters and activations to hardware memory far exceeds the actual computational time. This is further exacerbated by recent trends to ever-increase the model size and enable longer context windows. As a result, batch decoding, a promising direction for more efficient utilization of hardware resources, is impeded.

Figure 1: Visualization of the causal attention weights associated with standard, local, sparse causal attention, and our approach. Adaptively sparse attention (rightmost) prunes weights dynamically for each token, and it does not impose any restricting inductive biases on the final attention structure.

## 3 Methodology

Background.We operate on sequences of text tokens \(\{0,1,,n_{}\}^{n}\), where \(n\) is the length of the sequence and \(n_{}\) is the vocabulary size. Tokens are embedded into \(^{0}^{n d}\) using an embedding layer, where \(d\) is the embedding dimension of the model. When necessary, we use the superscript \(\{1,2,,L\}\) to denote the representations and weights at different layers. One layer of the Transformer-decoder architecture (Vaswani et al., 2017) is defined as

\[=((^{-1}))+ ^{-1},\] (1) \[^{}=(())+ ,\] (2)

where MHA stands for Multi-head self-attention defined as

\[() =(_{1}(),_{2}( ),,_{h}())_{O},\] (3) \[_{i}() =(_{i},_{i},_{i} ).\] (4)

Here \(_{i}=_{Q_{i}}\), \(_{i}=_{K_{i}}\), and \(=_{V_{i}}\) are the queries, keys and values and SA denotes the single-head self-attention. The weight matrices \(_{Q_{i}},_{K_{i}},_{V_{i}}^{d p}\) linearly project the input embedding into the head dimension \(p\). Finally, \(_{O}^{d d}\) is the output projection. The feed-forward part of the Transformer is defined as

\[()=_{}(_{F_{1}}) _{F_{2}},\] (5)

where \(_{}\) is a nonlinearity, and \(_{F_{1}},_{F_{2}}\) are linear layers with typical dimensions \(_{F_{1}}^{d 4 d}\) and \(_{F_{2}}^{4 d d}\). A final projection layer \(_{}^{d n_{}}\) is used to project back to the vocabulary space and predict the next token from the representations \(^{L}\). We are focusing on Pre-LN (Xiong et al., 2020) decoder-only architectures, meaning that attention is causally masked, i.e. every input token \(i\) attends to the first \(i\) tokens in the input sequence. Conceptually, our method acts by predicting these attention masks using a learned mechanism in a layer-wise manner, with the introduction of additional constraints to make sure causality is preserved (i.e. if a token is dropped, it will remain dropped in the future). During inference, however, our method can efficiently be implemented by erasing tokens from the key-value cache commonly adopted in autoregressive attention models.

Background: key-value cache.In autoregressive Transformers, inference can be optimized by reusing pre-computed activations (keys and values) to accelerate the sequential generation of tokens (Ott et al., 2019; Vaswani et al., 2018; Wolf et al., 2020), bringing down the computational cost to generate a single token to \((n)\) from \((n^{2})\) (where \(n\) is the sentence length). Most existing sparse attention techniques ignore the specifics of this process and focus on sparsifying each attention operation separately. As non-attended tokens can still be attended to by subsequent tokens, memory benefits are limited. By contrast, our approach is compatible with this setting, allowing us to design an efficient batched data structure where dropped tokens are effectively removed from the computation.

Figure 2: We illustrate the state of the memory buffer at the start of each iteration for our proposed approach. Dropped tokens are irrelevant for any subsequent generation step and their cached activations are erased. Since self-attention is a set operation, the buffer (keys/values) of the dropped tokens can be reused by subsequent tokens, ensuring that the data structure is as packed as possible. Here “X” denotes tokens that are currently being dropped. Red boxes correspond to tokens that are already dropped, for which Key-Value values are no longer being cached.

### Adaptively Sparse Attention

We allow the network to selectively drop parts of the context that are no longer required. An illustration of our proposed method can be seen in Fig. 2. At each layer, we introduce the parameters \(_{Q_{}}^{},_{K_{}}^{} ^{d r}\) for dimension \(r\), that calculate the interaction queries and keys \(_{}^{},_{}^{}^{n  r}\), as \(_{}^{}=^{}_{Q_{}}^{}\) and \(_{}^{}=^{}_{K_{}}^{}\). We then calculate the _interaction_ of token \(k\) with token \(j\) at layer \(\) as:

\[_{k,j}^{}=_{n=j+1}^{k}}_{n,j}^{ }\;\;\;\;}_{n,j}^{}=(_{}^{})_{n}^{}(_{}^{})_{j }}{}+^{}),\;j<k\\ 1,\;j=k,\\ 0,\;j>k,\] (6)

where \(()\) denotes the sparse sigmoid function introduced in Section 3.2 and \(^{}\) a scalar parameter per layer, that controls the initial sparsity as seen in Fig. 3 (right). Indices in \(_{}^{},_{}^{}^{n  r}\) refer to the rows of the matrices. We can then modify the self-attention

\[(_{i}^{},_{i}^{},_{i}^{})= (_{i}^{}(_{i}^{})^{} }{}+(^{}))_{i}^{}.\] (7)

For \(j>k\) we set \(_{k,j}^{}=0\), which leads to masking entries in the self-attention, corresponding to the regular causal masking. We also impose that a token cannot drop itself, thus \(_{k,k}^{}=1\). We want to preserve information regarding the current token as its predictions are particularly important in determining the next token for the regular language modeling task that we are considering. Small values of \(}_{n,j}^{}\) impose partial masking of the corresponding token in the attention, and complete masking occurs when \(}_{n,j}^{}=0\). The cumulative product over tokens \(j+1 k\) in Eq. (6) imposes that dropping a token (when \((.) 0\)) has an irreversible effect, as it will remain dropped for all subsequent tokens, and hence for the remaining of the generation process. The complexity of the pruning logic is \((n d r+n^{2} r)\), which is lower than the one of the self-attention operation for \(r<d\).

Our mechanism allows layers to act independently, meaning that different sparsity patterns are encountered across layers. We also experimented with tying the model's dropping decisions with depth by imposing that a token dropped at a given layer cannot be attended to in subsequent layers. However, we observed worse results and hence did not pursue this further. This is perhaps expected, given numerous results and interpretability studies regarding sparsity patterns of attention heads at different layers (Ramsauer et al., 2020; Hao et al., 2021).

### Sparse Sigmoid

In Eq. (6), we use \(()\), as a sigmoid-like function to let the network decide when and what to drop. We favour binary decisions, leading to interaction values of either \(0\) or \(1\). Inspired by the \(\)-entmax function introduced in Peters et al. (2019); Martins et al. (2020), we define the \(\)-sigmoid (based on the entropies proposed by Tsallis (1988)) as:

\[(x)=(x)=_{p}(p x+H_ {}(p)),\] (8)

where

\[H_{}(p)=(p-p^{}+(1-p)-(1-p)^ {}),\;\; 1\\ -p p-(1-p)(1-p),\;\;=1.\] (9)

By varying \(\) during the training, we can control the sparsity in the network, i.e. regulate the softness of the pruning mechanism. In practice, we start from small values of \(=1\) and increase it according to a cosine scheduler, as shown in Fig. 3. Small values of \(\) allow meaningful gradient signals to pass through the dropping mechanism, which is crucial at the beginning of training. On the other hand, larger values of \(\) lead to sparse results desired during inference. We thus increase \(\) to values leading to very sparse solutions, as illustrated in Fig. 3. In practice, during inference, we replace \(()\) with the step function, that corresponds to \(\). We also initialize the biases parameters \(^{}\) in (6) to a positive value, ensuring that tokens at the beginning of training have a prior towards not being dropped. This strategy also facilitates fine-tuning existing pretrained models, as our modulewill initially default close to the identity function. The \(\)-sigmoid along with the training schedule on \(\) allows for good signal propagation properties for the gradients (Noci et al., 2022). We also explored using a regular sigmoid with a varying temperature (Kim et al., 2022), leading to suboptimal nonbinary predictions and instabilities during training. Training with our sparse sigmoid also directly eliminates the need to have any auxiliary network (Lee et al., 2023).

### Regularized Objective

We augment the regular language modeling objective with a regularization that incentivizes the network \(f\) to drop parts of the sequence. We fine-tune pretrained models, with parameters \(\), using the objective:

\[L(,)=L_{lm}(,)+L_{sparsity}(,),\] (10)

where

\[L_{lm}(,)=(f_{}(),( ))\] (11)

is the regular cross-entropy loss for the language modeling task based on the original and shifted input tokens \(\), and

\[L_{sparsity}(,)=_{i,}_{i,j}^{}\] (12)

is the sparsity loss, encouraging the model to prune the context. In total \((L\,n(n-1))/2\) entries of \(_{i,j}^{}\) are learned, as indicated in Eq. (6). We choose \(>0\) to enforce different levels of sparsity. In general, for a current position \(i\) in the context, we define as sparsity, the percentage of the previous tokens dropped, i.e. \(( i)/i\).

## 4 Experiments

We fine-tune pretrained GPT-2 models 1, that support a context size of up to 1024 tokens, on a subset of the English Wikipedia _20220301.en_ and English _bookcorpus_ datasets. We keep a separate test set where we report perplexity after training. All models shown, for a fair comparison, were fine-tuned using the same lightweight training setup as described in Appendix A. When using our adaptive sparse attention, we use a cosine scheduler for the \(\) parameter as displayed in Fig. 3 and specify \(r=64\) for the dimensions of \(_{Q_{}}^{},_{K_{}}^{}\). More ablations regarding optimization and variations of our dropping mechanism are provided in Appendix B. Unless otherwise stated, results refer to GPT-2-_small_ models. We use the term _dense_ for the regular GPT-2 models, fine-tuned without any additional \(_{Q_{}},_{K_{}}\) parameters.

Figure 3: (Left) We use a cosine scheduler to set the values of \(\) during training. (Middle) For values of \(>1\), mappings of the \(\)-sigmoid saturate at \( 1/(-1)\). During inference, we replace the \(\)-sigmoid with a step function, that corresponds to the case \(\). (Right) Distribution of \(_{k,j}^{}\) for different values of \(^{}\) with respect to the distance between the tokens \(k-j\). For this depiction, we assume random normally distributed vectors as inputs and randomly initialized weights \(_{_{}}^{},_{K_{}}^{}\), according to ‘He’ initialization (He et al., 2015).

Baselines.We compare against the baselines presented in Fig. 1. _Local Attention_ refers to a causal attention mask, where each token attends to the previous \(k\) tokens in the sequence, including itself. This can also be interpreted as restricting the receptive field of the model. _Sparse Attention_ refers to the baselines from Child et al. (2019); Lin et al. (2022), where each token \(i\) intends to the tokens satisfying (1) \( i/k= j/k\) and (2) the tokens \(k-1,2 k-1,, i/k k-1\) (numbering starts from zero). We fine-tune these baselines using the same aforementioned fine-tuning procedure, for different choices of \(k\), leading to different levels of sparsity, depending on the current context size.

Data structure.Real-world deployment of our approach exhibits numerous challenges due to the nature of batched generation. In particular, we highlight differences in prompt length (initial prefix), different final lengths (termination criteria), and uneven dropping of tokens across different sentences. Maximum performance is achieved when the key-value cache is represented as a contiguous block of memory, and any masking resulting from padding or removed tokens ("holes") will result in a decrease in efficiency. To this end, we devise an efficient batched data structure that allows for efficient insertion and deletion of tokens (leveraging the set nature of the self-attention operation), while _(i)_ allowing the underlying storage to be processed as a contiguous block of memory and _(ii)_ ensuring that the load factor of the data structure is high enough to guarantee a performance speed-up. More details are provided in the Appendix A.

### Results

Perplexity vs sparsity.We first study how context-pruning changes for different levels of sparsity in Fig. 4. Depending on the current context size, our method allows for up to 80% of the context to be successfully pruned, i.e. removed, with no performance loss in terms of perplexity (-0.085 average gain in perplexity when context size is 1000 tokens for 80.35% of sparsity compared to the dense counterpart). Our method also adapts to the current context size, meaning a network trained with specific sparsity regularization exhibits different levels of sparsity depending on the current context size. Compared to the baselines, our method exhibits consistently lower perplexity results for the same level of sparsity.

Zero-Shot Performance.To test general model capabilities and complement perplexity evaluations, we provide results on several zero-shot tasks (Dettmers et al., 2022) in Fig. 5. Similar trends hold overall; our approach retains or even outperforms the performance of the dense baseline, even for cases with high sparsity. These tasks involve scenarios where the model is required to perform without any specific training or prior exposure to the target domain. The results obtained validate that the models' general capabilities can be retained, even under high levels of sparsity.

Computational Analysis.We analyse the gains in terms of FLOPs and required memory when generating new sequences due to caching in Fig. 6. Our dropping mechanism introduces additional computational costs for the calculation of \(_{}^{},_{}^{}\) and the logic behind dropping via Eq. (6). Due to the relatively small chosen parameter \(r\), i.e. the output dimension of the interaction weights \(_{Q_{}}^{},_{K_{}}^{}\), these are nevertheless minimal. Although the raw FLOPs benefit when using sparse models does not seem very significant, as aforementioned, inference is predominately memory-bound. The attention thus takes a significant proportion of real-time inference (Dao et al., 2022). On the contrary, dense matrix multiplications used for all linear projections are very efficient. Memory

Figure 4: Perplexity (lower is better) for different levels of sparsity. (Left) Overall perplexity averaged across tokens with context size varying from \(1\) to \(1024\). The three plots on the right show perplexity for different context sizes.

benefits, on the other hand, are substantial, as the memory required for caching is a linear function with respect to sparsity, with a negative slope. Sparser solutions will thus additionally allow us to generate more sequences in a batched fashion. This is particularly relevant for bigger models, also longer sequences, where batch decoding is a major challenge (Shazeer, 2019).

Throughput.We demonstrate how reduced context and reduced memory requirements can lead to significant real-world time throughput in Fig. 7. Initially, our pruned networks are slower in terms of latency for small context lengths, because of the additional cost associated with the logic behind pruning. Nevertheless, they quickly surpass the dense baseline that struggles as the context size increases. This verifies the fact that although raw FLOPs benefits look unsubstantial, in fact, this leads to significant gains due to the specific memory profile of Transformers' inference. Crucially, our pruned networks can support a much bigger batch size, leading to significant throughput gains. More specifically, for long context sizes, our GPT-2-_small_ model offers an additional \(98\%\) margin in throughput for a loss in perplexity of only \(0.316\), with respect to the dense counterpart. Similarly, our GPT-2-_medium_ model can yield \(189\%\) additional throughput for only \(0.084\) loss in perplexity for a context size of 1000 tokens. In particular, the same model (for \(=1.0\)) provides a higher throughput than a GPT-2-_small_ model, while achieving \(3.769\) lower perplexity. As context windows become larger by the day in state-of-the-art models, we expect these gains to become even more relevant.

Figure 5: Mean zero-shot accuracy (higher is better) for the _WinoGrande_, _HellaSwag_, _PIQA_, and _LAMBADA_ datasets. As the sparsity of all methods depends on the context size, we average the expected sparsity based on the lengths of the prefixes in these datasets. (Left) GPT-2-_small_ models and (right) all GPT-2 models.

Figure 6: (Left) Distribution of FLOPs for models with different levels of sparsity. Here, _embedding-layer_ refers to the embedding of the input sequence to the representation \(^{0}\), _logits-layer_ to the projections of the final representation \(^{L}\) according to the vocabulary size, _feed-forward_ to the feed-forward components, summed across the different layers, _qko-calculation_ to the projection of the current representation to queries, keys, values and the final output projection, _attention_ to the actual softmax operation and _drop-tokens_ to additional compute required for calculating \(^{c}_{}\), \(^{c}_{}\) and performing dropping via Eq. (6). (Right) Memory requirements when caching previous activations (keys and values). When implementing dropping, interaction keys \(^{c}_{}\) have to be additionally cached.

Figure 8: (Top) Example of pruned tokens for layer 5 for the GPT-2-_small_ model fine-tuned with \(-0.3\) during generation. Most pruning is triggered by punctuation. (Bottom-left) We calculate the probability of tokens to be kept in the context based on the part of speech (POS) of the words they correspond to. (Bottom-middle) Most dropping is caused by tokens corresponding to punctuation, but distinct layers behave differently. (Bottom-right) Example of the number of tokens pruned by the tokens’ position id, for 2 layers of GPT-2-_small_.

Figure 7: We measure throughput using the optimal batch size on an NVIDIA RTX A5000 GPU. (Left) Throughput in terms of tokens per second for different models and different levels of sparsity (top) averaged across tokens for context sizes from 1 to 1024 and (bottom) when the context size is 1000 tokens. (Right) Average (top) throughput for varying context size for the GPT-2-_medium_ model and average (bottom) time per generation step for varying context size. As our models require significantly less memory, a larger batch size can be accommodated, where large portions of the throughput gains can be attributed to.

Interpretability.Fig. 8 provides insights into the interpretability aspect of the model's decision-making process. It is observed that token removal predominantly occurs when encountering stop words (punctuation), which aligns with the intuition that local information within a sentence becomes less relevant after its completion. Furthermore, it is worth noting that layers at varying depths exhibit distinct behaviours, reinforcing our rationale for dissecting token removal decisions across depth. The variance in sparsity distribution across different depths indicates the necessity of conducting additional interpretability research to obtain valuable insights in the interactions of the tokens within the model. We provide more insights towards this direction in the Appendix C.

## 5 Discussion

We proposed Adaptively Sparse Attention, a novel approach to dynamically prune the context in decoder-only Transformer architectures. Our results indicate that our technique performs favourably compared to competitive baselines in terms of the ratio between perplexity and sparsity of the attention weights. Remarkably our approach also significantly reduces the computational and memory requirements without affecting its final performance. We practically showcase these benefits achieving more than double the throughput at cases. Adaptively sparse attention comes with two additional practical advantages: first, it can be seamlessly integrated into existing pre-trained models via a cheap fine-tuning step; second, it represents an orthogonal contribution to the burgeoning research line aimed at increasing the level of efficiency of modern LLMs. As such, we envision its combination with existing techniques like weight pruning and quantization to be a promising avenue for future research.