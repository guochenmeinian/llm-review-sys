# Achieving Constant Regret in Linear Markov Decision Processes

Weitong Zhang

School of Data Science and Society

University of North Carolina at Chapel Hill

Chapel Hill, NC 27599

weitongz@unc.edu

&Zhiyuan Fan

EECS

Massachusetts Institute of Technology

Cambridge, MA 02139

fanzy@mit.edu

&Jiafan He

Department of Computer Science

University of California, Los Angeles

Los Angeles, CA 90095

jiafanhe19@ucla.edu

&Quanquan Gu

Department of Computer Science

University of California, Los Angeles

Los Angeles, CA 90095

qgu@cs.ucla.edu

equal contribution

###### Abstract

We study the constant regret guarantees in reinforcement learning (RL). Our objective is to design an algorithm that incurs only finite regret over infinite episodes with high probability. We introduce an algorithm, \(\), for misspecified linear Markov decision processes (MDPs) where both the transition kernel and the reward function can be approximated by some linear function up to misspecification level \(\). At the core of \(\) is an innovative certified estimator, which facilitates a fine-grained concentration analysis for multi-phase value-targeted regression, enabling us to establish an instance-dependent regret bound that is constant w.r.t. the number of episodes. Specifically, we demonstrate that for a linear MDP characterized by a minimal suboptimality gap \(\), \(\) has a cumulative regret of \(}(d^{3}H^{5}/)\) with high probability, provided that the misspecification level \(\) is below \(}(/(H^{2}))\). Here \(d\) is the dimension of the feature space and \(H\) is the horizon. Remarkably, this regret bound is independent of the number of episodes \(K\). To the best of our knowledge, \(\) is the first algorithm to achieve a constant, instance-dependent, high-probability regret bound in RL with linear function approximation without relying on prior distribution assumptions.

## 1 Introduction

Reinforcement learning (RL) has been a popular approach for teaching agents to make decisions based on feedback from the environment. RL has shown great success in a variety of applications, including robotics (Kober et al., 2013), gaming (Mnih et al., 2013), and autonomous driving. In most of these applications, there is a common expectation that RL agents will master tasks after making only a bounded number of mistakes, even over indefinite runs. However, theoretical support for this expectation is limited in RL literature: in the worst case, existing works such as Jin et al. (2020); Ayoub et al. (2020); Wang et al. (2019) only provided \(}()\) regret upper bounds with \(K\) being the number of episodes; in the instance-dependent case, Simchowitz and Jamieson (2019); Yang et al. (2021); He et al. (2021) achieved logarithmic high-probability regret upper bounds (e.g.,\(}(^{-1} K))\) for both tabular MDPs and MDPs with linear function approximations, provided a minimal suboptimality gap \(\). However, these findings suggest that an agent's regret increases with the number of episodes \(K\), contradicting to the expectation of finite mistakes in practice. To close this gap between theory and practice, there is a recent line of work proving constant regrets bound for RL and bandits, suggesting that an RL agent's regret may remain bounded even when it encounters an indefinite number of episodes. Papini et al. (2021); Zhang et al. (2021) have provided instance-dependent constant regret bound under certain coverage assumptions on the data distribution. However, verifying these data distribution assumptions can be difficult or even infeasible. On the other hand, it is known that high-probability constant regret bound can be achieved unconditionally in multi-armed bandits (Abbasi-Yadkori et al., 2011) and contextual linear bandits if and only if the misspecification is sufficiently small with respect to the minimal sub-optimality gap (Zhang et al., 2023). This raises a critical question:

_Is it possible to design a reinforcement learning algorithm that incurs only constant regret under minimal assumptions?_

To answer this question, we introduce a novel algorithm, which we refer to as \(LSVIUCB}\), for reinforcement learning with linear function approximation. To encompass a broader range of real-world scenarios characterized by large state-action spaces and the need for function approximation, we consider the _misspecified linear MDP_(Jin et al., 2020) setting, where both the transition kernel and reward function can be approximated by a linear function with approximation error \(\). We show that, with our innovative design of certified estimator and novel analysis, \(LSVIUCB}\) achieves constant regret without relying on any prior assumption on data distributions. Our key contributions are summarized as follows:

* We introduce a parameter-free algorithm, referred to as \(LSVIUCB}\), featuring a novel certified estimator for testing when the confidence set fails. This certified estimator enables \(LSVIUCB}\) to achieve a constant, instance-dependent, high probability regret bound of \(}(d^{3}H^{5}/)\) for tasks with a suboptimality gap \(\), under the condition that the misspecification level \(\) is bounded by \(<}/(H^{2})\). This bound is termed a _high probability constant regret bound_, indicating that it does not depend on the number of episodes \(K\). We note that this constant regret bound matches the logarithmic expected regret lower bound of \((^{-1} K)\), suggesting that our result is valid and optimal in terms of the dependence on the suboptimality gap \(\).
* When restricted to a well-specified linear MDP (i.e., \(=0\)), the constant high probability regret bound improves the previous logarithmic result \(}(d^{3}H^{5}^{-1} K)\) in He et al. (2021) by a \( K\) factor. Our results suggest that the total suboptimality incurred by \(LSVIUCB}\) remains constantly bounded, regardless of the number of episodes \(K\). In contrast to the previous constant regret bound achieved by Papini et al. (2021), our regret bound does not require any prior assumption on the feature mapping, such as the UniSOFT assumption made in Papini et al. (2021). To the best of our knowledge, \(LSVIUCB}\) is the first algorithm to achieve a _high probability constant regret bound_ for MDPs without prior assumptions on data distributions. We further show that this constant regret high-probability bound does not violate the logarithmic expected regret bound by letting \(=1/K\)2. 
**Notation.** Vectors are denoted by lower case boldface letters such as \(\), and matrices by upper case boldface letters such as \(\). We denote by \([k]\) the set \(\{1,2,,k\}\) for positive integers \(k\). We use \( x\) to denote the logarithm of \(x\) to base \(2\). For two non-negative sequence \(\{a_{n}\},\{b_{n}\},a_{n}(b_{n})\) means that there exists a positive constant \(C\) such that \(a_{n} Cb_{n}\); \(a_{n}}(b_{n})\) means there exists a positive constant \(k\) such that \(a_{n}(b_{n}^{k}b_{n})\); \(a_{n}(b_{n})\) means that there exists a positive constant \(C\) such that \(a_{n} Cb_{n}\); \(a_{n}(b_{n})\) means there exists a positive constant \(k\) such that \(a_{n}(b_{n}^{-k}b_{n})\); \(a_{n}(b_{n})\) means that \(_{n}b_{n}/a_{n}=0\). For a vector \(^{d}\) and a positive semi-definite matrix \(^{d d}\), we define \(\|\|_{}^{2}=^{}\). For any set \(\), we use \(||\) to denote its cardinality. We denote the identity matrix by \(\) and the empty set by \(\). The total variation distance of two distribution measures \(()\) and \(()\) is denoted by \(\|()-()\|_{}\).

## 2 Related Work

Instance-dependent regret bound in RL.Although most of the theoretical RL works focus on worst-case regret bounds, instance-dependent (a.k.a., problem-dependent, gap-dependent) regret bound is another important bound to understanding how the hardness of different instance can affect the sample complexity of the algorithm. For tabular MDPs, Jaksch et al. (2010) proved a \(}(D^{2}S^{2}A^{-1} K)\) instance-dependent regret bound for average-reward MDP where \(D\) is the diameter of the MDP and \(\) is the policy suboptimal gap. Simchowitz and Jamieson (2019) provided a lower bound for episodic MDP which suggests that the any algorithm will suffer from \((^{-1})\) regret bound. Yang et al. (2021) analyzed the optimistic \(Q\)-learning and proved a \((SAH^{6}^{-1} K)\) logarithmic instance-dependent regret bound. In the domain of linear function approximation, He et al. (2021) provided instance-dependent regret bounds for both linear MDPs (i.e., \(}(d^{3}H^{5}^{-1} K)\)) and linear mixture MDPs (i.e., \(}(d^{2}H^{5}^{-1} K)\)). Furthermore, Dann et al. (2021) provided an improved analysis for this instance-dependent result with a redefined suboptimal gap. Zhang et al. (2023) proved a similar logarithmic instance-dependent bound with He et al. (2021) in misspecified linear MDPs, showing the relationship between misspecification level and suboptimality bound. Despite all these bounds are logarithmic depended on the number of episode \(K\), many recent works are trying to remove this logarithmic dependence. Papini et al. (2021) showed that under the linear MDP assumption, when the distribution of contexts \((s,a)\) satisfies the 'diversity assumption' (Hao et al., 2020) called 'UniSOFT', then LSVI-UCB algorithm may achieve an expected constant regret w.r.t. \(K\). Zhang et al. (2021) showed a similar result on bilinear MDP (Yang and Wang, 2020), and extended this result to offline setting, indicating that the algorithm only need a finite offline dataset to learn the optimal policy. Table 1 summarizes the most relevant results mentioned above for the ease of comparison with our results.

RL with model misspecification.All of the aforementioned works consider the well-specified setting and ignore the approximation error in the MDP model. To better understand this misspecification issue, Du et al. (2019) showed that having a good representation is insufficient for efficient RL unless the approximation error (i.e., misspecification level) by the representation is small enough. In particular, Du et al. (2019) showed that an \(()\) misspecification will lead to \((2^{H})\) sample complexity for RL to identify the optimal policy, even with a generative model. On the other hand, a series of work (Jin et al., 2020; Zanette et al., 2020, 2020) provided \(}(+ K)\)-type regret bound for RL in various settings, where \(\) is the misspecification level3 and we ignore the dependence on the dimension of the feature mapping \(d\) and the planing horizon \(H\) for simplicity. These algorithms, however, require the knowledge of misspecification level \(\), thus are not _parameter-free_. Another concern for these algorithms is that some of the algorithms (Jin et al., 2020) would possibly suffer from a _trivial asymptotic regret_, i.e., \((k)>(k(d,H,(1/)))\), as suggested by Vial et al. (2022). This means the performance of the RL algorithm will possibly degenerate as the number of episodes \(k\) grows. To tackle these two issues, Vial et al. (2022) propose the \(\) algorithm which requires a parameter \(_{}\). When \(_{}=d/\), the proposed

   Algorithm & Misspecified MDP? & Result \\  LSVI-UCB (He et al., 2021) & \(\) & \(}(d^{3}H^{5}^{-1}(K))\) \\ LSVI-UCB (Papini et al., 2021) & \(\) & \(}(d^{3}H^{5}^{-1}(1/))\) \\ \(\) (ours, Theorem 5.1) & ✓ & \(}(d^{3}H^{5}^{-1})\) \\   

Table 1: Instance-dependent regret bounds for different algorithms under the linear MDP setting. Here \(d\) is the dimension of the linear function \((s,a)\), \(H\) is the horizon length, \(\) is the minimal suboptimality gap. All results in the table represent high probability regret bounds. The regret bound depends the number of episodes \(K\) in He et al. (2021) and the minimum positive eigenvalue \(\) of features mapping in Papini et al. (2021). **Misspecified MDP?** indicates if the algorithm can (✓) handle the misspecified linear MDP or not (\(\)).

algorithm is _parameter-free_ but will have a trivial _asymptotic regret bound_. When \(_{}=\), the algorithm will have a non-trivial _asymptotic regret bound_ but is not _parameter-free_ since it requires knowledge of the misspecification level. Another series of works (He et al., 2022; Lykouris et al., 2021; Wei et al., 2022) are working on the _corruption robust_ setting. In particular, Lykouris et al. (2021); Wei et al. (2022) are using the _model-selection_ technique to ensure the robustness of RL algorithms under adversarial MDPs.

## 3 Preliminaries

We consider episodic Markov Decision Processes, which are denoted by \((,,H,\{r_{h}\},\{_{h}\})\). Here, \(\) is the state space, \(\) is the finite action space, \(H\) is the length of each episode, \(r_{h}:\) is the reward function at stage \(h\) and \(_{h}(|s,a)\) is the transition probability function at stage \(h\). The policy \(=\{_{h}\}_{h=1}^{H}\) denotes a set of policy functions \(_{h}:\) for each stage \(h\). For given policy \(\), we define the state-action value function \(Q_{h}^{}(s,a)\) and the state value function \(V_{h}^{}(s)\) as

\[Q_{h}^{}(s,a)=r_{h}(s,a)+[_{h^{}=h+1}^{H}r_{h^{ }}s_{h^{}},_{h^{}}(s_{h^{}})\; \;s_{h}=s,a_{h}=a],V_{h}^{}(s)=Q_{h}^{}s,_{h}(s),\]

where \(s_{h^{}+1}_{h}(|s_{h^{}},a_{h^{}})\). The optimal state-action value function \(Q_{h}^{*}\) and the optimal state value function \(V_{h}^{*}\) are defined by \(Q_{h}^{*}(s,a)=_{}Q_{h}^{}(s,a),V_{h}^{*}(s)=_{}V_{h}^{}(s)\).

By definition, both the state-action value function \(Q_{h}^{}(s,a)\) and the state value function \(V_{h}^{}(s)\) are bounded by \([0,H]\) for any state \(s\), action \(a\) and stage \(h\). For any function \(V:\), we denote by \([_{h}V](s,a)=_{s^{}_{h}(|s,a)}V(s ^{})\) the expected value of \(V\) after transitioning from state \(s\) given action \(a\) at stage \(h\) and \([_{h}V](s,a)=r_{h}(s,a)+[_{h}V](s,a)\) where \(\) is referred to as the _Bellman operator_. For each stage \(h[H]\) and policy \(\), the Bellman equation, as well as the Bellman optimality equation, are presented as follows

\[Q_{h}^{}(s,a) =r_{h}(s,a)+[_{h}V_{h+1}^{}](s,a):=[_{h}V_{ h+1}^{}](s,a),\] \[Q_{h}^{}(s,a) =r_{h}(s,a)+[_{h}V_{h+1}^{*}](s,a):=[_{h}V_{h+ 1}^{*}](s,a).\]

We use regret to measure the performance of RL algorithms. It is defined as \((K)=_{k=1}^{K}V_{1}^{*}(s_{1}^{k})-V_{1}^{^{k}}(s_{ 1}^{k})\), where \(^{k}\) represents the agent's policy at episode \(k\). This definition quantifies the cumulative difference between the expected rewards that could have been obtained by following the optimal policy and those achieved under the agent's policy across the first \(K\) episodes, measuring the total loss in performance due to suboptimal decisions.

We consider linear function approximation in this work, where we adopt the _misspecified linear MDP_ assumption, which is firstly proposed in Jin et al. (2020).

**Assumption 3.1** (\(\)-Approximate Linear MDP, Jin et al. 2020).: For any \( 1\), we say a MDP \((,,H,\{r_{h}\},\{_{h}\})\) is a \(\)_-approximate linear MDP_ with a feature map \(:^{d}\), if for any \(h[H]\), there exist \(d\)_unknown_ (signed) measures \(_{h}=_{h}^{(1)},,_{h}^{(d)}\) over \(\) and an unknown vector \(_{h}^{d}\) such that for any \((s,a)\), we have

\[_{h}(|s,a)-(s,a),_{h}() \;_{},r_{h}(s,a)- (s,a),_{h}\,,\]

w.l.o.g. we assume \((s,a):\|(s,a)\| 1\) and \( h[H]:\|_{h}()\|,\|_{h}\| \).

The \(\)_-approximate linear MDP_ suggests that for any policy \(\), the state-action value function \(Q_{h}^{}\) can be approximated by a linear function of the given feature mapping \(\) up to some misspecification level, which is summarized in the following proposition.

**Proposition 3.2** (Lemma C.1, Jin et al. 2020).: For a \(\)_-approximate linear MDP_, for any policy \(\), there exist corresponding weights \(\{_{h}^{}\}_{h[H]}\) where \(_{h}^{}=_{h}+ V_{h+1}^{}(s^{}) _{h}(s^{})\) such that for any \((s,a,h)[H]\), \(Q_{h}^{}(s,a)-(s,a),_{h}^{}  2H\). We have \(\|_{h}^{}\|_{2} 2H\).

Next, we introduce the definition of the suboptimal gap as follows.

**Definition 3.3** (Minimal suboptimality gap).: For each \(s,a\) and step \(h[H]\), the suboptimality gap gap\({}_{h}(s,a)\) is defined by \(_{h}(s,a)=V_{h}^{*}(s)-Q_{h}^{*}(s,a)\) and the minimal suboptimality gap \(\) is defined by \(=_{h,s,a}_{h}(s,a):_{h}(s,a) 0}\).

Notably, a task with a larger \(\) means it is easier to distinguish the optimal action \(_{h}^{*}(s)\) from other actions \(a\), while a task with lower gap \(\) means it is more difficult to distinguish the optimal action.

## 4 Proposed Algorithms

### Main algorithm: \(\)

We begin by introducing our main algorithm \(\), which is a modification of the \(\)(Vial et al., 2022). As presented in Algorithm 1, for each episode \(k\), our algorithm maintains a series of index sets \(^{l}_{k,h}\) for each stage \(h[H]\) and phase \(l\). The algorithm design ensures that for any episode \(k\), the maximum number of phases \(l\) is bounded by \(L_{k}\{_{4}(k/d),0\}\). During the exploitation step, for each phase \(l\) associated with the index set \(^{l}_{k-1,h}\), the algorithm constructs the estimator vector \(^{k}_{h,l}\) by solving the following ridge regression problem in Line 6 and Line 7:

\[^{k}_{h,l}*{argmin}_{ ^{d}}\|\|_{2}^{2}+_{^{k-1}_{h,l}}( ^{}^{}_{h}-r_{h}^{}-^{k}_{h +1}(s^{}_{h+1}))^{2}.\]

After calculating the estimator vector \(^{k}_{h,l}\) in Line 8, the algorithm quantizes \(^{k}_{h,l}\) and \((^{k}_{h,l})^{-1}\) to the precision of \(_{l}\). Similar to \(\)(Vial et al., 2022), we note \(}^{k,-1}_{h,l}\) is the quantized version of inverse covariance matrix \((^{k}_{h,l})^{-1}\) rather than the inverse of quantized covariance matrix \((}^{k}_{h,l})^{-1}\). The main difference between our implementation and that in Vial et al. (2022) is that we use a layer-dependent quantification precision \(_{l}\) instead of the global quantification precision \(=2^{-4L}/d\), which enables our algorithm get rid of the dependence on \(( K)\) in the maximum number of phases \(L_{k}\).

After obtaining \(}^{k}_{h,l}\) and \(}^{k,-1}_{h,l}\), a subroutine, \(\), is called to calculate an optimistic value function \(^{k}_{h}(s^{}_{h})\) for all historical states \(s^{}_{h}\) in Line 10. Then the algorithm transits to stage \(h-1\) and iteratively computes \(}^{k}_{h,l}\) and \(}^{k,-1}_{h,l}\) for all phase \(l\) and stage \(h[H]\).

In the exploration step, the algorithm starts to do planning from the initial state \(s^{k}_{1}\). For each observed state \(s^{k}_{h}\), the same subroutine, \(\), will be called in Line 14 for the policy \(^{k}_{h}(s^{k}_{h})\), the corresponding phase \(l_{h}^{k}(s_{h}^{k})\), and a flag \(f_{h}^{k}(s_{h}^{k})\). If the flag \(f_{h}^{k}(s_{h}^{k})=1\), the algorithm adds the index \(k\) to the index set \(_{h,l_{h}^{k}(s_{h}^{k})}^{k}\) in Line 15. Otherwise, the algorithm skips the current index \(k\) and all index sets remain unchanged. Finally, the algorithm executes policy \(_{h}^{k}(s_{h}^{k})\), receives reward \(r_{h}^{k}\) and observes the next state \(s_{h+1}^{k}\) in Line 17.

```
1:input:\(s, l:}_{h,l}^{k}^{d}, }_{h,l}^{k-1}^{d d},L^{+}\)
2:output:\(}_{h}^{k}(s),_{h}^{k}(s),l_ {h}^{k}(s)^{+},f_{h}^{k}(s)\{0,1\}\)
3:\(_{h,1}^{k}(s)=,}_{h,0}^{k}(s)=0, _{h,0}^{k}(s)=H\)
4:for phase \(l=1,,L+1\)do
5: Set \(Q_{h,l}^{k}(s,a)=(s,a),}_{h,l}^{k} \)
6: Set \(_{h,l}^{k}(s)=*{argmax}_{a_{h,l}^{k}}Q_{h,l}^{k }(s,a),V_{h,l}^{k}(s)=Q_{h,l}^{k}s,_{h,l}^{k}(s)\)
7:if\(l>L\)then
8:return\(_{h}^{k}(s),_{h}^{k}(s),l_{h}^{k}(s),f_{h}^{k}(s) =_{h,l-1}^{k}(s),_{h,l-1}^{k}(s),l,1\)
9:elseif\(_{l}_{a_{h,l}^{k}(s)}\|(s,a)\|_{ }_{h,l}^{k-1}} 2^{-l}\)then
10:return\(_{h}^{k}(s),_{h}^{k}(s),l_{h}^{k}(s),f_{h}^{k}(s) =_{h,l-1}^{k}(s),*{argmax}_{a _{h,l}^{k}(s)}\|(s,a)\|_{}_{h,l}^{k- 1}},l,1\)
11:elseif\(V_{h,l}^{k}(s)-3 2^{-l},_{h,l-1}^{k}(s)}> V_{h,l}^{k}(s)+3 2^{-l},_{h,l-1}^{k}(s)}\)then
12:return\(_{h}^{k}(s),_{h}^{k}(s),l_{h}^{k}(s),f_{h}^{k}(s) =_{h,l-1}^{k}(s),_{h,l-1}^{k}(s),l,0\)
13:else
14:\(_{h,l}^{k}(s)=V_{h,l}^{k}(s)+3 2^{-l},_{h,l-1}^{k}(s)}\)
15:\(_{h,l}^{k}(s)=V_{h,l}^{k}(s)-3 2^{-l},_{h,l-1}^{k}(s)}\)
16:\(_{h,l+1}^{k}(s)=a_{h,l}^{k}(s):Q_{h,l}^{k}(s,a)  V_{h,l}^{k}(s)-4 2^{-l}}\)
17:endif
18:endfor ```

**Algorithm 2**\(}:s;\{}_{h,l}^{k}\}_{l},\{ }_{h,l}^{k,-1}\}_{l},L_{h }^{k}(s),_{h}^{k}(s),l_{h}^{k}(s),f_{h}^{k}(s)\)

### Subroutine: \(}\)

Next we introduce subroutine \(}\), improved from \(}\)(Vial et al., 2022) that computes the optimistic value function \(_{h}^{k}\). The algorithm is described as follows. Starting from phase \(l=1\), the algorithm first calculates the estimated state-action function \(Q_{h,l}^{k}(s,a)\) as a linear function over the quantified parameter \(}_{h,l}^{k}\) and feature mapping \((s,a)\), following Proposition 3.2. After calculating the estimated state-action value function \(Q_{h,l}^{k}(s)\), the algorithm computes the greedy policy \(_{h,l}^{k}(s)\) and its corresponding value function \(V_{h,l}^{k}(s)\).

Similar to \(}\)(Vial et al., 2022), our algorithm has several conditions starting from Line 7 to determine whether to stop at the current phase or to eliminate the actions and proceed to the next phase \(l+1\), which are listed in the following conditions.

* **Condition 1**: In Line 7, if the current phase \(l\) is greater than the maximum phase \(L\), we directly stop at that phase and take the greedy policy on previous phase \(_{h}^{k}(s)=_{h,l-1}^{k}(s)\).
* **Condition 2**: In Line 9, if there exists an action whose uncertainty \(\|(s,a)\|_{}_{h,l}^{k-1}}\) is greater than the threshold \(2^{-l}_{l}^{-1}\), our algorithm will perform exploration by selecting that action.
* **Condition 3**: In Line 11, we compare the value of the pessimistic value function \(_{h,l}^{k}(s)\) and the optimistic value function \(_{h,l}^{k}(s)\) which will be assigned in Line 14 and Line 15, if the pessimistic estimation will be greater than the optimistic estimation, we will stop at that phase and take the greedy policy on previous phase \(_{h}^{k}(s)=_{h,l-1}^{k}(s)\). Only in this case, the Algorithm 2 outputs flag \(f_{h}^{k}(s)=0\), which means this observation will not be used in Line 15 in Algorithm 1.
* **Condition 4**: In the default case in Line 16, the algorithm proceeds to the next phase after eliminating actions.

Notably, in **Condition 4**, since the expected estimation precision in the \(l\)-th phase is about \(}(2^{-l})\), our algorithm can eliminate the actions whose state-action value is significantly less than others, i.e., less than \(}(2^{-l})\), while retaining the remaining actions for the next phase.

Specially, our algorithm differs from that in Vial et al. (2022) in terms of **Condition 3** to certify the performance of the estimation. In particular, a well-behaved estimation should always guarantee that the optimistic estimation is greater than the pessimistic estimation. According to Line 14 and Line 15, this is equivalent to the confidence region for \(l\)-th phase has intersection of the previous confidence region \([^{k}_{h,l-1}(s),^{k}_{h,l-1}(s)]\). Otherwise, we hypothesis the estimation on \(l\)-th phase is corrupted by either misspecification or bad concentration event, thus will stop the algorithm. We will revisit the detail of this design later.

It's important to highlight that our algorithms provide unique approaches when compared with previous works. In particular, He et al. (2021) does not eliminate actions and combines estimations from all layers by considering the minimum estimated optimistic value function. This characteristic prevents their algorithm from achieving a uniform PAC guarantee in the presence of misspecification. For a more detailed comparison with He et al. (2021), please refer to Appendix B.1. Additionally, Lykouris et al. (2021); Wei et al. (2022) focus on a model-selection regime where a set of base learners are employed in the algorithms, whereas we adopt a multi-phase approach similar with SupLinUCB rather than conducting model selection over base learners.

## 5 Constant Regret Guarantee

**Theorem 5.1**.: Under Assumption 3.1, let \(_{l}=5(l+20+(ld))dH\) for some fixed \(0<<1/4\). With probability at least \(1-4\), if misspecification level \(\) is below \(}/(H^{2})\) where \(\) is the minimal suboptimality gap, then for all \(K^{+}\), the regret of Algorithm 1 is upper bounded by

\[(K)}d^{3}H^{5}^{-1}(1 /).\]

This regret bound is constant w.r.t. the episode \(K\).

Theorem 5.1 demonstrates a constant regret bound with respect to number of episodes \(K\). Compared with Papini et al. (2021), our regret bound does not require any prior assumption on the feature mapping \(\), such as the _UniSOFT_ assumption made in Papini et al. (2021). In addition, compared with the previous logarithmic regret bound He et al. (2021) in the well-specified setting, our constant regret bound removes the \( K\) factor, indicating the cumulative regret no longer grows w.r.t. the number of episode \(K\), with high probability.

**Remark 5.2**.: As discussed in Zhang et al. (2023) in the misspecified linear bandits, Our _high probability_ constant regret bound does not violate the lower bound proved in Papini et al. (2021), which says that certain diversity condition on the contexts is necessary to achieve an _expected_ constant regret bound. When extending this high probability constant regret bound to the expected regret bound, we have

\[[(K)]}d^{3}H^{5} ^{-1}(1/)(1-)+ K,\]

which depends on the number of episodes \(k\). To obtain a sub-linear expected regret, we can choose \(=1/K\), which yields a logarithmic expected regret \(}(d^{3}H^{5}^{-1} K)\) and does not violate the lower bound in Papini et al. (2021).

**Remark 5.3**.: Du et al. (2019) provide a lower bound showing the interplay between the misspecification level \(\) and suboptimality gap \(\) in a weaker setting, which we discuss in detail in Appendix B.2. Along with the result from Du et al. (2019), our results suggests that ignoring the dependence on \(H\), \(=}(/)\) plays an important seperation for if a misspeficied model can be efficiently learned. This result is also aligned with the positive result and negative result for linear bandits (Lattimore et al., 2020; Zhang et al., 2023).

## 6 Technical Challenges and Highlight of Proof Techniques

In this section, we highlight several major challenges in obtaining the constant regret under misspecified linear MDP assumption and how our method, especially the certified estimator, tackles these challenges.

### Challenge 1. Achieving layer-wise local estimation error.

In the analysis of the value function under misspecified linear MDPs, we follow the multi-phase estimation strategy (Vial et al., 2022) to eliminate suboptimal actions and improve the robustness of the next phase estimation. Similar approaches have been observed in Zhang et al. (2023b); Chu et al. (2011) within the framework of (misspecified) linear bandits. However, unlike linear bandits, when constructing the empirical value function \(_{h}\) for stage \(h\) in linear MDPs, Jin et al. (2020) requires a covering statement on value functions to ensure the convergence of the regression, which is written by: (see Lemma D.4 in Jin et al. (2020) for details)

\[_{}_{h}^{} _{h+1}^{k}(s^{})-[_{h+1}^{k}(s^{ })]_{_{h}^{-1}}}_{H} |)+(|_{h+1}^{k}|/)}+,\] (6.1)

where we employ notation \(}_{H}\) to obscure the dependence on \(H\) to simplify the presentation. We use the notation \(_{h+1}^{k}\) to denote as an \(\)-covering, (or quantification in Takemura et al. (2021); Vial et al. (2022)) for the value functions \(_{h+1}^{k}\). However, in the multi-phase algorithm, the empirical value function \(_{h+1}^{k}\) from the subsequent stage \(h+1\), which is formulated using all pairs of parameters \(_{h,}^{k},_{h,}^{k}}_{}\) in \(L\) phases. Consequently, the covering number \(|_{h+1}^{k}|\) is directly proportional to the number of phases \(L=( K)\).

Therefore, when analyzing any single phase \(l\), prior analysis cannot eliminate the \( K\) term from (6.1) to achieve a _local_ estimation error independent that is independent of the logarithmic number of global episodes \( K\). Furthermore, due to the algorithm design of previous methods (Vial et al., 2022), additional \( K\) terms may be introduced by global quantification (i.e., \(_{tol}=d/\)).

Our approach: \(\)-\(\).To tackle this challenge, we introduce the certified estimator into Algorithm 2 and use a 'local quantification' to ensure the quantification error of each phase \(l\) depend on the local phase \(}(l)\) instead of the global parameter \( K\). The certified estimator works as follows: Considering the concentration term we need to control for each phase \(l\):

\[_{_{h,l}^{k}}_{h}^{} _{h+1}^{k}(s^{})-[_{h+1}^{k}(s^{ })]_{(_{h,l}^{k})^{-1}},\] (6.2)

as discussed in **Challenge 1**, the function class \(}_{h+1}^{k}_{h+1}^{k}\) involves \(L=( K)\) parameters, leading to a \( K\) dependence in the results when using traditional routines. The idea of certified estimator is to get rid of this by not directly controlling \(|_{h+1}^{k}|\). Instead, certified estimator establishes a covering statement for the value function class \(_{h+1,l_{+}}^{k}_{h+1,l_{+}}^{k}\), where \(_{h+1,l_{+}}^{k}\) is the value function that only incorporates the first \(l_{+}\) phases of parameters \(_{h,}^{k},_{h,}^{k}}_{}\). Under this framework, the covering statement becomes:

**Lemma 6.1** (Lemma C.4, informal).: Let \(_{h+1,l_{+}}^{k}\) be the output of Algorithm 2 terminated at phase \(l_{+}^{+}\), then with probability is at least \(1-2\),

\[_{_{h,l}^{k}}_{h}^{} _{h+1,l_{+}}^{k}(s^{})-[_{h+1,l_{+}}^{k} (s^{})]_{(_{h,l}^{k})^{-1}}_{l,l_{+}}=5 l_{+}dH.\]

Lemma 6.1 suggests a concentration inequality at any phase \(l_{+}\), and the following lemma suggests that this procedure will only introduce an \(}(2^{-l_{+}})\) error, under some faithful extension of the \(_{h,l_{+}}^{k}(s)\):

**Lemma 6.2** (Lemma C.2, informal).: For any \(l_{+}^{+}\), \(|_{h}^{k}(s)-_{h,l_{+}}^{k}(s)| 6 2^{-l_{+}}\).

Therefore, if a large enough \(l_{+}\) can be reached in Algorithm 2, combining Lemma 6.1 and Lemma 6.2 allow us to bound (6.2) without introducing \( K\) factors. The next lemma shows that the Line 11 will only never be triggered in shallow layer \(l\).

**Lemma 6.3** (Lemma C.8, informal).: With probability at least \(1-2\), for any \((k,h)[K][H]\), Line 11 in Algorithm 2 can only be triggered on phase \(l(1/)\).

Lemma 6.3 delivers a clear message: In the well-specified setting, Line 11 will never be triggered (\(l\)). When the misspecification level is large, then Line 11 will be more likely triggered, indicating it's harder for the algorithm to proceed to deeper layer. The contribution of the certified estimator yields the following important lemma regarding the 'local estimation error':

**Lemma 6.4** (Lemma C.12, Informal).: With high probability, for any \(>(H^{2})\) and \(h[H]\), \(\) ensures \(_{k=1}^{}[V_{h}^{*}(s_{h}^{k})-V_{h}^{*} (s_{h}^{k})]}d^{3}H^{4} ^{-2}\).

**Remark 6.5**.: He et al. (2021) achieved a similar \(d^{3}H^{5}^{-2}\)_uniform-PAC_ bound for (well-specified) linear MDP. Comparing with Lemma 6.4 with \(=0\), one can find that our result is better than He et al. (2021). In addition, Lemma 6.4 ensures this _uniform-PAC_ result under all stage \(h[H]\) while He et al. (2021) only ensure the \(h=1\). This improvement is achieved by a more efficient data selection strategy which we will discuss in detail in Appendix B.1.

### Challenge 2. Achieving constant regret from local estimation error

In misspecified linear bandits, Zhang et al. (2023) concludes their proof by controlling \(_{k=1}^{}[V_{1}^{*}(s_{1}^{k})-V_{1}^{}(s_{1}^{k}) ]\)4. Although it is trivial showing that rounds with instantaneous regret \(V_{1}^{*}(s_{1}^{k})-V_{1}^{}(s_{1}^{k})<\) is optimal in bandits (i.e., \(V_{1}^{*}(s_{1}^{k})=V_{1}^{}(s_{1}^{k})\)), previous works fail to reach a similar result for RL settings. This difficulty arises from the randomness inherent in MDPs: Consider a policy \(\) that is optimal at the initial stage \(h=1\). After the initial state and action, the MDP may transition to a state \(s_{2}^{}\) with a small probability \(p\) where the policy \(\) is no longer optimal, or to another state \(s_{2}\) where \(\) remains optimal until the end. In this context, the gap between \(V_{1}^{*}(s_{1})\) and \(V_{1}^{}(s_{1})\) can be arbitrarily small, given a sufficiently small \(p>0\):

Therefore, one cannot easily draw a constant regret conclusion simply by controlling \(_{k=1}^{}[V_{1}^{*}(s_{1}^{k})-V_{1}^{}(s_{1}^{k})]\) since the gap between \(V_{1}^{*}(s_{1}^{k})-V_{1}^{}(s_{1}^{k})\) needs to be further fine-grained controlled. In short, the existence of \(\) describing the minimal gap between \(V^{*}(s)-Q^{*}(s,a)\) cannot be easily applied to controlling regret \(V^{*}(s)-V^{}(s)\).

Our approach: A fine-grained concentration analysisWe address this challenge by providing a fine-grained concentration analysis in connecting the gap with the regret. Notice that the regret \(V_{h}^{*}(s_{h})-V_{h}^{^{k}}(s_{h})\) in episode \(k\) is the expectation of cumulative suboptimality gap \([_{h=1}^{H}_{h}^{k}]\) taking over trajectory \(\{s_{h}^{k}\}_{h=1}^{H}\). In addition, the variance of the random variable can be self-bounded according to

\[[_{h=1}^{H}_{h}^{k}][ (_{h=1}^{H}_{h}^{k})^{2}] H^{2}\, [_{h=1}^{H}_{h}^{k}]=H^{2}V_{1}^{*}(s_{1}^{k})-V_ {1}^{^{k}}(s_{1}^{k}).\]

Denote \(_{k}\) be the difference between \(V_{h}^{*}(s_{h})-V_{h}^{^{k}}(s_{h})\) and the actual \(_{h=1}^{H}_{h}^{k}\). Freedman inequality (Lemma H.5) implies that \(_{t=1}^{T}^{t} aC\) and \(_{t=1}^{T}[^{t}] vC\) happens at the same with a small probability for certain constant \(a\) and \(v\). Using a fine-grained union bound statement over \(C\), we can reach the following statement indicates the cumulative regret can be upper bounded using the cumulative suboptimality gap:

**Lemma 6.6** (Lemma C.14, Informal).: The following statement holds with high probability:

\[_{k=1}^{K}V_{h}^{*}(s_{h})-V_{h}^{^{k}}(s_{h}) }_{k=1}^{K}_{h=1}^{H}_{h}^{k}+H^{2 }.\]

Comparing with Lemma 6.1 in He et al. (2021), Lemma 6.6 eliminates the \( K\) dependence, which is achieved by the aforementioned fine-grained union bound. As a result, together with Lemma 6.4, we reach the desired statement that \(\) achieves constant regret bound when the misspecification is sufficiently small against the minimal suboptimality gap.

## 7 Conclusions and Limitations

In this work, we proposed a new algorithm, called certified estimator, for reinforcement learning with a misspecified linear function approximation. Our algorithm is parameter-free and does not require prior knowledge of misspecification level \(\) or the suboptimality \(\). Our algorithm is based on a novel certified estimator and provides the first constant regret guarantee for misspecified linear MDPs and (well-specified) linear MDPs.

Limitations.Despite these advancements, several aspects of our algorithm and analysis warrant further investigation. One significant open question is whether the dependency on the planning horizon and dimension \(d,H\) can achieve optimal instance-dependent regret bounds. For the gap-independent regret bounds, the regret lower bound is \((dK})\) as shown by Zhou et al. (2021), and this benchmark has recently been met by works such as He et al. (2022); Agarwal et al. (2022). Additionally, our analysis assumes uniform misspecification across all actions. Investigating other types of misspecifications could lead to more sophisticated results, enhancing the algorithm's robustness and applicability to diverse real-world scenarios. This exploration remains an important direction for future research.