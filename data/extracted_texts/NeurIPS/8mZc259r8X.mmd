# Learning Cut Generating Functions for Integer Programming

Hongyu Cheng

Dept. of Applied Mathematics & Statistics

Johns Hopkins University

Baltimore, MD 21218

hongyucheng@jhu.edu

&Amitabh Basu

Dept. of Applied Mathematics & Statistics

Johns Hopkins University

Baltimore, MD 21218

basu.amitabh@jhu.edu

###### Abstract

The branch-and-cut algorithm is the method of choice to solve large scale integer programming problems in practice. A key ingredient of branch-and-cut is the use of _cutting planes_ which are derived constraints that reduce the search space for an optimal solution. Selecting effective cutting planes to produce small branch-and-cut trees is a critical challenge in the branch-and-cut algorithm. Recent advances have employed a data-driven approach to select good cutting planes from a parameterized family, aimed at reducing the branch-and-bound tree size (in expectation) for a given distribution of integer programming instances. We extend this idea to the selection of the best cut generating function (CGF), which is a tool in the integer programming literature for generating a wide variety of cutting planes that generalize the well-known Gomory Mixed-Integer (GMI) cutting planes. We provide rigorous sample complexity bounds for the selection of an effective CGF from certain parameterized families that provably performs well for any specified distribution on the problem instances. Our empirical results show that the selected CGF can outperform the GMI cuts for certain distributions. Additionally, we explore the sample complexity of using neural networks for instance-dependent CGF selection.

## 1 Introduction

Integer linear programming is an optimization framework that has diverse applications in logistics (Armtzen et al., 1995; Sinha et al., 1995; Hane et al., 1995), finance (Bertsimas et al., 1999), engineering (Grossmann and Kravanja, 1995), national defense (Gyffenberg et al., 1997; Jiang et al., 2014), healthcare (Ajayi et al., 2024; Valeva et al., 2023), statistics (Bertsimas et al., 2016; Dash et al., 2018; Wei et al., 2019) and machine learning (Bertsimas and Dunn, 2017; Chen et al., 2021; Malioutov et al., 2023), to give a small sample of applications and related literature. The method of choice for solving integer programming problems is the well-known _branch-and-cut_ paradigm (Schrijver, 1986; Nemhauser and Wolsey, 1988; Conforti et al., 2014). This procedure has two critical ingredients: _branching_, which is a way to subdivide the problem into smaller subproblems, and the use of _cutting planes_ which is a way to reduce the feasible region of a (sub)problem by deriving additional linear constraints that are implicitly implied by the integrality of the decision variables. To get to a concrete algorithm from this high level framework, one needs to make certain choices (such as how to branch, which cutting plane to use etc.) Thus, at a high level, the branch-and-cut method is really a collection of algorithms equipped with a common set of "tunable parameters". Upon a specific choice of values for these parameters, one actually obtains a well-defined algorithm that one can deploy on instances of the problem.

There is a substantial amount of literature on the mathematical foundations of cutting planes and branching, and many of their theoretical properties are well understood. Nevertheless, current theory does not give very precise recipes for making these parameter choices in branch-and-cut for getting the best performance on particular instances. There are some general insights available from theory, but a large part of the actual deployment of these algorithms in practice is heuristic in nature. This state of affairs has prompted several groups of researchers to explore the possibility of using machine learning tools to make these parameter choices in branch-and-cut; see (Scavuzzo et al., 2024) for a survey and the references therein.

In this paper we focus on some foundational aspects of the use of machine learning to improve algorithmic performance of branch-and-cut. One can formalize the problem as follows. Given a family of instances of integer programming problems, one wishes to select the parameters of branch-and-cut that will perform well on average, and one wishes to do this in a data-driven manner. More formally, one assumes there is a probability distribution over the family of instances and the goal is to find the choice of parameters that gives the best performance in expectation with respect to this distribution. The probability distribution is not explicitly known, but one can sample instances from the distribution and use these samples to guide the choice of parameters. This puts the problem in a classical learning theory framework and one can ask questions like the sample size required to guarantee success with high accuracy and high probability (over the samples). This perspective was pioneered in a recent series of papers (Balcan et al., 2021a,c,b, 2022, 2018) with several important insights and technical contributions. The broader question of selecting a good algorithm from a suite of algorithms for a computational problem, given access to samples from a distribution over the instances of the problem, is generally called _data-driven algorithm design_ and has received attention recently; see (Balcan, 2020, Balcan et al., 2021a) and the references therein. There is also a lot of recent activity in the related aspect of _algorithm design with predictions_; see, e.g., (Mitzenmacher and Vassilvitskii, 2022).

This paper contributes to this line of research that analyzes the sample complexity of using machine learning tools for parameter selection in branch-and-cut. In particular, we focus on the _cut selection problem_, which is also a central theme in the papers (Balcan et al., 2021c,b, 2022). Thus, we wish to learn what choice of cutting planes within the branch-and-cut procedure gives the best performance. Our results differ from this previous work in two main ways.

1. In (Balcan et al., 2021c,b, 2022), the authors focus on the classical cutting plane families of Chvatal-Gomory (CG) and Gomory Mixed-Integer (GMI) cutting planes. These are actually two very special cases of a much more general framework for deriving cutting planes for integer programming problems, which is called _cut generating function theory_. The idea behind cut generating functions goes back to seminal work by (Balas, 1971) and (Gomory and Johnson, 1972a,b) from the 1970s, and there has been a tremendous amount of progress in our understanding of this theory in the past 15 years. The main point is that cut generating functions give a parameterized family of cutting planes to choose from, which vastly generalizes the CG and GMI cuts. We provide sample complexity results for cut selection from this larger family. This requires new understanding of the structure of these cutting planes and their interplay with learning theory tools. While we do rely on some of the ideas from (Balcan et al., 2021c,b, 2022), several new technical and algorithmic challenges need to be overcome. The full potential of cut generating functions has not been realized despite sustained efforts in the past decade; see (Poirrier, 2014, Chapter 6) for a nuanced discussion. We believe an important factor behind this is that the cut selection problem for this much larger class is very hard. Thus, while they promise significant gains over traditional ideas like GMI cuts, it has been difficult to utilize them in practice. Using modern machine learning tools to help with the cut selection could be the key to deploying these powerful tools in practice. Thus, we believe our results to be significant in that they are the first of their kind in terms of establishing a rigorous foundation for using machine learning to solve the cut selection problem for cut generating functions.
2. All of the work in (Balcan et al., 2021a,c,b, 2022, 2018) focuses on making a _single_ choice of parameters that does well in expectation. However, it can be significantly more beneficial to allow the choice of parameters to _depend on the instance_(Rice, 1976; Gupta and Roughgarden, 2016). In recent work, the use of neural networks was suggested as a way to map instances to the choice of parameters in data-driven algorithm design (Cheng et al.,2024], and sample complexity bounds were derived for learning such a neural network. The authors in [Cheng et al., 2024] worked with CG and GMI cuts. Here we extend that analysis to learn neural mappings to more general cut generating functions.

Cut generating functions derive cutting planes by using the data from an optimal simplex tableaux for the linear programming relaxation of the integer programming problem. CG and GMI cutting planes are a special case of such cutting planes where data from a _single_ tableaux row is used. Our first result (Theorem 3.2) establishes sample complexity bounds for a parameterized family of cut generating functions that uses information from single rows of the simplex tableaux, but goes beyond CG and GMI cuts. Cut generating function theory also allows the use of information from _multiple rows_ of the tableaux, which will naturally result in stronger cutting planes because more information from the problem is used to derive these cuts. Our second result (Theorem 4.4) gives sample complexity results for a parameterized family of cut generating functions that uses information from \(k\) rows, for any fixed natural number \(k 2\). In Section 5, these sample complexity results are extended to learning neural networks that map instances to cut generating functions, achieving an instance dependent performance.

The choice of the cut generating function families that we study in this paper were dictated by three things: 1) we should be able to derive cutting planes from them in a computationally efficient way, 2) we should be able to derive concrete sample complexity bounds, and 3) we should be able to demonstrate that these new cutting planes are better in practice than classical cuts. Sections 3, 4 and 5 achieve aims 1) and 2). Section 6 gives evidence for 3) by showing that our choice of cut generating functions can indeed improve performance of branch-and-cut, especially with the use of instance dependent cutting planes. Our performance criteria is the overall tree size (number of nodes explored by the solver) for solving the problem. For those familiar with cut generating function theory, we mention that our cut generating functions are all _extreme functions_. This provides some additional theoretical underpinning to the claim that these cutting planes are of good quality.

We begin our formal presentation in Section 2 where we introduce the required concepts, terminology and notation from integer programming and learning theory that are needed to state and prove our results formally, which is done in Sections 3, 4 and 5.

## 2 Formal setup of the problem

Throughout the paper, we will use the following standard notations. The sign function \(:\{0,1\}\) is defined by \((x)=1\) if \(x 0\) and \((x)=0\) if \(x<0\). The set \(_{d}^{}=\{^{d}:_{1},, _{d},_{i=1}^{d}_{i}=1\}\) represents a \(d\)-dimensional simplex, where \( 2d\) is some predefined number. For a set of vectors \(\{^{1},,^{t}\}^{d}\), we use superscripts to denote vector indices and subscripts to specify the coordinates in a vector; thus, \(_{j}^{i}\) refers to the \(j\)-th coordinate of vector \(^{i}\). The floor and ceiling functions, denoted by \(\) and \(\) respectively, round each component of a vector down or up to the nearest integer. We denote \([]=-\) for any \(^{d}\), representing the fractional part of each component of the vector.

### Integer linear programming background

Given positive integers \(m,n\), a pure integer linear programming (ILP) problem in canonical form can be described as:

\[ ^{}\] (1) s.t. \[A,, ^{n},\]

for some \(A^{m n},^{m}\), and \(^{n}\). This problem is represented by the tuple \((A,,)\). In this paper, we consider the set of ILP instances \(\) such that for any \(I=(A,,)\), there exists a universal constant \(\) such that \(\{\|\|_{}:A, \}\).

A _cutting plane_ for (1) is given by \((,)^{n}\) such that the inequality \(^{}\) is satisfied by all points in the feasible region \(\{^{n}:A,\}\) of (1).

Cut generating functions.We now present the technique of cut generating functions to derive cutting planes for (1). Consider the equivalent standard form of (1) after introducing _slack variables_:

\[=,\ _{+}^{m+n},\] (2)

where \(=[A,I]^{m(n+m)}\). The simplex tableaux of the above problem with respect to a basis \(B\{1,,m+n\}\) with \(|B|=m\) is given by

\[^{B}+_{B}^{-1}_{N}^{N}= _{B}^{-1},\ _{+}^{m+n},\] (3)

where \(_{B}\) and \(_{N}\) represent the submatrices of \(\) corresponding to the columns indexed by \(B\) and \(N=\{1,,m+n\} B\), respectively. We select any \(k\) rows, where \(k\{1,...,m\}\), from (3) such that the right-hand side vector is not integral, and write the resulting system as:

\[+_{i=1}^{n}^{i}_{i}^{N}=,\ ^{N}_{+}^{n},_{+}^{k},\] (4)

where \(^{1},,^{n}^{k}\) and \(^{k}^{k}\) are subvectors of \(_{B}^{-1}_{N}\) and \(_{B}^{-1}\), respectively, corresponding to the selected rows. Suppose we have a function \(:^{k}_{+}\) satisfying the following conditions:

1. \(()=0\), \(()=1\),
2. subadditivity: \((+^{})()+(^{ }),,^{}^{k}\),
3. periodicity: \((+)=(),^{k}, ^{k}\),

then for any feasible \(^{N}\) and \(\) we have the following inequality:

\[1=()=(+_{i=1}^{n}^{i}_ {i}^{N})=(_{i=1}^{n}^{i}_{i}^{N}) _{i=1}^{n}(^{i}_{i}^{N})_{i= 1}^{n}(^{i})_{i}^{N}.\] (5)

It's noteworthy that the optimal solution to the relaxed linear programming problem, \([^{B},^{N}]=[_{B}^{-1} ,]\), will always violate this inequality. By substituting out the slack variables using (2), the inequality \(_{i=1}^{n}(^{i})_{i}^{N} 1\) becomes a cutting plane \(^{}\) for (1); see Lemma A.3.

We present two classical examples of one-dimensional (i.e., \(k=1\)) cut generating functions here (as well as their plots in Figure 0(a) and Figure 0(b)). A family of one-dimensional cut generating functions we will use in this paper will be presented in Section 3, and a family of \(k\)-dimensional cut generating functions, for arbitrary \(k 1\), will be presented in Section 4.

Gomory fractional cut [Gomory, 1958]:Define \(_{f}(r)=\). Applying this function to the \(j\)-th row of the simplex tableau (4) with \(_{j}\), the valid cut (5) translates to the Gomory fractional cut:

\[_{i=1}^{n}_{j}^{i}]}{[_{j}]}_{i}^{N}  1_{i=1}^{n}_{j}^{i}-[_{j}^{i}]}{ _{j}-[_{j}]}_{i}^{N} 1_{i=1}^{n}( _{j}^{i}-[_{j}^{i}])_{i}^{N}_ {j}-[_{j}].\]

This cut generating function gives cutting planes that are equivalent to the well-known Chvatal-Gomory (CG) cuts; see [10, Section 5.2.4] for a discussion.

Gomory's mixed-integer cut [Gomory, 1960]:The GMI cut function \(_{f}(r)\) is defined as \(\) when \([r][f]\), and \(\) when \([r]>[f]\). Applying to the \(j\)-th row with \(_{j}\), the valid cut (5) translates to the GMI cut:

\[_{i:[_{j}^{i}][_{j}]}_{j}^{i}]}{[ _{j}]}_{i}^{N}+_{i:[_{j}^{i}]>[_{j }]}_{j}^{i}]}{1-[_{j}]}_{i}^{N} 1_{i:[_{j}^{i}][_{j}]}[ _{j}^{i}]_{i}^{N}+_{j}]}{1-[_{j }]}_{i:[_{j}^{i}]>[_{j}]}(1-[_{j}^{i}] )_{i}^{N}[_{j}].\]

### Sample complexity of selecting cut generating functions

We will consider parameterized families of cut generating functions and the sample complexity of learning which cut generating functions work well. More precisely, we will track how well branch-and-cut performs when the cutting plane corresponding to a specific cut generating function is added to the initial linear programming relaxation of the problem, a.k.a the _root node of the branch-and-cut tree_. In this paper, we consider the branch-and-cut tree built with a product scoring policy for variable selection, a depth-first search policy for node selection, and only one cutting plane added at the root node. We will use the overall tree size needed to solve the problem as the quantitative measure of performance, which is strongly correlated with the overall solve time.

Consider an unknown probability distribution \(\) over the instance space \(\). We are presented with problems drawn independently and identically distributed (i.i.d.) from this distribution. We also have a family of cut generating functions parameterized by \(\). Let \(c(I,)\) denote the cutting plane obtained by applying the cut generating function corresponding to \(\) to the instance \(I\) as explained in the previous section. \(h(I,)[0,B]\) will denote the truncated branch-and-cut tree size for some \(B>0\), when the cutting plane \(c(I,)\) is used at the root node for processing \(I\).

The objective is to find the cut generating function that minimizes the expected tree size over the distribution \(\), i.e., we want to solve the stochastic optimization problem \(_{}_{I}h(I, )\). For any \(>0\) and \((0,1)\), the _sample complexity_ of the problem is a natural number \(N=N(,)\) such that if the number of sampled instances exceeds \(N\), the expected tree size for the distribution \(\) and the average tree size for the sampled instances differ by less than \(\) for every \(\), with probability (over the samples) at least \(1-\). Thus, if we have that many samples, we can use the cut generating function that minimizes the average tree size on our instances (this is a deterministic optimization problem since the sample is at hand, a.k.a the _empirical risk minimization (ERM)_ or _sample average approximation (SAA)_ problem) and we will do well in expectation, i.e., generalize to unseen instances, with high probability.

The pseudo-dimension \(()\) is a measure of the 'complexity' of the associated function class \(:=\{h(,):\}\), and is a key concept closely related to sample complexity. It is defined as the largest integer \(t\) for which there exists a set of instances and real values \((I_{1},s_{1}),,(I_{t},s_{t})\) such that

\[2^{t}=|\{((h(I_{1},)-s_{1}),,(h( I_{t},)-s_{t})):\}|\,.\]

A classical result in statistical learning theory (e.g., Theorem 19.2 in (Anthony et al., 1999)) implies the sample complexity bound

\[N(,)=(}{^{2}}( ()()+( ))).\]

Thus, our task reduces to finding an upper bound for \(()\).

In learning theory, identifying the piecewise structure of the function class \(=\{h(,):\}\) is a standard technique for bounding its pseudo-dimension (see (Anthony et al., 1999; Bartlett et al., 1998, 2019, 2019, 2021a, 2021b)). For a fixed instance \(I\), one shows that

Figure 1: Three cut generating functions on \([0,1)\), where \(_{f,s_{1},s_{2}}^{p,q}\) is defined in Section 3.

the parameter space \(\) can be partitioned into regions such that the function \(h(I,)\) behaves as a fixed'simple function' within each region. The partition is defined by a set of functions on \(\) and the regions of the partition correspond to parameter values in \(\) where these functions have invariant signs.

Given that our tree size function is an integer-valued function, we present a particular such result below in Lemma 2.1, which motivates the piecewise structure results presented later in Proposition 3.1 and Proposition 4.3. These results will be used in the proofs of Theorem 3.2 and Theorem 4.4 to bound the pseudo-dimension. The proof of Lemma 2.1 is provided in Appendix A. Note that a more general version of this result is given in (Balcan et al., 2021a), but our specific version is asymptotically better than a direct application of the general result, since Sauer's lemma ((Sauer, 1972; Shelah, 1972)) is not involved in the proof.

**Lemma 2.1**.: Let \(h:\), where \(^{d}\) for a natural number \(d\). Suppose that for any fixed \(I\), there exist at most \(\) functions, each expressible as the quotient of a polynomial of degree at most \(a\) and a strictly positive function. These functions partition \(\) into regions in which \(h(I,)\) remains constant. Then, the pseudo-dimension of the function class \(\{h(,):\}\) is given by:

\[(\{h(,):\})= (d( a)).\]

**Remark 2.2**.: In Theorems 3.2 and 4.4 that bound the pseudo-dimensions, we assume that the row(s) used for generating the cut are prefixed for all instances \(I\). However, it is straightforward to extend the analysis to give bounds on the pseudo-dimension when the choice of rows is also learned along with the cut generating function. We leave these details out of this conference version of the paper.

## 3 One-dimensional cut generating functions

In this section, we present a family of one-dimensional cut generating functions (originally proposed in (Gomory and Johnson, 2003)) that we believe satisfy the three criteria laid out in the Introduction, i.e., cutting planes can be obtained efficiently from them (we present closed form formulas below), sample complexity (pseudo-dimension) bounds can be established rigorously (Theorem 3.2 below), and they result in significantly smaller tree sizes compared to traditional cutting planes (Section 6).

### The construction

For any \(f(0,1),p,q[2,+]\), \(s_{1},s_{2}\), let

\[^{p,q}_{f,s_{1},s_{2}}(r)=\{\{\{_{i}^{1}(r), _{i}^{2}(r)\}:i=1,,p\}\{\{_{j}^{1 }(r),_{j}^{2}(r)\}:j=1,,q-1\}\},\]

where

\[_{i}^{1}(r) =s_{1}r+i}{p},_{i}^{2}(r)=s_{2}r+(i-1) }{p-1},i=1,,p,\] \[_{j}^{1}(r) =s_{1}(r-1)+(j-1)}{q-1},_{j}^{2}(r)=s_ {2}(r-1)+j}{q},j=1,,q-1.\]See Figures 1(c) and 2 for examples with different \(f,p,q\) and \(s_{1},s_{2}\). Let \(_{f}^{p,q}\) denote the set of all \((s_{1},s_{2})\) such that \(_{f,s_{1},s_{2}}^{p,q}()\) is a valid cut generating function, i.e., it satisfies the three conditions outlined in Section 2.1. The closed form of this set is provided in Lemma B.1, which indicates that \(_{f}^{p,q}\) is always a (possibly semi-infinite) rectangle.

### Pseudo-dimension bound

We first show that the cutting plane coefficients for (2) derived from this family of cut generating functions has a piecewise affine linear structure. This is key to establishing the pseudo-dimension bounds in Theorem 3.2 using Lemma 2.1.

**Proposition 3.1**.: For any fixed \(f(0,1),p,q[2,+]\), and \(r_{1},,r_{n}[0,1)\), there exists a decomposition of the \((s_{1},s_{2})\) space \(_{f}^{p,q}\) given by at most \(n\) hyperplanes such that, within each region, each coordinate of the cutting plane \([_{f,s_{1},s_{2}}^{p,q}(r_{1}),,_{f,s_{1},s_{2}}^{p,q}(r_{n} )]^{}\) is a fixed affine linear function of \((s_{1},s_{2})\).

To make the parameter selection in more controlled manner, we introduce a large positive constant \(M\) and adjust the bounds of \(s_{1}\) and \(s_{2}\) given in Lemma B.1 to finite ranges by replacing \(-\) and \(+\) with \(-M\) and \(+M\), respectively, in the corresponding cases. This restricts \((s_{1},s_{2})\) to the product of \(2\) bounded intervals, denoted as \([l_{1},u_{1}][l_{2},u_{2}]\), which is a bounded subset of \(_{f}^{p,q}\). This allows us to use parameters \(=(_{1},_{2})^{2}\) to control \(s_{1}\) and \(s_{2}\) as follows:

\[s_{1}=u_{1}-_{1}(u_{1}-l_{1}),\;s_{2}=l_{2}+ _{2}(u_{2}-l_{2}).\] (6)

We remark that setting \(_{1}=_{2}=0\) gives the \(_{f}\) function.

We now have all the pieces to state the precise pseudo-dimension bound.

**Theorem 3.2**.: Let \(p,q 2\) be arbitrary, but fixed, natural numbers. Let \(T(I,)\) denote the tree size of the branch-and-cut algorithm after adding the cut induced by the cut generating function \(_{f,s_{1},s_{2}}^{p,q}()\) at the root for a given instance \(I\), where \(s_{1},s_{2}\) are given by the mappings (6) based on \(_{1},_{2}\), and \(f\) is determined by \(I\). Then, the pseudo-dimension is given by

\[(\{T(,):[0,B ]\;|\;^{2}\})=(n^{2} ((m+n))).\]

## 4 \(k\)-dimensional cut generating functions

In this section, we present a family of \(k\)-dimensional cut generating functions, for arbitrary \(k 2\), that we believe satisfy the three criteria laid out in the Introduction, i.e., cutting planes can be obtained efficiently from them (Theorem 4.2 below), sample complexity (pseudo-dimension) bounds can be established rigorously (Theorem 4.4 below), and they result in smaller tree sizes compared to traditional cutting planes (Section 6). We note that this particular family of cut generating functions has not been studied previously in the literature (from a theory or computational perspective), though they are a subclass of cut generating functions studied in .

### The construction

Recall that \(m\) is the total number of constraints in the original integer program (1), and \(k m\) is the number of rows from the simplex tableaux used to derive the cutting planes. For any \([0,1)^{k}\{\}\) and \(=[_{1},,_{k}] ^{}_{k}^{}\) with a universal large constant \( 2m\), let

\[^{0}=^{k}_{i}^{i}}{_{ i=1}^{k}_{i}_{i}},\;^{1}= _{1}-1}^{1},...,\;^{k}=_{k}-1}^{k}^{k},\]

where \(^{i}\) denotes the \(i\)-th standard basis vector in \(^{k}\). Define \(_{,}:^{k}\) by

\[_{,}():=_{^{ k}}_{i=0,,k}^{i},+.\]

Using well-known results from cut generating function theory, it can be shown that \(_{,}\) satisfies the three conditions in Section 2.1 to qualify as a cut generating function; see, for example, the analysis in . It is noteworthy that for each \(=^{i}\) with \(i\{1,,k\}\), the function \(_{,}\) is equivalent to the one-dimensional GMI function \(_{_{i}}\), defined in Section 2.1.

**Remark 4.1**.: As we pointed out in the introduction, both families of cut generating functions considered in this paper are extreme for the pure integer infinite relaxation problem (Conforti et al., 2014; Gomory and Johnson, 1972a,b). The first family, described in Section 3.1, was proved to be extreme in Gomory and Johnson's original paper (Gomory and Johnson, 2003). For \(k\)-dimensional CGFs, they are minimal valid functions as they are the trivial lifting of the gauge function of maximal \((+^{k})\)-free convex sets with the covering property (Basu et al., 2013a; Conforti et al., 2014; Averkov and Basu, 2015). Then, these \(k\)-dimensional CGFs are extreme by the \((k+1)\)-slope theorem (Basu et al., 2013b).

### Computation and pseudo-dimension

Algorithm 1 shows how to compute the function values \(_{,}()\) (the cutting plane coefficients), in time that is linear in the dimension \(k\). We then expose an important piecewise structure of the corresponding family of cutting planes for (2) in Proposition 4.3. This piecewise structure is the key to establishing upper bounds on the pseudo-dimension (recall Lemma 2.1) for learning the optimal cut generating function from this family in Theorem 4.4.

```
1:Input:\(k_{+}[2,)\), \([0,1)^{k}\{\}\), \(=[_{1},,_{k}]^{}_{k}^{}\), \(^{k}\)
2:Output:\(_{,}()\)
3:\(}-[]-_{i=1}^{k}( _{i}_{i}+[_{i}])^{i}\)\(\)\(()\) is the indicator function
4:\(p_{i=1}^{k}_{i}}_{i}\)
5:\(q_{i=1}^{k}_{i}_{i}\)
6:\([_{1}}{[_{1}-1,, }_{k}}{}_{k}-1}]}.\)
7:\(a\{_{i}:i\{1,,k\}\}\)
8:\(i^{*}\{_{i}:i\{1,,k\}\}\)
9:\(b\{_{i}:i\{1,,k\}\{i^{*}\}\}\)
10:\(^{*}}_{i} q-(_{i^{*}}-1)p}{ _{i^{*}}(_{i}-1)-q}\)
11:\(_{,}()\{\{ _{i^{*}}[^{*}]}{q},}_{i^{*} }+[^{*}]}{}_{i^{*}}-1},b\},\{_{i^{*}}[^{*}]}{q},}_{i^{*}}+[ ^{*}]}{}_{i^{*}}-1},b\},\{,a \}\}\) ```

**Algorithm 1** Computation of \(_{,}()\)

**Theorem 4.2**.: For any \([0,1)^{k}\{\}\), \( 2k\), and \(_{k}^{}\), Algorithm 1 computes \(_{,}()\) in \((k)\) time. Therefore, the cutting plane obtained from \(_{,}\) can be computed in \((kn)\) time.

**Proposition 4.3**.: For any fixed \(k[2,+]\), \([0,1)^{k}\{\}\), \(^{1},,^{n}^{k}\), and \( 2k\), there exists a decomposition of \(_{k}^{}\) obtained by at most \(2n(+3)^{2}\) hyperplanes such that within each region, each coordinate of the cutting plane \([_{,}(^{1}),,_{,}(^{n})]^{}\) is a fixed rational function given by the quotient of two affine linear functions of \(\), where the denominator is always a fixed positive function of \(\).

**Theorem 4.4**.: For any fixed \(k[2,+]\), let \(T^{k}(I,)\) denote the tree size of the branch-and-cut algorithm after adding the cut induced by \(_{,}\) at the root for a given instance \(I\), where \(\) is determined by \(I\). Then, the pseudo-dimension is given by

\[(\{T^{k}(,):[0,B]_{k}^{}\})=(kn^{2}((m+n)) +k^{2}(n)).\]

## 5 Learnability of instance-dependent cut generating functions

The authors in (Cheng et al., 2024) studied the learnability of neural networks that select instance-dependent algorithms for any computational problem, as opposed to selecting a single algorithm that has the best expected performance, and applied this to the problem of selecting from the Chvatal-Gomory cutting plane family. Inspired by their work, this section discusses employing neural networks to dynamically select the most suitable cut generating function from a given family, tailored to each instance, as opposed to selecting a single cut generating function that has the best expected performance overall (as was done in Sections 3 and 4). In other words, given access to samples from the instance distribution, we want to learn the parameters of the optimal neural network that will map instances to instance specific cut generating functions.

We define a neural network \(_{}:^{d}^{W}^{}\) consisting of a fully connected architecture with ReLU activations, \(L\) layers, \(W\) parameters, \(d\) input units, \(\) output units, and \(U\) units in total. An encoder function \(:^{d}\) is employed to transform instances \(I=(A,,)\) into suitable neural network inputs, where a straightforward choice for \(\) could be the flattening of \(I\) into a vector, although more complex encoding strategies can be adopted to capture additional structural information about the instances. The primary goal is to input the encoded instance \((I)\) into the neural network, which then predicts parameters for the cut generating function that were discussed in Section 3 and Section 4. This idea is supported by empirical evidence of performance improvements when enumerating cutting plane parameters in an instance-dependent manner, as demonstrated in Table 1. A direct application of the main theorem in (Cheng et al., 2024) yields the following results:

**Theorem 5.1**.: Let \(h,h^{k}:^{W}[0,B]\) denote the branch-and-cut tree size after adding the cutting planes induced by corresponding cut generating functions, using parameters determined by the neural network described above. Formally, they are defined as \(h(I,)=T(I,_{2}((I),))\) and \(h^{k}(I,)=T^{k}(I,_{k}((I),))\), where \(T\) and \(T^{k}\) are the tree size functions defined in Theorems 3.2 and 4.4 respectively. Then the pseudo-dimension of these two learning problems have the following upper bounds:

\[(\{h(,): ^{W}\}) =(LW(U+2)+n^{2}W((m+n))),\] \[(\{h^{k}(,): ^{W}\}) =(LW(U+k)+kW(n)+n^{2}W((m+n) )).\]

## 6 Numerical experiments

Setup.We conducted numerical experiments to evaluate the performance of both one-dimensional and \(k\)-dimensional cut generating functions, as discussed in Section 3 and Section 4, across various distributions. The performance of these functions was compared to the GMI cut. The parameters for the cut generating functions were selected to minimize the average branch-and-cut tree size on the training set of size \(100\), and these parameters were then applied to the test set of size \(100\) to evaluate performance. All results presented in Table 1 are based on the test set, except for the last column. The experiments were run on a Linux machine equipped with a 12-core Intel i7-12700F CPU and 32GB of RAM. We solved the integer programming problems using Gurobi 11.0.1 (Gurobi Optimization, LLC, 2023), with default cuts, heuristics, and presolve settings turned off. The code and data used in all experiments are available at https://github.com/Hongyu-Cheng/LearnCGF.

Problem descriptions.We considered two types of problems: Knapsack and Packing.

1. \((N,K)\): Multiple knapsack problem with \(N\) items and \(K\) knapsacks. Instances were generated using the so-called "Chvatal distribution" from (Balcan et al., 2021). Note that there are some trivial upper bound constraints on the variables that contribute to the simplex tableaux. Even so, the table has n/a entries for the \(k\)-row cut strategies for the \(1\)-knapsack problem, as there are not enough fractional rows to generate multi-row cuts for many instances.

2. Packing(\(m,n\)): Packing problem with \(m\) constraints and \(n\) variables. We note that the knapsack problem can be viewed as a special case of the packing problem with binary variables. The packing instances were generated using the distribution from (Tang et al., 2020).

Cutting plane strategies.The following cutting plane strategies were evaluated and compared:

1. GMI: Classical Gomory's mixed integer cut as defined in Section 2.1.
2. \(1\)-row cut: Generated using the one-dimensional cut generating function defined in Section 3. We fixed \(p=q=2\) and performed a grid search with a step size of 0.1 to select the best parameter \(\{0,0.1,,0.9,1\}^{2}\).
3. \(k\)-row cut: Generated using \(_{,}\) defined in Section 4 with \(k\{2,5,10\}\). We uniformly sampled 121 different \(\) on the simplex \(_{k}^{}\)(see (Gordon-Rodriguez et al., 2020, Smith and Tromble, 2004)), and selected the best parameter based on the training set.
4. Best \(1\)-row cut: The average tree size using the best parameter for each instance on the _training set_. This is not a practical strategy but indicates the strength of the cut generating functions and the potential for instance-dependent cut generating using neural networks.

Since we aim to demonstrate that cut generating functions can produce stronger cuts than classical cutting planes, we did not specifically consider which row to select to generate the cut. This problem, while important in integer programming literature, is outside the scope of this paper. All cuts are generated from the first row of the simplex tableau with a non-integer right-hand side, and the \(k\)-row cut is generated from the first \(k\) such rows. Also, to select the best parameters based on samples (i.e., solve the ERM problem), we used a simple grid search and optimized through enumeration, since the branch-and-cut tree size is a highly sophisticated function of the added cutting planes at the root node.

Numerical results.As shown in Table 1, the two cut generating function families considered in this paper reduce the size of the branch-and-cut tree compared to the GMI cut. Although the improvement over the GMI cut on the test set is less obvious for the packing problem, the last column in the table shows that there are still cutting planes that perform much better for each instance. Moreover, all the multi-row cuts on the \((30,3)\) problems outperform the best 1-row cut, indicating that multi-row cuts can sometimes achieve performance levels that single-row cuts cannot reach.