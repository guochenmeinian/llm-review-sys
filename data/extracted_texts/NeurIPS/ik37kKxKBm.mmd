# In-Context Learning with Representations:

Contextual Generalization of Trained Transformers

 Tong Yang

CMU

&Yu Huang

UPenn

&Yingbin Liang

OSU

&Yuejie Chi

CMU

Department of Electrical and Computer Engineering, Carnegie Mellon University; email: tongyang@andrew.cmu.edu. Department of Statistics and Data Science, Wharton School, University of Pennsylvania; email: yuh42@wharton.upenn.edu. Department of Electrical and Computer Engineering, The Ohio State University; email: liang.889@osu.edu. Department of Electrical and Computer Engineering, Carnegie Mellon University; email: yuejiechi@cmu.edu.

###### Abstract

In-context learning (ICL) refers to a remarkable capability of pretrained large language models, which can learn a new task given a few examples during inference. However, theoretical understanding of ICL is largely under-explored, particularly whether transformers can be trained to generalize to unseen examples in a prompt, which will require the model to acquire contextual knowledge of the prompt for generalization. This paper investigates the training dynamics of transformers by gradient descent through the lens of non-linear regression tasks. The contextual generalization here can be attained via learning the template function for each task in-context, where all template functions lie in a linear space with \(m\) basis functions. We analyze the training dynamics of one-layer multi-head transformers to in-contextly predict unlabeled inputs given partially labeled prompts, where the labels contain Gaussian noise and the number of examples in each prompt are not sufficient to determine the template. Under mild assumptions, we show that the training loss for a one-layer multi-head transformer converges linearly to a global minimum. Moreover, the transformer effectively learns to perform ridge regression over the basis functions. To our knowledge, this study is the first provable demonstration that transformers can learn contextual (i.e., template) information to generalize to both unseen examples and tasks when prompts contain only a small number of query-answer pairs.

## 1 Introduction

Transformers (Vaswani et al., 2017) have achieved tremendous successes in machine learning, particularly in natural language processing, by introducing self-attention mechanisms that enable models to capture long-range dependencies and contextualized representations. In particular, these self-attention mechanisms endow transformers with remarkable in-context learning (ICL) capabilities, allowing them to adapt to new tasks or domains by simply being prompted with a few examples that demonstrate the desired behavior, without any explicit fine-tuning or updating of the model's parameters (Brown et al., 2020).

A series of papers have empirically studied the underlying mechanisms behind in-context learning in transformer models (Garg et al., 2022; Von Oswald et al., 2023; Wei et al., 2023; Olsson et al., 2022; Xie et al., 2021; Chen and Zou, 2024; Agarwal et al., 2024), which have shown that transformers can predict unseen examples after being prompted on a few examples. The pioneering work ofGarg et al. (2022) showed empirically that transformers can be trained from scratch to perform in-context learning of simple function classes, providing a theoretically tractable in-context learning framework. Following this well-established framework, several works have investigated various properties of in-context learning in transformers. For instance, studies have explored generalization and stability (Li et al., 2023), expressive power (Bai et al., 2024; Akyurek et al., 2022; Giannou et al., 2023), causal structures (Nichani et al., 2024; Edelman et al., 2024), statistical properties (Xie et al., 2021; Jeon et al., 2024), to name a few.

In particular, analysis from an optimization perspective can provide valuable insights into how these models acquire and apply knowledge that enable in-context learning. A few works (Huang et al., 2023; Chen et al., 2024; Li et al., 2024; Nichani et al., 2024) thus studied the training dynamics of shallow transformers with softmax attention in order to in-context learn simple tasks such as linear regression (Huang et al., 2023; Chen et al., 2024), binary classification tasks (Li et al., 2024), and causal graphs (Nichani et al., 2024). Their theoretical analyses illuminated how transformers, given an arbitrary query token, learn to _directly_ apply the answer corresponding to it from the query-answer pairs that appear in each prompt. Therefore, they all require the sequence length of each prompt to be large enough so that all query-answer pairs have been seen in each prompt with sufficiently high probability, whereas practical prompts are often too short to contain many query examples. This suggests that in-context learning can exploit _inherent contextual_ information of the prompt to generalize to _unseen_ examples, which further raise the following intriguing theoretical question:

_How do transformers learn contextual information from more general function classes to predict unseen examples given prompts that contain only partial examples?_

Since our paper studies ICL of non-linear function regression, the function mapping (which we also term as "template") naturally serves as the "contextual information" that can be learned for generalization to unseen examples. When each prompt contains only a small number of (noisy) examples, the template that generates the labels may be _underdetermined_, i.e., multiple templates could generate the same labels in the prompt. Such an issue of underdetermination further raises a series of intriguing questions, such as:

_When the template that generates a prompt is underdetermined, what is the transformer's preference for choosing the template and how good is such a choice?_

### Our contributions

In this paper, we answer the above questions by analyzing the training dynamics of a one-layer transformer with multi-head softmax attention through the lens of non-linear regression tasks. In our setting, the template function for each task lies in the linear space formed by \(m\) nearly-arbitrary basis functions that capture representation (i.e., features) of data. Our goal is to provide insights on how transformers trained by gradient descent (GD) acquire template information from more general function classes to generalize to unseen examples and tasks when each prompt contains only a small number of query-answer pairs. We summarize our contributions are as follows.

* We first establish the convergence guarantee of a one-layer transformer with multi-head softmax attention trained with gradient descent on general non-linear regression in-context learning tasks. We assume each prompt contains only a few (i.e., partial) examples with their Gaussian noisy labels, which are not sufficient to determine the template. Under mild assumptions, we establish that the training loss of the transformer converges at a linear rate. Moreover, by analyzing the limit point of the transformer parameters, we are able to uncover what information about the basic tasks the transformer extracts and memorizes during training in order to perform in-context prediction.
* We then analyze the transformer's behavior at inference time after training, and show that the transformer chooses its generating template by performing ridge regression over the basis functions. We also provide the iteration complexity for pretraining the transformer to reach \(\)-precision with respect to its choice of the template given an arbitrary prompt at inference time. We further compare the choice of the transformer and the best possible choice over the template class and characterize how the sequence length of each prompt influences the inference time performance of the model.

* Under more realistic assumptions, our analysis framework allows us to overcome a handful of assumptions made in previous works such as large prompt length (Huang et al., 2023; Chen et al., 2024; Li et al., 2024; Nichani et al., 2024), orthogonality of data (Huang et al., 2023; Chen et al., 2024; Li et al., 2024; Nichani et al., 2024), restrictive initialization conditions (Chen et al., 2024), special structure of the transformer (Nichani et al., 2024), and mean-field models (Kim and Suzuki, 2024). Further, the function classes we consider are a generalization of those considered in most theoretical works (Huang et al., 2023; Chen et al., 2024; Li et al., 2024; Wu et al., 2023; Zhang et al., 2023a). We also highlight the importance of multi-head attention mechanism in this process.

To our best knowledge, this is the _first_ work that analyzes how transformers learn contextual (i.e., template) information to generalize to unseen examples and tasks when prompts contain only a small number of query-answer pairs. Table 1 provides a detailed comparison with existing theoretical works in terms of settings, training analysis and generalization of in-context learning.

### Related work

In-context learning.Recent research has investigated the theoretical underpinnings of transformers' ICL capabilities from diverse angles. For example, several works focus on explaining the in-context learning of transformers from a Bayesian perspective (Xie et al., 2021; Ahuja et al., 2023; Han et al., 2023; Jiang, 2023; Wang et al., 2023; Wies et al., 2024; Zhang et al., 2023b; Jeon et al., 2024; Hahn and Goyal, 2023). Li et al. (2023) analyzed the generalization and stability of transformers' in-context learning. Focusing on the representation theory, Akyurek et al. (2022), Bai et al. (2024) studied the expressive power of transformers on the linear regression task. Akyurek et al. (2022) showed by construction that transformers can represent GD of ridge regression or the closed-form ridge regression solution. Bai et al. (2024) extended Akyurek et al. (2022) and showed that transformers can implement a broad class of standard machine learning algorithms in-context. Dai et al. (2022), Von Oswald et al. (2023) showed transformers could in-context learn to perform GD.

More pertinent to our work, Guo et al. (2023) considered an ICL setting very similar to ours, where the label depends on the input through a basis of possibly complex but fixed template functions, composed with a linear function that differs in each prompt. By construction, the optimal ICL algorithm first transforms the inputs by the representation function, and then performs linear ICL on top of the transformed dataset. Guo et al. (2023) showed the existence of transformers that approximately implement such algorithms, whereas our work is from a different perspective, showing that (pre)training the transformer loss by GD will naturally yield a solution with the aforementioned desirable property characterized in Guo et al. (2023).

Training dynamics of transformers performing ICL.A line of work initiated by Garg et al. (2022) aims to understand the ICL ability of transformers from an optimization perspective. (Zhang et al., 2023a; Kim and Suzuki, 2024) analyzed the training dynamics of transformers with _linear_ attention. Huang et al. (2023), Chen et al. (2024), Li et al. (2024) studied the optimization dynamics of one-layer softmax attention transformers performing simple in-context learning tasks, such as linear regression (Huang et al., 2023; Chen et al., 2024) and binary classification (Li et al., 2024).

    & nonlinear & multi & task & GD & noisy & representation \\  & attention & head & shift & convergence & data & learning \\  Wu et al. (2023) & ✗ & ✗ & ✓ & ✓ & ✓ & ✗ \\ Zhang et al. (2023a) & ✗ & ✗ & ✓ & ✓ & ✓ & ✗ \\ Huang et al. (2023) & ✓ & ✗ & ✓ & ✓ & ✗ & ✗ \\ Li et al. (2024) & ✓ & ✗ & ✓ & ✓ & ✓ & ✗ \\ Chen et al. (2024) & ✓ & ✓ & ✗ & ✗ & ✓ & ✗ \\ Kim and Suzuki (2024) & ✗ & ✗ & ✓ & ✗ & ✗ & ✓ \\ Ours & ✓ & ✓ & ✓ & ✓ & ✓ & ✓ \\   

Table 1: Comparisons with existing theoretical works that study the learning dynamics of transformers in ICL. Here, the last column refers to the fact that the response in the regression task is generated by a linearly weighted unknown representation (feature) model.

Among them, Huang et al. (2023) was the first to study the training dynamics of softmax attention, where they gave the convergence results of a one-layer transformer with single-head attention on linear regression tasks, assuming context features come from an orthogonal dictionary and each token in the prompts is drawn from a multinomial distribution. In order to leverage the concentration property inherent to multinomial distributions, they require the sequence length to be much larger than the size of dictionary. Their analysis indicates that the prompt tokens that are the same as the query will have dominating attention weights, which allows the transformer to _copy-paste_ the correct answer from those prompt tokens.

Li et al. (2024) studied the training of a one-layer single-head transformer in ICL on binary classification tasks. Same as Huang et al. (2023), they required the data to be pairwise orthogonal, and shared the same copy-paste mechanism as in Huang et al. (2023). To be precise, a fraction of their context inputs needs to contain the same pattern as the query to guarantee that the total attention weights on contexts matching the query pattern outweigh those on other contexts.

Chen et al. (2024) studied the dynamics of _gradient flow_ for training a one-layer multi-head softmax attention model for ICL of multi-task linear regression, where the coefficient matrix has certain spectral properties. They required the sequence length to be sufficiently large (Chen et al., 2024, Assumption 2.1), together with restrictive initialization conditions (Chen et al., 2024, Definition 3.1). While using the copy-paste analysis framework as in Huang et al. (2023), Li et al. (2024), the attention probability vector in their work is delocalized, so that the attention is spread out to capture the information from similar tokens in regression tasks. Kim and Suzuki (2024) studied the dynamics of Wasserstein gradient flow for training a one-layer transformer with an infinite-dimensional fully-connected layer followed by a linear attention layer for ICL of linear regression, assuming infinite prompt length. Nichani et al. (2024) analyzed the optimization dynamics of a simplified two-layer transformer with gradient descent on in-context learning a latent causal graph.

Notation.Boldface small and capital letters denote vectors and matrices, respectively. Sets are denoted with curly capital letters, e.g., \(\). We let \((^{d},)\) denote the \(d\)-dimensional real coordinate space equipped with norm \(\). \(I_{d}\) is the identity matrix of dimension \(d\). The \(^{p}\)-norm of \(\) is denoted by \(_{p}\), where \(1 p\), and the spectral norm and the Frobenius norm of a matrix \(\) are denoted by \(_{2}\) and \(_{F}\), respectively. \(^{}\) stands for the Moore-Penrose pseudoinverse of matrix \(\), and \(}_{,i}\) stands for its \(i\)-th column vector. We let \([N]\) denote \(\{1,,N\}\), and denote \(_{N}\) to represent the all-one vector of length \(N\), and by \(\) a vector or a matrix consisting of all \(0\)'s. We allow the application of functions such as \(()\) to vectors or matrices, with the understanding that they are applied in an element-wise manner. We use \(_{i}\) to denote the one-hot vector whose \(i\)-th entry is \(1\) and the other entries are all \(0\).

## 2 Problem Setup

In-context learning with representation.We consider ICL of regression with unknown representation, similar to the setup introduced in Guo et al. (2023). To begin, let \(f:^{d}^{m}\) be a fixed representation map that \(f()=(f_{1}(),,f_{m}())^{}\) for any \(^{d}\). The map \(f\) can be quite general, which can be regarded as a feature extractor that will be learned by the transformer. We assume that each ICL task corresponds to a map \(^{}f()\) that lies in the linear span of those \(m\) basis functions in \(f()\), where \(\) is generated according to the distribution \(_{}\). Thus, for each ICL instance, the (noisy) label of an input \(_{k}\) (\( k[K]\)) is given as

\[y_{k}=^{}(f(_{k})+_{k}),_{},_{k}}{{}}(0,_{m})\] (1)

where \(>0\) is the noise level.

The goal of ICL is to form predictions on query \(_{}\) given in-context labels of the form (1) on a few inputs, known as _prompts_. In this paper, we use \(\) to denote the _dictionary_ set that contains all \(K\) unit-norm _distinct_ tokens, i.e., \(\{_{1},,_{K}\}^{d}\) with each token \(_{k}_{2}=1\). We assume that each prompt \(P=P_{}\) provides the first \(N\) tokens (with \(N K\)) and their labels, and is embedded in the following matrix

\[^{P}_{1}&_{2}&&_{N}\\ y_{1}&y_{2}&&y_{N}\\ ^{}^{(d+1) N},\] (2)

where

\[(_{1},,_{N})^{d N}\] (3)is the collection of prompt tokens, and \((y_{1},,y_{N})^{}\) is the prompt label. Given the prompt as the input, the transformer predicts the labels for all the \(K\) tokens \(y_{1},,y_{K}\) in the dictionary set.

Transformer architecture.We adopt a one-layer transformer with multi-head softmax attention (Chen et al., 2024) -- illustrated in Figure 1 -- to predict the labels of all the tokens in the dictionary \(\), where \(H\) is the number of heads. Denote the query embedding as

\[^{Q}_{N+1}&_{N+2}&&_{K} \\ 0&0&&0^{(d+1)(K-N)},\] (4)

and denote the embedding of both the prompt and the query as \((^{P},^{Q})^{(d+1) K}\). We define the output of each transformer head as

\[_{h}()_{h}^{}^{P}((^{P})^{}(_{h}^{})^{}_{h}^{ }), h[H],\] (5)

where \(_{h}^{}^{d_{k}(d+1)}\), \(_{h}^{}^{d_{k}(d+1)}\), and \(_{h}^{}^{K(d+1)}\) are the query, key, and value matrices, respectively, and the softmax is applied column-wisely, i.e., given a vector input \(\), the \(i\)-th entry of \(()\) is given by \(e^{x_{i}}/_{j}e^{x_{j}}\). The attention map of the transformer \(()\) is defined as

\[()^{}_{1} ()\\ \\ _{H}()^{K K},\] (6)

where \(^{}\) is the output matrix. Following recent theoretical literature to streamline analysis (Huang et al., 2023; Nichani et al., 2024; Deora et al., 2023; Chen et al., 2024), we assume that the embedding matrices take the following forms:

\[^{}(_{K},,_{K}) ^{K HK},_{h}^{}(,_{ h})^{K(d+1)},\] (7a) \[(_{h}^{})^{}_{h}^{}= _{h}&\\ &0^{(d+1)(d+1)}, h[H],\] (7b)

where \(_{h}=(w_{h,1},,w_{h,K})^{}^{K}\) and \(_{h} R^{d d}\) are trainable parameters for all \(h[H]\).

The prediction of the labels is provided by the diagonal entries of \(()\), which we denote by \(}=(_{1},,_{K})^{K}\). Note that \(_{k}\) takes the following form under our parameter specification:

\[ k[K]:_{k}=,_{h=1}^{H}w_{h, k}\,(^{}_{h}_{k}).\] (8)

Training via GD.Let \(=\{_{h},_{h}\}_{h=1}^{H}\) denote all trainable parameters of \(\). Let \((_{1},,_{K})^{m K}\) denote the noise matrix. Given training data over ICL instances, the goal of training is to predict labels \(y_{k}\) for all \(_{k}\). Specifically, we train the transformer using gradient descent (GD) by optimizing the following mean-squared population loss:

\[()_{,}[_{k=1}^{K}(_{k}-y_{k})^{2} ].\] (9)

Figure 1: The structure of a one-layer transformer with multi-head softmax attention.

We apply different learning rates \(_{Q},_{w}>0\) for updating \(\{_{h}\}_{h=1}^{H}\) and \(\{_{h}\}_{h=1}^{H}\), respectively, i.e., at the \(t\)-th (\(t 1\)) step, we have

\[ h[H]:_{h}^{(t)}=_{h}^{(t-1)}-_{Q}_{_{h}}(^{(t-1)}),_{h}^{(t)}=_{h}^{(t-1) }-_{w}_{_{h}}(^{(t-1)}),\] (10)

where \(^{(t)}=\{_{h}^{(t)},_{h}^{(t)}\}_{h=1}^{H}\) is the parameter at the \(t\)-th step.

Inference time.At inference time, given a prompt \(P=P_{}\) with \(N\) examples, where \(\)_may not be in the support of the generation distribution_\(_{}\), the transformer applies the pretrained parameters and predicts the labels of all \(K\) tokens without further parameter updating.

## 3 Theoretical Analysis

### Training time convergence

In this section, we show that the training loss \(\) converges to its minimum value at a linear rate during training, i.e., the function gap

\[^{(t)}(^{(t)})-_{}  0, t\] (11)

at a linear rate, under some appropriate assumptions.

Key assumptions.We first state our technical assumptions. The first assumption is on the distribution \(_{}\) for generating the coefficient vector \(\) of the representation maps.

**Assumption 1** (Assumption on distribution \(_{}\)).: _We assume that in (1) each entry \(_{i}\) is drawn independently and satisfies \([_{i}]=0\) and \([_{i}^{2}]=1\) for all \(i[m]\)._

To proceed, we introduce the following notation:

\[(f(_{1}) f(_{N}))^{m N}, }(^{}+m_{N})^{1 /2}^{N N},\ \ _{}_{i[N]}\|}_{i} \|_{2},\] (12)

where \(}_{i}\) is the \(i\)-th column vector of \(}\) for \(i[N]\). We further define \(_{k}^{(t)}\) (\(k[K]\), \(t_{+}\)) and \(_{k}^{(t)}\) as follows:

\[_{k}^{(t)}(^{}_{1}^{(t)}_ {k},,^{}_{H}^{(t)}_{k})^{N H}, _{k}^{(t)}=}_{k}^{(t)}^{N H}.\] (13)

To guarantee the convergence, we require the initialization of the parameters \(^{(0)}\) satisfies the following condition.

**Assumption 2** (Assumption on initialization).: _For all \(k[K]\), \(_{k}^{(0)}\) has full row rank._

Before stating our main theorem, let us examine when the initialization condition in Assumption 2 is met. Fortunately, we only require the following mild assumption on \(\) to ensure our parameter initialization has good properties.

**Assumption 3** (Assumption on \(\)).: _There exists one row vector \(=(x_{1},,x_{N})^{}\) of the prompt token matrix \(\) (cf. (3)) such that \(x_{i} x_{j}\), \( i j\)._

Assumption 3 implies that \(\) has distinct tokens, i.e., \(_{j}_{k}\) when \(j k\). It is worth noting that Assumption 3 is the only assumption we have on the dictionary \(\). In comparison, all other theoretical works in Table 1 impose somewhat unrealistic assumptions on \(\). For example, Huang et al. (2023), Li et al. (2023), Nichani et al. (2024) assume that the tokens are pairwise orthogonal, which is restrictive since it implies that the dictionary size \(K\) should be no larger than the token dimension \(d\), whereas in practice it is often the case that \(K d\)(Reid et al., 2024; Touvron et al., 2023). In addition, Chen et al. (2024), Zhang et al. (2023), Wu et al. (2023) assume that each token is independently sampled from some Gaussian distribution, which also does not align with practical scenarios where tokens are from a fixed dictionary and there often exist (strong) correlations between different tokens.

The following proposition states that when the number of heads exceeds the number of prompts, i.e. \(H N\), we can guarantee that Assumption 2 holds with probability 1 by simply initializing \(\{_{h}\}_{h=1}^{H}\) using Gaussian distribution.

**Proposition 1** (Initialization of \(\{_{h}\}_{h=1}^{H}\)).: _Suppose Assumptions 1, 3 hold and \(H N\). For any fixed \(>0\), let \(_{h}^{(0)}(i,j)(0,^{2})\), then Assumption 2 holds almost surely._

Proof.: See Appendix E.1. 

Choice of learning rates.Define

\[_{0}_{k[K]}\{_{}(_{k}^{(0)} {B}_{k}^{(0)})\},\] (14)

where \(^{(0)}\) is the initial function gap (c.f. (11)). Assumption 2 indicates that \(_{0}>0\). Let \(\) be any positive constant that satisfies

\[_{0}^{-5/4}(}{-1}\| \|_{2}^{2}_{}K^{3/2}^{(0)})^{1/2}.\] (15)

We set the learning rates as

\[_{Q} 1/L_{w}=^{2}_{Q},\] (16)

where5

\[L^{2}=(8H\|_{2}^{2 }}{_{0}}}+1+^{}} \|_{2}}{m})^{2}\|\|_{2}^{4}(^{2}+^{2}}K^{2}N^{(0)})\] \[+2H^{2}\|\|_{2}^{4}(}{K^{2}}+^{4}}K^{3}\|\|_{2}^{2} (^{(0)})^{2}).\] (17)

Theoretical guarantee.Now we are ready to state our first main result, regarding the training dynamic of the transformer.

**Theorem 1** (Training time convergence).: _Suppose Assumptions 1, 2 hold. We let \(_{k}^{(0)}=\) and set the learning rates as in (16). Then we have_

\[(^{(t)})-_{}() (1-_{0}}{2K})^{t}((^{ (0)})-_{}()), t .\] (18)

Proof.: See Appendix C. 

Theorem 1, together with Proposition 1, shows that the training loss converges to its minimum value at a linear rate, under mild assumptions of the task coefficients and token dictionary. This gives the _first_ convergence result for transformers with multi-head softmax attention trained using GD to perform ICL tasks (see Table 1). Our convergence guarantee (18) also indicates that the convergence speed decreases as the size \(K\) of the dictionary or the number \(H\) of attention heads increases, which is intuitive because training with a larger vocabulary size or number of parameters is more challenging. However, a small \(H\) will limit the expressive power of the model (see Section 3.3 for detailed discussion), and we require \(H N\) to guarantee Assumption 2 holds, as stated in Proposition 1.

### Inference time performance

We now move to examine the inference time performance, where the coefficient vector \(\) corresponding to the inference task may not drawn from \(_{}\). In fact, we only assume that the coefficient vector \(\) at inference time is bounded as in the following assumption.

**Assumption 4** (Boundedness of \(\) at inference time).: _We assume that at inference time \(\|\|_{2} B\) for some \(B>0\)._

For notational simplicity, let \(^{Q}^{m(K-N)}\) denote

\[^{Q}(f(_{N+1}),,f(_{K}))^{m (K-N)}.\] (19)

The following theorem characterizes the performance guarantee of the transformer's output \(}\) (after sufficient training) at the inference time.

**Theorem 2** (Inference time performance).: _Let \(}\) be the solution to the following ridge regression problem:_

\[}_{}\{_{ i=1}^{N}(y_{i}-^{}f(_{i}))^{2}+\|\|_{2}^{2}\}.\] (20)

_Under the assumptions in Theorem 1, for any \(>0\) and \((0,1)\), if the number of training iterates \(T\) satisfies_

\[T}(\|\|_{2}+(2+2(1/)+N)^{1/2})^{2} /(m))}{(1/(1-}}{2R}))},\] (21)

_then given any prompt \(P\) that satisfies Assumption 4 at the inference time, with probability at least \(1-\), the output of the transformer \(}\) satisfies_

\[\|}-}^{}\|_{2}^{2} ,}^{} \\ (^{Q})^{}}.\] (22)

Proof.: See Appendix D. 

In Theorem 2, (22) shows that after training, the transformer learns to output the given labels of the first \(N\) tokens in each prompt, and more importantly, predicts the labels of the rest \(K-N\) tokens by implementing the ridge regression given in (20). Note that Akyurek et al. (2022) studied the expressive power of transformers on the linear regression task and showed by construction that transformers can represent the closed-form ridge regression solution. Interestingly, here we show from an optimization perspective that transformers can in fact be trained to do so.

Generalization capabilities of the pretrained transformer.Theorem 2 captures two generalization capabilities that the pretrained transformer can have.

1. _Contextual generalization to unseen examples:_ Theorem 2 suggests that the transformer exploits the _inherent contextual_ information (to be further discussed in Section 3.3) of the function template in the given prompt, and can further use such information to predict the unseen tokens.
2. _Generalization to unseen tasks:_ Theorem 2 also suggests that the pretrained transformer can generalize to a function map corresponding to any \(^{m}\) at the inference time (albeit satisfying Assumption 4), which is not necessarily sampled from the support of its training distribution \(_{}\).

We note that the contextual generalization that the transformer has here is different in nature from the prediction ability shown in previous works on ICL (Huang et al., 2023; Chen et al., 2024; Li et al., 2024; Nichani et al., 2024). Those work focuses on a setting where each prompt contains a good portion of tokens similar to the query token, allowing the transformer to _directly_ use the label of the corresponding answers from the prompt as the prediction. However, in practical scenarios, prompts often contain only partial information, and our analysis sheds lights on explaining how transformers generalize to unseen examples by leveraging ridge regression to infer the underlying template.

How does the representation dimension affect the performance?Beyond the above discovery, several questions are yet to be explored. For instance, while we demonstrate that transformers can be trained to implement ridge regression, how good is the performance of the ridge regression itself? What is the best choice of ridge regression we could expect? How close is the transformer's choice to the best possible choice? We address these questions as follows.

Given any prompt \(P\) at inference time, since there is no label information about the rest \(K-N\) tokens, the best prediction we could hope for from the transformer shall be

\[}^{}\\ (^{Q})^{}}_{},\] (23)

where \(^{Q}\) is defined in (19), and \(}_{}\) satisfies:

\[}_{}_{}_{ }[_{i=1}^{N}(y_{i}-^{}(f( _{i})+_{i}))^{2}].\] (24)In other words, we hope the transformer outputs the given \(N\) labels as they are. For the rest \(K-N\) labels, the best we could hope for is that the transformer estimates the coefficient vector \(\) by solving the above regression problem to obtain \(}_{}\), and predict the \(k\)-th label by \(}_{}^{}f(_{k})\) for \(k=N+1,,K\). Note that (24) is equivalent to the following ridge regression problem (see Lemma 4 in the appendix for its derivation):

\[}_{}=_{}\{ _{i=1}^{N}(y_{i}-^{}f(_{i}))^{2}+\| \|_{2}^{2}\}.\] (25)

The only difference between the two ridge regression problems (20) and (25) is the coefficient of the regularization term. This indicates that at the training time, the transformer learns to implement ridge regression to predict the labels of the rest \(K-N\) tokens, assuming the noise level is given by \(\). This observation also reflects how the sequence length \(N\) affects the transformer's preference for choosing templates and its performance at inference time:

* The closer \(m\) is to \(N\), the closer the transformer's choice of templates is to the best possible choice, and the better the transformer's prediction will be;
* When \(N<m\), the transformer tends to underfit by choosing a \(\) with small \(_{2}\)-norm;
* When \(N>m\), the transformer tends to overfit since it underestimates the noise level and in turn captures noise in the prediction.

### Further interpretation

We provide more interpretation on our results, which may lead to useful insights into the ICL ability of the transformer.

How does the transformer gain ICL ability with representations?Intuitively speaking, our pretrained transformer gains in-context ability by extracting and memorizing some "inherent information" of all basic function maps \(f_{i}\) (\(i[m]\)) during the training. Such information allows it to infer the coefficient vector \(\) from the provided labels in each prompt and calculate the inner product \(,f(_{k})\) to compute \(y_{k}\) given any token \(_{k}\) at inference time. To be more specific, the "inherent information" of all basic tasks could be described by the \(N\)-by-\(K\) matrix \(\) defined as follows (see also (34)):

\[(^{}+m_{N})^{-1}( ^{}}+(m_{N},))^{N  K},\]

where \(}(f(_{1}),,f(_{K}))=(, ^{Q})^{m K}\). During training, the transformer learns to approximate \(_{:,k}\) by \(_{h=1}^{H}w_{h,k}(^{}_{k}_{k})\) for each \(k[K]\).

To further elaborate, we take a closer look at the special case when the labels do not contain any noise, i.e., \(=0\), and \(N m\). In this case, \(\) becomes \(^{}}\), and given any prompt \(P=P_{}\), the coefficient vector \(\) could be uniquely determined from the provided token-label pairs in the prompt. It is straightforward to verify that the label of each token \(_{k}\) could be represented by the inner product of the given label vector \(\) and the \(k\)-th column of \(^{}}\), i.e.,

\[y_{k}=,^{}}_{:,k}.\] (26)

Comparing the above equation with (8), it can be seen that in order to gain the in-context ability, the transformer needs to learn an approximation of \(^{}}_{:,k}\) by \(_{h=1}^{H}w_{h,k}(^{}_{h}_{k})\) for each \(k[K]\).

More generally, in the proof of Theorem 2, we show that

\[}_{k}^{}=,_{:,k},\] (27)

comparing which with (8) suggests that a small training error implies that \(_{h=1}^{H}w_{h,k}(^{}_{h}_{k})\) is close to \(_{:,k}\). In fact, this is the necessary and sufficient condition for the training loss to be small. A rigorous argument is provided in Lemma 5.

The necessity and trade-offs of multi-head attention mechanism.Multi-head attention mechanism is essential in our setting. In fact, it is generally impossible to train a shallow transformer with only one attention head to succeed in the ICL task considered in our paper. This is because, as we have discussed above, the key for the transformer is to approximate \(_{:,k}\) by \(_{h=1}^{H}w_{h,k}(^{}_{h}_{k})\) for each \(k[K]\). If \(H=1\), the transformer could not approximate each \(_{:,k}\) by \(w_{1,k}(^{}_{1}_{k})\) in general since the entries of the latter vector are either all positive or all negative. In addition, Proposition 1 indicates that when \(H N\), the weights of the transformer with a simple initialization method satisfy our desired property that is crucial to guarantee the fast linear convergence. However, (18) implies that we should not set \(H\) to be too large, since larger \(H\) yields slower convergence rate.

## 4 Conclusion

We analyze the training dynamics of a one-layer transformer with multi-head softmax attention trained by gradient descent to solve complex non-linear regression tasks using partially labeled prompts. In this setting, the labels contain Gaussian noise, and each prompt may include only a few examples, which are insufficient to determine the underlying template. Our work overcomes several restrictive assumptions made in previous studies and proves that the training loss converges linearly to its minimum value. Furthermore, we analyze the transformer's strategy for addressing the issue of underdetermination during inference and evaluate its performance by comparing it with the best possible strategy. Our study provides the first analysis of how transformers can acquire contextual (template) information to generalize to unseen examples when prompts contain a limited number of query-answer pairs.