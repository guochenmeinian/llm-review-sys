# Robust low-rank training via approximate orthonormal constraints

Dayana Savostianova

Gran Sasso Science Institute

67100 L'Aquila (Italy)

dayana.savostianova@gssi.it

&Emanuele Zangrando

Gran Sasso Science Institute

67100 L'Aquila (Italy)

emanuele.zangrando@gssi.it

Gianluca Ceruti

University of Innsbruck

6020 Innsbruck (Austria)

gianluca.ceruti@uibk.ac.at

&Francesco Tudisco

Gran Sasso Science Institute

67100 L'Aquila (Italy)

francesco.tudisco@gssi.it

###### Abstract

With the growth of model and data sizes, a broad effort has been made to design pruning techniques that reduce the resource demand of deep learning pipelines, while retaining model performance. In order to reduce both inference and training costs, a prominent line of work uses low-rank matrix factorizations to represent the network weights. Although able to retain accuracy, we observe that low-rank methods tend to compromise model robustness against adversarial perturbations. By modeling robustness in terms of the condition number of the neural network, we argue that this loss of robustness is due to the exploding singular values of the low-rank weight matrices. Thus, we introduce a robust low-rank training algorithm that maintains the network's weights on the low-rank matrix manifold while simultaneously enforcing approximate orthonormal constraints. The resulting model reduces both training and inference costs while ensuring well-conditioning and thus better adversarial robustness, without compromising model accuracy. This is shown by extensive numerical evidence and by our main approximation theorem that shows the computed robust low-rank network well-approximates the ideal full model, provided a highly performing low-rank sub-network exists.

## 1 Introduction

Deep learning and neural networks have achieved great success in a variety of applications in computer vision, signal processing, and scientific computing, to name a few. However, their robustness with respect to perturbations of the input data may considerably impact security and trustworthiness and poses a major drawback to their real-world application. Moreover, the memory and computational requirements for both training and inferring phases render them impractical in application settings with limited resources. While a broad literature on pruning methods and adversarial robustness has been developed to address these two issues in isolation, much less has been done to design neural networks that are both energy-saving and robust. Actually, in many approaches the two problems seem to compete against each other as most adversarial robustness improving-techniques require even larger networks  or computationally more demanding loss functions, and thus more expensive training phases .

The limited work available so far on robust pruned networks is mostly focused on reducing memory and computational costs of the inference phase, while retaining adversarial robustness . However, the inference phase amounts to only a very limited fraction of the cost of thewhole deep learning pipeline, which is instead largely dominated by the training phase. Reducing both inference and training costs is a challenging but desirable goal, especially in view of a more accessible AI and its effective use on limited-resource and limited-connectivity devices such as drones or satellites.

Some of the most effective techniques for the reduction of training costs so far have been based on low-rank weights parametrizations [29; 55; 71]. These methods exploit the intrinsic low-rank structure of parameter matrices and large data matrices in general [17; 49; 59; 69]. Thus, assuming a low-rank structure for the neural network's weights \(W=USV^{}\), the resulting training procedures only use the small individual factors \(U,S,V\). This results in a training cost that scales linearly with the number of neurons, as opposed to a quadratic scaling required by training full-rank weights. Despite significantly reducing training parameters, these methods achieve accuracy comparable with the original full networks. However, their robustness with respect to adversarial perturbations has been largely unexplored so far.

#### Contributions

In this paper, we observe that the adversarial robustness of low-rank networks may actually deteriorate with respect to the full baseline. By modeling the robustness of the network in terms of the neural network's condition number, we argue that this loss of robustness is due to the exploding condition number of the low-rank weight matrices, whose singular values grow very large in order to match the baseline accuracy and to compensate for the lack of parameters. Thus, to mitigate this growing instability, we design an algorithm that trains the network using only the low-rank factors \(U,S,V\) while simultaneously ensuring the condition number of the network remains small. To this end, we interpret the loss optimization problem as a continuous-time gradient flow and use techniques from geometric integration theory on manifolds [12; 31; 55; 70] to derive three separate projected gradient flows for \(U,S,V\), individually, which ensure the condition number of the network remains bounded to a desired tolerance \(1+\), throughout the epochs. For a fixed small constant \(>0\), this is done by bounding the singular values of the small rank matrices within a narrow band \([s-,s+]\) around a value \(s\), chosen to best approximate the original singular values.

We provide several experimental evaluations on different architectures and datasets, where the robust low-rank networks are compared against a variety of baselines. The results show that the proposed technique allows us to compute from scratch low-rank weights with bounded singular values, significantly reducing the memory demand and computational cost of training while at the same time retaining or improving both the accuracy and the robust accuracy of the original model. On top of the experimental evidence, we provide a key approximation theorem that shows that if a high-performing low-rank network with bounded singular values exists, then our algorithm computes it up to a first-order approximation error.

This paper focuses on feed-forward neural networks. However, our techniques and analysis apply straightforwardly to convolutional filters reshaped in matrix form, as done in e.g. [29; 55; 71]. Other ways exist to promote orthogonality of convolutional filters, e.g. [60; 65; 77], which we do not consider in this work.

## 2 Related work

Neural networks' robustness against adversarial perturbations has been extensively studied in the machine learning community. It is well-known that the adversarial robustness of a neural network is closely related to its Lipschitz continuity [13; 23; 62; 68], see also Section 3. Accordingly, training neural networks with bounded Lipschitz constant is a widely employed strategy to address the problem. A variety of works studied Lipschitz architectures [37; 60; 65; 68], and a number of certified robustness guarantees have been proposed [23; 51; 61]. While scaling each layer to impose 1-Lipschitz constraints is a possibility, this approach may lead to vanishing gradients and it is known that a more effective way to reduce the Lipschitz constant and increase robustness is obtained by promoting orthogonality on each layer [5; 13]. On top of robustness, small Lipschitz constants and orthogonal layers are known to lead to improved generalization bounds [11; 45] and more interpretable gradients . Orthogonality was also shown to improve signal propagation in (very) deep networks [52; 74].

A variety of methods to integrate orthogonal constraints in deep neural networks have been developed over the years. Notable example approaches include methods based on regularization and landing [1; 13], cheap parametrizations of the orthogonal group [6; 38; 39; 48; 50], Riemannian and projected gradient descent schemes [2; 3; 10].

In parallel to the development of methods to promote orthogonality, an active line of research has grown to develop effective training strategies to enforce low-rank weights. Unlike sparsity-promoting pruning strategies that primarily aim at reducing the parameters required for inference [8; 21; 22; 30; 43], low-rank neural network models are designed to train directly on the low-parametric manifold of low-rank matrices and are particularly effective to reduce the number of parameters required by both inference and training phases. Similar to orthogonal training, methods for low-rank training include methods based on regularization [26; 29], as well as methods based on efficient parametrizations of the low-rank manifold using the SVD, randomized tensor dropout or the polar decomposition [32; 71; 75], and Riemannian optimization-based training models [55; 57].

By combining low-rank training with approximate orthogonal constraints, in this work we propose a strategy that simultaneously enforces robustness while only requiring a reduced percentage of the network's parameters during training. The method is based on a gradient flow differential formulation of the training problem, and the use of geometric integration theory to derive the governing equations of the low-rank factors. With this formulation, we are able to reduce the sensitivity of the network during training at almost no cost, yielding well-conditioned low-rank neural networks. Our experimental findings are supported by an approximation theorem that shows that, if the ideal full network can be approximated by a low-rank one, then our method computes a good approximation. This is well-aligned with recent work that shows the existence of high-performing low-rank nets in e.g. deep linear models [7; 17; 25; 49]. Moreover, as orthogonality helps in training really deep networks, low-rank orthogonal models may be used to mitigate the effect of increased effective depth when training low-rank networks .

## 3 The condition number of a neural network

The adversarial robustness of a neural network model \(f\) can be measured by the worst-case sensitivity of \(f\) with respect to small perturbations of the input data \(x\). In an absolute sense, this boils down to measuring the best global and local Lipschitz constant of \(f\) with respect to suitable distances, as discussed in a variety of papers [13; 15; 23; 62]. However, as the model and the data may assume arbitrary large and arbitrary small values in general, a relative measure of the sensitivity of \(f\) may be more informative. In other words, if we assume a perturbation \(\) of small size as compared to \(x\), we would like to quantify the largest relative change in \(f(x+)\), as compared to \(f(x)\). This is a well-known problem of conditioning, as we review next, and naturally leads to the concept of condition number of a neural network.

In the linear setting, the condition number of a matrix is a widely adopted relative measure of the worst-case sensitivity of linear problems with respect to noise in the data. For a matrix \(A\) and the matrix operator norm \(\|A\|=_{x 0}\|Ax\|/\|x\|\) the condition number of \(A\) is defined as \((A)=\|A\|\|A^{+}\|\), where \(A^{+}\) denotes the pseudo-inverse of \(A\). Note that it is immediate to verify that \((A) 1\). Now, if for example \(u\) and \(u_{}\) are the solutions to the linear system \(Au=b\), when \(A\) and \(b\) are exact data or when they are perturbed with noise \(_{A}\), \(_{b}\) of relative norm \(\|_{A}\|/\|A\|\) and \(\|_{b}\|/\|b\|\), respectively, then the following relative error bound holds

\[\|}{\|u\|}(A)\,\,.\]

Thus, small perturbations in the data \(A,b\) imply small alterations in the solution if and only if \(A\) is well conditioned, i.e. \((A)\) is close to one.

As in the linear case, it is possible to define the concept of condition number for general functions \(f\), [24; 53]. Let us start by defining the relative error ratio of a function \(f:^{d}^{m}\) in the point \(x\):

\[R(f,x;)=.\] (1)

In order to take into account the worst-case scenario, the _local_ condition number of \(f\) at \(x\) is defined by taking the sup of (1) over all perturbations of relative size \(\), i.e. such that \(\|\|\,\|x\|\), in the limit of small \(\). Namely, \((f;x)=_{ 0}_{ 0:\| \|\|x\|}R(f,x;)\). This quantity is a local measure of the "infinitesimal" conditioning of \(f\) around the point \(x\). In fact, a direct computation reveals that

\[(f;x)\, \,,\] (2)

as long as \(\|\|\,\|x\|\). Thus, \((f;x)\) provides a form of relative local Lipschitz constant for \(f\) which in particular shows that, if \(\|\|/\|x\|\) is smaller than \((f;x)^{-1}\), we expect limited change in \(f\) when \(x\) is perturbed with \(\). A similar conclusion is obtained using an absolute local Lipschitz constant in e.g. . Similarly to the absolute case, a global relative Lipschitz constant can be obtained by looking at the worst-case over \(x\), setting \((f)=_{x}(f;x)\). Clearly, the same bound (2) holds for \((f)\). Note that this effectively generalizes the linear case, as when \(f(x)=Ax\) we have \((f)=(f,x)=(A)\).

When \(f\) is a neural network, \((f)\) is a function of the network's weights and robustness may be enforced by reducing \((f)\) while training. In fact, \((f)\) is the relative equivalent of the network's Lipschitz constant and thus standard Lipschitz-based robustness certificates [23; 40; 68] can be recast in terms of \((f)\). However, for general functions \(f\) and general norms \(\|\|\), \((f)\) may be (very) expensive to compute, it may be non-differentiable, and \((f)>1\) can hold . Fortunately, for feed-forward neural networks, it holds (proof and additional details moved to Appendix B in the supplementary material)

**Proposition 1**.: _Let \(\) be the input space and let \(f(x)=z_{L+1}\) be a network with \(L\) linear layers \(z_{i+1}=_{i}(W_{i}z_{i})\), \(i=1,,L\). Then,_

\[(f)=_{x\{0\}}(f;x)_{i=1}^{L}_{x_{i}\{0\}} (_{i};x)_{i=1}^{L}(W_{i})\,.\]

_In particular, for typical \(_{i}\) and typical choices of \(_{i}\), including \(_{i}\{,\,,\,,\,, \,,\,\}\), we have_

\[_{x_{i}\{0\}}(_{i};x)  C<+\]

_for a positive constant \(C>0\) that depends only on the activation function \(_{i}\)._

Note that for entrywise nonlinearities \(\), the condition number \((;x)\) can be computed straightforwardly. In fact, when \(\) is Lipschitz, the problem can be reduced to a one-dimensional function, and it follows directly from its definition that (see also )

\[(f;x)=_{_{x}(x)}|_{x}||x|| (x)|^{-1}, x\]

where \((x)\) denotes Clarke's generalized gradient  of \(\) at the point \(x\). Thus, for example, if \(\) is _LeakyRelu_ with slope \(\), we have \(()=1\); if \(\) is the _logistic sigmoid_\((1+e^{-x})^{-1}\) and the feature space \(_{i}\) is such that \(_{i}=W_{i}_{i-1}\), then if \(|z_{i-1}| c_{i-1}\) entry-wise, we have \(|x_{i}| c_{i-1}_{uv}|W_{i}|_{uv}:=c_{i}\) and \(()_{x-c_{i}}|x|e^{-x}(1+e^{-x})^{-1} \{c_{i},1/e\}\).

From Proposition 1 we see that when \(f\) is a feed-forward network, to reduce the condition number of \(f\) it is enough to reduce the conditioning of all its weights. When \(\|\|=\|\|_{2}\) is the Euclidean \(L^{2}\) norm, we have \(_{2}(W)=s_{}(W)/s_{}(W)\), the ratio between the largest and the smallest singular value of \(W\). This implies that orthogonal weight matrices, for example, are optimally conditioned with respect to the \(L^{2}\) metric. Thus, a notable and well-known consequence of Proposition 1 is that imposing orthogonality constraints on \(W\) improves the robustness of the network [13; 27; 38; 50].

While orthogonal constraints are widely studied in the literature, orthogonal matrices are not the only optimally conditioned ones. In fact, \(_{2}(W)=1\) for any \(W\) with constant singular values. In the next section, we will use this observation to design a low-rank and low-cost algorithm that trains well-conditioned networks by ensuring \(_{2}(W) 1+\), for all layers \(W\) and a desired tolerance \(>0\).

## 4 Robust low-rank training

### Instability of low-rank networks

Low-rank methods are popular strategies to reduce the memory storage and the computational cost of both training and inference phases of deep learning models [29; 55; 71]. Leveraging the intrinsic low-rank structure of parameter matrices [7; 17; 49; 59], these methods train a subnetwork with weight matrices parametrized as \(W=USV^{}\), for "tall and skinny" matrices \(U,V\) with \(r\) columns, and a small \(r r\) matrix \(S\). Training low-rank weight matrices has proven to effectively reduce training parameters while retaining performance comparable to those of the full model. However, while a variety of contributions have analyzed and refined low-rank methods to match the full model's accuracy, the robust accuracy of low-rank models has been partially overlooked in the literature.

Here we observe that reducing the rank of the layer may actually deteriorate the network's robustness. We argue that this phenomenon is imputable to the exploding condition number of the network. In Figure 1 we plot the evolution of the condition number \(_{2}\) for the four internal layers of LeNet5 during training using different low-rank training strategies and compare them with the full model. While the condition number of the full model grows moderately with the iteration count, the condition number of low-rank layers blows up drastically. This singular value instability leads to poor robustness performance of the methods, as observed in the experimental evaluation of Section 5.

In the following, we design a low-rank training model that allows imposing simple yet effective training constraints, bounding the condition number of the trained network to a desired tolerance \(1+\), and improving the network robustness without affecting training nor inference costs.

### Low-rank gradient flow with bounded singular values

Let \(W^{n m}\) be the weight matrix of a linear layer within \(f\). For an integer \(r\{m,n\}\) let \(_{r}=\{W:(W)=r\}\) be the manifold of rank-\(r\) matrices which we parametrize as

\[_{r}=USV^{}:U^{n r},V^ {m r},\;S^{r r}}.\]

Obviously, the singular values of \(W=USV^{}_{r}\) coincide the singular values of \(S\). For \(s,\) such that \(0<<s\), define \(_{s}()\) as the set of matrices with singular values in the interval \([s-,s+]\). Note that \(_{s}(0)\) is a Riemannian manifold obtained essentially by an \(s\) scaling of the standard Stiefel manifold (the manifold of matrices with orthonormal columns) and any \(A_{s}(0)\) is optimally conditioned, i.e. \(_{2}(A)=1\). Thus, \(\) can be interpreted as an approximation parameter that controls how close \(_{s}()\) is to the "optimal" manifold \(_{s}(0)\). To enhance the network robustness, in the following we will constrain the parameter weight matrix \(S\) to \(_{s}()\). With this constraint, we get \(_{2}(W)(s-)^{-1}(s+)=1+\), with \(=2(s-)^{-1}\), so that the tolerance \(\) on the network's conditioning can be tuned by suitably choosing the approximation parameter \(\).

Given the loss function \(\), we are interested in the constrained optimization problem

\[ W=USV^{}_{r}S_{s}(),W\,.\] (3)

To approach (3), we use standard arguments from geometric integration theory [31; 70] to design a training scheme that updates only the factors \(U,S,V\) and the gradient of \(\) with respect to \(U,S,V\), without ever forming the full weights nor the full gradients. To this end, following , we first recast the optimization of \(\) with respect to each layer \(W\) as a continuous-time gradient flow

\[(t)=-_{W}(W(t)),\] (4)

where "dot" denotes the time derivative and where we write \(\) as a function of \(W\) only, for brevity. Along the solution of the differential equation above, the loss decreases and a stationary point is

Figure 1: Evolution of layersâ€™ condition numbers during training for LeNet5 on MNIST. From left to right: standard full-rank baseline model;  vanilla low-rank training;  dynamical low-rank training based on gradient flow;  low-rank training through regularization. All low-rank training strategies are set to \(80\%\) compression ratio (percentage of removed parameters with respect to the full baseline model).

approached as \(t\). Now, if we assume \(W_{r}\), then \( T_{W}_{r}\), the tangent space of \(_{r}\) at the point \(W\). Thus, to ensure the whole trajectory \(W(t)_{r}\), we can consider the projected gradient flow \((t)=-P_{W(t)}_{W}(W(t))\), where \(P_{W}\) denotes the orthogonal projection (in the ambient space of matrices) onto \(T_{W}_{r}\). Next, we notice that the projection \(P_{W}_{W}\) can be defined by imposing orthogonality with respect to any point \(Y T_{W}_{r}\), namely

\[ P_{W}_{W}-_{W},Y=0 Y T_{W}_{r}\]

where \(,\) is the Frobenius inner product. As discussed in e.g. , the above equations combined with the well-known representation of \(T_{W}_{r}\) yield a system of three gradient flow equations for the individual factors

\[=-G_{1}(U),&G_{1}(U)=P_{U}^{}_{U}( USV^{})(SS^{})^{-1}\\ =-G_{2}(V),&G_{2}(V)=P_{V}^{}_{V}(USV^{})(S ^{}S)^{-}\\ =-G_{3}(S),&G_{3}(S)=_{S}(USV^{})\] (5)

where \(P_{U}^{}=(I-UU^{})\) and \(P_{V}^{}=(I-VV^{})\) are the projection operators onto the space orthogonal to the span of \(U\) and \(V\), respectively.

Based on the system of gradient flows above, we propose a training scheme that at each iteration and for each layer parametrized by the tuple \(\{U,S,V\}\) proceeds as follows:

1. update \(U\) and \(V\) by numerically integrating the gradient flows \(=-G_{1}(U)\) and \(=-G_{2}(V)\)
2. project the resulting \(U,V\) onto the Stiefel manifold of matrices with \(r\) orthonormal columns
3. update the \(r r\) weight \(S\) by integrating \(=-G_{3}(S)\)
4. for a fixed robustness tolerance \(\), project the computed \(S\) onto \(_{s}()\), choosing \(s\) and \(\) so that * \(s\) is the best constant approximation to \(S^{}S\), i.e. \(s=*{argmin}_{}\|S^{}S-^{2}I\|_{F}\) * \(\) is such that the \(_{2}\) of the projection of \(S\) does not exceed \(1+\)

Note that the coefficients \(s\), \(\) at point \(4\) can be obtained explicitly by setting \(s=^{r}s_{j}(S)^{2}/r}\), the second moment of the singular values \(s_{j}(S)\) of \(S\), and \(= s/(2+)\). Note also that, in the differential equations for \(U,S,V\) in (5), the four steps above can be implemented in parallel for each of the three variables. The detailed pseudocode of the training scheme is presented in Algorithm 1. We conclude with several remarks about its implementation.

``` Input: Chosen compression rate, i.e. for each layer \(W\) choose a rank \(r\);  Initial layers' weights parametrized as \(W=USV^{}\), with \(S r r\);  Second singular value moment of \(S\), \(s=s_{k}(S)^{2}/r}\)  Conditioning tolerance \(>0\)
1for each iteration and each layer do (each block in parallel)
2\(U\) one optimization step with gradient \(G_{1}\) and initial point \(U\)
3\(U\) project \(U\) on Stiefel manifold with \(r\) orthonormal columns
4\(V\) one optimization step with gradient \(G_{2}\) and initial point \(V\)
5\(S\) one optimization step with gradient \(G_{3}\) and initial point \(S\)
6\(ss_{k}(S)^{2}/r}\), squareroot of second moment of the singular values of \(S\)
7\( s/(2+)\)
8\(S\) project \(S\) onto \(_{s}()\) ```

**Algorithm 1**Pseudocode of robust well-Conditioned Low-Rank (**CondLR** ) training scheme

#### Remarks, implementation details, and limitations

Each step of Algorithm 1 requires three optimization steps at lines 2, 4, 6. These steps can be implemented using standard first-order optimizers such as SGD with momentum or ADAM. Standard techniques can be used to project onto the Stiefel manifold at lines 3 and 5 of Algorithm 1, see e.g. . Here, we use the QR decomposition. As for the projection onto \(_{s}()\) at line 9, we compute the SVD of the small factor \(S\) and set to \(s+\) or \(s-\) the singular values that fall outside the interval \([s-,s+]\). Note that, when \(=0\), i.e. when we require perfect conditioning for the layer weight \(W=USV^{}\), then the SVD of \(S\) can be replaced by a QR step or any other Stiefel manifold projection. Indeed, we can equivalently set \(s=(S^{}S)/r}\), and then project onto \(_{s}(0)\) by rescaling by a factor \(s\) the projection of \(S\) onto the Stiefel manifold. In this case, the system (5) further simplifies, as we can replace \((SS^{})^{-1}\) and \((S^{}S)^{-}\) with the scalar \(1/s^{2}\).

Overall, the compressed low-rank network has \(r(n+m+r)\) parameters per each layer, where \(n\) and \(m\) are the number of input and output neurons. Thus, choosing \(r\) so that \(1-r(n+m+r)/(nm)=\) can yield a desired compression rate \(0<<1\) on the number of network parameters, i.e. the number of parameters one eliminates with respect to the full baseline. For example, in our experiments we will choose \(r\) so that \(=0.5\) or \(=0.8\).

**Computational complexity.** Each pass of Alg.1 is done against a batch \(x_{}\). In order to obtain minimal computational costs for each step in the algorithm, we evaluate \(USV^{}x_{}\) sequentially: first \(v=V^{}x_{}\), then \(u=Sv\), and finally \(Uu\). Assuming the size of the batch is negligible with respect to \(n\) and \(m\), the cost of these steps is \(O(rm),O(r),O(rn)\), respectively. Adding the bias term and evaluating the activation function requires \(O(n)\) operations. Hence, overall we have a cost per layer of \(O(r(n+m+1))\). Taping the forward evaluation to compute the gradient with respect to \(U,S,V\) does not affect the asymptotic costs. The QR decompositions used for \(U\) and \(V\) require \(O(r^{2}n)\) and \(O(r^{2}m)\) operations respectively, \(O(r^{2}(n+m))\) overall. Finally, computing the SVD in the projection step for \(S\) requires a worst-case cost of \(O(r^{3})\). Hence the overall cost per layer is \(O(r(1+r)(n+m)+r^{3})\) as opposed to the dense network training, which requires \(O(nm)\) operations per layer. If \(r n,m\) then the low-rank method is cheaper than the full baseline. For example, if \(n=m\), this happens provided \(r<\).

**Limitations.** As the rank parameter \(r\) has to be chosen a-priori for each layer of the network, a limitation of the proposed approach is the potential need for fine-tuning such parameter, even though the proposed analysis in Table 1 shows competitive performance for both \(50\%\) and \(80\%\) compression rates. Also, if the layer size \(n m\) is not large enough, the compression ratio \(=1-r(n+m+r)/(nm)\) might be limited. Thus the method works well only for wide-enough networks (\(n,m r\), so that \(>0\)). Finally, a standard way to obtain better adversarial performance would be to combine the proposed conditioning-based robustness with adversarial training strategies [16; 63; 73]. However, the cost of producing adversarial examples during training is not negligible, especially when based on multi-step attacks, and thus the way to incorporate adversarial training without affecting the benefits obtained with low-rank compression is not straightforward.

### Approximation guarantees

Optimization methods over the manifold of low-rank matrices are well-known to be affected by the stiff intrinsic geometry of the constraint manifold which has very high curvature around points where \(W_{r}\) is almost singular [4; 31; 70]. This implies that even very small changes in \(W\) may yield very different tangent spaces, and thus different training trajectories, as shown by the result below:

**Lemma 1** (Curvature bound, Lemma 4.2 ).: _For \(W_{r}\) let \(s_{}(W)>0\) be its smallest singular value. For any \(W^{}_{r}\) arbitrarily close to \(W\) and any matrix \(B\), it holds_

\[\|P_{W}B-P_{W^{}}B\|_{F} C\,s_{}(W)^{-1}\|W-W^{}\|_{F}\,,\]

_where \(C>0\) depends only on \(B\)._

In our gradient flow terminology, this phenomenon is shown by the presence of the matrix inversion in (5). While this is often an issue that may dramatically affect the performance of low-rank optimizers (see also Section 5), the proposed regularization step that enforces bounded singular values allows us to move along paths that avoid stiffness points. Using this observation, here we provide a bound on the quality of the low-rank neural network computed via Algorithm 1, provided there exists an optimal trajectory leading to an approximately low-rank network. We emphasize that this assumption is well-aligned with recent work showing the existence of high-performing low-rank nets in e.g. deep linear models [7; 17; 25; 49].

Assume the training is performed via gradient descent with learning rate \(>0\), and let \(W(t)\) be the full gradient flow (4). Further, assume that for \(t[0,]\) and a given \(>0\), for each layer there exists\(E(t)\) and \((t)_{r}_{s}()\) such that

\[W(t)=(t)+E(t)\,,\]

where \(s\) is the second moment of the singular values of \(W(t)\) and \(E(t)\) is a perturbation that has bounded variation in time, namely \(\|(t)\|\). In other words, we assume there exists a training trajectory that leads to an approximately low-rank weight matrix \(W(t)\) with almost constant singular values. Because the value \(s\) is bounded by construction, the parameter-dependent matrix \((t)\) possesses singular values exhibiting moderate lower bound. Thus, \(W(t)\) is far from the stiffness region of (5) and we obtain the following bound, based on  (proof moved to Appendix C in the supplementary material)

**Theorem 1**.: _Let \(U_{k}S_{k}V_{k}^{}\) be a solution to (5) computed with \(k\) steps of Algorithm 1. Assume that \(\) The low-rank initialization \(U_{0}S_{0}V_{0}^{}\) coincides with the low-rank approximation \((0)\). \(\) The norm of the full gradient is bounded, i.e., \(\|_{W}(W(t))\|\). \(\) The learning rate is bounded as \(}\). Then, assuming no numerical errors, the following error bound holds_

\[\|U_{k}S_{k}V_{k}^{}-W( k)\| 3\,.\]

Note that if \(f\) is smooth enough (e.g. Lipschitz) then by the previous theorem we directly obtain an equivalent bound for the functional distance \(\|f(U_{k}S_{k}V_{k}^{})-f(W( k))\|\).

## 5 Experiments

We illustrate the performance of Algorithm 1 on a variety of test cases. All the experiments can be reproduced with the code in PyTorch available at https://github.com/COMPiELLab/CondLR. In order to assess the combined compression and robustness performance of the proposed method, we compare it against both full and low-rank baselines.

For all models, we compute natural accuracy and robust accuracy. Let \(\{(x_{i},y_{i})\}_{i=1,,n}\) be the set of test images and the corresponding labels and let \(f\) be the neural network model, with output \(f(x)\) on the input \(x\). We quantify the test set robust accuracy as:

\[()=_{i=1}^{n}_{\{ y_{i}\}}(f(x_{i}+_{i}))\]

where \(=(_{i})_{i=1,,n}\) are the adversarial perturbation associated to each sample. Notice that, in the unperturbed case with \(\|_{i}\|=0\), the definition of robust accuracy exactly coincides with the definition of test accuracy. In our experiments, adversarial perturbations are produced by both the fast gradient sign method (FGSM)  and the projected gradient descent attack (PGD) , with \(\|_{i}\|_{}=\), and \(\) controls perturbation strength. As images in our set-up have input entries in \(\), the perturbed input is then clamped to that interval. Note that, for the same reason, the value of \(\) controls in our case the relative size of the perturbation.

**Datasets.** We consider MNIST, CIFAR10, and CIFAR100  datasets for evaluation purposes. The first contains 60,000 training images, the second one contains 50,000 training images, while the third one contains 50,000 training images. All the datasets have 10,000 test images, first two have 10 classes and last one has 100 classes. No data-augmentation is performed.

**Models.** We use LeNet5  for MNIST dataset, VGG16  and WideResnet (WRN16-4)  for CIFAR10 and CIFAR100. The general architecture for all the used networks is preserved across the models, while the weight-storing structures and optimization frameworks differ.

**Methods.** Our baseline network is the one done with the standard implementation. Cayley SGD  and Projected SGD  are Riemannian optimization-based methods that train the network weights over the Stiefel manifold of matrices with orthonormal columns. Thus, both methods ensure \(_{2}(W)=1\) for all layers. The former uses an iterative estimation of the Cayley transform, while the latter uses QR-based projection to retract the Riemannian gradient onto the Stiefel manifold. Both methods have no compression and use full-weight matrices. DLRT, SVD prune, and Vanilla are low-rank methods that ensure compression of the model parameters during training. DLRT  is based on a low-rank gradient flow model similar to the proposed Algorithm 1. SVD prune  is based on a regularized loss with a low-rank-promoting penalty term. This approach was designed to 

[MISSING_PAGE_FAIL:9]

algorithm able to mitigate this phenomenon in a computationally affordable way, allowing us to train directly on the manifold of matrices of a fixed rank while controlling the condition number.

    & &  &  & c.r. \\  Rel. perturbation \(\) & 0.0 & 0.02 & 0.04 & 0.06 & 0.0 & 0.002 & 0.004 & 0.006 & (\%) \\    } & Baseline & 0.9872 & 0.9793 & 0.9655 & 0.9407 & 0.9104 & **0.752** & 0.5822 & 0.4592 & 0 \\  & Cayley SGD & 0.9874 & 0.9804 & 0.9688 & 0.9486 & 0.8962 & 0.7446 & 0.5816 & 0.4529 & 0 \\  & Projected SGD & 0.9878 & 0.9807 & 0.968 & 0.9476 & 0.897 & 0.7455 & 0.5832 & 0.4574 & 0 \\     } & \(=0\) & **0.9883** & 0.9825 & 0.9732 & 0.958 & 0.9099 & 0.7456 & 0.5711 & 0.4292 & 50 \\  & \(=0.1\) & 0.9877 & **0.9828** & **0.9763** & **0.9677** & 0.9093 & 0.7411 & 0.5985 & 0.4878 & 50 \\  & \(=0.5\) & 0.9867 & 0.9802 & 0.9724 & 0.9598 & 0.8997 & 0.7225 & **0.6019** & **0.5017** & 50 \\  & Stief & 0.986 & 0.9809 & 0.9721 & 0.9586 & **0.9138** & 0.7322 & 0.546 & 0.4054 & 50 \\    } & DLRT & 0.967 & 0.9573 & 0.939 & 0.9078 & 0.8425 & 0.599 & 0.441 & 0.3691 & 50 \\  & Vanilla & 0.9875 & 0.9773 & 0.9603 & 0.94 & 0.8997 & 0.6771 & 0.4886 & 0.3849 & 50 \\  & SVD prune & 0.9883 & 0.9793 & 0.9639 & 0.9414 & 0.8992 & 0.673 & 0.4777 & 0.3698 & 50 \\     } & \(=0.0\) & 0.9882 & 0.9801 & 0.9676 & 0.9452 & 0.9066 & 0.7263 & 0.541 & 0.4 & 80 \\  & \(=0.1\) & 0.9877 & 0.9795 & 0.966 & 0.9444 & 0.9048 & 0.7123 & 0.5262 & 0.4013 & 80 \\  & \(=0.5\) & 0.9858 & 0.9768 & 0.9613 & 0.9342 & 0.8933 & 0.6823 & 0.4854 & 0.3666 & 80 \\  & Stief & 0.9815 & 0.9729 & 0.9581 & 0.9399 & 0.9067 & 0.7184 & 0.5289 & 0.3861 & 80 \\    } & DLRT & 0.9649 & 0.9517 & 0.9281 & 0.8865 & 0.8092 & 0.5839 & 0.4178 & 0.3086 & 80 \\  & Vanilla & 0.9862 & 0.972 & 0.9464 & 0.9194 & 0.881 & 0.6424 & 0.4266 & 0.299 & 80 \\   & SVD prune & 0.9864 & 0.9737 & 0.9512 & 0.9281 & 0.8799 & 0.6357 & 0.4206 & 0.2927 & 80 \\   

Table 1: Method comparison results

    & Rel. perturbation \(\) & 0.0 & 0.0003 & 0.0006 & 0.001 & 0.0013 & 0.0016 & cr (\%) \\    } & Baseline, FGSM & 0.9129 & 0.885 & 0.8531 & 0.8056 & 0.7667 & **0.7263** & 0 \\  & \(=0.0\) & 0.9254 & 0.8958 & **0.865** & 0.8092 & 0.7669 & 0.7236 & 50 \\  & \(=0.1\) & **0.9271** & **0.8974** & 0.8612 & **0.8117** & **0.7697** & 0.7223 & 50 \\  & \(=0.0\) & 0.9106 & 0.8807 & 0.844 & 0.7874 & 0.7413 & 0.697 & 80 \\  & \(=0.1\) & 0.9146 & 0.8833 & 0.8497 & 0.8004 & 0.7568 & 0.7142 & 80 \\     } & Baseline, PGD10 & 0.9129 & 0.8898 & 0.8619 & 0.8188 & **0.7828** & **0.7435** & 0 \\  & \(=0.0\) & 0.9254 & 0.8997 & **0.8714** & **0.8241** & 0.7791 & 0.7375 & 50 \\  & \(=0.1\) & **0.9271** & **0.9018** & 0.8684 & 0.8233 & 0.782 & 0.7374 & 50 \\  & \(=0.0\) & 0.9106 & 0.8838 & 0.8512 & 0.8014 & 0.7565 & 0.7064 & 80 \\  & \(=0.1\) & 0.9146 & 0.8861 & 0.8582 & 0.813 & 0.7705 & 0.724 & 80 \\   

Table 2: WRN16-4 Cifar10

Figure 2: Evolution of loss, accuracy, and \(_{i}(W_{i})\) for Lenet5 on MNIST dataset, for ill-conditioned initial layers whose singular values are forced to decay exponentially with powers of two.