# The Clock and the Pizza: Two Stories in Mechanistic Explanation of Neural Networks

Ziqian Zhong*, Ziming Liu*, Max Tegmark, Jacob Andreas

Massachusetts Institute of Technology

{ziqianz, zmliu, tegmark, jda}@mit.edu

Equal contribution.Code is available at https://github.com/fjzzq2002/pizza.

###### Abstract

Do neural networks, trained on well-understood algorithmic tasks, reliably re-discover known algorithms for solving those tasks? Several recent studies, on tasks ranging from group arithmetic to in-context linear regression, have suggested that the answer is yes. Using modular addition as a prototypical problem, we show that algorithm discovery in neural networks is sometimes more complex. Small changes to model hyperparameters and initializations can induce discovery of qualitatively different algorithms from a fixed training set, and even parallel implementations of multiple such algorithms. Some networks trained to perform modular addition implement a familiar _Clock_ algorithm (previously described by Nanda et al. ); others implement a previously undescribed, less intuitive, but comprehensible procedure we term the _Pizza_ algorithm, or a variety of even more complex procedures. Our results show that even simple learning problems can admit a surprising diversity of solutions, motivating the development of new tools for characterizing the behavior of neural networks across their algorithmic phase space. 1

## 1 Introduction

Mechanistically understanding deep network models--reverse-engineering their learned algorithms and representation schemes--remains a major challenge across problem domains. Several recent studies  have exhibited specific examples of models apparently re-discovering interpretable (and in some cases familiar) solutions to tasks like curve detection, sequence copying and modular arithmetic. Are these models the exception or the rule? Under what conditions do neural network models discover familiar algorithmic solutions to algorithmic tasks?

In this paper, we focus specifically on the problem of learning modular addition, training networks to compute sums like \(8+6=2\). Modular arithmetic can be implemented with a simple geometric solution, familiar to anyone who has learned to read a clock: every integer is represented as an angle, input angles are added together, and the resulting angle evaluated to obtain a modular sum (Figure 1, left). Nanda et al.  show that specific neural network architectures, when trained to perform modular addition, implement this _Clock_ algorithm. In this work, we show that the _Clock_ algorithm is only one part of a more complicated picture of algorithm learning in deep networks. In particular, networks structurally similar to the ones trained by Nanda et al. preferentially implement a qualitatively different approach to modular arithmetic, which we term the _Pizza_ algorithm (Figure 1, right), and sometimes even more complex solutions. Models exhibit sharp _algorithmic phase transitions_ between the _Clock_ and _Pizza_ algorithms as their width and attention strength very, and often implement multiple, imperfect copies of the _Pizza_ algorithm in parallel.

Our results highlight the complexity of mechanistic description in even models trained to perform simple tasks. They point to characterization of algorithmic phase spaces, not just single algorithmic solutions, as an important goal in algorithm-level interpretability.

**Organization** In Section 2, we review the _Clock_ algorithm  and show empirical evidence of deviation from it in models trained to perform modular addition. In Section 3, we show that these deviations can be explained by an alternative _Pizza_ algorithm. In Section 4, we define additional metrics to distinguish between these algorithms, and detect phase transitions between these algorithms (and others _Non-circular_ algorithms) when architectures and hyperparameters are varied. We discuss the relationship between these findings and other work on model interpretation in Section 5, and conclude in Section 6.

## 2 Modular Arithmetic and the _Clock_ Algorithm

**Setup** We train neural networks to perform modular addition \(a+b=c\ (\ p)\), where \(a,b,c=0,1,,p-1\). We use \(p=59\) throughout the paper. In these networks, every integer \(t\) has an associated embedding vector \(_{t}^{d}\). Networks take as input embeddings \([_{a},_{b}]^{2d}\) and predict a categorical output \(c\). Both embeddings and network parameters are learned. In preliminary experiments, we train two different network architectures on the modular arithmetic task, which we refer to as: Model A and Model B. **Model A** is a one-layer ReLU transformer  with constant attention, while **Model B** is a standard one-layer ReLU transformer (see Appendix F.1 for details). As attention is not involved in Model A, it can also be understood as a ReLU MLP (Appendix G).

### Review of the _Clock_ Algorithm

As in past work, we find that after training both Model A and Model B, embeddings (\(_{a},_{b}\) in Figure 1) usually describe a circle  in the plane spanned by the first two principal components of the embedding matrix. Formally, \(_{a}[(w_{k}a),(w_{k}a)]\) where \(w_{k}=2 k/p\), \(k\) is an integer in \([1,p-1]\). Nanda et al.  discovered a circuit that uses these circular embeddings to implement an interpretable algorithm for modular arithmetic, which we call the _Clock_ algorithm.

  Algorithm & Learned Embeddings & Gradient Symmetry & Required Non-linearity \\  Clock & Circle & No & Multiplication \\ Pizza & Circle & Yes & Absolute value \\ Non-circular & Line, Lissajous-like curves, etc. & N/A & N/A \\  

Table 1: Different neural algorithms for modular addition

Figure 1: Illustration of the _Clock_ and the _Pizza_ Algorithm.

"If a meeting starts at 10, and lasts for 3 hours, then it will end at 1." This familiar fact is a description of a modular sum, \(10+3=1\), and the movement of a clock describes a simple algorithm for modular arithmetic: the numbers 1 through 12 are arranged on a circle in \(360^{}/12=30^{}\) increments, angles of \(10 30^{}\) and \(3 30^{}\) are added together, then this angle is evaluated to determine that it corresponds to \(1 30^{}\).

Remarkably, Nanda et al.  find that neural networks like our Model B implement this _Clock_ algorithm, visualized in Figure 1 (left): they represent tokens \(a\) and \(b\) as 2D vectors, and adding their polar angles using trigonometric identities. Concretely, the _Clock_ algorithm consists of three steps: In step 1, tokens \(a\) and \(b\) are embedded as \(_{a}=[(w_{k}a),(w_{k}a)]\) and \(_{b}=[(w_{k}b),(w_{k}b)]\), respectively, where \(w_{k}=2 k/p\) (an everyday clock has \(p=12\) and \(k=1\)). Then the polar angles of \(_{a}\) and \(_{b}\) are added (in step 2) and extracted (in step 3) via trigonometric identities. For each candidate output \(c\), we denote the logit \(Q_{abc}\); the predicted output is \(c^{*}=*{argmax}_{c}Q_{abc}\).

Crucial to this algorithm is the fact that the attention mechanism can be leveraged to perform multiplication. What happens in model variants when the attention mechanism is absent, as in Model A? We find two pieces of evidence of deviation from the _Clock_ algorithm in Model A.

### First Evidence for _Clock_ Violation: Gradient Symmetricity

Since the _Clock_ algorithm has logits:

\[Q_{abc}^{}=(_{a,x}_{b,x}-_{a,y} _{b,y})_{c,x}+(_{a,x}_{b,y}+_{a,y}_{b,x})_{c,y},\] (1)

(see Figure 1) the gradients of \(Q_{abc}\) generically lack permutation symmetry in argument order: \(_{_{a}}Q_{abc}_{_{b}}Q_{abc}\). Thus, if learned models exhibit permutation symmetry (\(_{_{a}}Q_{abc}=_{_{b}}Q_{abc}\)), they must be implementing some other algorithm.

We compute the 6 largest principal components of the input embedding vectors. We then compute the gradients of output logits (unnormalized log-probabilities from the model) with respect to the input embeddings. We then project them onto these 6 principal components (since the angles relevant to the _Clock_ and _Pizza_ algorithms are encoded in the first few principal components). These projections are shown in Figure 2. While Model B demonstrates asymmetry in general, Model A exhibits gradient symmetry.

### Second Evidence for _Clock_ Violation: Logit Patterns

Inspecting models' outputs, in addition to inputs, reveals further differences. For each input pair \((a,b)\), we compute the output logit assigned to the correct label \(a+b\). We visualize these _correct logits_ from Models A and B in Figure 3. Notice that the rows are indexed by \(a-b\) and the columns by \(a+b\). From Figure 3, we can see that the correct logits of Model A have a clear dependency on \(a-b\) in that within each row, the correct logits are roughly the same, while this pattern is not observed in Model B. This suggests that Models A and B are implementing different algorithms.

Figure 2: Gradients on first six principal components of input embeddings. \((a,b,c)\) in the title stands for taking gradients on the output logit \(c\) for input \((a,b)\). x and y axes represent the gradients for embeddings of the first and the second token. The dashed line \(y=x\) signals a symmetric gradient.

## 3 An Alternative Solution: the _Pizza_ Algorithm

How does Model A perform modular arithmetic? Whatever solution it implements must exhibit gradient symmetricity in Figure 2 and the output patterns in Figure 3. In this section, we describe a new algorithm for modular arithmetic, which we call the _Pizza_ algorithm, and then provide evidence that this is the procedure implemented by Model A.

### The _Pizza_ Algorithm

Unlike the _Clock_ algorithm, the _Pizza_ algorithm operates _inside_ the circle formed by embeddings (just as pepperoni are spread all over a pizza), instead of operating on the circumference of the circle. The basic idea is illustrated in Figure 1: given a fixed label \(c\), for _all_\((a,b)\) with \(a+b=c\), the points \(_{ab}=(_{a}+_{b})/2\) lie on a line though the origin of a 2D plane, and the points closer to this line than to the lines corresponding to any other \(c\) form two out of \(2p\) mirrored "pizza slices", as shown at the right of the figure. Thus, to perform modular arithmetic, a network can determine which slice pair the average of the two embedding vectors lies in. Concretely, the _Pizza_ algorithm also consists of three steps. Step 1 is the same as in the _Clock_ algorithm: the tokens \(a\) and \(b\) are embedded at \(_{a}=((w_{k}a),(w_{k}a))\) and \(_{b}=((w_{k}b),(w_{k}b))\), respectively. Step 2 and Step 3 are different from the _Clock_ algorithm. In Step 2.1, \(_{a}\) and \(_{b}\) are averaged to produce an embedding \(_{ab}\). In Step 2.2 and Step 3, the polar angle of \(_{ab}\) is (implicitly) computed by computing the logit \(Q_{abc}\) for any possible outputs \(c\). While one possibility of doing so is to take the absolute value of the dot product of \(_{ab}\) with \(((w_{k}c/2),(w_{k}c/2))\), it is not commonly observed in neural networks (and will result in a different logit pattern). Instead, Step 2.2 transforms \(_{ab}\) into a vector encoding \(|(w_{k}(a-b)/2)|((w_{k}(a+b)),(w_{k}(a+b)))\), which is then dotted with the output embedding \(U_{c}=((w_{k}c),(w_{k}c))\). Finally, the prediction is \(c^{*}=*{argmax}_{c}Q_{abc}\). See Appendix A and Appendix L for a more detailed analysis of a neural circuit that computes \(_{ab}\) in a real network.

The key difference between the two algorithms lies in what non-linear operations are required: _Clock_ requires multiplication of inputs in Step 2, while _Pizza_ requires only absolute value computation, which is easily implemented by the ReLU layers. If neural networks lack inductive biases toward implementing multiplication, they may be more likely to implement _Pizza_ rather than _Clock_, as we will verify in Section 4.

### First Evidence for _Pizza_: Logit Patterns

Both the _Clock_ and _Pizza_ algorithms compute logits \(Q_{abc}\) in Step 3, but they have different forms, shown in Figure 1. Specifically, \(Q_{abc}(Pizza)\) has an extra multiplicative factor \(|(w_{k}(a-b)/2)|\) compared to \(Q_{abc}()\). As a result, given \(c=a+b\), \(Q_{abc}(Pizza)\) is dependent on \(a-b\), but \(Q_{abc}()\) is not. The intuition for the dependence is that a sample is more likely to be classified correctly if \(_{ab}\) is longer. The norm of this vector depends on \(a-b\). As we observe in Figure 3, the logits in Model A indeed exhibit a strong dependence on \(a-b\).

Figure 3: Correct Logits of Model A & Model B. The correct logits of Model A (left) have a clear dependence on \(a-b\), while those of Model B (right) do not.

### Second Evidence for _Pizza_: Clearer Logit Patterns via Circle Isolation

To better understand the behavior of this algorithm, we replace the embedding matrix \(\) with a series of rank-2 approximations: using only the first and second principal components, or only the third and fourth, etc. For each such matrix, embeddings lie in a a two-dimensional subspace. For both Model A and Model B, we find that embeddings form a circle in this subspace (Figure 4 and Figure 5, bottom). We call this procedure _circle isolation_. Even after this drastic modification to the trained models' parameters, both Model A and Model B continue to behave in interpretable ways: a subset of predictions remain highly accurate, with this subset determined by the periodicity of the \(k\) of the isolated circle. As predicted by the _Pizza_ and _Clock_ algorithms described in Figure 1, Model A's accuracy drops to zero at specific values of \(a-b\), while Model B's accuracy is invariant in \(a-b\). Applying circle isolation to Model A on the two principal components (one circle) yields a model with \(32.8\%\) overall accuracy, while retaining the first six principal components (three circles) yields an overall accuracy of \(91.4\%\). See Appendix D for more discussion. By contrast, Model B achieves \(100\%\) when embeddings are truncated to the first six principal components. Circle isolation thus reveals an _error correction_ mechanism achieved via ensembling: when an algorithm (clock or pizza) exhibits systematic errors on subset of inputs, models can implement multiple algorithm variants in parallel to obtain more robust predictions.

Using these isolated embeddings, we may additionally calculate the isolated logits directly with formulas in Figure 1 and compare with the actual logits from Model A. Results are displayed in Table 2. We find that \(Q_{abc}(Pizza)\) explains substantially more variance than \(Q_{abc}()\).

**Why do we only analyze correct logits?** The logits from the _Pizza_ algorithm are given by \(Q_{abc}(Pizza)=|(w_{k}(a-b)/2)|(w_{k}(a+b-c))\). By contrast, the _Clock_ algorithm has logits \(Q_{abc}()=(w_{k}(a+b-c))\). In a word, \(Q_{abc}(Pizza)\) has an extra multiplicative factor \(|(w_{k}(a-b)/2)|\) compared to \(Q_{abc}()\). By constraining \(c=a+b\) (thus \((w_{k}(a+b-c))=1\)), the factor \(|(w_{k}(a-b)/2)|\) can be identified.

**(Unexpected) dependence of logits \(Q_{abc}()\) on \(a+b\)**: Although our analysis above expects logits \(Q_{abc}()\) not to depend on \(a-b\), they do not predict its dependence on \(a+b\). In Figure 5, we surprisingly find that \(Q_{abc}()\) is sensitive to this sum. Our conjecture is that Step 1 and Step 2 of the _Clock_ are implemented (almost) noiselessly, such that same-label samples collapse to the same point after Step 2. However, Step 3 (classification) is imperfect after circle isolation, resulting in fluctuations of logits. Inputs with common sums \(a+b\) produce the same logits.

Figure 4: Correct logits of Model A (_Pizza_) after circle isolation. The rightmost pizza is accompanying the third pizza (discussed in Section 3.4 and Appendix D). _Top:_ The logit pattern depends on \(a-b\). _Bottom:_ Embeddings for each circle.

### Third Evidence for _Pizza_: Accompanied & Accompanying Pizza

The Achilles' heel of the _Pizza_ algorithm is antipodal pairs. If two inputs \((a,b)\) happen to lie antipodally, then their middle point will lie at the origin, where the correct "pizza slice" is difficult to identify. For example in Figure 1 right, antipodal pairs are (1,7), (2,8), (3,9) etc., whose middle points all collapse to the origin, but their class labels are different. Models cannot distinguish between, and thus correctly classify, these pairs. Even for odd \(p\)'s where there are no strict antipodal pairs, approximately antipodal pairs are also more likely to be classified incorrectly than non-antipodal pairs.

Intriguingly, neural networks find a clever way to compensate for this failure mode. we find that pizzas usually come with "accompanying pizzas". An accompanied pizza and its accompanying pizza complement each other in the sense that near-antipodal pairs in the accompanied pizza become adjacent or close (i.e, very non-antipodal) in the accompanying pizza. If we denote the difference between adjacent numbers on the circle as \(\) and \(_{1}\), \(_{2}\) for accompanied and accompanying pizzas, respectively, then \(_{1}=2_{2}\). In the experiment, we found that pizzas #1/#2/#3 in Figure 4 all have accompanying pizzas, which we call pizzas #4/#5/#6 (see Appendix D for details). However, these accompanying pizzas do not play a significant role in final model predictions 2. We conjecture that training dynamics are as follows: (1) At initialization, pizzas #1/#2/#3 correspond to three different "lottery tickets" . (2) In early stages of training, to compensate the weaknesses (antipodal pairs) of pizzas #1/#2/#3, pizzas #4/#5/#6 are formed. (3) As training goes on (in the presence of weight decay), the neural network gets pruned. As a result, pizzas #4/#5/#6 are not significantly involved in prediction, although they continue to be visible in the embedding space.

 Circle & \(w_{k}\) & \(Q_{abc}()\) FVE & \(Q_{abc}()\) FVE \\  \#1 & \(2/59 17\) & 75.41\% & 99.18\% \\  \#2 & \(2/59 3\) & 75.62\% & 99.18\% \\  \#3 & \(2/59 44\) & 75.38\% & 99.28\% \\ 

Table 2: After isolating circles in the input embedding, fraction of variance explained (FVE) of **all** Model A’s output logits (\(59 59 59\) of them) by various formulas. Both model output logits and formula results’ are normalized to mean \(0\) variance \(1\) before taking FVE. \(w_{k}\)’s are calculated according to the visualization. For example, distance between \(0\) and \(1\) in Circle #1 is \(17\), so \(w_{k}=2/59 17\).

Figure 5: Correct logits of Model B (_Clock_) after circle isolation. _Top:_ The logit pattern depends on \(a+b\). _Bottom:_ Embeddings for each circle.

The Algorithmic Phase Space

In Section 3, we have demonstrated a typical _Clock_ (Model A) and a typical _Pizza_ (Model B). In this section, we study how architectures and hyperparameters govern the selection of these two algorithmic "phases". In Section 4.1, we propose quantitative metrics that can distinguish between _Pizza_ and _Clock_. In Section 4.2, we observe how these metrics behave with different architectures and hyperparameters, demonstrating sharp phase transitions. The results in this section focus _Clock_ and _Pizza_ models, but other algorithmic solutions to modular addition are also discovered, and explored in more detail in Appendix B.

### Metrics

We wish to study the distribution of _Pizza_ and _Clock_ algorithms statistically, which will require us to distinguish between two algorithms automatically. In order to do so, we formalize our observations in Section 2.2 and 2.3, arriving at two metrics: **gradient symmetricity** and **distance irrelevance**.

#### 4.1.1 Gradient Symmetricity

To measure the symmetricity of the gradients, we select some input-output group \((a,b,c)\), compute the gradient vectors for the output logit at position \(c\) with respect to the input embeddings, and then compute the cosine similarity. Taking the average over many pairs yields the gradient symmetricity.

**Definition 4.1** (Gradient Symmetricity).: _For a fixed set \(S_{p}^{3}\) of input-output pairs3, define **gradient-symmetricity** of a network \(M\) with embedding layer \(E\) as_

\[s_{g}_{(a,b,c) S}(}{_{a}},}{_{b}} ),\]

_where \((a,b)=\) is the cosine-similarity, \(Q_{abc}\) is the logit for class \(c\) given input \(a\) and \(b\). It is clear that \(s_{g}[-1,1]\)._

As we discussed in Section 2.2, the _Pizza_ algorithm has symmetric gradients while the _Clock_ algorithm has asymmetric ones. Model A and Model B in Section 3 have gradient symmetricity \(99.37\%\) and \(33.36\%\), respectively (Figure 2).

#### 4.1.2 Distance Irrelevance

To measure the dependence of correct logits on differences between two inputs, which reflect the distances of the inputs on the circles, we measure how much of the variance in the correct logit matrix depends on it. We do so by comparing the average standard deviation of correct logits from inputs with the same differences and the standard deviation from all inputs.

**Definition 4.2** (Distance Irrelevance).: _For some network \(M\) with correct logit matrix \(L\) (\(L_{i,j}=Q_{ij,i+j}\)), define its **distance irrelevance** as_

\[q_{d_{p}}(L_{ i,i+d} i_{p})}{(L_{i,j} i,j _{p}^{2})},\]

_where \(\) computes the standard deviation of a set. It is clear that \(q\)._

Model A and Model B in Section 3 give distance irrelevance 0.17 and 0.85, respectively (Figure 3). A typical distance irrelevance from the _Pizza_ algorithm ranges from 0 to 0.4 while a typical distance irrelevance from _Clock_ algorithm ranges from 0.4 to 1.

#### 4.1.3 Which Metric is More Decisive?

When the two metrics have conflicting results, which one is more decisive? We consider distance irrelevance as the decisive factor of the _Pizza_ algorithm, as the output logits being dependent on the distance is highly suggestive of _Pizza_. On the other hand, gradient symmetricity can be used to rule out the _Clock_ algorithm, as it requires multiplying (transformed) inputs which will result in asymmetric gradients. Figure 6 confirmed that at low distance irrelevance (suggesting pizza) the gradient symmetricity is almost always close to 1 (suggesting non-clock).

### Identifying algorithmic phase transitions

How do models "choose" whether to implement the _Clock_ or _Pizza_ algorithm? We investigate this question by interpolating between Model A (transformer without attention) and Model B (transformer with attention). To do so, we introduce a new hyperparameter \(\) we call the **attention rate**.

For a model with attention rate \(\), we modify the attention matrix \(M\) for each attention head to be \(M^{}=M+J(1-)\). In other words, we modify this matrix to consist of a linear interpolation between the all-one matrix and the original attention (post-softmax), with the rate \(\) controlling how much of the attention is kept. The transformer with and without attention corresponds to the case where \(=1\) (attention kept) and \(=0\) (constant attention matrix). With this parameter, we can control the balance of attention versus linear layers in transformers.

We performed the following set of experiments on transformers (see Appendix F.1 for architecture and training details). (1) One-layer transformers with width \(128\) and attention rate uniformly sampled in \(\) (Figure 7). (2) One-layer transformers with width log-uniformly sampled in \(\) and attention rate uniformly sampled in \(\) (Figure 7). (3) Transformers with \(2\) to \(4\) layers, width \(128\) and attention rate uniformly sampled in \(\) (Figure 11).

The _Pizza_ and the _Clock_ algorithms are the dominating algorithms with circular embeddings.For circular models, most observed models either have low gradient symmetricity (corresponding to the _Clock_ algorithm) or low distance irrelevance (corresponding to the _Pizza_ algorithm).

Two-dimensional phase change observed for attention rate and layer width.For the fixed-width experiment, we observed a clear phase transition from the _Pizza_ algorithm to the _Clock_ algorithm (characterized by gradient symmetricity and distance irrelevance). We also observe an almost linear phase boundary with regards to both attention rate and layer width. In other words, the attention rate transition point increases as the model gets wider.

Dominance of linear layers determines whether the _Pizza_ or the _Clock_ algorithm is preferred.For one-layer transformers, we study the transition point against the attention rate and the width:

* The _Clock_ algorithm dominates when the attention rate is higher than the phase change point, and the _Pizza_ algorithm dominates when the attention rate is lower than the point. Our explanation is: At a high attention rate, the attention mechanism is more prominent in the network, giving rise to the clock algorithm. At a low attention rate, the linear layers are more prominent, giving rise to the pizza algorithm.
* The phase change point gets higher when the model width increases. Our explanation is: When the model gets wider, the linear layers become more capable while the attention mechanism receive less benefit (attentions remain scalars while outputs from linear layers become wider vectors). The linear layer therefore gets more prominence with a wider model.

Possibly hybrid algorithms between the _Clock_ and the _Pizza_ algorithms.The continuous phase change suggests the existence of networks that lie between the _Clock_ and the _Pizza_ algorithms. This is achievable by having some principal components acting as the _Clock_ and some principal components acting as the _Pizza_.

Figure 6: Distance irrelevance vs gradient symmetricity over all the main experiments.

Existence of non-circular algorithms.Although our presentation focuses on circular algorithms (i.e., whose embeddings are circular), we find non-circular algorithms (i.e., whose embeddings do not form a circle when projected onto any plane) to be present in neural networks. See Appendix B for preliminary findings. We find that deeper networks are more likely to form non-circular algorithms. We also observe the appearance of non-circular networks at low attention rates. Nevertheless, the _Pizza_ algorithm continues to be observed (low distance irrelevance, high gradient symmetricity).

## 5 Related Work

**Mechanistic interpretability** aims to mechanically understand neural networks by reverse engineering them [2; 3; 5; 4; 10; 11; 1; 12; 13; 14]. One can either look for patterns in weights and activations by studying single-neuron behavior (superposition , monosemantic neurons ), or study meaningful modules or circuits grouped by neurons [4; 14]. Mechanistic interpretability is closely related to training dynamics [8; 13; 1].

**Learning mathematical tasks**: Mathematical tasks provide useful benchmarks for neural network interpretability, since the tasks themselves are well understood. The setup could be learning from images [16; 17], with trainable embeddings , or with number as inputs [19; 5]. Beyond arithmetic relations, machine learning has been applied to learn other mathematical structures, including geometry , knot theory  and group theory .

**Algorithmic phase transitions**: Phase transitions are present in classical algorithms  and in deep learning [6; 24; 25]. Usually the phase transition means that the algorithmic performance sharply

Figure 7: Training results from 1-layer transformers. Each point in the plots represents a training run reaching circular embeddings and 100% validation accuracy. See Appendix C for additional plots. _Top:_ Model width fixed to be 128. _Bottom:_ Model width varies. The phase transition lines are calculated by logistic regression (classify the runs by whether gradient symmetricity \(>98\%\) and whether distance irrelevance \(<0.6\)).

changes when a parameter is varied (e.g., amount of data, network capacity etc). However, the phase transition studied in this paper is _representational_: both clock and pizza give perfect accuracy, but arrive at answers via different interal computations. These model-internal phase transitions are harder to study, but closer to corresponding phenomena in physical systems .

**Algorithm learning in neural networks**: Emergent abilities in deep neural networks, especially large language models, have recently attracted significant attention . An ability is "emergent" if the performance on a subtask suddenly increases with growing model sizes, though such claims depend on the choice of metric . It has been hypothesized that the emergence of specific capability in a model corresponds to the emergence of a modular circuit responsible for that capability, and that emergence of some model behaviors thus results from a sequence of quantized circuit discovery steps .

## 6 Conclusions

We have offered a closer look at recent findings that familiar algorithms arise in neural networks trained on specific algorithmic tasks. In modular arithmetic, we have shown that such algorithmic discoveries are not inevitable: in addition to the _Clock_ algorithm reverse-engineered by , we find other algorithms (including a _Pizza_ algorithm, and more complicated procedures) to be prevalent in trained models. These different algorithmic phases can be distinguished using a variety of new and existing interpretability techniques, including logit visualization, isolation of principle components in embedding space, and gradient-based measures of model symmetry. These techniques make it possible to _automatically_ classify trained networks according to the algorithms they implement, and reveal algorithmic phase transitions in the space of model hyperparameters. Here we found specifically that the emergence of a _Pizza_ or _Clock_ algorithm depends on the relative strength of linear layers and attention outputs. We additionally showed that these algorithms are not implemented in isolation; instead, networks sometimes ensemble multiple copies of an algorithm in parallel. These results offer exciting new challenges for mechanistic interpretability: (1) How to find, classify, and interpret unfamiliar algorithms in a systematic way? (2) How to disentangle multiple, parallel algorithm implementations in the presence of ensembling?

LimitationsWe have focused on a single learning problem: modular addition. Even in this restricted domain, qualitatively different model behaviors emerge across architectures and seeds. Significant additional work is needed to scale these techniques to the even more complex models used in real-world tasks.

Broader ImpactWe believe interpretability techniques can play a crucial role in creating and improving safe AI systems. However, they may also be used to build more accurate systems, with the attendant risks inherent in all dual-use technologies. It is therefore necessary to exercise caution and responsible decision-making when deploying such techniques.