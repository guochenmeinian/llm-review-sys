# Galopa: Graph Transport Learning

with Optimal Plan Alignment

 Yejiang Wang\({}^{1,2}\) Yuhai Zhao\({}^{1,2,}\) Zhengkui Wang\({}^{3}\) Ling Li\({}^{1,2}\)

\({}^{1}\) School of Computer Science and Engineering, Northeastern University, China

\({}^{2}\) Key Laboratory of Intelligent Computing in Medical Image

of Ministry of Education, Northeastern University, China

\({}^{3}\) InfoComm Technology Cluster, Singapore Institute of Technology, Singapore

wangyejiang@stumail.neu.edu.cn, zhaoyuhai@mail.neu.edu.cn, zhengkui.wang@singaporetech.edu.sg, lilingneu@gmail.com

 Corresponding author.

###### Abstract

Self-supervised learning on graphs aims to learn graph representations in an unsupervised manner. While graph contrastive learning (GCL - relying on graph augmentation for creating perturbation views of anchor graphs and maximizing/minimizing similarity for positive/negative pairs) is a popular self-supervised method, it faces challenges in finding label-invariant augmented graphs and determining the exact extent of similarity between sample pairs to be achieved. In this work, we propose an alternative self-supervised solution that (i) goes beyond the label invariance assumption without distinguishing between positive/negative samples, (ii) can calibrate the encoder for preserving not only the structural information inside the graph, but the matching information between different graphs, (iii) learns isometric embeddings that preserve the distance between graphs, a by-product of our objective. Motivated by optimal transport theory, this scheme relies on an observation that the optimal transport plans between node representations at the output space, which measure the matching probability between two distributions, should be consistent with the plans between the corresponding graphs at the input space. The experimental findings include: (i) The plan alignment strategy significantly outperforms the counterpart using the transport distance; (ii) The proposed model shows superior performance using only node attributes as calibration signals, without relying on edge information; (iii) Our model maintains robust results even under high perturbation rates; (iv) Extensive experiments on various benchmarks validate the effectiveness of the proposed method.

## 1 Introduction

Self-supervised graph learning involves learning representations of real-world graph data without the need for human supervision. Graph contrastive learning (GCL)  has been identified as one of the most successful graph self-supervised learning approaches, with its key components consisting of graph augmentation and contrastive learning. The former creates perturbation views of anchor graphs via various augmenting techniques, while the latter maximizes the similarity for two augmentations (positive pairs) of the same anchor and minimizes the similarity for those of two different anchors (negative pairs). The effectiveness of contrastive learning is dependent on the assumption that the augmented operations preserve the nature of data points and ensure that the augmented samples have consistent labels with the original ones.

However, graph data structures are discrete and their properties may vary significantly even with slight perturbations, which makes it much more challenging to design reasonable augmentations that guarantee the label-invariant assumption for graphs, in contrast to images or text. Additionally, the concept of "maximum similarity" in contrastive learning is difficult to measure since it is vague and lacks a clear indication of how much similarity should be maximized (or minimized) for a given pair of positive (or negative) views.

To address these challenges, an intuitive solution is to introduce the concept of distance from the input space, whereby the distance between the learned embeddings is forced to be equal to the distance between the corresponding input graphs. However, this requirement is challenging to achieve as the input objects (graphs) and output representations (vectors) are two distinct concepts, making it difficult to agree on their distance metrics. For instance, comparing the graph edit distance between graphs  and the Euclidean distance between vectors directly is inconceivable.

In response to the aforementioned challenges, in this paper, we propose a novel self-supervised learning method that seeks to align optimal transport plans  from graph space to node representation space, instead of transport distance . This method is referred to as Graph Transport Learning (GTL), and it exploits the key concept in optimal transport (OT) theory, which aims to identify an optimal match (i.e., transport plan) between two data distributions (e.g., node sets of graphs) that minimizes the matching cost (i.e., transport distance). As shown in Figure 1, the transportation plan \(\) explicitly determines how to match particles from the source distribution \(\) to the target distribution \(\). Our approach involves several key steps. First, we obtain two graph views by augmenting a graph and generating node embeddings using a backbone model, such as Graph Neural Network (GNNs) . Two optimal transport plans can be computed from the graph space and the representation space, respectively. To accurately capture the matching relationships in the original graph space, we enforce the backbone to learn representations that exhibit consistency with the optimal transport plans between the corresponding source graphs in the input space. This is achieved by minimizing the discrepancy between the two plans. Unlike distance-based approaches, the transport plan alignment shows several advantages: (i) _Direct comparability_: Plans with the same dimension can be compared directly, regardless of differences between the graph and representation spaces. The value of the transport plan is dimensionless, representing the joint probability of two particles; (ii) _Accurate match relationship_: For discrete objects, the transport plan retains more accurate matching relation between data compared to distance; (iii) _Label-variant_: Importantly, our self-supervised model does not require differentiating between positive and negative samples after graph augmentation. This is due to the availability of corrective information from the input space, which eliminates the need for a label-invariant assumption. Notably, our experimental findings in Section 7 demonstrate that our model maintains robust performance even under high perturbation rates, such as when 80\(\%\) of both edges and node attributes are destroyed during graph augmentation. In summary, we make the following contributions:

* We propose a novel paradigm for self-supervised graph learning based on optimal plan alignment, Galopa, which offers a distinct objective compared to contrastive learning methods. This approach eliminates the need for a label-invariant assumption.
* By constraining the discrepancy between the transport plans, we introduce a new loss to enable the sharing of the exact matching information from the graphs space to the representation space.
* Multiple comprehensive experiments, including distance v.s plan, node feature v.s edge, robustness test and comparison with state-of-the-art methods demonstrate remarkable performance of Galopa.

## 2 Related Work

**Self-supervised Learning on Graphs.** Graph self-supervised learning has been a promising paradigm for learning useful representations of unlabeled graph data. The node embedding methods aim to learn a low-dimensional vector embedding of vertex preserving different kinds of order proximity via factorization , random walk  or deep learning [8; 61]. Recently, graph contrastive learning has achieved unprecedented success [6; 28; 55; 64], where the goal is to ensure representations have high similarity between positive views of a graph and high dissimilarity between negative views. A common way of contrastive objective is contrasting views at the node level. For the

Figure 1: An illustration of discrete optimal transport plan.

representations (positive views) \(_{i}^{1}\) and \(_{i}^{2}\) of same node \(i\) in two augmented graphs \(_{1}\) and \(_{2}\), the pairwise contrastive loss can be defined as

\[_{}=_{i}((_ {i}^{1},_{i}^{2})/}}{e^{(_{i}^{1},_{i}^{2})/}+_{k i}e^{(_{i}^{1},_{k }^{2})/}})\] (1)

where \(\) is a discriminator that maps two views to an agreement (similarity) score, such as the inner product. \(\) denotes the temperature. Obviously, this type of loss strongly relies on the label invariance assumption. In other words, it needs to know (or assume) beforehand that the two views are positive/negative samples, which is challenging for discrete graph structures. For example, there exist some graphs, such as molecular graphs, whose labels are very sensitive to perturbation/corruption. Some studies have explored the label-invariant augmentation [29; 31; 74], but such augmentations require very careful design and adjustment, and sometimes limit the power of graph augmentation. More recently,  utilizes the graph edit distance to train graph discriminator to predict whether a graph is an original graph or a perturbed one. However, this model still requires positive and negative samples and relies on the assumption of label invariance.

**Optimal Transport.** Optimal transport (OT)  is a mathematical tool for aligning probability distributions has received much attention in the machine learning community in many applications, e.g., computer vision [4; 51], generative adversarial network [2; 7; 30], domain adaptation . OT aims to derive a transport plan between a source and a target distribution, such that the transport cost is minimized.  proposes the Gromov-Wasserstein (GW) distance between metrics defined within each space rather than between samples across different spaces, which has been used as a distance between graphs in several applications [56; 60; 67]. However, these studies can only perform graph classification on datasets with multiple graphs and cannot be applied to network analysis, such as node representation classification, where only one network is available. In this work, we combine optimal transport problem with graph neural network to form a novel self-supervised learning paradigm that allows both graph and network learning. See Appendix A for more details.

## 3 Background

Notations.Let \(=(,,)\) be a graph of \(n\) nodes where \(\) denotes the set of nodes, \(\{0,1\}^{n n}\) is the adjacency matrix. \(^{n}\) is the empirical distribution of nodes in \(\). Generally, \(\) is a uniform discrete probability distribution. When the node label (or attribute) is available, we represent the node feature matrix as \(^{n d}\), where \(d\) denotes the dimension of node attributes. \(^{i}\) represents the \(i\)-row of \(\). Let \( n=\{1,,n\}\), \( n^{2}= n n\) and \(,\) denotes the inner product for matrices. We denote \(\) the tensor-matrix multiplication. \(_{n}\) represents the vector with ones as all the \(n\) elements. \(||\) denotes absolute value.

Plan and Optimal Transport.The optimal transport (OT) problem is pioneered by Monge  in order to seek the most cost-effective _transport plan_ that transforms the mass of a pile of sand into another one. In particular, it studies how to find an optimal coupling or optimal plan \(\) for transforming the distribution \(\) to \(\) with minimum total transport cost (i.e., optimal transport distance), where the element of \(\) describes the probability of moving mass from one position to another. In this work, we mainly focus on the discrete case. Given two sets of features \(_{1}=\{_{1}^{i}\}_{i=1}^{n}\) and \(_{2}=\{_{2}^{j}\}_{j=1}^{m}\), where \(n\) and \(m\) are are the number of features, respectively. \(^{n}\) and \(^{m}\) are the probability distributions of the entities in the two sets, respectively. The formulation of the OT distance is

\[(_{1},_{2})=_{(,)}_{i  n}_{j m}c_{}( _{1}^{i},_{2}^{j})_{ij}=_{(,)} (_{1},_{2}),\] (2)

where

\[(,)=\{^{n m}_{m}=,_{n}=\}\] (3)

denotes all the joint distributions \(\) with marginals \(\) and \(\). \((_{1},_{2})_{ij}=c_{}(_{1}^{i},_{2}^{j})\) is the cost (work) of moving \(_{1}^{i}\) to \(_{2}^{j}\), the cosine distance between \(_{1}^{i}\) and \(_{2}^{i}\) is a popular choice. The \(^{n m}\) is called as **transport plan**. This distance is also known as the Wasserstein distance.

Optimal Transport for Graphs.The Wasserstein problem requires the two distributions of point sets to lie in the same space. But for graphs, it is difficult to measure the cost between two nodes on different graphs without node label (attribute). Even if the cost between nodes could be calculated, the Wasserstein distance cannot take the edge information into account. To compare distributions that are not necessarily in the same space,  defines Gromov-Wasserstein distance between two graphs without node label \(_{1}=(_{1},)\) and \(_{2}=(_{2},)\) as follow

\[_{}(_{1},_{2})=_{_{}(,)}_{i,k n^{2}}_{j,l  m^{2}}c_{}(_{1}^{ik},_{2}^{jl}) _{ik}_{jl}=_{(,)}(_{1},_ {2}),\] (4)

where \((_{1},_{2})\) is 4-D tensor and \((_{1},_{2})_{ijkl}=c_{}(_{1}^{ik},_{2 }^{jl})\). The cost function \(c_{}\) is commonly defined as \(c_{}(_{1}^{ik},_{2}^{jl})=|_{1}^{ik}-_{2}^ {jl}|\).

Consider two graphs with node attributes \(_{1}=(_{1},_{1},)\) and \(_{2}=(_{2},_{2},)\) where \(_{1}^{n n}\) and \(_{2}^{m m}\) denote their adjacency matrices, \(_{1}^{n d}\) and \(_{2}^{m d}\) are feature matrices. The fused Gromov-Wasserstein distance  between graphs \(_{1}\) and \(_{2}\) can be defined as

\[_{}(_{1},_{2})=_{_{}(,)}\ _{ij}c_{}(_{1}^{i},_{2}^{j})_{ij}^{ }+(1-)_{ijkl}c_{}(_{1}^{ik},_{2}^ {jl})_{ij}^{}_{kl}^{}\] (5)

which is equivalent to

\[_{_{}(,)}\ (_{1},_ {2})+(1-)(_{1},_{2})_{},\ _{}\] (6)

where \((_{1},_{2})_{ij}=c_{}(_{1}^{i},_{2}^ {j})\), \((_{1},_{2})_{ijkl}=c_{}(A_{1}^{ik},A_{2}^{jl})\) and \([0;1]\) denotes a trade-off parameter. Obviously, this definition is a fusion of Equations (2) and (4).

## 4 Graph Transport Alignment

As analyzed in the previous section, the recent graph contrastive techniques are deeply plagued by positive and negative sample generation, since graph properties could become completely different even with slight perturbations. To design a universal self-supervision scheme, we are motivated to calibrate the similarity between different representations in the output space using the matching signal between corresponding graphs from the input space. In particular, we first perturb the given graph to obtain two different graphs (e.g., a perturbed graph and the original one) and generate the node embeddings of the two graphs using the backbone model (e.g., GNNs). After computing the optimal transport plans for the graphs and the sets of node representations respectively (Section 4.1), we take the discrepancy between the two plans as the loss to calibrate the backbone for obtaining representation with rich geometry awareness and interpretable correspondences (Section 4.2). We compare the proposed graph self-supervised learning paradigm with graph contrastive learning in Section 4.3. The framework can be found in Figure 2.

### Optimal Transport Plan

In general, it is challenging to define two similarity metrics (e.g., distances), which can be directly compared, in two different spaces. This is especially the case for graphs and vectors, two distinct objects by nature. Fortunately, optimal transport theory offers a glimmer of hope, transportation plan, for such comparison. In this section, we present objectives that aim at finding the optimal plan for two graphs (or sets of vectors) to minimize the transport cost. For the graph, a natural idea is to jointly take into account both node attributes and explicit topology information (i.e., edges) in the transportation plan. In this work, we leverage  to present an objective function for calculating the optimal transport plan which integrates the edge structure and the feature information on nodes.

Figure 2: A framework of graph transport self-supervised learning.

Specifically, the fused optimal transport plan \(_{}^{*}^{n m}\) between two node-attribute graphs \(_{1}\) and \(_{2}\) can be defined as

\[_{}^{*}=*{argmin}_{_{}(,)} \ (_{1},_{2})+(1-)(_{1},_{2 })_{},\ _{}\] (7)

with the fused Gromov-Wasserstein distance (6). By tuning the parameter \(\) we can control the bias of the learned optimal plan between node attributes and edge structure. Intuitively we might think that combining more edge information could greatly benefit the expressiveness power of the model. However, we observe that the performance of the proposed method does not degrade significantly in the absence of edge information, and even increases rather than decreases on some datasets. It will be explained in detail later.

For the node representations of graph encoded by the backbone model (e.g., GNNs), we can either use Equation (2) directly to calculate the optimal plan \(_{}^{*}^{n m}\) or set \(=1\) in Equation (7) as

\[_{}^{*}(_{1},_{2})=*{argmin}_{_{ }(,)}\ (_{1},_{2}),\ _{}\] (8)

where \((_{1},_{2})_{ij}=c_{}(_{1}^{i},_{2}^ {j})\), \(_{1}\) and \(_{2}\) denote the node representations corresponding to \(_{1}\) and \(_{2}\), respectively.

### Optimal Transport Alignment

The previous section establishes the foundation that comparing the similarity metrics defined on graph space and vector space can be reduced into comparing the two optimal transport plans from these spaces, each of which can be solved using Equations (7) or (2). This is a valid comparison because the optimal transport plan \(\) acts as a _probabilistic matching_ of two distributions, while the two plan matrices have the same dimensions (i.e., \(n m\)).

Naturally, the encoder may succeed in obtaining a _good_ representations for a graph if it learns the node embeddings that not only retain its structural information inside the graph, but also capture matching information with other graphs. This motivates us to force the encoder to preserve the matching relationship in the graph space by aligning the plan between the two graphs with the plan of their corresponding node representations. We define a match alignment loss by minimizing the discrepancy between the two transport plans as follows

\[_{}=_{}^{*},\,_{ }^{*}_{1},_{2}\] (9)

where the discrepancy function \((,)\) can be any commonly used metric, e.g., the Frobenius-norm \(\|-\|_{F}\) or the divergence \(D(\|)\).

In addition, to guide the encoder to learn a representation retaining structural information inside the graph, we also calibrate the cost matrix \((_{1},_{2})\), which implies the implicit structure relationships between nodes, in the representation space as follow

\[_{}=_{1},_{2}+(1-)_{1},_{2}_{ }^{*},\,_{1},_{2}\] (10)

To understand the concept of _'implicit structure'_ intuitively, here we consider the one-dimensional case. As shown in Figure 3, given a point set \(=\{_{1}^{1},,_{1}^{n}\}\), the location of each of its points is fixed. If the position of a point (yellow) \(_{2}^{j}\) is unknown but the transportation cost from this point to all points (blue) in the point set \(\) is known, then the location of this point is determined with respect to the entire point set \(\). The same holds true for another point \(_{2}^{l}\). Thus the relative position relationship between points \(_{2}^{j}\) and \(_{2}^{l}\) can be captured implicitly by the transport costs matrix \((_{1},_{2})\).

To this end, we define the overall graph transport alignment loss as

\[_{}=_{}+_{}\] (11)

where \(\) is the trade-off parameter.

Figure 3: An illustration of implicit structure in one-dimension.

### Compare with Graph Contrastive Learning

Although our objective function is different from the contrastive loss as shown in Equation (1), we find that the algorithmic philosophy of both is very similar. Here we analyze at the node level. Given a graph \(\), the perturbation graphs \(_{1}\) and \(_{2}\) are obtained by augmenting \(\). If the attribute and context of node \(i\) in \(\) are corrupted in a similar way and obtained two node views in \(_{1}\) and \(_{2}\). The cost between these two views is quite small (almost zero) and thus the optimal transport plan yields a high probability of matching between these two node views. With Equations (9) and (10), the model Galopa calibrates the matching probability and cost of the corresponding node representations in the output space, which is actually making the representations of two similar nodes similar enough. And for two different nodes \(i\) and \(k\) of \(\), the cost between their corresponding node views in graphs \(_{1}\) and \(_{2}\) is relatively larger. This leads to the opposite correction, i.e., making the representation of two dissimilar nodes sufficiently dissimilar.

From the contrastive learning perspective, the above process is not inconsistent with its goals. But there is a fundamental difference between graph transport alignment and graph contrastive learning: Galopa directly utilizes calibration signal from the graph space. Precisely because of this signal, we do not have to distinguish between positive and negative samples, like _Maxwell's demon_.

### Complexity

The time complexity of the model Galopa is mainly influenced by the optimization process of Equations (7) and (8). To optimize Equation (7), which contains the fused Gromov-Wasserstein term, we utilize a conditional gradient (CG) solver . This solver necessitates the computation of a gradient with a nearly cubic time complexity at each iteration concerning the size of the graph, i.e., the number of nodes. On the other hand, Equation (8) with the Wasserstein term can be optimized using the Sinkhorn-Knopp algorithm , which is highly time-efficient with a nearly square complexity.

## 5 Plan or Distance?

Thanks to the alignment of the plan and cost for the representation, as a byproduct, we find that the OT distance between the optimal node representations \(^{*}\) in Equation (11) is equal to the distance between its corresponding graphs. This is due to the two losses (10) and (9) constrain the optimal node representation to satisfy \((_{1}^{*},_{2}^{*})=(_{1},_{2})+(1- )(_{1},_{2})_{}^{*}\) and \(_{}^{*}(_{1}^{*},_{2}^{*})=_{}^{*}\), respectively. This means that our losses can prompt the encoder to learn an isometric embedding that preserves the distance between graphs, which is one of the pursuits of the general representation model. Hence, we became interested in the question of who is more important, distance or plan? How would the model perform if we drop the alignment of the plan and cost but instead optimize the distance directly? In this section, we assess and rationalize the role of the plan for graph structure data in our self-supervised framework. To compare the possible performance gap between distance and plan, instead of directly optimizing the plan, we construct a new loss with distance as following

\[_{}=|_{}(_{1},_{2})-(_{1},_{2})|\] (12)

where \(||\) denotes absolute value, and \(_{}(_{1},_{2})=_{( {h}_{1},_{2})}_{ij}c_{}(_{1}^{i},_{2}^ {j})_{ij}^{}+(1-)_{ijkl}c_{}(A_{1}^{ ik},A_{2}^{jl})_{ik}^{}_{jl}^{}\).

We evaluate the performance of using the pretraining representations on 2 social network datasets, CORA and CITESEER  for node classification, and 2 graph classification data PROTEINS and

Figure 4: Plan versus distance. Comparing mean graph/node classification accuracy between transport alignment loss and distance loss on 4 datasets.

MUTAG from TUDataset  for graph classification. See Section 8 for detailed experimental configurations. Figure 4 reports the averaged node/graph classification accuracy results over the node/graph-level datasets. The results suggest that the model using the plan as an objective significantly outperforms the counterpart models using the distance. Although the experimental result may lead to'surprise', it demonstrates that the plan is closer to the essence than the distance, for discrete structured data. The optimal transport formulation Equation (5) contains both matching and implicit structural information. If only the final distance is retained instead of capturing the two types of information separately, the learned representation may fail to align properly with the input element. Because the optimal transport plan for the discrete OT problem is not unique in general and the optimal distance may correspond to several plans.

## 6 Node Attributes or Edges?

Among the information encoded in a graph, the structure and node attributes are two crucial elements for representation learning. The basic requirement of the encoder is to preserve the topology structures and capture the vertex feature of graphs. Thus a problem is encountered in our self-supervised learning paradigm: if we try to calibrate the representations learned by the backbone encoder, which is more important, the edge structure or the node attributes? In other words, if the calibration signal from the input space contains only node attribute information and completely ignores the explicit edge connectivity, will the performance of the proposed model deteriorate significantly? The answer seems obvious--it should be. But the case seems to be different. Let's take a look at the experiment below.

As in the previous section, we performed the comparative experiments on four datasets CORA, CITESEER, PROTEINS, and MUTAG. Here we first consider the normal case of our loss function (i.e., \( 0\)). We set the value of the parameter \(\) to adjust the bias of node attributes or edge connections for the plan in the graph space. If \(=1\), the model takes into account only node attributes in the transportation plans. When \(=0\), it integrates explicit edge information while completely ignoring the node feature. Figure 5 reports the results with different \(\) and shows a surprising outcome: With only node attributes for the calculation of the plan, the model achieves outstanding performance on all the datasets, even optimal on some data. However, if we set \(=0\) to remove the implicit structure constraint term \(_{}\), the performance of the model suddenly deteriorates dramatically.

This verifies that the constraint \(_{}\) is necessary and the implicit structural information it captures does calibrate the encoder even in the case of missing explicit edge connection. It therefore inspires self-supervised graph learning: it may not be able to tell that edge information does not contribute to correction for significant performance gains, but it is perfectly feasible to use only node attributes as a calibration supervisory signal for backbone model. This is a practical and valuable finding since the number of edges in a real-world graph dataset is much more than the number of nodes. The time and space complexity of the model can be reduced greatly if only the node information is used in the calculation of the correction signal while ignoring the edge connections.

## 7 Are the Transport Alignment Free from Positive/Negative Samples?

As shown in Equation (11), the proposed objective function does not distinguish whether the two different graphs/nodes are positive (negative) samples or not. Here, we want to show that the graph transport alignment strategy can be independent of the label invariance assumption. We conduct experiments below to see how different levels of perturbation affect the performance of Galopa. When augmenting the graph, we fixed one of the augmentations as NoAug and the other augmentation

Figure 5: The mean graph/node classification accuracy on 4 datasets under different values of parameter \(\).

requires a hyper-parameter "_aug ratio_" that controls the portion of node attributes/edge that are selected for perturbing. Note that different augmentation strategies can be combined. Since the computation of the optimal transport plan in this paper involves node attributes and edge, we perform two augmentation policies, edge perturbation and feature masking, with different augmentation rates on four datasets (i.e., CORA, CITESEER, MUTAG, and PROTEINS) as shown in Figure 6.

From Figure 6 we find that the performance of our model does not change much even when the original graph is perturbed heavily. For example, even if eighty percent of the edges are removed while eighty percent of the node attributes are destroyed, the model's performance on the dataset CITESEER (0.742) is almost equal to the optimal result (0.743). Fluctuations of only zero point five to two percent are also observed on other data sets, such as one point three in PROTEINS data. Hence, it validates that the alignment of optimal transport between the source space and target space is indeed free from the label-invariant assumption.

## 8 Comparison with the State-of-the-art Methods

In this section, we compare our proposed self-supervised pre-training framework, Galopa, with state-of-the-art methods in the settings of unsupervised learning on graph/node classification. More results can be found in the Appendix.

### Experimental Setup

**Datasets.** We analyze the quality of representations learned by Galopa on node and graph classification benchmarks. For node classification, we evaluate the performance of using the pretraining representations on 7 benchmark graph datasets, namely, CORA, CITESEER, PUBMED  and Wiki-CS, Amazon-Computers, Amazon-Photo, and Coauthor-CS . For graph classification, we follow GraphCl to perform evaluations on 6 graph classification data NCI1, PROTEINS, DD, MUTAG, COLLAB, and IMDB-B from TUDataset .

**Baselines.** For node-level tasks, we adopt three types of baselines: 1) _Supervised learning methods_, including Mlp and Gcn; 2) _Graph embedding methods_, including DeepWalk and

  
**Model** & **CORA** & **CITESEER** & **PUBMED** & **WikCS** & **Ame-Comp.** & **Ame-Photo** & **Coauthor-CS** & **Average** \\  Mlp & 47.92 \(\) 0.41 & 49.31 \(\) 0.26 & 69.14 \(\) 0.34 & 71.98 \(\) 0.42 & 73.81 \(\) 0.21 & 78.53 \(\) 0.32 & 90.37 \(\) 0.19 & 68.72 \(\) 0.31 \\ Gcn & 81.54 \(\) 0.68 & 70.73 \(\) 0.65 & 79.16 \(\) 0.25 & 93.02 \(\) 0.11 & 86.51 \(\) 0.54 & 92.42 \(\) 0.22 & 93.03 \(\) 0.31 & 85.20 \(\) 0.39 \\  DeepWalk & 70.72 \(\) 0.63 & 51.39 \(\) 0.41 & 73.27 \(\) 0.86 & 74.42 \(\) 0.13 & 85.68 \(\) 0.07 & 89.40 \(\) 0.11 & 84.61 \(\) 0.22 & 75.64 \(\) 0.35 \\ NonDeepXe & 71.08 \(\) 0.91 & 47.34 \(\) 0.84 & 66.23 \(\) 0.95 & 71.76 \(\) 0.14 & 84.41 \(\) 0.14 & 89.68 \(\) 0.19 & 85.16 \(\) 0.04 & 73.67 \(\) 0.46 \\  Gae & 71.49 \(\) 0.41 & 65.83 \(\) 0.40 & 72.23 \(\) 0.71 & 73.97 \(\) 0.16 & 85.27 \(\) 0.19 & 91.62 \(\) 0.13 & 90.01 \(\) 0.71 & 78.63 \(\) 0.39 \\ Vga & 77.31 \(\) 1.02 & 67.41 \(\) 0.24 & 78.55 \(\) 0.62 & 75.56 \(\) 0.28 & 86.40 \(\) 0.22 & 92.16 \(\) 0.12 & 92.13 \(\) 0.16 & 80.97 \(\) 0.38 \\ Ddi & 82.34 \(\) 0.71 & 78.13 \(\) 0.54 & 76.78 \(\) 0.31 & 75.37 \(\) 0.13 & 84.01 \(\) 0.52 & 91.62 \(\) 0.42 & 92.16 \(\) 0.62 & 82.02 \(\) 0.46 \\ Gmi & 82.39 \(\) 0.65 & 71.72 \(\) 0.15 & 79.34 \(\) 1.04 & 74.87 \(\) 0.13 & 82.18 \(\) 0.27 & 90.68 \(\) 0.18 & OOM & \\ MyGkl & 83.45 \(\) 0.68 & 73.28 \(\) 0.48 & 80.09 \(\) 0.62 & 77.51 \(\) 0.06 & 87.53 \(\) 0.12 & 91.74 \(\) 0.08 & 92.11 \(\) 0.14 & 83.67 \(\) 0.31 \\ Grace & 81.92 \(\) 0.89 & 71.21 \(\) 0.64 & 80.54 \(\) 0.36 & 78.19 \(\) 0.10 & 86.35 \(\) 0.44 & 92.15 \(\) 0.25 & 92.91 \(\) 0.20 & 83.32 \(\) 0.41 \\ Gca & 82.38 \(\) 0.47 & 71.51 \(\) 0.32 & 80.89 \(\) 0.28 & 78.29 \(\) 0.36 & 87.88 \(\) 0.26 & 92.33 \(\) 0.68 & 92.64 \(\) 0.34 & 83.70 \(\) 0.39 \\ Bari & 81.30 \(\) 0.54 & 72.06 \(\) 0.63 & 80.52 \(\) 0.30 & 76.13 \(\) 0.18 & **89.09 \(\) 0.51** & 92.15 \(\) 0.32 & 92.33 \(\) 0.39 & 83.37 \(\) 0.41 \\  Galopa & **84.21 \(\) 0.30** & **74.34 \(\) 0.18** & **84.57 \(\) 0.34** & **81.23 \(\) 0.19** & 88.65 \(\) 0.11 & **92.77 \(\) 0.40** & **93.04 \(\) 0.25** & **85.54 \(\) 0.25** \\   

Table 1: Mean node classification accuracy (%) for supervised and unsupervised models. The highest performance of unsupervised models is highlighted in **boldface**. OOM indicates Out-Of-Memory.

Figure 6: The mean graph/node classification accuracy when contrasting with different perturbation rates under 4 datasets. Fix one of the augmentations as NoAug and the other augmentation be the combination of edge perturbation and feature masking. Darker colors indicate better performance.

Node2Vec ; 3) _Graph contrastive learning methods_, including Gae, Vgae , Dgi , Gmi , MvGrl , Grace , Gca , and Bgrl . For graph-level task, we evaluate the performance of Galopa in terms of the linear classification accuracy and compare it with 1) two _supervised learning methods_, including Gcn  and Gin ; 2) seven _kernel-based methods_, including SP , GK , WL , WLPM , FGW , Ddg , and Mlg ; 3) three _unsupervised methods_, including Node2Vec , Sub2Vec , Graph2Vec ; 4) five recent SOTA _self-supervised learning methods_ based on contrastive learning, including InfoGraph , GraphCl , Ad-Gcl , Joav2 , Rgcl  and SimGrace .

**Protocol.** We follow the standard evaluation protocol of previous state-of-the-art graph self-supervised learning approaches at the graph and node levels, respectively. Specifically, for graph classification, we report the mean 10-fold cross-validation accuracy after 5 runs followed by a linear SVM. The linear SVM is trained by applying cross-validation on training data folds and the best mean accuracy is reported. For node classification, we report the mean accuracy on the test set after 50 runs of training followed by a linear neural network model. For the graphs (nodes) datasets, we randomly split the data, where 80%/10%/10% (10%/10%/80%) of graphs (nodes) are selected for the training, validation, and test set, respectively.

**Implementation Details.** In the experiments, we use the Adam optimizer  with learning rate is tuned in \(\{0.0001,0.001,0.01\}\). The optimization routine and the convergence analysis are summarized in Appendix B. We conduct the experiment with the trade-off parameter \(\) and \(\), the parameter \(C\) of Svm, batch size in the sets \(\{10^{-3},10^{-2},,10^{2},10^{3}\}\), \(\{0,0.1,,0.9,1\}\), \(\{10^{-3},,10^{3}\}\), \(\{16,64,128,256,512\}\), respectively. To perform graph augmentation, we use 4 types of operations: Edge Perturbation, Feature Masking, Node Dropping, and Graph Sampling. Our model is implemented with Pytorch Geometric  and Deep Graph Library .

### Performance Comparison

**Performance under Node-level.** Table 1 reports the averaged results over the node-level datasets. Comparing the results in Table 1, we have the following major observations. The proposed method outperforms the state-of-the-art self-supervised models significantly and even exceeds the supervised models on several datasets. For example, on PUBMED, Galopa achieves 84.57% accuracy, which is a 3.68% relative improvement over previous state-of-the-art unsupervised algorithms. When compared to supervised baselines, it outperforms strong supervised baselines: On CORA, CITESEER and PUBMED benchmarks we observe 2.67%, 3.61% and 5.41% relative improvement over Gcn, respectively. On Coauthor-CS, the proposed unsupervised method shows competitive performance compared to the supervised models. Tabel 1 lists the average accuracy of 7 benchmark datasets, from which Galopa achieves the best performance as well. For example, our proposed Galopa

  
**Model** & **PROTEINS** & **DD** & **MUTAG** & **NC11** & **COLLAB** & **IMDB-B** & **Average** \\  Gcn & 74.92 \(\) 0.33 & 76.24 \(\) 0.14 & 85.63 \(\) 0.24 & 80.20 \(\) 0.14 & 79.01 \(\) 0.18 & 70.45 \(\) 0.37 & 77.74 \(\) 0.23 \\ Gin & 76.28 \(\) 0.28 & 78.91 \(\) 0.13 & 89.47 \(\) 0.16 & 82.75 \(\) 0.19 & 80.23 \(\) 0.19 & 73.70 \(\) 0.60 & 80.22 \(\) 0.25 \\  SP & 75.07 \(\) 0.54 & -jd & 85.25 \(\) 0.24 & 73.53 \(\) 0.16 & — & 55.62 \(\) 0.02 & — \\ GK & 71.67 \(\) 0.55 & 78.53 \(\) 0.03 & 81.71 \(\) 0.21 & 66.06 \(\) 0.12 & 71.81 \(\) 0.31 & 65.93 \(\) 0.10 & 72.61 \(\) 0.22 \\ WL & 72.92 \(\) 0.56 & 79.78 \(\) 0.36 & 80.76 \(\) 0.30 & 80.01 \(\) 0.50 & 69.30 \(\) 0.42 & 72.30 \(\) 0.44 & 75.84 \(\) 0.43 \\ WLPM & — & 78.79 \(\) 0.38 & 87.13 \(\) 0.42 & **86.32 \(\) 0.19** & — & — & — \\ FGW & 74.50 \(\) 0.23 & — & 88.34 \(\) 0.12 & 86.24 \(\) 0.31 & — & 62.97 \(\) 0.24 & — \\ DgK & 73.21 \(\) 0.61 & 74.79 \(\) 0.32 & 87.51 \(\) 0.65 & 79.98 \(\) 0.36 & 64.43 \(\) 0.48 & 67.09 \(\) 0.37 & 74.50 \(\) 0.46 \\ Mlg & 41.23 \(\) 0.27 & 1d & 87.94 \(\) 0.16 & 1d & 1d & 66.67 \(\) 0.30 & — \\  Node2Vec & 57.58 \(\) 0.36 & — & 72.62 \(\) 1.02 & 54.93 \(\) 0.16 & 56.12 \(\) 0.02 & 50.25 \(\) 0.09 & — \\ Sub2Vec & 53.06 \(\) 0.56 & 54.33 \(\) 0.24 & 61.17 \(\) 1.59 & 52.82 \(\) 0.15 & 55.26 \(\) 0.15 & 55.34 \(\) 0.15 & 55.33 \(\) 0.47 \\ Graph2Vec & 73.33 \(\) 0.21 & 79.32 \(\) 0.29 & 83.28 \(\) 0.93 & 73.21 \(\) 0.18 & 71.10 \(\) 0.54 & 71.16 \(\) 0.05 & 75.23 \(\) 0.36 \\  InfoGraph & 74.44 \(\) 0.31 & 72.85 \(\) 1.78 & 89.01 \(\) 1.13 & 76.20 \(\) 1.06 & 70.05 \(\) 1.13 & **73.03 \(\) 0.87** & 75.93 \(\) 1.04 \\ Graph2Vec & 74.39 \(\) 0.45 & 78.62 \(\) 0.40 & 86.80 \(\) 1.34 & 77.87 \(\) 0.41 & 73.16 \(\) 1.15 & 71.14 \(\) 0.44 & 76.69 \(\) 0.69 \\ ad-GCL & 73.28 \(\) 0.46 & 75.79 \(\) 0.87 & 88.74 \(\) 1.85 & 73.91 \(\) 0.77 & 72.02 \(\) 0.56 & 70.21 \(\) 0.68 & 75.65 \(\) 0.86 \\ Joa0v2 & 74.13 \(\) 0.51 & 77.32 \(\) 0.29 & 87.17 \(\) 1.09 & 78.40 \(\) 0.17 & 69.19 \(\) 0.16 & 70.37 \(\) 0.37 & 76.09 \(\) 0.43 \\ Rgcl & 75.03 \(\) 0.43 & 78.86 \(\) 0.48 & 87.66 \(\) 1.01 & 78.14 \(\) 1.08 & 70.92 \(\) 0.65 & 71.85 \(\) 0.84 & 77.07 \(\) 0.74 \\ SimGrace & 75.23 \(\) 0.19 & 77.45 \(\) 1.03 & 89.27 \(\) 1.39 & 79.10 \(\) 0.25 & 71.37 \(\) 0.44 & 71.45 \(\) 0.29 & 77.31 \(\) 0.59 \\  Galopa & **76.93 \(\) 0.18** & **83.87 \(\) 0.42** & **91.11 \(\) 1.27** & 77.86 \(\) 0.36 & **73.20 \(\) 0.37** & 70.72 \( the unsupervised SOTA baseline SimGrace by 1.84% on average, and even outperforms supervised GCN by 0.34%. These results further validate that calibrating the backbone model by optimal transport alignment can produce expressive and generalizable representations.

**Performance under Graph-level.** In this section, we examine whether the proposed Galopa performs better than state-of-the-art methods at graph-level datasets. The results of supervised learning baselines and unsupervised methods are reported in Table 2. The results shown in Table 2 suggest that Galopa achieves state-of-the-art results with respect to unsupervised models. For example, on DD it achieves 83.87% accuracy, a 4.09% relative improvement over the previous state-of-the-art baselines. For kernel methods, our approach achieves better performance on most datasets. When compared to supervised baselines individually, our model outperforms Gcn in 4 out of 6 datasets and outperforms Gin in 3 out of 6 datasets, e.g., a 1.64% relative improvement on Gin for the NCI1 dataset. Our approach outperforms the state-of-the-art graph contrastive learning approaches. For example, compared to SimGrace, which is one of the best SOTA methods, Galopa has a relative improvement of 1.63% on average across all datasets. Galopa outperforms GraphCl and InfoGraph with a relative improvement of 2.25% and 3.01% on average, respectively. To summarize, our newly proposed Galopa for graph self-supervised has achieved SOTA performance.

## Discussion

**Conclusion.** In this paper, we investigated the self-supervised graph learning problem, addressing the challenges posed by label-invariant issues in contrasting graph learning. Unlike existing methods that adopt contrastive or distance-based regularization approaches, we propose a novel paradigm based on optimal transport for self-supervised graph learning. Our approach focuses on aligning optimal transport plans between the graph space and the representation space. By aligning the transport plans, our method enforces the backbone model to learn representations that precisely preserve the matching relationships in the original graph space. Our observations reveal several noteworthy findings: (i) The optimal transport plan serves as a more informative calibration signal for the encoder compared to the transport distance, capturing essential characteristics; (ii) It is feasible to utilize only node attributes as a correction signal for the backbone model, without relying on edge information; (iii) Our proposed graph self-supervised model eliminates the need to distinguish between positive and negative samples and overcomes the label-invariant assumption; Furthermore, extensive experiments conducted on multiple benchmark datasets demonstrate the state-of-the-art performance of our proposed framework in terms of generalizability and robustness.

**Limitations and Future Work.** Although the transport plan opens the door for direct communication between the input graph space and the output representation space, it also becomes a computational bottleneck for the model to some extent due to the limitation of optimal transport computation complexity. To reduce the time complexity, we can utilize the properties of the proposed model and/or the scaling optimal transport techniques that can reduce the time complexity from cubic to square or even to linear, we provide 4 ways to do this below: (i) Unlike general OT settings, where the two graphs are typically quite different and the matching relationship between them is completely unknown, the difference between the original and augmented graphs in Galopa is quite small and the matching relations for subgraph components except with different part (i.e., complementary set of difference part) is known. This means that we can utilize the _matching prior_ to reduce the computational cost. Hence, we can split the difference part with its neighborhood from the two graphs and compute the optimal transport plan only for that part. Since the percentage of that part is very small, it can greatly reduce the time complexity; (ii) According to the observation in Section 6, we can avoid the cubic complexity of optimizing GW by using only the node attributes for computing the optimal plan in graph space, while retaining similar performance with near-square time complexity; (iii) Alternatively, we can reduce the computational cost by utilizing sparsity  or graph partitioning . In particular, we can employ the most recent work on linear optimal transport , which computes FGW term and/or Wasserstein term in linear time; (iv) We have the option to combine the aforementioned methods. For instance, by merging insights from the first point, a significant portion of subgraph pairs acquired via graph partitioning in the third point turns out to be identical. This realization can further pare down the complexity of partitioning methods.

As the main goal of this paper is to propose an alternative self-supervised graph learning paradigm beyond the label-invariant assumption that accurately links/communicates the input and output spaces, we leave the scalability issue as our future work.