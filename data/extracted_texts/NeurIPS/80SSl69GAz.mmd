# SwitchHead: Accelerating Transformers with Mixture-of-Experts Attention

Robert Csordas\({}^{1}\) Piotr Piekos\({}^{2}\) Kazuki Irie\({}^{3}\) Jurgen Schmidhuber\({}^{2,4}\)

\({}^{1}\)Stanford University, Stanford, CA, USA

\({}^{2}\)AI Initiative, KAUST, Thuwal, Saudi Arabia

\({}^{3}\)Center for Brain Science, Harvard University, Cambridge, MA, USA

\({}^{4}\)The Swiss AI Lab IDSIA, USI & SUPSI, Lugano, Switzerland

rcsordas@stanford.edu, piotr.piekos@kaust.edu.sa,

kirie@fas.harvard.edu, juergen@idsia.ch

Work done at IDSIA.

###### Abstract

Despite many recent works on Mixture of Experts (MoEs) for resource-efficient Transformer language models, existing methods mostly focus on MoEs for _feedforward_ layers. Previous attempts at extending MoE to the _self-attention_ layer fail to match the performance of the _parameter-matched_ baseline. Our novel SwitchHead is an effective MoE method for the _attention layer_ that successfully reduces both the compute and memory requirements, achieving wall-clock speedup, while matching the language modeling performance of the baseline Transformer. Our novel MoE mechanism allows SwitchHead to compute up to 8 times fewer attention matrices than the standard Transformer. SwitchHead can also be combined with MoE feed-forward layers, resulting in fully-MoE "SwitchAll" Transformers. For our 262M parameter model trained on C4, SwitchHead matches the perplexity of standard models with only 44% compute and 27% memory usage. Zero-shot experiments on downstream tasks confirm the performance of SwitchHead, e.g., achieving more than 3.5% absolute improvements on BliMP compared to the baseline with an equal compute resource.1

## 1 Introduction

Large language models (LLMs) have shown remarkable capabilities [1; 2; 3; 4] and great versatility . However, training large Transformers [6; 7] requires a considerable amount of computing power and memory, which is not accessible to most researchers, academic institutions, and even companies.

Figure 1: A schematic representation of SwitchHead. It consists of a few independent heads, each with multiple experts for value and output projections. Each head has a single attention matrix.

Even running them in inference mode--typically much less resource-intensive--requires significant engineering effort . Accelerating Transformers remains an important research question.

In this context, Mixture of Experts (MoE) layers [9; 10; 11] have become popular to efficiently scale up Transformers to a large number of parameters [12; 13; 14; 15; 16; 17]. However, most of these works mainly focus on applying MoE to the 2-layer _feedforward blocks_, i.e., the multi-layer perceptron (MLP) components of the Transformer, while keeping the self-attention layers unchanged. Given that attention also accounts for a considerable amount of compute and memory usage in Transformers (especially for long context sizes), using _MoE for attention_ has potential to further improve resource efficiency in Transformers. While MoE-based attention remains underexplored in general, there are existing works on MoE approaches for attention [18; 19]. However, in practice, previously proposed methods typically require a lot of engineering tricks for successful training, _and_ most importantly, only achieve a modest reduction in computing and memory requirements in the end (as we also confirm in our experiments).

Here, we present a novel MoE-based attention method, SwitchHead, whose mechanism allows to reduce the number of attention matrices that need to be computed and stored. Following \(\)-MoE , our method uses a non-competitive selection activation function (sigmoid), and does not require regularization or extra tricks for stable training. Importantly, we show that it is possible to compute the MoE projections _outside_ of the attention core, which enables a significant reduction in the number of computed attention maps, resulting in significant resource savings. Our thorough investigation shows that it is enough to choose the value and output projections from a pool of experts and share keys and queries between them.

We evaluate our method on C4 , Enwik8 , peS2o  and Wikitext 103 , with two model sizes (47M and 262M). Additionally, we measure the zero-shot performance of our main models on Lambda , BLiMP , and Children's Books Test  datasets. Our experiments demonstrate that SwitchHead can achieve performance comparable to parameter-matched baselines with just a fraction of the compute and memory budget. In addition, we introduce "SwitchAll", a fully MoE-based Transformer model, that combines a \(\)-MoE-based MLP layer with our SwitchHead attention, often outperforming dense baselines with the same parameter budgets.

Finally, we analyze the attention maps of our SwitchHead. We find that the attention maps taken over all heads are qualitatively similar to the dense baselines, indicating a significant reduction in redundancy without a loss of expressivity. In addition, expert selections are often interpretable.

## 2 Method

### Background

The standard multi-head self-attention (MHA) layer  consists of four major steps: (1) compute key, query, and value projections, (2) compute the attention matrix, (3) use the attention matrix to project the values, and (4) map the projected values to the output. Let \(h\), \(T\), \(n_{}\), \(d_{}\), \(d_{}\) denote positive integers. Let \(^{T d_{}}\) denote an input to the MHA layer with \(n_{}\) heads, \(T\) be the sequence length, and \(d_{}\) denote the size of the hidden representations of the model. \(_{\{K,V,Q\}}^{h}^{d_{} d_{}}\) are the projection matrices for head \(h\{1,...,n_{}\}\). Then \(^{h}=_{K}^{h}\), \(^{h}=_{Q}^{h}\), and \(^{h}=_{V}^{h}\) (thus \(^{h},^{h},^{h}^{T d_{}}\)) are the keys, queries, and values, respectively. The attention matrix for the head \(h\), \(^{h}^{T T}\), and the output \(^{T d_{}}\) are calculated as follows:

\[^{h} =(}}}^{h}^{h})\] (1) \[ =(^{1}^{1}|^{2}^{2}|...|^{n_{}}^{n_{}})_{O}\] (2)

where \(|\) denotes concatenation in the last dimension, the \(()\) is also over the last dimension, and \(_{O}^{n_{}d_{} d_{}}\). However, an alternative formulation reflects the role of \(_{O}\) better. Let us divide \(_{O}\) along the first dimension into submatrices for each head, \(_{O}^{h}^{d_{} d_{}}\), such that \(_{O}=(_{O}^{1}|_{O}^{2}|...|_{ O}^{n_{}})^{}\). In this case, the output (Eq. 2) can be equivalently written as:

\[=_{h}^{h}^{h}_{O}^{h}\] (3)From this, it can be seen that all computations are local to each head. Computing the attention matrix \(^{h}\) and the readout \(^{h}^{h}\) requires compute in order of \(O(n_{}d_{}T^{2})\) MACs (multiplication-accumulation operation2). During training, it requires the storage of \(O(n_{}T^{2})\) for the attention matrices and \(O(n_{}Td_{})\) for storing the sub-results of the projections. Given a sufficiently long sequence, computing the attention matrix and projecting the values will dominate the compute requirements due to the quadratic dependence on the sequence length \(T\).

### From Dense to SwitchHead Attention Layer

Our goal is to obtain resource reductions while maintaining the fundamental properties of attention and retaining a fully expressive attention matrix. For that, we start from the following observation: modern LLMs use tens of heads [2; 27]. Are so many of them all necessary? As we show later in Sec. 3, indeed, naively reducing the number of heads (while keeping the same number of parameters by increasing the head dimension) results in performance loss. Explaining the reason for the need for many heads is beyond the scope of this paper. Nevertheless, here are some hypotheses: (1) they provide multiple inputs for the operations that the network performs in each step, (2) they are specialized and provide inputs only for specific operations (in this case, each operation would use a different subset of heads), (3) they may provide diverse outputs due to different initializations, some being more successful than others, thus enabling better learning. Among these, (2) and (3) may offer an opportunity for resource savings: if not all heads are needed at the same time, it might be possible to _switch_ among them depending on the context.

One naive method to achieve this is to use a gating signal using a linear projection \(_{S}^{d_{} n_{}}\), and use the heads with the highest score, by replacing Eq. 3 with Eq. 6:

\[ =(_{S})\] (4) \[ =(,k),\{1,...,n_{ }\}\] (5) \[[t,c] =_{h}[t,h](^{h}^{h}_{O }^{h})[t,c]\] (6)

where \([t,c]\) denotes indexing the specific element of the output matrix \(^{T d_{}}\), for timestep \(t\) and channel \(c\), and \(k\) is the number of active experts. Following the \(\)-MoE method , we use a non-competitive selection function (sigmoid \(\) in Eq. 4). Now, let us define the _source_ side of attention as the keys and values and the _destination_ side as the queries and output. Intuitively, the above method corresponds to choosing a subset of attention heads based on the _destination_ side alone3. Our preliminary experiments confirmed that this method is indeed feasible for language modeling on WikiText-103. However, it is difficult to achieve acceleration and memory savings with this method. To see why, notice that the entries of the attention matrix \(^{h}\) depend on _pairs_ of tokens, one for the source and one for the destination side, but the choice is made _only_ based on the destination side. Thus, in the worst case, for each destination, a different source might be chosen, in which case all possible source projections have to be computed for the keys and values, which we would like to avoid.

Alternatively, we propose to improve the method above by introducing conditional computations for the source and destination projections independently of each other. That is, we parameterize each of key, query, value, output projection by an independent MoE. This avoids conditional computations that involve the attention matrix itself. Our solution implements this using Mixtures of Experts (MoEs). The concepts of "heads" are no longer well defined in the conventional sense: we redefine a head as an instance of a computed attention matrix. We call the total number of them \(n_{}\). For each head \(h\), we define a separate list of \(E\) experts. The total number of _experts_ is then \(n_{} E\). Then, the projection matrices become \(_{K}^{h,e}\), \(_{Q}^{h,e}\), \(_{V}^{h,e}\) and \(_{O}^{h,e}^{d_{} d_{}}\), where \(h\) denotes the head index and \(e\) the specific expert. Then we compute the source-side expert selection as follows:

\[_{S}^{h} =(_{S}^{h})\] (7) \[_{S}^{h} =(_{S}^{h},k),_{S}^{h} \{1,...,E\}\] (8)where \(^{h}_{S}^{d_{}} E}\). We compute the destination-side experts similarly: \(^{h}_{D}=(^{h}_{D})\), \(^{h}_{D}=(^{h}_{D},k),^{h} _{S}\{1,...,E\},^{h}_{D}^{d_{}}  E}\). Then, the value projection \(^{h}\) is computed as a weighted sum of the selected experts:

\[^{h}=_{e^{h}_{S}}^{h}_{S}[e]^{h,e}_{ V}\] (9)

The key and query projections are computed similarly: \(^{h}=_{e^{h}_{S}}^{h}_{S}[e]^{h,e}_{ K}\), and \(^{h}=_{e^{h}_{D}}^{h}_{D}[e]^{h,e}_{ Q}\). The output projection also becomes an MoE:

\[=_{h=0}^{n_{}}-1}_{e^{h}_{D}} ^{h}_{D}[e]^{h}^{h}^{h,e}_{O}\] (10)

As we'll show, it is not necessary to make all projections MoEs. In Section 3.1 we show that keeping a single, head-specific copy of the query and key projections and reusing them for all experts is beneficial. We call this method SwitchHead.

Essentially, SwitchHead reduces the number of attention matrices that have to be computed (\(n_{}\)) significantly, by using multiple experts per head. Note that our method does not depend on the specific implementation of the attention, allowing for easy experimentation and research. A schematic representation is shown in Figure 1.

## 3 Experiments

We conduct our experiments in a _parameter-matched_ setting  which better reflects the task of language modeling (than the FLOPS-matched setting often used to evaluate MoEs). Our main experiments use Transformer XL, because we found them to consistently and significantly outperform RoPE-based baselines  for a fixed amount of compute. We provide the details of this analysis in Appendix A.4. The conclusions on the effectiveness of SwitchHead are consistent in both cases.

As an important specification, under this parameter-matched setting, we always configure Switchhead such that it _matches the perplexity_ of the baseline dense Transformer, and we _maximize its resource reductions_. For this, we follow a systematic procedure. First, we set \(n_{}}*E\) to be the same as \(n_{}}\) of the dense baseline. We start with setting \(n_{}}=2\) and \(k=2\), which provide the most resource reductions. If the resulting model underperforms, we increase \(k\). If \(k=4\) underperforms as well, we set \(n_{}}=4\) and \(k=2\). We always set \(d_{}}\) so that the total number of parameters of the resulting model matches the number of parameters of the baseline. This reasonably simple procedure ensures a good amount of resource savings, while avoiding doing an expensive hyperparameter search.

   \#total params & Model & \(n_{}}\) & Perplexity \(\) & MACs & Mem (floats) \\ 
47M & SwitchHead & 2 & 12.27 & 170.4M & 0.8M \\  & Transformer & 10 & 12.31 & 453.4M & 3.5M \\  & MoA & 4 & 12.60 & 223.5M & 1.3M \\  & MoA & 6 & 12.64 & 306.8M & 1.9M \\  & MoA & 8 & 12.77 & 390.2M & 2.6M \\  & MoA & 2 & 12.84 & 140.1M & 0.7M \\ 
262M & MoA & 8 & 9.50 & 2.9G & 9.9M \\  & SwitchHead & 2 & 9.55 & 2.0G & 2.9M \\  & Transformer & 16 & 9.66 & 5.4G & 21.0M \\  & MoA & 12 & 9.68 & 4.1G & 14.7M \\  & MoA & 4 & 9.69 & 1.7G & 5.1M \\  & MoA & 2 & 9.87 & 1.1G & 2.7M \\   

Table 1: Performance of SwitchHead compared to different MoA variants. MoA can outperform the baseline, but only at a price of using significantly more compute and memory. Also, SwitchHead outperforms the baseline dense Transformer. These results are on Wikitext 103. Table sorted by model perplexity.

Note that all the perplexity gains seen in the main result tables are the byproduct of imperfect matching, and our goal is to achieve _reductions in resource requirements_, unless noted otherwise (See Sec. 3.5). Detailed hyperparameters of all our models can be found in Sec. A.5 in the Appendix. We use and adopt the Triton kernel of \(\)-MoE  for our purposes.

For all datasets except the character-level Enwik8 , we use sub-word units [29; 30] obtained with a SentencePiece tokenizer  with a vocabulary size of 8k tokens. For most of our experiments, we use Transformer XL  with the context size being twice the size of the active/current chunk, because we found it to be significantly more resource-efficient than the standard setup. However, in order to show that our method is also competitive in the standard Transformer with RoPE positional ecodings, we also demonstrate our main findings in this setup (Appendix A.4).

All models are trained for 100k batches. Some of the datasets we consider (C4 , and peS2o ) are much larger. In this case, we train on the first \(10^{5}*T*N_{}\) tokens of the dataset.

### Which Projections Require an MoE?

As discussed in Sec. 2.2, each linear projection (keys, values, queries, and output) can potentially be replaced independently by an MoE. Here we first check which projection benefits from such a replacement. As we target the parameter-matched setting, using MoE where it is not necessary can have a negative effect. Since experts use a significant part of the parameter budget, they can reduce the number of parameters available for the more useful parts of the model. Thus, we did a search over all possible combinations of MoE versus fixed projections with two active heads and compared them to the parameter-matched baseline. We find that the output projection is necessary to match the performance of the baseline (for detailed results refer to Tab. 6 in the appendix). Having MoE in the key and query projections turn out to be _un_necessary. Models without the output and value MoE underperform the dense baseline with \(n_{}=2\) heads.

In sum, the best-performing model is the one using MoE for value and output projections. We use this model variant in the rest of experiments in this paper.

### Comparison with MoA

The method most related to ours is the so-called Mixture of Attention Heads, or MoA . Unlike SwitchHead, MoA uses a _single_ key and value projection and chooses \(n_{}\) active query and output projections from a pool of \(E\) experts.

MoA computes the attention map for each selected expert and computes their weighted average after the attention computation takes place. In contrast, SwitchHead calculates the weighted average of the \(K\) selected experts _before_ and _after_ attention computation. Because of this, in practice, the same perplexity is achieved with the required number of computed attention matrices (\(n_{}\)) which is much lower for SwitchHead compared to MoA, allowing significant resource savings.

Also, unlike MoA, SwitchHead uses a non-competitive activation function (sigmoid) . We confirm that with this, our method performs well without any regularization, while MoA requires three different regularizers.

We compare our method with MoA in Table 1. It can be seen that while MoA can slightly outperform our method in terms of perplexity, it can only do so at the price of significantly more resource usage. Given a similar computation and memory budget, our method consistently outperforms MoA.

### Performance on Different Datasets

We test our methods on a diverse set of language modeling datasets, including C4 , Enwik8 , peS2o , at two different scales: a 47M and a 262M parameters. We chose this experimental setting taking into account our compute-budget and confidence in our results which are consistent in across various configurations.

The results are shown in Table 2. We compare our models to two baselines: one with the same number of heads as the total number of experts (\(n_{} E\)) of the SwitchHead models, and the other has the same number of heads as the number of active attention matrices (\(n_{}\)) as our models. Ourmodels closely match the performance of the full, many-head baseline with the fraction of memory and compute requirements (see Sec. 3.7 for more details).

In addition, we verify the performance of our models trained on the C4 dataset downstream tasks in a zero-shot manner. We consider Lambada , BLiMP  and Children's Book Test (CBT) . The results are shown in Table 4: our SwitchHead models consistently outperform or match the performance of the baseline dense Transformer models.

### SwitchAll

The goal of achieving more resource-efficient Transformers includes reducing the resource requirements of both the MLP and the attention layers. \(\)-MoE  was recently proposed as a parameter-efficient MoE method for accelerating the MLP layers. However, it remains unclear whether it can be efficiently combined with our SwitchHead, or can have some negative interaction effect if combined in a "SwitchAll", where every layer is MoE-based.

To verify this, we take the baseline architecture of Csordas et al.  without any hyperparameter change and replace the attention layer with SwitchHead. The hyperparameters for the attention are directly taken from the experiments shown in Tab. 2. The results are shown in Tab. 3. The combined, fully-MoE model often outperforms the dense baselines for each dataset and model size considered, except in the case of the 262M parameter model on the C4 dataset.

### MAC-Matched Setup

All our experiments so far were calibrated so that the predictive performance (perplexity) matches to the performance of the baseline Transformer, and we were aiming for maximum resource savings. However, it is also a valid question to ask what is the performance of SwitchHead in a MAC-matched setup, where the compute requirements of our model are matched to those of the baseline. We achieve this by increasing \(d_{}\) and \(n_{}\) until we have the same MAC requirements as the baseline. This results in a model with more parameters. For the small Transformer XL, we increase \(d_{}\) from \(76\) to

   Dataset & \#total params & Model & \(n_{}\) & ppl/bpc \(\) & MACs & Mem (floats) \\  C4 & 47M & SwitchHead & 2 & 22.53 & 203M & 0.8M \\  & & Transformer & 10 & 22.71 & 453M & 3.5M \\  & & Transformer & 2 & 23.71 & 453M & 1.4M \\   & 262M & SwitchHead & 4 & 16.23 & 2.4G & 5.6M \\  & & Transformer & 16 & 16.28 & 5.4G & 21M \\  & & Transformer & 4 & 17.09 & 5.4G & 8.4M \\  Wikitext 103 & 47M & SwitchHead & 2 & 12.31 & 170M & 0.8M \\  & & Transformer & 10 & 12.32 & 453M & 3.5M \\  & & Transformer & 2 & 12.73 & 453M & 1.4M \\   & 262M & SwitchHead & 2 & 9.77 & 2.0G & 2.9M \\  & & Transformer & 16 & 9.80 & 5.4G & 21M \\  & & Transformer & 2 & 10.09 & 5.4G & 6.3M \\  peS2o & 47M & Transformer & 10 & 12.83 & 453M & 3.5M \\  & & SwitchHead & 2 & 12.84 & 203M & 0.8M \\  & & Transformer & 2 & 13.37 & 453M & 1.4M \\   & 262M & Transformer & 16 & 9.78 & 5.4G & 21M \\  & & SwitchHead & 4 & 9.86 & 2.4G & 5.6M \\  & & Transformer & 4 & 10.11 & 5.4G & 8.4M \\  Enwik8 & 41M & Transformer & 8 & 1.10 & 1.6G & 10M \\  & & SwitchHead & 2 & 1.10 & 709M & 2.8M \\  & & Transformer & 2 & 1.13 & 1.6G & 4.2M \\   

Table 2: Performance of SwitchHead compared to baselines on different datasets and model sizes. It can be seen that the predictive performance of our SwitchHead model is comparable to the baselines, and is always better than the baseline with an equal number of heads. Perplexity is shown for Wikitext 103, C4 and peS2o datasets, and bits/character (bpc) for Enwik8. Models sorted by perplexity.

\(112\) and \(n_{}\) from 2 to 3. For large XL, we increase \(n_{}\) from 4 to 6 and \(d_{}\) from 112 to 168. For the small RoPE model, we change \(n_{}\) from 2 to 3 and \(d_{}\) from 64 to 84, for big \(n_{}\) from 4 to 6 and \(d_{}\) from 112 to 168. We show the results in Tab. 4: MAC-matched models outperform the others by a large margin both in perplexity and in zero-shot task performance.

### Shared Selection

For further time savings, we can share the expert selection between the source and destination side. Acceleration is achieved by reducing the number of sorting and top-k steps compared to the full SwitchHead. However, this results in a minor performance loss, which might be tolerated in some cases where the acceleration is more important. See Tab. 4 for more details.

### Wall-Clock Time and Memory Usage Estimation

In all of our tables, we report the number of multiply-accumulate (MAC) operations following Zhang et al. . The reason for this is that the actual wall-clock time is highly implementation and hardware-dependent. Nevertheless, we measured the runtime and total memory usage of our entire training pipeline (including the feedforward layer) to demonstrate that our current (suboptimal) implementation is already capable of providing wall-clock time acceleration. We show the results in Tab. 5. The measurements are taken on identical hardware with the same implementation (including for the attention core), the only difference being the MoE-based projections for the attention. It can be seen that for both scales, SwitchHead trains around 1.5 times faster, while using 61%-67% as much memory as the baseline.

We also report the performance of MoA for reference in Table 5. For measuring the resource usage of MoA, we chose the fastest MoA model that can match the performance of the dense baseline, or simply the best MoA model when no MoA model can match the baseline performance. This resulted in choosing MoA with \(H=4\) for the 47M model and MoA with \(H=8\) for the 262M parameter model. SwitchHead outperforms MoA on both scales, both in wall clock time and memory requirements. Note that these measurements also include the MLP layers, the optimizer, and the gradient synchronization in the case of multi-GPU training.

## 4 Analysis

In order to see how the network uses the attention heads, we trained a small, 6-layer, 8-head Transformer on ListOps [33; 34]. The reason for this choice is that small, algorithmic tasks tend to be more interpretable compared to language modeling tasks. We also train a parameter-matched, 2-head

   Dataset & \#total params & Model & \(n_{}\) & ppl \(\) & MACs & Mem (floats) \\  Wikitext 103 & 47M & SwitchAll & 2 & 12.17 & 170M & 0.8M \\  & & Transformer & 10 & 12.32 & 453M & 3.5M \\   & 262M & Transformer & 16 & 9.80 & 5.4G & 21M \\  & & SwitchAll & 4 & 9.81 & 2.4G & 5.6M \\  C4 & 47M & SwitchAll & 2 & 22.09 & 202M & 0.8M \\  & & Transformer & 10 & 22.63 & 453M & 3.5M \\   & 262M & SwitchAll & 4 & 16.45 & 2.4G & 5.6M \\  & & Transformer & 16 & 16.58 & 5.4G & 21M \\  peS2o & 47M & SwitchAll & 2 & 12.56 & 202M & 0.8M \\  & & Transformer & 10 & 12.83 & 453M & 3.5M \\   & 262M & Transformer & 16 & 9.78 & 5.4G & 21M \\  & & SwitchAll & 4 & 9.86 & 2.4G & 5.6M \\   

Table 3: Performance of SwitchAll (SwitchHead + \(\)-MoE ) on different datasets and model sizes. Our SwitchAll model is close or better compared to the baselines. Models sorted by perplexity. Note: We show the parameter count of the dense model. The parameter count for the big SwitchAll model is 259M because of the imperfect parameter matching.

SwitchHead model. Both models achieve around 95% accuracy on a held-out IID validation set, in contrast to the dense 2-head model, which saturates around 80%. Note that ListOps is a classification task and does not use autoregressive masking.

We visualize the maximum of attention heads for each layer, both for the standard Transformer (Fig. 1(a)) and SwitchHead (Fig. 1(b)). The attention maps are qualitatively similar. Due to different initialization and learning dynamics, thus the overlap between the two models would not be perfect. Complete attention map visualizations can be found in Fig. 4 and 3 in the appendix.

In addition, we anlyze individual attention heads for SwitchHead. We find that it is often possible to interpret the selection weights: on synthetic tasks, the output experts specialize according to different _operations_, while the input ones distinguish numbers and closed parentheses. The attention map itself appears to distribute information about contiguous chunks of numbers (see Fig. 5 in the appendix).

Attention maps of the language models are more difficult to interpret. However, we visualize the attention maps of the 47M parameter Transformer XL and the SwitchHead model from Tab. 2. We find them to be qualitatively similar. We also identified induction heads  in both models, some examples shown for SwitchHead in Fig. 5(a) and for Transformer in Fig. 5(b) in the appendix. Other typical vertical line-lined attention patterns are shown in Fig. 5(c) and 5(d).

## 5 Related Work

The method most closely related to ours is MoA , which introduces a MoE style attention. It defines each attention head as an expert but shares the key and value projections between them. Unlike in our Switchhead, each of the selected experts requires a separate attention matrix, which significantly increases its memory usage. Due to the use of a competitive softmax-based activation function in the selection network, it requires complex regularization to prevent expert collapse . In the original formulation, the number of active heads is high. Our experiments also confirm that MoA needs many attention heads to match the performance of the dense baseline (see Sec. 3.2), and it is only possible to do so with a significantly higher resource budget than our method.

Nguyen et al.  analyze the attention matrices, and they conclude that they are usually low rank. Motivated by this, the authors construct a few (e.g., 2) "global attention matrices", and they compute each local matrix for specific heads by a weighted average of those. However, they average the logits,

   Model & \#total params & ppl \(\) & Lambada \(\) & BLiMP \(\) & CBT \(\) \\  SwitchHead & 47M & \(22.53\) & \(20.4\%\) & \(75.7\%\) & - \\ Transformer & 47M & \(22.71\) & \(20.4\%\) & \(73.6\%\) & - \\ SwitchHead MAC-matched & 63M & \(21.18\) & \(23.5\%\) & \(77.1\%\) & - \\ SwitchHead Shared selection & 47M & \(22.81\) & \(20.0\%\) & \(74.6\%\) & - \\  SwitchHead & 262M & \(16.23\) & \(29.4\%\) & \(79.6\%\) & \(83.3\%\) \\ Transformer & 262M & \(16.28\) & \(28.2\%\) & \(76.1\%\) & \(83.6\%\) \\ SwitchHead MAC-matched & 376M & \(15.43\) & \(30.2\%\) & \(79.4\%\) & \(84.2\%\) \\ SwitchHead Shared selection & 262M & \(16.49\) & \(28.6\%\) & \(79.4\%\) & \(82.7\%\) \\   

Table 4: Performance of SwitchHead trained on C4 dataset, compared to dense Transformer baseline with matched number of parameters.

   Size & Model & ms/iteration & Rel. iter. time & RAM/GPU & Rel. Mem. & \#GPUs & GPU type \\   & Transformer & 473ms/iter & 1.0 & 20.5G & 1.0 &  &  \\  & SwitchHead & 342ms/iter & **0.72** & 13.5G & **0.65** & & \\  & MoA & 412ms/iter & 0.87 & 15.3G & 0.75 & & \\   & Transformer & 670ms/iter & 1.0 & 20.5G & 1.0 &  &  \\  & SwitchHead & 442ms/iter & **0.65** & 12.5G & **0.61** & & \\   & MoA & 851ms/iter & 1.27 & 16.4G & 0.80 & & \\   

Table 5: Real-world resource usage of our method. The numbers shown below are for training time for the whole pipeline, including the feedforward layers. It can be seen that SwitchHead in the current implementation reduces both the runtime and the memory usage by a factor of 1.4-1.5.

not the final matrix, so each individual head-specific matrix has to be computed. This means that in the best case, they can only save half of the computation associated with the attention matrix because the readout (Eq. 3) is still needed. For the same reason, memory savings are also low.

Peng et al.  propose to reweight the contribution of each head by a gating function. However, they only reduce the number of total attention heads by one, presumably to compensate for the parameters used by the selection logic. Their goal was not to reduce resource usage but to have better predictive performance, which they achieve. They use a softmax-based competitive selection mechanism. To avoid collapse, the gating function is trained only in some steps.

More broadly, there have been several works on MoE to accelerate language models. Shazeer et al.  introduce sparsely-gated mixture of experts. Fedus et al.  introduce Mixture of Experts in Transformers. Lepikhin et al.  train a MoE-based LLM, and Clark et al.  analyze the scaling laws of MoE models. Lewis et al.  introduce an alternative method for preventing collapse. However, none of these methods focus on the important, _parameter-matched_ setting. Csordas et al.  introduce the non-competitive activation based MoE method, \(\)-MoE, which was shown to be successful in such a setting, but the authors only focused on accelerating the MLPs and not the attention.

Multi-Query attention  uses a single key and value projection that is shared between the heads while using multiple queries. Our findings show that such a configuration is suboptimal: using multiple output and value projections is the most important choice in our model design.

Dao et al.  provides a hardware-aware CUDA implementation of the entire attention layer, which avoids storing the attention matrix. By saving memory bandwidth in this way, they achieve a significant wall clock time speedup, despite that the attention matrix should be recomputed in the backward pass. This is orthogonal to our method and they can be combined for further acceleration.

## 6 Limitations

Our models are modest in size compared to the current state-of-art LLMs. However, training such models is estimated to cost millions of dollars, which we cannot afford. Instead, we aim to show the versatility of our model by choosing a diverse set of datasets, including Enwik 8, Wikitext 103, C4 and peS2o, and different positional encodings, such as Transformer-XL-style relative positional encoding and RoPE. We also demonstrate the competitiveness of our models in zero-shot downstream tasks. We believe that the evidence we provided is enough for a research group with a larger amount of resources at their disposal to verify our findings in a state-of-the-art model.

Figure 2: An attention map of the (a) standard Transformer and (b) SwitchHead. The maximum of all heads in the given layer are shown.

The Triton kernel that we used is currently around 60% of the speed of a single dense matrix multiplication of the size of a single expert with cuBLAS. Even this, we showed wall-clock time speedup. We estimate that 80-90% should be achievable with a more optimal kernel. Model-parallel training requires the implementation of a load-balancing system that can dynamically move experts between GPUs.

## 7 Conclusion

On a wide range of language modeling datasets with different model sizes, our novel Mixture-of-Experts (MoE) based attention method called SwitchHead achieves performance of parameter-matched dense counterparts, with only a fraction of the computational cost and memory usage. SwitchHead drastically reduces the number of attention matrices that have to be computed, by using MoE for the value and output projections. Our method is stable and does not need additional regularization to prevent degenerate solutions (a well-known practical issue in many existing MoE models). Our method can also be successfully combined with MoE MLP layers, to obtain "SwitchAll" where every layer of the Transformer is MoE-based, achieving a huge reduction in resource requirements.