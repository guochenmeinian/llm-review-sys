# Triple Eagle: Simple, Fast and Practical

Budget-Feasible Mechanisms

 Kai Han

School of Computer Science and Technology

Soochow University, P.R.China

hankai@suda.edu.cn

&You Wu

School of Computer Science and Technology

Soochow University, P.R.China

20235227129@stu.suda.edu.cn

He Huang

School of Computer Science and Technology

Soochow University, P.R.China

huangh@suda.edu.cn

&Shuang Cui

School of Computer Science and Technology

University of Science and Technology of China

lakers@mail.ustc.edu.cn

Kai Han is the corresponding author (Email: hankai@suda.edu.cn).

###### Abstract

We revisit the classical problem of designing Budget-Feasible Mechanisms (BFMs) for submodular valuation functions, which has been extensively studied since the seminal paper of Singer [FOCS'10] due to its wide applications in crowdsourcing and social marketing. We propose TripleEagle, a novel algorithmic framework for designing BFMs, based on which we present several simple yet effective BFMs that achieve better approximation ratios than the state-of-the-art work for both monotone and non-monotone submodular valuation functions. Moreover, our BFMs are the first in the literature to achieve linear complexities while ensuring obvious strategyproofness, making them more practical than the previous BFMs. We conduct extensive experiments to evaluate the empirical performance of our BFMs, and the experimental results strongly demonstrate the efficiency and effectiveness of our approach.

## 1 Introduction

In the celebrated Influence Maximization (IM) problem (e.g., [19; 21; 27]) an advertiser needs to select some "seed users" in a social network, such that the influence spread caused by "Word-of-Mouth" propagation is maximized. However, the users may want some rewards for serving as seeds and also behave strategically to maximize their utilities. So the advertiser has to pay the users under some budget \(B\) and ensure their _truthfulness_, besides maximizing the influence spread . Another similar problem arises in crowdsourcing markets (e.g., Amazon's Mechanical Turk ), where a crowdsourcing task owner needs to hire some strategic workers to perform a crowdsourcing task and pay them under a budget, with the goal of maximizing the crowdsourcing revenue [4; 25; 37; 38].

Motivated by the above applications, Singer  initiates the studies on _budget-feasible mechanism design_, where a buyer needs to select a set \(S\) of strategic sellers with private costs from a ground set \(\) with \(||=n\) and pay them under a budget \(B\), such that the valuation \(f(S)\) is maximized while ensuring that the sellers report their private costs truthfully. Singer  considers a _monotone and submodular_ valuation function \(f()\) and adopts a _value oracle_ model where \(f(X)\) can be obtained for all \(X\). Following Singer 's work, a lot of BFMs have been proposed; almost all of the theoretical studies in this line put their emphasis on improving the approximation ratios of the proposed BFMs (as elaborated in Sec. 1.1), and many studies have applied BFMs to variousapplication scenarios such as mobile crowdsensing, federated learning, experimental design, social advertising, vehicle sharing, data pricing, team formation, cellular traffic planning, and so on.

### Main Results of the Related Work

There exist BFMs concentrating on different valuation functions including (monotone or non-monotone) submodular functions, additive, XOS and subadditive functions. We review them separately in the following.

**BFMs for monotone submodular valuation functions:** Singer  proposes a 117.7-approximation BFM. Chen et al.  improve the work of  by proposing a 7.91-approximation BFM, and they also propose a lower bound of 2 (resp. \(+1\)) for the approximation ratio of any randomized (resp. deterministic) BFM for submodular valuation functions. Jalaly and Tardos  further propose an improved 5-approximation BFM. It is noted that all the above mentioned BFMs are randomized and incur a polynomial number (at least \((n^{2})\)) of value oracle queries. The studies of  also propose BFMs with exponential time complexity, among which the randomized BFM proposed by  achieve the best ratio of 4. Recently, Balkanski et al.  propose the first deterministic BFM with polynomial running time, which achieves a ratio of 4.75 by using \((n^{2} n)\) value oracle queries, and they also show a lower bound of 4.5 for the ratio of their proposed BFM.

Observing the large number of participants in some BFM applications such as crowdsourcing, some studies  have also considered a "large market" model where the additional assumptions of \(}{B} 0\) or \(}{} 0\) are made, with \(c_{max}\) (resp. \(v_{max}\)) denoting the maximum cost (resp. valuation) of any single element. Under these assumptions, Anari et al.  and Jalaly and Tardos  show that there exist 3-approximation and 2.58-approximation BFMs using \((n^{2})\) and \((n^{6})\) value oracle queries, respectively. However, their time complexity still can be too high for large markets, and the additional assumptions mentioned above may not always hold. For example, in the influence maximization problem, the advertiser's budget could be relatively small even though the social network has billion-scale, so \(}{B} 0\) may not be true. Therefore, in this work we will consider the original BFM model of .

**BFMs for non-monotone submodular valuation functions:** When the valuation function is non-monotone and submodular, Amantidis et al.  propose a 505-approximation BFM leveraging the continuous greedy algorithm in , while Balkanski et al.  achieve a 64-approximation under \((n^{2} n)\) time complexity. Very recently, Huang et al.  propose a randomized BFM with an improved approximation ratio of \((3+)^{2} 27.4\) under \((n n)\) time complexity.

**BFMs for other valuation functions:** There also exist BFMs for additive valuation functions , among which Gravin et al.  achieve the best-known approximation ratios of 2 and 3 for randomized and deterministic BFMs, respectively. For subaddtive and XOS valuation functions, the work of  proposes BFMs using _demand oracle queries_, as it is known that no BFMs with polynomial number of value oracle queries can achieve any ratio better than \(n^{0.5-}\) for these valuation functions .

### Limitations of Prior Art and Our Contributions

Despite the great progress on BFM design in a dozen years as described above, the existing BFMs for submodular valuations still suffer from several major deficiencies. First, all of them have at least \((n^{2})\) query complexity, which can be impractical for large markets. Second, it is unclear whether their approximation ratios can be further improved (both for randomized and deterministic BFMs). Third, from a practical point of view, their algorithmic frameworks for achieving truthfulness still have some serious drawbacks. To understand these, we explain their techniques in the following.

The BFMs in  have used _sealed-bid auctions_ roughly described as follows: the sellers first report their costs and then are sorted according to the non-increasing order of their _densities_ (i.e., the ratios of their _marginal gains_ to costs), and finally the mechanism selects some winners with the largest densities and ensures truthfulness using Myerson's lemma . However, sealed-bid auctions have been criticized for lacking practicability , because it is hard for the players to verify truthfulness and to trust the auctioneer, resulting in strategic behaviours.

To address the issues of sealed-bid auctions, there is growing interest in designing "simple mechanisms" (e.g., ). The seminal work of Milgrom and Segal  proposes a new class of auctions dubbed _clock auctions_, where each player can be offered by multiple descending pricesand remains active only if the player accepts the last offered price, and eventually the mechanism selects some active players as the winners and pay them the last offered prices. Milgrom and Segal  indicate that clock auctions satisfy _obvious strategyproofness_ and several other properties (e.g., group strategyproofness, transparency, and unconditional winner privacy) not possessed by sealed-bid auctions. Inspired by , Balkanski et al.  propose a BFM using clock auction with the following design: they make \((_{2}n)\) guesses on \(\) using a "doubling trick" similar to that in online learning theory , and create \((_{2}n)\) candidate solutions without violating \(B\) by offering each active seller a new price for each guessed \(\), and the final winners are selected from the best candidate solutions. The clock auction BFM in  adopts a similar framework as , but uses random sampling to handle non-monotone submodular valuation functions.

Although clock auctions are considered to be more practical than sealed-bid auctions , we argue that they sometimes still lack practicability, as enquiring a player with too many descending prices may be time-consuming and cause the effect that the player loses patience and quits the auction early. We hereby propose the concept of _pricing complexity_ of clock auctions:

**Definition 1**: _The (worst-case) pricing complexity of a clock auction is the maximum number of prices it offers to any player participating in the auction._

It can be seen from above that the BFMs in  have \((_{2}n)\) pricing complexity, which could still be large for impatient sellers. In fact, Balkanski et al.  raise an open question of "whether there exist even simpler families of budget feasible mechanisms with which one can obtain constant approximations mechanisms", and prove that _posted-price mechanisms_ are insufficient for deriving a constant ratio. Note that posted-price mechanisms (e.g., ) are perhaps the simplest form of truthful mechanisms; these mechanisms show each player one "take-it-or-leave-it" price and hence have \((1)\) pricing complexity. The main difference between posted-price mechanisms and clock auctions is about how they deal with any seller \(u\) who accept the offered price: it is mandatory to select such a seller \(u\) as a winner in posted-pricing mechanisms, while clock auctions may not follow this rule (this implies that clock auctions have the additional power of use "side observations" on the other sellers' behavior to decide whether \(u\) should be a winner). However, from a practical perspective, clock auctions with low pricing complexities are almost as simple as posted-pricing mechanisms, because both of them can be efficiently implemented and can be easily understood by the players for ensuring truthfulness.

In this paper, we address all the deficiencies of the existing BFMs mentioned above by presenting TripleEagle, a novel clock auction framework that brings us several simple, fast, effective, and practical BFMs. Specifically, we show that:

* For monotone submodular functions, there exist a randomized BFM and a deterministic BFM with the approximation ratios of \(+5}{2} 4.3\) and \(2+ 4.45\), respectively; both of them use at most \((n)\) value oracle queries. This improves the best-known ratio of 4.75 in  (using \((n^{2} n)\) value oracle queries) for this long-standing problem.
* For non-monotone submodular functions, there exists a randomized BFM with an approximation ratio of \(12\), using at most \((n)\) value oracle queries. This improves the best-known ratio of \((3+)^{2} 27.4\) of the randomized BFM proposed in  using \((n n)\) value oracle queries.
* Under the assumption of  that each seller's cost is no more than \(B\), our TripleEagle BFMs offer each seller only one price; without this assumption, at most one additional price query is needed in total. Therefore, our BFMs only have \((1)\) pricing complexity, which provides a confirmative answer to the open question of Balkanski et al.  mentioned above, because TripleEagle is virtually as simple as a posted-pricing mechanism.
* We conduct extensive experiments using the applications of influence maximization and crowdsourcing. The experimental results show that, compared to the state-of-the-art BFMs proposed in , our BFMs are faster in orders of magnitude, while achieving significantly better valuations of the winning sellers.

Compared to , our TripleEagle framework has an essentially different design roughly explained as follows. Instead of offering multiple descending prices to each seller through blindly guessing \(\) as in , we adopt a pricing rule inspired by the simple yet fundamental _law of supply and demand_ in economics . Specifically, TripleEagle processes the sellers in an arbitrary order and calculates the price offered to a new "supplier" (i.e., an unprocessed seller) based on the "current supply" (i.e., the valuation of already processed sellers who accepted the offered prices). Therefore, the offered prices in TripleEagle tend to decrease when there are more sellers. Finally, TripleEagle tries to return a set of sellers with the maximum ratios of marginal gains to prices under the budget \(B\). Due to this novel design, TripleEagle only needs one scan over the sellers and offer one price to each seller, while still achieving a better approximation ratio than .

As far as we know, our work is the first attempt on reducing both the time complexity and pricing complexity of BFMs. We analogize a low pricing complexity to the "Triple Eagle" hole score in golf 2, and believe that our ideas have the potential to be applied to other clock auction problems.

## 2 Preliminaries

Following , we assume that each seller in a ground set \(\) has a private cost \(c(u) 0\) and there is a submodular valuation function defined on the power set of \(\) satisfying \( X:f(X) 0\) and

\[ X,Y:f(X)+f(Y) f(X Y)+f(X Y)\] (1)

We say that \(f()\) is monotone if \( X Y:f(X) f(Y)\), otherwise it is non-monotone. For simplicity, we call \(f(X Y) f(X Y)-f(Y)\) as the marginal gain of \(X\) with respect to \(Y\) for all \(X,Y\), and we use \(c(X)\) and \(p(X)\) (\( X\)) as shorthand for \(_{u X}c(u)\) and \(_{u X}p(u)\), respectively. We will consider clock auctions where each seller \(u\) can be offered by descending prices that are computed using public information, and we use \(p(u)\) to denote the last price offered to \(u\) at any time. When a clock auction terminates, a set \(S\) can be selected as winners only if \(p(S) B\) and each seller \(u S\) has never rejected any price offered to \(u\). The approximation ratio of \(S\) is defined as \(/f(S)\), where \(=f(O)\) and \(O\) is an optimal solution to the problem \(\{f(X):X c(X) B\}\). We will also consider randomized clock auctions: such an auction is a deterministic clock auction for every realization of all its internal random choices, and it clearly satisfies _universal truthfulness_. For the simplicity of description, we adopt the assumption made in [9; 13] that \( v:c(v) B\), and we will show how to remove this assumption later. In our algorithms, if the elements in a set \(X\) are sequentially inserted into \(X\), listed as \(\{u_{1},,u_{q}\}\) according to the order that they are inserted, then we call the subset \(Y=\{u_{s},,u_{t}\} X( s,t:1 s t q)\) as a _regular subset_ of \(A\), and also call \(Y\) a _suffix_ (resp. _prefix_) of \(X\) if \(t=q\) (resp. \(s=1\)). Throughout the paper, we use \(u^{*}\) to denote a seller in \(\) who has the maximum valuation, i.e., \(u^{*}=_{u}f(u)\).

## 3 Randomized BFM for Monotone Submodular Valuations

In this section, we consider a monotone submodular valuation function \(f()\) and provide a randomized BFM using the TripleEagle framework, as shown by Algorithm 1 (i.e., the TripleEagleRan algorithm). Algorithm 1 takes as input a parameter \(>1\) for setting a "reserve price" that will be explained shortly. In Line 1, Algorithm 1 calls the LSDPricing procedure (i.e., Algorithm 2) to process all sellers in \(\) except \(u^{*}\); each of these sellers is offered one price by Algorithm 2 and then Algorithm 2 returns a set \(A\) containing the sellers who accept their prices. After that, if \(f(A) f(u^{*})\), then Algorithm 1 calls Algorithm 2 again to process \(u^{*}\) and finally returns a suffix of \(A\) respecting the budget constraint (Lines 3-4). Otherwise, Algorithm 1 makes a random decision of returning either \(u^{*}\) or \(T\) (Lines 6-13), where \(T\) is a superset of \(A\) and is got by trying to include \(u^{*}\) by offering \(u^{*}\) a "best effort" price of \(B-p(A)\).

It can be seen that Algorithm 2 offers each seller \(u\) a price \()}\). This pricing rule is inspired by the fundamental Law of Supply and Demand (LSD) in economics , as intuitively explained in the following. First, note that \(A\) contains all the processed sellers who accept the offered prices, so \(f(A)\) can be regarded as the current "supply" in the market, thus the price offered to a new "supplier" (i.e., an unprocessed user \(u\)) should decrease with the increment of \(f(A)\). Second, the marginal gain \(f(u A)\) represents how much value the user \(u\) can contribute given the current supply \(f(A)\), so the price offered to \(u\) should increase with \(f(u A)\). Third, the factor \( f(u^{*})\) guarantees that no user can be paid a price larger than \(B/\), which can be regarded as a "reserve price" of the buyer. Without this reserve price, the winner set could have poor value due to the overpayment to some sellers.

```
1\(A(,\{u^{*}\}, f(u^{*}))\);
2if\(f(A) f(u^{*})\)then
3\(A(A,\{u^{*}\}, f(u^{*}))\);
4\(S\) the largest suffix of \(A\) satisfying \(_{u S}p(u) B\);
5
6else
7 Sample a random number \(Z\) from the uniform distribution \(\);
8if\(Z\)then
9\(p(u^{*}) B;S\{u^{*}\}\)
10else
11 Set \(p(u^{*})=B-_{u A}p(u)\) and show \(u^{*}\) the price \(p(u^{*})\);
12if\(u^{*}\) accepts \(p(u^{*})\)then\(T A\{u^{*}\}\) ;
13else\(T A\) ;
14\(S T\);
15
16 return\(S\) ```

**Algorithm 1**\(()\)

### Performance Analysis of \(\)

It is evident that Algorithm 1 provides each seller only one price and incurs \(2n\) value oracle queries (\(n\) queries for finding \(u^{*}\)). So we only analyze its approximation ratio. Let us consider the set \(A\) at the moment that Algorithm 1 finishes. For convenience, we use \(A_{u}\) to denote the set of elements already in \(A\) at the moment right before \(u\) (\( u\)) is processed. We first introduce Lemmas 1-2, which can be proved based on submodularity and the observation that each seller who accepts the offered price must have a sufficiently large density (and vice versa) due to the pricing rule of Algorithm 2.

```
1foreach\(u C\)do
2\(p(u)\); Show \(u\) the price \(p(u)\);
3if\(u\) accepts \(p(u)\)then\(A A\{u\}\) ;
4 return\(A\) ```

**Algorithm 2**\((A,C,)\)

**Lemma 1**: _For any regular subset \(X=\{u_{s},,u_{t}\}\) of \(A\) returned by Algorithm 2, we have_

\[f(X)_{v X}f(v A_{v}) p(X)})+  f(u^{*})}{B}\]

**Lemma 2**: _After Line 3 of Algorithm 1 is executed, we have \( 2f(A)+ f(u^{*})\)._

With Lemmas 1-2, we can bound the approximation ratio of Algorithm 1 if \(S\) is generated by Line 4, as shown by Lemma 3. Intuitively, if \(p(A) B\), then we have \(f(A) f(u^{*})\) due to Line 3 and hence we can use Lemma 2 to get \((2+)f(S)\) directly; if \(p(A)>B\), then \(p(S)\) is also sufficiently large, which implies \(f(S)\) is large, because \(S\) is a suffix of \(A\) and hence contains the sellers in \(A\) with the largest ratios of marginal gains to prices due to the pricing rule of Algorithm 2.

**Lemma 3**: _For any \((2,+1)\), the set \(S\) generated by Line 4 of Algorithm 1 satisfies_

\[(3+-1},2+)  f(S)\]

**Proof**: Due to Line 2, we must have \(f(u^{*}) f(A)\) when Line 4 of Algorithm 1 is executed.

Therefore, if \(p(A) B\), then we have \(S=A\) and hence

\[ 2f(A)+ f(u^{*})(2+)f(S)\] (2)due to Lemma 2. In the following, we consider the case of \(p(A)>B\). Let \(H\) be the smallest suffix of \(A\) satisfying \(p(H)>B\), so \(H S\) contains exactly one element (denoted by \(w\)) which is added into \(A\) before the elements in \(S\). Using Lemma 2 and submodularity, we get

\[  2f(A)+ f(u^{*}) 2f(S\{w\})+2f(A H)+ f(u^{*})\] (3) \[ 2f(S)+2f(A H)+(2+)f(u^{*})\]

Suppose that \(f(A H)= f(u^{*})\), \(p(w)= B\) (and hence \(p(S)>(1-)B\)) for certain \(>0\) and \(\). According to Lemma 1, we have

\[f(u^{*}) f(w A H) B)}{B}(+)f(u^{*})\] (4) \[f(S)(1-)B)}{B}(1-^{2})(+)f(u^{*})\] (5)

Let \(x=+\). We have \(\) and \(f(S)-1}{x}f(u^{*})\) due to Eqns. (4)-(5). Combining these with Eqn. (3), we get

\[  2f(S)+(2+2+)f(u^{*}) 2f(S)+ f(S)\] (6) \[= (4+)f(S)\]

Note that \(x=+>2\). The R.H.S. of Eqn (6) is no more than \(4f(S)\) when \(x\) or \(\). When \(<\) (i.e., \(<+1\)) and \(x[,)\), the R.H.S. of Eqn (6) is maximized when \(x=\). Therefore, for any \((2,+1)\) we have

\[(4++2}{^{2}-1})f(S) =(3+-1})f(S)\] (7)

Combining Eqn. (2) and Eqn. (7) completes the proof. \(\)

Next, we bound the approximation ratio of Algorithm 1 when \(S\) is generated by Lines 6-13 (using randomization), as shown by Lemma 4:

**Lemma 4**: _For any \(>2\), if Algorithm 1 returns \(S\) that is generated by Lines 6-13, then we have_

\[(2+)[f(S)]\]

**Proof**: In this case, we must have \(f(A)<f(u^{*})\) after Line 1 is executed. This implies \(p(A)<B\) because otherwise we have \(f(A) f(u^{*})\) due to Lemma 1, contradicting \(f(A)<f(u^{*})\) when \(>1\). We prove that the set \(T\) generated by Lines 10-13 of Algorithm 1 must satisfy \( 2f(T)+ f(u^{*})\) according to the following discussion:

1. \(u^{*} O\): In this case, we can use similar reasoning as Lemma 2 to get \[ 2f(A)+ f(u^{*}) 2f(T)+ f(u^{*})\] where the second inequality is due to \(A T\) according to Lines 11-12.
2. \(u^{*} O\) and \(u^{*}\) accepts the price in Line 11: In this case, we have \(T=A\{u^{*}\}\) and hence can also use similar reasoning as Lemma 2 to get \[-f(T)_{u O T}f(u A) f(A)+  f(u^{*}) f(T)+ f(u^{*}),\] which yields \( 2f(T)+ f(u^{*})\).
3. \(u^{*} O\) and and \(u^{*}\) rejects the price in Line 11: In this case, we must have \(T=A\), \(c(u^{*})>B-p(A)\) and hence \[c(O\{u^{*}\}) p(A))})}\] (8)where the second inequality is due to Lemma 1. Note that all the sellers in \(O\{u^{*}\}\) has been processed by Line 1 and each seller \(u O\{u^{*}\} A\) must reject the offered price and hence satisfy \(c(u)>p(u)\). So we can use this and Eqn. (8) to get

\[f(O\{u^{*}\})-f(A)_{u O\{u^ {*}\}}f(u A_{u})\] (9) \[= _{u O\{u^{*}\} A}p(u) )+ f(u^{*})}{B}_{u O\{u^{*} \} A}c(u))}{B}\] \[ )}(f(A)+ f(u^{*}))f(A)+f(u^{*})\]

Therefore, when \(>2\), we have

\[ f(O\{u^{*}\})+f(u^{*})(1+)f(A)+ 2f(u^{*}) 2f(T)+ f(u^{*})\] (10)

According to Lines 6-13, the algorithm returns \(T\) or \(\{u^{*}\}\) with probability of \(\) or \(\), respectively. So we get

\[[f(S)] = [S=T] f(T)+[S=\{u^{*}\}] f(u^{*})\] (11) \[= +)}{2+} {}{2+}\] (12)

which completes the proof. 

Combining Lemmas 3-4, we immediately get:

**Theorem 1**: _With \(=+1}{2} 2.3\), the Triple\(\) mechanism can return a set \(S\) satisfying \(+5}{2}[f(S)]\) by offering one price to each seller in \(\) and incurring at most \((n)\) value oracle queries._

_Remark:_ As mentioned in Sec. 2, we have adopted the assumption made in  that \( v:c(v) B\) for the simplicity of description. This assumption can be easily removed according to the following discussion. Note that each buyer is guaranteed to be offered a price no more than \(B\) in Triple\(\). Therefore, before running Triple\(\), we only need to identify a valid \(u^{*}=_{v:v c(v) B}f(v)\). This can be done by first sorting all the sellers according to the non-increasing order of their values, and then offer \(B\) to them one by one until seeing the first seller accepting \(B\) and then that seller is clearly a valid \(u^{*}\). After that, we can delete all the sellers rejecting \(B\) and then run Triple\(\). Clearly, using such a method, the complexity of our mechanism on the number of value oracle queries is still \((n)\), while only one additional price query (for \(u^{*}\)) is incurred. This method can also be used for all our mechanisms described in the sequel.

## 4 Deterministic BFM for Monotone Submodular Valuations

If we directly use the \(\) algorithm to process all the sellers in \(\), it is possible that the valuation of the sellers who accept the offered prices is no more than \(f(u^{*})\), while \(u^{*}\) rejects its price and hence cannot be selected as a winner, resulting in a poor approximation ratio (especially when \(f(u^{*})\) is large). To address this issue, we have used randomization in Triple\(\). In this section, we introduce Triple\(\) (i.e., Algoirth 3), a deterministic BFM that circumvents the aforementioned issue using an idea of "two-phase pricing", as elaborated in the following.

In the first pricing phase (Lines 2-6), Algorithm 3 constructs a set \(K\) by using the pricing rule in Line 3 to processes the sellers in \(\{u^{*}\}\); this pricing rule is a relaxation of the pricing rule in the \(\) algorithm, because the valuation of the already processed sellers is not used to lower the price for the next seller to be processed.

The first pricing phase stops as soon as \(f(K) f(u^{*})\) (Line 6). If \(f(K)\) is still less than \(f(u^{*})\) when all the sellers in \(\{u^{*}\}\) have been processed in the first pricing phase, then Algoirth 3 sets the winner set \(S=\{u^{*}\}\) (Line 8). In the case that the first pricing phase generates a set \(K\) satisfying \(f(K) f(u^{*})\), Algorithm 3 enters the second pricing phase in Line 10, where we use \(\) to process all the sellers not processed in the first phase (including \(u^{*}\)). Intuitively, since and \(K\) is a prefix of \(A\) in the second pricing phase (Line 10), we can regard \(K\) as a substitute of \(u^{*}\) and hence no longer need to worry about the issue explained in the beginning of this section.

We analyze the approximation ratio of Algorithm 3 by considering two cases. In the first case, we have \(f(K)<f(u^{*})\) or \(p(A) B\), which implies that \(S=\{u^{*}\}\) or \(S=A\) due to Line 8 and Line 11. In this case, we can directly use the two-phase pricing rules to bound the total valuation of the sellers in \(O\) who rejected the offered prices and hence get Lemma 5:

**Lemma 5**: _When Algorithm 3 finishes, if \(f(K)<f(u^{*})\) or \(p(A) B\), then we have \((2+)f(S)\)._

In the second case (i.e., \(f(K) f(u^{*})\) and \(p(A)>B\)), we must have that \(S\) is generated by Line 11 and \(S A\). In this case, bounding the performance of Algorithm 3 is more complicated and is given by Lemma 6:

**Lemma 6**: _Suppose that \((2,+1}{2})\). When Algorithm 3 finishes, if \(f(K) f(u^{*})\) and \(p(A)>B\), then we have_

\[(3++2},2++-4},2++ -2}) f(S)\] (13)

We roughly explain the idea for proving Lemma 6 as follows. Consider the set \(A\) generated by Line 10 (recall that \(K\) is prefix of \(A\)). If the smallest suffix \(H\) of \(A\) satisfying \(p(H)>B\) does not intersect \(K\), then we can use similar reasoning as Lemma 3 to prove \((3++2})f(S)\). Under the other case (i.e., \(H K\)), \(H\) must have a prefix generated using the relaxed pricing rule of Line 3, which possibly degrades the valuation of \(H\) and hence \(S\) (note that \(S\) is a suffix of \(H\)). Fortunately, since \(f(K)\) is at most \(2f(u^{*})\) due to Line 6, we can prove that the approximation ratio of \(f(S)\) is only slightly weaker than that in the case of \(H K=\), i.e., \((2++-4},2+ +-2}).\)\(f(S)\). Combining Lemmas 5-6, we can immediately get the performance bounds of TripleEagleDet, as shown by Theorem 2, which reveals that TripleEagleDet has a better approximation ratio than the deterministic BFM with a provable ratio of 4.75 in . Note that Balkanski et al.  show that their BFM cannot achieve a ratio better than 4.5 even if their analysis for the 4.75-ratio is not tight.

**Theorem 2**: _With \(= 2.45\), the TripleEagleDet mechanism can return a set \(S\) satisfying \((2+)f(S)\) by offering one price to each seller in \(\) and incurring \(2n\) value oracle queries._

## 5 BFM for Non-Monotone Submodular Valuations

In this section, we extend our TripleEagleRan algorithm to handle a non-monotone submodular valuation function \(f()\), as shown by the TripleEagleNm algorithm (i.e., Algorithm 4).

The TripleEagleNm algorithm is similar in spirit to the TripleEagleRan algorithm except that it maintains two sets of candidate winners: \(A_{1}\) and \(A_{2}\). In Lines 1-6 of Algorithm 4, each seller \(u\{u^{*}\}\) is greedily routed to \(A_{j}(j\{1,2\})\) such that \(f(u A_{j})\) is maximized, and then \(u\) is offered a price generated using the same rule as Line 2 of Algorithm 2. After all the sellers in \(\{u^{*}\}\) are processed, Lines 12-19 of Algorithm 4 adopt the operations similar to those in Lines 6-13 of Algorithm 1, except that \(u^{*}\) is offered a "best-effort" price of \(B-p(A_{q})\) after it is greedily routed to \(A_{q}\) by Line 16. We show the performance bounds of Algorithm 4 in Theorem 3:

**Theorem 3**: _With \(=3\), the TripleEagleNm mechanism can return a set \(S\) satisfying \( 12[f(S)]\) by offering one price to each seller in \(\) and incurring at most \(3n\) value oracle queries._

## 6 Performance Evaluation

We use the influence maximization application mentioned in Sec. 1 to compare the following BFMs: (1) Our TripleEagleRan (TER) and TripleEagleDet (TED) algorithms, (2) The Iterative-Pruning (IP) algorithm in  with a ratio of 4.75, and (3) The Random-TM (RTM) algorithm in  with a ratio of 5. All the algorithms are implemented using C++ and are run on a Linux server with Intel Xeon Gold 6126 @ 2.60GHz CPU and 128GB memory. Each implemented randomized algorithm is independently executed 50 times, and the average result is reported. We use three real social network datasets: (1) FlixInser  with 28,843 nodes and 272,786 edges; (2) Epinions  with 75,879 nodes and 508,837 edges; and (3) Slashdot  with 82,168 nodes 948,464 edges. We adopt the well-known _Independence Cascade_ (IC) model  for the influence spread function \(f()\), and follow  to set the activation probability \(p_{u,v}\) of each edge \((u,v)\) to \(1/N_{in}(v)\), where \(N_{in}(v)\) denotes the set of in-neighbors of \(v\). The cost \(c(u)\) of each node is generated uniformly at random from the interval \(\). Since evaluating \(f()\) is known to be #P-hard , we adopt the approach in  to generate one million random _reverse-reachable sets_ for approximately evaluating \(f()\). It is known that the influence spread function through such an approximation is still monotone and submodular .

The experimental results in Fig. 1 reveal that, for all three datasets, our BFMs outperform the baselines on utility (i.e., the valuation of returned solution). Specifically, TER and TED have similar utilities that outperform RTM (resp. IP) with the performance gain ranging from \(55\%\)-\(122\%\) (resp. \(4\%\)-\(14\%\)). Moreover, TER and TED incur much fewer value oracle queries than RTM (resp. IP) in more than one (resp. three to four) orders of magnitude. It can also be seen that, although TER and RTM are both randomized mechanisms, RTM incurs large variations while TER is almost deterministic in Fig. 1. This can be explained by the fact that RTM always returns a random solution by its design, while the randomization of TER is only triggered in some special cases (see Sec. 3). Finally, we have also compared our BFMs with the existing ones using a crowdsourcing application similar to that in , where non-monotone submodular valuations are also considered. The experimental results are qualitatively similar to Fig. 1 and can be found in the Appendix due to the page limits.

## 7 Conclusion

We have proposed TripleEagle, a novel algorithmic framework for designing budget feasible mechanisms with submodular valuations, based on which we have presented several simple, fast, effective and practical BFMs that achieve obvious strategyproofness, low complexity, and better approximation ratios than the-state-of-the-art studies. The efficiency and effectiveness of our approach has been strongly corroborated by our experiments on influence maximization and crowdsourcing.