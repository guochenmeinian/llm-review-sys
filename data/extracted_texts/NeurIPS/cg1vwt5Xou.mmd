# Lookback Prophet Inequalities

Ziyad Benomar

ENSAE, Ecole Polytechnique,

FairPlay joint team

ziyad.benomar@ensae.fr

&Dorian Baudry

Department of Statistics,

University of Oxford

dorian.baudry@ox.ac.uk

&Vianney Perchet

CREST, ENSAE, Criteo AI LAB

Fairplay joint team

vianney.perchet@normalesup.org

###### Abstract

Prophet inequalities are fundamental optimal stopping problems, where a decision-maker observes sequentially items with values sampled independently from known distributions, and must decide at each new observation to either stop and gain the current value or reject it irrevocably and move to the next step. This model is often too pessimistic and does not adequately represent real-world online selection processes. Potentially, rejected items can be revisited and a fraction of their value can be recovered. To analyze this problem, we consider general decay functions \(D_{1},D_{2},\), quantifying the value to be recovered from a rejected item, depending on how far it has been observed in the past. We analyze how lookback improves, or not, the competitive ratio in prophet inequalities in different order models. We show that, under mild monotonicity assumptions on the decay functions, the problem can be reduced to the case where all the decay functions are equal to the same function \(x x\), where \(=_{x>0}_{j 1}D_{j}(x)/x\). Consequently, we focus on this setting and refine the analyses of the competitive ratios, with upper and lower bounds expressed as increasing functions of \(\).

## 1 Introduction

Optimal stopping problems constitute a classical paradigm of decision-making under uncertainty (Dynkin, 1963) Typically, in online algorithms, these problems are formalized as variations of the secretary problem (Lindley, 1961) or the prophet inequality (Krengel and Sucheston, 1977). In the context of the prophet inequality, the decision-maker observes a finite sequence of items, each having a value drawn independently from a known probability distribution. Upon encountering a new item, the decision-maker faces the choice of either accepting it and concluding the selection process or irreversibly rejecting it, with the objective of maximizing the value of the selected item. However, while the prophet inequality problem is already used in scenarios such as posted-price mechanism design (Hajiaghayi et al., 2007) or online auctions (Syrgkanis, 2017), it might present a pessimistic model of real-world online selection problems. Indeed, it is in general possible in practice to revisit previously rejected items and potentially recover them or at least recover a fraction of their value.

Consider for instance an individual navigating a city in search of a restaurant. When encountering one, they have the choice to stop and dine at this place, continue their search, or revisit a previously passed option, incurring a utility cost that is proportional to the distance of backtracking. In another example drawn from the real estate market, homeowners receive offers from potential buyers. The decision to accept or reject an offer can be revisited later, although buyer interest may have changed, resulting in a potentially lower offer or even a lack of interest. Lastly, in the financial domain, anagent may choose to sell an asset at its current price or opt for a lookback put option, allowing them to sell at the asset's highest price over a specified future period. To make a meaningful comparison between the two, one must account for factors such as discounting (time value of money) and the cost of the option.

### Formal problem and notation

To encompass diverse scenarios, we propose a general way to quantify the cost incurred by the decision-maker for retrieving a previously rejected value.

**Definition 1.1** (Decay functions).: _Let \(=(D_{1},D_{2},)\) be a sequence of non-negative functions defined on \([0,)\). It is a sequence of decay functions if_

1. \(D_{1}(x) x\) _for all_ \(x 0\)_,_
2. _the sequence_ \((D_{j}(x))_{j 1}\) _is non-increasing for all_ \(x 0\)_,_
3. _the function_ \(D_{j}\) _is non-decreasing for all_ \(j 1\)_._

In the context of decay functions \(\), if a value \(x\) is rejected, the algorithm can recover \(D_{j}(x)\) after \(j\) subsequent steps. The three conditions defining decay functions serve as fundamental prerequisites for the problem. The first and second conditions ensure that the recoverable value of a rejected item can only diminish over time, while the final condition implies that an increase in the observed value \(x\) corresponds to an increase in the potential recovered value. Although the non-negativity of the decay functions is non-essential, we retain it for convenience, as we can easily revert to this assumption by considering that the algorithm has a reward of zero by not selecting any item.

The motivating examples that we introduced can be modeled respectively with decay functions of the form \(D_{j}(x)=x-c_{j}\) where \((c_{j})_{j 1}\) is a non-decreasing positive sequence, \(D_{j}(x)=_{j}x\) with \(_{j}(p_{j})\) and \((p_{j})_{j 1}\) a non-increasing sequence of probabilities, and \(D_{j}(x)=^{j}x\) with \(\). In one of these examples (housing market), the natural model is to use _random decay functions_: the buyer makes the same offer if they are still interested, and offers \(0\) otherwise. Definition 1.1 can be easily extended to consider this case. However, to enhance the clarity of the presentation, we only discuss the deterministic case in the rest of the paper. In Appendix D, we explain how all the proofs and theorems can be generalized to that case.

The \(\)-prophet inequality.For any decay functions \(\), we define the \(\)-prophet inequality problem, where the decision maker, knowing \(\), observes sequentially the values \(X_{1},,X_{n}\), with \(X_{i}\) drawn from a known distribution \(F_{i}\) for all \(i[n]\). If they decide to stop at some step \(\), then instead of gaining \(X_{}\) as in the classical prophet inequality, they can choose to select the current item \(X_{}\) and have its full value, or select any item \(X_{i}\) with \(i<\) among the rejected ones but only recover a fraction \(D_{-i}(X_{i}) X_{i}\) of its value. Therefore, if an algorithm ALG stops at step \(\) its reward is

\[^{}(X_{1},,X_{n}) =\{X_{},D_{1}(X_{-1}),D_{2}(X_{-2}),,D_{ -1}(X_{1})\}\] \[=_{0 i-1}\{D_{i}(X_{-i})\}\;,\]

with the convention \(D_{0}(x)=x\). If the algorithm does not stop at any step before \(n\), then its reward is \(^{}(X_{1},,X_{n})=_{1 i n}\{D_{i}(X_{ (n-i+1)})\}\), which corresponds to \(=n+1\).

**Remark 1.1**.: _As in the standard prophet inequality, an algorithm is defined by its stopping time, i.e., the rule set to decide whether to stop or not. Hence, if \(\) and \(^{}\) are two different sequences of decay functions, any algorithm for the \(\)-prophet inequality, although its stopping time might depend on the particular sequence of functions \(\), is also an algorithm for the \(^{}\)-prophet inequality. Consider for example an algorithm ALG with stopping time \(()\) that depends on \(\). Its reward in the \(^{}\)-prophet inequality is \(^{^{}}(X_{1},,X_{n})=_{0 i -1}\{D^{}_{i}(X_{()-i})\}\)._

Observation order.Several variants of the prophet inequality problem have been studied, depending on the order of observations. The standard model is the adversarial (or fixed) order: The instance of the distributions \(F_{1},,F_{n}\) is chosen by an adversary, and the algorithm observes the samples \(X_{1} F_{1},,X_{n} F_{n}\) in this order (Krengel and Sucheston, 1977, 1978). In the _random order_ model, the adversary can again choose the distributions, but the algorithm observes the samples in a uniformly random order. Another setting in which the observation order is no longer important is the IID model (Hill and Kertz, 1982; Correa et al., 2021b), where all the values are sampled independently from the same distribution \(F\). The \(\)-prophet inequality is well-defined in each of these different order models: if the items are observed in the order \(X_{(1)},,X_{(n)}\) with \(\) a permutation of \([n]\), then the reward of the algorithm is \(^{}(X_{1},,X_{n})=_{0 i-1}\{D_{i }(X_{(-i)})\}\). In this paper, we study the \(\)-prophet inequality in the three models we presented, providing lower and upper bounds in each of them.

Competitive ratio.In the \(\)-prophet inequality, an input instance \(I\) is a finite sequence of probability distributions \((F_{1},,F_{n})\). Thus, for any instance \(I\), we denote by \([^{}(I)]\) the expected reward of \(\) given \(I\) as input, and we denote by \([(I)]\) the expected maximum of independent random variables \((X_{i})_{i[n]}\), where \(X_{i} F_{i}\). With these notations, we define the competitive ratio, which will be used to measure the quality of the algorithms.

**Definition 1.2** (Competitive ratio).: _Let \(\) be a sequence of decay functions and \(\) an algorithm. We define the competitive ratio of \(\) by_

\[^{}()=_{I}[^{}(I)]}{[(I)]}\,\]

_with the infimum taken over the tuples of all sizes of non-negative distributions with finite expectation._

An algorithm is said to be \(\)-competitive if its competitive ratio is at least \(\), which means that for any possible instance \(I\), the algorithm guarantees a reward of at least \([(I)]\). The notion of competitive ratio is used more broadly in competitive analysis as a metric to evaluate online algorithms (Borodin and El-Yaniv, 2005).

### Contributions

It is trivial that non-zero decay functions \(\) guarantee a better reward compared to the classical prophet inequality. However, in general, this is not sufficient to conclude that the standard upper bounds or the competitive ratio of a given algorithm can be improved. Hence, a first key question is: what condition on \(\) is necessary to surpass the conventional upper bounds of the classical prophet inequality? Surprisingly, the answer hinges solely on the constant \(_{}\), defined as follows,

\[_{}=_{x>0}_{j 1}\{(x)}{x}\}\.\] (1)

In the adversarial order model, we demonstrate that the optimal competitive ratio achievable in the \(\)-prophet inequality is determined by the parameter \(_{}\) alone. Additionally, in both the random order and IID models, we demonstrate the essential requirement of \(_{}>0\) for breaking the upper bounds of the classical prophet inequality. In particular, this implies that no improvement can be made with decay functions of the form \(D_{j}(x)=x-c_{j}\) with \(c_{j}>0\), or \(D_{j}(x)=^{j}x\) with \([0,1)\). Subsequently, we develop algorithms and provide upper bounds in the \(\)-prophet inequality, uniquely dependent on the parameter \(_{}\). We illustrate them in Figure 1, comparing them with the identity function \(\), which is a trivial lower bound.

### Related work

Prophet inequalities.The first prophet inequality was proven by Krengel and Sucheston (Krengel and Sucheston, 1977, 1978) in the setting where the items are observed in a fixed order, demonstrating that the dynamic programming algorithm has a competitive ratio of \(1/2\), which is the best possible. It was shown later that the same guarantee can be obtained with simpler algorithms (Samuel-Cahn, 1984; Kleinberg and Weinberg, 2012), accepting the first value above a carefully chosen threshold. For a more comprehensive and historical overview, we refer the interested reader to surveys on the problem such as (Lucier, 2017; Correa et al., 2019). Prophet inequalities have immediate applications in mechanism design (Hajiaghiy et al., 2007; Deng et al., 2022; Psomas et al., 2022; Makur et al., 2024), auctions (Syrgkanis, 2017; Dutting et al., 2020), resource management (Sinclair et al., 2023), and online matching (Cohen et al., 2019; Ezra et al., 2020; Jiang et al., 2021; Papadimitriou et al., 2021; Brubach et al., 2021). Many variants and related problems have been studied, including, for example, the matroid prophet inequality (Kleinberg and Weinberg, 2012; Feldman et al., 2016),prophet inequality with advice (Diakonikolas et al., 2021), and variants with fairness considerations (Correa et al., 2021a, Arsenis and Kleinberg, 2022).

Random order and IID models.Esfandiari et al. (2017) introduced the _prophet secretary_ problem, where items are observed in a uniformly random order, and they proved a \((1-)\)-competitive algorithm. Correa et al. (2021c) showed later a competitive ratio of \(0.669\), and Harb (2024) enhanced it to 0.6724, which currently stands as the best-known solution for the problem. They also proved an upper bound of \(-1 0.732\), which was improved to \(0.7254\) in (Bubna and Chiplunkar, 2023) then 0.723 in (Giambratolomei et al., 2023). Addressing the gap between the lower and upper bound remains an engaging and actively pursued open question. On the other hand, the study of prophet inequalities with IID random variables dates back to papers such as (Hill and Kertz, 1982, Kertz, 1986), demonstrating guarantees on the dynamic programming algorithm. The problem was completely solved in (Correa et al., 2021b), where the authors show that the competitive ratio of the dynamic programming algorithm is \(0.745\), thus it constitutes an upper bound on the competitive ratio of any algorithm, and they give a simpler adaptive threshold algorithm matching it. Another setting that we do not study in this paper, is the _order selection_ model, where the decision-maker can choose the order in which the items are observed, knowing their distributions (Chawla et al., 2010, Beyhaghi et al., 2021, Peng and Tang, 2022).

Beyond the worst-case.In recent years, there has been increasing interest in exploring ways to exceed the worst-case upper bounds of online algorithms by providing the decision-maker with additional capabilities. A notable research avenue is learning-augmented algorithms (Lykouris and Vassilvtiskii, 2018), which equip the decision-maker with predictions or hints about unknown variables of the problem. Multiple problems have been studied in this framework, such as scheduling (Purohit et al., 2018, Lassota et al., 2023, Benomar and Perchet, 2024b), matching (Antoniadis et al., 2020, Dinitz et al., 2021, Chen et al., 2022), caching (Antoniadis et al., 2023, Chlkedowski et al., 2021, Christianson et al., 2023), the design of data structures (Kraska et al., 2018, Lin et al., 2022, Benomar and Coester, 2024), and in particular, online selection problems (Dutting et al., 2021, Sun et al., 2021, Benomar et al., 2023, Benomar and Perchet, 2024a, Diakonikolas et al., 2021). More related to our setting, the ability to revisit items in online selection has been studied in problems such as the multiple-choice prophet inequality, where the algorithm can select up to \(k\) items and its reward is the maximum selected value (Assaf and Samuel-Cahn, 2000). This allows for revisiting up to \(k\) items, chosen during the execution, for final acceptance or rejection decisions. Similarly, in Pandora's box problem (Weitzman, 1978, Kleinberg et al., 2016) and its variants (Esfandiari et al., 2019, Gergatsouli and Tzamos, 2022, Atsidakou et al., 2024, Gergatsouli and Tzamos, 2024, Berger et al., 2024), the decision maker decides the observation order of the items, but a cost \(c_{i}\) is paid for observing each value \(X_{i}\), with the gain being the maximum observed value minus the total opening costs. A very recent work investigates a scenario closely related to the lookback prophet inequality

Figure 1: Lower and upper bounds on the competitive ratio in the \(\)-prophet inequality depending on \(_{}\), in the adversarial order (Thm 4.3), random order (Thm 4.4) and IID (Thm 4.6) models

[Ekbatani et al., 2024] where, upon selecting a candidate \(X_{i}\), the decision-maker has the option to discard it and choose a new value \(X_{j}\) at any later step \(j\), at a buyback cost of \(fX_{i}\), where \(f>0\). The authors present an optimal algorithm for the case when \(f 1\), although the problem remains open for \(f(0,1)\). Other problems were studied in similar settings, such as online matching [Ekbatani et al., 2022] and online resource allocation [Ekbatani et al., 2023].

## 2 From \(\)-prophet to the \(D_{}\)-prophet inequality

Let us consider a sequence \(\) of decay functions. By Definition 1.1, for any \(x[0,]\) the sequence \((D_{j}(x))_{j 1}\) converges, since it is non-increasing and non-negative. Hence, there exists a mapping \(D_{}\) such that for any \(x 0\), \(_{j}D_{j}(x)=D_{}(x)\). Furthermore, we can easily verify that \(D_{}\) is non-decreasing and satisfies \(D_{}(x)[0,x]\) for all \(x 0\).

Thanks to these properties, we obtain that \((D_{})_{j 1}\) also satisfies Definition 1.1, and is hence a valid sequence of decay functions. We thus refer to the corresponding problem as the \(D_{}\)-prophet inequality. Since \(D_{j} D_{}\) for any \(j 1\), it is straightforward that the stopping problem with the decay functions \(D_{}\) would be less favorable to the decision-maker. More precisely, for any random variables \(X_{1},,X_{n}\), observation order \(\), and algorithm ALG with stopping time \(\), it holds that

\[^{}(X_{1},,X_{n})\{X_{()}, _{i<}D_{-i}(X_{(i)})\}\{X_{()},_{i<}D_{ }(X_{(i)})\}\,\]

which corresponds to the output of ALG (with the same decision rule) when all the decay functions are equal to \(D_{}\). Therefore, any guarantees established for algorithms in the \(D_{}\)-prophet inequality naturally extend to the \(\)-prophet inequality. However, it remains uncertain whether the \(\)-prophet inequality can yield improved competitive ratios compared to the \(D_{}\)-prophet inequality. In the following, we prove that this is not the case, for all the order models presented in Section 1.

**Theorem 2.1**.: _Let \(D_{}\) be the pointwise limit of the sequence of decay functions \(=(D_{j})_{j 1}\). Then for any instance \(I=(F_{1},,F_{n})\) of non-negative distributions, it holds in the adversarial and the random order models that_

\[:^{}()_{ {A}}[^{D_{}}(I)]}{[(I )]}\,\] (2)

_where the supremum is taken over all the online algorithms \(\) In the IID model, the same inequality holds with an additional \(O(n^{-1/3})\) term, which depends only on the size \(n\) of the instance._

The main implication of Theorem 2.1 is the following corollary.

**Corollary 2.1.1**.: _In the adversarial order and the random order models, if \(}_{}\) is an optimal algorithm for the \(D_{}\)-prophet inequality, i.e. with maximal competitive ratio, then \(}_{}\) is also optimal for the \(\)-prophet inequality. Moreover, it holds that_

\[^{}(}_{})=^{ _{}}(}_{})\.\]

A direct consequence of this result is that, in the adversarial and the random order models, the asymptotic decay \(D_{}\) entirely determines the competitive ratio that is achievable and the upper bounds for the \(\)-prophet inequality. Therefore, we can restrict our analysis to algorithms designed for the problem with identical decay function. In the IID model, the same conclusion holds if the worst-case instances are arbitrarily large, making the additional \(O(n^{-1/3})\) term vanish. This is the case in particular in the classical IID prophet inequality [Hill and Kertz, 1982].

### Sketch of the proof of Theorem 2.1

While we use different techniques for each order model considered, all the proofs share the same underlying idea. Given any instance \(I\) of non-negative distributions, we build an alternative instance \(J\) such that the reward of any algorithm on \(I\) with decay functions \(=(D_{j})_{j}\) is at most its reward on \(J\) with decay functions all equal to \(D_{}\). To do this, we essentially introduce an arbitrarily large number of zero values between two successive observations drawn from distributions belonging to \(I\). Hence, under \(J\), the algorithm cannot recover much more than a fraction \(D_{}(X)\) for any past observation \(X\) collected from a distribution \(F I\).

In the adversarial case, implementing this idea is straightforward, since nature can build \(J\) by directly inserting \(m\) zeros between each pair of consecutive values, and the result is obtained by making \(m\) arbitrarily large. For the random order model, we use the same instance \(J\), but extra steps are needed to prove that the number of steps between two non-zero values is very large with high probability.

Moving to the IID model, an instance \(I\) is defined by a pair \((F,n)\), where \(F\) is a non-negative distribution, and \(n\) is the size of the instance. In this scenario, we consider an instance consisting of \(m>n\) IID random variables \((Y_{i})_{i[m]}\), each sampled from \(F\) with probability \(n/m\), and equal to zero with the remaining probability. We again achieve the desired result by letting \(m\) be arbitrarily large compared to \(n\). However, the number of variables sampled from \(F\) is not fixed; it follows a Binomial distribution with parameters \((m,n/m)\). We control this variability by using concentration inequalities, which causes the additional term \(O(n^{-1/3})\).

## 3 From \(D_{}\)-prophet to the \(_{}\)-prophet inequality

As discussed in Section 2, Theorem 2.1 implies that, for either establishing upper bounds or guarantees on the competitive ratios of algorithms, it is sufficient to study the \(D_{}\)-prophet inequality, where all the decay functions are equal to \(D_{}\). The remaining question is then to determine which functions \(D_{}\) allow to improve upon the upper bounds of the classical prophet inequality. Before tackling this question, let us make some observations regarding algorithms in the \(D_{}\)-prophet inequality.

In the \(D_{}\)-prophet inequality, it is always possible to have a reward of \(D_{}(_{i[n]}X_{i})\) by rejecting all the items and then selecting the maximum by the end. Thus, it is suboptimal to stop at a step \(i\) where \(X_{i} D_{}(_{j<i}X_{j})\). An algorithm respecting this decision rule is called _rational_.

**Lemma 3.1**.: _For any rational algorithm \(\) in the \(D_{}\)-prophet inequality, if we denote by \(\) its stopping time, then for any instance \(I=(F_{1},,F_{n})\) and \(X_{i} F_{i}\) for all \(i[n]\) we have_

\[^{D_{}}(X_{1},,X_{n})=^{0}(X_{1},,X _{n})+D_{}_{i[n]}X_{i}_{=n+1}\,\]

_where \(^{0}\) denotes the reward of the algorithm in the standard prophet inequality. Moreover, the optimal dynamic programming algorithm in the \(D_{}\)-prophet inequality is rational._

The best competitive ratio in the \(D_{}\)-prophet inequality is achieved, possibly among others, by the optimal dynamic programming algorithm, which is a rational algorithm by the previous Lemma. Hence, it suffices to prove upper bounds on rational algorithms. We use this observation to prove the next propositions.

**Proposition 3.2**.: _In the \(D_{}\)-prophet inequality, if \(_{x>0}(x)}{x}=0\), then it holds, in any order model, that_

\[:^{D_{}}()_{}^{0}()\,\] (3)

_where the supremum is taken over all the online algorithms \(\) and \(^{0}\) denotes the competitive ratio in the standard prophet inequality._

Proposition 3.2 implies that if \(_{x>0}(x)}{x}=0\), then, in any order model, any upper bound on the competitive ratios of all algorithms in the classical prophet inequality is also an upper bound on the competitive ratios of all algorithm in the \(D_{}\)-prophet inequality. Consequently, for surpassing the upper bounds of the classical prophet inequality, it is necessary to have, for some \(>0\), that \(D_{}(x) x\) for all \(x 0\). Furthermore, the next Proposition allows giving upper bounds in the \(D_{}\)-prophet inequality that depend only on \(_{x>0}(x)}{x}\).

**Proposition 3.3**.: _Let \(=_{x>0}D_{}(x)/x\), and \(0<a<b\). Consider an instance \(I\) of distributions with support in \(\{0,a,b\}\), then in any order model and for any algorithm \(\) we have that_

\[^{D_{}}()_{}[ ^{}(I)]}{[(I)]}\,\]

_where \([^{}(I)]\) is the reward of \(\) if all the decay functions were equal to \(x x\)._

The core idea for proving this proposition is that rescaling an instance, i.e. considering \((rX_{i})_{i[n]}\) instead of \((X_{i})_{i[n]}\), has no impact in the classical prophet inequality. However, in the \(D_{}\)-prophetinequality, rescaling can be exploited to adjust the ratio \((rx)}{rx}\). By considering instances with random variables taking values in \(\{0,a,b\}\) almost surely, where \(a<b\), a reasonable algorithm facing such an instance would never reject the value \(b\). Consequently, the value it recovers from rejected items is either \(D_{}(0)=0\) or \(D_{}(a)\). Rescaling this instance by a factor \(r=s/a\) and taking the ratio to the expected maximum, the term \((s)}{s}\) appears, with \(s\) a free parameter that can be chosen to satisfy \((s)}{s}_{x>0}(x)}{x}=_{}\).

As a consequence, if \(_{x>0}(x)}{x}=\), then any upper bound obtained in the \(\)-prophet inequality (when the decay functions are all equal to \(x x\)) using instances of random variables \((X_{1},,X_{n})\) satisfying \(X_{i}\{0,a,b\}\) a.s. for all \(i\), is also an upper bound in the \(D_{}\)-prophet inequality.

ImplicationConsider any sequence \(\) of decay functions, and define

\[_{}:=_{x>0}\{(x)}{x}\}=_{ x>0}_{j 1}\{(x)}{x}\}\.\]

For any \(x>0\) and \(j 1\) it holds that \(D_{j}(x)_{}x\), therefore, any guarantees on the competitive ratio of an algorithm in the \(_{}\)-prophet inequality are valid in the \(\)-prophet inequality, under any order model. Furthermore, combining Theorem 2.1 and Proposition 3.3, we obtain that for any instance \(I\) of random variables taking values in a set \(\{0,a,b\}\) it holds that

\[:^{}()_{}[^{_{}}(I)]}{[ (I)]}\,\]

with an additional term of order \(O(n^{-1/3})\) in the IID model. In the particular case where \(_{}=0\), Proposition 3.3 with Theorem 2.1 give a stronger result, showing that no algorithm can surpass the upper bounds of the classical prophet inequality. This is true also for the IID model since the instances used to prove the tight upper bound of \( 0.745\) are of arbitrarily large size (Hill and Kertz, 1982).

Therefore, by studying the \(\)-prophet inequality for \(\), we can prove upper bounds and lower bounds on the \(\)-prophet inequality for any sequence \(\) of decay functions.

## 4 The \(\)-prophet inequality

We study in this section the \(\)-prophet inequality, where all the decay functions are equal to \(x x\), for some \(\). For any algorithm \(\) with stopping time \(\) and random variables \(X_{1},,X_{n}\), if the observation order is \(\), we use the notation

\[^{}(X_{1},,X_{n})=\{X_{()}, X_{( -1)},, X_{(1)}\}\.\]

and we denote by \(^{}()\) the competitive ratio of \(\) in this setting. In the following, we provide theoretical guarantees for the \(\)-prophet inequality.

For each observation order, we first derive upper bounds on the competitive ratio of any algorithm, depending on \(\), using only hard instances satisfying the condition of Proposition 3.3. This would guarantee that the upper bounds extend to the \(\)-prophet inequality if \(_{}=\). Then, we design single-threshold algorithms with well-chosen thresholds depending on \(\) and the distributions, with competitive ratios improving with \(\). A crucial property of single-threshold algorithms, which we use to estimate their competitive ratios, is that their reward satisfies

\[^{}(X_{1},,X_{n})=^{0}(X_{1},,X_{n })+(_{i}X_{i})_{(,\,X_{i}<)}\.\] (4)

The additional term appearing due to \(\) depends only on \(_{i[n]}X_{i}\), which is the reward of the prophet against whom we compete. This property is not satisfied by more general class of algorithms such as multiple-threshold algorithms, where each observation \(X_{(i)}\) is compared with a threshold \(_{i}\).

**Remark 4.1**.: _We only consider instances with continuous distributions in the proofs of lower bounds. The thresholds \(\) considered are such that \((_{i[n]}X_{i})=g(,n,)\), with \(g\) depending on \(\), the order model \(\) and the size of the instance \(n\). Such a threshold is always guaranteed to exist when the distributions are continuous. However, as in the prophet inequality, the algorithms can be easily adapted to non-continuous distributions by allowing stochastic tie-breaking. A detailed strategy for doing this can be found for example in (Correa et al., 2021c)._Before delving into the study of the different models, we provide generic lower and upper bounds, which depend solely on the bounds of the classical prophet inequality and \(\).

**Proposition 4.2**.: _In any order model, if \(\) is a lower bound in the classical prophet inequality, and \(\) an upper bound, then, in the \(\)-prophet inequality_

1. _there exists a trivial algorithm with a competitive ratio of at least_ \(\{,\}\)_,_
2. _the competitive ratio of any algorithm is at most_ \((1-)+\)_._

### Adversarial order

We first consider the adversarial order model, and prove the upper bound of \(\). Then, we provide a single-threshold algorithm with a competitive ratio matching this upper bound, hence fully solving the \(\)-prophet inequality in this adversarial order model.

**Theorem 4.3**.: _In the adversarial order model, the competitive ratio of any algorithm is at most \(\). Furthermore, there exists a single threshold algorithm with a competitive ratio \(\): given any instance \((F_{1},,F_{n})\), this is achieved with the threshold \(\) satisfying_

\[_{X_{1} F_{1},,X_{n} F_{n}}(_{i[n]}X_{i})= \.\]

The upper bound in the previous theorem is proved using instances satisfying the condition of Proposition 3.3. Hence it extends to the \(D_{}\)- then to the \(\)-prophet inequality, with \(=_{}\), by Proposition 3.3 and Theorem 2.1.

### Random order

Consider now that the items are observed in a uniformly random order \(X_{(1)},,X_{(n)}\), and \(X^{*}=_{i[n]}X_{i}\). As for the adversarial model, we first prove an upper bound on the competitive ratio as a function of \(\), and then prove a lower bound for a single-threshold algorithm. However, for this model, there is a gap between the two bounds, as illustrated in Figure 1.

We first prove an upper bound that depends on \(\), matching the upper bound \(-1\) of Correa et al. (2021c) when \(=0\) and equal to \(1\) when \(=1\). Our single-threshold algorithm has a competitive ratio of at least \((1-)\) when \(=0\), which is the best competitive ratio of a single threshold algorithm in the prophet inequality (Esfandiari et al., 2017; Correa et al., 2021c), and equal to \(1\) for \(=1\).

**Theorem 4.4**.: _The competitive ratio of any algorithm ALG in the \(\)-prophet inequality with random order satisfies_

\[^{}()(1-)^{3/2}(- {1-})+\.\]

_Furthermore, denoting by \(p_{}\) is the unique solution to the equation \(1-(1-)p=\), the single-threshold algorithm ALG\({}_{}\) with \(_{X_{1} F_{1},,X_{n} F_{n}}(_{i[n]}X_{i})=p_{}\) satisfies_

\[^{}() 1-(1-)p_{}\.\]

Similarly to the adversarial order model, we used instances satisfying the condition of Proposition 3.3 to prove the upper bound, thus it extends to the \(\)-prophet inequality with \(=_{}\).

While the equation defining \(p_{}\) cannot be solved analytically, the solution can easily be computed numerically for any \(\). Before moving to the IID case, we propose in the following a more explicit lower bound derived from Theorem 4.4.

**Corollary 4.4.1**.: _In the random order model, the single threshold algorithm with a threshold \(\) satisfying \((_{i[n]}X_{i})=\) has a competitive ratio of at least \(1-\)._

### IID Random Variables

In the classical IID prophet inequality, (Hill and Kertz, 1982) showed that the competitive ratio of any algorithm is at most \( 0.745\). The proof of this upper bound is hard to generalize for the IID \(\)-prophet inequality. As an alternative, we prove a weaker upper bound, which equals \( 0.778\)for \(=0\) and \(1\) for \(=1\), and the proof relies on instances of arbitrarily large size satisfying the condition of Proposition 3.3, hence the upper bound can be extended to the \(\)-prophet inequality.

Subsequently, we present a single-threshold algorithm with the same competitive ratio as the random order algorithm. However, the proof is different, leveraging the fact that the variables are identically distributed. More precisely, we introduce a single-threshold algorithm with guarantees that depend on the size \(n\) of the instance, then we show that its competitive ratio is at least that of the algorithm presented in Theorem 4.4, with equality when \(n\) approaches infinity.

Although it might look surprising that the obtained competitive ratio in the IID model is not better than that of the random-order model, the same behavior occurs in the classical prophet inequality. Indeed, Li et al. (2022) established that no single-threshold algorithm can achieve a competitive ratio better than \(1-1/e\) in the standard prophet inequality with IID random variables, which is also the best possible with a single-threshold algorithm in the random order. However, considering larger classes of algorithms, the competitive ratios achieved in the IID model are better than those of the random order model.

We describe the algorithm and give a first lower bound on its reward depending on the size of the instance in the following lemma.

**Lemma 4.5**.: _Let \(a_{n,}\) be the unique solution of the equation \((}-1)(-1)=\), then for any IID instance \(X_{1},,X_{n}\), the algorithm with threshold \(\) satisfying \((X_{1}>)=}{n}\) has a reward of at least_

\[}(1-(1-}{n})^{n}) [_{i[n]}X_{i}]\;.\]

We can prove that the reward presented in the Lemma above is strictly better than that of the random order model. However, both are asymptotically equal as we show in the following theorem.

**Theorem 4.6**.: _The competitive ratio of any algorithm in the IID \(\)-prophet inequality is at most_

\[U()=1-(1-)(3-)-(2-)}{2(2e^{2}-1)-(3e^{2 }-1)}\;.\]

_In particular, \(U\) is increasing, \(U(0)=)} 0.778\) and \(U(1)=1\). Furthermore, there exists a single-threshold algorithm \(_{}\) satisfying_

\[^{}(_{}) 1-(1-)p_{ }\;,\]

_where \(p_{}\) is defined in Theorem 4.4._

To prove the upper bound, we used instances satisfying the condition of Proposition 3.3, guaranteeing that it remains true in the \(D_{}\)-prophet inequality with \(=_{}\). On the other hand, Theorem 2.1 ensures that the upper bound extends to the \(\)-prophet inequality, but with an additional \(O(1/n^{1/3})\) term. The latter does change the result, as we considered instances of arbitrarily large size \(n\).

## 5 Conclusion

In this paper, we addressed the \(\)-prophet inequality problem, which models a very broad spectrum of online selection scenarios, accommodating various observation order models and allowing to revisit rejected candidates at a cost. The problem extends the classic prophet inequality, corresponding to the special case where all decay functions are zero. The main result of the paper is a reduction from the general \(\)-prophet inequality to the \(\)-prophet inequality, where all the decay functions equal to \(x x\) for some constant \(\). Subsequently, we provide algorithms and upper bounds for the \(\)-prophet inequality, which remain valid, by the previous reduction, in the \(\)-prophet inequality. Notably, the proved upper and lower bounds match each other for the adversarial order model, hence completely solving the problem. Our analysis paves the way for more practical applications of prophet inequalities, and advances efforts towards closing the gap between theory and practice in online selection problems.

#### Limitations and future work

Better upper bounds in the \(D_{}\)-prophet inequality.Proposition 3.3 establishes that upper bounds proved in the \(\)-prophet inequality using instances of random variables with support in some set \(\{0,a,b\}\) remain true in the \(D_{}\)-prophet inequality, hence in the \(\)-prophet inequality by Theorem 2.1. This is enough to establish a tight upper bound in the adversarial order model, but not in the random order and IID models. An interesting question to explore is if more general upper bounds can be extended, or not, from the \(\)- to the \(\)-prophet inequality.

Algorithms for the \(\)-prophet inequality.As explained in Section 4, our analysis of the competitive ratio of single-threshold algorithms relies on the identity (4), which is not satisfied for instance by multiple-threshold algorithms. In the adversarial order model, we proved that the optimal competitive ratio \(1/(2-)\) can be achieved with a single-threshold algorithm. However, this is not the case in the random order or IID models. An interesting research avenue is to study other classes of algorithms in the \(\)-prophet inequality.