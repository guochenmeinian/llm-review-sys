# Learning Transformer Programs

Dan Friedman Alexander Wettig Danqi Chen

Department of Computer Science & Princeton Language and Intelligence

Princeton University

{dfriedman,awettig,danqic}@cs.princeton.edu

###### Abstract

Recent research in mechanistic interpretability has attempted to reverse-engineer Transformer models by carefully inspecting network weights and activations. However, these approaches require considerable manual effort and still fall short of providing complete, faithful descriptions of the underlying algorithms. In this work, we introduce a procedure for training Transformers that are mechanistically interpretable by design. We build on RASP (Weiss et al., 2021), a programming language that can be compiled into Transformer weights. Instead of compiling human-written programs into Transformers, we design a modified Transformer that can be trained using gradient-based optimization and then automatically converted into a discrete, human-readable program. We refer to these models as _Transformer Programs_. To validate our approach, we learn Transformer Programs for a variety of problems, including an in-context learning task, a suite of algorithmic problems (e.g. sorting, recognizing Dyck-languages), and NLP tasks including named entity recognition and text classification. The Transformer Programs can automatically find reasonable solutions, performing on par with standard Transformers of comparable size; and, more importantly, they are easy to interpret. To demonstrate these advantages, we convert Transformers into Python programs and use off-the-shelf code analysis tools to debug model errors and identify the "circuits" used to solve different sub-problems. We hope that Transformer Programs open a new path toward the goal of intrinsically interpretable machine learning.1

## 1 Introduction

Transformers (Vaswani et al., 2017) have become the predominant neural network architecture in machine learning, representing the state-of-the-art in natural language processing (NLP) and increasingly in computer vision, molecular modeling and other domains. Prominently, large Transformer-based language models (LLMs; Brown et al., 2020) have demonstrated impressive general-purpose capabilities and are now widely deployed as components in user-facing AI applications such as chatbots, search engines, and code assistants. However, these systems are fundamentally limited by a lack of interpretability, which makes them difficult to audit, debug, and maintain. This black-box quality poses practical challenges and limits the usefulness of these models in high-stakes applications.

As a result, a considerable body of work has aimed at improving our understanding of Transformers. In NLP, much of this work has focused on pre-trained Transformer language models such as BERT (Devlin et al., 2019), using a variety of post-hoc methods, including analyzing attention patterns (Clark et al., 2019) and probing hidden representations (e.g., Tenney et al., 2019; Belinkov, 2022). These post-hoc approaches can provide partial insight into model behavior but have also been shown to be misleading (Jain and Wallace, 2019; Bolukbasi et al., 2021); in any case, they do not provide a complete or faithful description of the algorithm that the model implements. More recently,research on mechanistic interpretability has attempted to gain an algorithmic understanding of these models, with the goal of reverse-engineering Transformers into human-interpretable components. This line of work includes efforts to characterize "circuits" of attention heads (Ehlage et al., 2021; Olsson et al., 2022; Wang et al., 2023; Nanda et al., 2023); align network representations with symbolic causal models (Geiger et al., 2023); interpret feed-forward layers (Nostalgebraist, 2020; Geva et al., 2022); and localize and edit factual information (Meng et al., 2022). However, such methods require extensive manual effort and can be impeded by the inherent complexity of the underlying models (e.g. McGrath et al., 2023).

In this work, instead of attempting to explain black-box models, we aim to train Transformers that are mechanistically interpretable by design. We take inspiration from RASP (Weiss et al., 2021), a programming language for characterizing Transformer operations, and Tracr (Lindner et al., 2023), a compiler for converting RASP programs into Transformer networks. RASP provides a conceptual framework for mapping between Transformer components and human-readable code. However, whereas prior work has compiled human-written programs into Transformers, our goal is to train Transformers using gradient-based optimization and then automatically decompile them into human-readable programs.

To this end, we propose a method for learning _Transformer Programs_--Transformers that are constrained to implement human-interpretable algorithms. First, we introduce a set of constraints that restrict the Transformer to lie within an interpretable subspace of the parameter space, by which we mean the subset of parameter values that can be mapped to a family of human-readable programs. Second, we develop a continuous relaxation scheme for learning these programs. Transformer Programs can be deterministically mapped to a program in a human-readable programming language, like Python. The Python program is functionally identical to the Transformer, but considerably easier to interpret--for example, we can debug errors by setting breakpoints using the standard Python debugger. Our overall approach is illustrated in Figure 1.

We validate our approach by learning Transformer Programs for a variety of problems, including an in-context learning task; the set of algorithmic problems introduced by Weiss et al. (2021); and NLP benchmarks for named entity recognition and text classification. While discrete optimization introduces some challenges, we show that the Transformer Programs achieve reasonable performance relative to standard Transformers of comparable size, and, unlike standard Transformers, they are easy to interpret. We illustrate this point by converting Transformers into Python programs and using off-the-shelf code analysis tools to extract the"circuits" used to solve different sub-problems, and to debug model errors. Overall, we aim to demonstrate that Transformer Programs represent a promising first step towards building intrinsically interpretable machine learning models.

## 2 Background

**Transformer architecture.** The Transformer (Vaswani et al., 2017) is a neural network architecture for processing sequential data. The input to the Transformer is a sequence of tokens \(=w_{1},,w_{N}\) in a discrete vocabulary \(\). At the input layer, the model maps the tokens to a sequence of \(d\)-dimensional embeddings \(_{0}^{N d}\). In the standard Transformer, this initial embedding is defined as the sum of a learned token embedding and a positional embedding. Each subsequent layer \(i\) consists of a multi-head attention layer (MHA) followed by a multilayer perceptron layer (MLP): \(_{i}=_{i-1}+_{i}(_{i-1}+_{i}(_{i-1}))\).2 Following the presentation

Figure 1: We design a modified Transformer that can be trained on data and then automatically discretized and converted into a human-readable program. The program is functionally identified to the Transformer, but easier to understand—for example, using an off-the-shelf Python debugger.

of Elhage et al. (2021), multi-head attention can be written as

\[()=_{h=1}^{H}(_{Q} ^{h}(_{K}^{h})^{})_{V}^{h}_{O}^{h},\]

where \(H\) is the number of heads, \(d_{h}\) is the attention embedding dimension, \(_{Q}^{h},_{K}^{h},_{V}^{h}^{d d _{h}}\) are referred to as the _query_, _key_, and _value_ projections respectively, and \(_{O}^{h}^{d_{h} d}\) projects the output value back to the model dimension. By default, we assume that attention is bi-directional, corresponding to a Transformer encoder, but we also support causal masking. The MLP layer operates at each position independently; in the standard Transformer, it is a two-layer feedforward network: \(()=(_{1})_{2}\), where \(_{1}^{d d_{m}},_{2}^{d_{ m} d}\), and \(\) is a non-linear activation, commonly the ReLU function. The output of the model is a sequence of token embeddings, \(_{L}^{N d}\). The model is typically trained end-to-end on a prediction task by applying a linear classifier to the final-layer token embeddings.

**Transformer circuits.** Transformer circuits (Elhage et al., 2021) are an abstraction for characterizing how a neural network processes information. Informally, a Transformer can be viewed as a series of nodes (attention heads and feed-forward layers) reading and writing information to the _residual stream_, which refers to the sequence of token embeddings \(_{0},,_{L}^{N d}\) computed at each layer. Each node "reads" from the residual stream via a projection matrix \(_{}^{d d_{h}}\); calculates some function \(f(_{i-1}_{})\); and then "writes" to the residual stream via another projection: \(_{i}=_{i-1}+f(_{i-1}_{}) _{}\), with \(_{}^{d_{h} d}\). Mechanistic interpretability seeks to find the circuits within a Transformer that implement individual behaviors, but this goal is often difficult in practice; for example, different attention heads may write to the same subspace of the residual stream, making it difficult to disentangle how information flows from one component to another.

**Programming languages for Transformer.** RASP (Weiss et al., 2021) is a programming language consisting of a set of function primitives for defining operations on sequences. These are designed to ensure that any program written in RASP can be implemented by a Transformer network, by mapping between RASP primitives and Transformer components. Tracr (Lindner et al., 2023) is a compiler for RASP that implements this mapping in practice. The central operation is select, which corresponds to attention in the Transformer. select takes as input a sequence of \(^{N}\); a sequence of \(^{M}\); and a boolean \(\{0,1\}\). The output is an attention matrix \(\{0,1\}^{M N}\) with \(_{i,j}=(_{i},_{j})\). The select operator is combined with an aggregate operation, which takes as input an attention matrix \(\) and a sequence of \(^{N}\) and outputs, at each row \(i\), the weighted average of \(\), with weights given by \(_{i}\). RASP also supports arbitrary element-wise operations, which correspond to the feed-forward layers in a Transformer. RASP and Tracr provide a framework for mapping from human-interpretable programs to Transformers, but there is no clear way to map an arbitrary Transformer to a RASP program.

## 3 Learning Transformer Programs

Our main idea is to define constraints on the Transformer weights that guarantee that there is a simple, deterministic mapping between Transformer components and RASP-like programming primitives. We refer to the set of Transformers satisfying these constraints as _Transformer Programs_. To provide an overall picture our approach, we illustrate our method with a minimal Transformer Program, containing only categorical attention layers. This model was trained to perform a simple in-context learning task (described in more detail in Section 4.1) and is depicted in Figures 2 and 3. In Section 3.3, we show we extend our framework to support a broader set of operations.

### Disentangled residual stream

Our first constraint is to ensure that the model maintains a disentangled residual stream. This means that the token embeddings encode the values of a fixed set of named variables, with each variable encoded in an orthogonal subspace. This constraint is illustrated in Figure 2. In this example, the initial input embedding encodes the values of two categorical variables, corresponding to the token and position embeddings. Each attention layer then reads a fixed set of variables from the residual stream and writes a new variable to a dedicated address.

**Reading from the residual stream.** To ensure that each module reads a fixed set of variables, we parameterize each projection matrix by a one-hot indicator vector over the available variables.

Suppose the residual stream encodes \(m\) categorical variables, all with cardinality \(k\), resulting in input embeddings \(\{0,1\}^{N mk}\). Then each projection matrix \(^{mk k}\) is defined by an indicator \(\{0,1\}^{m}:_{i=1}^{m}_{i}=1\). That is, \(=[_{1}_{k};;_{m}_{k}]^{}\), where \(_{k}\) is the \(k k\) identity matrix. Concretely, this means that each attention head is associated with three gate vectors, \(_{K},_{Q},_{V}\), defining the key, query, and value variables, respectively.

Writing to the residual stream.To ensure that the residual stream remains disentangled, we constrain each module to write its output to a dedicated, orthogonal subpace, taking inspiration from Tracr. In practice, we accomplish this simply by concatenating the module output to the input--i.e., if layer \(i\) consists of a single attention head \(h\), then \(_{i}=[_{i-1};h(_{i-1})]\). (This is equivalent to adding the output to the input after padding with zeros.) The output of each attention head is another categorical variable with cardinality \(k\), so the final embedding dimension is then \((2+L H) k\), where \(L\) is the number of layers and \(H\) is the number of heads per layer.

### Transformer Program modules

Next, we constrain each module to implement an interpretable, rule-based mapping between inputs and outputs. Here, we describe the primary modules in our programs, categorical attention heads; we extend this framework to additional modules in Section 3.3. Categorical attention heads can be decomposed into two operations, corresponding to the select and aggregate operations in RASP: first determining which queries attend to which keys, and then aggregating the corresponding values.

Computing the attention pattern.First, each attention head reads one key and one query variable, and then determines which queries should attend to which keys. In RASP, this operation is defined via a boolean predicate, which maps every combination of key and query to a value in \(\{0,1\}\). We implement a simple learnable predicate by associating each attention head with a one-to-one mapping between query values and key values (Figure 3). Assuming that all variables have cardinality \(k\), each attention head is associated with a binary predicate matrix, \(_{}\{0,1\}^{k k}\), with the constraint that each row \(_{,i}\) sums to one. The self-attention pattern is then defined by a score matrix \(\{0,1\}^{N N}\), with \(=_{Q}_{}( _{K})^{}\).

Aggregating categorical variables.We adopt a constraint from Tracr and require that each query token attends to a single key token; this constraint is necessary to ensure that the output variable will also be categorical. We enforce this by using hard attention, defining the output of head \(h\) as \(_{i}=hot}(_{j}_{i,j})\), where \(_{i}\) denotes the \(i^{th}\) row of the attention matrix. We implement hard attention so that, in the event that there is no matching key for a query, the model defaults to

Figure 2: We constrain the Transformer to have a _disentangled residual stream_: the token embeddings encode a fixed set of discrete variables in orthogonal subspaces, and each module reads a fixed set of variables and writes a new variable to a dedicated address. Here, we depict the residual stream of a Tranformer Program that was trained on a simple in-context learning task (Section 4.1).

attend to a beginning of sequence token; in the event that there is more than one matching key, the model attends to the closest match. More details are provided in the Appendix A.1.

**Optimization.** Consider a Transformer Program with a single categorical attention head, with \(m\) input variables of cardinality \(k\). This model is defined by the indicators \(_{K},_{Q},_{V}\) and the predicate matrix \(_{}\). To learn Transformer Programs, we optimize a distribution over these discrete program weights. For each gate \(_{K},_{Q},_{V}\), we define a parameter \(_{K},_{Q},_{V} ^{m}\). For row in the predicate matrix \(_{}\), we define parameters \(_{1},,_{k}^{k}\), with \(_{i}\) defining a distribution over the \(i^{th}\) row. Referring to these parameters collectively as \(\), we define a distribution over discrete Transformer weights \(p()\) as the product of categorical distributions, which we optimize using the Gumbel reparameterization (Jang et al., 2017). Given a classification dataset \(\) consisting of inputs \(\) and labels \(y\), we minimize the loss

\[=_{ p( )}[_{,y}[-  p(y;)]]_{s=1}^{S}_{,y}[- p(y ;_{s})],\]

where \(_{s}\) is a sample from the product of Gumbel-Softmax distributions, with softmax temperature \(>0\), and \(S\) is a hyper-parameter denoting the number of samples per training step. Transformer Programs also include a discrete \(\) operations in hard attention, which we also relax using the Gumbel-Softmax. We anneal the Gumbel temperature over the course of training. As \( 0\), the samples are identical to one-hot samples of the corresponding categorical distribution.

**Extracting programs.** After training, we obtain a discrete model by taking the maximum likelihood weights, \(^{*}=_{}p( )\), and applying the \(\) operation for hard attention. We then implement a deterministic mapping to convert the model to a Python program, inspired by RASP (Figure 4). Specifically, we convert each attention head \(h\) into a predicate function, which maps each possible pair of query and key values to a value in \(\{0,1\}\). The attention operation is then

Figure 4: After training, we convert the model into an equivalent Python program, modeled on RASP. This code corresponds to the attention heads illustrated in Figure 3.

Figure 3: We further constrain each module to implement an interpretable, rule-based mapping between input and output variables. This figure depicts the categorical attention module, which defines a one-to-one correspondence between key and query variables. In this example, the first attention layer outputs the value of the tokens variable from the preceding position. The second attention layer uses this output to implement a simple induction head (Olsson et al., 2022), mapping each letter token to a number that is preceded by the same letter.

implemented by a library function, select_closest, which selects the closest key satisfying the predicate, or the first token in the sequence if there is no match.

### Extensions

This framework can be extended to support additional modules, provided that the module can be mapped to a program and optimized effectively. We introduce three extensions here, providing more details and examples in Appendix A.2.

**Learning word embeddings.** For synthetic tasks with a small vocabulary (i.e., \(||<100\)), we use fixed, one-hot token embeddings. For larger-scale NLP tasks, we learn a factored categorical embedding, representing each token as the product of \(m\) categorical variables, where \(m\) is another hyperparameter. That is, each word embedding is the concatenation of \(m\)\(k\)-dimensional one-hot embeddings. After training, these variables can be understood by inspecting the set of words taking on each value, which we illustrate in Figure 7.

**Aggregating numerical variables.** We also equip the model with a form of numerical attention, to facilitate operations like counting. We augment the input embeddings with a single scalar variable, which is fixed to be equal to one. In order to ensure that the resulting program is discrete, we implement a limited form of numerical attention, which guarantees that the output values are integers with a bounded range. This enables us to characterize downstream modules by enumerating the possible input values. This module loosely corresponds to the selector_width primitive from RASP. In Tracr and RASP, selector_width is implemented using one attention layer and one feed-forward layer. We "hard-code" it in the form of an attention-like head that reads categorical variables as key and query and a numerical variable as the value. As above, the module learns a binary predicate matrix mapping queries to keys, but aggregates values by taking a weighted sum. That is, given attention scores \(\{0,1\}^{M N}\) and value variable \(\), the output for the \(i^{th}\) token is defined as \(_{j=1}^{N}_{i,j}[j]\).

**Feed-forward layers.** Finally, we implement a simple feed-forward layer, designed to correspond to a lookup-table. Each feed-forward layer reads \(\) input variables, which are designated in advance to be either numerical or categorical variables, and outputs one new categorical variable. For example, assuming the residual stream encodes \(m\) categorical variables with cardinality \(k\), and \(n\) numerical variables. The output of a categorical feed-forward layer is defined as \(=hot}((f_{}(_{ }))\), where \(_{}^{(mk+n) k}\) is a projection matrix constrained, as above, to read \(\) categorical variables, and \(f:^{ k k}\) is an arbitrary transformation. (We implement \(f\) as an MLP with one hidden layer). This module can be fully described as a look-up table, mapping \(k^{}\) possible inputs to \(k\) outputs. An example of a learned MLP is illustrated in Figure 9.

## 4 Experiments

In this section, we learn Transformer Programs for a variety of tasks, including a simple in-context learning experiment (SS4.1); the suite of algorithmic tasks introduced by Weiss et al. (2021) (SS4.2); and two NLP tasks: named entity recognition and text classification (SS4.3). Additional implementation details for all experiments are provided in Appendix SSB, and we provide further ablations and analysis of the generated code in Appendix SSC.

### In-context learning

First, by way of illustration, we learn a Transformer Program for a toy task (Figure 5), designed to elicit a simple form of in-context learning Brown et al. (2020). The input to the model is a sequence of alternating letters and numbers that end with a letter. If the letter has appeared already in the sequence, the model should output the number that followed it. If the letter has not appeared before, the model should output an _unk_ token. We train an attention-only Transformer with two layers and one attention head per layer, with a vocabulary of four numbers and four letters, and trained on sequences of up to 10 tokens long. The token and position variables are fixed, one-hot indicators, meaning that the input embeddings encode two variables and the final embeddings encode four: tokens, positions, and one output variable for each attention head. The cardinality of each variable is \(k=10\). For this task, we use a causal attention mask.

Figure 5: Sample inputs and targets for a simple in-context learning task.

Results.The learned program achieves perfect accuracy on a held-out test set, and we can observe that the model learns to compose attention heads according to the _induction heads_ pattern identified by Elhage et al. (2021). The residual stream is illustrated in Figure 2, and the attention heads in Figure 3. The first attention head learns to read the position variable for both key and query. At each position, it attends to the key at the previous position and writes the value of the tokens variable as the value. The second attention head reads tokens as the query and the output of the previous head (head_0_0_outputs) as key. If the query is a letter, the head attempts to map it to a key that has the same letter written to head_0_0_outputs--that is, a number preceded by the same letter.

### RASP tasks

Next, we test whether we can learn Transformer Programs for a wider variety of algorithmic tasks. We use the tasks introduced by Weiss et al. (2021) to illustrate the RASP language, which are listed in Table 1. We train on small-scale instances of each task, setting the maximum sequence length to 16 for Dyck-1 and Dyck-2, and setting the maximum sequence length and vocabulary size to 8 for the remaining tasks. As above, we use fixed one-hot token and position embeddings and set the variable cardinality \(k\) to be equal to the maximum sequence length. For this setting, we introduce numerical attention and MLPs. We equip each model with an equal number of categorical and numerical attention heads, and categorical and numerical MLPs, fixing the number of MLP input variables to two, and perform a grid-search over the number of layers, attention heads, and MLPs per-layer.

Results.The results of this experiment are in Table 1. On five out of seven tasks, our method is able to find a program that gets more than 99% accuracy. The exceptions are Double-Histogram (98.4) and Most-Freq (75.69). These results show that, at least on short inputs, Transformer Programs can learn effective solutions to a variety of algorithmic tasks. On the other hand, in Appendix SSC.1, we find that the results degrade for longer inputs, suggesting that the model may not learn robust solutions to all tasks. Additional, we can observe that the learned models often use more layers and attention heads than we might expect. For example, Weiss et al. (2021) present RASP solutions for Sort and Reverse requiring only two layers and one attention head, while our best models use three layers and eight attention heads (four categorical and four numerical). These observations indicate that the solutions found by our method might be quite different from human-written solutions.

What kinds of programs does the model learn?To get a better sense for how the model solves these tasks, we examine a program that the model learns for the Sort task. We analyze a model with two layers and four attention heads per layer, which achieves greater than 99% accuracy, and compile it into a Python program of approximately 300 lines, excluding the classifier weights. We find that the program uses a variety of heuristics for sorting these sequences. For example, Figure 6 depicts the code for one of the first-layer attention heads. This head looks for a 1 or a 4 in the sequence. If it finds a 1, it increases the likelihood of outputting 1 at positions one or two, and if it finds a 4, it increases the likelihood of outputting 4 at positions three through six. In Appendix Fig.11, we use an interactive Python debugger to find a more sophisticated circuit, composing attention heads at two layers. We provide more examples in Appendix SSA.2 and analysis of the learned programs in Appendix SSC.2. In general, we find that the model learns a variety of non-trivial solutions, composing

  
**Dataset** & **Description** & **Example** & \(k\) & **L** & **H** & **M** & _Acc._ \\  Reverse & Reverse a string. & reverse(“abc”) = “cbba” & 8 & 3 & 8 & 2 & 99.79 \\ Histogram & For each token, the number of occurrences of that letter in the sequence. & 8 & 1 & 4 & 2 & 100.0 \\ Double hist. & For each token, the number of unique tokens with the same histogram value. & & hist(2”abbc”) = “2112” & 8 & 3 & 4 & 2 & 98.40 \\ Sort & Sort the input in lexicographical order. & 8 & 3 & 8 & 8 & 4 & 99.83 \\ Most-Freq & The unique input tokens in order of frequency, using position to break ties. & 8 & 3 & 8 & 4 & 75.69 \\ Dyck-1 & For each position \(i\), is the input up until \(i\) &  dyck1(”0”)” = “PTPTPTF” \\  & 16 & 3 & 8 & 2 & 99.30 \\ Dyck-2 & The same as above, but in Dyck-2. & 
 dyck2(”{})”)” = “PPPTPTF” \\  & 16 & 3 & 4 & 4 & 99.09 \\   

Table 1: The RASP tasks, as introduced by Weiss et al. (2021). We train Transformer Programs on small-scale instance of each task and report the number of layers (L), attention heads (H), and MLPs (M) used in the best-performing model. \(k\) denotes the variable cardinality, which is fixed at the maximum sequence length for each task.

operations at different layers to compute higher-order patterns. These solutions include both brittle heuristics and sensible strategies for the different tasks.

Comparison to standard Transformers.In Appendix Fig. 10, we provide additional results comparing Transformer Programs with standard Transformers on RASP tasks with different lengths and vocabulary sizes. Standard Transformers out-perform Transformer Programs across most tasks.3 Interestingly, we observe that both models show similar trends, with model performance degrading for tasks with longer sequences and larger vocabularies. Nevertheless, the Transformer Programs deteriorate more dramatically, with over a 50% accuracy gap relative to the standard Transformer in the most difficult setting. We discuss these scaling challenges in more detail in Section 6.

### NLP tasks: named entity recognition and text classification

Now, we turn to standard NLP tasks including named entity recognition  and text classification . (Due to space constraints, we present text classification results in Appendix SSC.4.) We first experiment with the English portion of the CoNLL-2003 Named Entity Recognition task . This dataset consists of sentences from Reuters news articles (14,041 train/3,250 validation/3,453 test sentences). The data is labeled according to an IOB2 tagging scheme, with each word being assigned to one of four entity types (PER, ORG, LOC, MISC) or marked as not an entity (0). We filter the dataset to sentences with at most 32 words and use a vocabulary of the 10,000 most common words, replacing the remaining words with an _unknown_ token. For these experiments, we use only categorical attention heads, with one categorical MLP per-layer. We fix the variable cardinality at 32 and perform a grid search over number of embedding variables, layers, and heads. The embedding parameters are initialized with 300-dimensional GloVe embeddings . We compare the Transformer Program with a standard Transformer, also initialized with GloVe embeddings with grid search of model dimension and number of layers and heads. More details are provided in Appendix SSB.3.

  
**Model** & **D** & **L** & **H** & _Precision_ & _Recall_ & _F1_ \\  Unigram baseline & - & - & - & 82.8 & 55.1 & 66.2 \\ Standard Transformer & 128 & 3 & 4 & 80.4 & 62.7 & 70.5 \\ Transformer Program & 32\(\)4 & 2 & 8 & 81.0 & 71.8 & 76.1 \\   

Table 2: Named entity recognition on the CoNLL 2003 shared task. For each method, we report the embedding dimension (D), number of layers (L), number of heads (H) of the best-performing model, and precision, recall and F1. For the Transformer Program, the embedding dimension is equal to the variable cardinality multiplied by the number of input variables. The unigram baseline predicts the class most commonly associated with each word in the training set.

Figure 6: _Left:_ This code corresponds to an attention head in a Transformer Program that was trained to sort sequences of up to eight tokens long, with beginning- and end-of-sequence tokens. At early positions, this attention head checks if there is a 1 in the sequence, and at later positions it looks for a 4. _Right:_ The classifier weights associated with this feature.

Results.The results are in Table 2. We compare the best-performing Transformer Program with a standard Transformer and with a unigram baseline, which predicts the tag most frequently assigned to each word in the training data. The Transformer Program achieves reasonable performance, on par with the standard Transformer. In particular, the Transformer Program surpasses the unigram baseline, demonstrating that the method learns to make use of contextual information to predict tags.

Interpretability.We illustrate the resulting program by examining how it distinguishes between two commonly confused classes, location entities (B-LOC) and organizations (B-ORG). To see how the model makes this distinction in general, we extract the linear classifier weights and identify the features with the largest difference between the two classes (Figure 7). The highest ranked features include word-level features (that is, components of the word embeddings); position information; and features computed by the attention heads. Working backwards through the program, we find that the model copies information from the neighboring words--for example, increasing the likelihood of B-LOC if the word is preceded by a preposition like "at" or "In".

## 5 Related work

Learning programs.Our work has precedent in a variety of existing work on program induction and neuro-symbolic methods (e.g. Reed and De Freitas, 2015; Cai et al., 2017; Andreas et al., 2016; Inala et al., 2020; Cranmer et al., 2020; Kim, 2021). In particular, a long line of work on Inductive Logic Programming (Muggleton and De Raedt, 1994; Cropper and Dumancic, 2022) has sought to learn symbolic logical programs from data, and a number of recent works have used neural networks to search for discrete logical expressions using differentiable reparameterizations (Payani and Fekri, 2019; Wang et al., 2021; Petersen et al., 2022). We differ from these methods in targeting programs for the Transformer and focusing on sequence modeling problems.

Transformers and formal languages.In addition to RASP (Weiss et al., 2021), a body of research has explored the connection between Transformers and formal languages. Much of this has aimed to

Figure 7: We examine how the program distinguishes location entities (B-LOC) from organization entities (B-ORG) by examining the feature weights with the largest gap between the two classes (7a). Many of the top features are components of the word embeddings, but the model also learns to use the attention heads to gather information from the context. For example, attention head attn_0_3 copies one of the embedding variables from the previous position (7b). It promotes the B-LOC label if the value is Var3.V03, which includes prepositions like “at” and “In” (7c). We represent the embedding variables as Python Enum objects, which facilitates analysis using a debugger.

formally characterize the expressivity of Transformers with hard attention (Hahn, 2020; Merrill et al., 2022; Hao et al., 2022). Giannou et al. (2023) show how Transformers can act as programmable computers by designing a Transformer that can execute programs written in a single-instruction language. Another line of work has attempted to extract deterministic automata, or rules, from neural networks, largely focusing on recurrent neural networks (Jacobsson, 2005; Wang et al., 2018; Weiss et al., 2018). Merrill and Sabharwal (2022) show theoretically that any fixed-precision Transformer can be expressed as a formula in a type of first-order logic. In contrast to this work, our goal is to design a more interpretable Transformer, rather than extract rules from an existing network.

**Interpretable machine learning models.** Some prior work has introduced architecture changes aimed at making Transformers more interpretable, including sparse attention (Zhang et al., 2021) and changes to the activation function (Ehlage et al., 2022). These methods make some components of the Transformer qualitatively easier to understand; in contrast, our method results in a model that can be fully described by a discrete program. More generally, a growing body of work has sought to develop intrinsically interpretable machine learning models (e.g. Wang and Rudin, 2015; Chen et al., 2019; Rudin, 2019), a motivation we share in this work.

## 6 Conclusion and discussion

We introduced a method for training Transformers that can be deterministically mapped to discrete, human-readable programs. We showed that our method is capable of learning effective solutions for a several synthetic and real-world tasks, and that the resulting programs are easy to interpret. In particular, converting Transformers into programs offers practical benefits--for example, we can use standard code-analysis tools to debug errors. On the other hand, learning discrete programs introduces considerable modeling and optimization challenges. We conclude by mentioning some limitations of our method, which we believe represent promising avenues for future work.

**Scaling challenges.** While we were able to learn a number of effective Transformer Programs, we found that they can struggle to learn on longer inputs, and to learn parsimonious solutions. Are these errors because the framework is not expressive enough, or are they due to optimization issues? Our results suggest that the main issue is optimization. This is evident from the fact that, for many tasks, we can write a Transformer Program that would achieve perfect accuracy, but our method fails to learn these solutions. We conduct a more detailed case study of some optimization failures in Appendix C.3. Therefore, future work is needed to develop better methods for discrete optimization. Additionally, our experiments use a restricted set of modules that may be less expressive than standard Transformers. For example, hard-attention Transformers are less expressive than standard Transformers (Hahn, 2020; Hao et al., 2022). These restrictions can be relaxed in part by introducing new modules within this framework. We discuss some extensions in Appendix A.4, but leave this direction to future work.

**Are the programs interpretable?** We have argued that our discrete Transformer Programs are more interpretable than standard Transformers, but one might question whether programs are actually easier to understand, especially as we learn larger programs for more complex tasks. On one hand, these programs are interpretable in the sense that we can trace how information flows between different positions and model components, and we can inspect the program using off-the-shelf code analysis tools, like debuggers. For more complex tasks, the program can be understood as a collection of individually interpretable feature functions, rather than a single interpretable algorithm (as illustrated in Figure 7). Nonetheless, the learned programs can still be complicated and non-intuitive. Another avenue for future work is to explore methods for automatically analyzing the resulting programs, and for imposing an inductive bias in favor of more interpretable programs.