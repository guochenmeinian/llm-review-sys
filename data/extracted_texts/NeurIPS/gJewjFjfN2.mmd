# Fed-GraB: Federated Long-tailed Learning with Self-Adjusting Gradient Balancer

Zikai Xiao1,  Zihan Chen2  Songshang Liu1  Hualiang Wang3  Yang Feng4

Jin Hao5  Joey Tianyi Zhou6  Jian Wu1  Howard Hao Yang1

Zhozhu Liu1\({}^{}\)

\({}^{1}\)Zhejiang University,

\({}^{2}\)Singapore University of Technology and Design,

\({}^{3}\)The Hong Kong University of Science and Technology,

\({}^{4}\)Angelalign Technology Inc,

\({}^{5}\)State Key Laboratory of Oral Diseases, Sichuan University,

\({}^{6}\)Centre for Frontier AI Research (CFAR), A*STAR, Singapore

zikai@zju.edu.cn

Co-first author.

###### Abstract

Data privacy and long-tailed distribution are the norms rather than the exceptions in many real-world tasks. This paper investigates a federated long-tailed learning (Fed-LT) task in which each client holds a locally heterogeneous dataset; if the datasets can be globally aggregated, they jointly exhibit a long-tailed distribution. Under such a setting, existing federated optimization and/or centralized long-tailed learning methods hardly apply due to challenges in (a) characterizing the global long-tailed distribution under privacy constraints and (b) adjusting the local learning strategy to cope with the head-tail imbalance. In response, we propose a method termed Fed-GraB, comprised of a Self-adjusting Gradient Balancer (SGB) module that re-weights clients' gradients in a closed-loop manner based on the feedback of global long-tailed prior derived from a Direct Prior Analyzer (DPA) module. Using Fed-GraB, clients can effectively alleviate the distribution drift caused by data heterogeneity during the model training process and obtain a global model with better performance on the minority classes while maintaining the performance of the majority classes. Extensive experiments demonstrate that Fed-GraB achieves state-of-the-art performance on representative datasets such as CIFAR-10-LT, CIFAR-100-LT, ImageNet-LT, and iNaturalist. Our codes are available at https://github.com/ZackZikaiXiao/FedGraB.

## 1 Introduction

Federated learning (FL) is an approach for massively distributed clients to train a global machine learning model collaboratively without exposing their private data, which has garnered ever-increasing attention in academia and industry alike . Unlike conventional machine learning methods, FL brings the learning objective directly onto the end-user devices for local training, where only the intermediate parameters (e.g., gradients) need to be sent to a server for model aggregation and update. This approach not only substantially reduces the communication overheads but, more importantly, facilitates the clients in obtaining a generic global model without sharing their private data, thereby contributing to the development of trustworthy intelligent systems . Despite its great potential,realizing FL also requires one to overcome new hurdles in real-world implementations, among which a particular challenge stems from data heterogeneity, i.e., the non-IID distribution and imbalanced dataset sizes across clients [4; 5; 6; 7]. These factors often give rise to a pernicious issue where the data set of different clients jointly follows a global long-tailed distribution, which is commonly known as the Federated Long-Tailed learning (Fed-LT) problem [8; 9]. For instance, patients' diagnosis varies substantially across medical centers but collaboratively form long-tailed distributions for certain diseases [10; 11]. In a broad range of applications, performance on the minority classes (i.e., tail classes) , such as rare diseases, dangerous behaviors in autonomous driving [13; 14], and abnormal breath or heart rates in wearable devices , play a pivotal role in developing reliable and robust solutions to an FL system.

The difficulty in addressing the Fed-LT problem primarily stems from the fact that although clients' datasets can be locally balanced, globally, i.e., if the datasets were aggregated, the distribution may be long-tailed. As clients would not disclose their data information due to privacy concerns, identifying the global long-tailedness in data distribution could be onerous. To that end, a natural question arises:

Question 1: _How to leverage the global long-tailed statistics, especially for the minorities that need to be carefully tailored, without conflicting with privacy concerns?_

On the other hand, even if the globally long-tailed data information is available, existing methods do not directly apply to address such a problem. Specifically, typical FL methods cope with data heterogeneity via generic techniques such as dynamic regularizations, client selections, data augmentation, distillation, and personalization training [16; 17; 18; 19; 4; 20; 21]. These approaches ignored the diverged/imbalanced class levels that can result in the global long-tailed issue [22; 23]. Hence, they cannot guarantee decent performance for the tail classes. A key ingredient to improve long-tailed learning is to boost the performance of tail classes without degrading the performance of the head classes [24; 25]. While several learning methods dedicated to long-tailed data exist, they usually assume global class priors for re-balancing, which are not available in the context of FL due to privacy concerns . Moreover, these methods may not be applicable in local training as local distributions could present diverse long-tailed characteristics and/or are not even long-tailed . As such, it begs another question as follows:

Figure 1: (a): An illustration of the Fed-GraB framework, in which SGB is mounted on all classes of each client based on the prior vector \(_{c}\) derived by the DPA module, ensuring federated balanced local training; (b): Comparison for the difference of positive and negative gradients.

Figure 2: An example of the global and local distributions of CIFAR-10-LT (Left) and CIFAR-100-LT (Right) under non-IID setting. The bar on the top demonstrates the sorted global long-tailed distribution. Each row represents the diverse statistics of class imbalance of each client.

Question 2:_How to perform local training to synergistically aggregate a global model that excels on both majority and minority classes under the FL setting?_

A possible choice is to re-balance the clients' local gradients via approaches such as Seasaw loss  or Equalization Loss v2 . However one needs to customize these methods on different clients with heuristically selected hyper-parameters, resulting in complicated models with limited generalization capability. Moreover, the trained local models may have huge variance, as illustrated in Fig. 4 (a), and hardly formulate a synergistic model to handle tail class.

In light of the above challenges, this paper proposes Fed-GraB, comprised of a long-tailed statistic analyzer and a gradient rebalance, for the Fed-LT problem, as illustrated in Fig. 1. More specifically, we develop a federated weight-norm-based method, coined as the Direct Prior Analyzer (DPA), to derive a prior vector for global data statistics, utilizing the weight parameters from the global classifier. To overcome the degradation caused by the distribution discrepancy between the server and clients (or amongst the clients) in Fed-LT, we establish a self-adjusting gradient balancer (SGB) based on the estimated global head-tail characteristics, which is integrated at every client to re-balance the positive and negative gradients in a class-wise and privacy-preserving manner. A marked advantage of Fed-GraB is that it trains all heterogeneous clients in a _feedback-based closed-loop_ manner, encouraging all clients to contribute to the global long-tailed recognition task collaboratively. We also provide comprehensive theoretical and empirical analyses to verify the effectiveness of Fed-GraB. We conduct excessive experiments on multiple benchmark datasets (including the CIFAR-10/100-LT, ImageNet-LT, and iNaturalist) with both long-tailed and non-IID data distributions. The results demonstrate that Fed-GraB outperforms state-of-the-art (SOTA) baselines, including federated optimization for heterogeneous data, FL methods for LT classification, and centralized LT learning methods in FL settings.

## 2 Related Work

### Federated learning with data heterogeneity

Numerous FL approaches have been developed to cope with the heterogeneous or imbalanced data distribution. For instance, FedProx, FedDyn, and MOON modify the local loss function by adding regularizers at the local side. SCAFFOLD proposes a control variates-based method to reduce the clients' distribution drift brought by the discrepancies. FedIR dynamically adjusts the sampling ratio of each client based on each client's contribution and data distribution situation. And FedNova is proposed to tackle the induced objective inconsistency problem. On the server side, FedAvgM and FedAdaGrad are proposed to mitigate the performance degradation. Moreover, FL-oriented client selection [30; 31] and data augmentation strategies  have been investigated to enhance the performance. To address the poor generalization of a single generic model, personalization training methods have been recently explored to maintain multiple personalized local models [33; 34; 21]. However, most of these methods pay more attention to the discrepancies in inter-client distributions while ignoring the inconsistency among different classes, failing to achieve satisfactory performance on the tail classes. In lieu of this, an alternate paradigm  solely addresses the personalized long-tail conundrum, disregarding the variances within inter-client distributions. Notable exceptions could be found in [8; 36; 6] to tackle class imbalance. Still, they require the exchange of local features , private local data distribution , and auxiliary data , which would lead to potential privacy issues.

### Long-tailed learning

Long-tailed data widely exists in real-world machine learning tasks, where head classes dominate the training [10; 37]. To tackle the poor performance of tail classes in such scenarios, many approaches have been explored to boost the performance of tail classes via class re-balancing, information augmentation, and module improvements [38; 39; 40; 41; 25]. Re-balancing strategies, as the mainstream approaches in long-tailed learning, can be categorized into class re-sampling, re-weighting, and logit adjustments [10; 42]. Re-sampling approaches [43; 44; 45; 46] address the class imbalance via over-sampling tail classes or under-sampling head classes. On the other hand, the re-weighting approaches aim to balance the loss([47; 48; 49; 50]) or gradients (Seesaw loss , Eqlv2 ). Specifically, Focal loss  increases the prediction probabilities to achieve better prediction performance for tail classes. And a label-distribution-aware margin loss LDAM is introduced by  using label frequency. Moreover, a multi-expert framework (TADE ), prototype learning (OLTR ), and head-to-tail knowledge transfer (LEAP ) have been proposed for improved long-tailed data performance. However, such methods' effectiveness may be constrained in Fed-LT due to discrepancies in local and global statistics.

## 3 Method

### Preliminaries

**Federated Learning:** Consider an FL system with \(N\) clients and an \(M\)-class visual recognition dataset \(=\{_{k}\}_{k=1}^{N}\) for classification tasks. \(_{k}\) denotes the local dataset of client \(k\) with size \(|_{k}|\). Usually, the FL training process iterates multiple communication rounds until convergence. In a typical communication round \(l\), the central server randomly selects a subset of clients \(_{l}\) and distributes the latest global model \(w^{l}\) to them. For client \(k_{l}\), it performs local update to \(w^{l}\) based on \(_{k}\), where the locally computed model is denoted as \(w^{l}_{k}\). At the end of the round, the global model could be updated by the aggregation criterion (e.g., FedAvg) for the next round computation.

**Long-tailed distribution in FL:** To characterize the long-tailed data distribution in Fed-LT, we measure the imbalance factors in global perspectives, which is denoted by IF\({}_{}\) and computed over the global dataset \(\). We could employ a predefined imbalance IF\({}_{}\) to sample from balanced datasets, constructing long-tailed datasets; see Fig. 2 for visualization.

**Positive and Negative Gradients:** Notably, positive and negative cumulative gradients have an important effect on long-tailed tasks such as visual recognition , object detection , and instance segmentation . Suppose we have a neural network-based classification model with Cross Entropy loss as \(()=-_{i=1}^{M}y_{i}(_{i})\), with \(_{i}=}}{_{j=1}^{M}e^{_{j}}}\), where \(y_{i}\) is the ground truth label, \(=[z_{1},z_{2},,z_{M}]\) are the logits, and \(=[_{1},_{2},,_{M}]\) denotes the probabilities of the classifier. Given a sample with label \(j\), the positive gradients are defined as the derivative of the loss with respect to \(z_{j}\), while the rest shall be the negative gradients, i.e.,

\[^{}_{z_{j}}()=_{j},^{ }_{z_{irkj}}()=_{i}-1.\] (1)

### Direct Prior Analyzer (DPA)

This section details the proposed DPA module which calculates a prior vector for balanced training. It utilizes the same information required by FedAvg, without the need for extra data or distribution details. Essentially, DPA derives a prior probability vector that discerns potential tail classes by examining the L2-norm of the weight parameters within the classifiers. The reason for this design arises from existing studies [25; 54], revealing that a model recognizes head or tail classes via classifier and tends to give higher scores for head classes when trained with imbalanced data. Thus, the weight norm serves as an effective indicator of the imbalance degree since the norm of the active weights could empirically reflect the behavior and frequency of different classes. In particular, let \(w^{j}_{g}\) denote the weights of classifier \(j\) in the global model classifier with weights \(w_{g}\). The estimated global distribution would be given by \(_{c}=\{p_{j}\ |\ h(\|w^{j}_{g}\|_{2})\}\), where \(h()\) is a linear transformation for scaling the norm to share of the total. This estimation can be executed after global model aggregation with full client participation.

In the Fed-GraB implementation, the prior vector \(_{c}\) derives from DPA at the onset of local training. It is also worth mentioning that \(_{c}\) does not need to be perfect and only requires information that reflects the model prediction inclinations at the class level, rather than a complete correspondence with the distribution itself. See more detailed analysis in experiments.

Figure 3: The closed-loop in SGB. \(^{pos}_{j}(t),^{neg}_{j}(t)\) are updated according to the controller, and the re-weighted gradients are stored in the _collector_ for future cumulative computation of \(_{j}(t)\).

### Self-adjusting Gradient Balancer for Fed-LT

This part establishes the Self-adjusting Gradient Balancer (SGB), an effective tool that can be integrated into biased classifiers to re-balance local training and improve the overall performance. Particularly, we consider the difference between cumulative positive and negative gradients \((t)\), with \(_{j}(t)\) for class \(j\) defined as \(_{j}(t)=g_{j}^{pos}(t)-g_{j}^{neg}(t)\), where \(g_{j}(t)=_{i=0}^{t}_{z_{j}}(^{t})\) is the cumulative gradients of class \(j\), capturing the overall imbalance degree throughout the training process. In a toy balanced scenario with \(M\) samples each with equal probability to the \(M\) classes, the expected target \(z_{j}(t)\) of \(_{j}(t)\) is:

\[E(z_{j}(t))=_{i=1}^{M-1}(E(_{i}(t))-1)-E(_{j}(t))=0,\] (2)

indicating that \((t)\) approaches zero when the distributions become identical.

The core idea of SGB is to consistently align \(_{j}(t)\) to 0 for tail classes in a closed-loop and self-adjusting manner. Specifically, we carry out a proportional-integral-derivative controller  to continually update the re-weighting coefficients of gradients with regard to the logits in a class-wise manner, as demonstrated in Fig. 3. The re-weighting process is based on adaptive self-adjustment with error feedback until \((t)\) reaches the pre-determined balanced target, rather than following heuristic methods as [26; 27]. The error feedback \(e_{j}(t)=_{j}(t)-z_{j}(t)\) for class \(j\) represents the distance between the current status \(_{j}(t)\) and a target \(z_{j}(t)\) during training. Given \(e(t)\), the output of the controller in SGB is

\[u_{j}(t)=K_{P}e_{j}(t)+K_{I}_{j=0}^{t}e_{j}(t)+K_{D}(e_{j}(t)-e_{j}(t-1)),\] (3)

where \(K_{P}\), \(K_{I}\), and \(K_{D}\) are controlling factors. The proportional item with \(K_{P}\) shows the controller would give bigger re-weighting coefficients \(_{j}\) to compensate the imbalance for current larger errors. Meanwhile, the integral item with \(K_{I}\) could look back on the past errors to reduce the steady-state offset which could not be handled by the proportional item. Furthermore, as computing \(_{j}\) only with the proportional and integral loop could hardly achieve steady and smooth re-weighting, we introduce the third differential item with \(K_{D}\) to control the fluctuations based on future expectations. For instance, when \(_{j}(t)\) is close to \(0\), the differential item would prohibit \(u(t)\) from diverging re-weighting and vise versa. Overall, the three items work together to achieve quick, precise, and stable adjustments.

We first map \(u_{j}(t)\) through a simple activation function \(()\) to calculate \(_{j}^{neg}=(-u_{j}(t)),\;_{j}^{pos}=(u_{j}(t))\), where \((x)=}\). Then, we combine the global information obtained by DPA to calculate the final coefficients for positive and negative gradients per iteration as:

\[_{j}=_{r>_{c}[j]}[_{j}^{pos},_{j}^{ neg}]+_{r_{c}[j]},\] (4)

where \(()\) is the indicator function. Consequently, the re-weighted gradients are computed as:

\[_{z_{j}}^{^{}}(^{t}) =_{j}^{}(t)_{z_{j}}^{}(^{t} ),\\ _{z_{j}}^{^{}}(^{t})=_{j}^{ }(t)_{z_{j}}^{}(^{t}).\] (5)

The working mechanism of SGB at a typical client is summarized in Fig. 3. As depicted in Fig. 1 (a), SGB is implemented across all the classes in each client, with parameters adjusted in accordance with the prior vector derived by DPA. By utilizing global information, this approach encourages all clients to contribute coherently to the global model while simultaneously rectifying prediction biases arising from long-tailed datasets. As shown in Fig. 1 (b), SGB improves the balance between cumulative positive and negative gradients. See experiments and Supplementary for further analysis.

### Algorithm Summary for Fed-GraB

The training pipeline of our Fed-GraB framework is presented in Algorithm 1, which consists of two stages. First, DPA calculates the prior vector \(_{c}\) after receiving aggregated weights \(w_{k}^{l}\). Then, SGB is applied to all the classes. The local classifier would be dynamically adjusted with weighted positive and negative gradients via a \((t)\)-based closed-loop controller in accordance with prior vector \(_{c}\) derived from DPA. The combination with SGB and DPA is detailed in Eq. (4).

### Privacy discussions of DPA

As the local prior computation is performed at the client side, there would be a few privacy concerns with the DPA method. It is, however, noteworthy that the potential privacy issue exists in the general FL frameworks rather than specific to our proposed DPA method. For instance, gradient inversion  can pose a threat to almost all gradient transmission-based FL methods without any privacy-preservation techniques. As the privacy issue of the FL framework is beyond the scope of this work, we briefly include the discussion in this subsection.

## 4 Experiments

### Experimental Setup

**Baselines:** We consider two types of SOTA baselines: (1) FL-oriented methods to tackle data heterogeneity (FedProx, FedNova) or federated long-tailed data-oriented (FedIR and CReFF), and FedAvg is also included for reference; (2) Long-tailed learning (LT)-oriented methods (\(\)-norm, Eqlv2, LDAM, Focal-loss and GCL-loss) applied at local training of each client. We also provide the results of the long-tailed methods in centralized learning (CL) settings as the oracle performance upper bound, including SGB.

**Datasets:** We conduct the experiments in three benchmark datasets for long-tailed classification, i.e., CIFAR-10/100-LT, ImageNet-LT. CIFAR-10/100-LT are sampled into long-tailed distribution by exponential distribution controlled by IF, and we use the same configurations as in  for ImageNet-LT with the number of images per class ranging from 5 to 1280. To evaluate the performance on real-world data, we also conduct experiments on iNaturalist-User-160k, with 160k examples of 1,023 species classes and partitioned on the basis of iNaturalist-2017.

**Federated settings:** We use non-IID data partitions for all experiments, implemented via symmetric Dirichlet distributions with concentration parameter \(\) to control the identicalness of local data distributions among all the clients. We train a ResNet-18 over \(N=40\) clients on CIFAR-10-LT. ResNet-34 and ResNet-50 are used on CIFAR-100-LT and ImageNet-LT respectively with \(N=20\) clients. For iNaturalist-160k, we use the same settings as ImageNet-LT.

**Implementation of baselines:** For the sake of fairness, we keep consistent settings external for experiments. We conduct experiments using a starting model from FedAvg. For CReFF, the number of federated features is 100, we use 0.1, 0.01 as federated feature learning rate and main net learning rate respectively on CIFAR-10/100-LT. We report the official result  on ImageNet-LT. As \(\)-norm is a one-shot method, we provide a pre-trained model by FedAvg and adjust the classifier weights on the server as post-process. Focal-Loss and EQL v2 do not require distribution prior. We directly replace the local cross-entropy loss with their proposed re-balancing methods. For LDAM, we use the local data distribution for its local training.

### Comparison with State-of-the-art Methods

**Evaluation on CIFAR-10-LT:**

The performance of Fed-GraB/SGB on diverse settings are reported in Tab. 1. Notably, Fed-GraB achieves the best overall accuracies on all settings, with a significant improvement on the tail classes while ensuring good performance of the head classes. The performance gain becomes more evident under extremely imbalanced data. Moreover, the SGB implemented in the CL setting (i.e., performance upper bound testing) surpasses existing SOTA long-tail methods, further demonstrating the universal effectiveness of Fed-GraB under different scenarios.

**Evaluation on CIFAR-100-LT, ImageNet-LT, and iNaturalist-160k:** Tab. 2 shows that Fed-GraB consistently outperforms all baselines on test overall accuracies for CIFAR-100-LT and ImageNet-LT, with remarkable improvements on middle and tail classes. While LT-orientated methods obtain better results than the FL method in the extremely imbalanced ImageNet-LT, Fed-GraB can still surpass it3. The reason boils down to that for classification tasks with a large number of classes, local data samples for each class would be extremely small. In this case, the SGB with global prior for class-wise re-balancing is more effective in learning a better-aggregated model.

As for iNaturalist-160k, Fed-GraB significantly boosts the classification accuracy on tail classes while maintaining the best overall performance compared to FL methods. In comparison to LT-oriented methods, Fed-GraB's SGB provides a robust mechanism against data heterogeneity, leading to an outstanding performance on both 3-shot and overall metrics.

A salient advantage of Fed-GraB is that it achieves universal outperformance on three large-scale or real-world scenarios, demonstrating the robustness over other methods such as CReFF, \(-norm\) or Eqlv2-FL which attain good performance on a specific dataset.

**Evaluation of Communication Efficiency:** Tab. 3 presents the communication efficiency of different methods trained on CIFAR-10-LT under two non-IID settings. We compare the required communication efficiency of the proposed methods on CIFAR-100-LT and ImageNet-LT. We compare the proposed methods on CIFAR-100-LT and ImageNet-LT with the same settings.

   &  & _{0}\)=10} & _{0}\)=10} \\   & & Many & Med & Few & All & Many & Med & Few & All & Many & Med & Few & All \\   & Softmax & 0.901 & 0.879 & 0.886 & \(0.893_{0.003}\) & 0.908 & 0.776 & 0.742 & \(0.817_{0.003}\) & 0.920 & 0.745 & 0.675 & 0.767\({}_{0.601}\) \\  & Eqlv2 & 0.902 & 0.880 & 0.874 & \(0.890_{0.102}\) & 0.903 & 0.774 & 0.774 & \(0.819_{0.006}\) & 0.912 & 0.751 & 0.679 & 0.775\({}_{0.610}\) \\  & LJAM & 0.957 & 0.799 & 0.854 & \(0.838_{0.002}\) & 0.964 & 0.739 & 0.685 & \(0.753_{0.011}\) & 0.936 & 0.729 & 0.610 & 0.698\({}_{0.600}\) \\  & SGD-EL & 0.897 & 0.901 & \(0.901_{0.898}\) & \(0.898_{0.008}\) & 0.891 & 0.817 & \(0.833_{0.084}\) & \(0.864_{0.001}\) & 0.901 & 0.738 & 0.814 & 0.818\({}_{0.600}\) \\    & FedAvg & 0.896 & 0.858 & 0.846 & \(0.877_{0.001}\) & 0.858 & 0.771 & 0.693 & \(0.792_{0.005}\) & 0.922 & 0.716 & 0.616 & 0.737\({}_{0.601}\) \\  & FedProx & 0.898 & 0.859 & 0.854 & \(0.877_{0.002}\) & 0.891 & 0.773 & 0.691 & \(0.794_{0.002}\) & 0.921 & 0.725 & 0.852 & 0.729\({}_{0.602}\) \\  & FedProx & 0.912 & 0.853 & 0.848 & \(0.822_{0.002}\) & 0.903 & 0.757 & \(0.702_{0.003}\) & 0.934 & 0.734 & 0.599 & 0.739\({}_{0.600}\) \\  & FedProx & 0.966 & 0.823 & 0.862 & \(0.868_{0.001}\) & 0.972 & 0.775 & \(0.693_{0.003}\) & 0.969 & 0.755 & 0.756 & 0.728\({}_{0.600}\) \\  & CReFF & 0.911 & 0.850 & 0.887 & \(0.884_{0.002}\) & 0.896 & 0.769 & \(0.664_{0.003}\) & 0.791 & \(0.693_{0.003}\) & 0.935 & 0.723 & 0.574 & 0.726\({}_{0.600}\) \\  & \(\)-norm & 0.887 & 0.871 & \(0.908_{0.003}\) & 0.878 & \(0.790 & 0.725 & \(0.805_{0.002}\) & 0.922 & 0.726 & 0.668 & 0.700\({}_{0.600}\) \\  & Eqlv2-FL & 0.896 & 0.852 & 0.857 & \(0.875_{0.003}\) & 0.886 & 0.786 & \(0.690_{0.009}\) & 0.919 & 0.704 & 0.597 & 0.729\({}_{0.600}\) \\  & LJAM-FL & 0.901 & 0.845 & 0.825 & \(0.863_{0.004}\) & 0.884 & 0.739 & 0.662 & \(0.768_{0.005}\) & 0.891 & 0.638 & 0.495 & 0.679\({}_{0.602}\) \\  & Focal-FL & 0.887 & 0.839 & 0.834 & \(0.869_{0.005}\) & 0.877 & 0.744 & \(0.665 & \(0.775_{0.002}\) & 0.916 & 0.701 & 0.558 & 0.733\({}_{0.600}\) \\  & GCL-FL & 0.923 & 0.747 & 0.781 & \(0.796_{0.00}\) & 0.949 & 0.748 & \(0.699 & \(0.761_{0.005}\) & 0.963 & 0.726 & 0.608 & 0.726\({}_{0.600}\) \\  & FedGraB & 0.886 & 0.882 & 0.892 & \(0.885_{0.001}\) & 0.875 & 0.784 & \(0.775\) & \(0.818_{0.003}\) & 0.910 & 0.698 & 0.713 & 0.766\({}_{0.600}\) \\    & FedAvg & 0.890 & 0.864 & 0.861 & \(0.876_{0.002}\) & 0.865 & 0.772 & 0.685 & \(0.781_{0.003}\) & 0.906 & 0.720 & 0.585 & 0.719\({}_{0.600}\) \\  & FedProx & 0.883 & 0.864 & 0.863 & \(0.874_{0.000}\) & 0.857 & 0.776 & \(0.688 & \(0.782_{0.001}\) & 0.892 & 0.712 & 0.564 & 0.715\({}_{0.601}\) \\  & FedProx & 0.903 & 0.856 & 0.834 & \(0.877_{0.002}\) & 0.888 & \(0.773 & \(0.697 & \(0.788_{0.003}\) & 0.942 & 0.739 & 0.609 & 0.739\({}_{0.600}\) \\  & FedProx & 0.955 & 0.816 & 0.870 & \(0.866_{0.001}\) & 0.961 & 0.771 & \(0.698 & \(0.781_{0.001}\) & 0.976 & 0.762 & 0.562 & 0.715\({}_{0.600}\) \\  & CReFF & 0.900 & 0.838 & 0.880 & \(0.877_{0.004}\) & 0.878 & \(0.768 & \(0.664 & \(0.786_{0.003}\) & 0.932 & 0.699 & 0.580 & 0.718\({}_{0.600}\) \\  & \(\)-norm & 0.887 & 0.863 & 0.850 & \(0.857_{0.

[MISSING_PAGE_FAIL:8]

test accuracy. Furthermore, we visualize the accuracies of FedAvg and Fed-GraB after local updates on the received global model in Fig. 5 (a), which demonstrate that Fed-GraB can achieve better and more balanced performance across classes, especially for tails (e.g., class 2, 3, 8, 9).

**Mounting strategies with SGB:** In Fed-GraB, SGB is universally applied to all classifiers through the use of DPA, rather than selectively targeting specific classes without DPA. We demonstrate that a full mounting approach with DPA can more readily attain optimal performance compared to a custom-tailored tailed class (i.e., mounting on 7 to 9 classes). As depicted in Fig. 5 (b), the model excels when SGB is employed on tail classes, while accuracy diminishes when mounting all classes or solely the exceedingly biased classes. Notably, DPA significantly bolsters overall performance.

### Ablation Study and Model Analysis

**The target of \((t)\):** A critical step of SGB is to compute re-weighting coefficients \(\) by \(e(t)=(t)-z(t)\). Here we argue that for a static \(z(t)\), different values of \(z(t)\) would not lead to significant differences in training, as long as those values are not extremely biased. We visualize the training process with two different \(z(t)\) in Fig. 5 (c) by assuming a continuous scenario. The training would consist of two phases during the closed-loop controlling. The _Phase 1_ could be regarded as a noisy initialization stage which is usually very short, resulting in different initial values based on \(e(t)\). Afterward, the _Phase 2_ is started, and similar adjusting behaviors of \(e(t)\) could be observed, i.e., \((t)\) fluctuates around \(z(t)\), leading to similar \(\) that stands for re-weighting strength. As the duration \(\) of _Phase 1_ is negligibly short and would not impose significant influence for training. The experimental results with different target values in Fig. 6 (a) further demonstrate our argument. More analysis is presented in the Supplementary.

**Ablation on SGB hyper-parameters:** To investigate the effects of hyper-parameters \(K_{P}\), \(K_{I}\), and \(K_{D}\), we observe the real-time \((t)\) during the training process with various parameter groups, as depicted in Fig. 6 (b) using the parameter sets: \(K_{P}=1,10,10,10\), \(K_{I}=0,0,0,0.01\), \(K_{D}=0,0,0.1,0.1\). We notice that \(K_{P}=10\) (green) more effectively constrains \((t)\) around \(0\) compared to \(K_{P}=1\) (orange). To reduce fluctuations, we incorporate \(K_{D}=0.1\) (red). In this case, \((t)\) remains above \(0\), necessitating the introduction of \(K_{I}\) (purple) to correct the static deviation. Notably, SGB demonstrates substantial robustness to the parameter group, as further evidenced in the Supplementary.

Fed-GraB **on different imbalance levels:** To demonstrate Fed-GraB is versatile across different global data distributions, we conduct experiments with global imbalance factors ranging from 5 to 50. As shown in Fig. 6 (c), Fed-GraB achieves better performance than others on a broad range of IF\({}_{}\). The results indicate that Fed-GraB could alleviate the performance degradation in moderate imbalanced cases while yielding more significant improvements on highly imbalanced data.

**Computational and Storage Cost of SGB:**

The additional cost from SGB are mainly attributed to the computation and storage of \((t)\) and \(u(t)\). As shown in Eq. (3), the main computational steps are the differential and summation of \(e(t)\), which should be linearly proportional to number of the gradients. Such extra computational cost is analogous to the additional manipulations of gradients in advanced stochastic gradient decent methods such as Momentum or Adam . Overall, the extra computation which is implemented with several lines of code could be done very quickly. Besides, Fed-GraB needs some extra storage cost to store the weighted gradients which is quite cheap as well.

Figure 6: (a): Performance ablation with different \((t)\); (b): Ablation on different \(K_{P}\), \(K_{I}\) and \(K_{D}\) in Fed-GraB; (c): Performance evaluation with diverse IF\({}_{}\).

## 5 Conclusions and Limitations

We proposed Fed-GraB, a self-adjusting and closed-loop gradient re-balancing framework for Fed-LT tasks. Fed-GraB comprises DPA, a federated global long-tailedness analyzer, and SGB, a local gradient balancer, addressing the discrepancies in inter-client and inter-class statistics. We carried out extensive experiments to analyze the functionality of different components in Fed-GraB and demonstrate the efficacy of Fed-GraB in various Fed-LT configurations.

**Limitations.** In this work, we mainly focus on aggregating a global Fed-LT model, while extensions to include clients are of high interest such as training superior heterogeneous clients with with personalized strategies. Besides, experiments with real-world medical or autonomous vehicle datasets could be examined to further demonstrate the effectiveness of Fed-GraB.