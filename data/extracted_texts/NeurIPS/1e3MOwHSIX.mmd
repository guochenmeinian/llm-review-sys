# MAGNET : Improving the Multilingual Fairness

of Language Models

with Adaptive Gradient-Based Tokenization

 Orevaoghene Ahia1 Sachin Kumar2,3 Hila Gonen1 Valentin Hofmann2 Tomasz Limisiewicz4 Yulia Tsvetkov1 Noah A. Smith1,2

1University of Washington 2Allen Institute for AI 3The Ohio State University

4Charles University

oahia@cs.washington.edu

###### Abstract

In multilingual settings, non-Latin scripts and low-resource languages are usually disadvantaged in terms of language models' utility, efficiency, and cost. Specifically, previous studies have reported multiple modeling biases that the current tokenization algorithms introduce to non-Latin script languages, the main one being over-segmentation. In this work, we propose MAGNET--multilingual adaptive gradient-based tokenization--to reduce over-segmentation via adaptive gradient-based subword tokenization. MAGNET learns to predict segment boundaries between byte tokens in a sequence via sub-modules within the model, which act as internal boundary predictors (tokenizers). Previous gradient-based tokenization methods aimed for uniform compression across sequences by integrating a single boundary predictor during training and optimizing it end-to-end through stochastic reparameterization alongside the next token prediction objective. However, this approach still results in over-segmentation for non-Latin script languages in multilingual settings. In contrast, MAGNET offers a customizable architecture where byte-level sequences are routed through language-script-specific predictors, each optimized for its respective language script. This modularity enforces equitable segmentation granularity across different language scripts compared to previous methods. Through extensive experiments, we demonstrate that in addition to reducing segmentation disparities, MAGNET also enables faster language modelling and improves downstream utility.

## 1 Introduction

Despite the proliferation of generative language models (LMs) in English, their non-English counterparts are far from being widely adopted. While multilingual LMs offer several advantages such as resource efficiency and cross-lingual generalization, the performance disparities across languages remain a significant challenge. Previous work has largely attributed these disparities to training data imbalances across languages . Recent work, however, highlights that _tokenization_-- the way input text is segmented--can considerably degrade not only model performance but also training and inference costs on account of overly fragmenting certain languages and scripts . Subword segmentation algorithms used to build LM tokenizers  typically segment the training corpus relying on frequency statistics alone. Due to data imbalances, they obtain high compression in high-resource languages, while majority of languages are over-fragmented. This issue disproportionately affects non-Latin scripts covering languages spoken by billions of people, which are not only less frequent in such corpora, but can require up to \(4\) more bytes to represent the same information.

[MISSING_PAGE_FAIL:2]

MAGNET: Multilingual Adaptive GradeNet-basEd Tokenization

Our goal is to build a multilingual byte-level language model with equitable segmentation across languages. We propose to achieve this by dedicating a separate module within the model for each writing script, to serve as an internal tokenizer for languages that use that script. Our proposed model, called MAGNET, builds on _hourglass transformers_, an architecture that was introduced to efficiently handle long sequences in tokenizer-free models. We make several simple but important modifications to this architecture in order to obtain equitable segmentation across languages, while maintaining a high quality of multilingual modeling. In what follows, we explain the main concepts of hourglass transformers, and then introduce the modifications we make to accommodate equitable multilingual modeling.

### Background: Hourglass Transformers

The hourglass transformer  is a hierarchical architecture for efficiently handling long sequences. The architecture has three main components, each consisting of one or more transformer layers: A **tokenization submodule** which takes as input a byte sequence and outputs a segmentation, a **language modeling submodule** that takes as input the predicted segments or tokens and is then trained to perform next token prediction, and an **upsampling module** that takes as input the hidden representations of the segmentations and converts them back to a byte sequence on which a typical language modeling loss can be applied. Considering this model as a blackbox, it still performs byte-level language modeling, however, it requires significantly less compute thanks to the tokenization submodule.

Gradient-based TokenizationThis submodule performs two steps. First, the given input sequence \(x_{1},,x_{N}\) (where each \(x_{t}\) is a byte in our case) is encoded using a small transformer network (with causal attention) to produce a sequence of hidden vectors \(h_{1}^{T},,h_{N}^{T}\). Next, a _boundary predictor_ takes as input each \(h_{t}\) and predicts a scalar value between \(0\) and \(1\), indicating the probability of position \(t\) to be the end of a segment. It is implemented as

\[_{t}=p(b_{t}=1)=(_{}(h_{t})),\] (1)

where MLP indicates a multi-layer perceptron and \(\) is the sigmoid function. To convert the soft probabilities to hard segment predictions, a Bernoulli distribution is sampled from, defined by \(_{t}\). Since the sampling operation will make the process non-differentiable, hard Gumbel-sigmoid is used, a stochastic reparameterization of the Bernoulli distribution, following Nawrot et al. :

\[b_{t}=_{t}u}{(1-_{t})(1-u)} , u(0,1)\] (2)

where \(\) is a hyper-parameter. Since this module is differentiable, the segmentations are learned during training of the full model.3 This module is referred to as "gradient-based tokenization."

Language ModelingGiven a sequence of segment boundaries \(b_{t}\{0,1\}\) from the boundary predictor, this submodule first pools the hidden states belonging to the same segment by averaging them to form a sequence of representations \(h_{1}^{P},,h_{k}^{P}\).4 Let \(t_{1},,t_{k}\) indicate the positions at which a boundary is sampled, i.e., for any contiguous pair \(t_{j},t_{j+1}\), the sequence \(x_{t_{j}+1} x_{t_{j+1}}\) forms a "token" ending at position \(t_{j+1}\).5 The input representation of this "token" is defined as \(hP_{j}=-t_{j}}_{t=t_{j}+1}^{t_{j+1}}hT_{t}\). These representations are then passed through the middle block of transformer layers (with causal attention) to obtain another sequence of hidden representations \(h_{1}^{M},,h_{k}^{M}\). From the perspective of a subword-tokenizaton based language model, this module is equivalent to the transformer blocks without the input and output embedding layers.

UpsamplingThis module converts \(h_{l}^{M}\) to probabilities over a byte vocabulary. This involves, first, upsampling the output of the middle block to the original resolution by duplication followed by skip connection: \(h_{t}^{U}=h_{}^{M}+h_{t}^{T}\).6 These vectors are further passed through a small transformer network followed by an unembedding layer and a softmax to get a probability distribution over which language modeling loss (cross entropy) can be computed. To prevent the boundary predictor from collapsing and trivially predicting each position \(t\) as a boundary, Nawrot et al.  propose adding a regularizer to the LM objective: \(-(;l,k)\) where,

\[(;N,k)=^{k}(1-)^{N-k}, k=_{N}b_{t}.\] (3)

Here \(\) is a hyperparameter, \(k\) defines the number of predicted segments or tokens. Intuitively, this loss nudges the model to find a \(k\) close to \( l\) which is the mode of the Binomial distribution. In other words, \(\) allows to control the compression rate of the input sequence to approximately \(\). Setting it as \(1\) will lead to every position being predicted as boundary whereas setting it to \(0\) will cause no boundaries to be predicted.

### Adaptive Gradient-Based Tokenization via Multiple Boundary Predictors

To encode the same information, different languages require different number of bytes, owing to their different inherent efficiencies [3; 25; 33] as well as restrictions imposed by Unicode mappings, where non-Latin languages (e.g., Indian languages) may require up to 4 bytes per character.78 In multilingual models, setting the same compression rate (via \(\)) for all languages will lead to text in some languages getting segmented into much longer sequences,9 see Equation (3). This disparity contributes to higher compute and memory costs for such languages as well as poorer model performance for downstream tasks . This issue parallels subword tokenizers where languages with higher segmentation rates get disadvantaged due to longer context-length requirements to perform the same task and poorer in-context learning performance since the same context length fits fewer training instances than other languages leading to unfairness [5; 3; 25; 33].

To make tokenization more equitable, we propose MAGNET, which efficiently learns to segment sequences across languages and language scripts with similar granularity. As part of creating equitable segmentation, we aim to efficiently maximize sequence compression, without having a negative impact on downstream performance across languages.

Introducing multiple gradient-based tokenizersTo achieve this, we propose a modification to the model architecture that enables the processing of multiple language scripts. Each script has its own boundary predictor trained with distinct Binomial priors \(\) determined based on the scripts' Unicode encoding and also tailored to a desired compression rate. This allows us to achieve similar fragmentation rates across languages, due to variations in compression. The input sequence is tagged with its script10 and we infer the segmentation by routing it through the appropriate boundary predictor. The remainder of the model architecture remains the same.

Determining \(\) for equitable tokenizatonWe use the binomial priors \(\) for each boundary predictor to control the rates of the resulting segmentations for the different scripts. Since we want to impose equitable lengths across languages, we set the different \(\) according to the following process. First, we choose an _anchor language_\(L\) for each script in our training corpus and define a quantity _byte-to-word ratio_\(\) for this script as follows. Let \(=\{_{1},,_{D}\}\) be a sample of text sequences in language \(L\) from our training corpus with \(|_{i}|\) denoting the byte-length and \(_{}(_{i})\) the number of words11 in sequence \(_{i}\). We define the average byte-to-word ratio \(\) over \(\) as:

\[=_{i=1}^{D}_{i}|}{_{ }(_{i})}\] (4)We then set the prior \(_{S}\) for the corresponding script \(S\) to be \(1/\). Our final training objective over a single instance **x** is as follows:

\[_{i=1}^{N}-\,p_{}(x_{i}|x_{<i})-_{S}( ()=S)\,\,(_{S};N,k)\]

where \(\) is the indicator function and \(()\) is a function assigning a writing script to a sequence of bytes **x**, such assignment can be easily obtained based on codepoint definitions in Unicode.

## 3 Experimental Setup

### Language Modeling

Pretraining DataWe pretrain all models on nine languages (English, Spanish, French, Russian, Ukranian, Belarusian, Telugu, Bengali and Hindi) divided into three groups, written with distinct scripts: Latin, Cyrillic, and Indic (Brahmic) scripts. Our choice of selection is based on the linguistic diversity of these languages and the availability of data for downstream evaluation. Our pretraining data is obtained from the OSCAR dataset . We present the statistics for each language in Appendix C.

BaselinesWe compare MAGNET against Dynamic Token Pooling , which infers boundaries with a fixed binomial prior \(\) for every sequence, irrespective of the language script. This model is referred to as DTP in the rest of the paper. DTP has a single boundary predictor; we train two versions of this baseline with the binomial prior \(\) as 0.2 and 0.1 respectively yielding 5\(\) and 10\(\) compression respectively. We also compare against a byte-level decoder language model. To ensure fair model comparisons, this model has a similar architecture as DTP, but without any sequence compression.

MAGNET configurationsWe compute the byte-word-ratios', choosing English, Russian and Telugu as anchor languages for each the language script, based on initial explorations. The FLORES  dataset is used for this purpose and the resulting ratios are approximately 5\(\), 10\(\), and 20\(\) for English, Russian, and Telugu, respectively. Based on these ratios, we train five MAGNET models with different binomial prior combinations maintaining the ratio but adjusting the multipliers. First, to optimize for word-level boundary segmentation, we use the original byte-to-word ratio configuration, i.e., 5\(\) compression for Latin, 10\(\) compression for Cyrillic and 20\(\) compression for Indic languages within the same model. The second configuration; \((1,2,4)\) is the average bytes-to-character ratio for English, Russian and Telugu. Hence, using this configuration optimizes for fair byte-level-modelling with character-level granularity. The third configuration \((3,6,12)\) is based on a hypothesis that it would lead to fair subword-segmentation boundaries. Finally, since we apply a very high compression on Indic languages, we empirically test two additional configurations \((5,10,13)\) and \((5,10,15)\) with a reduced compression rate for Indic languages.

Subword Tokenizer TrainingTo compare the segmentation derived from MAGNET to traditional subword tokenizers, we create byte-level byte pair encoding (BPE) vocabularies containing 50K, 100K and 250K subword units on our pretraining data. We employ \(\)-sampling to train the tokenizers, typically used to improve representation of low-resource languages . That is, we sample documents for each language according to a multinomial distribution with probabilities \(\{q_{i}\}_{i=1 N}\), where: \(q_{i}=^{0}}{_{j=1}^{N}p_{j}^{0}}\) with \(p_{i}=}{_{k=1}^{N}n_{k}}\). This increases tokens for low-resource languages and has been shown to reduce bias towards high-resource ones. We consider \(=0.5,0.3\) consistent with [10; 12].

    &  \\
**Configuration** & **Latin** & **Cyrillic** & **Indic** \\  DTP 5\(\) & 0.2 & 0.2 & 0.2 \\ DTP 10\(\) & 0.1 & 0.1 & 0.1 \\ MAGNET \((1,2,4)\) & 1 & 0.5 & 0.25 \\ MAGNET \((3,6,12)\) & 0.33 & 0.17 & 0.083 \\ MAGNET \((5,10,13)\) & 0.2 & 0.10 & 0.076 \\ MAGNET \((5,10,15)\) & 0.2 & 0.10 & 0.066 \\ MAGNET \((5,10,20)\) & 0.2 & 0.10 & 0.05 \\   

Table 1: Binomial prior choice for each MAGNET and DTP model configuration. These combinations of binomial priors determine the compression rate of sequences per language script. While DTP uses fixed priors for all languages, MAGNET is dynamic and script-specific.

Downstream DatasetsTo demonstrate the effectiveness of MAGNET, we evaluate by finetuning our trained models on several question answering and classification tasks. Specifically, we evaluate on XQuAD (question answering) , XNLI (natural language inference) , PAWS-X (paraphrase detection)  from XTREME , and SIB 200 (the topic classification) . We provide a detailed language coverage across all tasks in Table 5. In addition, to test how adaptation capabilities of MAGNET, we evaluate on dialect tasks, specifically ILI  the Indo-Aryan Language Identification (ILI) shared task and HaSCoSVa-2022 , hatespeech detection on Spanish dialects. We provide finetuning details in Appendix D.

### Analyzing segmentation across models

The objective of this analysis is to compare segmentation granularity across different approaches. That is, we measure whether the same amount of information is conveyed through similar token counts across various languages. Following previous work [33; 3], we conduct this analysis with the parallel corpus FLORES-200  focusing on the nine languages in our pretraining data.

For byte-level models, segmentation is done by converting each sentence to raw UTF-8 bytes and computing the average number of bytes per sentence. With the subword tokenizer, each sentence is segmented using the tokenizer we trained in 3.1, and the average number of resulting tokens computed across all sentences. As for gradient-based methods like DTP and our MAGNET, we feed each sentence into the model and retrieve a sequence of boundary predictions from the boundary predictor layers. The count of positive predictions determines the number of tokens per sentence.

## 4 Results

The goal of MAGNET is to learn equitable segmentation during training while maintaining high quality downstream performance. Ideally, we expect that MAGNET results in higher compression for the non-Latin script languages, hence balancing segmentation granularity across all languages. This, in turn, should improve modeling efficiency by reducing computational costs at training and inference time.

### MAGNET results in equitable segmentation across language scripts.

We analyze the segmentation granularity, contrasting our method with byte-level, subword tokenization, and DTP as described in SS3.2. Our results in Figure 2 show that MAGNET models produce similar segmentation rates for all languages. The improvement is particularly noticeable in non-Latin script languages that are most susceptible to over-segmentation with the baselines.

First, we compare byte-level segmentation to MAGNET with the \((1,2,4)\) segmentation configuration. As described in SS3.1, Indic languages have approximately four byte code-points to one character, Cyrillic languages have approximately two, and many Latin languages have a one-to-one mapping. Therefore, we expect that training MAGNET with the \((1,2,4)\) configuration will result in equitable byte-level modeling across all of these languages. Appendix Figure 6(a) shows that MAGNET \((1,2,4)\) results in a \(3\) drop in the average number of tokens for the Indic languages, and close to \(2\) drop for Cyrillic, while the Latin languages are not affected. Next, we compare segmentation between DTP \(5\), MAGNET at \((5,10,13)\), MAGNET at \((5,10,20)\) and subword-tokenizers at vocabulary sizes 50k, 100k and 250k with and without alpha sampling (see SS3.1). We find that MAGNET models result in the most equitable segmentation across all languages. In fact, we measure a drop close to 5\(\) in the average number of tokens for the Indic languages compared to DTP and the subword tokenizers. Notably, we also see that a subword tokenizer with a large vocabulary size is required to achieve a lower segmentation rate on Cyrillic

Figure 2: Average number of tokens after segmenting the FLORES dataset. Subword tokenizers and DTP result in over-segmentation in non-Latin script languages, while MAGNET closes the gap.

languages, whereas for Indic languages, even with a large vocabulary and \(\) sampling, we observe a pronounced disparity. This contrasts with findings from previous work that \(\) sampling alleviates tokenization disparities . Overall, these results suggest that MAGNET learns equitable segmentation across languages with diverse scripts, while fixed segmentation models like DTP and byte-based subword tokenizers are sub-optimal and very likely to result in over-segmentation.

### MAGNET maintains performance on downstream tasks.

Our goal is to enforce equitable segmentation while maintaining model performance across tasks. In Table 2, we present results for the best-performing MAGNET model compared to DTP and byte-level models (we provide comparisons to all MAGNET models in SS5.1). Overall, We find that MAGNET models perform better than DTP but are competitive with the byte-level models while being considerably faster and requiring less compute. MAGNET\((3,6,12)\) performs best on PAWS-X and SIB, while \((1,2,4)\) performs best on XNLI and XQUAD.

We report language-specific results on the XNLI dataset in Figure 3. We see better results with the MAGNET models even in some cases where the models in comparison optimize for a similar segmentation. For instance, on Spanish, MAGNET at \((5,10,15)\) outperforms DTP at \(5\). On Indic languages, MAGNET models are generally competitive with the DTP models. We provide more analysis on the trade-offs between downstream performance and segmentation in SS5.1. Results on dialectal tasks are reported in SS2 We see competitive results across all models on all the tasks, suggesting that there is also no negative impact as a result of adapting the models to their respective dialects.

### MAGNET results in more efficient models.

Comparing inference times across all models, we expect that models which optimize for fixed compression like DTP would be only efficient for Latin languages because of their lower byte-to-word ratio. Hence, we anticipate that our routing strategy with the MAGNET models would result in an efficiency gain for non-Latin script languages. In Figure 4, we plot the inference time per language in XQUAD, relative to the inference time of the byte-level models. We show that MAGNET has a shorter inference time than the byte-level models, comparable to DTP for English and Russian and slightly lower for Hindi and Russian. If we assume the optimal compression rates for English and Russian to be \(5\) and \(10\), respectively, using a DTP model with a fixed compression rate for both languages requires training two separate monolingual models to obtain the ideal compression rate for each. However, training a

Table 2: The average performance (accuracy) on downstream tasks on all languages across different models. We present results for the best-performing MAGNET model: (\((3,6,12)\) for PAWS-X and SIB), (\((1,2,4)\) for XQUAD and XNLI). Bold indicates the best overall performance.Table 6 provides more detailed language-specific results.

Figure 3: Language-specific accuracy on the XNLI task across byte-level, and all DTP and MAGNET models. Results are mostly competitive between byte-level and MAGNET models on Latin languages and Russian.

single MAGNET \((5,10,20)\) model that dynamically achieves 5\(\) compression rate for English and 10\(\) compression rate for Russian results in a lower inference time for both.

## 5 Analysis and Discussion

### Trade-off between downstream performance and equitable segmentation

Previous studies have reported correlations between compression and model performance . We empirically investigate these tradeoffs by comparing downstream performance across different MAGNET configurations defined in Table 1. In the results reported in Table 3, we find that the configurations that perform best are MAGNET\((1,2,4)\) and MAGNET\((3,6,12)\). These configurations are equivalent to fair byte-level and subword modelling across all languages. We also report the average task performance per script at various compression rates in Figure 5. Here we are not looking to compare performance across language scripts, but rather to assess performance across different compression rates within each language script. Our results show that there is little to no drop in performance for Latin and Cyrillic languages as compression increases moderately. However, for Indic languages, we see an average of 5% drop in performance as compression increases.

### What is the granularity of segmentation across different compression rates?

In SS3.1, we highlight that the binomial prior is essential for determining the granularity of the segmentation derived from the boundary predictor. To intrinsically validate that MAGNET indeed learns

Figure 4: Inference time per language in XQUAD, relative to the byte-level model. MAGNETâ€™s inference time is shorter than the byte-level model and comparable to DTP for most of the languages.

Figure 5: Average task performance vs compression trade off across language scripts.

Table 3: Results (accuracy) from ablations across all MAGNET configurations.

[MISSING_PAGE_FAIL:9]

Related Work

Overcoming segmentation disparities in subword tokenizationIn multilingual settings, subword tokenizers have proven to be prone to over-segmentation, due to the data-driven nature of the BPE algorithm . Previous work [13; 12; 44] has attempted to address data imbalance issues in subword tokenizers by over-sampling low-resource languages. Our work shows that this only alleviates the bias on certain scripts and doesn't solve the problem. Other studies [1; 36; 17] have also shown that tokenization in transformers remains biased in favor of high-resource languages. Wang et al.  enforce models to use smaller subword units in high-resource languages to make segmentation fairer. Some works [23; 8] suggest training multilingual tokenizers on language clusters to mitigate segmentation disparities, however, this leads to expanded vocabularies. Despite these attempts, it is evident that the training objectives of subword tokenizers do not effectively align with those of language modeling.

Tokenizer-free language modelsLanguage modelling over bytes [45; 4] and pixels [37; 38; 26] has become desirable, as it removes complicated preprocessing pipelines in modelling. Xue et al.  introduced ByT5, a tokenizer-free variant of T5  that processes text at the byte level. However byte-level encoding over-fragments non-Latin script languages resulting in overly long sequences. Since byte or character sequences usually result in longer sequences, previous work [30; 9; 41; 47; 31; 15] on tokenizer-free LMs has introduced novel model architectures to mitigate the computational overhead of processing raw character or byte text directly. These methods [9; 41; 47; 30] end up segmenting raw sequences into fixed/dynamic-size patches, which is not suitable for modelling over non-Latin scripts.

## 7 Conclusion

In this work, we introduce MAGNET, a gradient-based tokenization method to learn equitable segmentation across languages scripts in byte-level multilingual models. MAGNET dynamically routes byte-level sequences through language-script-specific internal boundary predictors trained to infer word boundaries through stochastic reparameterisation. We show that MAGNET enables us to learn token representations with the same granularity across languages compared to vanilla byte-level models and previous gradient-based tokenization approaches. Our analysis demonstrates that while there are indeed downstream performance trade-offs as a result of MAGNET inducing high compression on non-Latin script languages, we are still able to maintain downstream performance quality. Overall, our results hold promise for future research on equitable segmentation and text processing more generally.