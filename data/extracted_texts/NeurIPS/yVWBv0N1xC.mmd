# LayerNAS: Neural Architecture Search in Polynomial Complexity

Anonymous Author(s)

Affiliation

Address

email

###### Abstract

Neural Architecture Search (NAS) has become a popular method for discovering effective model architectures, especially for target hardware. As such, NAS methods that find optimal architectures under constraints are essential. In our paper, we propose LayerNAS to address the challenge of multi-objective NAS by transforming it into a combinatorial optimization problem, which effectively constrains the search complexity to be polynomial.

LayerNAS rigorously derives its method from the fundamental assumption that modifications to previous layers have no impact on the subsequent layers. When dealing with search spaces containing \(L\) layers that meet this requirement, the method performs layerwise-search for each layer, selecting from a set of search options \(\). LayerNAS groups model candidates based on one objective, such as model size or latency, and searches for the optimal model based on another objective, thereby splitting the cost and reward elements of the search. This approach limits the search complexity to \(O(H|| L)\), where \(H\) is a constant set in LayerNAS.

Our experiments show that LayerNAS is able to consistently discover superior models across a variety of search spaces in comparison to strong baselines, including search spaces derived from NATS-Bench, MobileNetV2 and MobileNetV3.

## 1 Introduction

With the surge of ever-growing neural models used across all ML-based disciplines, the efficiency of neural networks is becoming a fundamental factor in their success and applicability. A carefully crafted architecture can achieve good quality while maintaining efficiency during inference. However, designing optimized architectures is a complex and time-consuming process - this is especially true when multiple objectives are involved, including the model's performance and one or more cost factors reflecting the model's size, Multiply-Adds and inference latency. Neural Architecture Search (NAS), is a highly effective paradigm for dealing with such complexities. NAS automates the task and discovers more intricate and complex architectures than those that can be found by humans. Additionally, recent literature shows that NAS allows to search for optimal models under specific constraints (e.g., latency), with remarkable applications on architectures such as MobileNetV3 , EfficientNet  and FBNet .

Most NAS algorithms encode model architectures using a list of integers, where each integer represents a selected search option for the corresponding layer. In particular, notice that for a given model with \(L\) layers, where each layer is selected from a set of search options \(\), the search space contains \(O(||^{L})\) candidates with different architectures. This exponential complexity presents a significant efficiency challenge for NAS algorithms.

In this paper, we present LayerNAS, an algorithm that addresses the problem of Neural Architecture Search (NAS) through the framework of combinatorial optimization. The proposed approach decouples the constraints of the model and the evaluation of its quality, and explores the factorized search space more effectively in a layerwise manner, reducing the search complexity from exponential to polynomial.

LayerNAS rigorously derives the method from the fundamental assumption: optimal models when searching for \(layer_{i}\) can be constructed from one of the models in \(layer_{i-1}\). For search spaces that satisfy this assumption, LayerNAS enforces a directional search process from the first layer to the last layer. The directional layerwise search makes the search complexity \(O(C|| L)\), where \(C\) is the number of candidates to search per layer.

For multi-objective NAS problems, LayerNAS treats model constraints and model quality as separate metrics. Rather than utilizing a single objective function that combines multi-objectives, LayerNAS stores model candidates by their constraint metric value. Let \(_{i,h}\) be the best model candidate for \(layer_{i}\) with \(=h\). LayerNAS searches for optimal models under different constraints in the next layer by adding the cost of the selected search option for next layer to the current layer, i.e., \(_{i,h}\). This transforms the problem into the following combinatorial optimization problem: _for a model with \(L\) layers, what is the optimal combination of options for all layers needed to achieve the best quality under the cost constraint?_ If we bucketize the potential model candidates by their cost, the search space is limited to \(O(H|| L)\), where \(H\) is number of buckets per layer. In practice, capping the search at 100 buckets achieves reasonable performance. Since this holds \(H\) constant, it makes the search complexity polynomial.

Our contributions can be summarized as follows:

* We propose LayerNAS, an algorithm that transforms the multi-objective NAS problem to a Combinatorial Optimization problem. This is a novel formulation of NAS.
* LayerNAS is directly designed to tackle the search complexity of NAS, and reduce the search complexity from \(O(||^{L})\) to \(O(H|| L)\), where \(H\) is a constant defined in the algorithm.
* We demonstrate the effectiveness of LayerNAS by identifying high-performing model architectures under various Multiply-Adds (MAdds) constraints, by searching through search spaces derived from MobileNetV2  and MobileNetV3 .

## 2 Related Work

The survey by  categorizes methods for Neural Architecture Search into three dimensions: search space, search strategy, and performance estimation strategy. The formulation of NAS as different

Figure 1: Comparison with baseline models and NAS methods.

problems has led to the development of a diverse array of search algorithms. Bayesian Optimization is first adopted for hyper-parameter tuning [3; 9; 13; 20]. Reinforcement Learning is utilized for training an agent to interact with a search space [45; 27; 46; 19]. Evolutionary algorithms [24; 29] have been employed by encoding model architectures to DNA and evolving the candidate pool. ProgressiveNAS  uses heuristic search to gradually build models by starting from simple and shallow model architectures and incrementally adding more operations to arrive at deep and complex final architectures. This is in contrast to LayerNAS, which iterates over changes in the layers of a full complex model.

Recent advancements in mobile image models, such as MobileNetV3 , EfficientNet , FBNet , are optimized by NAS. The search for these models is often constrained by metrics such as FLOPs, model size, latency, and others. To solve this multi-objective problem, most NAS algorithms [33; 5] design an objective function that combines these metrics into a single objective. LEMONADE  proposes a method to split two metrics, and searches for a Pareto front of a family of models. Once-for-All  proposes progressive shrinking algorithm to efficiently find optimal model architectures under different constraints.

Larger models tend to have better performance compared to smaller models. However, the increased size of models also means increased computational resource requirement. As a result, the optimization of neural architectures within constrained resources is an important and meaningful aspect of NAS problems, which can be solved as multi-objective optimization . There is increasing interest in treating NAS as a compression problem [43; 42] from an over-sized model. These works indicate that compressing with different configurations on each layer leads to a model better than uniform compression. Here, NAS can be used to search for optimal configurations [14; 25; 35].

The applicability of NAS is significantly influenced by the efficiency of its search process. One-shot algorithms [23; 5; 1; 2] provide a novel approach by constructing a supernet from the search space to perform more efficient NAS. However, this approach has limit on number of branches in supernet due to the constraints of supernet size. The search cost is not only bounded by the complexity of search space, but also the cost of training under "train-and-eval" paradigm. Training-free NAS [26; 6; 44; 32] breaks this paradigm by estimating the model quality with other metrics that are fast to compute. However, the search quality heavily relies on the effectiveness of the metrics.

## 3 Problem Definition

Most NAS algorithms do not differentiate the various types of NAS problems. Rather, they employ a single encoding of the search space with a general solution for the search process. However, the unique characteristics of NAS problems can be leveraged to design a tailored approach. We categorize NAS problems into three major types:

Figure 2: Illustration of the LayerNAS Algorithm described in Algorithm 1. For each layer: (1) select a model candidate from current layer and generate children candidates; (2) filter out candidates not in the target objective range; (3) update the model in the bucket if thereâ€™s a candidate with better quality; and finally, move to the next layer.

* Topology search: the search space defines a graph with multiple nodes. The objective is to identify an optimal topology for connecting nodes with different operations. This task allows for the exploration of novel architectures.
* Size search or compression search: the search occurs on a predefined model architecture with multiple layers. Each layer can be selected from as a set of search options. Empirically, the best-performing model is normally the one with the most parameters per layer. Therefore, in practice, we aim to search for the optimal model under certain constraints. NATSBench size search  provides a public dataset for this type of task. MobilNetV3 , EfficientNet , FBNet  also establish the search space in this manner. This problem can also be viewed as a compression problem , as reducing the layer size serves as a means of compression by decreasing the model size, FLOPs and latency.
* Scale search: model architectures are uniformly configured by hyper-parameters, such as number of layers or size of fully-connected layers. This task views the model as a holistic entity and uniformly scales it up or down, rather than adjusting individual layers or components.

This taxonomy illustrates the significant variation among NAS problems. Rather than proposing a general solution to address all of them, we propose to tackle with search spaces in a layerwise manner. Specifically, we aim to find a model with \(L\) layers. For each \(layer_{i}\), we select from a set of search options \(_{i}\). A model candidate \(\) can be represented as a tuple with size \(L\): \((s_{1},s_{2},...,s_{L})\). \(s_{i}_{i}\) is a selected search option on \(layer_{i}\). The objective is to find an optimal model architecture \(=(s_{1},s_{2},...,s_{L})\) with the highest accuracy:

\[*{argmax}_{(s_{1},s_{2},...,s_{L})}Accuracy()\] (1)

## 4 Method

We propose LayerNAS as an algorithm that leverages layerwise attributes. When searching models \(_{i}\) on \(layer_{i}\), we are searching for architectures in the form of \((s_{1..i-1},x_{i},o_{i+1..L})\). \(s_{1..i-1}\) are the selected options for \(layer_{1..i-1}\), and \(o_{i+1..L}\) are the default, predefined options. \(x_{i}\) is the search option selected for \(layer_{i}\), which is the current layer in the search. In this formulation, only \(layer_{i}\) can be changed, all preceding layers are fixed, and all succeeding layers are using the default option. In topology search, the default option is usually no-op; in size search, the default option can be the option with most computation.

LayerNAS operates on a search space that meets the following assumption, which has been implicitly utilized by past chain-structured NAS techniques [22; 33; 15].

**Assumption 4.1**.: The optimal model \(_{i}\) on \(layer_{i}\) can be constructed from a model \(m_{i-1}\), where \(_{i-1}\) is a set of model candidates on \(layer_{i-1}\).

This assumption implies:

* Enforcing a sequential search process is possible when exploring \(layer_{i}\) because improvements to the model cannot be achieved by modifying \(layer_{i-1}\).
* The information for finding an optimal model architecture on \(layer_{i}\) was collected when searching for model architectures on \(layer_{i-1}\).
* Search spaces that are constructed in a layerwise manner, such as those in size search problems discussed in Section 3, can usually meet this assumption. Each search option can completely define how to construct a succeeding layer, and does not depend on the search options in previous layers.
* It's worth noting that not all search spaces can meet the assumption. Succeeding layers may be coupled with or affect preceding layers in some cases. In practice, we transform the search space in Section 5 to ensure that it meets the assumption.

### LayerNAS for Topology Search

The LayerNAS algorithm is described by the pseudo code in Algorithm 1. \(_{l}\) is a set of model candidates on \(layer_{l}\). \(_{l,h}\) is the model on \(layer_{l}\) mapped to \(h\), a lower dimensional representation. \(\) is usually a finite integer set, so that we can index and store models.

Some functions can be customized for different NAS problems with a-priori knowledge:

* select: samples a model from a set of model candidates in the previous layer \(_{l}\). It could be a mechanism of evolutionary algorithm  or a trained predictor  to select most promising candidates. The method will also filter out model architectures that we do not need to search, usually a model architecture that is invalid or known not to generate better candidates. This can significantly reduce the number of candidates to search.
* apply_search_option: applies a search option from \(_{l+1}\) on \(_{l}\) to generate \(_{l+1}\). We currently use random selection in the implementation, though, other methods could lead to improved search option.
* \(:\) maps model architecture in \(\) to a lower dimensional representation \(\). \(\) could be an encoded index of model architecture, or other identifiers that group similar model architectures. We discuss this further in 4.2. When there is a unique id for each model, LayerNAS will store all model candidates in \(\).

In this algorithm, the total number of model candidates we need to search is \(_{i=1}^{L}|_{i}||_{i}|\). It has a polynomial form, but \(|_{L}|=O(||^{L})\) if we set \(()\) as unique id of models. This does not limit the order of \(|_{L}|\) to search. For topology search, we can design a sophisticated \(\) to group similar model candidates. In the following discussion, we will demonstrate how to lower the order of \(|_{L}|\) in multi-objective NAS.

### LayerNAS for Multi-objective NAS

LayerNAS is aimed at designing an efficient algorithm for size search or compression search problems. As discussed in Section 3, such problems satisfy Assumption 4.1 by nature. Multi-objective NAS usually searches for an optimal model under some constraints, such as model size, inference latency, hardware-specific FLOPs or energy consumption. We use "cost" as a general term to refer to these constraints. These "cost" metrics are easy to calculate and can be determined when the model architecture is fixed. This is in contrast to calculating accuracy, which requires completing the model training. Because the model is constructed in a layer-wise manner, the cost of the model can be estimated by summing the costs of all layers.

Hence, we can express the multi-objective NAS problem as,

\[*{argmax}_{(s_{1},s_{2},,s_{L})} Accuracy(_{L})\] (2) s.t. \[_{i=1}^{L}Cost(s_{i})\]

where \(Cost(s_{i})\) is the cost of applying option \(s_{i}\) on \(layer_{i}\).

We introduce an additional assumption by considering the cost in Assumption 4.1:

**Assumption 4.2**.: The optimal model \(_{i}\) with \(=C\) when searching for \(layer_{i}\) can be constructed from the optimal model \(_{i-1}\) with \(=C-Cost(s_{i})\) from \(_{i-1}\).

In this assumption, we only keep one optimal model out of a set of models with similar costs. Suppose we have two models with the same cost, but \(_{i}\) has better quality than \(^{}_{i}\). The assumption will be satisfied if any changes on following layers to \(_{i}\) will generate a better model than making the same change to \(^{}_{i}\).

By applying Assumption 4.2 to Equation (2), we can formulate the problem as combinatorial optimization:

\[*{argmax}_{x_{i}} Accuracy(_{i})\] s.t. \[_{j=1}^{i-1}Cost(s_{1..i-1},x_{i},o_{i+1,L})\] (3) \[ _{i}=(s_{1..i-1},x_{i},o_{i+1..L}),_{i-1} =(s_{1..i-1},o_{i..L})_{i-1,h^{}}\]

This formulation decouples cost from reward, so there is no need to manually design an objective function to combine these metrics into a single value, and we can avoid tuning hyper-parameters of such an objective. Formulating the problem as combinatorial optimization allows solving it efficiently using dynamic programming. \(_{l,h}\) can be considered as a memorial table to record best models on \(layer_{l}\) at cost \(h\). For \(layer_{l}\), \(_{l}\) generates the \(_{l+1}\) by applying different options selected from \(_{l+1}\) on \(layer_{l+1}\). The search complexity is \(O(H|| L)\).

We do not need to store all \(_{l,h}\) candidates, but rather group them with the following transformation:

\[(_{i})=_{i})- Cost( _{i})}{ Cost(_{i})- Cost(_{i})} H\] (4)

where \(H\) is the desired number of buckets to keep. Each bucket contains model candidates with costs in a specific range. In practice, we can set \(H=100\), meaning we store optimal model candidates within 1% of the cost range.

Equation (4) limits \(|_{i}|\) to be a constant value since \(H\) is a constant. \( Cost(_{i})\) and \( Cost(_{i})\) can be easily calculated when we know how to select the search option from \(_{i+1}.._{L}\) in order to maximize or minimize the model cost. This can be achieved by defining the order within \(_{i}\). Let \(s_{i}=1\) represent the option with the maximal cost on \(layer_{i}\), and \(s_{i}=||\) represent the option with the minimal cost on \(layer_{i}\). This approach for constructing the search space facilitates an efficient calculation of maximal and minimal costs.

The optimization applied above leads to achieving polynomial search complexity \(O(H|| L)\). \(O(||)=H\) is upper bound of the number of model candidates in each layer, and becomes a constant after applying Equation (4). \(||\) is the number of search options on each layer.

LayerNAS for Multi-objective NAS does not change the implementation of Algorithm 1. Instead, we configure methods to perform dynamic programming with the same framework:

* \(\): groups \(_{i}\) by their costs with Equation (4)
* select: filters out \(_{l}\) if all \(_{l+1}\) constructed from it are out of the range of target cost. This significantly reduces the number of candidates to search.

* In practice, Assumption 4.2 is not always true because accuracy may vary in each training trial. The algorithm may store a lucky model candidate that happens to get a better accuracy due to variation. We store multiple candidates for each \(h\) to reduce the problem from training accuracy variation.

## 5 Experiments

### Search on ImageNet

**Search Space:** we construct several search spaces based on MobileNetV2, MobileNetV2 (width multiplier=1.4), MobileNetV3-Small and MobileNetV3-Large. For each search space, we set similar backbone of the base model. For each layer, we consider kernel sizes from {3, 5, 7}, base filters and expanded filters from a set of integers, and a fixed strides. The objective is to find better models with similar MAdds of the base model.

To avoid coupling between preceding and succeeding layers, we first search the shared base filters in each block to create residual shortcuts, and search for kernel sizes and expanded filters subsequently. This ensures the search space satisfy Assumption 4.1.

We estimate and compare the number of unique model candidates defined by the search space and the maximal number of searches in Table 1. In the experiments, we set \(H=100\), and store 3 best models with same \(h\)-value. Note that the maximal number of searches does not mean actual searches conducted in the experiments, but rather an upper bound defined by the algorithm.

A comprehensive description of the search spaces and discovered model architectures in this experiment can be found in the Appendix for further reference.

**Search, train and evaluation:**

During the search process, we train the model candidates for 5 epochs, and use the top-1 accuracy on ImageNet as a proxy metrics. Following the search process, we select several model architectures with best accuracy on 5 epochs, train and evaluate them on 4x4 TPU with 4096 batch size (128 images per core). We use RMSPropOptimizer with 0.9 momentum, train for 500 epochs. Initial learning rate is 2.64, with 12.5 warmup epochs, then decay with cosine schedule.

**Results**

We list the best models discovered by LayerNAS, and compare them with baseline models and results from recent NAS works in Table 2. For all targeted MAdds, the models discovered by LayerNAS achieve better performance: 69.0% top-1 accuracy on ImageNet for 61M MAdds, a 1.6% improvement over MobileNetV3-Small; 75.6% for 229M MAdds, a 0.4% improvement over MobileNetV3-Large; 77.1% accuracy for 322M MAdds, a 5.1% improvement over MobileNetV2; and finally, 78.6% accuracy for 627M MAdds, a 3.9% improvement over MobileNetV2 1.4x.

Note that for all of these models, we include squeeze-and-excitation blocks  and use Swish activation , in order to to achieve the best performance. Some recent works on NAS algorithms, as well as the original MobileNetV2, do not use these techniques. For a fair comparison, we also list the model performance after removing squeeze-and-excitation and replacing Swish activation with ReLU. The results show that the relative improvement from LayerNAS is present even after removing these components.

   & Target & \# Unique & \# Max \\ Search Space & MAdds & Models & Trials \\  MobileNetV3-Small & 60M & \(5.0e+20\) & \(1.2e+5\) \\ MobileNetV3-Large & 220M & \(4.8e+26\) & \(1.5e+5\) \\ MobileNetV2 & 300M & \(5.3e+30\) & \(1.4e+5\) \\ MobileNetV2 1.4x & 600M & \(1.6e+39\) & \(2.0e+6\) \\  

Table 1: Comparison of model candidates in the search spaces

### NATS-Bench

The following experiments compare LayerNAS with others NAS algorithms on NATS-Bench . We evaluate NAS algorithms from these three perspectives:

* Candidate quality: the quality of the best candidate found by the algorithm, as can be indicated by the peak value in the chart.
* Stability: the ability to find the best candidate, after running multiple searches and analyzing the average value and range of variation.
* Efficiency: The training time required to find the best candidate. The sooner the peak accuracy candidate is reached, the more efficient the algorithm.

#### NATS-Bench topology search

NATS-Bench topology search defines a search space on 6 ops that connect 4 tensors, each op has 5 options (conv1x1, conv3x3, maxpool3x3, no-op, skip). It contains 15625 candidates with their number of parameters, FLOPs, accuracy on Cifar-10, Cifar-100 , ImageNet16-120 .

In Table 3, we compare with recent state-of-the-art methods. Although training-free NAS has advantage of lower search cost, LayerNAS can achieve much better results.

#### NATS-Bench size search

NATS-Bench size search defines a search space on a 5-layer CNN model, each layer has 8 options on different number of channels, from 8 to 64. The search space contains 32768 model candidates. The one with the highest accuracy has 64 channels for all layers, we can refer this candidate as "the largest model". Instead of searching for the best model, we set the goal to search for the optimal model with 50% FLOPs of the largest model.

Under this constraints for size search, we implement popular NAS algorithms for comparison, which are also used in the original benchmark papers [40; 10]: random search, proximal policy optimization (PPO)  and regularized evolution (RE) . We conduct 5 runs for each algorithm, and record the best accuracy at different training costs.

LayerNAS treats this as a compression problem. The base model, which is the largest model, has 64 channels on all layers. By applying search options with fewer channels, the model becomes smaller,

   Model & Top1 Acc. & Params & MAdds \\  MobileNetV3-Small\({}^{}\) & 67.4 & 2.5M & 56M \\ MNasSmall  & 64.9 & 1.9M & 65M \\
**LayerNAS** (Ours)\({}^{}\) & **69.0** & 3.7M & 61M \\  MobileNetV3-Large\({}^{}\) & 75.2 & 5.4M & 219M \\
**LayerNAS** (Ours)\({}^{}\) & **75.6** & 5.1M & 229M \\  MobileNetV2\({}^{}\) & 72.0 & 3.5M & 300M \\ Proxylessas-mobile\({}^{}\) & 74.6 & 4.1M & 320M \\ MNasNet-A1  & 75.2 & 3.9M & 315M \\ FairNAS-C\({}^{}\) & 74.7 & 5.6M & 325M \\ LayerNAS-no-SE(Ours)\({}^{}\) & 75.5 & 3.5M & 319M \\ Efficient-B0  & 77.1 & 5.3M & 390M \\ SGNAS-B  & 76.8 & - & 326M \\ FairNAS-C\({}^{}\) & 76.7 & 5.6M & 325M \\ GreedyNAS-B\({}^{}\) & 76.8 & 5.2M & 324M \\
**LayerNAS** (Ours)\({}^{}\) & **77.1** & 5.2M & 322M \\  MobileNetV2 1.4\(\)\({}^{}\) & 74.7 & 6.9M & 585M \\ ProgressiveNAS\({}^{}\) & 74.2 & 5.1M & 588M \\ Shapley-NAS\({}^{}\) & 76.1 & 5.4M & 582M \\ MAGIC-AT\({}^{}\) & 76.8 & GM & 598M \\ LayerNAS-no-SE (Ours)\({}^{}\) & 77.1 & 7.6M & 598M \\
**LayerNAS** (Ours) \({}^{}\) & **78.6** & 9.7M & 627M \\   \({}^{}\) Without squeeze-and-excitation blocks.

\({}^{}\) With squeeze-and-excitation blocks.

Table 2: Comparison of models on ImageNetfaster and less accurate. The search process is to find the optimal model with expected FLOPs. By filtering out candidates that do not produce architectures falling within the expected FLOPs range, we can significantly reduce the number of candidates that need to be searched.

## 6 Conclusion and Future Work

In this research, we propose LayerNAS that formulates Multi-objective Neural Architecture Search to Combinatorial Optimization. By decoupling multi-objectives into cost and accuracy, and leverages layerwise attributes, we are able to reduce the search complexity from \(O(||^{L})\) to \(O(H|| L)\).

Our experiment results demonstrate the effectiveness of LayerNAS in discovering models that achieve superior performance compared to both baseline models and models discovered by other NAS algorithms under various constraints of MAdds. Specifically, models discovered through LayerNAS achieve top-1 accuracy on ImageNet of 69% for 61M MAdds, 75.6% for 229M MAdds, 77.1% for 322M MAdds, 78.6% for 627M MAdds. Furthermore, our analysis reveals that LayerNAS outperforms other NAS algorithms on NATS-Bench in all aspects including best model quality, stability and efficiency.

While the current implementation of LayerNAS has shown promising results, several current limitations that can be addressed by future work:

* LayerNAS is not designed to solve scale search problems mentioned in Section 3, because many hyper-parameters of model architecture are interdependent in scale search problem, which contradicts the statement in Assumption 4.1.
* One-shot NAS algorithms have been shown to be more efficient. We aim to investigate the potential of applying LayerNAS to One-shot NAS algorithms.

    &  &  &  \\  Training time (sec) &  &  &  \\ Target mFLOPs &  &  &  \\   & Validation & Test & Validation & Test & Validation & Test \\ RS & 0.8399 & 0.9265 & 0.5947 & 0.6935 & 0.3638 & 0.4381 \\ RE  & **0.8440** & 0.9282 & 0.6057 & 0.6962 & 0.3770 & 0.4476 \\ PPO  & 0.8432 & 0.9283 & 0.6033 & 0.6957 & 0.3723 & 0.4438 \\ LayerNAS & **0.8440** & **0.9320** & **0.6067** & **0.7064** & **0.3812** & **0.4537** \\  Optimal validation & 0.8452 & 0.9264 & 0.6060 & 0.6922 & 0.3843 & 0.4500 \\ Optimal test & 0.8356 & 0.9334 & 0.5870 & 0.7086 & 0.3530 & 0.4553 \\   

Table 4: Comparison on NATS-Bench size search. Average on 5 runs.

    & Cifar10 & Cifar100 & ImageNet16-120 & Search cost (sec) \\   RS & 92.39\(\)0.06 & 63.54\(\)0.24 & 42.71\(\)0.34 & 1e+5 \\ RE  & 94.13\(\)0.18 & 71.40\(\)0.50 & 44.76\(\)0.64 & 1e+5 \\ PPO  & 94.02\(\)0.13 & 71.68\(\)0.65 & 44.95\(\)0.52 & 1e+5 \\ KNAS  & 93.05 & 68.91 & 34.11 & 4200 \\ TE-NAS  & 93.90\(\)0.47 & 71.24\(\)0.56 & 42.38\(\)0.46 & 1558 \\ EigenNas  & 93.46\(\)0.02 & 71.42\(\)0.63 & 45.54\(\)0.04 & - \\ NASI  & 93.55\(\)0.10 & 71.20\(\)0.14 & 44.84\(\)1.41 & 120 \\ FairNAS  & 93.23\(\)0.18 & 71.00\(\)1.46 & 42.19\(\)0.31 & 1e+5 \\ SGNAS  & 93.53\(\)0.12 & 70.31\(\)1.09 & 44.98\(\)2.10 & 9e+4 \\ LayerNAS & **94.34\(\)0.12** & **73.01\(\)0.63** & **46.58\(\)0.59** & 1e+5 \\  Optimal test accuracy & 94.37 & 73.51 & 47.31 & \\   

Table 3: Comparison on NATS-Bench topology search. Mean and deviation of test accuracy on 5 runs.