# Replicable Reinforcement Learning

Eric Eaton

University of Pennsylvania

Philadelphia, PA 19104

eeaton@seas.upenn.edu

&Marcel Hussing

University of Pennsylvania

Philadelphia, PA 19104

mhussing@seas.upenn.edu

&Michael Kearns

University of Pennsylvania

Philadelphia, PA 19104

mkearns@cis.upenn.edu

&Jessica Sorrell

University of Pennsylvania

Philadelphia, PA 19104

jsorrell@seas.upenn.edu

###### Abstract

The _replicability crisis_ in the social, behavioral, and data sciences has led to the formulation of algorithm frameworks for replicability -- i.e., a requirement that an algorithm produce identical outputs (with high probability) when run on two different samples from the same underlying distribution. While still in its infancy, provably replicable algorithms have been developed for many fundamental tasks in machine learning and statistics, including statistical query learning, the heavy hitters problem, and distribution testing. In this work we initiate the study of _replicable reinforcement learning_, providing a provably replicable algorithm for parallel value iteration, and a provably replicable version of R-max in the episodic setting. These are the first formal replicability results for control problems, which present different challenges for replication than batch learning settings.

## 1 Introduction

The growing prominence of machine learning (ML) and its widespread adoption across industries underscore the need for replicable research (Wagstaff, 2012; Pineau et al., 2021). Many scientific fields have suffered from this same inability to reproduce the results of published studies (Begley and Ellis, 2012). Replicability in ML requires not only the ability to reproduce published results (Wagstaff, 2012), as may be partially addressed by sharing code and data (Stodden et al., 2014), but also consistency in the results obtained from successive deployments of an ML algorithm in the same environment. However, the inherent variability and randomness present in ML pose challenges to achieving replicability, as these factors may cause significant variations in results.

Building upon foundations of algorithmic stability (Bousquet and Elisseeff, 2002), recent work in learning theory has established rigorous definitions for the study of supervised learning (Impagliazzo et al., 2022) and bandit algorithms (Esfandiari et al., 2023) that are provably _replicable_, meaning that algorithms produce identical outputs (with high probability) when executed on distinct data samples from the same underlying distribution. However, these results have not been extended to the study of control problems such as reinforcement learning (RL), that have long been known to suffer from stability issues (White and Eldeib, 1994; Mannor et al., 2004; Islam et al., 2017; Henderson et al., 2018). These stability issues have already sparked research into robustness for control problems including RL (Khalil et al., 1996; Nilim and Ghaoui, 2005; Iyengar, 2005). Non-deterministic environments and evaluation benchmarks, the randomness of the exploration process, and the sequential interaction of an RL agent with the environment all complicate the ability to make RL replicable. Our work is orthogonal to that of the robustness literature and our goal is not to reducethe effect of these inherent characteristics, such as by decreasing the amount of exploration that an agent performs, but to develop replicable RL algorithms that support these characteristics.

Toward this goal, we initiate the study of replicable RL and develop the first set of RL algorithms that are provably replicable. We contend that the fundamental theoretical study of replicability in RL might advance our understanding of the aspects of RL algorithms that make replicability hard. In this work, we put on a similar lens as Impagliazzo et al. (2022) and consider replicability as an algorithmic property that can be achieved simultaneously with exploration and exploitation. First, we show that it is possible to obtain a near-optimal, replicable policy given sufficiently many samples from every state in the environment. This notion is then naturally extended to replicable exploration.

Our contributions can be summarized as follows. We provide two novel and efficient algorithms to

* show that stochastic, sample-based value iteration can be done replicably and
* replicably explore the space of an MDP while also finding an optimal policy.

We experimentally validate that our algorithms require much fewer samples than theory suggests.

## 2 Preliminaries

### Reinforcement learning

We consider the problem of solving a discounted Markov decision process (MDP) \(=\{,,R,P,,\}\) with state space \(\), action space \(\), reward function \(R\), transition kernel \(P\), discount factor \(\), and initial state distribution \(\). We assume that the size of the state space \(||\) and number of possible actions \(||\) are finite and not too large. Further, we assume that the rewards for every state-action pair are deterministic, bounded, and known. Relaxing assumptions on the reward function might not necessarily seem straightforward in our goal of replicable RL, as the stochastic reward would need to be made replicable. However, the case can be handled by our algorithms with minor modifications and only constant factor overhead. The goal is to find a policy \(:\) that maximizes the cumulative discounted reward \(J_{h}=_{k=h}^{}^{k-h}R_{k}(s,a)\). We use the typical definitions of the value and Q-value functions for the expected cumulative discounted return from a state or state-action pair, respectively:

\[V_{}(s) =}_{,P}[J_{h}|s_{h}=s] Q_{}(s,a) =}_{,P}[J_{h}|s_{h}=s,a_{h}=a].\]

To show the various difficulties that come from trying to achieve replicability in RL, we consider two different settings to examine various components of the problem.

Parallel sampling settingFirst, we ask whether it is even possible to obtain a replicable policy from empirical samples without considering the challenges of exploration. For this, we can adopt the setting of generative models \(G_{}\), or more precisely, the parallel sampling setting. In the parallel sampling model, first introduced by Kearns and Singh (1998a), one has access to a parallel generative sampling subroutine \((G_{})\). A single call to \((G_{})\) will return, for every state-action pair \((s,a)\), a randomly sampled next state \(s^{}\) drawn from \(P(s^{}|s,a)\). The key advantage is that this model separates learning from the quality of the exploration procedure.

**Definition 2.1** (Generative model).: _Let \(\) denote an arbitrary MDP. Then a generative model \(G_{}((s,a))\) is a randomized algorithm that, given a state-action pair \((s,a)\), outputs a deterministic reward \(R(s,a)\) and a next state \(s^{}\) sampled from \(P(|s,a)\)._

**Definition 2.2** (Parallel sampling).: _Let \(\) denote an arbitrary MDP. Then a call to the parallel sampling subroutine \((G_{})\) returns exactly one sample \(s^{}_{i} G_{}((s_{i},a_{i}))\) for every state-action pair \((s_{i},a_{i})\) in \(\) of \(\) using a generative model._

Episodic settingThe second setting we consider is one in which an algorithm does have to explore the MDP before it can obtain an optimal policy. More precisely, we consider an episodic setting where, in every episode \(e\{1,2,...,E\}\), the agent starts in a position \(s_{0}\) and interacts with the environment for a fixed amount of time \(H\). At any step \(h[1,H]\), the agent is in some state \(s_{h}\), selects an action \(a_{h}\), receives a reward \(r_{h}\) and transitions to a new state \(s_{h+1}\). Gathering a trajectory \(=(s_{0},a_{0},r_{0},..,s_{H},a_{H},r_{H})\) of states, actions and rewards under policy \(\) can be thought of as a draw from a distribution \( P_{}^{}()\). We will omit the sub-and superscripts when clear from context. For consistency with the remaining analysis, we work with a \(\)-discounted version of the problem.

### Replicability

We build on the recent framework by Impagliazzo et al. (2022), which considers replicability as a property of randomized algorithms that take as input a dataset sampled i.i.d. from an arbitrary distribution. They consider an algorithm to be replicable if, on two runs in which its internal randomness is fixed and its input data is resampled, it outputs the same result with high probability:

**Definition 2.3** (Replicability).: _Fix a domain \(\) and target replicability parameter \((0,1)\). A randomized algorithm \(:^{n}\) is \(\)-replicable if for all distributions \(D\) over \(\), randomizing over the internal randomness \(r\) of \(\) and choice of samples \(S_{1},S_{2}\), each of size \(n\) drawn i.i.d. from \(D\), we have: \(_{S_{1},S_{2},r}[(S_{1};r)(S_{2};r)].\)_

Several key tools that were introduced by Impagliazzo et al. (2022) will prove useful or yield inspiration for the algorithms developed in this work. One of the key observations is that many of the computations in RL can be phrased as statistical queries, defined as follows:

**Definition 2.4** (Statistical query, (Kearns, 1998)).: _Fix a distribution \(D\) over \(\) and an accuracy parameter \((0,1)\). A statistical query is a function \(:\), and a mechanism \(M\) answers \(\) with tolerance \(\) on distribution \(D\) if \(a M\) satisfies \(a[_{x D}[(x)]]\)._

We will make direct use of the replicable algorithm for answering statistical queries by Impagliazzo et al. (2022) which will be useful to obtain replicable estimates of various measurements such as transition probabilities. We will refer to the replicable statistical query procedure as \(\). We note that Impagliazzo et al. (2022) also proves a lower-bound on the sample complexity required for replicable statistical queries, showing that the results below are essentially tight.

**Theorem 2.1** (Replicable statistical queries, Impagliazzo et al. (2022)).: _There is a \(\)-replicable algorithm \(\) such that for any distribution \(D\) over \(\), replicability parameter \((0,1)\), accuracy parameter \((0,1)\), failure parameter \( O()\), and query \(:\), letting \(S\) be a sample of \(n O(^{2}})\) elements drawn i.i.d. from \(D\), we have that \(a_{,}(S,)\) satisfies \(a[_{x D}[(x)]]\) except with probability at most \(\) over the samples \(S\)._

At a very high level, \(\) uses its sample to empirically estimate the expected value of the statistical query on the target distribution. It then uses its internal randomness to pick an evenly-spaced set of canonical representatives from the \(\) interval, and returns whichever canonical representative is closest to the empirical estimate. We note that the algorithm of Impagliazzo et al. (2022) for replicably answering statistical queries is not only sample efficient, but also computationally efficient, as it has runtime polynomial in \(1/,1/,\) and \((1/)\).

## 3 Replicable reinforcement learning

To define replicability for the RL setting, we can adapt Definition 2.3 more or less exactly. The question that arises is which of the many RL objects should be made replicable? We separate the difficulty of replicability into three levels: replicability of the MDP, the value function, and the policy. Since these objects carry different amounts of information (Farahmand, 2011), the following relationships can be established.

If we are able to replicably (and accurately) estimate an MDP, we can always replicably compute an (optimal) value function using standard techniques on our estimates, and from replicable value functions we can obtain the corresponding policies. Note that the inverse is not true as we lose information when going from MDP to value function and then policy. As a result, we expect that replicable estimation of MDPs is the hardest setting in stochastic RL, followed by replicable value function, and then policy estimation.

For replicability of control problems, a sensible measure to ask for is the production of identical policies, which are the ultimate object of primary interest. We would at least like to ensure that with high probability, we can obtain identical optimal policies across two runs of our RL procedures:

**Definition 3.1** (Replicable policy estimation).: _Let \(\) be a policy estimation algorithm that outputs a policy \(^{*}:\) given a set of trajectories \(S\) sampled from an MDP. Algorithm \(\) is \(\)-replicable if, given independently sampled trajectory sets \(S_{1}\) and \(S_{2}\), and yielding policies \(^{*}_{1}\) and \(^{*}_{2}\), it holdsfor all states \(s\) and actions \(a\) that_

\[_{S_{1},S_{2},x_{1}}[^{*(1)}(a|s) ^{*(2)}(a|s)]\] \[^{*(1)}(a|s)(S_{1};r) ^{*(2)}(a|s)(S_{2};r),\]

_where \(r\) represents the internal randomness of \(\). Trajectory sets \(S_{1}\) and \(S_{2}\) may potentially be gathered from the environment during the execution of an RL algorithm._

While this definition is the weakest we would like to achieve, the results we present in this paper provide stronger guarantees. Our Replicable Phased Value Iteration builds on  and ensures replicability of value functions, while our Replicable Episodic R-max follows  and provides replicability of full MDPs. Equivalent formal definitions for replicable value and MDP estimation are given in Appendix A.

Current algorithms for sample-based RL problems will struggle to satisfy Definition 3.1 of replicability and output different policies even in simple environments (see Figure 1). In some cases, this may not be problematic since the resulting policies will still be \(\)-optimal, but in practice it is often hard to tell when that is the case. Fixing replicability will support the identification of problematic solutions and encourage procedures that yield more stable solutions in the long run. Varying policies can, for example, arise from sample uncertainty, insufficient state-space coverage, or differing exploration. In order to achieve replicability, all of the aforementioned challenges need to be addressed, which makes for an intricate but interesting problem. With this in mind, the next section will introduce a first set of formally replicable algorithms that separate out some of these challenges.

## 4 Algorithms

### Replicable phased value iteration

The first question we answer positively is whether it is even possible to achieve replicability when the samples are drawn i.i.d. from the same distribution. For this, we use the parallel sampling model described in section 2. This model is well-suited for the task as it allows us to analyze sample-based value iteration independent of the exploration policy that collects the samples.

We provide a replicable version of indirect Phased Q-learning , which was later also referred to as Phased Value Iteration . In brief, the algorithm iterates \(T\) times and at every iteration makes \(m\) calls to \((G_{})\), computes an approximate value estimate for every state and does one round of value updates.  provide the following Lemma 4.1 to show the optimality of the original procedure.

**Lemma 4.1** (Phased Q-learning convergence, ).: _Suppose the number of calls to \((G_{})\) is chosen such that the value function estimates produced in every round by Phased Q-learning are sufficiently accurate. For any MDP \(\), Phased Q-learning converges to a policy \(^{*}\) whose return is within \(\) of the optimal policy \(^{*}\)._

Our algorithm operates similarly, but we would like to achieve replicability on top of optimality. We use a randomized rounding procedure for statistical query estimation (\(\)) provided by Impagliazzo et al. (2022) to compute the value estimates at every iteration. For this, we assume that the value function is normalized to the interval \(\). A detailed description of our algorithm is

Figure 1: The GridWorld for our experiments (left) and two different policies that were generated by the Phased Q-learning Algorithm on this gridworld (center and right). Following the first policy (center) more likely reaches the left goal while following the right policy more likely reaches the right goal. All states except the goals have 0 reward. The actions are up, down, left and right; there is a 30% chance that after choosing an action the agent moves left or right of the target direction.

provided in Algorithm 1. The Replicable Phased Value Iteration (rPVI) algorithm we provide satisfies Definition 3.1 and produces \(\)-optimal policies. It goes even one step further and produces not only replicable policies but replicable value functions. This is formalized in the following Theorem 4.1.

**Theorem 4.1**.: _Let \((0,1)\) be the accuracy and \((0,1)\) be the replicability parameter. Let \((0,1)\) be the sample failure probability. Set the number of calls to \((G_{})\) at every iteration to_

\[m=O((1/)||^{2}||^{2}}{ ^{2}(-2)^{2}}{}|||}{}+(1/))\]

_where \(O\) supresses the dependence on \(\). In two runs \((1)\) and \((2)\) with shared internal randomness, Algorithm 1 produces identical policies, s.t. \([^{*(1)}^{*(2)}] O()\). In every run, the produced policies \(^{*}\) achieve return at most \(\) less than the optimal policy \(^{*}\) with all but probability \(O()\)._

Proof Sketch.: We give a sketch for the proof of the theorem here and refer the reader to a full proof in Appendix B.2. Assume that we can get replicable and accurate estimates of the value function expectations from our rSTAT procedure. One can show by induction that the algorithm consistently produces the same value functions in every iteration. Lemma 4.2 guarantees the convergence to an optimal policy. Finally, we can use union and Chernoff bounds to pick a sufficiently large sample for our rSTAT queries to be replicable and accurate and satisfy our assumption.

An interesting observation is that rPVI discretizes the space of values as a function of the \(\)-parameter and \(\) (see Appendix B.2). As a result, replicability becomes harder for larger values of \(\) as discretization intervals become smaller and we require more samples to obtain an equally sized \(\). This is intuitive as we need to account for more potential future states that might impact our estimates.

The number of samples to compute a replicable value function is at most \(O(^{2}(1/)||^{2}||^{2}/^{2})\) times larger than computing a non-replicable one (Kearns and Singh, 1998a). Still, a key observation of the original Phased Q-learning result was that it is sufficient for every state-action pair to have a sample size logarithmic in \(||||\), making the procedure cheaper than estimating the full transition dynamics of an MDP. The cost of replicability is the loss of this property. However, we note that rPVI does not yield replicable transition probability estimation. Using the idea of rSTAT queries to obtain transition estimates turns out to be significantly more expensive than the replicable value estimation done by Algorithm 1 (see Appendix B.2.1). Our results retain the notion that direct value estimation is much cheaper than estimating the full transition kernel even in the presence of replicability.

### Replicable RL with exploration

Next, we consider the setting of episodic exploration. We show that, despite the stochastic nature of exploration, it is possible to guarantee replicability while still outputting an \(\)-optimal policy.

We take the R-max algorithm of Brafman and Tennenholtz (2003) as the starting point for our replicable algorithm RepRMAX (Algorithm 2). It proceeds in rounds where the agent interacts with the environment for multiple episodes. The collection of trajectories encountered during exploration is used to incrementally build a model \(}\) of the underlying MDP \(\). The algorithm implicitly partitions the set of state-action pairs \(\) into two groups: known and unknown. All \((s,a)\) are initialized to be unknown. While a state is unknown, the model \(}\) maintains that \((s,a)\) is a self-loop with probability \(1\), and that \((s,a)\) has maximum reward, thereby promoting exploration of unknown states. After a state-action pair \((s,a)\) has been visited sufficiently many times, it is added to the collection of known states \(K\) and its transition probabilities \(\) and reward \(\) are updated with an empirical approximation of \(_{K}(s^{} s,a)\) for all \(s^{}\) and the observed reward \(R\), respectively. After every update, the policy \(_{}_{K}}\) is computed as the optimal policy of the current model estimate.

While convergence of Algorithm 2 to an \(\)-optimal policy follows from familiar arguments (Brafman and Tennenholtz, 2003), proving replicability will require a great deal of additional care. To ensure that two runs of \(\) (with shared internal randomness) converge to the same policy with high probability, we will show something even stronger: we prove that two such runs will with high probability perform the same sequence of updates to their respective models \(}_{K}\) and policies \(_{}_{K}}\).

To enforce this property, we introduce a sub-routine in Algorithm 3 which replicably identifies state-action pairs that should be added to the collection of known states. Guaranteeing that at each iteration the set of known states \(K\) will be the same for two independent runs of the algorithm helps ensure that the models of the MDP \(}_{K}\), and consequently the policies \(_{}_{K}}\) learned at each iteration, will also be identical. To provide replicability, we will want to avoid using a fixed threshold for the number of times a state-action pair \((s,a)\) must be visited before it is considered "known". Under small deviations in realized transitions, a fixed threshold might lead to some \((s,a)\) becoming known in one run of the algorithm and not another. Instead, we use a randomized threshold.

In a call to Algorithm 3, the sample drawn at that round is used to estimate the expected number of visits to \((s,a)\) in a single trajectory, for every \((s,a)\). This estimate is added to the count \(n(s,a)\), which maintains the sum, over all iterations thus far, of the estimated expected visits to \((s,a)\) from a single trajectory of the policy \(_{}_{K}}\) at that iteration. A new threshold \(k^{}\) is then sampled uniformly from \([k,k+w]\). If \(n(s,a) k^{}\), it is added to the set of known states \(K\). From standard concentration arguments, we know that for two runs of Algorithm 2 with independent samples, the estimates of the total number of expected visits \(n(s,a)\) will both be close to the true total number of expected visits, and therefore close to each other. Algorithm 3 will only make different decisions about adding an \((s,a)\) pair to the set of known states if the threshold \(k^{}\) is chosen to fall between the two estimated values \(n(s,a)\) from the two runs. Here, the concentration of \(n(s,a)\) and the fact that \(k^{}\) is randomized allows us to bound the probability that the threshold \(k^{}\) is chosen to fall between the different \(n(s,a)\)values. We show in Theorem 4.2 that so long as the sample size \(m\) that is used to estimate expected visits, and the window \(w\) from which the randomized threshold in sampled, are taken to be large enough, the update to the set of known states at each round will be replicable.

``` \(K_{i}=\{(s,a):(s,a)(s,a) K\}\) \(k^{}[k,k+w]\) for\((s,a) K_{i}\)do \(_{s,a}=|}_{ S_{i}}_{h=1}^{H}[(s_{h},a_{h})=(s,a)]\) \(n(s,a)=n(s,a)+_{s,a}\) if\(n(s,a)<k^{}\)then  Remove \((s,a)\) from \(K_{i}\) endif endfor return\(K_{i}\) ```

**Algorithm 3**\(\)

Now that we have understood the intricacies on an intuitive level, we will prove convergence (Lemma 4.2) and replicability (Theorem 4.2) of Algorithm 2.

**Lemma 4.2** (Convergence).: _Consider \(\) to be Algorithm 4. Let \((0,1)\) be the accuracy parameter, \((0,1)\) the replicability parameter, and \((0,1)\), be the sample failure probability, with \(</4\). Let \(T(]||}{}+(1/ )}{^{2}})\) be a bound on the number of iterations of Algorithm 2. Suppose \(1->}{H||}\) and let \(m O(|^{2}||^{2}T^{4}(1/)}{ ^{2}})\) be the number of trajectories per iteration. Let \(k=H\) be the lowest expected visit count of a state-action pair before it is known. Let \(w O(k)\) define the window \([k,k+w]\) for sampling the randomized threshold \(k^{}\). Then with all but probability \(\), after \(T\) iterations, \(\) yields an \(\)-optimal policy._

The proof of convergence is similar to those found in  and , so we defer the proof to Appendix B.3. We continue here with the final theorem statement that summarizes the properties of our \(\) algorithm.

**Theorem 4.2**.: _Let parameters be set as in Lemma 4.2. Then with all but probability \(\), \(\) converges to an \(\)-optimal policy in \(T\) iterations and samples \(mT\) trajectories, each of length \(H\), for a total sample complexity of \(O(|^{2}||^{T}H^{6}(1/)}{^{2} ^{5}})\) and \(|^{2}||^{2}H^{10}^{5}(1/)(1/)} {^{10}}).\) Further, let \(S_{1}\) and \(S_{2}\) be two trajectory sets, independently sampled over two runs of \(\) with shared internal randomness, and let \(_{_{K}}^{(1)}(a|s)(S_{1};r)\) and \(_{_{K}}^{(2)}(a|s)(S_{2};r)\). Then_

\[_{S_{1},S_{2},r}_{_{K}}^{(1)}(a|s)_{ _{K}}^{(2)}(a|s) O().\]

Proof.: Lemma 4.2 gives us that, for our settings of \(k\) and \(T\), Algorithm 2 converges to an \(\)-optimal policy in \(T\) iterations, except with probability \(\). The sample complexity follows immediately from the bound on \(T\) and the setting of \(m\), so it remains to analyze replicability. Our analysis will make use of some additional shorthand. We use \(_{K} O(/(|||))\) to denote the replicability parameter for the decision to add a single \((s,a)\) to \(K\), in a single call to Algorithm 3. We similarly use \(_{SQ} O(/(||^{2}||))\), \(_{SQ} O((1-)^{2}/||)\), and \(_{SQ} O(/(||^{2}||))\) to denote the replicability, accuracy, and failure parameters for the \(\) queries made during the updates to \(P(s^{}|s,a)\). We use \(t O(}{T}) O(||T^{2}})\) to denote a high probability bound on the difference between the empirical estimates for the expected visits to a given \((s,a)\) in a trajectory across two runs of Algorithm 3, i.e. \(|_{s,a}^{(1)}-_{s,a}^{(2)}| O(t)\). We are now ready to prove the following stronger claim:

**Claim 4.1**.: _If two runs of Algorithm 2 begin iteration \(i\) with \(}_{K}^{(1)}=}_{K}^{(2)}\), \(_{_{K}}^{(1)}=_{_{K}}^{(2)}\), and \(|n(s,a)^{(1)}\) - \(n(s,a)^{(2)}| O(it)\;(s,a)\), then at the end of \(i\), \(}_{K}^{(1)}=}_{K}^{(2)}\), \(_{_{K}}^{(1)}=_{_{K}}^{(2)}\), and \(|n(s,a)^{(1)}\) - \(n(s,a)^{(2)}| O(it+t)\;(s,a)\), with all but probability \(O(_{K}||||+_{SQ}|K_{1}|||)\)._We take the initialization of Algorithm 2 as the base case for our inductive proof. Before the first iteration, \(_{}_{K}}\) is initialized randomly and shared internal randomness yields \(^{(1)}_{}_{K}}=^{(2)}_{}_{K}}\). We additionally initially initialize \(}_{K}\) and all \(n(s,a)\), and so \(}^{(1)}_{K}=}^{(2)}_{K}\) and \(n(s,a)^{(1)}=n(s,a)^{(2)}\).

Next, we prove the inductive step. We begin by showing that, at the end of the \(i\)th iteration, \(|n(s,a)^{(1)}-n(s,a)^{(2)}| O(it+t)\)\((s,a)\), with all but probability \(O(_{K}||||)\).

Our inductive hypothesis gives us that \(|n(s,a)^{(1)}-n(s,a)^{(2)}| O(it)\), so it suffices to show that, for a single \((s,a)\), \(^{(1)}_{s,a}-^{(2)}_{s,a} O(t)\) except with probability \(O(_{K})\). To obtain high probability bounds on \(|^{(1)}_{s,a}-^{(2)}_{s,a}|\), we will rely on our assumption that at the start of the iteration, \(^{(1)}_{}_{K}}=^{(2)}_{}_{K}}\). It follows that, for every state-action pair \((s,a)\), the expected number of visits to \((s,a)\) in a single episode is the same for both iterations. That is, for every \((s,a)\), defining \(c_{s,a}:=_{ P()}[_{h=1}^{H}[(s_{h}, a_{h})=(s,a)]],\) we have \(c^{(1)}_{s,a}=c^{(2)}_{s,a}\).

For a particular \((s,a)\), Chernoff bounds applied to the average observed counts \(^{(1)}_{s,a}\) and \(^{(2)}_{s,a}\) show that they must both be close to their (shared) expectation with high probability. We draw a sample of

\[m O(|^{2}||^{2}T^{4}(1/)}{^{2 }}) O((1/)}{t^{2}})( (1/_{K})}{t^{2}})\]

trajectories, and each \(c_{s,a}[0,H]\), so except with probability \(4(m^{2}}{H^{2}m}) O(_{K})\),

\[|^{(1)}_{s,a}-^{(2)}_{s,a}||_{  S^{(1)}_{1}}_{h=1}^{H}[_{h}=(s,a)]-c^{(1)}_{s,a} |+|_{ S^{(2)}_{1}}_{h=1}^{H}[ _{h}=(s,a)]-c^{(1)}_{s,a}| O(t),\]

where \(_{h}:=(s_{h},a_{h})\). Union bounding over all \(s\) and \(a\) shows that the stated bound holds for all \((s,a)\) except with probability \(_{K}||||\).

We now show that \(}^{(1)}_{K}=}^{(2)}_{K}\) at the end of the iteration, except with probability \(O(_{K}||||+_{SQ}|K_{i}|||)\). Observe that \(}^{(1)}_{K}=}^{(2)}_{K}\) at the end of the iteration unless at least one of the following two events occurs: 1) \(K^{(1)}_{1} K^{(2)}_{1}\) - the set of new known \((s,a)\) pairs differs across the two runs. 2) The updates to \(_{K}(s^{}|s,a)\) and \(R(s,a)\) differ for at least one \((s,a)\). The first event occurs exactly when \(k^{}\) falls in between \(n(s,a)^{(1)}+^{(1)}_{s,a}\) and \(n(s,a)^{(2)}+^{(2)}_{s,a}\). We have already shown that

\[|n(s,a)^{(1)}+^{(1)}_{s,a}-n(s,a)^{(2)}-^{(2)}_{s,a}| O (it+t) O(tT),\]

for a single \((s,a)\), except with probability \(O(_{K})\). We have sampled \(k^{}\) uniformly at random from an interval of width \(w\), so it follows that \(_{k^{},S_{1},S_{2}}[(s,a) K^{(1)}_{i} K^{(2)}_{i }] O(_{K}+tT/w).\) We took \(t}{T}\), so by union bound over \(\), the probability of the first event is at most \(O(||||_{K})\).

To bound the probability of the second event conditioned on the first event not occurring, it suffices to bound the probability that the updates to \(_{K}(s^{}|s,a)\) for \((s,a) K_{i}\) differ across both runs, By the conditioning, we have \(K^{(1)}_{1}=K^{(2)}_{1}\), so it suffices to show that each call to rSTAT returns the same value for both runs. Taking \(_{SQ}\), \(_{SQ}\), and \(_{SQ}\) as the replicability, tolerance, and failure parameters respectively gives that a sample of size \(s O(||^{2}(1/_{SQ})/(((_{SQ}-2_{SQ }))^{2}(1-)^{4})\) is sufficient, by Theorem 2.1. Furthermore, we have assumed that \(1->^{1/4}(1/)}{H||^{1/4} (1/)}\), \(_{SQ}<_{SQ}/4\), and \(_{SQ} O(/||^{2}||)\), so a sample of size \(s O(|^{6}||^{6}H(1/)}{^{ }^{2}})\) will also suffice. Each \((s,a)\) is added to \(K_{i}\) only if it was visited at least \(km\) times. We have taken \(k=H\), \(m O(|^{2}||^{2}T^{4}(1/)}{})\), and \(T(|||^{6}H}{})\). It follows that \(mk O(|^{6}||^{6}H^{5}(1/)}{ ^{}^{2}})\) and therefore \(S[(s,a)]\) comprises at least \(s\) i.i.d. samples from \(P( s,a)\), as desired. Union bounding over the \(|K_{i}|||\) queries in the \(i\)th iteration gives a bound of \(|K_{i}|||_{SQ}\) on the probability of the second event, conditioned on the first event not happening.

We now assemble our inductive argument into a proof of the theorem. At the start of iteration \(i\), the inductive hypothesis holds except with probability \(_{j=1}^{i-1}_{K}||||+_{SQ}|K_{j}|||\)Noting that \(_{j=1}^{T}|K_{j}|||||\), and recalling that we have taken replicability parameters \(_{K} O(/(||||))\) and \(_{SQ} O(/(||^{2}||))\), ensures we achieve a replicability parameter \(\) after the \(T\) iterations of Algorithm 2. 

### Limitations

As mentioned previously, our bounds lose some of the properties that standard RL results provide, such as the ability to estimate value functions with only a logarithmic dependence on relevant parameters. We expect that some of the sample complexity overhead from achieving replicability is inevitable, as seen in the statistical query lower-bound of Impagliazzo et al. (2022). Nonetheless, we hope that future work can improve on the sample-complexities of our algorithms.

Our work is in part motivated by the recent replicability concerns in deep RL (Islam et al., 2017; Henderson et al., 2018). However, establishing formal guarantees in these highly complicated settings is often not easy. As such, our algorithms suffer the weakness that many theoretical results in RL have to deal with, namely their lack of immediate applicability to real-world problems. Yet, our empirical evaluation in section 5 will show that there is hope for practical application.

## 5 Experiments

While our asymptotic bounds have sample complexity overhead from the introduction of replicability, we would like to analyze the actual requirements in practice. We introduce a simple MDP in Figure 1 that contains several ways of reaching the two goals. We analyze the impact of the number of calls to \((G_{})\) on replicability for rPVl. In theory, our dependence on the number of calls is not logarithmic with respect to \(||||\) but we would like to see if can draw a sample that is much smaller, maybe even on the order of the logarithmic requirement. We choose accuracy \(=0.02\), failure rate \(=0.001\) and replicability \(=0.2\). The number of calls that would be required by standard Phased Q-learning is at most \(m 13000\) (ignoring \(\) factors). We take several multiples of \(m\) and measure the fraction of identical and unique value functions, treating the rSTAT\(_{SQ}\) as a hyperparameter.

The results are presented Figure 2, revealing that the number of samples needed to replicably produce the same value function can be several orders of magnitude lower than suggested by our bounds and that it is feasible to use a larger \(_{SQ}\) than theoretically required. This should allow us to scale to more complex problems in the future. The algorithm quickly produces a small set of value functions that may not be identical but, with a little more data, minor differences are removed. Note that using a replicable procedure naturally incurs overhead, which is expected. However, the overhead is significantly better than the theoretically required sample-size with squared \(||||\) dependence. In the rSTAT procedure, taking smaller values for \(_{SQ}\) for a fixed sample should improve replicability at the cost of accuracy of query responses, by increasing the width of each subinterval of the partition so that there are fewer partition elements overall. The experiments highlight that, as long as sample sizes are sufficiently large and \(_{SQ}\) is chosen small enough, we achieve high replicability.

## 6 Related work

Our work builds upon the foundational ideas by Impagliazzo et al. (2022), who introduce formal notions of replicability that are strongly related to robustness, privacy, and generalization (Bun et al., 2023; Kalavasis et al., 2023). Building on these formal definitions of replicability, researchers have provided algorithms for replicable bandits (Esfandiari et al., 2023) and replicable clustering (Esfandiari et al., 2023). Ahn et al. (2022) introduce algorithms for convex optimization using a slightly different notion of replicability. Our paper presents the first results for formally replicable algorithms in a control setting.

A concurrent and independent work by Karbasi et al. (2023) also studies formal replicability of reinforcement learning. They also study the setting of discounted tabular MDPs, with access to a generative model, and show the same sample complexity upper-bounds for achieving replicable policy estimation in this setting that we prove in our work. Additionally, they provide a matching lower bound. They go on to consider two relaxed notions of replicability that allow them to provide improved sample complexity upper-bounds in the generative model setting. Our work instead considers a second setting, providing a first algorithm for replicable policy estimation in the episodic exploration setting. We also provide experimental validation of the practical feasibility of our Replicable Phased Value Iteration algorithm.

From an RL perspective, our work is strongly related to understanding exploration in MDPs (Kearns and Singh, 1998; Brafman and Tennenholtz, 2003; Kakade, 2003). In the finite-horizon episodic setting, researchers made progress on upper bounds for exploration Auer and Ortner (2006); Auer et al. (2008); Jaksch et al. (2010) that ultimately led to the development of a near-complete understanding of the problem (Azar et al., 2017; Zanette and Brunskill, 2019; Simchowitz and Jamieson, 2019). Lower bounds are provided in other works (Dann and Brunskill, 2015; Osband and Roy, 2016). Further, Jin et al. (2020); Kaufmann et al. (2021) provide results on a reward-free framework that allows for the optimization of any reward function. While a good amount of progress has been made on understanding the base problem, the notion of replicability is not considered in any of them.

Given the connections of replicability and robustness, our work is related but orthogonal to that of the study of worst-case optimal policies and value functions. These worst-case results are often obtained via the study of robust Markov decision processes, first introduced by Nilim and Ghaoui (2005); Iyengar (2005). One line of work here has focused on relaxation of assumptions and combating conservativeness in robust MDPs (Wiesemann et al., 2013; Mannor et al., 2016; Petrik and Russel, 2019; Panaganti and Kalathil, 2022). Others have focused on various new formulations such as distributional robustness (Xu and Mannor, 2010; Yu and Xu, 2016). However, all of the above work focuses on understanding worst-cases and finding policies that do not have to be replicable.

Finally, our work is related to efforts in practical RL to ensure replicability, such as benchmark design (Guss et al., 2021; Mendez et al., 2022) and robust implementation (Nagarajan et al., 2018; Seno and Imai, 2022) and evaluation (Lynnerup et al., 2020; Jordan et al., 2020; Agarwal et al., 2021).

## 7 Conclusion & future work

We introduced the notion of formal replicability to the field of RL and established various novel algorithms for replicable RL. While these first results might have sub-optimal sample complexities, they highlight the crucial fact that replicability in RL is hard and requires study of the various aspects that impact it. We hope that future work can alleviate some of these efficiency challenges. A general open question is if replicable RL might simply be harder by nature than standard RL? This question needs to be posed on various levels because, as we argue in Section 3, finding a replicable policy might be easier than requiring the value function to be replicable. Finally, we believe the development of replicable algorithms for other settings such as the non-episodic setting as well as practical application are of great importance.

Figure 2: The \(\) algorithm evaluated on varying numbers of calls to \((G_{})\), with several values for the internal \(\) parameter \(_{SQ}\). Results are provided across \(150\) runs with different random sampling seeds. The number of calls is set to constant factor multiples of \(m=13000\). The dotted green line denotes the replicability threshold of \(1-\). The results show that, in practice, the number of samples needed for replicability can be orders of magnitude lower than our bounds suggest.