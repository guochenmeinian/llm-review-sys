# Quantum algorithm for large-scale market equilibrium computation

Po-Wei Huang1 and Patrick Rebentrost1, 2

1Centre for Quantum Technologies, National University of Singapore, Singapore 117543

2Department of Computer Science, National University of Singapore, Singapore 117417

huangpowei22@u.nus.edu, patrick@comp.nus.edu.sg

###### Abstract

Classical algorithms for market equilibrium computation such as proportional response dynamics face scalability issues with Internet-based applications such as auctions, recommender systems, and fair division, despite having an almost linear runtime in terms of the product of buyers and goods. In this work, we provide the first quantum algorithm for market equilibrium computation with sub-linear performance. Our algorithm provides a polynomial runtime speedup in terms of the product of the number of buyers and goods while reaching the same optimization objective value as the classical algorithm. Numerical simulations of a system with 16384 buyers and goods support our theoretical results that our quantum algorithm provides a significant speedup.

## 1 Introduction

The balance of supply and demand is a fundamental and well-known law that determines the price of goods in a market. In a market with a set of \(n\) buyers and \(m\) goods, the _competitive equilibrium_[1; 2] determines the optimal price and allocation of goods such that the supply equals the demand in the given market. The computation of the competitive equilibrium is known as the _market equilibrium computation problem_, whose unique solution was shown to exist under a general model of the economics in the seminal work of Arrow and Debreu . The relevance of such problems in algorithmic game theory [4; 5] is substantiated by the first welfare theorem, which implies that the competitive equilibria are _Pareto-efficient_, where no allocation is available that makes one agent better without making another one worse. In _competitive equilibrium from equal income_ (CEEI) scenarios, such equilibria are further known to by _envy-free_[7; 8], where no agent would prefer an allocation received by another agent over their own.

The market equilibrium computation problem has, in recent years, been extended to various large-scale Internet-based markets , including auction markets , fair item allocation/fair division [11; 12; 13], scheduling problems  and recommender systems . Such developments call for the need to further develop algorithmic theories for markets and the computation of market equilibria. We focus on a particular type of market known as the Fisher market [16; 17], where there is a set of \(n\) buyers interested in buying \(m\) infinitely-divisible goods, and where each buyer has their monetary budget that has no intrinsic value apart from being used to purchase goods. We mainly consider Fisher markets with linear utilities, where the total utility gained by purchasing goods is strictly linear to the value and proportion of the goods obtained.

For combinatorial formulations of the market equilibrium problem, algorithms have been discovered that can obtain exact and approximate solutions [18; 19; 20; 21], these algorithms scale poorly against the growing number of buyers and goods. One can also formulate the market equilibrium computation problem as an optimization problem that maximizes a convex objective function known as the Eisenberg-Gale (EG) convex program [22; 23]. For such optimization problems, approximatesolutions can be found much faster. One such algorithm of the market equilibrium problem is the _proportional response_ (PR) dynamics [24; 25]. The PR dynamics is an iterative algorithm that converges with a rate of \(\) where \(T\) is the number of iterations. Each iteration has a cost of \((mn)\) from proportionally updating individual bids of each buyer for different goods.

Given the high number of buyers and goods that can exist in Internet-based markets, the problem of further algorithmic speedups to the computation continues to be an active field of research. Gao and Kroer  discovered that by using projected gradient descent instead of PR dynamics, the market equilibrium can be found with linear convergence. Other attempts that aim to reduce the cost per iteration, such as using clustering to reduce the problem size , have also been made. However, it is unclear whether advantages beyond a constant-factor speedup can be provided.

While it is unclear whether additional classical strategies can provide further algorithmic speedup to the market equilibrium computation problem, one can utilize algorithmic developments in quantum computation to achieve such goals. Quantum computation  is an emerging technology that has been utilized for algorithmic speedups in various optimization problems  such as linear programming  and semidefinite programming [30; 31; 32; 33].

In this work, we consider a Fisher market with \(n\) buyers and \(m\) goods, where the objective is to find an approximate market equilibrium whose EG objective function is within an additive error \(\) of the optimal EG objective value. We provide a method to reduce the cost per iteration by utilizing quantum norm estimation and quantum inner product estimation [34; 35] and provide the first quantum algorithm to achieve sublinear performance in terms of the product of the buyers and goods in market equilibrium computation. To arrive at the quantum algorithm, we show an alternate version of the PR dynamics with erroneous updates, which we term the faulty proportional response (FPR) dynamics. We then provide a quantum algorithm that provides a quadratic speedup in terms of the smaller dimension between buyers and goods, as well as less memory consumption, albeit being based on QRAM instead of classical RAM. We summarize our results in Table 1.

Unlike the classical PR algorithm, which provides an entire matrix corresponding to the competitive equilibrium with storage \((mn)\) space,1 we provide quantum query and sample access to the values of the competitive equilibrium, which allows access to the individual values by index querying as well as \(_{1}\) sample access to the values. This access format has previously been used as the output model for quantum recommendation systems , quantum linear system solvers , but has been pointed out to have significant caveats . While the quantum algorithm does not exactly "solve" the market equilibrium problem in the sense of outputting the entire matrix, quantum query and sample access provide a preparation of a quantum state encoding the solution that can be used for further computation, for extracting only a small set of values within the matrix, or for extracting certain properties of the matrix, which may indeed be the use case for large-scale distributed systems.

   Algorithm & Iterations & Runtime & Memory & Result Prep. \\  PR dynamics  & \(\) & \(}\) & \((mn)\) & N/A, in RAM \\ Our work & \(\) & \(}}{^{2}}\) & \((m+n)^{*}\) & QA: \(()\) & SA: \(}()\) \\   

Table 1: _Main results._ In this work, \(n\) is the number of buyers, \(m\) is the number of goods, and \(\) indicates the additive error of the computed values to the minimally-achievable EG objective value. The memory complexity for the quantum algorithm (annotated with *) refers to the use of quantum query access to classical memory, achievable by QRAM (see Definition 3), instead of classical RAM. As the computed competitive equilibrium consumes \((mn)\) memory, our quantum algorithm does not provide the entire bid matrix, but instead provides quantum query access (QA) and sample access (SA) to the competitive equilibrium. The result preparation column refers to the additional runtime cost of preparing QA and SA.

## 2 Preliminaries

Notations.Let \([n]:=\{0,1,,n-1\}\). We use \(\) to represent element-wise multiplication, as well as \(\) for bit-wise XOR operation and \(\) for tensor products. For vectors \(v^{N}\), we denote a vector's \(_{p}\) norm by \(\|v\|_{p}:=[n]{_{i=1}^{N}|v_{i}|^{p}}\). Let \(_{M N}()\) indicate the space of square matrices of size \(M N\) over \(\). We denote the \(i\)-th row vector of \(A\) by \(A_{i,*}\) and the \(j\)-th column vector of \(A\) by \(A_{*,j}\). We further define \(\) as \(\), and the \(n\)-unit simplex as \(^{n}\), i.e. \(^{n}=\{v^{n},\|v\|_{1}=1\}\). For sets of numbers, we add the subscript \({}_{+}\) to indicate a constraint on positivity for elements in the set. We use \(|k\) to denote a binary encoding of a real number \(k\) up to arbitrary precision into a quantum state, and \(|\) to denote a multi-qubit zero state whose number of qubits can be inferred from the context. Lastly, we use \(}()\) to omit polylogarithmic factors in asymptotic runtime/memory analysis.

Quantum computation.Quantum algorithms are shown to be able to provide asymptotic speedups over classical counterparts  by utilizing characteristics of quantum mechanics such as preparing superpositions of different computational paths.

This property of quantum algorithms allows one to simulate the probability distribution of classical randomized algorithms directly as amplitudes of the quantum state, with the accepted results of the classical algorithms labelled as "good" states, and the rejected results as "bad" states. The _quantum amplitude amplification_ (QAA)  technique amplifies the amplitudes "good" states such that the success probability increases to a sufficiently high occurrence from its original \(p\) upon measurement at a runtime cost of \((1/)\). This provides a quadratic speedup compared to classical Monte Carlo methods, which take on average \((1/p)\) samples to achieve success. The QAA technique gives way to another technique known as _quantum amplitude estimation_ (QAE) , which combines QAA with eigenvalue estimation via quantum phase estimation (QPE)  to directly estimate the probability value of the occurrence of a certain event with a quadratic speedup.

**Theorem 1** (Quantum amplitude estimation; Theorem 12, , Formulation of ).: _Let \(t\). We are given one copy of a quantum state \(|\) as input, as well as a unitary transformation \(U=I-2||\), and a unitary transformation \(V=I-2P\) for some projector \(P\). There exists a quantum algorithm that outputs \(\), an estimate of \(a=\|P\,|\,\|^{2}\), such that_

\[|-a| 2}{M}+}{M^{2}}\]

_with probability at least \(8/^{2}\), using \(M\) applications of \(U\) and \(V\) each._

In this paper, we use QAE to estimate \(_{1}\) norms and inner products of vectors \(v^{N}\) up to a multiplicative error in \(M(}{}())\) runtime with probability \(1-\), invoking a quadratic speedup in both the dimension and the error rate. We defer the formulation and details to Appendix A.

Apart from quantum subroutines that provide speedups, we also require the usage of arithmetic operations such as addition, subtraction, multiplication, and division on quantum computers. We assume the arithmetic model, which would allow us to ignore issues arising from the fixed point representation of numbers.2 We further assume that we have access to quantum arithmetic circuits  that can perform such arithmetic operations in \((1)\) gates, and that by using such circuits, computation of the \(n\)-th power of a number, where \(n\), can be achieved in \(( n)\) gates, using methods like binary exponentiation . We note that quantum arithmetic circuits can be used to execute the same operation on multiple numbers in parallel if the numbers are held in superposition.

In regards to the access of data encoding in quantum states, there are two main models - quantum query access and quantum sample access. For clarity, we highlight quantum states that indicate the index in such access models in bold font throughout the manuscript.

**Definition 1** (Quantum query access).: Let \(n\) and \(c(1)\). Let a vector of bit strings \(w\) be such that \( j[n],w_{j}\{0,1\}^{c}\), and let an arbitrary bit string be \(x\{0,1\}^{c}\). We define quantum query access to \(w\) as the access to individual bit strings in \(w\) for \(j[n]\) in the format of

\[|\,|x|\,|x w_{j}\]

operating on \(( n)\) qubits.

_Note 1.1_.: Note that when \(x=0\), the quantum register stores \(|w_{j}\) after the query. When \(x=w_{j}\), the quantum register stores \(|0\) after the query. Hence, two consecutive queries onto a quantum register is the identity operation.

**Definition 2** (Quantum sample access).: Let \(n\) and \(w^{n}\). We define quantum sample access to \(w\) as the access to the index \(j[n]\) by probability \(w_{j}/\|w\|_{1}\) in the format of

\[|_{j=0}^{n-1}}{\|w\|_{1}}}| \]

operating on \(( n)\) qubits.

_Note 2.1_.: In quantum mechanics, Born's rule  postulates that the probability of measurement outcome corresponding to a state \(|\) is proportional to the square of its amplitude under superposition. Hence, the square root in the amplitude regarding the format of quantum sample access.

Lastly, we need to access the input matrices and intermediate vectors as a superposition of encoded quantum states. Such quantum query access to classical data in memory can be achieved by _quantum random access memory_ (QRAM) as follows.3 We refer the reader to  for a detailed survey.

**Definition 3** (Quantum random access memory; ).: Let \(n\) and \(c(1)\). Also let \(w\) be a vector of bit strings such that \( i[n],w_{i}\{0,1\}^{c}\). A quantum RAM provides quantum query access to \(w_{i}\) in superposition after a one-time construction cost of \(}(n)\), where each access costs \(( n)\).

_Note 3.1_.: Quantum sample access can also be provided by QRAM via Grover-Rudolph procedure  during construction with logarithmic overhead but is not used in this work.

Fisher market equilibrium.In the Fisher market model , we are given a market of \(m\) infinitely divisible goods to be divided among \(n\) buyers. Without loss of generality, we assume a unit supply for each good. Each buyer \(i[n]\) has a budget of \(B_{i}>0\) that has no intrinsic value apart from being used to purchase goods where, again without loss of generality, we assume that the corresponding vector \(B^{n}\). Each buyer also has a utility function \(u_{i}:^{m}_{+}\) that maps an allocation of portions of \(m\) items to a utility value. We can then define the allocation matrix \(x_{n m}()\) such that \(x_{ij}\) is the portion of item \(j\) allocated to buyer \(i\), where \(x_{i}^{m}\) is the bundle of products allocated to buyer \(i\). In this paper, we consider linear utility functions such that \(u_{i}(x_{i})=_{j[m]}v_{ij}x_{ij}\), where \(v_{ij}>0\) is the value for a unit of item \(j\) for buyer \(i\).

Given the Fisher market, we want to compute its _competitive equilibrium_, which consists of the price vector \(p_{+}^{m}\) for each item \(j\) and allocation matrix \(x\) such that each buyer \(i\) exhausts their entire budget \(B_{i}\) to acquire a bundle of items \(x_{i}\) that maximizes each of their utility \(u_{i}(x_{i})\).

The market equilibrium of Fisher markets can be captured by solving the Eisenberg-Gale (EG) convex program . The program is derived from maximizing the budget-weighted geometric mean of the buyers' utilities i.e. the Nash social welfare, satisfying natural properties such as invariance of the optimal solution to rescaling and splitting , and balances the efficiency and fairness regarding the allocation of goods. Applying the \(\) on the geometric mean, the EG program is as follows:

\[_{x 0}_{i[n]}B_{i} u_{i}(x_{i})_{i[n]}x_{ij}=1, j[m].\] (1)

where the price \(p_{j}\) is the dual variable of the constraint on \(x_{ij}\). Such convex programs (maximization of a concave function subject to constraints) can be solved by interior point methods , but may not scale to large markets. We discuss this further in Section 6.

For the linear Fisher market, an alternative convex program that obtains the same market equilibrium was shown by Shmyrev . Supposing that each buyer \(i\) submits a bid \(b_{ij}\) for item \(j\) such that the sum of the bid of the buyer matches their budget \(B_{i}\) such that each buyer \(i\) is allocated \(x_{ij}=b_{ij}/p_{j}\) of item \(j\), we have the following convex program:

\[_{b 0}_{ij}b_{ij}}{p_{j}}_{i[n]}b_{ij}=p_{j}, j[m];_{j[m]}b_{ij}=B_{i}, i [n].\] (2)

As the allocation matrix and price vector can be directly computed from and conversely, be used to compute the bid matrix, the bid matrix can be used as a direct representation of the market equilibrium itself, and hence, is the output of the algorithm we discuss in our paper.

Proportional response dynamics.The proportional response (PR) dynamics is an iterative algorithm [24; 25; 58] that obtains the Fisher market equilibrium computation by updating the bids \(b_{ij}\) submitted by buyer \(i\) for item \(j\). For each time step \(t\), the elements of the price vector \(p_{j}^{(t)}\) are computed by summing the bids for item \(j\) such that \(p_{j}^{(t)}=_{i}b_{ij}^{(t)}\). The allocation \(x_{ij}^{(t)}\) is then obtained by taking \(x_{ij}^{(t)}=b_{ij}^{(t)}/p_{j}^{(t)}\). The buyers then update the bids such that the new bid is proportional to the utility \(u_{i}^{(t)}=_{j}v_{ij}x_{ij}^{(t)}\) gained in the current time step such that \(b_{ij}^{(t+1)}=B_{i}v_{ij}x_{ij}^{(t)}/u_{i}^{(t)}\). It was shown by Birnbaum _et al._ that the PR dynamics is equivalent to mirror descent [60; 61] with respect to a Bregman divergence  of the Shmyrev convex program.

For ease of discussion, we write the objective function of the EG and Shmyrev convex programs as functions of the bid matrix \(b\), obtaining the EG objective function \((b)=-_{i[n]}B_{i} u_{i}\) and Shmyrev objective function \((b)=_{i[n],j[m]}b_{ij}}{v_{ij}}\). We denote the optimal bid \(b^{*}=_{b S}(b)\), where \(=b_{n m}():_{j[m]}b_{ ij}=B_{i}}\).

The convergence bounds of the PR dynamics regarding the EG and Shmyrev objective functions for linear Fisher markets were found as follows:

**Theorem 2** (Convergence of PR dynamics; ).: _Considering a linear Fisher market, for \(b_{ij}^{(t)}\) as iteratively defined by the proportional response dynamics where \(b_{ij}^{(0)}=}{m}\), we have_

\[(b^{(T)})-(b^{*}),(b^{(T-1)})-(b^{*} ).\] (3)

We provide an alternate end-to-end proof of the convergence of both convex programs in Appendix B that varies from Birnbaum _et al._'s approach and, unlike the latter, is centered around the EG function instead of the Shmyrev function. Elements of this proof are used in the proof of theorems in later sections. Two notable results that we prove and utilize are: 1) \((b^{(t+1)})(b^{(t)})+_{i[n]}B_{i} B_{i}(b^{(t)})\), and 2) the telescoping sum of the difference of the KL divergence  of the optimal bid and the iterating bids can be lower bounded by the difference of the current EG objective function and the optimal EG function.

## 3 Faulty proportional response dynamics

Before moving on to our quantum algorithm, we propose the faulty proportional response (FPR) dynamics, which computes an erroneous update to compute a sequence of bids \(_{ij}^{(t)}\). Such updates still retain a convergence guarantee, and serve as a counterpart to Theorem 2. We first define a faulty update we use for the FPR dynamics:

**Definition 4** (Faulty proportional response update).: Let \(t 0\) and \(^{(t)}_{n m}(_{+})\). Let us be given \(_{p}(0,0.5)\) and \(^{(t)}\) such that \( j,t\), \(|_{j}^{(t)}-_{j}^{(t)}|_{j}^{(t)}_{p}\) where \(_{j}^{(t)}=_{i[n]}_{ij}^{(t)}\). Further, let us be given \(_{}(0,0.5)\) and \(^{(t)}\) such that \( i,t,|_{i}^{(t)}-_{i}^{(t)}|_{j}^{(t) }_{p}\) where \(_{i}^{(t)}=_{j[m]}v_{ij}_{ij}^{(t)}/_{j}^{(t)}\). A faulty proportional response update of the bids from timestep to \(t+1\) is then expressed as follows:

\[_{ij}^{(t)}=_{ij}^{(t)}}{_{j}^{(t)}},_{ij}^{(t+1)}=B_{i}_{ij}^{(t)}}{_{i}^{(t)}}.\]

Note that while \(_{j}\) provides an estimation to the price \(_{j}=_{i[n]}_{ij}\), \(_{i}\) does not provide an estimation to the exact utility \(_{i}=_{j[m]}v_{ij}_{ij}/_{j}\). Instead, \(_{i}\) estimates \(_{i}\), which replaces \(_{j}\) in the computation of \(u_{i}\) with \(_{j}\).

We find the convergence bounds of the FPR dynamics regarding the EG objective function for linear Fisher markets are as follows:

**Theorem 3** (Convergence of the FPR dynamics).: _Considering a linear Fisher market, for \(b_{ij}^{(t)}\) as iteratively defined by the faulty proportional response dynamics where \(_{ij}^{(0)}=}{m}\), we have_

\[_{t[T]}(^{(t)})-(b^{*})\]

_when \(_{}\) and \(_{p}\)._A high-level idea of the proof follows from the telescoping sum trick to upper bound the EG objective functions with KL divergence from our proof of PR dynamics but with the consideration of error. We show an end-to-end proof of the convergence of the EG objective function in Appendix C.

Notice that in the FPR dynamics, we do not enforce the monotonicity of the iterations, but instead simply take the minimum value over all iterations. The error terms \(_{p}\) and \(_{}\) in the FPR dynamics are only upper bounded such that the total sum of objective values over \(T\) iterations (plus the original iteration) can be upper bounded by \( m\) plus an accumulated error over \(T\) iterations also within \( m\). If we enforce the monotonicity of the iterations to take the last iteration, the error would require \((1/T^{2})\) precision and would incur a further multiplicative overhead of \(T\) in our algorithm.

However, given the formulation of a faulty update, a problem that comes into question is whether the computation of the exact value of the function \((b)\) is supported, as we do not compute \(u_{i}\) in the process of updating. Without computation of \((b)\), one can not be sure which iteration of \(^{(t)}\) is the minimum. On the other hand, we can use the computed value of \(_{i}^{(t)}\) as an estimator for the function \((b)\). The following result is then obtained.

**Theorem 4**.: _Considering a linear Fisher market, for \(b_{ij}^{(t)}\) as iteratively defined by the faulty proportional response dynamics where \(_{ij}^{(0)}=}{m}\). Let \(t^{*}=_{t[T]}_{i[n]}B_{i}_{i}^{(t)}\). Then_

\[(^{(t^{*})})-(b^{*})\]

_when \(_{}\) and \(_{p}\)._

The proof of this theorem can similarly be found in Appendix C, which has the same proof idea as Theorem 3 apart from some slight differences in error handling.

## 4 Quantum algorithm

We present our quantum algorithm for solving linear Fisher market equilibrium computation based on the FPR dynamics. Our quantum algorithm does not aim to provide speedups in terms of the number of iterations but provides speedups on the iteration cost of the PR dynamics algorithm. Our algorithm, while reducing the runtime in terms of the number of buyers \(n\) or goods \(m\), increases runtime in terms of the number of iterations \(T\) but as the \(T\) is logarithmically dependent on \(m\), there is an overall quadratic speedup provided in the smaller of the two dimensions.

In this section, we further assume that \(v_{n m}(_{+})\). We note that the multiplicative scaling of \(v_{ij}\) does not affect the bid matrix \(b\) generated in the FPR dynamics as errors are multiplicative. Hence if the values are larger than \(1\), we scale down the values by dividing the queried \(v_{ij}\) by a number that is larger than \(_{ij}v_{ij}\).

To compute the market equilibrium for the Fisher market by the FPR dynamics in the quantum setting, we require the data input of both the budget vector \(B^{n}\) and the value matrix \(v_{n m}(_{+})\). We assume quantum query access to the budget and vector and value matrix by the index is readily given to us as part of the problem input without having to load classical data into a quantum system. That is, given an index state and ancilla quantum registers we can store the value of the budget and value according to the index in the ancilla register. Note that these operations can be performed in superposition, such that \(}_{i,j}}_{i,j}}\).

We do not explicitly state how the data input of the budget and value entries are generated; they could be extracted from entries of a matrix already preloaded in QRAM, or generated/reconstructed from a low-rank approximation of the matrix , which takes \((k mn)\) cost to access \(k\)-rank approximations using quantum arithmetic circuits, but with much lower memory consumption.4 We note that the low-rank approximation assumption of the value matrix has not yet been utilized to produce reductions in resource consumption in classical methods as the PR dynamics and other methods to compute market equilibrium  require all \(mn\) entries of the full value matrix as input.

Storing the results of the computed bids \(^{(t)}_{n m}(_{+})\) in QRAM would require a cost of \(}(mn)\) which would remove all possibility of potential speedups. The same applies to the allocation matrix \(^{(t)}\). Hence, every time we require the usage of \(^{(t)}\) or \(^{(t)}\), we compute them on-the-fly as follows:

\[^{(t)}_{ij}=_{ij}v^{t}_{ij}}{m_{k=0}^{t-1} ^{(k)}_{j}_{k=0}^{t-1}^{(k)}_{i}},^{(t)}_{ij}= _{ij}v^{t}_{ij}}{m_{k=0}^{t-1}^{(k)}_{j}_{k=0}^{ t-1}^{(k)}_{i}}\] (4)

Given quantum query access to the values of \((^{(t)}_{p})_{j}:=_{k=0}^{t}^{(k)}_{j}\) and \((^{(t)}_{})_{i}:=_{k=0}^{t}^{(k)}_{i}\), one can encode the values of \(^{(t+1)}\) and \(^{(t)}\) into a quantum state in superposition via quantum arithmetic circuits in runtime of \(()\). In our algorithm, we compute and store the vectors \(^{(t)}_{p}\) and \(^{(t)}_{}\) in QRAM, after which, query access to such values cost \(()\). Taking the \(t\)-th power of the budget and value cost \(()\) by using CNOT gates and binary exponentiation .

The remaining steps are to compute the price vector \(\) and utility vector \(\) in each iteration. Each entry \(_{j}\) is the estimation of the \(_{1}\) norm of \(_{*,j}\) and each entry \(_{i}\) is the estimation of the inner product between \(_{i,*}\) and \(v_{i,*}\), which can both be obtained using QAE. \(^{(t)}_{p}\) and \(^{(t)}_{}\) can then be iteratively updated by multiplying by the values of \(\) and \(\) each iteration. The full algorithm is shown in Algorithm 1, and the algorithmic guarantee is shown in Theorem 5.

```
0: Quantum query access to \(B\) and \(v\), Timestep limit \(T\), Price error \(_{p}\), Utility error \(_{}\)
1maxEGVa\(1=-\), \(b^{(0)}_{ij}=}{m}\)
2for\(t=0\) to \(T\)do
3for\(j=0\) to \(m\)do
4\(^{(t)}_{j}=\|^{(t)}_{*,j}\|_{1}(1_{p})\) via Q norm est. (Lemma A.1) with success prob. \(1-\)
5 Store vector \(^{(t)}_{p}=^{(t)}^{(t-1)}_{p}\) into QRAM
6 Gain access to \(^{(t)}_{ij}\) via \(^{(t)}_{p}\) and \(^{(t-1)}_{}\) in QRAM
7for\(i=0\) to \(n\)do
8\(^{(t)}_{i}= x^{(t)}_{i,*},v_{i,*}(1_{})\) via Q inner prod. est. (Lemma A.3) with success prob. \(1-\)
9 Store vector \(^{(t)}_{}=^{(t)}^{(t-1)}_{}\) into QRAM
10 Gain access to \(^{(t+1)}_{ij}\) via \(^{(t)}_{p}\) and \(^{(t)}_{}\) in QRAM
11 Classically compute \(^{(t)}=_{i[n]}B_{i}(^{(t)}_{i})\)
12if\(^{(t)}>\)then
13\(=^{(t)}\), bestPiP \(=^{(t-1)}_{p},=^{(t-1)}_{}\)
14returnbestPiP and bestPiNu in QRAM ```

**Algorithm 1**Quantum algorithm for faulty proportional response dynamics

**Theorem 5** (Quantum algorithm for the faulty proportional response dynamics).: _Let \((0,0.5),n,m,T\), \(_{p}=}{8T}\), and \(_{}=}{6T}\). Given quantum query access to \(B\) and \(v\), and access to QRAM, with success probability \(1-\), Algorithm 1 produces values stored in QRAM such that query and sample access to the values of \(^{(t^{*})}\) can be constructed, where_

\[(^{(t^{*})})-(b^{*})}{T},\]

_with \(}(T^{2})\) runtime and \(}(m+n)\) QRAM space. To provide query access to \(^{(t^{*})}\), an additional cost of \(()\) is incurred from accessing \(^{(t^{*}-1)}_{p}\) and \(^{(t^{*}-1)}_{}\) in QRAM. Providing sample access to \(^{(t^{*})}\) requires additional cost of \(()\) from QAA._

Proof.: Per union bound , we find that the total success probability is at least \(1-\). The output of Algorithm 1 of bestPiP and bestPiNu corresponds to the values of \(^{(t^{*}-1)}_{p}\) and \(^{(t^{*}-1)}_{}\). This gives us the guarantee of convergence shown in Theorem 4.

For the runtime analysis, the quantum norm estimation subroutine (Lemma A.1) takes \((}{_{p}})\) for \(mT\) iterations, while quantum inner product (Lemma A.3) estimation takes \((}{_{p}})\) for \(nT\) iterations, resulting in a total runtime of \(}(T^{2})\). For uses of QRAM, the construction on Lines 5 and 9 is a one-time cost of \(}(n)\) and \(}(m)\), respectively, with a total runtime of \(}(T(m+n))\). The classical computation of the EG value in Line 11 costs \((Tn)\). We note that the quantum norm and inner product estimation subroutine is the main bottleneck of the algorithm, and hence the total runtime is then \(}(T^{2})\).

For the memory complexity, for the \(t\)-th iteration, we require 6 vectors in QRAM: the current iteration \(_{p}^{(t)}\) and \(_{}^{(t)}\), the best iteration bestPiP and bestPiNu and the previous iteration \(_{p}^{(t-1)}\) and \(_{}^{(t-1)}\), in case we need to update bestPiP and bestPiNu. Note that to update the best iteration, we simply reroute the register of the previous iteration to being the best iteration. There is no need to copy data or reconstruct a new QRAM as the data from the previous iteration is no longer needed in the next iteration. Therefore, the memory is \((m+n)\) for storing the 6 vectors.

The values bestPiP and bestPiNu can be used to construct query access \(^{(t^{*})}\) per Equation (4). To prepare quantum sample access to the matrix \(^{(t^{*})}\), using quantum query access to \(^{(t^{*})}\) from Algorithm 1 and Equation (4) in addition to conditioned rotation gates, we can encode the values of \(^{(t^{*})}\) onto the amplitudes of an ancilla qubit via Lemma A.1 such that we obtain

\[}_{i,j}}_{i,j}(^{(t^{*})}_{ij}}+ ^{(t^{*})}_{ij}})\] (5)

Note that states where the last qubit is \(\) are the "good" states that we want, while the states where the last qubit is \(\) are "bad" states. To get rid of the "bad" states, we use QAA to amplify the amplitudes of the "good" states. Rewriting the above terms and ignoring the ancilla qubits, we obtain

\[^{(t^{*})}\|_{1}}{mn}}_{i,j}^{(t^{*})}_{ij}}{\|^{(t^{*})}\|_{1}}}+^{(t^{*})}\|_{1}}{mn}}_{i,j}^{(t^{*})}_{ij}}{mn-\|^{(t^{*})}\|_{1}}}\] (6)

We see from the above that the success probability of obtaining "good" states is \(^{(t^{*})}\|_{1}}{mn}\). Hence, QAA costs \(^{(t^{*})}\|_{1}}}\) query accesses to \(b^{(t^{*})}\), and while the exact value of \(\|^{(t^{*})}\|_{1}\) is not known, by Definition 4, \(}\|^{(t^{*})}\|_{1}}\). Hence, the query complexity of \(b^{(t^{*})}\) can be further upper bounded as \(()})()\). On the other hand, the cost of query access to \(b^{(t^{*})}\) has \(( Tmn)\) cost, therefore, the total cost for sample access to \(b^{(t^{*})}\) is \(}( T)\).

## 5 Numerical simulations

We simulate the market equilibrium computation under PR dynamics and our quantum algorithm.5 To showcase the effects of quantum speedups, we fixed the number of queries to all bid matrices \(b^{(t)}\) and observed the reduction of the objective value over the number of queries.

As an actual simulation of QAE using quantum gates over multiple qubits is costly, we directly compute the probability vector of \([Z=z]\) for \(z[M]\) that one would obtain by QAE  for a target value \(a\),

\[[Z=z]=(M_{z})}{M^{2}^{2}(_{z})}\] (7)

where \(_{z}=(|z-^{-1}()/|,|1-z+^{-1}()/|)\). \(M\) is the number of times that call the unitaries \(U\) and \(V\) in QAE (see Theorem 1), and is linearly correlated to the runtime. We then sample the output according to the computed probabilities to obtain an estimator \(=^{2}()\).

For our experiments, we generate the input data \(v\) where the value \(v\) is sampled from a uniform distribution with range \((0,1]\) and a normal distribution \((0.5,0.25)\), where we resample values that fall outside the range of \((0,1]\). For the budget \(B\), we either sample from the same distribution as the value matrix or set the same budget for all buyers to simulate competitive equilibrium from equal income (CEEI) applications. Our simulation includes \(n=16384\) buyers, \(m=16384\) goods, and iterate for \(T=16\) iterations for the PR dynamics. For the quantum algorithm, note that the queries per iteration would be reduced by \(\) if we use an actual quantum computer, hence increasing the number of iterations to fix the number of queries. For QAE, we run for \(}=512\) iterations and set \(M(})\). As the classical algorithms are deterministic, we return our quantum algorithm over \(15\) times with the same sample of \(B\) and \(v\) to observe the variance of convergence progress. Results are shown in Figure 1. Details on implementation and setup are found in Appendix D.

From the plots of Figure 1, we note that the results fit our theoretical results in that the quantum algorithm converges much faster than that of the PR dynamics . Further, we also compare against the convergence of projected gradient descent, which supports empirical results by Gao and Kroer  that in the regime of mid-level accuracy and low iterations, PR dynamics-related algorithms, both classical and quantum, converge faster than projected gradient descent.

## 6 Discussion

Quasi-linear utilities.For the bulk of our paper, we focus on the setting of linear utilities for Fisher markets. However, applications of market equilibrium computation in large-scale Fisher markets involve mostly quasi-linear utilities . An approach for using PR dynamics for quasi-linear utilities proposed by Gao and Kroer 6 includes the usage of slack variables \(=(_{1},,_{m})\) that represent the buyers' leftover budgets. The PR updates are then modified as follows:

\[b_{ij}^{(t+1)}=B_{i}x_{ij}^{(t)}}{_{j^{}}v_{ij^{}} x_{ij^{}}^{(t)}+_{i}^{(t)}},\ _{i}^{(t+1)}=B_{i}^{(t)}}{_{j^{}}v_{ij^{}} x_{ij^{}}^{(t)}+_{i}^{(t)}}.\] (8)

Further, PR dynamics for quasi-linear utilities exhibit a convergence rate of \(\). Using the methods discussed in previous sections, the quasi-linear version of PR dynamics can then be readily adapted to its quantum version by employing the same techniques of computing and storing in QRAM the values \(_{p}^{(t)}\) and \(_{}^{(t)}\) with on-the-fly computation of \(^{(t+1)}\), \(^{(t)}\) and \(^{(t+1)}\).

Constant number of buyers.Notice that our quantum algorithm provides a quadratic speedup on the smaller value in regards to the number of buyers \(n\) and number of goods \(m\). Therefore given extreme cases where the number of buyers \(n(1)\), our algorithm does not provide a speedup.

Figure 1: _Experimental results._ We perform our experiments on \(n=16384\) buyers and \(m=16384\) goods given the same amount of queries for all algorithms. We observe in Figure 0(a) that over different distributions, our quantum algorithm (green) significantly outperforms the PR dynamics (blue), which aligns with our theoretical results. Furthermore, our results also show that both our quantum algorithm and the PR dynamics outperform projected gradient descent (orange) in the mid-accuracy regime. Figure 0(b) shows the convergence of a single run of the quantum algorithm despite its instability from faulty updates, as well as the variance over the multiple runs (shaded in gray).

However, in such cases, quantum speedups may still be obtained simply by removing the QAE step for estimating the price for each item and replacing it with using quantum arithmetic circuits to compute the exact sum. We use a total of \((nT(T,m,n))\) qubits to compute the values of \(b_{i,*}\) separately on the \(i\)-th set of qubits, and only conduct QAE when estimating the utility value for each buyer. Given that in this setting, \(n(1)\), the total runtime would then be \(T^{2}\), gaining a quadratic speedup over the number of goods \(m\).

**Dequantization.** Given the work in recent years towards the development of quantum-inspired classical algorithms  that achieve similar performances as quantum algorithms using sampling-based techniques, a natural question that arises is whether our algorithm can be "de-quantized". The main speedup in our algorithm stems from the usage of estimation of \(_{1}\) norms and inner products. While the use of sampling techniques can indeed provide inner product estimations, they retain the same \((1/^{2})\) dependency instead of the \((1/)\) dependency of QAE. Hence, our algorithm performance may be hard to replicate in classical settings.

On the other hand, while it has been suggested that the computation of market equilibrium may benefit from low-rank approximations , methods of using such properties to accelerate the computation of gradients have not been proposed, given that the update of the PR dynamics rely on element-wise multiplication of matrices instead matrix multiplication. This would suggest that using sampling techniques to accelerate updates would be similarly difficult.

**Practicality.** Our quantum algorithm relies mostly on the QAE subroutine to achieve quantum speedups. In its original formulation, QAE involves the usage of QPE as a subroutine, which requires multiple controlled unitaries and the quantum Fourier transform . QAE is thus regarded as a fault-tolerant quantum subroutine, whose execution may be beyond the capabilities of current quantum hardware. However, many subtle improvements to the QAE algorithm have since been made after its discovery, such as simplifying subroutines  or trading circuit depth with speedup factors . Such improvements pave the way for potential implementation of QAE, and by extension, this paper, on next-generation quantum hardware in the early fault-tolerant regime .

**Potential and limitations for further quantum speedups.** Our quantum algorithm shares similarities to other quantum algorithms that are based on the _multiplicative weight update_ (MWU) method . Such methods have found success in obtaining quantum speedups for LPs  and SDPs , which have been extended to applications such as zero-sum games , quadratic binary optimization , and financial applications . Apart from the MWU-esque PR dynamics, various other methods for computing market equilibrium have also been proposed. Can quantum speedups obtained from these methods exceed those of our quantum algorithm?

Tracing back to the roots of the EG convex program  and Shmyrev convex program , it is well known that such programs can be solved in polynomial time with interior-point methods (IPM) . However, as IPMs require using linear solvers as subroutines, and as there is no guarantee of well-conditioned systems, the quantum linear systems solver  may not provide significant speedup. Therefore, it may be unlikely that quantum IPMs  can provide significant speedups.

First-order methods such as the Frank-Wolfe (FW) algorithm  and projected gradient descent (PGD) have also been discussed as candidates for solving market equilibrium , with PGD achieving linear convergence classically. While PGD obtains a superior asymptotic convergence rate in terms of the error \(\) compared to PR dynamics, as our quantum speedups stem from faster computations of results within a single iteration, it may be harder to find such speedups for PGD as there has been no evidence for quantum speedups in projections onto a simplex  as required.

On the other hand, the FW algorithm has been shown to provide quantum speedups for regression . However, convergence results of FW  show that \((b^{(T)})-(b^{*})}{(T+2)}\), where \(C_{}\) can be shown to be \((n)\) by computing relevant values. The number of iterations \(T\) required for convergence to additive error \(\) is then \(()\) as compared to \(()\) of PR dynamics. This matches the results of Gao and Kroer , which show that FW has slow convergence empirically for market equilibrium computation. Prior no-go results suggest that quantum algorithms cannot provide speedups for \(T\) when \(T\) is independent of the problem dimension . Assuming no quantum speedups in \(T\), given the \((n)\) upper bound in the FW algorithm, the quantum algorithm based on FW can potentially have a higher dependency on \(n\) than the classical PR dynamics.