# Towards Revealing the Mystery behind

Chain of Thought: A Theoretical Perspective

 Guhao Feng\({}^{1,5,*}\)  Bohang Zhang\({}^{2,*}\)   Yuntian Gu\({}^{3,*}\)   Haotian Ye\({}^{3,*}\)

Di He\({}^{2,}}}}}}}}}}}}}}}\)  Liwei Wang\({}^{2,4,}}}}}}}}}}}}}}\)

\({}^{1}\)School of EECS, Peking University  \({}^{2}\)National Key Laboratory of General Artificial Intelligence,

School of Intelligence Science and Technology, Peking University  \({}^{3}\)Yuanpei College,

Peking University  \({}^{4}\)Center for Machine Learning Research, Peking University  \({}^{5}\)Pazhou Lab

fenguhao@stu.pku.edu.cn   zhangbohang@pku.edu.cn   guyuntian@stu.pku.edu.cn

haotianye@pku.edu.cn   dihe@pku.edu.cn   wanglw@pku.edu.cn

Equal contributions.

###### Abstract

Recent studies have discovered that Chain-of-Thought prompting (CoT) can dramatically improve the performance of Large Language Models (LLMs), particularly when dealing with complex tasks involving mathematics or reasoning. Despite the enormous empirical success, the underlying mechanisms behind CoT and how it unlocks the potential of LLMs remain elusive. In this paper, we take a first step towards theoretically answering these questions. Specifically, we examine the _expressivity_ of LLMs with CoT in solving fundamental mathematical and decision-making problems. By using circuit complexity theory, we first give impossibility results showing that bounded-depth Transformers are unable to directly produce correct answers for basic arithmetic/equation tasks unless the model size grows _super-polynomially_ with respect to the input length. In contrast, we then prove by construction that autoregressive Transformers of _constant size_ suffice to solve both tasks by generating CoT derivations using a commonly used math language format. Moreover, we show LLMs with CoT can handle a general class of decision-making problems known as Dynamic Programming, thus justifying their power in tackling complex real-world tasks. Finally, an extensive set of experiments show that, while Transformers always fail to directly predict the answers, they can consistently learn to generate correct solutions step-by-step given sufficient CoT demonstrations.

## 1 Introduction

Transformer-based Large Language Models (LLMs) have emerged as a foundation model in natural language processing. Among them, the autoregressive paradigm has gained arguably the most popularity [51; 9; 46; 69; 57; 16; 52; 54], based on the philosophy that all different tasks can be uniformly treated as sequence generation problems. Specifically, given any task, the input along with the task description can be together encoded as a sequence of tokens (called the _prompt_); the answer is then generated by predicting subsequent tokens conditioned on the prompt in an autoregressive way.

Previous studies highlighted that a carefully designed prompt greatly matters LLMs' performance [32; 38]. In particular, the so-called _Chain-of-Thought_ prompting (CoT)  has been found crucial for tasks involving arithmetic or reasoning, where the correctness of generated answers can be dramatically improved via a modified prompt that triggers LLMs to output intermediate derivations. Practically, this can be achieved by either adding special phrases such as "_let's think step by step_" or by giving few-shot CoT demonstrations [34; 61; 56; 44; 70; 63]. However, despite the striking performance, the underlying mechanism behind CoT remains largely unclear and mysterious. On one hand, are thereindeed _inherent_ limitations of LLMs in directly answering math/reasoning questions? On the other hand, what is the essential reason behind the success of CoT2 in boosting the performance of LLMs?

This paper takes a step towards theoretically answering the above questions. We begin with studying the capability of LLMs on two basic mathematical tasks: evaluating arithmetic expressions and solving linear equations. Both tasks are extensively employed and serve as elementary building blocks in solving complex real-world math problems . We first provide fundamental impossibility results, showing that none of these tasks can be solved using bounded-depth Transformer models without CoT unless the model size grows super-polynomially with respect to the input length (Theorems 3.1 and 3.2). Remarkably, our proofs provide insights into why this happens: the reason is not due to the (serialized) computational cost of these problems but rather to their _parallel complexity_. We next show that the community may largely undervalue the strength of autoregressive generation: we prove by construction that autoregressive Transformers of _constant_ size can already perfectly solve both tasks by generating intermediate derivations in a step-by-step manner using a commonly-used math language format (Theorems 3.3 and 3.4). Intuitively, this result hinges on the recursive nature of CoT, which increases the "effective depth" of the Transformer to be proportional to the generation steps.

Besides mathematics, CoT also exhibits remarkable performance across a wide range of reasoning tasks. To gain a systematic understanding of why CoT is beneficial, we next turn to a fundamental class of problems known as _Dynamic Programming_ (DP) . DP represents a golden framework for solving sequential decision-making tasks: it decomposes a complex problem into a sequence (or chain) of subproblems, and by following the reasoning chain step by step, each subproblem can be solved based on the results of previous subproblems. Our main finding demonstrates that, for general DP problems of the form (5), LLMs with CoT can generate the complete chain and output the correct answer (Theorem 4.7). However, it is impossible to directly generate the answer in general: as a counterexample, we prove that bounded-depth Transformers of polynomial size cannot solve a classic DP problem known as Context-Free Grammar Membership Testing (Theorem 4.8).

Our theoretical findings are complemented by an extensive set of experiments. We consider the two aforementioned math tasks plus two celebrated DP problems listed in the "Introduction to Algorithms" book , known as _longest increasing subsequence_ (LIS) and _edit distance_ (ED). For all these tasks, our experimental results show that directly predicting the answers without CoT always fails (accuracy mostly below 60%). In contrast, autoregressive Transformers equipped with CoT can learn entire solutions given sufficient training demonstrations. Moreover, they even generalize well to longer input sequences, suggesting that the models have learned the underlying reasoning process rather than statistically memorizing input-output distributions. These results verify our theory and reveal the strength of autoregressive LLMs and the importance of CoT in practical scenarios.

## 2 Preliminary

An (autoregressive) Transformer [58; 50] is a neural network architecture designed to process a sequence of input tokens and generate tokens for subsequent positions. Given an input sequence \(\) of length \(n\), a Transformer operates the sequence as follows. First, each input token \(s_{i}\) (\(i[n]\)) is converted to a \(d\)-dimensional vector \(_{i}=(s_{i})^{d}\) using an embedding layer. To identify the sequence order, there is also a positional embedding \(_{i}^{d}\) applied to token \(s_{i}\). The embedded input can be compactly written into a matrix \(^{(0)}=[_{1}+_{1},,_{n}+_{n}]^{} ^{n d}\). Then, \(L\) Transformer blocks follow, each of which transforms the input based on the formula below:

\[^{(l)}=^{(l-1)}+^{(l)}(^{(l-1)})+ ^{(l)}(^{(l-1)}+^{(l)}(^{(l-1)})), l [L],\] (1)

where \(^{(l)}\) and \(^{(l)}\) denote the multi-head self-attention layer and the feed-forward network for the \(l\)-th Transformer block, respectively:

\[^{(l)}() =_{h=1}^{H}(_{Q}^{(l,h)}( _{K}^{(l,h)})^{}+)_{V}^{(l,h)}_{ O}^{(l,h)},\] (2) \[^{(l)}() =(_{1}^{(l)})_{2}^{(l)}.\] (3)Here, we focus on the standard setting adopted in Vaswani et al. , namely, an \(H\)-head softmax attention followed by a two-layer pointwise FFN, both with residual connections. The size of the Transformer is determined by three key quantities: its depth \(L\), width \(d\), and the number of heads \(H\). The parameters \(_{Q}^{(l,h)},_{K}^{(l,h)},_{V}^{(l,h)},_{O}^{(l,h)}\) are query, key, value, output matrices of the \(h\)-th head, respectively; and \(_{1}^{(l)},_{2}^{(l)}\) are two weight matrices in the FFN. The activation \(\) is chosen as GeLU , following . The matrix \(\{-,0\}^{n n}\) is a causal mask defined as \(M_{ij}=-\) iff \(i<j\). This ensures that each position \(i\) can only attend to preceding positions \(j i\) and is the core design for autoregressive generation.

After obtaining \(^{(L)}^{n d}\), its last entry \(_{n;i}^{(L)}^{d}\) will be used to predict the next token \(s_{n+1}\) (e.g., via a softmax classifier). By concatenating \(s_{n+1}\) to the end of the input sequence \(\), the above process can be repeated to generate the subsequent token \(s_{n+2}\). The process continues iteratively until a designated End-of-Sentence token is generated, signifying the completion of the process.

**Chain-of-Thought prompting**. Autoregressive Transformers possess the ability to tackle a wide range of tasks by encoding the task description into a partial sentence, with the answer being derived by complementing the subsequent sentence . However, for some challenging tasks involving math or general reasoning, a direct generation often struggles to yield a correct answer. To address this shortcoming, researchers proposed the CoT prompting that induces LLMs to generate intermediate reasoning steps before reaching the answer . In this paper, our primary focus lies in understanding the mechanism behind CoT, while disregarding the aspect of how prompting facilitates its triggering. Specifically, we examine CoT from an _expressivity_ perspective: for both mathematical problems and general decision-making tasks studied in Sections 3 and 4, we will investigate whether autoregressive Transformers are expressive for \(()\) directly generating the answer, and \(()\) generating a CoT solution for the tasks.

## 3 CoT is the Key to Solving Mathematical Problems

Previous studies have observed that Transformer-based LLMs exhibit surprising math abilities in various aspects . In this section, we begin to explore this intriguing phenomenon via two well-chosen tasks: arithmetic and equation. We will give concrete evidence that LLMs are capable of solving both tasks when equipped with CoT, while LLMs without CoT are provably incapable.

### Problem formulation

**Arithmetic.** The first task focuses on evaluating arithmetic expressions. As shown in Figure 1 (left), the input of this task is a sequence consisting of numbers, addition \((+)\), subtraction \((-)\), multiplication \(()\), division \(()\), and brackets, followed by an equal sign. The goal is to calculate the arithmetic expression and generate the correct result. This task has a natural CoT solution, where each step performs an intermediate computation, gradually reducing one atomic operation at a time while copying down other unrelated items. Figure 1 (left) gives an illustration, and the formal definition of the CoT format is deferred to Appendix B.

**Equation.** The second task considers solving linear equations. As shown in Figure 1 (right), the input of this task is a sequence consisting of \(m\) linear equations, each of which involves \(m\) variables. The input ends with a special symbol \(\). The goal is to output the value of these variables that satisfies the set of equations (assuming the answer exists and is unique). A natural CoT solution is the Gaussian elimination algorithm: at each step, it eliminates a certain variable in all but one equations. After \(m-1\) steps, all equations will have only one variable and the problem is solved. Figure 1 (right) gives an illustration, and we defer the formal definition of the CoT format to Appendix B.

**Number field**. Ideally, for both tasks, the input sequences involve not only symbol tokens but also floating-point numbers. This complicates the definitions of the model's input/output format

Figure 1: Illustrations of CoT on two math tasks.

and further entails intricate precision considerations when dealing with floating-point divisions. To simplify our subsequent analysis, here we turn to a more convenient setting by transitioning to the _finite field_ generated by integers modulo \(p\) for a prime number \(p\). Importantly, the finite field contains only \(p\) numbers (ranging from \(0\) to \(p-1\)) and thus can be uniformly treated as tokens in a pre-defined dictionary (like other operators or brackets), making the problem setting much cleaner. Moreover, arithmetic operations \((+,-,,)\) are well-defined and parallel the real number field (see Appendix A.1 for details). Therefore, this setting does not lose generalities.

In subsequent sections, we denote by \((n,p)\) the arithmetic evaluation task defined on the finite field modulo \(p\), where the input length does not exceed \(n\). Similarly, we denote by \((m,p)\) the linear equation task defined on the finite field modulo \(p\) with no more than \(m\) variables.

### Theoretical results

We begin by investigating whether Transformers can directly produce answers to the aforementioned problems. This corresponds to generating, for instance, the number "3" or the solution "\(x=1;y=1;z=0\)" in Figure 1 immediately after the input sequence (without outputting intermediate steps). This question can be examined via different theoretical perspectives. One natural approach is to employ the classic representation theory, which states that multi-layer perceptrons with sufficient size (e.g., the depth or width approaches infinity) are already universal function approximators [18; 35; 40]. Recently, such results have been well extended to Transformer models : it is not hard to show that a constant-depth Transformer with sufficient size can solve the above tasks3. However, the above results become elusive when taking the representation _efficiency_ into account, since it says nothing about the required model size for any specific task. Below, we would like to give a more fine-grained analysis of how large the network needs to be by leveraging the tool of complexity theory.

We focus on a _realistic_ setting called the **log-precision Transformer**[42; 37]: it refers to a Transformer whose internal neurons can only store floating-point numbers within a finite \(O( n)\) bit precision where \(n\) is the maximal length of the input sequence (see Appendix A.3 for a formal definition). Such an assumption well-resembles practical situations, in which the machine precision (e.g., 16 or 32 bits) is typically much smaller than the input length (e.g., 2048 in GPT), avoiding the unrealistic (but crucial) assumption of infinite precision made in several prior works [49; 20]. Furthermore, log-precision implies that the number of values each neuron can take is _polynomial_ in the input length, which is a _necessary_ condition for representing important quantities like positional embedding. Equipped with the concept of log-precision, we are ready to present a central impossibility result, showing that the required network size must be prohibitively large for both math problems:

**Theorem 3.1**.: _Assume \(^{0}^{1}\). For any prime number \(p\), any integer \(L\), and any polynomial \(Q\), there exists a problem size \(n\) such that no log-precision autoregressive Transformer defined in Section 2 with depth \(L\) and hidden dimension \(d Q(n)\) can solve the problem \((n,p)\)._

**Theorem 3.2**.: _Assume \(^{0}^{1}\). For any prime number \(p\), any integer \(L\), and any polynomial \(Q\), there exists a problem size \(m\) such that no log-precision autoregressive Transformer defined in Section 2 with depth \(L\) and hidden dimension \(d Q(m)\) can solve the problem \((m,p)\)._

**Why does this happen?** As presented in Appendices D.2 and E.2, the crux of our proof lies in applying circuit complexity theory . By framing the finite-precision Transformer as a computation model, one can precisely delineate its expressivity limitation through an analysis of its circuit complexity. Here, bounded-depth log-precision Transformers of polynomial size represent a class of _shallow_ circuits with complexity upper bounded by \(^{0}\). On the other hand, we prove that the complexity of both math problems above are lower bounded by \(^{1}\) by applying _reduction_ from \(^{1}\)-complete problems. Consequently, they are intrinsically hard to be solved by a well-parallelized Transformer unless the two complexity classes collapse (i.e., \(^{0}=^{1}\)), a scenario widely regarded as impossible .

**How about generating a CoT solution?** We next turn to the setting of generating CoT solutions for these problems. From an expressivity perspective, one might intuitively perceive this problem as more challenging as the model is required to express the entire problem solving process, potentially necessitating a larger model size. However, we show this is not the case: a _constant-size_ autoregressive Transformer already suffices to generate solutions for both math problems.

**Theorem 3.3**.: _Fix any prime \(p\). For any integer \(n>0\), there exists an autoregressive Transformer defined in Section 2 with constant hidden size \(d\) (independent of \(n\)), depth \(L=5\), and 5 heads in each layer that can generate the CoT solution defined in Appendix B for all inputs in \((n,p)\). Moreover, all parameter values in the Transformer are bounded by \(O((n))\)._

**Theorem 3.4**.: _Fix any prime \(p\). For any integer \(m>0\), there exists an autoregressive Transformer defined in Section 2 with constant hidden size \(d\) (independent of \(m\)), depth \(L=4\), and 5 heads in each layer that can generate the CoT solution defined in Appendix B for all inputs in \((m,p)\). Moreover, all parameter values in the Transformer are bounded by \(O((m))\)._

**Remark 3.5**.: The polynomial upper bound for parameters in Theorems 3.3 and 3.4 readily implies that these Transformers can be implemented using log-precision without loss of accuracy. See Appendix A.3 for a detailed discussion on how this can be achieved.

Proof sketch.: The proofs of Theorems 3.3 and 3.4 are based on construction. We begin by building a set of fundamental operations in Appendix C that can be implemented by Transformer layers. Specifically, the softmax attention head can perform two types of operations called the (conditional) COPY and MEAN (Lemmas C.7 and C.8). Here, conditional COPY extracts the content of the unique previous position that satisfies certain conditions, while Conditional MEAN averages the values of a set of previous positions that satisfy certain conditions. These two operations can be seen as a form of "_gather/scatter_" operator in parallel computing. On the other hand, the FFN in a Transformer layer can perform basic computations within each position, such as multiplication (Lemma C.1), conditional selection (Lemma C.4), and lookup tables (Lemma C.5). With these basic operations as "instructions" and by treating autoregressive generation as a loop, it is possible to write "programs" that can solve fairly complex tasks. As detailed in Appendices D.1 and E.1, we construct parallel algorithms that can generate CoT sequences for both math problems, thus concluding the proof. 

Several discussions are made as follows. _Firstly_, the constructions in our proof reveal the significance of several key components in the Transformer design, such as softmax attention, multi-head, feed-forward networks, and residual connection. Our proofs offer deep insights into the inner workings of Transformer models when dealing with complex tasks, significantly advancing prior understandings such as the "induction head" mechanism . Moreover, our results identify an inherent advantage of Transformers compared to other sequence models like RNNs: indeed, as shown in Appendix F.2, constant-size RNNs _cannot_ solve any of the above math tasks using the same CoT format. _Secondly_, we highlight that in our setting, the CoT derivations of both math problems are purely written in a _readable_ math language format, largely resembling how humans write solutions. In a broad sense, our findings justify that LLMs have the potential to convey meaningful human thoughts through _grammatically precise_ sentences. _Finally_, one may ask how LLMs equipped with CoT can bypass the impossibility results outlined in Theorems 3.1 and 3.2. Actually, this can be understood via the _effective depth_ of the Transformer circuit. By employing CoT, the effective depth is no longer \(L\) since the generated outputs are repeatedly looped back to the input. The dependency between output tokens leads to a significantly deeper circuit with depth proportional to the length of the CoT solution. Note that even if the recursive procedure is repeated within a fixed Transformer (or circuit), the expressivity can still be far beyond \(^{0}\): as will be shown in Section 4, with a sufficient number of CoT steps, autoregressive Transformers can even solve \(\)-complete problems.

## 4 CoT is the Key to Solving General Decision-Making Problems

The previous section has delineated the critical role of CoT in solving math problems. In this section, we will switch our attention to a more general setting beyond mathematics. Remarkably, we find that LLMs with CoT are theoretically capable of emulating a powerful decision-making framework called _Dynamic Programming_, thus strongly justifying the ability of CoT in solving complex tasks.

### Dynamic Programming

Dynamic programming (DP) is widely regarded as a core technique to solve decision-making problems . The basic idea of DP lies in breaking down a complex problem into a series of small subproblems that can be tackled in a sequential manner. Here, the decomposition ensures that there is a significant interconnection (overlap) among various subproblems, so that each subproblem can be efficiently solved by utilizing the answers (or other relevant information) obtained from previous ones.

Formally, a general DP algorithm can be characterized via three key ingredients: state space \(\), transition function \(T\), and aggregation function \(A\). Given a DP problem with \(N\) input sequences \(^{(1)},,^{(N)}\), denote the problem size to be the vector \(=(|^{(1)}|,,|^{(N)}|)\). Fixing the problem size \(\), there is an associated **state space**\(_{}\) representing the finite set of decomposed subproblems, where each state \(i_{}\) is an index signifying a specific subproblem. The size of the state space \(_{}\) grows with the problem size \(\). We denote by \((i)\) the answer of subproblem \(i\) (as well as other information stored in the DP process). Furthermore, there is a _partial order_ relation between different states: we say state \(j\) precedes state \(i\) (denoted as \(j i\)) if subproblem \(j\) should be solved before subproblem \(i\), i.e., the value of \((i)\) depends on \((j)\). This partial order creates a directed acyclic graph (DAG) within the state space, thereby establishing a reasoning chain where subproblems are resolved in accordance with the topological ordering of the DAG.

The **transition function**\(T\) characterizes the interconnection among subproblems and defines how a subproblem can be solved based on the results of previous subproblems. It can be generally written as

\[(i)=T(,,i,\{(j,(j)):j i\} ),\] (4)

where \(\) is the concatenation of all input sequences \(^{(1)},,^{(N)}\). In this paper, we focus on a restricted setting where each state \(i\) only depends on \(()\) a finite number of tokens in the input sequence \(\) and \(()\) a finite number of previous states. Under this assumption, we can rewrite (4) into a more concrete form:

\[(i)&=f(,i,s_{ {g}(,i)},((,i)))\\ &=f(,i,s_{g_{1}(,i)},,s_{g_{J}(,i)},(h_{1}(,i)),,(h_{K}(,i))),\] (5)

where functions \(f,,\) fully determine the transition function \(T\) and have the following form \(f:^{N}^{J}^{K} \), \(:^{N}(\{ \})^{J}\), \(:^{N}(\{ \})^{K}\). Here, the state space \(\), input space \(\), and DP output space \(\) can be arbitrary domains, and \(J,K\) are constant integers. If state \(i\) depends on less than \(J\) input tokens or less than \(K\) previous states, we use the special symbol \(\) to denote a placeholder, such that all terms \(s_{}\) and \(()\) are unused in function \(f\).

After solving all subproblems, the **aggregation function**\(A\) is used to combine all results and obtain the final answer. We consider a general class of aggregation functions with the following form:

\[A(\{(i,(i)):i_{}\})=u (_{i_{}}(i)),\] (6)

where \(_{}_{}\) is a set of states that need to be aggregated, \(\) is an aggregation function such as \(,\,,\) or \(\), and \(u:\) is any function where \(\) denotes the space of possible answers.

A variety of popular DP problems fits the above framework. As examples, the longest increasing subsequence (LIS) and edit distance (ED) are two well-known DP problems presented in the "Introduction to Algorithms" book  (see Appendix G.1 for problem descriptions and DP solutions). We list the state space, transition function, and aggregation function of the two problems in the table below.

   Problem & Longest increasing subsequence & Edit distance \\  Input & A string \(\) of length \(n\) & Two strings \(^{(1)}\), \(^{(2)}\) of length \(n_{1}=|^{(1)}|\) \\  & & and \(n_{2}=|^{(2)}|\), concatenated together \\  State space & \(\{(j,k):j[n],k\{0,,j\!-\!1\}\}\) & \(\{0,,n_{1}\}\{0,,n_{2}\}\) \\  Transition function & \((j,k)=\!\{1&k\!=\!0\\ ((j,k\!-\!1),&\\ (k,k\!-\!1)&k\!>\!0\\ [[s_{j}\!>\!s_{k}]\!+\!1)&.\) & \((j,k)=\!\{ak&j\!=\!0\\ bj&k\!=\!0\\ (j\!-\!1)+a,&\\ (j\!-\!1,k)+b,&\\ (j\!-\!1,k\!-\!1)&\\ &+c[s_{j}^{(1)}\!\!s_{k}^{(2)}])\\   

   Aggregation function & \(_{i[n]}(i,i-1)\) & \((n_{1},n_{2})\) \\   

### Theoretical results

We begin by investigating whether LLMs with CoT can solve the general DP problems defined above. We consider a natural CoT generation process, where the generated sequence has the following form:

\[^{(1)}||^{(N)}|(i_{1},(i_{1}))(i_{|_{}|},(i_{| _{}|}))\]Here, the input sequence consists of \(N\) strings separated by special symbols, and \((i_{1},,i_{|_{}|})\) is a feasible topological ordering of the state space \(_{}\). We assume that all domains \(\), \(\), \(\), \(\) belong to the real vector space so that their elements can be effectively represented and handled by a neural network. Each \((i,}\!(i))\) above will be represented as a _single_ vector and generated jointly in the CoT output. We further assume that \(\), \(\), \(\), \(\) are _discrete_ spaces (e.g., integers) so that the elements can be precisely represented using finite precision. To simplify our analysis, we consider a _regression_ setting where each element in the CoT output directly corresponds to the output of the last Transformer layer (without using a softmax layer for tokenization as in Section 3). Instead, the Transformer output is simply projected to the nearest element in the corresponding discrete space (e.g., \(\) or \(\)). Likewise, each generated output is directly looped back to the Transformer input without using an embedding layer. This regression setting is convenient for manipulating numerical values and has been extensively adopted in prior works .

Before presenting our main result, we make the following assumptions:

**Definition 4.1** (Polynomially-efficient approximation).: Given neural network \(P_{}\) and target function \(:^{}^{}\) where \(^{}^{d_{}}\) and \(^{}^{d_{}}\), we say \(\) can be approximated by \(P_{}\) with polynomial efficiency if there exist \(>0\), \(>0\) such that for any error \(>0\) and radius \(R>0\), there exists parameter \(\) satisfying that \(()()-P_{}(+)\|_{} <+\|\|_{}\) for all \(^{}\), \(\|\|_{} R\) and all \(\|\|_{}<\); \(()\) all elements of parameter \(\) are bounded by \(O((R,1/))\).

**Assumption 4.2**.: The size of the state space can be polynomially upper bounded by the problem size \(\), i.e., \(|_{}|=O((||))\). Similarly, all input elements, DP values, and answers are polynomially upper bounded by the problem size \(\).

**Assumption 4.3**.: Each function \(f\), \(\), \(\) and \(u\) in (5) and (6) can be approximated with polynomial efficiency by a perceptron of constant size (with GeLU activation).

**Assumption 4.4**.: The function \(F:^{N}\) defined as \(F(,i_{k})=i_{k+1}\) for \(^{N}\), \(k[|_{}|-1]\) can be approximated with polynomial efficiency by a perceptron of constant size (with GeLU activation), where \((i_{1},,i_{|_{}|})\) is a feasible topological ordering of the state space \(_{}\).

**Assumption 4.5**.: The function \(F:^{N}\{0,1\}\) defined as \(F(,i)=[i_{n}]\) (see (6)) can be approximated with polynomial efficiency by a perceptron of constant size (with GeLU activation).

**Remark 4.6**.: All assumptions above are mild. Assumption 4.2 is necessary to ensure that the state vectors, inputs, and DP values can be represented using log-precision, and Assumptions 4.3 to 4.5 guarantee that all basic functions that determine the DP process can be well-approximated by a composition of finite log-precision Transformer layers of constant size. In Appendix G.1, we show these assumptions are satisfied for LIS and ED problems described above as well as the CFG Membership Testing problem in Theorem 4.8.

We are now ready to present our main result, which shows that LLMs with CoT can solve all DP problems satisfying the above assumptions. We give a proof in Appendix G.2.

**Theorem 4.7**.: _Consider any DP problem satisfying Assumptions 4.2 to 4.5. For any integer \(n\), there exists an autoregressive Transformer with constant depth \(L\), hidden dimension \(d\) and attention heads \(H\) (independent of \(n\)), such that the answer generated by the Transformer is correct for all input sequences of length no more than \(n\). Moreover, all parameter values are bounded by \(O((n))\)._

To complete the analysis, we next explore whether Transformers can directly predict the answer of DP problems without generating intermediate CoT sequences. We show generally the answer is no: many DP problems are intrinsically hard to be solved by a bounded-depth Transformer without CoT. One celebrated example is the Context-Free Grammar (CFG) Membership Testing, which take a CFG \(G\) and a string \(\) as input and tests whether \(\) belongs to the context-free language generated by \(G\). A formal definition of this problem and a standard DP solution are given in Appendix G.1. We have the following impossibility result (see Appendix G.3 for a proof):

**Theorem 4.8**.: _Assume \(^{0}^{1}\). There exists a context-free language such that for any depth \(L\) and any polynomial \(Q\), there exists a sequence length \(n\) where no log-precision autoregressive transformer with depth \(L\) and hidden dimension \(d Q(n)\) can generate the correct answer for the CFG Membership Testing problem for all input strings of length \(n\)._

In contrast, enabling CoT substantially improves the expressivity of Transformers: as proved in Jones & Laaser , the universal CFG Membership Testing is a celebrated \(\)-complete problem and is intrinsically hard to be solved by a well-parallelized computation model. Combined with these results, we conclude that CoT plays a critical role in tackling tasks that are inherently difficult.

Experiments

In previous sections, we proved by construction that LLMs exhibit sufficient expressive power to solve mathematical and decision-making tasks. On the other hand, it is still essential to check whether a Transformer model can _learn_ such ability directly from training data. Below, we will complement our theoretical results with experimental evidence, showing that the model can easily learn underlying task solutions when equipped with CoT training demonstrations.

### Experimental Design

**Tasks and datasets.** We choose four tasks for evaluation: Arithmetic, Equation, LIS, and ED. The first two tasks (Arithmetic and Equation) as well as their input/CoT formats have been illustrated in Figure 1. For the LIS task, the goal is to find the length of the longest increasing subsequence of a given integer sequence. For the ED task, the goal is to calculate the minimum cost required (called edit distance) to convert one sequence to another using three basic edit operations: insert, delete and replace. All input sequences, CoT demonstrations, and answers in LIS and ED are bounded-range integers and can therefore be tokenized (similar to the first two tasks). We consider two settings: (i) CoT datasets, which consist of <problem, CoT steps, answer> samples; (ii) Direct datasets, which are used to train models that directly predict the answer without CoT steps. These datasets are constructed by removing all intermediate derivations from the CoT datasets.

For each task, we construct three datasets with increasing difficulty. For Arithmetic, we build datasets with different numbers of operators ranging from \(\{4,5,6\}\). For Equation, we build datasets with different numbers of variables ranging from \(\{3,4,5\}\). For LIS, we build datasets with different input sequence lengths ranging from \(\{50,80,100\}\). For ED, we build datasets with different string lengths, where the average length of the two strings ranges from \(\{12,16,20\}\). Creating these datasets allows us to investigate how model performance varies with the increase of problem size. We generate 1M samples for each training dataset and 0.1M for testing while ensuring that duplicate samples between training and testing are removed. More details about the dataset construction can be found in Appendix H.

**Model training and inference.** For all experiments, we use standard Transformer models with hidden dimension \(d=256\), heads \(H=4\), and different model depths \(L\). We adopt the AdamW optimizer  with \(_{1}=0.9,_{2}=0.999,=10^{-4}\), and weight decay \(=0.01\) in all experiments. We use a fixed dropout ratio of 0.1 for all experiments to improve generalization. For CoT datasets, we optimize the negative log-likelihood loss on all tokens in the CoT steps and answers. This is similar to the so-called process supervision proposed in a concurrent work . For direct datasets, we optimize the negative log-likelihood loss on answer tokens. All models are trained on 4 V100 GPUs for 100 epochs. During inference, models trained on the direct datasets are required to output the answer directly, and models trained on CoT datasets will generate the whole CoT process token-by-token (using greedy search) until generating the End-of-Sentence token, where the output in the final step is regarded as the answer. We report the accuracy as the evaluation metric. Please refer to Appendix H for more training configuration details.

### Experimental Results

**Main results**. All results are shown in Figure 2, where each subfigure corresponds to a task with x-axis representing the difficulty level and y-axis representing the test accuracy (%). We repeat each experiment five times and report the error bars. In each subfigure, the purple bar and blue bars indicate the performance of the model trained on the CoT and direct datasets, respectively. The model depths are specified in the legend. From these results, one can easily see that 3-layer Transformers with CoT already achieve near-perfect performance on all tasks for all difficulty levels, which is consistent to Theorems 3.3, 3.4 and 4.7 and may further imply that they can learn better solutions with fewer model depth than our constructions. Moreover, it is worth noting that, for some difficult datasets such as Equation 5 variables, a perfect accuracy would imply that the model can precisely generate a correct CoT with a very long length of roughly 500 for all inputs. In contrast, models trained on direct datasets perform much worse even when using larger depths (particularly on the Equation task). While increasing the depth usually helps the performance of direct prediction (which is consistent with our theory), the performance drops significantly when the length of the input sequence grows. All these empirical findings verify our theoretical results and clearly demonstrate the benefit of CoT in autoregressive generation.

**Robustness to data quality**. Unlike the synthetic datasets constructed above, real-world training datasets are not perfect and often involve corruption or miss intermediate steps. This calls into question whether the model can still perform well when training on low-quality datasets. To investigate this question, we construct corrupted datasets for the arithmetic task in Appendix I. Surprisingly, our results show that the 3-layer Transformer model can still achieve more than 95% accuracy even with 30% of the data missing an intermediate CoT step and involving a single-token corruption. This clearly demonstrates the robustness of CoT training on low-quality datasets.

**Length extrapolation.** We finally study whether the learned autoregressive models can further extrapolate to data with longer lengths. We construct a CoT training dataset for the arithmetic task with the number of operators ranging from \(1\) to \(15\), and test the model on expressions with the number of operators in \(\{16,17,18\}\). As shown in Figure 3, our three-layer Transformer model still performs well on longer sequences, suggesting that the model indeed learns the solution to some extent (instead of memorizing data distributions). Potentially, we believe models trained on more data with varying lengths can eventually reveal the complete arithmetic rules.

## 6 Related Work

Owing to the tremendous success of Transformers and Large Language Models across diverse domains, there has been a substantial body of works dedicated to theoretically comprehending their capabilities and limitations. Initially, researchers primarily focused on exploring the expressive power of Transformers in the context of function approximation. Yun et al.  proved that Transformers with sufficient size can universally approximate arbitrary continuous sequence-to-sequence functions on a compact domain. Recently, universality results have been extended to model variants such as Sparse Transformers  and Transformers with relative positional encodings (RPE) .

Figure 3: Performance of length extrapolation experiment, tested on sequences that are longer than those in training.

Figure 2: Model performance on different tasks. For all tasks and various difficulty levels, autoregressive Transformers with CoT consistently outperform Transformers trained on direct datasets. In particular, 3-layer Transformers already succeed in these tasks with almost perfect accuracy, while deeper Transformers (\(L=3,4,5\)) trained on the direct datasets typically fail.

More relevant to this paper, another line of works investigated the power of Transformers from a computation perspective. Early results have shown that both standard encoder-decoder Transformers  and looped Transformer encoders are Turing-complete [49; 47; 20; 8]. However, these results depend on the unreasonable assumption of _infinite_ precision, yielding a quite unrealistic construction that does not match practical scenarios. Recently, Giannou  demonstrated that a constant-depth looped Transformer encoder can simulate practical computer programs. Wei et al.  showed that finite-precision encoder-decoder Transformers can _approximately_ simulate Turing machines with bounded computation time. Liu et al.  considered a restricted setting of learning automata, for which a shallow non-recursive Transformer provably suffices. Yao et al.  demonstrated that Transformers can recognize or generate bounded-depth Dyck language , a specific type of context-free language. Besides affirmative results, other works characterized the expressivity limitation of Transformers via the perspective of modeling formal languages [26; 7; 62; 66; 14] or simulating circuits [27; 43; 42]. However, none of these works (except ) explored the setting of autoregressive Transformers typically adopted in LLMs, which we study in this paper. Moreover, we consider a more practical setting that targets the emergent ability of LLMs in solving basic reasoning problems via a _readable_ CoT output, which aligns well with real-world scenarios.

Recently, the power of Transformers has regained attention due to the exceptional in-context learnability exhibited by LLMs . Garg et al.  demonstrated that autoregressive Transformers can in-context learn basic function classes (e.g., linear functions, MLPs, and decision trees) via input sample sequences. Subsequent works further revealed that Transformers can implement learning algorithms such as linear regression , gradient descent [1; 59; 19], and Bayesian inference , and a broad class of machine learning algorithms . The works of [23; 45] studied in-context learning via the concept of "induction heads". All the above works investigated the power of (autoregressive) Transformer models from an expressivity perspective, which shares similarities to this paper. Here, we focus on the reasoning capability of Transformers and underscore the key role of CoT in improving the power of LLMs.

## 7 Limitations and Future Directions

In this work, from a model-capacity perspective, we theoretically analyze why Chain-of-Thought prompting is essential in solving mathematical and decision-making problems. Focusing on two basic mathematical problems as well as Dynamic Programming, we show that a bounded-depth Transformer without CoT struggles with these tasks unless its size grows prohibitively large. In contrast to our negative results, we prove by construction that when equipped with CoT, constant-size Transformers are sufficiently capable of addressing these tasks by generating intermediate derivations sequentially. Extensive experiments show that models trained on CoT datasets can indeed learn solutions almost perfectly, while direct prediction always fails. We further demonstrate that CoT has the potential to generalize to unseen data with longer lengths.

Several foundational questions remain to be answered. Firstly, while this paper investigates why CoT enhances the expressivity of LLMs, we do not yet answer how the CoT generation process is triggered by specific prompts. Revealing the relation between prompts and outputs is valuable for better harnessing LLMs. Secondly, it has been empirically observed that scaling the model size significantly improves the CoT ability . Theoretically understanding how model size plays a role in CoT would be an interesting research problem. Thirdly, this paper mainly studies the expressivity of LLMs in generating CoT solutions, without theoretically thinking about their _generalization_ ability. Given our experimental results, we believe it is an important future direction for theoretically studying how LLMs can generalize from CoT demonstrations (even in the out-of-distribution setting, e.g., length extrapolation (Figure 3)) [60; 13]. Finally, from a practical perspective, it is interesting to investigate how models can learn CoT solutions when there are only limited CoT demonstrations in training (or even purely from direct datasets). We would like to leave these questions as future work, which we believe are beneficial to better reveal the power and limitations of LLMs.

Acknowledgement.This work is supported by National Key R&D Program of China (2022ZD0114900) and National Science Foundation of China (NSFC62276005), and is partially funded by Microsoft Research Asia Collaborative Research Project. The authors are grateful to David Chiang, who pointed out a mistake regarding the P-completeness of CFG Membership Testing in the early version of this paper. The authors also thank all reviewers for their valuable suggestions.

## Author Contributions

**Guhao Feng** proposed to analyze the expressivity of Transformers using circuit complexity and proved all impossibility results in this paper, including Theorems 3.1, 3.2 and 4.8. He came up with the initial idea of Dynamic Programming. He and Bohang Zhang formalized the DP framework and proved all positive results in this paper, including Theorems 3.3, 3.4 and 4.7. He contributed to the paper writing of Appendices C to G.

**Bohang Zhang** supervised all undergraduate students. He raised the the problem of linear equation. He and Guhao Feng formalized the DP framework and proved all positive results in this paper, including Theorems 3.3, 3.4 and 4.7. In the experimental part, he helped generate datasets with Yuntian Gu, conducted hyper-parameter tuning, and finalized all experiments in Section 5. He was responsible for writing the majority of this paper and checking/correcting all proofs.

**Yuntian Gu** was responsible for the experimental part. He wrote the entire code, including the model details, training pipeline, and evaluation. He created the datasets for all four tasks in Section 5 and conducted extensive experimental exploration during this project (with the help of Bohang Zhang).

**Haotian Ye** participated in regular discussions, raised ideas, and helped check the code in experiments.

**Di He** initiated the problem of studying the capability of Transformers in basic tasks like evaluating arithmetic expressions. **Di He** and **Liwei Wang** led and supervised the research, suggested ideas and experiments, and assisted in writing the paper.