# EFO\({}_{k}\)-CQA: Towards Knowledge Graph

Complex Query Answering beyond Set Operation

Anonymous Author(s)

Affiliation

Address

email

###### Abstract

To answer complex queries on knowledge graphs, logical reasoning over incomplete knowledge needs learning-based methods because they are capable of generalizing over unobserved knowledge. Therefore, an appropriate dataset is fundamental to both obtaining and evaluating such methods under this paradigm. In this paper, we propose a comprehensive framework for data generation, model training, and method evaluation that covers the combinatorial space of Existential First-order Queries with multiple variables (EFO\({}_{k}\)). The combinatorial query space in our framework significantly extends those defined by set operations in the existing literature. Additionally, we construct a dataset, EFO\({}_{k}\)-CQA, with 741 query types for empirical evaluation, and our benchmark results provide new insights into how query hardness affects the results. Furthermore, we demonstrate that the existing dataset construction process is systematically biased and hinders the appropriate development of query-answering methods, highlighting the importance of our work. Our code and data are provided in https://anonymous.4open.science/r/EFOK-CQA/README.md

## 1 Introduction

The Knowledge Graph (KG) is a powerful database that encodes relational knowledge into a graph representation [34; 31], supporting downstream tasks [41; 8] with essential factual knowledge. However, KGs suffer from incompleteness during its construction [34; 7; 19]. The task of Complex Query Answering (CQA) proposed recently has attracted much research interest [13; 28]. This task ambitiously aims to answer database-level complex queries described by logical complex connectives (conjunction \(\), disjunction \(\), and negation \(\)) and quantifiers1 (existential \(\)) [37; 27; 18]. Currently, learning-based methods dominate the CQA tasks because they can empirically generalize to unseen knowledge as well as prevent the resource-demanding symbolic search.

The thriving of learning-based methods also puts an urgent request on high-quality benchmarks, including datasets with comprehensive coverage of queries and sound answers, and fair evaluation protocol for learning-based approaches. In the previous study, datasets are developed by progressively expanding the **syntactical expressiveness**, where conjunction , union , negation , and other operators  are taken into account sequentially. In particular, BetaE dataset  contains all logical connectives and becomes the standard training set for model development. A largerevaluation benchmark EFO-1-QA  was proposed to systematically evaluate the combinatorial generalizability of CQA models on such queries. More related works are included in Appendix A.

However, the queries in previous datasets [28; 36] are recently justified as "Tree-Form" queries  as they rely on the tree combinations of set operations. Compared to the well-established TPC-H decision support benchmark  for database query processing, queries in existing CQA benchmarks [28; 36] have two common shortcomings: (1) lack of **combinatorial answers**: only one variable is queried, and (2) lack of **structural hardness**: all existing queries subject to the structure-based tractability [29; 39]. It is rather questionable whether existing CQA data under such limited scope can support the future development of methodologies for general decision support with incomplete knowledge.

The goal of this paper is to establish a new framework that addresses the aforementioned shortcomings to support further research in complex query answering on knowledge graphs. Our framework is formally motivated by the well-established investigation of constraint satisfaction problems , in which all queries can be formulated. In general, the contribution of our work is four folds.

**Complete coverage**: We capture the complete Existential First Order (EFO) queries from their rigorous definitions, underscoring both **combinatorial hardness** and **structural hardness** and extending the existing coverage  which covers only a subset of \(_{1}\) query. The captured query family is denoted as \(_{k}\) where \(k\) stands for multiple variables.
**Curated datasets**: We derive \(_{k}\)-CQA dataset, a enormous extension of the previous EFO-1-QA benchmark  and contains 741 types of query. We design several systematic rules to guarantee that our dataset includes high-quality nontrivial queries, particularly those that contain multiple query variables and are not structure-based tractable.
**Convenient implementation**: We implement the entire pipeline for query generation, answer sampling, model training and inference, and evaluation for the undiscussed scenarios of **combinatorial answers**. Our pipeline is backward compatible, which supports both set operation-based methods and more recent ones.
**Results and findings**: We evaluate six representative CQA methods on our benchmark. Our results refresh the previous empirical findings and further reveal the structural bias of previous data.

## 2 Problem definition

### Existential first order (EFO) queries on knowledge graphs

Given a set \(\) of entities and a set \(\) of relations, a knowledge graph \(\) encodes knowledge as a set of factual triple \(=\{(h,r,t)\}\). We always assume the KG that we have observed \(_{o}\) is only part of the real KG, meaning that \(_{o}\).

The existing research only focuses on the logical formulas without universal quantifiers [27; 35]. We then offer the definition of it based on strict first order logic.

**Definition 1** (Term).: _A term is either a variable \(x\) or an entity \(a\)._

**Definition 2** (Atomic formula).: \(\) _is an atomic formula if \(=r(h,t)\), where \(r\) is a relation, \(h\) and \(t\) are two terms._

**Definition 3** (Existential first order formula).: _The set of the existential formulas is the smallest set \(\) that satisfies the following2:_

1. _For atomic formula_ \(r(h,t)\)_, itself and its negation_ \(r(h,t), r(h,t)\)__
2. _If_ \(,\)_, then_ \((),()\)__
3. _If_ \(\) _and_ \(x_{i}\) _is any variable, then_ \( x_{i}\)_._

**Definition 4** (Free variable).: _If a variable \(y\) is not associated with an existential quantifier, it is called a free variable, otherwise, it is called a bounded variable. We write \((y_{1},,y_{k})\) to indicate \(y_{1},,y_{k}\) are the free variables of \(\)._

**Definition 5** (Sentence and query).: _A formula \(\) is a sentence if it contains no free variables, otherwise, it is called a query. In this paper, we always consider formula with free variables, thus, we use formula and query interchangeably._

**Definition 6** (Substitution).: _For \(a_{1},,a_{k}\), where \(a_{i}\), we write \((a_{1}/y_{1},,a_{k}/y_{k})\) or simply \((a_{1},,a_{k})\) for the result of simultaneously replacing all the occurrence of \(y_{i}\) in \(\) by \(a_{i}\), \(i=1,,k\)._

**Definition 7** (Answer of an EFO query).: _For a given existential query \((y_{1},,y_{k})\) and a knowledge graph \(\), its answer is a set that defined by_

\[[(y_{1},,y_{k})]=\{(a_{1},,a_{k}))|a_{i} ,i=1,,k,\,(a_{1},,a_{k})\}.\]

**Definition 8** (Disjunctive Normal Form (DNF)).: _For any existential formula \((y_{1},,y_{k})\), it can be converted to the Disjunctive normal form as shown below:_

\[(y_{1},,y_{k}) =_{1}(y_{1},,y_{k})_{m}(y_{1}, ,y_{k}),\] (1) \[_{i}(y_{1},,y_{k}) = x_{1},,x_{n}._{i1}_{it},\] (2)

where \(_{ij}\) is either an atomic formula or its negation, \(x_{i}\) is called an existential variable.

DNF form has a strong property that \([(y_{1},,y_{k})]=_{i=1}^{m}[_{i}(y_ {1},,y_{k})]\), which allows us to only consider conjunctive formulas \(_{i}\) and then aggregate those answers to retrieve the final answers. This practical technique has been used in many previous research . Therefore, we only discuss conjunctive formulas in the rest of this paper.

### Constraint satisfaction problem for EFO queries

Formally, a Constraint Satisfaction Problem (CSP) \(\) can be represented by a triple \(=(X,D,C)\) where \(X=(v_{1},,v_{n})\) is an \(n\)-tuple of variables, \(D=(D_{1},,D_{n})\) is the corresponding \(n\)-tuple of domains, \(C=(C_{1},,C_{t})\) is \(t\)-tuple constraint, each constraint \(C_{i}\) is a pair of \((S_{i},R_{S_{i}})\) where \(S_{i}\) is a set of variables \(S_{i}=\{v_{i_{j}}\}\) and \(R_{S_{i}}\) is the constraint over those variables .

Historically, there are strong parallels between CSP and conjunctive queries in knowledge bases . The terms correspond to the variable set \(X\). The domain \(D_{i}\) of a constant entity contains only itself, while it is the whole entity set \(\) for other variables. Each constraint \(C_{i}\) is binary that is induced by an atomic formula or its negation, for example, for an atomic formula \(r(h,t)\), we have \(S_{i}=\{h,t\}\), \(R_{S_{i}}=\{(h,t)|h,t,(h,r,t)\}\). Finally, by the definition of existential quantifier, we only consider the answer of free variables, rather than tracking all terms within the existential formulas.

**Definition 9** (CSP answer of conjunctive formula).: _For a conjunctive formula \(\) in Equation 2 with \(k\) free variables and \(n\) existential variables, the answer set, \(\), of it formulated as CSP instance is:_

\[}[(y_{1},,y_{k})]=[^{ }(y_{1},,y_{n+k})],^{}=_{i1}_{it}.\]

This shows that the inference of existential formulas is easier than solving CSP instances since the existential variables do not need to be kept track of.

Figure 1: Operator Tree versus Query Graph. **Left**: An operator tree representing a given query “List the presidents of European countries that have never held the Olympics” ; **Right**: A query graph representing a given query “Find a pair of persons who are both colleagues and co-authors and were born in the same country, with one having awarded the fields medal while the another not”, which is both a multigraph and a cyclic graph, containing two free variables.

### The representation of query

To give an explicit representation of existential formula, operator tree  was proposed to represent a formula, where each node represents the answer set for a sub-query, and the logic operators in it naturally represent set operations. This method allows for the recursive computation from constant entity to the final answer set in a bottom-up manner . We also provide full details of the operator tree and tree-form query in Appendix C. However, this representation method is inherently directed, acyclic, and simple, therefore more recent research breaks these constraints by being bidirectional [21; 37] or being cyclic or multi graph . To meet these new requirements, they propose to represent the formula by the query graph , which inherits the convention of constraint network in representing CSP instance. We utilize this design and further extend it to represent EFO\({}_{k}\) formula that contains multiple free variables. We provide the illustration and comparison of the operator tree and the query graph in Figure 1, where we show the strong expressiveness of the query graph. We also provide the formal definition of query graph as follows:

**Definition 10** (Query graph).: _Let \(\) be a conjunctive formula in equation 2, its query graph is defined by \(G()=\{(h,r,t,)\})\), where an atomic formula \(r(h,t)\) in \(\) corresponds to \((h,r,t,)\) and \( r(h,t)\) corresponds to \((h,r,t,)\)._

Therefore, any conjunctive formulas can be represented by a query graph, in the rest of the paper, we use query graphs and conjunctive formulas interchangeably.

## 3 The combinatorial space of EFO\({}_{k}\) queries

Although previous research has given a systematic investigation in the combinatorial space of operator trees , the combinatorial space of the query graph is much more challenging due to the extremely large search space and the lack of explicit recursive formulation. To tackle this issue on a strong theoretical background, we put forward additional assumptions to exclude trivial query graphs. Such assumptions or restrictions also exist in the previous dataset and benchmark [28; 36]. Specifically, we propose to split the task of generating data into two levels, the abstract level, and the grounded level. At the abstract level, we create _abstract query graph_, at the grounded level, we provide the abstract query graph with the relation and constant and instantiate it as a query graph. In this section, we elaborate on how we investigate the scope of the nontrivial EFO\({}_{k}\) query of interest step by step.

### Nontrivial abstract query graph of EFO\({}_{k}\)

The abstract query graph is the ungrounded query graph without information of certain knowledge graphs, and we give an example in Figure 3.

**Definition 11** (Abstract query graph).: _The abstract query graph \(=(V,E,f,g)\) is a directed graph with three node types,\(\{\)**Constant Entity, Existential Variable, Free Variable\(\}\)**, and two edge types,\(\{\)**positive, negative\(\}\)**. The \(V\) is the set of nodes, \(E\) is the set of directed edges, \(f\) is the function maps node to node type, \(g\) is the function maps edge to edge type._

**Definition 12** (Grounding).: _For an abstract query graph \(\), a grounding is a function \(I\) that maps it into a query graph \(G=I()\)._

Figure 2: Left: Example of trivial abstract query graph, in the upper left graph, the \(x_{1}\) is redundant violating Assumption 13, in the bottom left graph, answers for the whole query can be decomposed to answer two free variables \(y_{1}\) and \(y_{2}\) alone, violating Assumption 14. Right: Example of new query graph that is not included in previous benchmark  even though it can be represented by operator-tree. The representation of query graph follows Figure 1.

We propose two assumptions of the abstract query graph as follows:

**Assumption 13** (No redundancy).: _For an abstract query graph \(\), there is not a subgraph \(_{s}\) such that for every grounding \(I\), \([I()]=[I(_{s})]\)._

**Assumption 14** (No decomposition).: _For an abstract query graph \(\), there are no such two subgraphs \(_{1}\), \(_{2}\), satisfying that \(_{1},_{2}\), such that for every instantiation \(I\), \([I()]=[I(_{1})][I (_{2})]\), where the \(\) represents the cartesian product._

The assumption 14 inherits the idea of the **structural** decomposition technique in CSP , which allows for solving a CSP instance by solving several sub-problems and combining the answer together based on topology property. Additionally, meeting these two assumptions in the grounded query graph is extremely computationally costly thus we avoid it in practice.

We provide some easy examples to be excluded for violating the assumptions above in Figure 2.

### Nontrivial query graph of \(_{k}\)

Similarly, we propose two assumptions on the query graph.

**Assumption 15** (Meaningful negation).: _For any negative edge \(e\) in query graph \(G\), we require removing it results in different CSP answers: \(}[G-e]}[G]\).3_

Assumption 15 treats negation separately because of the fact that for any \(\), any relation \(r\), there is \(|\{(h,t)|h,t,(h,r,t)\}|||^{2}\), which means that the constraint induced by the negation of an atomic formula is much less "strict" than the one induced by a positive atomic formula.

**Assumption 16** (Appropriate answer size).: _There is a constant \(M||\) to bound the candidate set for each free variable \(y_{i}\) in \(G\), such that for any \(i\), \(|\{a_{i}|(a_{1},,a_{i},,a_{k})[G]\}| M\)._

We note the Assumption 16 **extends** the "bounded negation" assumption in the previous dataset [28; 36]. We give an example "Find a city that is located in Europe and is the capital of a country that has not held the Olympics" in Figure 2, where the candidate set of \(x_{1}\) is in fact bounded by its relation with the \(y_{1}\) variable but not from the bottom "Olympics" constant, hence, this query is excluded in their dataset due to the directionality of operator tree.

Overall, the scope of the formula investigated in this paper surpasses the previous EFO-1-QA benchmark because of: (1). We include the \(_{k}\) formula with multiple free variables for the first time; (2). We include the whole family of \(_{1}\) query, many of them can not be represented by operator tree; (3) Our assumption is more systematic than previous ones as shown by the example in Figure 2. More details are offered in Appendix D.3.

## 4 Framework

We develop a versatile framework that supports five key functionalities fundamental to the whole CQA task: (1) Enumeration of nontrivial abstract query graphs as discussed in Section 3; (2) Sample grounding for the abstract query graph; (3) Compute answer for any query graph efficiently; (4) Support implementation of existing CQA models; (5) Conduct evaluation including newly introduced \(_{k}\) queries with multiple free variables. We explain each functionality in the following. An illustration of the first three functionalities is given in Figure 3, where we show how each functionality cooperates to help CQA tasks. We note that preprocessing allows us to extend our framework to more avant-garde settings, like inductive settings or graphs with numerics, more discussions in Appendix G.

### Enumerate abstract query graph

As discussed in Section 3, we are able to abide by those assumptions as well as **enumerate** all possible query graphs within a given search space where certain parameters, including the number 

### Ground abstract query graph

To ground an abstract query graph \(\) and comply with the assumption 15, we split the abstract query graph into two parts, the positive part and the negative part, \(=_{p}_{n}\). Then the grounding process is also split into two steps: 1. Sample grounding for the positive subgraph \(_{p}\) and compute its answer, 2. Ground the \(_{n}\) to decrease the answer got in the first step. Details in Appendix D.2.

Finally, to fulfill the assumption 16, we follow the previous practice of manually filtering out queries that have more than \(100 k\) answers [28; 36], as we have introduced the \(_{k}\) queries.

### Answer for existential formula

As illustrated in Section 2.2, the answer to an existential formula can be solved by a CSP solver, however, we also show in Definition 9 that solve it as CSP leads to huge computation costs. Thus, we develop our own algorithm following the standard solving technique of CSP, which ensures consistency conditions in the first step, and do the backtracking to get the final answers in the second step. Finally, we select part of our sampled queries and double-check it with the CSP solver https://github.com/python-constraint/python-constraint.

### Learning-based methods

As the query graph is an extension to the operator tree regarding the express ability to existential formulas, we are able to reproduce CQA models that are initially implemented by the operator tree in our new framework. Specifically, since the operator tree is directed and acyclic, we compute its topology ordering that allows for step-by-step computation in the query graph. This algorithm is illustrated in detail in the Appendix F. Therefore, our pipeline is backward compatible.

Conversely, for the newly proposed models that are based on query graphs, the original operator tree framework is not able to implement them, while our framework is powerful enough. We have therefore clearly shown that the query graph representation is more powerful than the previous operator tree and is able to support arbitrary existential formulas as explained in Section 2.3.

### Evaluation protocol

As we have mentioned in Section 2.1, there is an observed knowledge graph \(_{o}\) and a full knowledge graph \(\). Thus, there is a set of observed answers \(_{o}\) and a set of full answers \(\) correspondingly. Since the goal of CQA is to tackle the challenge of incompleteness, it has been a common practice to

Figure 3: Illustration of the all functionalities of our framework. Real-world KG is preprocessed and fed into our pipeline, which contains the whole process of data generation and supports end-to-end machine learning as well as evaluation. The origin of the KG picture is in Appendix I.

evaluate CQA models by the "hard" answers \(_{h}=-_{o}\). However, to the best of our knowledge, there has not been a systematic evaluation protocol for EFO\({}_{k}\) queries, thus we leverage this idea and propose three types of different metrics to fill the research gap in the area of evaluation of queries with multiple free variables, and thus have combinatorial answers.

**Marginal.** For any free variable \(y_{i}\), its full answer is \(^{y_{i}}=\{a_{i}|(a_{1},,a_{i},,a_{k}) \}\), the observed answer of it \(^{y_{i}}_{o}\) is defined similarly. This is termed "solution projection" in CSP theory  to evaluate whether the locally retrieved answer can be extended to an answer for the whole problem. Then, we rank the hard answer \(^{y_{i}}_{h}=^{y_{i}}-^{y_{i}4}_{o}\), against those non-answers \(-^{y_{i}}-^{y_{i}}_{o}\) and use the ranking to compute standard metrics like MRR, HIT@K for every free variable. Finally, the metric on the whole query graph is taken as the average of the metric on all free variables. We note that this metric is an extension of the previous design . However, this metric has the inherent drawback that it fails to evaluate the combinatorial answer by the \(k\)-length tuple and thus fails to find the correspondence among free variables.

**Multiply.** Because of the limitation of the marginal metric discussed above, we propose to evaluate the combinatorial answer by each \(k\)-length tuple \((a_{1},,a_{k})\) in the hard answer set \(_{h}\). Specifically, we rank each \(a_{i}\) in the corresponding node \(y_{i}\) the same as the marginal metric. Then, we propose the HIT@\(n^{k}\) metric, it is 1 if all \(a_{i}\) is ranked in the top \(n\) in the corresponding node \(y_{i}\), and 0 otherwise.

**Joint.** Finally, we note these metrics above are not the standard way of evaluation, which is based on a joint ranking for all the \(^{k}\) combinations of the entire search space. We propose to estimate the joint ranking in a closed form given certain assumptions, see Appendix E for the proof and details.

## 5 The EFO\({}_{k}\)-CQA dataset and benchmark results

### The EFO\({}_{k}\)-CQA dataset

With the help of our framework developed in Section 4, we develop a new dataset called EFO\({}_{k}\)-CQA, whose combinatorial space is parameterized by the number of constants, existential and free variables, and the number of edges. EFO\({}_{k}\)-CQA dataset includes 741 different abstract query graphs in total.

    &  &  &  &  &  &  &  \\    & & & SDAG & & & & & & \\   & 1 & 31.4 & 33.0 & 22.3 & 21.1 & 17.7 & 30.7 & 22.1 & \\  & 3 & 2 & 57.2 & 36.2 & 35.5 & 29.3 & 29.4 & 45.3 & 32.5 & \\  & 3 & 80.0 & 53.1 & 55.6 & 38.2 & 37.8 & 58.2 & 42.1 & 36.4 \\   & AVG(c) & 93.9 & 43.8 & 40.6 & 33.8 & 32.7 & 49.3 & & \\   & 1 & 34.4 & 34.9 & 23.0 & 21.4 & 17.4 & 30.3 & 22.4 & \\  & 2 & 60.0 & 38.4 & 36.8 & 29.8 & 29.3 & 45.3 & 33.0 & 36.7 \\  & 3 & 83.0 & 55.5 & 55.5 & 38.5 & 37.8 & 57.8 & 42.4 & \\   & AVG(c) & 62.2 & 46.0 & 42.0 & 34.2 & 32.6 & 49.1 & & \\   & 1 & 34.9 & 35.4 & 23.6 & 21.8 & 18.4 & 34.2 & 23.5 & \\  & 2 & 61.0 & 39.1 & 38.4 & 32.0 & 31.5 & 50.2 & 35.2 & \\  & 3 & 84.8 & 56.7 & 57.1 & 41.1 & 40.0 & 63.4 & 44.9 & 39.0 \\   & AVG(c) & 63.4 & 47.0 & 43.5 & 36.5 & 34.7 & 54.1 & & \\   & 1 & **39.0** & 34.2 & 17.6 & 17.4 & 12.7 & 28.7 & 18.7 & \\  & 2 & 50.7 & 33.8 & 33.6 & 28.4 & 28.4 & 45.7 & 31.4 & 35.9 \\  & 3 & 58.4 & 49.6 & 52.4 & 39.3 & 39.1 & 60.4 & 42.6 & 35.9 \\   & AVG(c) & 50.7 & 41.4 & 38.4 & 33.8 & 32.4 & 50.2 & & \\   & 1 & 38.6 & 37.8 & 21.8 & 22.9 & 17.8 & 31.7 & 23.2 & \\  & 2 & 62.2 & 40.2 & 35.0 & 30.8 & 28.1 & 44.4 & 32.5 & \\  & 3 & 86.6 & 36.9 & 51.9 & 38.3 & 35.3 & 55.8 & 40.8 & 35.8 \\   & AVG(c) & 65.4 & 47.8 & 39.6 & 34.5 & 30.8 & 48.0 & & \\   & 1 & 38.7 & **42.7** & **32.5** & **26.1** & **22.5** & **41.5** & **28.8** & \\  & 2 & **65.5** & **47.7** & **48.2** & **39.7** & **40.1** & **56.5** & **43.4** & **47.0** \\   & 3 & **84.2** & **43.9** & **43.5** & **50.5** & **50.4** & **63.5** & **53.6** & **47.0** \\    & AVG(c) & **65.8** & **54.7** & **51.5** & **44.9** & **43.7** & **57.5** & & \\   

Table 1: HIT@10 scores(%) for inferring queries with one free variable on FB15k-237. We denote \(e\), \(c\) as the number of existential variables, constant entities correspondingly. SDAG represents Simple Directed Acyclic Graph, Multi for multigraph, and Cyclic for cyclic graph. AVG.(\(c\)) and AVG.(\(e\)) is the average score of queries with the number of constant entities / existential variables fixed.

The parameters and the generation process, as well as its statistics, are detailed in Appendix D.4, where we also provide a dataset constructed in inductive settings. However, we mainly focus on transductive settings in the main paper since there are very few inductive models to benchmark.

We have made some adaptations to the implementation of CQA models, allowing them to infer \(_{k}\) queries, full detail in Appendix F. The experiment is conducted on a standard KG FB15k-237 , additional experiments on other standard KGs FB15k and NELL are presented in Appendix H.

### Benchmark results for \(k=1\)

Because of the great number of abstract query graphs, we follow previous work  to group query graphs by three factors: (1). the number of constant entities; (2). the number of existential variables, and (3). the topology of the query graph5. The result is shown in Table 1 and Figure 4.

**Structure analysis.** Firstly, we find a clear monotonic trend that adding constant entities makes a query easier while adding existing variables makes a query harder, which the previous research  fails to uncover. Besides, we are the first to consider the topology of query graphs: when the number of constants and existential variables is fixed, we have found the originally investigated queries that correspond to Simple Directed Acyclic Graphs (SDAG) are generally easier than the multigraphs ones but harder than the cyclic graph ones. This is an intriguing result that greatly deviates from traditional CSP theory which finds that the cyclic graph is NP-complete, while the acyclic graph is tractable . We conjecture that the cyclic graph contains one more constraint than SDAG that serves as a source of information for CQA models, while the multigraph tightens an existing constraint and thus makes the query harder.

**Model analysis.** For models that are built on operator tree, including BetaE, LogicE, and ConE, their relative performance is steady among all breakdowns and is consistent with their reported score in the original dataset .However, for models that are built on query graphs, including CQD, LMPNN, and FIT, we found that LMPNN performs generally better than CQD in SDAG, but falls behind CQD in multigraphs and cyclic graphs. We assume the reason is that LMPNN requires training while CQD does not, however, the original dataset are **biased** which only considers SDAG, leading to the result

Figure 4: Relative performance of the six representative CQA models in queries with one free variable, where the ranking of query types is determined by the average HIT@10 score. A Gaussian filter with sigma=1 is added to smooth the curve.

that LMPNN doesn't generalize well to the unseen tasks with different topology property. We expect future CQA models may use our framework to address this issue and gain better generalization.

Moreover, by the detailed observation in Figure 4, we plot two boxes. In the red box, we find that even the worst model and the best model have pretty similar performance in these easiest queries despite that they may differ greatly in other queries. In the black box, we note that CQD , though designed in a rather general form, is pretty unstable when comes to empirical evaluation, as it has a clear downward curve and deviates from other model's performance enormously in most difficult query types. Therefore, though its performance is better than LMPNN on average as reported in Table 1, its unsteady performance suggests its inherent weakness, especially when the users are risk-sensitive and desire a trustworthy machine-learning model that does not crash in extreme cases .

We note FIT is designed to infer all EFO\({}_{1}\) queries and is indeed able to outperform other models in almost all breakdowns, however, its performance comes with the price of computational cost, and face challenges in cyclic graph where it degenerates to enumeration: we further explain in Appendix F.

### Benchmark results for \(k=2\)

As we have explained in Section 4.5, we propose three kinds of metrics, marginal ones, multiply ones, and joint ones, from easy to hard, to evaluate the performance of a model in the scenario of multiple variables. The evaluation result is shown in Table 2. As the effect of the number of constant variables is quite clear, we remove it and add the metrics based on HIT\(@10\) as the new factor.

For the impact regarding the number of existential variables and the topology property of the query graph, we find the result is similar to Table 1, which may be explained by the fact that those models are all initially designed to infer queries with one free variable. For the three metrics we have proposed, we have identified a clear difficulty difference among them though they generally show similar trends. The scores of joint HIT@10 are pretty low, indicating the great hardness of answering queries with multiple variables. Moreover, we have found that FIT falls behind other models in some breakdowns which are mostly cyclic graphs, corroborating our discussion in Section 5.2. We offer more experiment results and further discussion in Appendix H.

## 6 Conclusion

In this paper, we make a thorough investigation of the family of EFO\({}_{k}\) formulas based on a strong theoretical background. We then present a new powerful framework that supports several functionalities essential to CQA task, and build the EFO\({}_{k}\)-CQA dataset that greatly extends the previous datasets. Our evaluation result brings new empirical findings and reflects the biased selection in the previous dataset impairs the performance of CQA models, emphasizing the contribution of our work.

    & HIT@10 & \(e=0\) &  &  &  \\  & Type & & SDMG & Multi & SDMG & Multi & Cyclic & SDMG & Multi & Cyclic & \\   & Marginal & 54.5 & 50.2 & 49.5 & 46.0 & 58.8 & 37.2 & 35.5 & 58.3 & 43.8 \\  & Multi & 27.3 & 22.4 & 22.3 & 16.9 & 26.2 & 16.9 & 13.9 & 25.7 & 18.3 \\  & Joint & 6.3 & 5.4 & 5.2 & 4.2 & 10.8 & 2.2 & 2.3 & 9.5 & 4.5 \\   & Marginal & 58.2 & 50.9 & 52.2 & 47.4 & 60.4 & 37.7 & 35.8 & 59.2 & 44.6 \\  & Multiply & 32.1 & 23.1 & 24.9 & 18.1 & 28.3 & 18.1 & 14.8 & 26.6 & 19.5 \\  & Joint & 6.8 & 6.0 & 6.1 & 4.5 & 12.3 & 2.5 & 2.7 & 10.3 & 5.1 \\   & Marginal & 60.3 & 53.8 & 54.2 & 50.3 & **66.2** & 40.1 & 38.5 & **63.7** & 47.7 \\  & Multiply & 33.7 & 25.2 & 26.1 & 19.8 & 32.1 & 19.5 & 16.3 & 30.3 & 21.5 \\  & Joint & 6.7 & 6.4 & 6.2 & 4.8 & 12.6 & 2.6 & 2.7 & 10.9 & 5.3 \\   & Marginal & 50.4 & 46.5 & 49.1 & 45.6 & 59.7 & 33.5 & 33.1 & 61.5 & 42.8 \\  & Multiply & 28.9 & 23.4 & 25.4 & 19.5 & 31.3 & 17.8 & 16.0 & 30.5 & 21.0 \\  & Joint & **8.0** & 8.0 & 7.4 & 6.0 & **13.9** & 36.0 & 39.8 & **12.0** & **6.4** \\   & Marginal & 58.4 & 51.1 & 54.9 & 49.2 & 64.7 & 39.6 & 36.1 & 58.7 & 45.4 \\  & Multiply & 35.0 & 26.7 & 29.2 & 21.7 & **33.4** & 21.4 & 17.0 & 28.4 & 22.2 \\  & Joint & 7.6 & 7.5 & 7.1 & 5.3 & 12.9 & 2.8 & 2.9 & 9.5 & 5.2 \\   & Marginal & **64.3** & **61.0** & **63.1** & **60.7** & 58.5 & **49.0** & **49.1** & 60.2 & **54.3** \\  & Multiply & **39.7** & **32.2** & **35.9** & **27.8** & 27.4 & **29.5** & **26.8** & **32.4** & **29.2** \\   & Joint & 7.4 & **9.0** & **7.8** & **6.5** & 10.1 & **3.7** & **4.6** & 10.6 & **6.4** \\   

Table 2: HIT@10 scores(%) of three different types for answering queries with two free variables on FB15k-237. The constant number is fixed to be two. \(e\) is the number of existential variables. The SDAG, Multi, and Cyclic are the same as Table 1.