# Imbalanced Mixed Linear Regression

Pini Zilber Boaz Nadler

Faculty of Mathematics and Computer Science

Weizmann Institute of Science, Israel

{pini.zilber, boaz.nadler}@weizmann.ac.il

###### Abstract

We consider the problem of mixed linear regression (MLR), where each observed sample belongs to one of \(K\) unknown linear models. In practical applications, the mixture of the \(K\) models may be imbalanced with a significantly different number of samples from each model. Unfortunately, most MLR methods do not perform well in such settings. Motivated by this practical challenge, in this work we propose Mix-IRLS, a novel, simple and fast algorithm for MLR with excellent performance on both balanced and imbalanced mixtures. In contrast to popular approaches that recover the \(K\) models simultaneously, Mix-IRLS does it sequentially using tools from robust regression. Empirically, beyond imbalanced mixtures, Mix-IRLS succeeds in a broad range of additional settings where other methods fail, including small sample sizes, presence of outliers, and an unknown number of models \(K\). Furthermore, Mix-IRLS outperforms competing methods on several real-world datasets, in some cases by a large margin. We complement our empirical results by deriving a recovery guarantee for Mix-IRLS, which highlights its advantage on imbalanced mixtures.

## 1 Introduction

In this paper, we consider a simple generalization of the linear regression problem, known as mixed linear regression (MLR) [5, Chapter 14]. In MLR, each sample belongs to one of \(K\) unknown linear models, but it is not known to which one. MLR can thus be viewed as a combination of regression and clustering. Despite its simplicity, the presence of multiple linear components makes MLR highly expressive and thus a useful data representation model in various applications, including trajectory clustering , health care analysis , market segmentation , face recognition , population clustering , drug sensitivity prediction  and relating genes to disease phenotypes [8; 47].

Several methods were developed to solve MLR, including expectation maximization [15; 5], alternating minimization [52; 53] and gradient descent . These methods share three common features: they all (i) require as input the number of components \(K\); (ii) estimate the \(K\) models simultaneously; and (iii) tend to perform better on balanced mixtures, where the number of samples from each of the \(K\) models are approximately equal. As illustrated in Section 4, given data from an imbalanced mixture, these methods may fail. In addition, most of the theoretical guarantees in the literature assume a balanced mixture. Since imbalanced mixtures are ubiquitous in applications, it is of practical interest to develop MLR methods that are able to handle such settings, as well as corresponding recovery guarantees.

In this paper, we present Mix-IRLS, a novel and conceptually different iterative algorithm for MLR, able to handle both balanced and imbalanced mixtures. Mix-IRLS is computationally efficient, simple to implement, and scalable to high-dimensional settings. In addition, Mix-IRLS successfully recovers the underlying components with relatively few samples, is robust to noise and outliers, and does not require as input the number of components \(K\). In Sections 4 and 5 we illustrate the competitive advantage of Mix-IRLS over several other methods, on both synthetic and real data.

To motivate our approach, let us consider a highly imbalanced mixture, where most samples belong to one model. In this case, the samples that belong to the other models may be regarded as _outliers_ with respect to the dominant one. The problem of finding the dominant model may thus be viewed as a specific case of robust linear regression, a problem for which there exist several effective algorithms, see e.g. [27; 50]. After finding the dominant model, we remove its associated samples from the observation set and repeat the process to find the next dominant model. This way, the \(K\) linear models are found _sequentially_ rather than simultaneously as in the aforementioned methods.

For our Mix-IRLS sequential approach to succeed, we found it important to allow in its intermediate rounds an "I don't know" assignment to some of the samples. Specifically, given an estimate of the dominant model, we partition the samples to three classes, according to their fit to the estimated model: good, moderate and poor fit; see Figure 1. The samples with good fit are used to re-estimate the model coefficients; those with poor fit are assumed to belong to a yet undiscovered model, and hence are passed to the next round; the moderate fit samples, on whose model identity we have only low confidence ("I don't know"), are ignored, but used later in a refinement phase.

To recover the dominant model at each of the \(K\) rounds, we perform robust regression using iteratively reweighted least squares (IRLS) [24; 10; 40]. IRLS iteratively solves weighted least squares subproblems, where the weight of each sample depends on its residual with respect to the current model estimate. As the iterations proceed, outliers are hopefully assigned smaller and smaller weights, and ultimately ignored; see Figure F.1 for an illustration of this mechanism.

On the theoretical front, in Section 6 we present a recovery guarantee for our method. Specifically, we show that in a population setting with an imbalanced mixture of two components, Mix-IRLS successfully recovers the linear models. A key novelty in our result is that it holds for a sufficiently imbalanced mixture rather than a sufficiently balanced one (or even a perfectly balanced one) as is common in the literature [52; 2; 35]. In addition, unlike most available guarantees, our guarantee allows an unknown \(K\), and it is insensitive to the initialization, allowing it to be arbitrary.

To the best of our knowledge, our work is the first to specifically handle imbalance in the MLR problem, providing both a practical algorithm as well as a theoretical recovery guarantee. Furthermore, we are the first to propose and analyze an adaptation of IRLS to the MLR problem. A related sequential approach to solve MLR using robust regression was proposed by . They used random sample consensus (RANSAC) instead of IRLS, and without our "I don't know" concept. To find a component,  randomly pick \((d+2)\) samples from the data and run ordinary least squares (OLS) on them, in hope that they all belong to the same component. As discussed by the authors of , their approach is feasible only in low dimensional settings, as the probability that all \(d+2\) chosen samples belong to the same component decreases exponentially with the dimension \(d\); specifically,  considered only \(d 5\). In addition,  did not provide a theoretical guarantee for their method. In contrast, our Mix-IRLS method is scalable to high dimensions, and enjoys a theoretical guarantee.

**Notation.** For a positive integer \(K\), denote \([K]=\{1,,K\}\), and the set of all permutations over \([K]\) by \([K]!\). For a vector \(u\), denote its Euclidean norm by \(\|u\|\). For a matrix \(X\), denote its spectral

Figure 1: Illustration of Mix-IRLS. The data is a mixture of \(K=3\) components. At each round, Mix-IRLS excludes samples with poor and moderate fit (marked by ’X’ and ’?’, respectively), and performs linear regression on the good fit samples. The poor fit samples are passed to the next round.

norm by \(\|X\|\) and its smallest singular value by \(_{}(X)\). Given a matrix \(X^{n d}\) and an index set \(S[n]\), \(X_{S}^{|S| d}\) is the submatrix of \(X\) that corresponds to the rows in \(S\). Denote by \((w)\) the diagonal matrix \(W\) whose entries are \(W_{ii}=w_{i}\). The probability of an event \(A\) is \([A]\). Denote the expectation and the variance of a random variable \(x\) by \([x]\) and \([x]\), respectively. The cumulative distribution function of the standard normal distribution \((0,1)\) is \(()\).

## 2 Problem Setup

Let \(\{(x_{i},y_{i})\}_{i=1}^{n}\) be \(n\) pairs of explanatory variables \(x_{i}^{d}\) and corresponding responses \(y_{i}\). In standard linear regression, one assumes a linear relation between the response and the explanatory variables, namely \(y_{i}=x_{i}^{}^{*}+_{i}\) where \(_{i}\) are random noise terms with zero mean. A common goal is to estimate the coefficient vector \(^{*}^{d}\). In mixed linear regression (MLR), in contrast, the assumption is that each response \(y_{i}\) belongs to one of \(K\) different linear models \(\{_{k}^{*}\}_{k=1}^{K}\). Formally,

\[y_{i}=x_{i}^{}_{c_{i}^{*}}^{*}+_{i}, i=1,,n,\] (1)

where \(c^{*}=(c_{1}^{*},,c_{n}^{*})^{}[K]^{n}\) is the label vector. Importantly, we do not know to which component each pair \((x_{i},y_{i})\) belongs, namely \(c^{*}\) is unknown. For simplicity, we assume the number of components \(K\) is known, and later on discuss the case where it is unknown. Given the \(n\) samples \(\{(x_{i},y_{i})\}_{i=1}^{n}\), the goal is to estimate \(^{*}\{_{1}^{*},,_{K}^{*}\}^{d}\), possibly by estimating also \(c^{*}\). See Figure 4(left) for a real-data visualization of MLR in the simplest setting of \(d=1\) and \(K=2\).

For the \(K\) regression vectors \(^{*}\) to be identifiable, sufficiently many samples from each component must be observed. The minimal total number of samples depends on the dimension and the mixture proportions. Denote the vector of mixture proportions by \(p=(p_{1},,p_{K})\), with \(p_{k}=|\{i[n]:c_{i}^{*}=k\}|/n\). Then the information limit on the sample size, namely the minimal number of observations \(n\) required to recover \(^{*}\) in the absence of noise, is \(n_{}=d/(p)\). As formally proven in Appendix B, no method can recover all \(K\) models given fewer samples.

The lack of knowledge of the labels \(c^{*}\) makes MLR significantly more challenging than standard linear regression. Even in the simplified setting of \(K=2\) with perfect balance (\(p_{1}=p_{2}=1/2\)) and no noise (\(=0\)), the problem is in general NP-hard . However, as detailed in Section 6, various assumptions render the problem computationally tractable, and enable to derive theoretical guarantees.

The Mix-IRLS Method

For simplicity, we present our algorithm assuming \(K\) is known; the case of an unknown \(K\) is discussed in Remark 3.3. Mix-IRLS consists of two phases. In its first (main) phase, Mix-IRLS recursively recovers each of the \(K\) components \(_{1}^{*},,_{K}^{*}\) by treating the remaining components as outliers. The sequential recovery is the core idea that distinguishes Mix-IRLS from most other methods. In the second phase, we refine the estimates of the first phase by optimizing them simultaneously, similar to existing methods. As discussed below, in many cases accurate estimates are already found in the first phase, in which case the second phase is not necessary. For brevity, we defer the description of the second phase to Appendix C.

Before we dive into details, let us give a brief overview of the main phase mechanism. At each round of this phase, Mix-IRLS uses techniques from robust regression to estimate the largest component present in the data. Then, it partitions the samples to three subsets, according to their fit to the found component: good, moderate and poor. Mix-IRLS refines the component estimate using only the samples with good fit, and proceeds to the next round with the poor fit samples. The moderate fit samples are ignored in the main phase, as we have high uncertainty in their component assignment - they either may or may not belong to the found component. As detailed below Mix-IRLS depends on four parameters: a model fit threshold \(w_{}(0,1)\), an oversampling ration \( 1\), a tuning parameter \(\) and the number of IRLS iterations \(T_{1} 1\).

Importantly, the robust regression used by Mix-IRLS succeeds even if the dominant component consists less than 50% of the data. The well-known "breakdown point" of robust regression at 50% assumes nothing on the data samples, and in particular allows for adversarial outliers. In our case, the 'outliers', namely the samples that belong to a yet undiscovered component, follow an MLR model. As such, standard high-dimensional robust regression methods can recover the underlying linear model even with 70% and 80% outliers; see Appendix H for an empirical illustration.

Next, we present in details the main phase of Mix-IRLS. A pseudocode appears in Algorithm 1. Given \(X=(x_{1} x_{n})^{}\) and \(y=(y_{1} y_{n})^{}\), we initialize the set of active samples to the entire dataset, \(S_{1}=[n]\). Next, we perform the following procedure for \(K\) rounds. At round \(k[K]\), starting from a random guess \(_{k}\) for the \(k\)-th vector, we run \(T_{1}\) iterations of IRLS :

\[r_{i,k} =|x_{i}^{}_{k}-y_{i}|,\, i S_{k}, \] (2a) \[w_{i,k} =^{2}/_{k}^{2}},\, i S _{k}, \] (2b) \[_{k} =(X_{S_{k}}^{}W_{k}X_{S_{k}})^{-1}X_{S_{k}}^{}W_{k}\,y_{ S_{k}}, \] (2c)

where \(_{k}=\{r_{i,k} i S_{k}\}\), and \(W_{k}=(w_{1,k},w_{2,k},)\). The updated estimate (2c) is the minimizer of the weighted least squares objective \(\|W^{}(y_{S_{k}}-X_{S_{k}}_{k})\|^{2}\). Intuitively, if \(_{k}\) is close to some \(_{i}^{*}\), then samples from other components receive a lower weight and the updated \(_{k}\) is even closer to \(_{i}^{*}\). After \(T_{1}\) iterations of (2a)-(2c), we define the subset \(S_{k+1}\) of 'poor fit' samples that seem to belong to other components,

\[S_{k+1}=\{i S_{k}:w_{i,k} w_{}\}.\] (3)

This serves as the set of active samples for the next round. In addition, for some \( 1\) whose choice is discussed below, we define the subset \(S_{k}^{}\) of samples with a 'good fit' to the \(k\)-th component,

\[S_{k}^{}=\{ dS_{k}w_{i,k}\}.\] (4)

We then refine the estimate of \(_{k}\) by performing OLS on this subset,

\[_{k}^{}=(X_{S_{k}^{}}^{}X_{S_{k}^{}})^{-1}X _{S_{k}^{}}^{}y_{S_{k}^{}}.\] (5)

The subsets \(S_{k}^{}\) and \(S_{k+1}\) are in general disjoint, unless the threshold \(w_{}\) or the oversampling ratio \(\) are too high. The choice for the value of \(w_{}\) is discussed in Remark 3.1 and Section 6. A suitable value for \(\) depends on the ratio between the sample size \(n\) and the information limit \(n_{}=d/(p)\). In the challenging setting of \(n n_{}\), \(\) should be set close to \(1\), confining the algorithm to use the least possible number of samples at each round. If \(n n_{}\), then \(\) can be set to a higher value, allowing the algorithm to estimate each component more accurately and more robustly to noise by using more samples.

This concludes the main phase of Mix-IRLS. The second (refinement) phase, described in Appendix C, improves the estimates \(_{k}^{}\) using also the moderate fit samples that were ignored in the first phase. Yet, empirically in many cases the second phase is not needed, since the main phase already outputs highly accurate estimates of \(^{*}\). This is in accordance with the theoretical result in Section 6.

_Remark 3.1_ (Threshold adaptation).: If the threshold \(w_{}\) is too small, the number of poor fit samples \(|S_{k+1}|\) of (3) may be insufficient to estimate the (\(k+1\))-th component. To avoid the tuning of \(w_{}\), we use the following scheme: Mix-IRLS gets as input an initial value for \(w_{}\), and if needed, it increases its value and starts over; see Lines 11 to 13 in Algorithm 1. The value \(0.1\) is heuristic, and a more theoretically grounded update rule is an open question for future research.

_Remark 3.2_ (Parameter tuning).: Mix-IRLS has four input parameters: \(,,T_{1}\) and an initial value for \(w_{}\) (see Remark 3.1). As empirically demonstrated in Sections 4 and 5, there is no need to carefully tune these parameters; see Appendix F for an explanation of this point. The values used in our experiments are specified in Appendix G.

_Remark 3.3_ (Unknown/overestimated \(K\)).: If \(K\) is unknown, or only an upper bound \(K_{}\) is given, Mix-IRLS can automatically find the true \(K\) without cross validation. To find it, we ignore the resetting criterion (Lines 11 to 13 in Algorithm 1), and instead run Mix-IRLS until there are too few samples to estimate the next component, namely \(|S_{k+1}|< d\). We then set \(K\) to the number of components with at least \( d\) associated samples, and proceed to the second phase.

## 4 Simulation Results

We present simulation results on synthetic data in this section, and on several real-world datasets in the next one. We compare the performance of Mix-IRLS to the following algorithms: (i) AltMin - alternating minimization [52; 53]; (ii) EM - expectation maximization [5; Chapter 14], ; and (iii) GD - gradient descent on a factorized objective . We implemented all methods in MATLAB.1 In some of the simulations, we additionally ran a version of EM for which the mixture proportions \(p\) are given as prior knowledge, but it hardly improved its performance and we did not include it in our results. In addition, we plot the performance of an oracle which is provided with the vector \(c^{*}\) of the true labels of all \(n\) samples and separately computes the OLS solution for each component.

All methods were given the same random initialization, as described shortly. Other initializations did not qualitatively change the results. For EM and GD we added an AltMin refinement step at the end of each algorithm to improve their estimates. In principle, Mix-IRLS has several tuning parameters. However, Mix-IRLS performs well with a fixed set of values (see Remark 3.2). Hence, in the following, we show the results for a tuning-free variant of our method. Further technical details, including maximal number of iterations, early stopping criteria and parameter tuning of GD appear in Appendix G.

Similar to [56; 21], in each simulation we sampled the entries of the explanatory variables \(X\) and of the regression vectors \(^{*}\) from the standard normal distribution \((0,1)\). In this section, the dimension is fixed at \(d=300\). The additive noise terms are Gaussian, \(_{i}(0,^{2})\). Additional simulations with other values of \(d\) and \(\), including different noise levels for the \(K\) components (i.e.,

Figure 2: Comparison of various MLR algorithms. Depicted is the failure rate, out of 50 random initializations, for which \(F_{}>2\) (see (6)), as a function of the sample size \(n\). The dimension and noise level are fixed at \(d=300\) and \(=10^{-2}\). Mixture: \(K=3\) with \(p=(0.7,0.2,0.1)\) (left panel); \(K=5\) with \(p=(0.63,0.2,0.1,0.05,0.02)\) (right panel).

different \(_{1},,_{K}\)), as well as simulations with different separation levels between the components, appear in Appendix H. As discussed in the introduction, a central motivation for the development of Mix-IRLS is dealing with imbalanced mixtures. Hence, in this section, the labels \(c_{i}^{*}\) were drawn from a multinomial distribution with highly imbalanced proportions. In Appendix H, we present results for balanced and moderately imbalanced mixtures.

We measure the accuracy of an estimate \(\{_{1},,_{K}\}\) by the following quantity:

\[F_{}(;^{*})=_{[K]^{}}_{k=1, ,K}\|_{(k)}-_{k}^{*}\|.\] (6)

The minimization above is over all \(K!\) permutations, which makes the accuracy measure invariant to the order of the regression vectors in \(\). A similar objective was used by .

All algorithms were initialized with the same random vectors \(_{1},,_{K}\), whose entries were sampled from the standard normal distribution \((0,1)\). For each simulation, we performed 50 independent realizations, each with a different random initialization \(\), and report the median errors and the failure probability. The latter quantity is defined as the percentage of runs whose error \(F_{}\) (6) is above \(2\); see an explanation for this choice in Appendix G. Due to space limits, some figures appear in Appendix H.

In the first simulation, we examine the performance of the algorithms as a function of the sample size \(n\). The results are depicted in Figure 2, and the corresponding runtimes in Figure H.3. Mix-IRLS is shown to recover the components with sample size very close to the oracle's minimum. All competing methods, in contrast, get stuck in bad local minima unless the sample size is much larger. Importantly, this behavior does not follow from the presence of noise, and as shown in Appendix H, the result does not qualitatively change in a noiseless setting. Moreover, as shown in Figure H.8, the nearly optimal performance of Mix-IRLS seems to be independent of the dimension \(d\). It does depend, however, on the mixture proportions: for a moderately imbalanced mixture, Mix-IRLS does not match the oracle performance. Yet, even in this case, Mix-IRLS still markedly outperforms the other methods; see Figure H.6.

Next, we explore the robustness of the algorithms to additive noise, outliers and overestimation. Figure H.10 shows that all algorithms are stable to additive noise of various levels, but only Mix-IRLS matches the oracle performance in all runs. To study robustness to outliers, in the following simulation we artificially corrupt a fraction \(f(0,1)\) of the observations. A corrupted response \(_{i}\) is sampled from a normal distribution with zero mean and variance \(_{j=1}^{n}y_{j}^{2}/n\), independently of the original value \(y_{i}\). Figure 3(left) shows the error (6) of the algorithms as a function of the corruption fraction \(f\). To let the algorithms cope with outliers while keeping the comparison fair, we made the _same_ modification in all of them: at each iteration, the estimate \(\) is calculated based on the \((1-f)n\) samples with smallest residuals. In Mix-IRLS, we implemented this modification only in the second phase. As shown in the figure, empirically, Mix-IRLS can deal with a corruption fraction of \(f=9\%\), which is over \(4\) times more corrupted samples than the other algorithms. In the balanced setting, Mix-IRLS can deal with roughly twice as many corrupted samples (\(f=17\%\)), which is almost 6 times more outliers than other methods. These results should not be surprising in light of the fact that robust regression is at the heart of Mix-IRLS's mechanism.

Figure 3: Robustness of several MLR algorithms to outliers (left panel) and the overparameterization (right panel). Values of \(d,,K\) and \(p\) are the same as in Figure 2(left), and \(n=12000\). Qualitatively similar results for a balanced mixture appear in Figures H.15 and H.16. X-axis on left panel is fraction of outliers; X-axis on right panel is the difference between the number of components \(K\) given to the algorithms and the true \(K^{*}\).

The last simulation considered the case of an unknown number of components. Specifically, the various algorithms were given as input a number of components \(K K^{*}\) where \(K^{*}\) is the true number of mixture components in the data. Here, the error is defined similar to (6), but with \(K^{*}\) instead of \(K\). Namely, the error is calculated based on the best \(K^{*}\) vectors in \(\), ignoring its other \(K-K^{*}\) vectors. Figure 3(right) shows that most algorithms have similar performance at the correct parameter value \(K=K^{*}\), and EM succeeds also at small overparameterization, \(K-K^{*} 3\). Only Mix-IRLS is insensitive to overparameterization, and succeeds with unbounded \(K\). This feature is attained thanks to the sequential nature of Mix-IRLS (Remark 3.3). Similar results hold for balanced mixtures; see Appendix H.

## 5 Real-World Datasets

We begin by analyzing the classical music perception dataset of Cohen . In her thesis, Cohen investigated the human perception of tones by using newly available electronic equipment. The \(n=150\) data points acquired in her experiment are shown in Figure 4(left). Cohen discussed two music perception theories: One theory predicted that in this experimental setting, the perceived tone (y-axis) would be fixed at \(2.0\), while the other theory predicted an identity function (\(y=x\)). The results, depicted in Figure 4(left), support both theories. As a mathematical formulation of this finding, Cohen proposed the MLR model (1) with \(K=2\), where the labels \(c^{*}\) are i.i.d. according to a Bernoulli distribution; see also .

In Figure 4(left), the untuned version of Mix-IRLS is shown to capture the two linear trends in the data. Notably, untuned Mix-IRLS was not given the number of components, but automatically stopped at \(K=2\) with its default parameters. By increasing the sensitivity of Mix-IRLS to new components via the parameter \(w_{}\), it is possible to find three or even more components; see Figure I.19.

Next, we compare the performance of Mix-IRLS to the algorithms listed in the previous section on a more challenging problem: the CO2 emission by vehicles in Canada dataset, available on Kaggle (see Appendix G). This dataset approximately follows an MLR model, where the samples can be clustered into components according to their fuel type: regular gasoline, premium gasoline, diesel or ethanol (\(K=4\)). The mixture is imbalanced, with the proportions \(p=(0.49,0.43,0.05,0.03)\). We ask the following question: given the engine features (engine size, number of cylinders, fuel consumption in city and highway), how close are the methods' clusters to the (ground-truth) fuel type clusters?

We measure the performance of the methods with class-wise balanced accuracy, defined as the average of sensitivity/recall and specificity. We chose this measure as it is considered suitable for imbalanced mixtures, but other measures yield qualitatively similar results. As clustering is defined only up to permutation, for each method we choose the permutation that maximizes the overall intersection of its estimated clusters with the true ones, defined as

\[_{[K]]}|\{i[n]:(c_{i})=c_{i}^{*}\}|.\] (7)

The results, reported in Table 1, demonstrate the effectiveness of Mix-IRLS on imbalanced mixtures. While on the dominant class (regular gasoline) all methods achieve comparable balanced accuracy,

Figure 4: Left panel: Mix-IRLS estimate for the music perception data , where \(d=1\) and \(n=150\). Right panel: Comparison of several MLR algorithms on the medical insurance dataset. Note that the y-axis is on a log scale. Median estimation errors are calculated across 50 random initializations according to (8), and error bars correspond to the median absolute deviation.

Mix-IRLS significantly outperforms the other methods on the remaining classes. EM is the only method that is slightly better than Mix-IRLS on one of the rare classes, but achieves markedly worse balanced accuracy on the other two rare classes. Moreover, importantly, Mix-IRLS is the only method that is stable with respect to the initialization, demonstrating negligible variance across different random initializations.

Finally, we compare the performance of the algorithms on four of the most popular benchmark datasets for linear regression, all of which are available on Kaggle (see Appendix G): medical insurance cost, red wine quality, World Health Organization (WHO) life expectancy, and fish market. The task in each dataset is to predict, respectively: medical insurance cost from demographic details; wine quality from its psychochemical properties; life expectancy from demographic and medical details; and fish weight from its dimensions. For these datasets, MLR is at best an approximate model, and its regression vectors \(^{*}\) are unknown. Hence, we replace (6) by the following quality measure which represents the fit of an MLR model to the data:

\[F_{}(;X,y)=[y]}_{i=1}^{ n}_{j[K]}(x_{i}^{}_{j}-y_{i})^{2},\] (8)

resembling the K-means objective for clustering . To illustrate the advantage of a multi-component model, we also report the results of an ordinary least squares (OLS) solution. In this section, besides vanilla Mix-IRLS we report the results of a tuned variant, denoted Mix-IRLS:tuned. The tuning is done using only the observed objective (8), and no oracle is involved in the procedure.

As the number of components \(K\) is unknown, we explore the algorithms' performance given different values of \(K\), ranging from 2 to 7. The upper limit 7 was chosen arbitrarily, and the results do not change qualitatively for larger values. All algorithms start from the same random initialization. Additional details appear in Appendix G.

Figure 4(right) shows the performance of the algorithms on the medical insurance dataset in terms of the median error (8) across 50 different random initializations. The results for the other three datasets, as well as the minimal errors achieved across the realizations, are deferred to Appendix I. In general, both Mix-IRLS and Mix-IRLS:tuned improve upon the other methods, sometimes by 30% or more.

The experiments on the Kaggle datasets demonstrate that empirically Mix-IRLS finds MLR coefficients that fit the data significantly better than other methods. Hence, given as input data that (approximately) does follow an MLR model for some \(K\), our method would often compute accurate estimates of its corresponding mixture coefficients where other methods would fail to do so.

## 6 Recovery Guarantee for Mix-IRLS

In this section, we theoretically analyze Mix-IRLS in a population setting with an infinite number of samples. For simplicity, we assume the explanatory variables are normally distributed. Without loss of generality, we assume zero mean and identity covariance,

\[x_{i}(0,I_{d}).\] (9)

In the more general case where \(x_{i}(,)\) for some \(\) and \(\), one may find \(\) and \(\) from the data, and mean center and whiten the samples \(x_{i}^{-1/2}(x_{i}-)\), before applying our method. The responses \(y_{i}\) are assumed to follow model (1) with \(K=2\) components \((_{1}^{*},_{2}^{*})\) and labels

   Balanced accuracy & Mix-IRLS & AltMin & EM & GD \\  regular gasoline (49\%) & \(\) & \(\) & \(\) & \(\) \\  premium gasoline (43\%) & \(\) & \(0.48 0.10\) & \(0.48 0.01\) & \(0.40 0.03\) \\  diesel (5\%) & \(\) & \(\) & \(0.54 0.07\) & \(0.70 0.12\) \\  ethanol (3\%) & \(\) & \(0.63 0.07\) & \(\) & \(0.61 0.05\) \\   

Table 1: Results of MLR algorithms on the CO2 emission from vehicles dataset. Reported are median balanced accuracy and median absolute deviation based on 50 random initializations.

generated independently of \(x_{i}\) according to mixture proportions \(p_{1} p_{2}>0\). This setting was considered in several previous theoretical works that analyzed the EM method for MLR .

We assume the noise terms \(_{i}\) are all i.i.d., zero-mean random variables, independent of \(x_{i}\) and \(c_{i}^{*}\). We further assume they are bounded and follow a symmetric distribution,

\[|_{i}|_{}[_{i}  t]=[_{i}-t] t.\] (10)

For analysis purposes, we consider a slightly modified variant of Mix-IRLS, formally described in Appendix E. In this variant, Mix-IRLS excludes samples \(x_{i}\) with large magnitude, \(\|x_{i}\|^{2}>R\) where \(R\) is a fixed parameter. A natural choice for its value is \(R[\|x_{i}\|^{2}]=d\), e.g. \(R=2d\). In a high-dimensional setting with \(d 1\), such a choice excludes a proportion of the samples that is exponentially small in \(d\). For simplicity, we present our result assuming \(R\) is large, corresponding to large dimension \(d\); the general result appears in Lemma E.1.

The following theorem states that given a sufficiently imbalanced mixture, namely \(p_{1}\) is large enough, Mix-IRLS successfully recovers the underlying vectors \(_{1}^{*}\) and \(_{2}^{*}\).

**Theorem 6.1**.: _Let \(\{(x_{i},y_{i})\}_{i=1}^{}\) be i.i.d. from a mixture of \(K=2\) components with proportions \((p_{1},p_{2})\), regression vectors \((_{1}^{*},_{2}^{*})\), and noise terms \(_{i}\) that follow (10) with \(_{}\). Denote \(=_{1}^{*}-_{2}^{*}\), and \(=5p_{2}/4\). Suppose that_

\[q+(1+})}{\| \|}<.\] (11)

_Further assume that Mix-IRLS is run with parameters \(=\), and with \(\), \(w_{}\) that satisfy,_

\[\|\|^{2}}<w_{}<\| \|^{2}},\] (12)

_Then for sufficiently large \(R\), starting from an arbitrary initialization, the first phase of Mix-IRLS with at least one iteration (\(T_{1} 1\)) recovers \(^{*}\) up to an error that decreases with increasing \(R\),_

\[_{k=1,2}\|_{k}-_{k}^{*}\|}}{_{}+\|\|}.\] (13)

_Specifically, in the absence of noise (\(_{}=0\)), Mix-IRLS perfectly recovers the regression vectors._

Theorem 6.1 considers only the first phase of Mix-IRLS, as it is sufficient to recover the regression vectors in the described setting. Indeed, empirically, the second phase is often unnecessary. The choice of an oversampling ratio \(=\) is suited to the population setting where \(n=\); see the discussion after Eq. (5). The theorem proof appears in Appendix E.

_Remark 6.2_ (Different noise levels).: Theorem 6.1 holds also in the case of different noise levels \(_{1},_{2}\) for each of the two mixture components. In this case, \(_{}\) is replaced by \(\{_{1},_{2}\}\). Indeed, as illustrated empirically in in Figure H.11, Mix-IRLS is able to handle such a case as well.

_Remark 6.3_ (Required imbalance).: Due to (11), Theorem 6.1 holds only for a sufficiently imbalanced mixture. In the absence of noise, the factor \(5/4\) in the definition of \(\) may be relaxed to any number arbitrarily close to one, at the expense of increasing \(R\). In turn, this implies that our theorem holds for any mixture with the probability of the second component allowed to be arbitrarily close to \(p_{2}<1/2\). In simple words, in the noiseless setting our guarantee holds as long as the mixture is not perfectly balanced. More generally, in the presence of noise, there is a trade-off between mixture imbalance and noise level: the proportion of the dominant component \(p_{1}\) increases with the noise level \(_{}\). This theoretical finding is in agreement with the simulation results in Section 4: Mix-IRLS works better as the imbalance increases. We emphasize that empirically, Mix-IRLS works well also on balanced mixtures, \(p_{1}=p_{2}=1/2\); see Appendix H. Hence it is an open problem to derive theoretical guarantees for a perfectly balanced mixture.

_Remark 6.4_ (Allowed range for \(w_{}\)).: Theorem 6.1 holds for a limited range of values for \(w_{}\), see (12). This range depends on \(q\), which in turn depends on the noise level and the mixture imbalance. For example, at a noise level \(_{}=10^{-2}\), proportions \(p=(3/4,1/4)\), separation of \(\|\|=1\), parameter choice of \(=1\) and \(R 2\), the range for which recovery is guaranteed is \(0.69 w_{} 0.9\). As mentioned previously, empirically we run Mix-IRLS with an initial value of \(w_{}=0.1\) which is increased by the algorithm (see lines 11-13 in Algorithm 1). Indeed, in accordance to this analysis, in many cases the final value is within this range.

_Remark 6.5_ (Overparameterization / unknown \(K\)).: In practical scenarios, the number of components \(K\) is often unknown. Remarkably, Theorem 6.1 can be extended to an overparameterized setting, where the true number of components \(K^{*}\) is 2 but Mix-IRLS is given an overestimated number \(K>2\), together with a corresponding (arbitrary) initialization \((_{1},,_{K})\). This is explicitly discussed in Appendix D (Proposition D.1), and also demonstrated empirically in Figure 3(right).

Theorem 6.1 and Remark 6.5 are in accordance with several empirical findings from previous sections: Mix-IRLS performs better on imbalanced mixtures than on balanced ones; it copes well with an overparameterized \(K\); and it works well starting from a random initialization. Our analysis (Appendix E) sheds light on the inner mechanism of Mix-IRLS that enables these features.

**Comparison to prior work.** Several works derived MLR recovery guarantees for AltMin and GD in a noiseless setting. More related to our Theorem 6.1 are works that studied the population EM algorithm in the presence of noise . These works assumed a perfectly balanced mixture of two components, \(p_{1}=p_{2}=1/2\). An exception is , who allowed for \(K>2\) and an imbalanced mixture. However, their allowed imbalance is limited. In addition, they required a sufficiently accurate initialization. A key novelty in our result is not only that we allow for highly imbalanced mixtures, but that large imbalance actually makes recovery _easier_ for Mix-IRLS: since the quantity \(q\) of (11) is monotonically decreasing with the mixture imbalance, the allowed range (12) of the parameter \(w_{}\) increases with the imbalance. Furthermore, our result holds for an arbitrary initialization. The downside is that Theorem 6.1 requires sufficient imbalance (see Remark 6.3), and does not provide a recovery guarantee for our method on a perfectly balanced mixture, even though empirically, our method works well also in this case. Our result is novel in another aspect as well. In contrast to most existing guarantees, Theorem 6.1 holds also for an arbitrary input number of components \(K\); see Remark 6.5.

Mix-IRLS recovers the first component by treating the samples from the second component as outliers. In the noiseless setting, our guarantee allows the second component to consist almost \(1/2\) of the data; see Remark 6.3. For comparison, in the context of robust regression,  recently analyzed an IRLS method in noiseless setting, and allowed less than \(1/5\) corrupted samples. Our higher tolerance is possible thanks to the strong structural assumption of MLR (1).

## 7 Summary and Discussion

In this work, we presented a novel method to solve MLR, Mix-IRLS, that handles both imbalanced and balanced mixtures. Mix-IRLS is robust to outliers and to an overestimated number of components. The latter feature leads to another contribution of our method: under suitable conditions, it can be run with an overestimated \(K>K^{*}\) and will automatically find the true number of components \(K^{*}\).

The basic idea of Mix-IRLS - sequential recovery using tools from robust regression - was also employed by . Several important differences between their method and Mix-IRLS were listed in the introduction; first and foremost is the fact that  is limited to low dimensions. It is interesting to note that  also made a connection between MLR and robust regression, but the other way around: as a simplified theoretical model, they assumed the outliers follow a linear model, and applied the EM algorithm to the obtained MLR problem to detect them. Also relevant to our work are recent papers on subspace clustering , list-decodable learning  and real phase retrieval . We discuss their relation to our work, additional relevant papers and future research directions, in Appendix A.

Our current theoretical analysis is limited to the case of only \(K=2\) components and a population setting with infinitely many samples. While the first assumption is very common in the literature (e.g., , and many others), population analysis is usually followed by a finite-sample one. In our case, a main challenge in such an analysis revolves around the sequential nature of Mix-IRLS. Once Mix-IRLS estimates a component, it removes its associated samples. Analyzing a modified sample set introduces complex statistical dependencies - the data no longer follow a normal distribution but rather a conditional distribution. In the population setting, various quantities happen to cancel out nicely; see, for example, the derivation of (E.17) from (E.16). Under the setting of finite sample size, we need to bound these quantities under a conditional distribution. We hope to be able to overcome these challenges and extend our analysis to a finite-sample setting in the future. Finally, another interesting future research direction is to formally prove Mix-IRLS's robustness to outliers, as was empirically demonstrated in Section 4.