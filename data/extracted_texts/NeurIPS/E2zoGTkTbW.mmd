# Reward Imputation with Sketching for

Contextual Batched Bandits

 Xiao Zhang\({}^{1,2}\), Ninglu Shao\({}^{1,2,}\), Zihua Si\({}^{1,2,}\), Jun Xu\({}^{1,2,}\),

**Wenhan Wang\({}^{3}\)**, Hanjing Su\({}^{3}\), Ji-Rong Wen\({}^{1,2}\)

\({}^{1}\) Gaoling School of Artificial Intelligence, Renmin University of China, Beijing, China

\({}^{2}\) Beijing Key Laboratory of Big Data Management and Analysis Methods, Beijing, China

\({}^{3}\) Tencent Inc., Shenzhen, China

{zhangx89, ninglu_shao, zihua_si, junxu, jrwen}@ruc.edu.cn

{justinsu, ezewang}@tencent.com

 Ninglu Shao and Zihua Si have made equal contributions to this paper.

###### Abstract

Contextual batched bandit (CBB) is a setting where a batch of rewards is observed from the environment at the end of each episode, but the rewards of the non-executed actions are unobserved, resulting in partial-information feedback. Existing approaches for CBB often ignore the rewards of the non-executed actions, leading to underutilization of feedback information. In this paper, we propose an efficient approach called Sketched Policy Updating with Imputed Rewards (SPUIR) that completes the unobserved rewards using sketching, which approximates the full-information feedbacks. We formulate reward imputation as an imputation regularized ridge regression problem that captures the feedback mechanisms of both executed and non-executed actions. To reduce time complexity, we solve the regression problem using randomized sketching. We prove that our approach achieves an instantaneous regret with controllable bias and smaller variance than approaches without reward imputation. Furthermore, our approach enjoys a sub-linear regret bound against the optimal policy. We also present two extensions, a rate-scheduled version and a version for nonlinear rewards, making our approach more practical. Experimental results show that SPUIR outperforms state-of-the-art baselines on synthetic, public benchmark, and real-world datasets.

## 1 Introduction

Contextual bandits have gained significant popularity in solving sequential decision-making problems (Li et al., 2010; Lan and Baraniuk, 2016; Yom-Tov et al., 2017; Yang et al., 2021), where the agent continuously updates its decision-making policy fully online (i.e., at each step), considering the context and the received reward feedback to maximize cumulative rewards. In this paper, we address a more general setting called _contextual batched bandits_ (CBB). In CBB, the decision process is divided into \(N\) episodes, and within each episode, the agent interacts with the environment for a fixed number of \(B\) steps. At the end of each episode, the agent collects reward feedbacks and contexts. Subsequently, the policy is updated using the collected data to guide the decision-making process in the subsequent episode. CBB offers a practical framework for real-world streaming applications (e.g., streaming recommendation (Zhang et al., 2021, 2022)). In the context of CBB settings, the batch size \(B\), can be adjusted by the agent to achieve improved regret guarantees and meet the data throughput requirements based on the available computing resources (Zhou, 2023).

In bandit settings, it is common for the environment to only provide feedback on the rewards of executed actions to the agent, while concealing the rewards of non-executed actions. This type of limited feedback is referred to as _partial-information feedback_ (also called "bandit feedback"). In CBB setting, existing approaches tend to overlook the potential rewards associated with non-executed actions. Instead, they address the challenge of partial-information feedback through an exploration-exploitation tradeoff in both the context space and reward space (Han et al., 2020; Zhang et al., 2020). However, CBB agents typically estimate and maintain reward models for the action-selection policy, thereby capturing some information about the potential rewards of non-executed actions. This additional reward structure information is available for policy updating in each episode but remains untapped by existing batched bandit approaches.

In the context of contextual bandit settings where the policy is updated online, several bias-correction approaches have been introduced to tackle the issue of partial-information feedback. Dimakopoulou et al. (2019) presented linear contextual bandits integrating the balancing approach from causal inference, which reweight the contexts and rewards by the inverse propensity scores. Chou et al. (2015) designed pseudo-reward algorithms for contextual bandits using upper confidence bound (UCB) strategy, which use a direct method to estimate the unobserved rewards. Kim and Paik (2019) focused on the correction of feedback bias for LASSO bandit with high-dimensional contexts, and applied the doubly-robust approach to the reward modification using average contexts. While these approaches have demonstrated effectiveness in contextual bandit settings, little attention has been given to addressing the under-utilization of partial-information feedback in CBB setting.

Theoretical and experimental analyses in Section 2 indicate that better performance of CBB is achievable if the rewards of the non-executed actions can be received. Motivated by these observations, we propose a novel reward imputation approach for the non-executed actions, which mimics the reward generation mechanisms of environments. We conclude our contributions as follows.

(1) To fully utilize feedback information in CBB, we formulate the reward imputation as a problem of imputation regularized ridge regression, where the policy can be updated efficiently using sketching.

(2) We prove that our reward imputation approach obtains a relative-error bound for sketching approximation, achieves an instantaneous regret with a controllable bias and a smaller variance than that without reward imputation, has a lower bound of the sketch size independently of the overall number of steps, enjoys a sublinear regret bound against the optimal policy, and reduces the time complexity from \(O(Bd^{2})\) to \(O(cd^{2})\) for each action in one episode, where \(B\) denotes the batch size, \(c\) the sketch size, and \(d\) the dimension of the context space, satisfying \(d<c<B\).

(3) We present two practical variants of our reward imputation approach, including the rate-scheduled version that sets the imputation rate without tuning, and the version for nonlinear rewards.

(4) We carried out extensive experiments on a synthetic dataset, the publicly available Criteo dataset, and a dataset from a commercial app to demonstrate our performance, empirically analyzed the influence of different parameters, and verified the correctness of the theoretical results.

**Related Work.** Recently, batched bandit has become an active research topic in statistics and learning theory including \(2\)-armed bandit (Perchet et al., 2016), multi-armed bandit (Gao et al., 2019; Zhang et al., 2020; Wang and Cheng, 2020), and contextual bandit (Han et al., 2020; Ren and Zhou, 2020; Gu et al., 2021). Han et al. (2020) defined linear contextual bandits, and designed UCB-type algorithms for both stochastic and adversarial contexts, where true rewards of different actions have the same parameters. Zhang et al. (2020) provided methods for inference on data collected in batches using bandits, and introduced a batched least squares estimator for both multi-arm and contextual bandits. Recently, Esfandiari et al. (2021) proved refined regret upper bounds of batched bandits in stochastic and adversarial settings. There are several recent works that consider similar settings to CBB, e.g., episodic Markov decision process (Jin et al., 2018), LASSO bandits (Wang and Cheng, 2020). Sketching is another related technology that compresses a large matrix to a much smaller one by multiplying a (usually) random matrix while retaining certain properties (Woodruff, 2014), which has been used in online convex optimization (Calandriello et al., 2017; Zhang and Liao, 2019).

## 2 Problem Formulation and Analysis

Let \([x]=\{1,2,,x\}\), \(^{d}\) be the context space whose dimension is \(d\), \(=\{A_{j}\}_{j[M]}\) the action space containing \(M\) actions,\([;]=[},}]^{}\), \(\|\|_{1}\)\(\|\|_{2}\) denote the Frobeniusnorm, \(1\)-norm, and spectral norm of a matrix \(\), respectively, \(\|\|_{1}\) and \(\|\|_{2}\) be the \(_{1}\)-norm and the \(_{2}\)-norm of a vector \(\), \(_{}()\) and \(_{}()\) denote the minimum and maximum of the of singular values of \(\). In this paper, we focus on the setting of _Contextual Batched Bandits_ (CBB) in Protocol 1, where the decision process is partitioned into \(N\) episodes, and in each episode, CBB consists of two phases: (1) the _policy updating_ approximates the optimal policy based on the received contexts and rewards; (2) the _online decision_ chooses actions for execution following the updated and fixed policy \(p\) for \(B\) steps (\(B\) is also called the _batch size_), and stores the context-action pairs and the observed rewards of the executed actions into a data buffer \(\). The reward \(R\) in CBB is a _partial-information feedback_ where rewards are unobserved for the non-executed actions.

In contrast to the existing batched bandit setting (Han et al., 2020; Esfandiari et al., 2021), where the true reward feedbacks for all actions are controlled by the same parameter vector while the received contexts differ across actions at each step, we make the assumption that in CBB setting, the mechanism of true reward feedback varies across actions, while the received context is shared among actions. Formally, for any context \(_{i}^{d}\) and action \(A\), we assume that the expectation of the true reward \(R_{i,A}^{}\) is determined by an unknown action-specific _reward parameter vector_\(_{A}^{*}^{d}\): \([R_{i,A}^{}_{i}]=_{A}^{*},_{i}\) (the linear reward will be extended to the nonlinear case in Section 5). This setting for reward feedback matches many real-world applications, e.g., each action corresponds to a different category of candidate coupons in coupon recommendation, and the reward feedback mechanism of each category differs due to the different discount pricing strategies.

Next, we delve deeper into understanding the impact of unobserved feedbacks on the performance of policy updating in CBB setting. We first conducted an empirical comparison by applying the batch UCB policy (SBUCB) (Han et al., 2020) to environments under different proportions of received reward feedbacks. In particular, the agent under full-information feedback can receive all the rewards of the executed and non-executed actions, called _Full-Information CB-B_ (FI-CBB) setting. From Figure 1, we can observe that the partial-information feedbacks are damaging in terms of hurting the policy updating, and batched bandit policy can benefit from more reward feedbacks, where the performance of \(80\%\) feedback is very close to that of FI-CBB. Then, we prove the difference of instantaneous re-grets between the CBB and FI-CBB settings in Theorem 1 (proof can be found in Appendix A).

**Theorem 1**.: _For any action \(A\) and context \(_{i}\), let \(_{A}^{n}\) be the reward parameter vector estimated by the batched UCB policy in the \(n\)-th episode. The upper bound of instantaneous regret (defined by \(|_{A}^{*},_{i}-_{A}^{*},_{i}|\)) in the FI-CBB setting is tighter than that in CBB setting (i.e., using the partial-information feedback)._

From Theorem 1, we can infer that utilizing partial-information feedbacks leads to a deterioration in the regret of the bandit policy. Ideally, the policy would be updated using full-information feedback. However, in CBB, full-information feedback is unavailable. Fortunately, in CBB, different reward parameter vectors are maintained and estimated separately for each action, and the potential reward

Figure 1: Average rewards of batch UCB policy (Han et al., 2020) under different proportions of received reward feedbacks, interacting with the synthetic environment in Section 6, where \(x\%\) feedback means that \(x\%\) of actions can receive their true rewards

structures of the non-executed actions have been captured to some extent. Therefore, why not utilize these maintained reward parameters to estimate the unknown rewards for the non-executed actions? In the following, we propose an efficient reward imputation approach that leverages this additional reward structure information to enhance the performance of the bandit policy.

## 3 Reward Imputation for Policy Updating

In this section, we present an efficient reward imputation approach tailored for policy updating in CBB setting.

**Formulation of Reward Imputation.** As shown in Figure 2, in contrast to CBB that ignores the contexts and rewards of the non-executed steps of each action, our reward imputation approach completes the missing values using the imputed contexts and rewards, approximating the full-information CBB setting. Specifically, at the end of the \((n+1)\)-th episode, for each action \(A_{j},j[M]\), the context vectors and rewards received at the steps where the action \(A_{j}\) is executed are observed, and are stored into a _context matrix_\(^{n}_{A_{j}}^{N^{n}_{j} d}\) and a _reward vector_\(^{n}_{A_{j}}^{N^{n}_{j}}\), respectively, where \(N^{n}_{j}\) denotes the number of executed steps of \(A_{j}\) in episode \(n+1\). More importantly, at the steps (in episode \(n+1\)) where the action \(A_{j}\) is NOT executed, the following imputations need to be performed for action \(A_{j}\): (1) since the contexts are shared by all the actions, we directly store them into an _imputed context matrix_\(}^{n}_{A_{j}}^{^{n}_{j} d}\), where \(^{n}_{j}\) denotes the number of non-executed steps of \(A_{j}\) (i.e., \(^{n}_{j}=B-N^{n}_{j}\)); (2) since the rewards of \(A_{j}\) are unobserved at the non-executed steps, we estimate them using an _imputed reward vector_: for any \(j[M]\),

\[}^{n}_{A_{j}}=\{r_{n,1}(A_{j}),r_{n,2}(A_{j}),,r_{n, ^{n}_{j}}(A_{j})\}^{^{n}_{j}},\]

where \(r_{n,b}(A_{j}):=}^{n}_{A_{j}},_{n,b}\) denotes the _imputed reward_ parameterized by \(}^{n}_{A_{j}}^{d}\) and \(_{n,b}\) is the \(b\)-th row of \(}^{n}_{A_{j}}\).

Next, we introduce the updating process of the reward parameter vector \(}^{n}_{A_{j}}\). We first concatenate the context and reward matrices from the previous episodes: \(^{n}_{A_{j}}=[^{0}_{A_{j}};;^{n}_{A_{j}}]^{L^{n}_{j} d},\ ^{n}_{A_{j}}=[^{0}_{A_{j}};;^{n}_{A_{j}}] ^{L^{n}_{j}},\ L^{n}_{j}=_{k=0}^{n}N^{k}_{j},\ }^{n}_{A_{j}}=[}^{0}_{A_{j}};; }^{n}_{A_{j}}]^{^{n}_{j} d}, }^{n}_{A_{j}}=[}^{0}_{A_{j}};;}^{n}_{A_{j}}]^{^{n}_{j}},\ ^{n}_{j}=_{k=0}^{n} ^{k}_{j}.\) Then, the _updated parameter vector_\(}^{n+1}_{A_{j}}\) of the imputed reward for action \(A_{j}\) can be obtained by solving the _imputation regularized ridge regression_: for \(n=0,1,,N-1\),

\[}^{n+1}_{A_{j}}=*{arg\,min}_{ ^{d}}^{n}_{A_{j}}-^{n}_{A_ {j}}\|^{2}_{}}_{}+}^{n}_{A_{j}}-}^{n}_{A_ {j}}\|^{2}_{}}_{}+\| \|^{2}_{2},\] (1)

where \(\) is the _imputation rate_ that controls the degree of reward imputation and measures a trade-off between bias and variance (Remark 1&2), \(>0\) is the regularization parameter. The discounted variant of the closed least squares solution of (1) is used for computing \(}^{n+1}_{A_{j}}\):

\[}^{n+1}_{A_{j}}=(^{n+1}_{A_{j}})^{-1}( ^{n+1}_{A_{j}}+}^{n+1}_{A_{j}}),\] (2)

Figure 2: Comparison of the stored data corresponding to the action \(A_{j}=\{A_{j}\}_{j[M]}\) in CBB, CBB with our reward imputation, and full-information CBB, in the \((n+1)\)-th episode

where \(_{A_{j}}^{n+1}:=_{d}+_{A_{j}}^{n+1}+}_{A_{j}}^{n+1}\), and

\[_{A_{j}}^{n+1} =_{A_{j}}^{n}+_{A_{j}}^{n}_{A_{j}}^{ n},_{A_{j}}^{n+1}=_{A_{j}}^{n}+_{A_{j}}^{n }_{A_{j}}^{n},\] (3) \[}_{A_{j}}^{n+1} =}_{A_{j}}^{n}+}_{A_{j}}^{n }}_{A_{j}}^{n},}_{A_{j}}^{n+1}=}_{A_{j}}^{n}+}_{A_{j}}^{n}}_{A _{j}}^{n},\] (4)

and \((0,1)\) is the _discount parameter_ that controls how fast the previous imputed rewards are forgotten, and can help guaranteeing the regret bound in Theorem 2.

**Efficient Reward Imputation using Sketching.** As shown in the first 4 columns in Table 1, the overall time complexity of the imputation for each action is \(O(Bd^{2})\) in each episode, where \(B\) represents the batch size, and \(d\) the dimensionality of the input. Thus, for all the \(M\) actions in one episode, reward imputation increases the time complexity from \(O(Bd^{2})\) of the approach without imputation to \(O(MBd^{2})\). To address this issue, we design an efficient reward imputation approach using sketching, which reduces the time complexity of each action in one episode from \(O(Bd^{2})\) to \(O(cd^{2})\), where \(c\) denotes the _sketch size_ satisfying \(d<c<B\) and \(cd>B\). Specifically, in the \((n+1)\)-th episode, the formulation in (1) can be approximated by a _sketched ridge regression_ as:

\[}_{A_{j}}^{n+1}=*{arg\,min}_{ ^{d}}\|_{A_{j}}^{n}(_{A_{j}}^{n}- _{A_{j}}^{n})\|_{2}^{2}+\|}_{A_ {j}}^{n}(}_{A_{j}}^{n}-}_{A_{j} }^{n})\|_{2}^{2}+\|\|_{2}^{2},\] (5)

where \(}_{A}^{n+1}\) denotes the updated parameter vector of the imputed reward using sketching for action \(A\), \(_{A_{j}}^{n}^{c N_{j}^{n}}\) and \(}_{A_{j}}^{n}^{c_{j}^{n}}\) are the _sketch submatrices_ for the observed term and the imputation term, respectively, and the _sketch matrices_ for the two terms can be represented as

\[_{A_{j}}^{n}=[_{A_{j}}^{0},_{A_{j}}^{1},,_{A_{j}}^{n}]^{c L_{j}^{n}},} _{A_{j}}^{n}=[}_{A_{j}}^{0},}_{A_{j}}^{1}, ,}_{A_{j}}^{n}]^{c_{ j}^{n}}.\]

We denote the sketches of the context matrix and the reward vector by \(_{A_{j}}^{n}:=_{A_{j}}^{n}_{A_{j}}^{n}^{c  d}\) and \(_{A_{j}}^{n}:=_{A_{j}}^{n}_{A_{j}}^{n}^{c}\), the sketches of the imputed context matrix and the imputed reward vector by \(_{A_{j}}^{n}:=}_{A_{j}}^{n}}_{A_{j}}^ {n}^{c d}\) and \(}_{A_{j}}^{n}:=}_{A_{j}}^{n}}_{A_{j}}^{n}^{c}\). Similarly to (2), the discounted variant of the closed solution of (5) as follows:

\[}_{A_{j}}^{n+1}=(_{A_{j}}^{n+1})^{-1}( _{A_{j}}^{n+1}+}_{A_{j}}^{n+1}),\] (6)

where \((0,1)\) denotes the discount parameter, \(_{A_{j}}^{n+1}:=_{d}+_{A_{j}}^{n+1}+}_{A_{j}}^{n+1}\), and

\[_{A_{j}}^{n+1} =_{A_{j}}^{n}+_{A_{j}}^{n}_ {A_{j}}^{n},_{A_{j}}^{n+1}=_{A_{j}}^{n}+_{A_{j}}^{n }_{A_{j}}^{n},\] (7) \[}_{A_{j}}^{n+1} =}_{A_{j}}^{n}+}_{A_{j}}^{ n}}_{A_{j}}^{n},}_{A_{j}}^{n+1}=}_{A_ {j}}^{n}+}_{A_{j}}^{n}}_{A_{j} }^{n}.\] (8)

Using the parameter \(}_{A_{j}}^{n+1}\), we obtain the _sketched version of imputed reward_ as \(_{n,b}(A_{j}):=}_{A_{j}}^{n},_{n,b}\) at step \(b[_{j}^{n}]\). Finally, we specify that the sketch submatrices \(\{_{A}^{n}\}_{A A,n[N]}\) and \(\{}_{A_{j}}^{n}\}_{A,n[N]}\) are the block construction of Sparser Johnson-Lindenstrauss Transform (SJLT) (Kane and Nelson, 2014), where the sketch size \(c\) is divisible by the number of blocks \(D\)3. As shown in the last 4 columns in Table 1, sketching reduces the time complexity of reward imputation from \(O(MBd^{2})\) to \(O(Mcd^{2})\) for all \(M\) actions in one episode, where \(c<B\). When \(Mc B\), the overall time complexity of our reward imputation using sketching is even comparable to that without reward imputation, i.e., a \(O(Bd^{2})\) time complexity.

**Updated Policy using Imputed Rewards.** Inspired by the UCB strategy (Li et al., 2010), the updated policy for online decision of the \((n+1)\)-th episode can be formulated using the imputed rewards (parameterized by \(}_{A}^{n+1}\) in (2)) or the sketched version of imputed rewards (parameterized by \(}_{A}^{n+1}\) in (6)). Specifically, for a new context \(\),

\(\): _origin policy_\(_{n+1}\) selects the action as \(A*{arg\,max}_{A}}_{A}^{n +1},+[^{}(_{A}^{n+1})^{-1}]^{ }\),

\(\): _sketched policy_\(_{n+1}\) selects the action as \(A*{arg\,max}_{A}}_{A}^{n +1},+[^{}(_{A}^{n+1})^{-1}]^{ }\),

where \( 0\) and \( 0\) are the regularization parameters in policy and their theoretical values are given in Theorem 4. We summarize the reward imputation using sketching and the sketched policy into Algorithm 2, called SPUIR. Similarly, we call the updating of the original policy that uses reward imputation without sketching, the Policy Updating with Imputed Rewards (PUIR).

## 4 Theoretical Analysis

We provide the instantaneous regret bound, prove the approximation error of sketching, and analyze the regret of SPUIR in CBB setting. The detailed proofs can be found in Appendix B. We first demonstrate the instantaneous regret bound of the original solution \(}_{A}^{n}\) in (1).

**Theorem 2** (Instantaneous Regret Bound).: _Let \((0,1)\) be the discount parameter, \(\) the imputation rate. In the \(n\)-th episode, if the rewards \(\{R_{n,b}\}_{b[B]}\) are independent4 and bounded by \(C_{R}\), then, for any \(b[B],\, A\), there exists \(C_{}>0\) such that, with probability at least \(1-\),_

\[|}_{A}^{n},_{n,b}- _{A}^{*},_{n,b}|[\|_{A}^{*}\|_{2}++^{}^{-}C_{}][_{n,b}^{}(_{A}^{n})^{-1} _{n,b}]^{},\] (9)

_where \(_{A}^{n}=_{d}+_{A}^{n}+}_{A}^{n}\), \(=[2C_{R}^{2}(2MB/)]^{}\). The first term on the right-hand side of (9) can be seen as the bias term for the reward imputation, while the second term is the variance term. The variance term of our algorithm is not larger than that without the reward imputation, i.e, for any \(^{d}\),_

\[[^{}(_{A}^{n})^{-1}]^{ }[^{}(_{d}+_{A}^{n} )^{-1}]^{}.\]

_Further, a larger imputation rate \(\) leads to a smaller variance term \([^{}(_{A}^{n})^{-1}]^{}\)._

   &  \\  Item & Operation & Equation & Time & Item & Operation & Equation & Time \\  \(_{A_{j}}^{n+1}\) & \(}_{A_{j}}^{n+1}\) & MM & (3), (4) & \(O(Bd^{2})\) & \(_{A_{j}}^{n+1}\), \(}_{A_{j}}^{n+1}\) & MM & (7), (8) & \(O(cd^{2})\) \\ \(_{A_{j}}^{n+1}\) & \(_{A_{j}}^{n+1}\) & MM & (3), (4) & \(O(Bd)\) & \(_{A_{j}}^{n+1}\), \(}_{A_{j}}^{n+1}\) & MM & (7), (8) & \(O(cd)\) \\ \((_{A_{j}}^{n+1})^{-1}\) & MI & (2) & \(O(d^{3})\) & \((_{A_{j}}^{n+1})^{-1}\) & MI & (6) & \(O(d^{3})\) \\  & & – & & & \(_{A_{j}}^{n}\), \(_{A_{j}}^{n}\) & Sketching & – & \(O(N_{j}^{n}d)\) \\  & – & & & & \(}_{A_{j}}^{n}\), \(}_{A_{j}}^{n}\) & Sketching & – & \(O(_{j}^{n}d)\) \\  Overall & – & – & \(O(Bd^{2})\) & Overall & – & – & \(O(cd^{2})\) \\  

Table 1: The time complexities of the original reward imputation in (1) (first 4 columns) and the reward imputation using sketching in (5) (last 4 columns) for action \(A_{j}\) in the \((n+1)\)-th episode, where \(N_{j}^{n}\) (\(_{j}^{n}\)) denotes the number of steps at which the action \(A_{j}\) is executed (non-executed) in episode \(n+1\), \(_{j}^{n}+N_{j}^{n}=B\), and the sketch size \(c\) satisfying \(d<c<B\) and \(cd>B\) (MM: matrix multiplication; MI: matrix inversion; Overall: overall time complexity for action \(A_{j}\) in one episode)

**Remark 1** (Smaller Variance).: _From Theorem 2, we can observe that our reward imputation achieves a smaller variance \(([_{n,b}^{}(_{A}^{})^{-1}_{n,b}]^{ })\) than that without the reward imputation. By combining Theorem 2 and the proof of Theorem 1, we can obtain that the variance in instantaneous regret bound of SPUIR is in between the variances in full and partial information scenarios. Thus, reward imputation in SPUIR provides a promising way to use expert advice approaches for bandit problems._

**Remark 2** (Controllable Bias).: _Our reward imputation approach incurs a bias term \(^{}^{-}C_{}\) in addition to the two bias terms \(\|_{A}^{*}\|_{2}\) and \(\) that exist in every existing UCB-based policy. But the additional bias term \(^{}^{-}C_{}\) is controllable due to the presence of imputation rate \(\) that can help controlling the additional bias. Moreover, the term \(C_{}\) in the additional bias can be replaced by a function \(f_{}(n)\), and \(f_{}(n)\) is monotonic decreasing w.r.t. number of episodes \(n\) provided that the mild condition \(=(d^{-1})\) holds (the definition and analysis about \(f_{}\) can be found in Appendix B.1). Overall, the imputation rate \(\) controls a trade-off between the bias term and the variance term, and we will design a rate-scheduled approach for automatically setting \(\) in Section 5._

**Remark 3** (Relationship with Existing Instantaneous Regrets).: _According to the original definition in the context of online learning, the definition of instantaneous regret should be \(_{A}_{A}^{*},_{n,b}- _{A_{n,b}}^{*},_{n,b}\). However, in the specific setting of contextual batched bandit (CBB) that is the focus of this paper, as derived in Appendix (second inequality of Eq. (48)), if we denote the upper bound of \(|}_{A}^{n},_{n,b}-_{A }^{*},_{n,b}|\) as U, then 2U serves as an upper bound for instantaneous regret. Thus, in the context of CBB explored in this paper, we are interested in an upper bound for \(|}_{A}^{n},s_{n,b}-_{A}^{*},_{n,b}|\) and define it as the instantaneous regret bound._

Although some approximation error bounds using SJLT have been proposed (Nelson and Nguyen, 2013; Kane and Nelson, 2014; Zhang and Liao, 2019), it is still unknown what is the lower bound of the sketch size while applying SJLT to the sketched ridge regression problem in our SPUIR. Next, we prove the approximation error as well as the lower bound of the sketch size in SPUIR. For convenience, we drop all the superscripts and subscripts in this result.

**Theorem 3** (Approximation Error Bound of Imputation using Sketching).: _Denote the imputation regularized ridge regression function by \(F()\) (defined in (1)) and the sketched ridge regression function by \(F^{}()\) (defined in (5)) for reward imputation, whose solutions are \(}=_{^{d}}F()\) and \(}=_{^{d}}F^{}()\). Let \(\) be the imputation rate, \(>0\) the regularization parameter, \((0,0.1]\), \((0,1)\), \(_{}=[;}]\), and \(_{}=\|_{}\|_{2}^{2}/(\|_{}\|_{2} ^{2}+)\). If \(\) and \(}\) are SJLT, assuming that \(D=(^{-1}^{3}(d^{-1}))\) and the sketch size \(c=(d\ (d^{-1})/^{2}),\) with probability at least \(1-,\) the following results hold:_

\[F(})(1+_{})F(}),\|}-}\|_{2}=O(}).\]

To measure the convergence of approximating the optimal policy in an online manner, we define the _regret_ of SPUIR against the optimal policy as

\[(N,B):=_{A}_{n[N],b[B]}[_{A}^{*},_{n,b}-_{A_{I_{n,b}}}^{*},_{n,b}],\]

where \(I_{n,b}\) denotes the index of the executed action using the sketched policy \(_{n}\) (parameterized by \(\{}_{A}^{n}\}_{A}\)) at step \(b\) in the \(n\)-th episode. We final prove the regret bound of SPUIR.

**Theorem 4** (Regret Bound of SPUIR).: _Let \(T=BN\) be the overall number of steps, \((0,1)\) be the discount parameter, \(\) the imputation rate, \(>0\) the regularization parameter, \(C_{}^{}=_{A}\|_{A}^{*}\|_{2}\), \(C_{}\) be the positive constant defined in Theorem 2. Assume that the conditional independence assumption in Theorem 2 holds and the upper bound of rewards is \(C_{R}\), \(M=O((d)),\,T d^{2}\), \(=[2C_{R}^{2}(2MB/_{1})]^{}\) with \(_{1}(0,1)\), \(= C_{}^{}++^{}^{-}C _{},= C_{},\) where \(C_{}>0\) which decreases with increase of \(1/\) and \((0,1)\). Let \(_{2}(0,0.1]\), \(_{}<1\) be the constant defined in Theorem 3, and \(C_{}\) be a positive constant that decreases with increase of \(1/\). For the sketch matrices \(\{_{A}^{n}\}_{A,n[N]}\) and \(\{}\}_{A,n[N]}\), assuming that the number of blocks in SJLT \(D=(^{-1}^{3}(d_{2}^{-1}))\), and the sketch size satisfying_

\[c=(d\ (d_{2}^{-1})/^{2} ),\]_then, for an arbitrary sequence of contexts \(\{_{n,b}\}_{n[N],b[B]}\), with probability at least \(1-N(_{1}+_{2})\),_

\[(N,B) 2 C_{}(T+1)(+dB)+O (T d}/B).\] (10)

**Remark 4**.: _Setting \(B=O(),_{}=1/d\) yields a sublinear regret bound of order \(()\)5 provided that the sketch size \(c=(_{}^{2}d^{3}\ (d_{2}^{-1}))\). We can observe that the lower bound of \(c\) is independent of the overall number of steps \(T\), and a theoretical value of the batch size is \(B=C_{B}=C_{B}^{2}N/d\), where setting \(C_{B} 25\) is a suitable choice that has been verified in the experiments in Section 6. In particular, when \(_{}=O(1/d)\), the sketch size of order \(c=(d\ d)\) is sufficient to achieve a sublinear regret._

From the theoretical results of regret, we can observe that our SPUIR admits several advantages: (a) The order of our regret bound (w.r.t. the overall number of steps) is not higher than those in the literature in the fully-online setting (Li et al., 2019; Dimakopoulou et al., 2019) that is a more simple setting than ours; (b) The first term in the regret bound (10) measures the performance of policy updating using imputed rewards (called "policy error"). From Theorem 2 and Remark 1&2, we obtain that, in each episode, our policy updating has a smaller variance than the policy without the reward imputation, and incurs a decreasing additional bias under mild conditions, leading to a tighter regret (i.e., smaller policy error) after some number of episodes. (c) The second term on the right-hand side of (10) is of order \(O(T d}/B)\), which is incurred by the sketching approximation using SJLT (called "sketching error"). This sketching error does not have any influence on the order of regret of SPUIR, which may even have a lower order with a suitable choice of \(_{}\), e.g., setting \(_{}=T^{-1/4}d^{-1}\) yields a sketching error of order \(O(T^{3/8}d^{1/2})\) provided that \(c=(_{}^{2}d^{3}\ (d_{2}^{-1}))\).

At a fundamental level, the effectiveness of the proposed reward imputation can be attributed to the following two key factors:

(1) **Leveraging contextual bandit structure**: Traditional bandit methods only consider the structural assumptions for executed actions, leaving out non-executed ones. Our reward imputation approach incorporates a wide range of reward function structural assumptions, covering both executed and non-executed actions. By imputing missing rewards with observed data, we reduce the impact of missing data for a more accurate reward estimation.

(2) **Balancing exploration and exploitation**: Reward imputation's effectiveness arises from its impact on the exploration-exploitation trade-off. By incorporating imputed rewards, our proposed algorithms can make informed decisions even when observed rewards are incomplete. This enhances the agent's exploration strategy, helping it discover more valuable actions and reducing cumulative regret. Essentially, our reward computation approach approximates full-information feedback, mitigating the explore/exploit dilemma.

## 5 Extensions of Our Approach

To make the proposed reward imputation approach more feasible and practical, we tackle the following two research questions by designing variants of our approach following the theoretical results:

**RQ1 (Parameter Selection):**: _Can we set the imputation rate \(\) without tuning?_

**RQ2 (Nonlinear Reward):**: _Can we apply the proposed reward imputation approach to the case where the expectation of true rewards is nonlinear?_

**Rate-Scheduled Approach.**: For RQ1, we equip PUIR and SPUIR with a rate-scheduled approach, called PUIR-RS and SPUIR-RS, respectively. From Remark 1&2, a larger imputation rate \(\) leads to a smaller variance while increasing the bias, while the bias term includes a monotonic decreasing function w.r.t. number of episodes under mild conditions. Therefore, we can gradually increase \(\) with the number of episodes, avoiding the large bias at the beginning of reward imputation. Specifically, we set \(=X\%\) for episodes from \((X-10)\% N\) to \(X\% N\), where \(X\).

**Application to Nonlinear Rewards.**: For RQ2, we provide nonlinear versions of reward imputation. We use linearization technologies of nonlinear rewards, rather than directly setting the rewards as nonlinear functions (Valko et al., 2013; Chatterji et al., 2019), avoiding the linear regret or curse of kernelization. Specifically, instead of using the linear imputed reward \(_{n,b}(A_{j}):=}_{A_{j}}^{n},_{n,b}\), we use the following linearized nonlinear imputed rewards, denotes by \(_{n,b}(,A)\):

**(1) SPUIR-Exp.** We assume that the expected reward is an exponential function as \(G_{}(,)=(^{} ).\) Then \(_{n,b}(,A)=,_{} G_{}(,_{n,b}),\) where \(_{}G_{}(,_{n,b})=(^{}_{n,b})_{n,b}\).

**(2) SPUIR-Poly.** When the expected reward is a polynomial function as \(G_{}(,)=(^{} )^{2}.\) Then \(_{n,b}(,A)=,_{} G_{}(,_{n,b}),\) where \(_{}G_{}(,_{n,b})=2(^{}_{n,b})_{n,b}\).

**(3) SPUIR-Kernel.** Consider that the underlying expected reward in a Gaussian reproducing kernel Hilbert space (RKHS). We use \(_{n,b}(,A)=,(_{n,b})\) in random feature space, where the random feature mapping \(\) can be explicitly computed.

For SPUIR-Exp and SPUIR-Poly, combining the linearization of convex functions (Shalev-Shwartz, 2011) with Theorem 4 yields the regret bounds of the same order. For SPUIR-Kernel, using the approximation error of random features (Rahimi and Recht, 2008), we can also obtain that, SPUIR-Kernel has the same regret bound as SPUIR under mild conditions (see proofs in Appendix B).

## 6 Experiments

We empirically evaluated the performance of our algorithms on 3 datasets: the synthetic dataset, publicly available Criteo dataset6(Criteo-recent, Criteo-all), and dataset collected from Tencent's WeChat app for coupon recommendation (commercial product).

**Experimental Settings.** We compared our algorithms with: Sequential Batch UCB (SBUCB) (Han et al., 2020), Batched linear EXP3 (BEXP3) (Neu and Olkhovskaya, 2020), Batched linear EXP3 using Inverse Propensity Weighting (BEXP3-IPW) (Bistritz et al., 2019), Batched Balanced Linear Thompson Sampling (BLTS-B) (Dimakopoulou et al., 2019), and Sequential version of Delayed Feedback Model (DFM-S) (Chapelle, 2014). We applied the algorithms to CBB setting and implemented on Intel(R) Xeon(R) Silver 4114 CPU@2.20GHz, and repeated the experiments \(20\) times. We tested the performance of algorithms in streaming recommendation scenarios, where the reward is represented by a linear combination of the click and conversion behaviors of users. According to Remark 4, we set the batch size as \(B=C_{B}^{2}N/d\), the constant \(C_{B} 25\), and the sketch size \(c=150\) on all the datasets. The average reward was used to evaluate the accuracy of algorithms.

**Performance Evaluation.** Figure 3(a)-(c) reports the average reward of SPUIR with its variants and the baselines. We observed that SPUIR and its variants achieved higher average rewards, demonstrating the effectiveness of our reward imputation. Moreover, SPUIR and its rate-scheduled version SPUIR-RS had similar performances compared with the origin PUIR, which indicates the practical effectiveness of our variants and verifies the correctness of the theoretical analyses. The results on commercial product in Table 2 indicate that SPUIR outperformed the second-best baseline with the improvements of 1.07% CVR (conversion rate) and 1.12% CTCVR (post-view

   Algorithm & CVR (mean \(\) std) & CTCVR (mean \(\) std) & Time (sec., mean \(\) std) \\  DFM-S & 0.8656 \(\) 0.0473 & 0.3317 \(\) 0.0218 & 302.3140 \(\) 8.3045 \\ SBUCB & 0.8569 \(\) 0.0037 & 0.4277 \(\) 0.0084 & 43.5435 \(\) 0.3659 \\ BEXP3 & 0.4846 \(\) 0.0205 & 0.2425 \(\) 0.0116 & 53.5001 \(\) 0.9220 \\ BEXP3-IPW & 0.4862 \(\) 0.0187 & 0.2436 \(\) 0.0113 & 56.0101 \(\) 1.4142 \\ BLTS-B & 0.8663 \(\) 0.0178 & 0.4285 \(\) 0.0157 & 218.2109 \(\) 1.8198 \\  PUIR & 0.8807 \(\) 0.0053 & 0.4411 \(\) 0.0029 & 184.3575 \(\) 2.2346 \\ SPUIR & 0.8770 \(\) 0.0059 & 0.4397 \(\) 0.0032 & 81.5753 \(\) 1.5879 \\ PUIR-RS & 0.8763 \(\) 0.0056 & 0.4389 \(\) 0.0030 & 180.4999 \(\) 1.7763 \\ SPUIR-RS & 0.8758 \(\) 0.0058 & 0.4391 \(\) 0.0031 & 80.8003 \(\) 2.9030 \\   

Table 2: Performance comparison of coupon recommendation on commercial product click-through&conversion rate). Besides, our reward imputation approaches were more efficient than DFM-S, BLTS-B. The variants using sketching of our algorithms (SPUIR, SPUIR-RS) significantly reduced the time costs of reward imputation, and took less than twice as long to run compared to the baselines without reward imputation (SBUCB, BEXP3, BEXP3-IPW). Figure 3(d) illustrates performances of SPUIR and its nonlinear variants, where SPUIR-Kernel achieved the highest rewards indicating the effectiveness of the nonlinear generalization of our approach. For different decision tasks, a suitable nonlinear reward model needs to be selected for better performances.

**Parameter Influence.** From the regret bound (10), we can observe that a larger batch size \(B\) results in a larger first term (of order \(O(B)\), called policy error) but a smaller second term (of order \(O(1/B)\), called sketching error), indicating that a suitable batch size \(B\) needs to be set. This conclusion was empirically verified in Figure 3(e), where \(B=1,000\) (\(C_{B}=25\)) yields better empirical performance in terms of the average reward. Similar phenomenon can also be observed on Criteo dataset and commercial product. All of the results verified the theoretical results in Remark 4: \(B=C_{B}=C_{B}^{2}N/d\) is a suitable choice while setting \(C_{B} 25\). From the results in Figure 3(f) we observe that, for our SPUIR and SPUIR-RS, the performances significantly increased when the sketch size \(c\) reached \(10\%B\) (\( d d\)), which demonstrates the conclusion in Remark 4 that only the sketch size of order \(c=(dd)\) is needed for satisfactory performance.

## 7 Conclusion

This paper presents a computationally efficient reward imputation approach for contextual batched bandits that addresses the challenge of partial-information feedback in real-world applications. The proposed approach mimics the reward generation mechanism of the environment, approximating full-information feedback. It reduces time complexity using sketching, achieves a relative-error bound for approximation, and exhibits regret with controllable bias and reduced variance. The theoretical formulation and algorithmic implementation may provide an efficient reward imputation scheme for online learning under limited feedback.

Figure 3: (a), (b), (c): Average rewards of the compared algorithms, the proposed SPUIR and its variants on synthetic dataset, Criteo dataset, and the real commercial product data, where we omitted the curves of algorithms whose average rewards are \(5\%\) lower than the highest reward; (d): SPUIR and its three nonlinear variants on synthetic dataset; (e): SPUIR with different batch sizes on Criteo-recent; (f): SPUIR and SPUIR-RS with different sketch sizes on synthetic dataset