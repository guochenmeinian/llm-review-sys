# You Shall not Pass: the Zero-Gradient Problem in Predict and Optimize for Convex Optimization

Anonymous Author(s)

Affiliation

Address

email

###### Abstract

Predict and optimize is an increasingly popular decision-making paradigm that employs machine learning to predict unknown parameters of optimization problems. Instead of minimizing the prediction error of the parameters, it trains predictive models using task performance as a loss function. In the convex optimization domain, predict and optimize has seen significant progress due to recently developed methods for differentiating optimization problem solutions over the problem parameters. This paper identifies a yet unnoticed drawback of this approach - the zero-gradient problem - and introduces a method to solve it. The suggested method is based on the mathematical properties of differential optimization and is verified using two real-world benchmarks.

## 1 Introduction

Mathematical programming is one of the fundamental tools of applied mathematics. It is utilized in various domains, such as finance (Cornuejols and Tutuncu, 2006), power systems (Bansal, 2005), robotics (Raja and Pugazhenthi, 2012), and many others. The main practical limitation of mathematical programming is that it requires a fully-defined model describing the problem which is not always available in reality. A promising approach to overcome this limitation is to employ machine learning (ML) to predict missing parts of the model (Ning and You, 2019).

_Predict and optimize_ (P&O) (Elmachtoub and Grigas, 2017) is a decision-making paradigm that combines ML with mathematical programming. It considers optimization problems where some parameters are unknown and should be predicted prior to solving the problem. The P&O approach builds upon the observation that naively training an ML algorithm to match the distribution of unknown parameters is inefficient (Elmachtoub and Grigas, 2017), as this approach does not take the actual task performance into account. Instead, P&O aims at using task performance as the objective function for ML models directly.

The standard approach to training models in machine learning is to use gradient-based algorithms, such as stochastic gradient descent Kiefer and Wolfowitz (1952). In predict and optimize, computing the gradient of the task performance involves differentiating the solution of the optimization problem with respect to the parameters, which is a non-trivial task. In their seminal work, Agrawal et al. (2019) have shown that a large class of convex optimization problems indeed can be differentiated.

In this paper, we identify a fundamental drawback of differential optimization - the _zero-gradient problem_. Specifically, we show that the Jacobian of convex problems often has a large null space, and hence the task performance, as a function of the ML model parameters, is flat in a significant part of its domain. Therefore, it can not be optimized using gradient-based methods. Consequently, we introduce a way to compute an approximate gradient that is zero only in the optimal solution and isguaranteed to not decrease performance. Finally, we validate the superiority of this method using two real-world problems: the portfolio optimization problem and the optimal power flow problem.

## 2 Predict and optimize

In this section, we provide an overview of the existing research in the predict and optimize domain. Then, we define the P&O problem and introduce the solution approach that we are going to investigate later in this manuscript.

### Related work

To the best of our knowledge, the predict and optimize framework was first introduced by Elmachtoub and Grigas (2017). They consider optimization problems with linear objectives and derive a convex approximation of the task performance function. Then, they optimize the prediction model by using sub-gradients of this approximation. Later, this method was extended onto combinatorial problems by Mandi et al. (2020). Several other approximations were introduced in other studies focusing on combinatorial problems. Vlastelica et al. (2019) derive a differentiable piecewise-linear approximation for the task performance; Berthet et al. (2020) employ stochastic perturbations to approximate derivative of combinatorial problems.

Unlike in the combinatorial case, continuous convex optimization problems do allow exact differentiation of the loss function. The sequence of works (Amos and Kolter, 2017), (Agrawal et al., 2019), (Agrawal et al., 2019) developed a differential optimization technique to compute the derivative of convex optimization problems. In their latest work (Agrawal et al., 2019), the authors delivered a general method that allows differentiating disciplined convex programs (Grant et al., 2006). This result gave rise to new applications of P&O to convex optimization: Uysal et al. (2021) applied convex differential optimization to the risk budgeting portfolio optimization problem; Wang et al. (2020) utilized it to learn surrogate models for predict and optimize; Donti et al. (2017) applied the method to three different real-world benchmarks. Moreover, several studies applied differential optimization to predict and optimize for other problem classes. In Wilder et al. (2019), it was used in linear optimization via constructing a quadratic approximation of the problem. Later, Mandi and Guns (2020) improved upon this result by using logarithmic approximations. Ferber et al. (2020) combined a similar idea with the cutting plane approach and used differential optimization in combinatorial problems.

Outside of predict and optimize, differential optimization also has found several applications. Chen et al. (2021) used it to train reinforcement learning agents in the action space with convex constraints, and Agrawal et al. (2019), employed it for tuning model predictive control algorithms.

While the benefits of the differential optimization approach to predict and optimize are numerous, it is still not fully understood. It was reported in several studies Vlastelica et al. (2019), Wilder et al. (2019), that the gradient of a linear problem is zero everywhere, except for the finite set of points where it is undefined. Since any linear problem is convex, this observation suggests that the gradients of convex problems should be also thoroughly investigated.

### Problem formulation

In this section, we introduce the P&O problem. We refer readers to Elmachtoub and Grigas (2017) for further details. In predict and optimize, we solve optimization problems of the form

\[}\;f(x,w)\;\;x,\] (True problem)

where \(x^{n}\) is the decision variable, \(w^{u}\) is a vector of unknown parameters, \(f:^{n}^{u}\) is the objective function, and \(\) is the feasibility region. The defining feature of this problem is that the parameters \(w\) are unknown at the moment when the decision must be made. Therefore, the true optimization problem is under-defined and cannot be solved directly.

One way to deal with the unknown parameters \(w\) is to use a prediction \(\) instead. Then, the decision can be computed by solving the following problem, which we refer to as the internal problem:

\[x^{*}()=}\;f(x,)\;\;x .\] (Internal problem)A commonly made assumption is that instead of \(w,\) we observe a feature vector \(o\) that contains some information about \(w.\) Also, we have a dataset \(=\{(o_{k},w_{k})\},\) e.g., of historical data, which we can use to learn the relation between \(w\) and \(o.\) This setup enables using ML models to compute the prediction. We denote the prediction model by \(_{},\) and thus we have \(=_{}(o).\)

The problem described above is not specific to predict and optimize. What separates the P&O paradigm from earlier works is the approach to training the model \(_{}.\) In the past, machine learning models would be trained to predict \(w\) as accurately as possible, e.g., in Mukhopadhyay and Vorobeychik (2017). However, the parameter prediction error is merely an artificial objective and our true goal is to derive a decision \(x\) that maximizes the task performance \(f(x,w).\) The main goal of the P&O approach is to utilize this objective for training the model \(_{}.\) The task performance achieved by \(_{}\) on the dataset \(\) can be quantified by the following loss function:

\[L()=-|}_{(o,w)}fx^{*} _{}(o),w\] (1)

Most machine learning algorithms for training models are based on computing the gradient of the loss function (Kiefer and Wolfowitz (1952)). To train \(_{}\) with a gradient-based algorithm, we need to differentiate \(L\) over \(,\) and hence we need to compute the gradient \(_{}fx^{*}(),w,\) where \(=_{}(o).\) Applying the chain rule, it can be decomposed into three terms:

\[_{}fx^{*}(),w=_{x}fx^{*}(),w\;_{}x^{*}()\;_{}.\] (2)

The second term, \(_{}x^{*}(),\) is the Jacobian of the solution of the optimization problem over the prediction \(.\) An exact method to compute this Jacobian was introduced in Agrawal et al. (2019), but it has never been thoroughly analyzed. In the next section, we show that \(_{}x^{*}()\) has a large null space, thereby causing the total gradient in Eq. 2 to be zero even outside of the optimum.

## 3 Differentiable optimization

In this section, we study the derivative of convex optimization programs over the parameters of the objective function. We show that the gradient in Eq. 2 is often zero outside of the optimum, and hence it causes gradient-following methods to get stuck in suboptimal solutions. In the second part of this section, we introduce a method to solve this problem.

Without loss of generality, we consider a single instance of the problem, i.e., one sample \((o,w).\) Everywhere in this section, we denote the prediction by \(=_{}(o).\) Then, the decision is computed as a solution of the internal optimization problem defined as follows:

\[x^{*}()=*{arg\,max}_{x}f(x,)\;\;x .\] (3)

We use \(\) to denote the value of \(x^{*}()\) for a given prediction \(.\) As we are interested in convex optimization problems, we make the following assumptions:

**Assumption 1**.: _The objective function \(f(x,w)\) is concave and twice continuously differentiable in \(x\) for any \(w.\)_

**Assumption 2**.: _The feasibility region \(\) is convex, i.e., \(\{=\{x|g_{i}(x) 0,i=1,,l\},\) where \(g_{i}(x)\) are convex differentiable functions. Moreover, for any \(x,\) the gradients \(\{_{x}g_{i}(x)|g_{i}(x)=0\}\) of the active constraints are linearly independent. 1_

Additionally, we make an assumption about how \(f\) depends on \(w,\) which holds for many real-world problems, including linear and quadratic optimization problems.

**Assumption 3**.: _The objective function \(f(x,w)\) is twice continuously differentiable in \(w.\)_

Throughout this paper, we use derivatives of different objects. For clarity, we first provide an overview of them: the gradient of the true objective function over the decision, \(_{x}f(,w);\) the Jacobian of the decision over the prediction, \(_{}x^{*}();\) the Jacobian of the prediction over the ML model parameters, \(_{};\) and the gradient of the predicted objective in the internal problem, \(_{x}f(x,).\) In the next section, we establish some crucial properties of the Jacobian \(_{}x^{*}().\)

### The zero-gradient theorem

We begin by investigating the relation between the values of the function \(x^{*}()\) and the gradient of the internal objective, \(_{x}f(x,)\). Let \(n_{i}:=_{x}g_{i}(),\,i=1,,\,l\) be the normal vectors of the constraints at \(\), Then, the KKT conditions Kuhn and Tucker (1951) at \(\) state that there exist real values \(_{1},,_{l}\) such that the following holds:

\[_{x}f(,)=_{i=1}^{l}_{i}n_{i},_{i}g_{i} ()=0,_{i} 0, g_{i}() 0, i=1,,l.\]

Under Assumptions 1 and 2, the KKT multipliers \(_{i}\) are uniquely defined by \(\) and \(\). Thus, as \(\) is defined by \(\), we sometimes write \(_{i}()\) to emphasize that it is, in fact, a function of \(\). To provide a geometrical perspective on the KKT conditions, we introduce the following definition:

**Definition 3.1**.: _Let \(x\) and let \(I(x)=\{i|g_{i}(x)=0\}\) be the set of indices of the constraints active at \(x\). Let \(n_{i}=_{x}g_{i}(x),\, i I(x)\), be the normal vectors of these constraints. The gradient cone, \(G(x):=_{i I}_{i}n_{i}|_{i} 0},\) is the positive linear span of normal vectors \(n_{i}.\)_

Combining the KKT conditions with Definition 3.1, we immediately arrive at the following property:

**Property 3.2**.: _Let \(x\) and let \(_{x}f(x,)\) be the internal gradient at \(x\). Then, \(x\) is a solution to the problem in Eq. 3 if and only if \( i I(x),_{i} 0,\) such that \(_{x}f(x,)=_{i I(x)}_{i}n_{i} G(x),\) where \(I(x)\) is the set of indices of active constraints, \(I(x)=\{i|g_{i}(x)=0\}.\)_

While trivial, this property provides a geometrical interpretation of the problem. Effectively, a point \(x\) is a solution to the problem in Eq. 3 if and only if the internal gradient at this point lies inside its gradient cone. Figure 1 illustrates this property.

Before studying the Jacobian \(_{}x^{*}(),\) we first need to address the question of when this Jacobian exists. Sufficient conditions for existence are given in Fiacco (1976). Under Assumptions 1-3, these conditions can be reformulated as follows:

**Lemma 3.3** (Theorem 2.1 in Fiacco (1976)).: _Let Assumptions 1-3 hold and let_

\[_{x}f(,)=_{i I()}_{i}()n_{i}\]

_be the representation of the internal gradient with the normals of the active constraints. Then, suppose that the strict complementary slackness condition holds, i.e., \(_{i}()>0,\, i I().\) Then, the Jacobian \(_{}x^{*}()\) exists at \(.\) Moreover, \(_{i}()\) is continuous around \(\) for any \(i I().\)_

Proof of this lemma is given in Fiacco (1976). This result establishes that strict complementary slackness is sufficient for the Jacobian \(_{}x^{*}()\) to exist. In most cases, the points that violate strict complementary slackness form a zero-measure set and hence can be neglected in practice.

Now, we have all the necessary tools to describe the structure of the Jacobian \(_{}x^{*}()\). Suppose that the strict complementary slackness condition holds at \(\) and hence the Jacobian exists. Assume that we perturb \(\) and obtain \(^{}.\) Let \(^{}=x^{*}(^{})\) denote the solution corresponding to \(^{}.\) What can be said about \(^{}?\) Strict complementary slackness implies that the constraints active at \(\) will remain active at \(^{}\) if the difference \(\|^{}-\|_{2}^{2}\) is small enough. Therefore, the decision \(^{}\) can only move within the tangent space of \(\) at \(\), i.e., orthogonally to all \(n_{i},\,i I(.)\) Hence, when more constraints are active, \(^{}\) can move in less directions. Formally, we obtain the following lemma:

**Lemma 3.4**.: _Suppose that the strict complementary slackness conditions hold at \(\) and let \(_{x}f(,)=_{i I()}_{i}n_{i},\;_{i}>0,\; i I()\) be the internal gradient. Let \(()=span(\{n_{i}\,|\,i I()\})\) be the linear span of the gradient cone. Then \(()\) is contained in the left null space of \(_{}x^{*}(),\) i.e., \(v\,_{}x^{*}()=0,\; v()\)_

The formal proof of this result can be found in the appendix. Lemma 3.4 is very important, as it specifies in what directions \(x^{*}()\)_can move_ as a consequence of changing \(\). Now, the first term in the chain rule in Eq. 2, \(_{x}f(,w)\), specifies in what directions \(x^{*}()\)_should_ move in order for the true objective to increase. Naturally, if these directions are contained in the null space of \(_{}x^{*}(),\) then the total gradient in Eq. 2 is zero. This observation constitutes the main theorem of this paper - the zero-gradient theorem.

**Theorem 3.5** (Zero-gradient theorem).: _Let \(\) be a prediction, and let \(\) be the solution of the internal optimization problem defined in Eq. 3. Suppose that the strict complementary slackness conditions hold at \(\) and let \(()=span(\{n_{i}\,|\,i I()\})\) be the linear span of the gradient cone at \(\). Then, \(_{x}f(,w)()_{}f(,w)=0\)._

The proof of this theorem is obtained by simply applying Lemma 3.4 to the chain rule in Eq. 2. The theorem claims that the gradient of the P&O loss in Eq. 1 can be zero in the points outside of the optimal solution. Hence, any gradient-following method "shall not pass" these points. In particular, the zero-gradient phenomenon happens in such points \(\) where the true gradient \(_{x}f(,w)\) is contained in the space \(()\) spanned by the gradient cone \(G()\). As the dimensionality of this space grows with the number of active constraints, the zero-gradient issue is particularly important for problems with a large number of constraints. In the worst case, \(()\) can be as big as the whole decision space \(^{n}\), thereby making the total gradient \(_{}f(,w)\) from Eq. 2 zero for any value of the true gradient \(_{x}f(,w)\). In the following sections, we introduce a method that resolves the zero-gradient problem and provides theoretical guarantees for its performance.

### Quadratic programming approximation

The fundamental assumption of the predict and optimize framework is that training \(_{}\) using the task performance loss is better than fitting it to the true values of \(w\). Hence, the models trained with predict and optimize might output \(\) that is significantly different from the true \(w\) and yet produces good decisions. Taking this argument one step further, we claim that the objective function \(f(x,)\) in the internal optimization problem in Eq. 3 does not need to be the same as the true objective \(f(x,w)\). In particular, we suggest computing decisions using a simple quadratic program (QP):

\[x^{*}_{QP}()=}-\|x-\|_{2}^{2}\;x.\] (4)

The reasons for this choice are manyfold. First, the internal objective \(f_{QP}(x,)=-\|x-\|_{2}^{2},\) is strictly concave and hence \(x^{*}_{QP}()\) is always uniquely-defined. Moreover, the range of \(x_{QP}()\) is \(\), i.e., \( x,\;\) such that \(x=x^{*}_{QP}()\). Hence, it can represent any optimal solution. However, the most important property of QP is that its Jacobian is very simple, which we explain below.

The problem in Eq. 4 has a simple geometrical interpretation: the point \(x=\) is the unconstrained maximum of \(f_{QP}(x,)\) and \(x^{*}_{QP}()\) is its Euclidean projection on the feasibility set \(\), see Figure 2. To compute the Jacobian \(_{}\,x^{*}_{QP}\), we need to understand how perturbations of \(\) affect \(x^{*}_{QP}\). Employing the geometrical intuition above, we obtain the following lemma:

**Lemma 3.6**.: _Let \(\) be a prediction and \(\) be the optimal solution of the QP problem defined in Eq. 4. Let the strict complementary slackness condition hold and let \(\{n_{i}|i I()\}\) be the normals of the active constraints. Let \(\{e_{j}|j=1,,n-|I()|\}\) be an orthogonal complement of vectors \(\{n_{i}|i I()\}\) to a basis of \(^{n}\). Then, the representation of the Jacobian \(_{}x_{QP}()\) in the basis \(\{n_{i}\}\{e_{j}\}\) is a diagonal matrix. Its first \(|I()|\) diagonal entries are zero, and the others are one._

Proof of this lemma can be found in the appendix. Lemma 3.6 implies that the Jacobian \(_{}x_{QP}()\) has a simple form and can be easily computed by hand. While providing computational benefits, this approach does not address the zero-gradient problem. In the next section, we introduce a method to compute an approximate of the Jacobian \(_{}x_{QP}()\) that has a strictly one-dimensional null space. Combined with the QP approximation, it is guaranteed to at least not decrease the task performance.

### Local smoothing

We identified a fundamental issue of differential optimization - the zero-gradient problem. We showed that the null space of the Jacobian \(_{}x()\) depends on the number of constraints active at \(\). Generally, this number can be as large as the number of optimized variables \(n\), and the gradient-descent algorithms can get stuck in certain points on the boundary of the feasibility region.

In this section, we propose a simple way to modify the feasibility region - we smooth \(\) locally around the point for which we compute the Jacobian, thereby ensuring that its null space becomes one dimensional. First, we define a method for the general setup, without imposing any assumptions on the optimization problem. Then, we demonstrate that combined with the QP approximation from Section 3.2, this smoothing approach has theoretical guarantees.

We begin with the general case - the problem in Eq. 3. Let \(_{x}f(,)=_{i I()}_{i}n_{i}\) be the internal gradient at \(\) for some \(_{i} 0,\  i I()\). Then, we introduce the following definition:

**Definition 3.7**.: _Let \(r>0\) be a positive real number. Let \(c=-rf(,)}{\|_{x}f(,) \|_{2}}.\) The local \(r\)-smoothed feasibility region, \(_{r}(,):=\{y|y^{n},\|y-c\|_{2} r\},\) is a ball of radius \(r\) around \(c\). The local \(r-\)smoothed problem \(P_{r}(,)\) with parameters \(,\) is defined as \(x_{r}^{*}():=_{x_{r}(,)}\,f(x,).\)_

Figure 2 shows an example of the local \(r-\)smoothed problem. Now, let \(_{r}=x_{r}^{*}()\) denote the solution of \(P_{r}(,)\). By construction, the internal gradient at \(_{r}\) lies in the one-dimensional gradient cone, and hence, by Property 3.2, \(_{r}=\). The main purpose of smoothing is to approximate the gradient in Eq. 2 by substituting \(_{}x^{*}()\) with \(_{}x_{r}^{*}()\). We highlight that the decisions are still computed using the non-smoothed problem \(x^{*}()\) and \(x_{r}^{*}(,)\) is used exclusively to perform the gradient update step. In other words, we use the following expression to compute the gradient:

\[_{}f(x^{*}(),w)_{x}f,w \,_{}x_{r}^{*}()\,_{}\] (5)

It is worth mentioning that the strict complementary slackness in the original problem is a stronger condition than the strict complementary slackness on \(P_{r}(,)\). Therefore, the Jacobian of the \(r-\)smoothed problem can exist even for predictions \(\) where the true Jacobian does not.

Generally, the efficiency of \(r-\)smoothing depends on the form of the internal problem in Eq. 3. Below, we show that combining \(r-\)smoothing with the QP approximation has guarantees on its performance. First, we notice that Lemma 3.6 prescribes the Jacobian of the \(r-\)smoothed QP problem:

**Property 3.8**.: _Let \(=x_{QP}^{*}()\) be a decision derived via QP. Suppose that the complementary slackness conditions hold for \(P_{r}(,)\) and let \(e_{1}=_{x}f_{QP}(,)\) be the internal gradient. Let \(\{e_{2},,e_{n}\}\) be a complement of \(e_{1}\) to an orthogonal basis of \(^{n}\). Then, the Jacobian \(_{}x_{r}^{*}()\) of the local \(r-\)smoothed problem expressed in the basis \(\{e_{1},e_{2},,e_{n}\}\) is a diagonal matrix. Its first entry is zero, others are ones._

As \(C_{r}(,)\) is defined by a single constraint, the null space of \(_{}x_{r}^{*}(,)\) is always one-dimensional. Hence, the zero-gradient problem can only occur when the internal gradient \(_{x}f_{QP}(,)\) and the true gradient \(_{x}f(,w)\) are exactly collinear. Hence, we expect \(r-\)smoothing to significantly improve upon the zero-gradient problem. Next, we show that the \(r-\)smoothed Jacobian is actually a good approximation. In the following theorem, we demonstrate that the local \(r-\)smoothing of the QP approach indeed yields a "good" direction for the gradient steps.

Figure 2: _Left_: Illustration of QP. The internal gradient (black arrow) at the solution of the QP \(\) (red point) is orthogonal to the feasibility region \(\) (blue area) and points towards the unconstrained maximum \(\) (purple cross). _Right_: Illustration of the \(r-\)smoothed problem. The internal gradient (black arrow) is orthogonal to the \(r-\)smoothed feasibility region \(_{r}(,)\) (green circle) at the decision \(\) (red point).

**Theorem 3.9**.: _Let \(=x^{*}_{QP}()\) be the decision obtained via QP and let \(_{}x^{*}_{r}()\) be the Jacobian of the \(r-\)smoothed QP problem. Let \(=_{x}f(,w)\)\(_{}x^{*}_{r}()\) be the prediction perturbation obtained by using this Jacobian and let \(^{}(t)=+t\) be the updated prediction. Then, for \(t 0^{+},\) using \(^{}(t)\) results in a non-decrease in the task performance. In other words, \(fx^{*}_{QP}(^{}(t)),w fx^{*}_{QP}(),w.\)_

Interestingly, this result does not depend on \(r.\) However, this is to be expected - no matter the radius of \(_{r},\) the Jacobian of \(P_{r}(,)\) is still the same by Lemma 3.6. Theorem 3.10 shows that using \(r-\)smoothing together with the QP approximation results in analytically computable Jacobian that has a strictly one-dimensional null space. Therefore, we are much less likely to encounter the zero-gradient problem when using this approximation. However, the resulting one-dimensional null space contains the only direction that can move the prediction \(,\) and hence the decision \(,\) inside \(.\) This might become crucial, for example, when the optimal solution with respect to the true objective lies in the interior of \(.\) To resolve this problem, we use the projection distance regularization method first suggested in Chen et al. (2021). Specifically, we add a penalty term

\[p()=\|-\|_{2}^{2},\] (6)

where \(^{+}\) is a hyperparameter. Minimizing this term, we push \(\) along the null-space of the Jacobian towards the feasibility region and eventually move \(\) inside \(.\)

### The training process

In this section, we summarize the results of Sections 3.1-3.3 and describe the final algorithm we use to solve the P&O problems. For each problem instance \((o,w),\) we first compute the prediction, \(=_{}(o),\) and the decision using the QP approximation method, \(=x^{*}_{QP}().\) Then, we obtain the achieved objective value, \(f(,w).\) During training, we update the model parameters \(\) by performing the steps described in Algorithm 1.

``` for\((o,w)\)do \( x^{*}_{QP}((o))\)\(\) Compute the decision \(f_{x}_{x}f(,w)\)\(\) Compute the true gradient \(_{x}_{x}f(,)\)\(\) Compute the internal gradient \(f^{0}^{*}_{x}}{\|f_{x}\|_{2}}\)\(\) Project the true gradient on the null space of \(_{}x^{*}_{r}()\)\( f_{x}_{}x^{*}_{r}()=f_{x}-f^{0}.\)\(\) Compute the prediction perturbation \(^{reg} 2(-)\)\(\) Compute the anti-gradient of the penalty from Eq. 6\((+^{reg})_{}\, _{}(o)\)\(\) Approximate the total gradient \(+\)\(\) Perform the gradient step of size \(\) ```

**Algorithm 1**

## 4 Experiments

The main result of Section 3 is the zero-gradient theorem, which describes when the gradient \(_{}fx^{*}(),w\) is zero. To deal with it, we introduced the QP approach for computing the decisions, \(r-\)smoothing for approximating the Jacobian \(_{}x^{*}(),\) and projection distance regularization to deal with the remaining null space dimension. Our solution deals with the zero gradient problem by combining these methods. In this section, we use two real-world P&O problems to evaluate the efficiency of our method.

### Portfolio optimization

Following Wang et al. (2020), we apply the predict and optimize framework to the Markowitz mean-variance stock market optimization problem Markowitz and Todd (2000). In this problem, we act as an investor who seeks to maximize the immediate return but minimize the risk penalty. The

[MISSING_PAGE_FAIL:8]

the predictor is a 2-layer neural network, further details on the training process are described in the appendix. The results in Figure 3 indicate that \(r-\)smoothing significantly improves the performance when the true objective is more linear. This result matches the theory from Section 3, as linear true objective pushes the decision \(\) towards the boundary of \(,\) and hence it is more likely to enter points with a large gradient cone. For the more quadratic objectives, the true maximum is often in the interior of \(,\) and hence \(r-\)smoothing alone is not sufficient to reach it. In this case, the regularization term from Eq 6 becomes crucial, as it is the only method that can push \(\) inside \(.\)

### Optimal power flow in a DC grid

To further understand the zero-gradient phenomenon, we consider the optimal power flow problem (OPF) for DC grids (Li et al., 2018). Due to power losses, the constraints in this problem are non-linear, thus making it computationally hard. In our experiments, we used a linearized version of the problem that represents a DC grid without power losses. The decision variable is the vector of nodal voltages \(v^{n},\) and the unknown parameter \(w\) represents either the value gained by serving power to a customer or the price paid for utilizing a generator. The reference voltage \(v_{0},\) the admittance matrix \(Y,\) and the constraint bounds represent the physical properties of the grid.

\[_{v} f(v,w)=-v_{0}w^{}(Yv)\] subject to: \[ v\] \[-v_{0}Yv\] \[ Y_{ij}(v_{i}-v_{j})\]

We refer the reader to Li et al. (2018) for further details of the problem. Importantly, the feasibility region is defined by multiple linear constraints, and therefore we expect it to have numerous vertices with large gradient cones. The objective function \(f(v,w)\) quantifies the social welfare (Veviurko et al., 2022) generated by all the users of the power grid. Importantly, \(f(v,w)\) is linear, and hence its maximum lies on the boundary of the feasibility region.

We compared the same four methods as before on this problem using randomly generated grids with four generators and twelve loads. Same as before, we use QP approximation, \(x_{QP}^{*}()=_{x}(-\|-x\|_{2}^{2}),\) to compute the decisions. The results in Figure 4 confirm our hypothesis - even though we differentiate through a quadratic problem, the linearity of the true objective causes the zero-gradient effect as the decision is pushed towards the boundary of the feasibility region. Then, due to a large number of constraints, it is likely to enter a vertex with a large gradient cone and get stuck there. In this case, \(r-\)smoothing greatly outperforms the standard differential optimization method from Agrawal et al. (2019), while the projection distance regularization does not help a lot.

## 5 Conclusion

In this work, we discover and explain the zero-gradient problem in P&O for convex optimization. In particular, we show that the null space of the Jacobian of a convex optimization problem can get arbitrarily large, especially in the case with numerous constraints. This phenomenon prevents gradient-following algorithms from learning optimal solutions in convex P&O problems.

To resolve this issue, we introduce a method to compute an approximation of the Jacobian. It is done by smoothing the feasibility region around the current solution and thereby reducing the dimensionality of the null space to one. We prove that the combination of smoothing with the QP approximation results in the gradient update steps that at least do not decrease the task performance, but often allow to escape the zero-gradient cones. To enable movement along the remaining one-dimensional null space, we add a projection distance regularization term. The suggested method leads to significantly better results for the convex P&O problems that suffer from the zero-gradient problem the most - those with many constraints and with the true optimum lying on the boundary of the feasibility set.

Figure 4: Comparison of different methods on the DC grid OPF problem. \(y-\)axis represents the mean and standard deviation of the test regret for twelve random seeds.