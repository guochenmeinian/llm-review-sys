# Mitigating Quantization Errors Due to Activation Spikes in GLU-Based LLMs

Anonymous Author(s)

Affiliation

Address

email

###### Abstract

Modern large language models (LLMs) have established state-of-the-art performance through architectural improvements, but still require significant computational cost for inference. In an effort to reduce the inference cost, post-training quantization (PTQ) has become a popular approach, quantizing weights and activations to lower precision, such as INT8. In this paper, we reveal the challenges of activation quantization in GLU variants , which are widely used in feed-forward network (FFN) of modern LLMs, such as LLaMA family. The problem is that severe local quantization errors, caused by excessive magnitudes of activation in GLU variants, significantly degrade the performance of the quantized LLM. We denote these activations as _activation spikes_. Our further observations provide a systematic pattern of activation spikes: 1) The activation spikes occur in the FFN of specific layers, particularly in the early and late layers, 2) The activation spikes are dedicated to a couple of tokens, rather than being shared across a sequence. Based on our observations, we propose two empirical methods, Quantization-free Module (QFeM) and Quantization-free Prefix (QFeP), to isolate the activation spikes during quantization. Our extensive experiments validate the effectiveness of the proposed methods for the activation quantization, especially with coarse-grained scheme, of latest LLMs with GLU variants, including LLaMA-2/3, Mistral, Mixtral, SOLAR, and Gemma. In particular, our methods enhance the current alleviation techniques (e.g., SmoothQuant) that fail to control the activation spikes.1

## 1 Introduction

Large language models (LLMs) have become a key paradigm in natural language processing, accelerating the release of variations within the community . Furthermore, latest LLMs establish state-of-the-art performance by training with increased scale, as well as by adopting architectural improvements such as GLU , RoPE , GQA , and MoE . Especially, GLU (Gated Linear Unit) variants (e.g., SwiGLU, GeGLU) has been adopted in the most of modern LLM architectures (e.g., LLaMA family ), due to training efficiency . Although LLMs broaden foundational capabilities in natural language tasks and potential for various applications, billions of parameters in the large models impose considerable computational costs on end users in practice. To reduce GPU memory requirements and accelerate inference speed, post-training quantization (PTQ) offers an affordable solution by quantizing weights and activations into a lower precision (e.g., INT8) without a need for expensive retraining steps . However, recent studies have revealed that large magnitude values at certain coordinates exist in the activations of LLMs, which are often called outliers, posing a key challenge in activation quantization . Another line of works attempts to explain the role of outlier values in the attention mechanism . Nevertheless, current research on the impact of evolving LLM architectures on the outliers remains insufficient.

In this paper, we present our discovery that the GLU architecture in the feed-forward network (FFN) generates excessively large activation values, which are responsible for significant local quantization errors. Specifically, we observe that these problematic activation values occur in specific linear layers and are dedicated to a couple of tokens, which will be discussed in Section 3. To distinguish the excessive GLU activations from the outliers, we refer to them as _activation spikes_. In light of our observations, we propose two empirical methods to mitigate the impact of activation spikes on quantization: Quantization-free Module (QFeM) and Quantization-free Prefix (QFeP). QFeM aims to partially exclude quantization for linear layers (or modules) where large quantization errors occur, instead of quantizing the entire linear modules in the LLM. By scoring the extent of scale disparity, QFeM selects linear modules to exclude. On the other hand, QFeP identifies the prefix that triggers activation spikes and preserves its context as a key-value (KV) cache, thereby preventing the recurrence of activation spikes in subsequent tokens. It is noteworthy that both QFeM and QFeP rely on calibration results to capture activation spikes in advance, without any modifications to the target LLM. This indicates that our methods can be integrated into any existing quantization methods.

In our comprehensive experiments, we demonstrate that recently released LLMs incorporating GLU variants struggle with activation spikes when applying activation quantization. Consequently, the proposed methods, QFeM and QFeP, substantially enhance the performance of the primitive quantization method, the round-to-nearest (RTN) method. Furthermore, we observe that current outlier alleviation methods [50; 51] are exposed to the activation spikes and benefit from our proposed methods. Compared to the strong baseline of fine-grained activation quantization , our methods show competitive performance, achieving reduced latency and memory footprint.

In summary, the contributions of our work are as follows:

* We find that the GLU architecture in modern LLMs systematically generates excessive activation values, which are responsible for significant performance degradation in activation quantization.
* Based on our observations, we propose two empirical methods, QFeM and QFeP, which effectively exclude the activation spikes during quantization, with negligible computational overhead and compatibility with any existing quantization techniques.
* Our extensive experimental results validate the detrimental impact of the activation spikes on activation quantization, while our proposed methods consistently enhance the quantization performance.

## 2 Related Works

Outlier Values in LLMs.Previously, outlier values have been observed in the transformer-based language models such as BERT  and early GPT  models through numerous studies [8; 24; 27; 35; 45]. Since the advent of LLMs [10; 57] rooted in the GPT, recent studies by [1; 12; 51] have tackled the existence of outlier values in LLMs. According to them, these outliers exhibit a large magnitude of values at the shared dimensions of hidden states across tokens. More recently, [9; 42] explain that the outliers attribute to the vertical pattern in the attention mechanism [25; 52], which influences the performance of LLMs. In particular,  claims a different type of outlier existing in the hidden states of specific tokens. However, prior studies merely focus on the superficial hidden states between the decoder layers. Our work provides a module-level investigation where quantization is applied practically, focusing on different LLM architectures.

Post-training Quantization for LLMs.Post-training quantization (PTQ) refers to the quantization of a neural network model to low precision, such as INT8, without additional parameter updates [17; 19]. Especially for LLMs, this approach cost-effectively achieves inference with low memory usage and faster inference latency by quantizing the weights and activations used in matrix multiplication (e.g., linear layer). However, because of the challenges in activation quantization of LLMs, many recent works are mainly focused on the weight-only quantization [11; 13; 15; 23; 26; 39; 54]. Otherwise, the activation quantization faces inherent outliers, which hinder accurate quantization by reducing representation resolution. To address this challenge,  proposes a mixed-precision quantization method where the outlier dimensions are computed in high precision. [50; 51] approach migration of scale from activation to weights to alleviate the scale of outlier activations. Along this line of research, we propose to enhance the activation quantization based on our observations.

## 3 Activation Spikes: Excessive Magnitude of GLU Activations

For clarity, "hidden states" refer to the output tensor of a transformer layer (or block), while "input activations" or "activations" denote the input tensor of a linear layer (or module) in the remain of this paper. Recent work  has investigated a novel type of outlier existing in the hidden states across modern LLMs. Although these outliers of hidden states play a crucial role in the attention mechanism [9; 42; 52], their relationship with input activations for quantization has not been fully explored. Importantly, because recent LLMs adopt Pre-LN [4; 53], which normalizes hidden states before self-attention and feed-forward network (FFN) blocks, the scale of hidden states does not reflect the scale of input activations within the transformer block. Therefore, we focus on the input activations fed into each linear module within the transformer block to connect to activation quantization. Specifically, we examine the four linear (projection) layers: query (parallel to key and value), out, up (parallel to gate), and down modules. For detailed illustration of Pre-LN transformer, please see Appendix D.1.

### Existence of Activation Spikes in GLU Variants

To analyze the input activations, we employ a calibration method, which is used to estimate the quantization factors such as scale and zero-point. For the calibration data, we use 512 samples randomly collected from the C4  training dataset. Afterwards, we feed each sample into the LLM and monitor each hidden state and input activation through the decoder layers. To estimate the scale factor, we use absolute maximum value. The tested LLMs are listed in Appendix A.1.

GLU-implemented LLMs exhibit activation spikes at specific layers.In Figure 0(a), we display the calibrated scale factors for the LLMs that implement GLU variants (e.g., SwiGLU, GeGLU). Across models, we observe a shared pattern of scale from the results. Within the early and late layers, the down modules in the FFN show noticeable magnitudes of input activations. Note that these input activations are derived from the _Hadamard Product_ within GLU. Thus, the GLU variants generate activation spikes at the specific layers. Interestingly, we notice a high correlation between the emergence of activation spikes and intermediate hidden states of large scale. This indicates that the FFN contributes to amplifying the hidden states via the addition operation in the residual connection . Once the magnitude of the hidden states is exploded, it persists through layers until encounter the activation spikes at late layers.

Non GLU-implemented LLMs show modest scale distribution.Figure 0(b) illustrates the calibration results for LLMs with the original feed-forward implementation in Transformer . We observe that the LLMs continue to generate the large-scale hidden states, regardless of the GLU implementation. This corresponds to the observations in . More importantly, our module-level results elaborate that the scale of hidden states is not transferable to the input activations of inner linear modules. Instead, we reveal that GLU variants are associated with the hidden states and generate activation spikes. This clarifies the quantization challenge of the GLU-implemented LLMs concentrated in the early and late layers. Because excessive scales of activation spikes have the potential to hinder the accurate quantization, we conduct an in-depth analysis to better understand these activation spikes in the following sections.

Figure 1: Calibration results on GLU-implemented and non GLU-implemented LLMs. We present the maximum magnitudes of input activations for each linear modules and layer-wise hidden states. For more results on different LLMs, see Appendix A.2, A.3.

### Token-level Scale Analysis within Activation Spikes

In the previous section, we observed the excessive scale of the input activations derived from GLU activation. When quantizing the input activations, the variance of input activation scales for each token affects the quantization performance . To delve into the disparity between token-wise scales in the activation spikes, we unroll them through the sequence of tokens. Figure 2 illustrates the individual input activation scales where the activation spike appears. Given a token sequence, the large magnitudes of input activations are observed in a couple of tokens, such as the BOS token, newline (\(\)n), and apostrophe (\(\,\)'). These specific tokens coincide with the observations of , which suggests that such tokens exhibit massive values in the hidden states. Thus, the activation spike is associated with the process of assigning a special role to these tokens in later transformer layers. However, the excessive scale of specific token hinders the estimation of scale factor for the other tokens, such as in per-tensor quantization. Additionally, the largest scale is dedicated to the first instance of the specified token, while the following usage exhibits a modest scale. This phenomenon makes the quantization more complicated, as the activation spikes dynamically occur depending on the current input sequence.

### Effect of Quantization on Activation Spikes

We explore the impact of local quantization errors caused by activation spikes on LLM outputs. To identify the layers where activation spikes occur, we utilize a ratio between the maximum and median values of the token-wise input activation scales, instead of using the maximum scale value alone. The max-median ratio for linear layer \(m\) can be formulated as \(r^{(m)}=^{(m)})}{(^{(m)})}\), where \(S^{(m)}\) represents the token-wise input activation scales incoming to module \(m M\). This max-median ratio captures the extent to which maximum scale dominate the other token scales. For comparison, we choose the activation quantization targets as the top-4, middle-4, and bottom-4 modules, based on the max-median ratio in descending order. Then, we evaluate the perplexity and mean-squared error (MSE) using the calibration dataset. Here, the MSE is calculated for the last hidden states between the original (FP16) and partially quantized LLM. As shown in Table 1, quantization on the top-4 rated modules solely degrades the LLM performance by significant margins, while the other cases exhibit negligible performance changes. We consider these quantization-sensitive input activations (_inter alia_ activation spikes) to be the quantization bottleneck, which, in this paper, refers to the quantization error caused by outliers.

Furthermore, the activation spikes are conditioned on the specific context of the input sequence as discussed in Section 3.2. Altogether, such dynamic bottlenecks must be handled with caution to enhance the quantization performance of LLMs.

    &  &  \\   & FP16 & Top 4 & Middle 4 & Bottom 4 & Top 4 & Middle 4 & Bottom 4 \\  LLaMA-2-7B & 7.37 & **11.77** & 7.38 & 7.40 & **1908.80** & 1.03 & 12.90 \\ LLaMA-2-13B & 6.84 & **15.09** & 6.84 & 6.84 & **4762.11** & 0.91 & 10.38 \\ Mistral-7B & 8.35 & **69.45** & 8.35 & 8.36 & **218.60** & 0.02 & 0.18 \\ Gemma-7B & 10.85 & **85.83** & 10.94 & 10.87 & **213.93** & 1.60 & 1.07 \\   

Table 1: Perplexity and MSE of partial activation quantization of LLMs

Figure 2: Token-wise scales in a specific layer with an activation spike. When quantizing the input activations using a per-tensor scale, the scale of the activation spike dominates the scales of the other tokens. For more examples, see Appendix D.2.

## 4 Mitigating Quantization Quality Degradation Based on the Observation

To address the quantization bottleneck, our approach is based on the deterministic occurrence patterns of activation spikes. First, we utilize the observation that bottlenecks occur at a few specific layers. This implies that naive full quantization of LLMs is affected by these bottlenecks. Second, we exploit the phenomenon that the activation spike is derived from the first occurrence of specific tokens. Thus, the planned occurrence prevents recurrence in the subsequent and possibly future tokens. In the following sections, we propose two methods inspired the above insights.

### Quantization-free Module (QFeM)

In the full quantization of LLM, all linear layers within the LLM are quantized. Among these linear layers, we propose omitting the quantization of input activations for linear layers where significant quantization errors are caused by activation spikes. To be noted, increasing the number of unquantized modules exhibits a trade-off between the inference latency and the model performance. Thus, determining which module should be quantized (or left unquantized) is crucial to retain the efficacy of quantization. Here, we use the max-median ratio \(r^{(m)}\) and define a set of unquantized modules, denoted as \(M_{}\), where the ratio \(r^{(m)}\) of each linear layer is larger than threshold \(\). For instance, all linear layers in \(M\) are quantized if \(=\). For clarity, we treat sibling linear layers, such as query-key-value, as a single linear layer. To control the impact of activation quantization only, we leave the weight parameters in unquantized linear layers as INT8 and dequantize them into FP16 during matrix multiplication with the incoming activations, operating as weight-only quantization.

Optimizing the threshold \(\).To calculate the activation scale ratio for each linear layer, we first gather token-wise input activation scales from the calibration examples discussed in Section 3.1. Exceptionally, for FFN experts in the mixture of experts (MoE) architectures like the Mix-tral model , calibration is performed separately. After determining these ratios, we use binary search to set the threshold value \(\), balancing inference latency and performance degradation. As a metric, we assess performance through perplexity measured on the same calibration examples. For example, the relationship between threshold value \(\) and its impact on performance is depicted in Figure 4, demonstrating how full quantization can degrade performance. Rather than fully quantizing, we identify an optimal threshold by finding the intersection of two performance curves; in Figure 4, this threshold is approximately 16. Details on the QFeM implementation are provided in Table 2.

Figure 4: Trade-off between perplexity (stands for performance) and \(|M_{unq}|\) (stands for latency) according to the threshold \(\) for LLaMA-2-13B model.

Figure 3: Overview of QFeM and QFeP. (Left): QFeM excludes the modules whose \(r^{(m)}\) is larger than the hyperparameter \(\) from quantization. (Right): QFeP computes in advance the prefix of activation spikes and utilizes solely their KV cache during the quantization phase, effectively preventing further activation spikes in subsequent sequences.

### Quantization-free Prefix (QFeP)

Orthogonal to the QFeM, we propose Quantization-free Prefix (QFeP) that mitigates the quantization errors by precomputing the prefix (or short prompt) corresponding to activation spikes. This method is based on the observations presented in Section 3.2, which indicate that significant quantization errors result from the overestimated scale factor of the _first instance_ within the restricted token set. Inspired by this occurrence pattern of activation spikes, we aim to construct a prefix which stabilizes the quantization scale factor of the tokens that come after the prefix. In other words, once the prefix is fixed at the beginning, the activation spikes consistently occur within the prefix. Afterward, we employ key-value (KV) caching mechanism to process the activation spikes in advance. In practice, KV cache is utilized to optimize the decoding speed of causal language models by storing precomputed key and value states of the previous tokens . This approach provides a bypass of the quantization including activation spikes, while preserving the context of prefix through the KV cache. The KV cache for the prefix is precomputed once through the offline inference of LLM without quantization. Then, this KV cache is exploited in the quantization phases, such as calibration or dynamic quantization, even for quantized inference. The process of QFeP is illustrated in Figure 3.

Prefix Search.To form a prefix of explicit activation spike, we first identify candidate token that represent the activation spike at the linear layer with the highest max-median ratio \(r^{(m)}\). For instance, the candidate token can be apostrophe (') token for LLaMA-2-70B model, as highlighted in red in Figure 2. Once the candidate token is identified, we search the middle context token for between the BOS token and the candidate token in the prefix. This middle context provides dummy context, which is required to activate the candidate token. To find the middle context, we design a template \([B,T_{1},C_{1},T_{2},C_{2}]\) where \(B\), \(T_{i}\), and \(C_{i}\) denote the BOS token, context token, and candidate token in the vocabulary \(V\), respectively. Then, we select the context token \(T\) where \(C_{1}\) triggers an activation spikes, while later instance of the same token \(C_{2}\) does not. When the context token for the activation spikes is varied, we choose the token that maximizes the activation scale ratio between the \(C_{1}\) and \(C_{2}\). Finally, we prepare the KV cache for searched prefix of \([B,T,C]\). Note that the latter sequence in the template can be replaced with sequences from dataset instead of repetition.

Implementation Details.During the prefix search phase, we exploit the calibration dataset used in Section 3.1. For the candidate tokens, we consider the tokens with the top three largest input activation magnitudes. Then, we search for the middle context token among top 200 most frequent tokens in the calibration dataset, which is the subset of the vocabulary \(V\). Finally, with the search result, we prepare the KV cache for the target model in FP16 precision. Exceptionally, for the Mixtral  model, we use the scale of output hidden states instead of input activations, as the tokens are divided sparsely in a mixture of experts architecture. Table 2 presents the searched prefix.

## 5 Experiments

### Experimental Setup

Models.Our proposed methods, QFeM and QFeP, aim to mitigate the quantization bottleneck, which is discussed in Section 3.3, caused by the activation spikes, especially in the GLU variants. To validate the efficiency proposed methods, we tested publicly released LLMs that were implemented with GLU, according to their paper and source code. We recognize recent LLMs, including LLAMA-2-{7B, 13B, 70B} , LLaMA-3-{7B, 70B}, Mistral-7B , Mixtral-8x7B , SOLAR-10.7B , and Gemma-7B , utilize the GLU architecture. The LLMs with original FFN are not covered, as they suffer from the existing outliers rather than activation spikes. All models are sourced from the huggingface-hub2 repository.

  
**Model** & **Prefix** & \(\) & \(|M_{sun}|/|M|\) \\  LLaMA-2-7B & [BOS] all. & 6.68 & 17 / 128 \\ LLaMA-2-13B & [BOS] then, & 12.91 & 6 / 160 \\ LLaMA-2-70B & [BOS] Iâ€™. & 9.16 & 25 / 320 \\ Mixtral-7B & [BOS] how & 49.00 & 3 / 128 \\ Mixtral-8x7B & [BOS].) n & 4.03 & 191 / 608 \\ SOLAR-10.7B & [BOS] a 1 & 6.48 & 11 / 192 \\ Gemma-7B & [BOS]. Pitu & 10.65 & 5 / 112 \\ LLaMA-3-8B & [BOS] - nd & 6.64 & 6 / 128 \\ LLaMA-3-70B & [BOS] and, & 78.37 & 3 / 320 \\   

Table 2: Specifications for QFeM and QFeP used in experiments. \(|M|\) denotes the total number of linear layers in the LLM, and \(|M_{unq}|\) represents the number of unquantized layers for QFeM.

[MISSING_PAGE_FAIL:7]

proposed QFeM and QFeP improve at comparable levels. This indicates that the activation spikes present a direct cause of the significant decrease in quantization performance. Because the proposed methods are orthogonal, the performance slightly increases when incorporating both QFeM and QFeP compared to applying them individually.

Other GLU-implemented LLMs.For other LLMs that incorporate GLU, we investigated the effectiveness of our methods in mitigating the quantization bottleneck. As can be seen in Figure 5, our methods consistently remedy the performance drop caused by activation spikes. Noticeably, the Mixtral model demonstrates robustness towards the performance degradation. This indicates that the mixture of experts architecture, which divides the MLP experts by tokens, helps to alleviate the impact of the activation spikes. Meanwhile, addressing the activation spikes is not a sufficient complement for the Gemma model compared to other models. We attribute this to the choice of activation function among GLU variants; specifically, Gemma uses GeGLU, while other models employ SwiGLU.

### Combining Outlier Alleviation Methods

While our method focuses on the activation spikes, the inherent outlier values in the input activations remain. Here, we combine the prior outlier alleviation methods, such as SmoothQuant (SQ)  and OutlierSuppressionPlus (OSP) , to further improve the quantization error. In practice, our methods are utilized during the scale calibration phase of alleviation methods to mitigate the impact of activation spikes on scale migration between activations and weights. Table 4 demonstrates the evaluation results of applying the outlier alleviation methods solely and combining them with our methods. We find that there are cases where the alleviation method fails to recover the performance when quantizing the activations with per-tensor scheme.3 This indicates that alleviating the outlier scales, including the activation spikes, is challenging. With the QFeM, the activation spikes are excluded, and the accurate alleviation is enabled. In addition, the QFeP also benefits from the SQ method, as seen in the case of LLaMA-2 70B. Exceptionally, the OSP successfully addresses the activation spikes in the 13B and 70B cases.

### Ablation Study

For the QFeP, we designed a length-three prefix for the KV cache, including the BOS token, context token, and extra token for activation spike. Because the KV cache consumes the capacity of the pretrained sequence position, it raises a question about the length of the prefix. Therefore, we conduct ablation study for different prefixes for the KV cache. For the prefixes, we prepare random, BOS only, and both QFeP without and with the context token. We illustrate the results of ablation study in Figure 6. In all cases, the random prefix showcases the lowest performance. While the KV cache with the BOS token demonstrates inconsistent performance, our QFeP

    &  &  &  \\   & **ppl(\(\))** & **acc(\(\))** & **ppl(\(\))** & **acc(\(\))** & **ppl(\(\))** & **acc(\(\))** \\  SQ  & 9.907 & 61.08\% & 34.869 & 59.45\% & 8.800 & 70.25\% \\ +QFeM & **5.534** & **69.65\%** & **5.118** & **71.23\%** & **3.599** & **75.93\%** \\ +QFeP & 5.715 & 68.66\% & 6.551 & 69.33\% & 5.228 & 74.07\% \\  OSP  & 38.490 & 59.90\% & 5.148 & 71.29\% & 3.827 & 75.52\% \\ +QFeM & **5.493** & **69.37\%** & **5.099** & **71.37\%** & **3.559** & **75.92\%** \\ +QFeP & 5.642 & 68.95\% & 5.144 & 71.05\% & 3.752 & 75.36\% \\   

Table 4: Evaluation of outlier alleviation methods with QFeM and QFeP. We report perplexity on WikiText-2 and averaged accuracy of four zero-shot tasks. The same quantization scheme for used on both SQ and OSP. Per-tensor weight quantization results are provided in Appendix C.1.

Figure 6: Prefix ablation. Y-axis represents averaged accuracy of four zero-shot tasks.

consistently shows significant improvement. Importantly, the results imply that the sufficient prefix for the models exhibits differences. However, we emphasize that our KV design for QFeP shows improvements by large margins across all models.

### Computational Cost Analysis

The proposed methods require additional resources to evict the activation spikes. Therefore, we analyze the computational costs of the methods and compare them in various schemes. For comparison, we evaluate different activation quantization schemes: dynamic per-token, dynamic per-tensor, and static per-tensor, denoted as AQ1, AQ2, and AQ3, respectively. This distinction establishes strong baselines and demonstrates the potential of the methods. To calibrate the static scales, we estimate the absolute maximum value using the calibration dataset, which is used in Section 3.1.

Inference Latency.For each setting, we present the accuracy of the zero-shot tasks and inference latency of the fixed token sequence, as shown in Figure 7. While the fine-grained scheme (AQ1) shows a negligible accuracy drop, the counterparts (AQ2, AQ3) degrade with the quantization bottleneck. However, by applying our methods, the coarse-grained schemes achieve a competitive performance gain. For example, the combination of AQ2 and QFeM demonstrates the performance close to the AQ1 but with faster latency. The results signify that addressing the quantization bottleneck is important to accelerate the inference latency with coarser granularity. Specifically, the naive static quantization (AQ3), the fastest scheme, exhibits a significant decline. We hope that our work contributes to the future works, which address the remaining challenges in static quantization.

Memory Footprint.In Table 5, we record the maximum memory footprint of our methods. For QFeP, the additional memory is consistently required for the preserved KV cache. However, this memory overhead is much smaller than that used in the fine-grained quantization (AQ1), as QFeM utilizes only three tokens for the cache. Contrary to QFeP, QFeM shows inconsistent memory utilization. For example, the 7B model with QFeM exhibits memory usage similar to AQ2, while the 70B model with QFeM incur additional consumption for a sequence length of 1K. This is attributed to the use of W8A16 for the unquantization modules in QFeM. To tailor the memory usage or inference speed, an alternative strategy can be utilized for QFeM, such as applying fine-grained activation quantization to the unquantization modules instead of using W8A16.

## 6 Conclusion

We explore the quantization challenge of GLU activations for modern LLMs. We find that the GLU variants generates excessive activation scales, which cause significant quantization bottlenecks at the specific layers. Based on the systematic generation pattern of the activation spikes, we propose methods that address the spikes in a layer-wise (QFeM) and token-wise manner (QFeP). In the experiments, we confirm that the proposed methods effectively resolve the quantization bottlenecks and result in a large performance gain. We expect that our work sheds light on the potential challenges in future studies regarding quantization and facilitates the development of efficient LLM systems.

    &  \\   & 1K & 2K \\   \\  AQ1 & 8185MiB & 9516MiB \\ AQ2 & 8148MiB & 9474MiB \\ +QFeP & 8149MiB & 9478MiB \\ +QFeM & 8148MiB & 9474MiB \\   \\  AQ1 & 67756MiB & 69037MiB \\ AQ2 & 67648MiB & 68820MiB \\ +QFeP & 67651MiB & 68822MiB \\ +QFeM & 6783MiB & 68819MiB \\   

Table 5: Memory footprint.

Figure 7: Accuracy-latency comparison of different activation quantization schemes: dynamic per-token (AQ1), dynamic per-tensor (AQ2), and static per-tensor (AQ3).