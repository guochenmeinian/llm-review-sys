# Macro Placement

by Wire-Mask-Guided Black-Box Optimization

 Yunqi Shi, Ke Xue, Lei Song, Chao Qian

National Key Laboratory for Novel Software Technology, Nanjing University, China

School of Artificial Intelligence, Nanjing University, China

{shiyq, xuek, songl, qianc}@lamda.nju.edu.cn

Corresponding Author

###### Abstract

The development of very large-scale integration (VLSI) technology has posed new challenges for electronic design automation (EDA) techniques in chip floorplanning. During this process, macro placement is an important subproblem, which tries to determine the positions of all macros with the aim of minimizing half-perimeter wirelength (HPWL) and avoiding overlapping. Previous methods include packing-based, analytical and reinforcement learning methods. In this paper, we propose a new black-box optimization (BBO) framework (called WireMask-BBO) for macro placement, by using a wire-mask-guided greedy procedure for objective evaluation. Equipped with different BBO algorithms, WireMask-BBO empirically achieves significant improvements over previous methods, i.e., achieves significantly shorter HPWL by using much less time. Furthermore, it can fine-tune existing placements by treating them as initial solutions, which can bring up to 50% improvement in HPWL. WireMask-BBO has the potential to significantly improve the quality and efficiency of chip floorplanning, which makes it appealing to researchers and practitioners in EDA and will also promote the application of BBO. Our code is available at https://github.com/lamda-bbo/WireMask-BBO.

## 1 Introduction

EDA techniques have been widely employed to assist engineers in designing chips , while the rapid advancement of VLSI technology has led to an exponential growth in chip scale, posing significant challenges. Particularly, for the important chip floorplanning stage in EDA, which strives to optimize power, performance, and area metrics while adhering to constraints such as congestion and density , the number of cells to be placed on the chip canvas increases rapidly and their routing relationships also become more complex, requiring innovative and efficient methods.

During the floorplanning placement stage, the position of each cell on the chip canvas is established. A modern chip typically comprises thousands of macros (i.e., individual building blocks such as memories) and millions of standard cells (i.e., smaller basic components like logic gates). The designer provides a netlist, which outlines the design requirements and serves as a large-scale hypergraph containing numerous hyper-edges (also called nets) that represent the routing relationships among macros and standard cells. Traditionally, the placement problem is divided into two successive stages : macro placement, which is usually addressed by heuristic or learning methods , and standard cell placement, which is usually addressed by analytical solvers . After placing all the cells (including macros and standard cells), a routing stage is performed. The general flow of chip floorplanning and routing is illustrated in Figure 1. In this work, we concentrate on macro placement due to its greater impact on placement quality: Macros are often larger and more crucial for achieving optimal placement .

arlier methods often formulate macro placement as a rectangular packing problem, where solutions are represented by sequence pair (SP) , B\({}^{*}\)-tree , corner block list (CBL)  or other data structures [34; 27], and solve it by simulated annealing (SA) [1; 18; 24; 40]. This kind of method suffers from the poor scalability due to the quadratic complexity of decoding a genotype solution to a phenotype placement. Analytical methods [12; 13; 28; 29] place macros and standard cells simultaneously, and relax the task to a mathematical programming problem, which can be solved efficiently. However, they cannot guarantee the non-overlapping between cells, which is a hard constraint of cell placement. More recently, by dividing the chip canvas into discrete grids and formulating the task of placing macros onto grids step by step as a Markov decision process (MDP), reinforcement learning (RL) methods have been applied, showing promising performance [14; 15; 26; 32]. But their fast convergence (after only a few hundred evaluations) observed in experiments may imply that the huge search space of placement is still underexplored, and further improvement is expected. A detailed review of these existing methods is provided in Section 2.

In this paper, we propose a new BBO framework for macro placement. To allow better exploration, a solution is directly represented by the coordinates of all macros on the chip canvas. HPWL is used as the minimization objective function. The key of our framework is that in order to improve efficiency, we use an elaborate evaluation procedure, which greedily improves a solution (with the goal of minimizing HPWL while avoiding overlapping) before evaluation. Concretely, using the wire mask  to record the increment of HPWL by moving a macro to each candidate grid on the chip canvas, the macros in the solution are sequentially adjusted to the nearest best grid. This framework is briefly called WireMask-BBO, which can use any BBO algorithm to solve the resulting problem.

Experimental results on multiple popular benchmarks demonstrate that WireMask-BBO, when equipped with different BBO algorithms such as random search (RS), Bayesian optimization (BO), and evolutionary algorithms (EA), significantly outperforms the compared representative methods, including traditional BBO methods based on packing formulation, analytical methods, and RL methods. Especially, WireMask-EA (i.e., WireMask-BBO equipped with EA) generates the highest-quality placement in 6 out of 7 different chip benchmarks, and surpasses the state-of-the-art MaskPlace  in 8 minutes on average. Besides, as an optimization-based method, WireMask-BBO can fine-tune any existing placement, regardless of how it was generated. That is, WireMask-BBO can be combined with any existing macro placement method as post-processing. Our experiments show that such fine-tuning can lead to an improvement of up to 50% in the objective HPWL.

Our main contribution is introducing the general framework WireMask-BBO, while not developing new BBO algorithms. In fact, our experiments show that even employing simple BBO techniques has led to superior performance over previous methods. We will open-source WireMask-BBO and use it as an optimization benchmark to encourage the invention of more efficient BBO algorithms for solving macro placement problems, as well as broaden the application scenario of BBO.

## 2 Background

In this section, we introduce the macro placement problem, and the existing methods which can be generally categorized into packing-based, analytical, and grid-based RL methods.

Figure 1: General flow of chip floorplanning and routing, where the routing stage basically relies on the placement result. We focus on the macro placement task in this paper.

### Macro Placement

The input for a macro placement problem constitutes a netlist \(H=(V,E)\), where \(V\) denotes the information (i.e., height and width) about all cells designated for placement on the chip, and \(E\) is a hyper-graph comprised of hyper-edges \(e_{i} E\), which encompasses multiple cells (including both macros and standard cells) and signifies their interconnectivity during the routing phase. A macro placement solution consists of the positions of all macros \(\{v_{i}\}_{i=1}^{k}\) with the coordinates of each macro \(v_{i} V\) on the chip canvas expressed as \((x_{i},y_{i})\), where \(k\) denotes the total number of marcros. To facilitate a comprehensive understanding of the macro placement problem, we present several key metrics for evaluating placement outcomes.

**HPWL** is the predominant metric for gauging placement quality, as it offers a precise estimation of the wirelength necessary for routing [9; 22; 38]. A shorter wirelength decreases delay and power consumption, enhancing overall performance . To calculate HPWL of a macro placement solution \(\), each hyper-edge \(e_{j} E\) corresponds to a rectangle area characterized by its lower-left endpoint, with coordinates (\(_{v_{i} e_{j}}x_{i},_{v_{i} e_{j}}y_{i}\)), and its upper-right endpoint, with coordinates (\(_{v_{i} e_{j}}x_{i},_{v_{i} e_{j}}y_{i}\)). That is, the rectangle is the smallest one bounding all cells within \(e_{j}\). Let \(w_{j}=_{v_{i} e_{j}}x_{i}-_{v_{i} e_{j}}x_{i}\) and \(h_{j}=_{v_{i} e_{j}}y_{i}-_{v_{i} e_{j}}y_{i}\) denote the width and height of the rectangle, respectively. Then,

\[(,H)=_{e_{j} E}(w_{j}+h_{j}).\] (1)

**Congestion** serves as a vital metric in determining the routability of a given placement, exerting a direct influence on the manufacturing process. A widely-adopted approach for approximating congestion is rectangular uniform wire density (RUDY) . The congestion of a grid on the canvas can be represented as the cumulative impact of all hyper-edge rectangle areas encompassing the grid. By selecting the top \(10\%\) congested grids (denoted as \(G^{}\)) and computing the mean of their congestion, the RUDY value of a macro placement solution is calculated as \(|}_{g_{i} G^{}}_{e_{j} E(g_{i})}+h_{j}}{w_{j} h_{j}}\), where \(|G^{}|\) is the size of \(G^{}\), \(E(g_{i})\) denotes the set of hyper-edges whose rectangle areas cover \(g_{i}\), and \((w_{j}+h_{j})/(w_{j} h_{j})\) measures the impact of the rectangle area of hyper-edge \(e_{j}\).

**Density** measures the overlap degree between cells by employing an electrostatic analogy . It is often treated as a penalty to diminish overlap, yielding a more uniform distribution of cells across the chip area [4; 13; 28; 29]. Further discussion will not be provided here, as our formulation ensures non-overlapping, which is a hard constraint of macro placement.

**Area** denotes the area of the minimum bounding rectangle that encloses all the macros. It was prevalent when the focus was on tightly packing macros and minimizing the area they occupied [10; 42]. However, when considering fixed-area chips as in [15; 26; 28; 32] and our work, the placement of cells optimized is to reduce wirelength and congestion rather than minimize the area.

### Packing-based Methods

As the focus was once on minimizing the bounding area of given macros, which can lead to a higher chip area utilization ratio , the packing formulation emerged as a natural and straightforward approach for the macro placement problem. Each macro, represented as a rectangle, has to be packed within a specified chip canvas, with the objective being to optimize the weighted sum of the area metric and HPWL metric. Several solution representation methods have been proposed, such as SP , B\({}^{*}\)-tree , CBL , etc. These genotype solutions will be mapped to concrete macro placement (phenotype) solutions for evaluation. SA is often employed [1; 18; 24; 40] to solve such BBO problems by perturbing the genotype to generate new offspring solutions and evaluating the corresponding phenotype to determine whether to accept the perturbation.

To handle both macros and standard cells, a divide-and-conquer idea is introduced [39; 43]. The standard cells are first clustered into blocks using either the logical hierarchy or min-cut-based partitioning algorithms [23; 37]. Placement is then performed on the mix of macro blocks and clustered standard cell blocks, often by SA using packing formulation [1; 2]. Finally, the standard cells are re-allocated by detailed placement. While reducing the problem size, clustering standard cells into rectangular blocks may cut some connections and hinder finding an optimal solution.

Recently, RL has been introduced to decide which perturbation operator should be selected and which macro should be perturbed by SA . Moreover,  formulates the CBL establishment as aMDP and constructs a CBL genotype step by step. These advancements continue to grapple with the drawbacks of packing, such as poor scalability, which cannot be solved fundamentally because the drawbacks come from the quadratic complexity of mapping from genotype to phenotype . Besides, at least one edge of each macro under the packing setting must be attached to another macro or the canvas's edge, making the placement quite congested, as visualized in Figure 2(a). Note that the congested macro placement will limit the space for subsequent standard cell placement, and lead to the bad performance of full placement, which will be shown in Table 3.

### Analytical Methods

Analytical methods [12; 13; 28; 29] place macros and standard cells simultaneously, and relax the full placement task to a mathematical programming problem, which can be solved efficiently. For example, DREAMPlace , a state-of-the-art and highly efficient analytical placement method, recasts the full placement task as \(\) WA\((,H)+(,H)\), where WA represents the smooth weighted-average wirelength (originally proposed by ) for approximating HPWL, Density denotes a differentiable density metric for penalizing overlapping, and \(\) is a trade-off factor. This problem is then solved numerically using classical mathematical optimization techniques (e.g., gradient descent), to rapidly generate high-quality full placement. Figure 2(b) shows a macro placement generated by DREAMPlace, which is better than that generated by packing in Figure 2(a). However, analytical methods cannot guarantee the non-overlapping between cells. Even employing macro placement legalization techniques, numerous overlaps may persist .

### Grid-based RL Methods

As the number of macros increases, packing-based methods encounter scalability challenges, while analytical methods may produce overlapping placements that are impractical for manufacturing . To meet the demands of modern chip design and fully leverage RL, the Graph placement published in _Nature_ divides the chip canvas into discrete grids, with each macro assigned discrete coordinates of grids, and formulates the placement problem as a MDP, wherein the agent decides the placement of the next macro at each step. Notably, no reward is given until the final step, when all macros are placed. The ultimate reward is the weighted sum of HPWL and congestion. Compared with packing-based methods, the grid-based design eliminates edge attachment and provides room for standard cell placement while offering improved scalability. The length of the MDP grows linearly with the number of macros, as opposed to the quadratic complexity of packing formulation . DeepPR  integrates convolutional and graph neural networks during the embedding stage, and introduces an intrinsic reward to promote exploration. However, DeepPR brings overlaps. Though PRNet  incorporates the overlap area into the reward function as a penalty, the non-overlapping issue still exists as observed in their experiments.

A key limitation of the above-mentioned methods is the absence of extrinsic rewards until the final step, leading to sub-optimal performance for a long MDP with over one thousand steps. To

Figure 2: Visualization of macro placement on the circuit benchmark _adaptec3_ using the proposed WireMask-EA and three representative methods. The macros are represented by yellow rectangles. The performance is evaluated in terms of HPWL and congestion; the lower the value, the better.

address this issue, MaskPlace  introduces a dense reward RL pipeline, incorporating a view mask for gathering global information, a position mask to ensure non-overlapping, and a wire mask to evaluate the placement of the current macro. Notably, the wire mask offers an immediate reward, calculated as the increase in HPWL after placing the current macro. These three masks are processed by a convolutional neural network and serve as input features for both the value and policy networks. MaskPlace can generate high-quality non-overlapping placement results in an affordable time. Figure 2(c) gives a placement example, which is better than that generated by packing and analytical methods as shown in Figures 2(a) and 2(b). From the experiments in , we can also observe that MaskPlace converges after only a few hundred evaluations, implying that the huge search space of placement may be still underexplored. The experimental results in Section 4 will confirm this conjecture, showing that our proposed framework will bring significant improvement.

## 3 Proposed Framework WireMask-BBO

This section is devoted to our proposed WireMask-BBO, where Section 3.1 introduces the problem formulation and Section 3.2 is concerned with optimization methods to solve the resulting problem.

### Wire-Mask-Guided Problem Formulation

**Solution representation.** To allow better exploration, a macro placement solution \(\) is directly represented by the coordinates of all macros \(\{v_{i}\}_{i=1}^{k}\), i.e., \(=(x_{1},y_{1},,x_{k},y_{k})\), where \((x_{i},y_{i})\) denotes the coordinates of the macro \(v_{i}\) on the chip canvas. For example, there are three macros A, B and C for the placement task in Figure 3, and thus a solution \(\) is represented by \((x_{1},y_{1},x_{2},y_{2},x_{3},y_{3})\).

**Objective evaluation.** The metric HPWL in Eq. (1) is used as the objective function to be minimized. But if optimizing in the solution space directly, it is difficult to efficiently find a solution that has a small HPWL value and satisfies the non-overlapping constraint. To improve the efficiency, a greedy improvement strategy is applied to a solution before evaluating it.

As in , the chip canvas is first divided into discrete grids. In the process of improving a solution greedily, each macro is moved to a grid by letting the macro's bottom-left corner situate at the bottom-left corner of the grid. The order of adjusting the position of a macro \(v_{i}\) is determined by the area of all the cells connected with \(v_{i}\), i.e., all the cells in the hyper-edges containing \(v_{i}\). Note that each hyper-edge contains a set of connected cells. The positions of all macros will be adjusted sequentially in the decreasing order of their corresponding computed areas, because a macro with a larger computed area implies connecting with more large cells and thus is intuitively more important.

Let \(v_{1}^{*},,v_{k}^{*}\) denote the ordered macros. Assume that the positions of \(v_{1}^{*},,v_{i-1}^{*}\) have been adjusted. When considering \(v_{i}^{*}\), a wire mask \(W_{i}\) introduced in  is first computed, which records the increase of HPWL by placing \(v_{i}^{*}\) to each candidate grid, given \(v_{1}^{*},,v_{i-1}^{*}\) already adjusted. Note that those grids that will lead to overlap or exceeding the canvas boundary after placing \(v_{i}^{*}\) are excluded. Then, \(v_{i}^{*}\) is moved to the grid with the least increment of HPWL. If such a grid is not unique, \(v_{i}^{*}\) is moved to the nearest one among them. This is actually a greedy step that moves \(v_{i}^{*}\) to the grid with the least increment on HPWL given the placement of \(v_{1}^{*},,v_{i-1}^{*}\). This process is repeated until the positions of all the macros have been adjusted. The HPWL of the resulting solution with all the adjusted macros is treated as the objective value of the original solution. Thus, a solution and its improved version in objective evaluation can be viewed as the genotype and phenotype representation of a macro placement. The detailed process of objective evalution is presented in Algorithm 1.

Figure 3 gives an example illustration of objective evaluation. For the input netlist \(H=(V,E)\), \(V\) contains three macros A, B and C, and the hyper-graph \(E\) contains two hyper-edges: one encompasses macros A and B, and the other encompasses A and C. Each hyper-edge signifies the interconnectivity of the macros contained by it. The chip canvas is partitioned into \(5 5\) grids. Assume that the width and height of each grid is both 1. The solution to be evaluated (as shown in Figure 3(a)) consists of the positions of macros A, B and C. According to the hyper-graph \(E\), we know that during the routing phase, macro A is connected with B and C, while macro B and C are both connected with only A. Thus, the corresponding areas computed in line 1 of Algorithm 1 are decreasingly ordered as A, B and C, which is just the order in line 2 to adjust the positions of macros sequentially.

When trying to adjust the position of macro A, a wire mask is first computed as in line 5 of Algorithm 1, which is shown in Figure 3(b), where the number in each grid is the increment of HPWLled by placing macro A in that grid. For example, if placing macro A in the center grid as shown in Figure 3(c), both the two hyper-edges correspond to the smallest rectangle bounding macro A (i.e., the red and black dotted square in Figure 3(c)) for computing HPWL in Eq. (1), and thus the corresponding HPWL is 6, which is the sum of half perimeters of these two rectangles. As the initial HPWL before placing macro A is 0, the increment of HPWL is 6. Note that when adjusting the position of a macro, its bottom-left corner must be situated at the bottom-left corner of a grid, and grids without numbers in the wire mask indicate that the current macro should not be placed there due to overlap or exceeding the canvas boundary. The underlined italic number in the wire mask denotes the least HPWL increment, representing the locally optimal choice, i.e., the set \(Q\) in line 6 of Algorithm 1. Then, as shown in lines 7-8 of Algorithm 1, macro A is placed at the local optimal grid, which has the smallest Euclidean distance to it. The coordinate of macro A in the original placement is denoted by the red star in Figure 3(b), and thus it is adjusted to be situated at the grid closest to it, as shown in Figure 3(c).

Figure 3: An example illustration of objective evaluation of WireMask-BBO.

The positions of macros B and C are adjusted similarly. Figure 3(c) shows the adjusted placement of macro A, and also the wire mask when trying to place macro B. Figure 3(d) shows the adjusted placement of macros A and B, and also the wire mask when trying to place macro C. Figure 3(e) gives the final improved placement after adjusting the positions of all macros. As HPWL is the sum of all hyper-edges' bounding rectangles' half perimeters, these rectangles can be updated each time a macro is placed, as shown by the red and black dotted squares in Figure 3. That is, for any individual macro, it is only necessary to update the bounding rectangles of its associated hyper-edges and compute the increase in their half perimeters. Thus, the calculation of HPWL can be performed incrementally, as in line 9 of Algorithm 1. In Figure 3, the increment of HPWL after placing macros A, B and C is 6, 3 and 2, respectively, leading to the HPWL value 11 of the final improved placement. Note that the red and black dotted bounding rectangles in Figure 3 are shown for illustrative purposes, while the actual HPWL calculation in our experiments is based on pin information.

Therefore, we have formulated macro placement as a black-box optimization problem, where the genotype-phenotype mapping is greedily guided by wire mask. Figures 3(a) and (e) give an example of genotype and phenotype representation. An algorithm for solving this problem will search in the genotype space, where the goodness of a genotype solution is estimated by the objective value of its corresponding phenotype. When an algorithm terminates, the corresponding phenotype of the generated genotype solution will be output as the final macro placement. Note that by the wire-mask-guided mapping process, the phenotype solution is guaranteed to have no overlap, and thus an algorithm can search in the genotype space without considering constraints.

### Black-Box Optimization

The above formulated problem can be solved by any BBO algorithm. In our experiments, we employ three simple ones, random search (RS), Bayesian optimization (BO)  and evolutionary algorithm (EA) . RS randomly allocates all macros in a solution and evaluates it, recording the historical best. For BO, we adopt the efficient TuRBO approach  to directly optimize the continuous coordinates \((x_{1},y_{1},,x_{k},y_{k})\) of all macros, resulting in a dimension of \(2k\), where \(k\) is the number of macros. For EA, we choose the simple (1+1)-EA [6; 49], which maintains only one solution and iteratively improves it by mutation. We design the mutation operator by randomly selecting two macros and exchanging their coordinates in a solution. Our experiments will show that using these three simple BBO algorithms has been sufficient for the superior performance over previous methods. It is expected to design better BBO algorithms for the proposed formulation of macro placement.

By adopting the grid-based discretization and designing the wire-mask-guided greedy genotype-phenotype mapping, the proposed framework WireMask-BBO can efficiently generate a non-overlapping high-quality placement, addressing the poor scalability issue of packing-based methods as well as the overlapping issue of analytical methods. The use of black-box optimization enhances the exploration ability, making WireMask-BBO able to surpass the state-of-the-art RL-based method MaskPlace . Figure 2(d) visualizes a placement generated by WireMask-BBO equipped with EA, which is better than that by SP-SA (a representative packing-based method) , DREAMPlace (a representative analytical method)  and MaskPlace , as shown in Figures 2(a), 2(b) and 2(c).

## 4 Experiments

We mainly empirically test our method on the ISPD2005 benchmark , which was originally proposed as a standard cell placement benchmark with fixed macros. Following conventional practice [15; 14; 26], we modify all macros to be movable for the macro placement problem. The ISPD2005 benchmark contains eight chips, i.e., _adapter1-4_ and _bigblue1-4_. Note that for the _bigblue2_ chip, which has over 20,000 macros and 30,000 macro-related hyper-edges, a single objective evaluation by step-by-step placement costs more than an hour. Thus, we do not include this chip in our experiments as . For each chip, the canvas is partitioned into approximately 150\(\)150 grids heuristically. The detailed statistics (e.g., the number of macros, partitions, etc.) of the chips are provided in Appendix A.

We compare WireMask-BBO with several representative macro placement methods, including the packing-based SP-SA , three analytical methods NTUPlace3 , RePlace , DREAMPlace , and three RL-based methods Graph placement , DeepPR , MaskPlace . As introduced in Section 3.2, we equip the proposed WireMask-BBO framework with RS, BO and EA,denoted as WireMask-RS, WireMask-BO and WireMask-EA, respectively. For the employed method TuRBO  for BO, we use the common hyper-parameters. For the EA, its initial solution is set as the best among 100 random solutions. All experiments are run on two Intel Xeon Platinum 8171M CPUs, each with 26 cores and 52 threads.

**Main results.** Table 1 gives the detailed results of running each method using five random seeds. The runtime for each run of WireMask-BBO is set as 1,000 minutes. The results of analytical and RL-based methods are directly from . Note that the analytical method NTUPlace3 is deterministic, and thus has no standard deviation. We compute the rank of each method on each chip as in , which are averaged in the last column of Table 1. WireMask-RS, WireMask-BO and WireMask-EA achieve the three highest ranks, disclosing the effectiveness of the proposed general framework WireMask-BBO. Among these three variants, WireMask-EA performs the best, which has the highest rank 1.43 and achieves the smallest HPWL value on 5 out of the 7 chips. RS relies solely on random sampling without leveraging any search history. BO performs well in many low-dimensional tasks (typically when the dimension \(d 20\)), but suffers from the curse of dimensionality due to the time-consuming cost of updating the Gaussian process surrogate model and optimizing the acquisition function . For example, in our experiments where \(d\) (i.e., 2 times the number of macros) is always larger than 1000, EA can sample much more solutions (about 2-7 times as shown in Table 9 of Appendix B) than BO during the 1000-minutes running. Compared with any previous method, WireMask-EA is significantly better on at least 6 out of the 7 chips, by the Wilcoxon rank-sum test with significance level 0.05. It is outperformed by RePlace and DREAMPlace on the chip _adapter4_, implying the suitability of analytical methods for this particular problem.

**Running time analysis.** As shown in Table 1, any variant of WireMask-BBO always performs better than the state-of-the-art MaskPlace , which ranks the highest among the compared previous methods. While  did not offer explicit training time details, the authors state a 200-minute convergence time in response to our inquiry. Next, we examine the efficiency of WireMask-BBO when compared with MaskPlace. Taking MaskPlace as the baseline, we plot the curve of HPWL over the wall clock time for WireMask-BBO in Figure 4. Each variant of WireMask-BBO surpasses MaskPlace very quickly. Particularly, WireMask-EA requires only 39, 8, 0.37, 0.62, 0.15, and 3 minutes, respectively, with an average of 8 minutes to surpass MaskPlace across six benchmark chips. This is notably faster than the 200-minute convergence time reported for MaskPlace. We have excluded the _bigblue4_ chip in Figure 4, because the 1,000-minute search for WireMask-EA only completes its initialization on this large-scale chip. On the chips _adapter3_ and _adapter4_, WireMask-EA actually outperforms MaskPlace after only a single greedy placement guided by wire mask, implying that MaskPlace fails to balance exploration and exploitation.

**Performance on congestion metric.** Aside from HPWL, congestion and density are also vital metrics as introduced in Section 2.1. As our framework WireMask-BBO maintains the non-overlapping property, density constraint does not need to be considered. Here, we evaluate placement congestion and compare it to the results of MaskPlace  and SP-SA  in Table 2. We normalize the congestion values by setting WireMask-EA's congestion to 1.00. The MaskPlace placements are provided by its authors2, while the SP-SA and WireMask-BBO placement results are obtained from a

   Method & Type & adopted & adapted & adapted & adapted & adapted & labeled & bibble & bibble(\( 10^{7}\)) & \(+/-/-\) & Avg. Rank \\  SP-SA & Praking & 188.844\(\)42.17 & 179.86\(\)8.75 & 113.54\(\)7.56 & 1200(\)4.25 & 5.12\(\)143 & 164.70\(\)9.53 & 5.29\(\)2.73 & 0/70 & 6.86 \\ NTUPlace3  & Analytical & 26.62 & 321.7 & 328.44 & 462.93 & 2.28 & 485.53 & 48.38 & 0/70 & 9.00 \\ RePlace  & Analytical & 16.99 \(\)1.20 & 113.52\(\)2.90 & 111.21 & 11.69 & 7.641\(\)0.55 & 2.486 & 119.84\(\)3.43 & 11.00\(\)0.73 & 1/60 & 5.28 \\ DREAMFilter  & Analytical & 158.81 \(\)1.64 & 170.94\(\)2.72 & 129.14 & 5.055 & **37.41\(\)0.87** & 4.24\(\)0.46 & 1019.29\(\)2.91 & 125.21\(\)6.14 & 1/60 & 4.86 \\ Graph  & RL & 30.10\(\)2.98 & 351.71\(\)3.20 & 38.38 & 18.35 & 131.54\(\)2.97 & 2.058\(\)1.29 & 35.78\(\)4.73 & 53.55\(\)4.06 & 0/70 & 9.00 \\ DeepF  & RL & 1.991 \(\)1.98 & 351.67\(\)2.30 & 38.16 & 131.86\(\)2.57 & 2.38\(\)5.65 & 34.08\(\)2.18 & 63.00\(\)4.44 & 0/70 & 8.86 \\ MaxMaxPlace  & RL & 6.38\(\)0.55 & 73.75\(\)6.53 & 64.44\(\)3.60 & 32.11\(\)0.65 & 2.91\(\)0.65 & 91.11\(\)7.83 & 10.17\(\)0.99 & 0/70 & 4.28 \\ WireMask-RS & Ours & 6.13\(\)0.05 & 59.28 \(\)1.60 & 60.04\(\)2.06 & 62.06 & 2.292 & 10.60\(\)0.52 & **5.26\(\)0.17** & **5.02\(\)0.17** & **0.52\(\)** & 2.57 \\ WireMask-BO & Ours & 6.07\(\)0.14 & 59.71\(\)3.34 & 61.00\(\)2.08 & 63.86\(\)1.01 & 2.14\(\)0.03 & 67.58\(\)6.49 & 6.52\(\)0.18 & 0/3/4 & 2.86 \\ WireMask-AA & Ours & **5.14\(\)0.07** & **52.43\(\)2.23** & **57.78\(\)1.16** & **53.79\(\)1.02** & **2.12\(\)0.01** & **59.87\(\)3.40** & **5.28\(\)** & 0.25 & **1.43** \\   

Table 1: HPWL values (\( 10^{5}\)) obtained by ten compared methods on seven chips. Each result consists of the mean and standard deviation of five runs. The best (smallest) mean value on each chip is bolded. The symbols ‘\(+\)’, ‘\(-\)’ and ‘\(\)’ indicate the number of chips where the result is significantly superior to, inferior to, and almost equal to WireMask-EA, respectively, according to the Wilcoxon rank-sum test with significance level 0.05.

1,000-minute search using the same random seed. The results show that though optimizing HPWL, WireMask-BBO can also achieve smaller congestion. The reason is that the RUDY approximation of congestion is sometimes positively related to the HPWL metric. Given a macro placement solution, the HPWL in Eq. (1) is computed as the sum of the rectangle's half-perimeter of hyper-edge, i.e., \(_{e_{j} E}(w_{j}+h_{j})\), where \(e_{j}\) denotes a hyper-edge, \(E\) denotes the hyper-graph comprised of all hyper-edges, \(w_{j}\) and \(h_{j}\) denote the width and height of the rectangle corresponding to \(e_{j}\), respectively. The RUDY measures the overall congestion on the canvas, and the congestion of each grid \(g_{i}\) on the canvas is calculated by the cumulative impact of all hyper-edges encompassing the grid. Note that a hyper-edge \(e_{j}\) will add an impact to each of its covered grids by \(}+}\). Then, the overall congestion of all grids is \(_{g_{i}}_{e_{j} E(g_{i})}}+}=_{e_{j } E}w_{j} h_{j}(}+})=_{e_{j} E }(w_{j}+h_{j})=\), where \(E(g_{i})\) denotes the set of hyper-edges whose corresponding rectangle covers the grid \(g_{i}\). The first equality holds because the number of times of a hyper-edge \(e_{j} E\) enumerated in LHS is equal to the number of grids covered by it, which is \(w_{j} h_{j}\). Thus, we can observe a positive relation between RUDY and HPWL. Besides our results, Table 4 in MaskPlace  and Table 4 in ChiPFormer  have also shown that the best HPWL can lead to the best congestion. However, a lower HPWL does not necessarily lead to a lower RUDY, because RUDY only considers the top-10% congested grids as introduced in Section 2.1.

**Full placement results.** Table 3 shows the results of different methods on the full placement task involving both macros and standard cells. We utilize PRNet  and DREAMPlace  as baselines, because both of them are designed to handle mixed-size placement tasks. The other five macro placement methods first optimize the macro placement, fix the macro positions, and then employ DREAMPlace to optimize the standard cell placement exclusively. The mean\(\)std values are derived from DREAMPlace standard cell placement using five different random seeds. The results of PRNet are directly from . Although WireMask-EA achieves the best performance on only one chip, i.e., _adapter4_, it attains the highest average rank. Compared with the mixed-size placement optimization methods PRNet and DREAMPlace, WireMask-EA does not explicitly optimize the full

  Benchmark &  &  &  &  &  &  &  &  \\ Mattes & HPWL & Coog. & HPWL & Coog. & HPWL & Coog. & HPWL & Coog. & HPWL & Cong. & HPWL & Cong. & HPWL & Cong. & HPWL & Cong. \\  Sp-SA  & 18.77 & 4.21 & 117.63 & 1.34 & 123.02 & 2.03 & 102.94 & 1.54 & 5.30 & 2.09 & 136.16 & 1.50 & 190.00 & 2.72 & 4.86 & 4.71 \\ MgOTrace  & 6.56 & 1.22 & 79.98 & 1.63 & 79.32 & 1.25 & 75.75 & 1.37 & 2.42 & 1.63 & 2.61 & **6.64** & **8.9** & / & / & 4.40 & 3.67 \\ WireMask-RB & 6.09 & 1.01 & 57.31 & 1.04 & 60.91 & 1.04 & 60.02 & **0.98** & 2.18 & 1.09 & 63.86 & 1.01 & **8.21** & 1.10 & 2.29 & 2.43 \\ WireMask-BO & 6.14 & 1.02 & 55.31 & **6.99** & 58.67 & 1.06 & 61.67 & 1.06 & **2.10** & **0.94** & 68.85 & 1.19 & 8.39 & 1.07 & 2.29 & 2.43 \\ WireMask-EA & **5.81** & **1.00** & **49.32** & 1.00 & **56.56** & **1.00** & **58.79** & 1.00 & 2.12 & 1.00 & **64.85** & 1.00 & 8.45 & **1.00** & **1.43** & **1.57** \\  

Table 2: Comparison on HPWL (\( 10^{5}\)) and Congestion (Cong.).

Figure 4: HPWL (\( 10^{5}\)) vs. wall clock time of WireMask-BBO, where the shaded region represents the standard error derived from 5 independent runs.

placement wirelength; thus, its best overall performance confirms the contribution of high-quality macro placement to an overall superior final placement.

**Fine-tuning results.** In fact, WireMask-BBO can be combined with any existing macro placement method for post-processing. The placement generated by any existing method can be treated as the initial solution of WireMask-BBO and then further improved. Table 4 shows the HPWL results of SP-SA and MaskPlace before and after 1,000 minutes of fine-tuning by WireMask-EA, with the average improvement ratio of \(53.93\%\) and \(17.06\%\), respectively. Compared to Table 1, fine-tuning the placement of MaskPlace leads to the best HPWL value on the two chips _adapted1_ and _bigblue1_.

**Additional results.** We propose a post local search procedure to further improve final placement results. We investigate the influence of the two hyper-parameters of WireMask-BBO, i.e., number of partitions in chip canvas discretization, and adjustment order of macros in objective evaluation. For WireMask-EA, the best-performed variant of WireMask-BBO, the influence of different mutation operators is also examined. We compare the number of evaluations of WireMask-BBO methods in 1000 minutes. Furthermore, we test on the _ariane_ RISC-V CPU design benchmark , still showing the clear superiority of WireMask-BBO over previous methods. We finally include comparisons with two concurrent advanced methods, i.e., ChiPFormer  and AutoDMP , and our WireMask-EA still maintains the superior performance. These results are provided in Appendix B.

## 5 Conclusion

This paper proposes the general framework WireMask-BBO for macro placement, which adopts a wire-mask-guided greedy genotype-phenotype mapping and can be equipped with any BBO algorithm. Extensive experimental results show that WireMask-BBO is clearly superior to previous packing-based, analytical, and RL-based methods. Furthermore, it can be combined with any existing macro placement method to further improve the final placement. Though showing significant potential, WireMask-BBO also has some limitations. First, it can only deal with macro placement, leaving standard cells for analytical placers. Second, its performance is limited for chips with a large number of macros due to the expensive objective evaluation. This, however, can be alleviated by equipping with high-dimensional BBO algorithms  or designing specific efficient BBO algorithms for macro placement, which is a very interesting future work. Our method does not have negative social impacts.

   Method & adapted1 & adapted2 & adapted3 & adapted4 & bigblue1 & bigblue3 & Avg. Imp. \\  SP-SA  & 18.84 & 117.36 & 115.48 & 120.03 & 5.12 & 164.70 &  \\ +WireMask-EA (1000min) & \(6.02 0.11\) & \(60.35 4.41\) & \(57.88 0.62\) & \(59.50 0.92\) & \(2.21 0.02\) & \(82.68 18.17\) & \\  MaskPlace  & 6.56 & 79.98 & 79.32 & 75.75 & 2.42 & 82.61 &  \\ +WireMask-EA (1000min) & \(5.84 0.10\) & \(61.43 1.23\) & \(59.24 2.71\) & \(60.35 1.38\) & \(2.10 0.01\) & \(74.93 7.79\) & \\   

Table 4: HPWL \(( 10^{5})\) values obtained after fine-tuning existing placements by running WireMask-EA for 1,000 minutes. The last column, Avg. Imp., denotes the average improvement ratio across six chips, obtained by comparing the HPWL values before and after fine-tuning.

   benchmark & adapted1 & adapted2 & adapted2 & adapted3 & adapted4 & bigblue1 & bigblue3 & \(+j-r\) & Avg. Rank \\  PBNet  & **8.28** & 12.33 & 23.24 & 23.49 & 14.10 & 46.86 & **1000.3** & 22.5/0 & 5.29 \\ DREAMMPC  & 11.10 \(\)1.31 & 138.41 \(\)1.74 & **173.63.09** & **237.37** & **11.33** & **106.48** & **23.651** & **23.655** & **17.85** & **23.23** & 2/4/1 & 3.57 \\ SP-SA -BreaMP -BreaMP & 10.86 \(\)0.18 & 14.80 \(\)0.01 & 30.63 \(\)0.82 & 28.89 \(\)0.02 & 10.70 \(\)0.01 & 65.01 \(\)0.12 & 20.79 \(\)0.36 & 0/7/0 & 6.29 \\ MapPLPL -BreaMP & 10.86 \(\)0.10 & 12.98 \(\)0.28 & 21.64 \(\)0.07 & 25.24 \(\)0.01 & 10.64 \(\)0.01 & 54.98 \(\)0.06 & 1/6 & 0/6/0 & 5.00 \\ WireMask-ES-BBMEMP & 10.94 \(\)0.02 & **0.97** & **0.02** & 22.76 \(\)0.01 & 22.09 \(\)0.01 & 10.41 \(\)0.03 & 42.58 \(\)0.20 & 20.62 \(\)0.08 & 2/4/1 & 3.00 \\ WireMask-BBO-BRMEMPC & 9.19 \(\)0.26 & 12.87 \(\)0.01 & 26.16 \(\)0.04 & 26.76 \(\)0.01 & 10.56 \(\)0.01 & 56.08 \(\)0.32 & 12.28 \(\)0.06 & 1/6/0 & 4.43 \\ WireMask-EA+DEREAMMPC & 8.93 \(\)0.01 & 9.20 \(\)0.05 & 21.72 \(\)0.01 & **20.51\(\)0.01** & 10.35 \(\)0.02 & 42.52 \(\)0.11 & 171.23 \(\)0.48 & **2.14** \\   

Table 3: Comparison of HPWL values \(( 10^{7})\) on the full placement task involving both macros and standard cells. The best (smallest) mean value on each chip is bolded. The symbols ‘+’, ‘-’ and ‘\(\)’ indicate the number of chips where the result is significantly superior to inferior to, and almost equivalent to WireMask-EA+DREAMMPC, respectively, according to the Wilcoxon rank-sum test with significance level 0.05.