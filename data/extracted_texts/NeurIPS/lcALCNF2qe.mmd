# Towards Universal Mesh Movement Networks

Mingrui Zhang\({}^{1}\) Chunyang Wang\({}^{1}\) Stephan Kramer\({}^{1}\) Joseph G. Wallwork\({}^{2}\)

Siyi Li\({}^{1}\) Jiancheng Liu Xiang Chen\({}^{3}\) Matthew D. Piggott\({}^{1}\)

\({}^{1}\)Imperial College London \({}^{2}\)University of Cambridge \({}^{3}\)Noah's Ark Lab, Huawei {mingrui.zhang18, chunyang.wang22,s.kramer}@imperial.ac.uk

{siyi.li20,m.d.piggott}@imperial.ac.uk

jw2423@cam.ac.uk xiangchen.ai@outlook.com ljcc0930@gmail.com

###### Abstract

Solving complex Partial Differential Equations (PDEs) accurately and efficiently is an essential and challenging problem in all scientific and engineering disciplines. Mesh movement methods provide the capability to improve the accuracy of the numerical solution without increasing the overall mesh degree of freedom count. Conventional sophisticated mesh movement methods are extremely expensive and struggle to handle scenarios with complex boundary geometries. However, existing learning-based methods require re-training from scratch given a different PDE type or boundary geometry, which limits their applicability, and also often suffer from robustness issues in the form of inverted elements. In this paper, we introduce the Universal Mesh Movement Network (UM2N), which - once trained - can be applied in a non-intrusive, zero-shot manner to move meshes with different size distributions and structures, for solvers applicable to different PDE types and boundary geometries. UM2N consists of a Graph Transformer (GT) encoder for extracting features and a Graph Attention Network (GAT) based decoder for moving the mesh. We evaluate our method on advection and Navier-Stokes based examples, as well as a real-world tsunami simulation case. Our method out-performs existing learning-based mesh movement methods in terms of the benchmarks described above. In comparison to the conventional sophisticated Monge-Ampere PDE-solver based method, our approach not only significantly accelerates mesh movement, but also proves effective in scenarios where the conventional method fails. Our project page can be found at https://erizmr.github.io/UM2N/.

## 1 Introduction

Various natural phenomena are modeled by Partial Differential Equations (PDE). The accurate and efficient approximation of the solutions to these complex and often nonlinear equations represents a fundamental challenge across all scientific and engineering disciplines. To solve real-world PDEs, many numerical methods require a computational mesh or grid to discretize the spatial domain. The quality of this mesh significantly impacts the balance between a numerical solution's accuracy and the computational cost required to obtain it. To maintain high-resolution everywhere in the domain is computationally expensive. Many systems modeled by PDEs however are multi-resolution in nature. For example, a small part of the system may be highly dynamic, while other regions are quasi-stationary; alternatively, some locations may be more important while others less important to the question being considered by the calculation . While a uniform, high-resolution mesh can be utilized to capture the dynamics or what is most important accurately, this is often wasteful of finite, precious computational resources and comes with sustainability implications .

An active body of research is focused on developing deep learning based methods to accelerate the PDE-solving process by learning surrogate neural solvers . A learned solver can output PDEsolutions directly given the physical parameters, and boundary conditions of a PDE. However, these methods encounter challenges such as not being able to guarantee physical plausibility of the PDE solution, weak generalization ability, and low data efficiency.

An alternative approach to improve the efficiency of a PDE solver is to utilize _mesh adaptation_, which is a technique for distributing the mesh according to numerical accuracy requirements. Two main categories of mesh adaptation techniques can be identified: \(h\)-adaptation and \(r\)-adaptation. \(h\)-adaptation refines or coarsens the mesh resolution dynamically through topological operations such as adding/deleting nodes and swapping element edges/faces. In contrast, \(r\)-adaptation (or _mesh movement_) relocates or moves mesh nodes, keeping the mesh topology and thus the number of elements and vertices in the mesh unchanged . These traditional mesh adaptation techniques can help reduce PDE-solving costs, but the mesh adaptation process itself may come at the cost of significant computational overhead.

Deep learning based methods have been proposed to accelerate mesh adaptation. . Most previous methods focus on \(h\)-adaptive refinement . Some existing works focus on learning error indicators or Riemannian metrics (which account for element shape and anisotropy, as well as size)  to guide the mesh adaptation process. The learned indicator or metric is then fed into a traditional remesher for mesh generation, or a mesh optimizer, which overall limits the performance of these works to being no better than traditional methods, especially in terms of efficiency. Reinforcement learning based methods show potential to improve the mesh adaptation task, but are difficult to train with low data efficiency . Only a small number of works focus on \(r\)-adaptation.  investigated supervised and unsupervised learning based mesh movement methods. However, the proposed methods require re-training from scratch given a different PDE or geometry, which limits their applicability. In addition, the unsupervised learning method requires significant GPU memory and suffers from long training times, which makes re-training even more prohibitive for large scale problems.

Targeting the generalization ability and efficiency of mesh movement, here we introduce the Universal Mesh Movement Network (UM2N), a two stage, deep-learning based model that learns to move the computational mesh guided by an optimal-transport approach driven by solutions of equations of Monge-Ampere (MA) type. Given an underlying PDE to solve numerically, the process of MA based mesh movement includes choosing a suitable monitor function (_i.e._, a measure for the desired mesh density) and solving an auxiliary PDE whose solution prescribes the movement of the mesh. The Monge-Ampere equation is an example of such an auxiliary PDE, which results in mesh movement with attractive theoretical properties , but whose solution comes at a significant computational cost. Therefore, we decouple the underlying PDE solve and the mesh movement process. The learning of the mesh movement process is essentially learning to solve the auxiliary Monge-Ampere equation.

The proposed UM2N consists of a Graph Transformer based encoder and a Graph Attention Network (GAT)  based decoder.

Element volume loss is selected within the training loss, instead of the coordinates loss used in previous works . This offers the advantage that element volume loss not only provides supervision signals but also penalizes negative volumes (i.e., inverted elements), thereby reducing mesh tangling and enhancing robustness. We construct a PDE-independent dataset by generating random generic fields for model training. The trained model can be applied in a zero-shot manner to move meshes with different sizes and structure, for solvers applicable to different PDE types and boundary geometries. We comprehensively demonstrate the effectiveness of our methods on different cases including advection, Navier-Stokes examples, as well as a real-world tsunami simulations on meshes with different sizes and structures. Our UM2N outperforms existing learning-based mesh movement methods in terms of the benchmarks described above. In comparison to the sophisticated Monge-Ampere PDE-solver based method, our approach not only significantly accelerates mesh movement, but also proves effective in scenarios where the conventional method fails. The trained model can be directly integrated into any mesh based numerical solvers for error reduction and acceleration in a non-intrusive way, which can benefit various engineering applications suffering trade-offs between accuracy and computational cost.

Our main contributions are listed as follows:* We present the UM2N framework, which once trained can be applied in a non-intrusive, zero-shot manner to move meshes with different sizes and structures, for solvers applicable to different PDE types and boundary geometries.
* We propose PDE-independent training strategies and mesh tangling aware loss functions for our Graph Transformer and GAT-based architecture.
* We demonstrate the universal ability of UM2N on different PDEs and boundary geometries: Advection, Navier-Stokes examples, and a real-world tsunami simulation case.

## 2 Related Works

**Neural PDE solver.** Neural PDE surrogate models can significantly accelerate the PDE solving process. There are three main groups of existing works. Physics-informed Neural Networks (PINNs) [6; 22; 23] are the first group, modeling the PDEs through implicit representations by neural networks. PINNs require knowledge of the governing equations and train neural networks with equation residuals from the PDEs with given boundary conditions and initial conditions. Neural operators are another group of methods for learning to solve PDEs which seek to learn a mapping from a function describing the problem to the corresponding solution function [7; 8; 24; 25; 26]. The third group is mesh-based PDE solvers with deep learning, including the utilization of CNNs and GNNs for processing structured and unstructured meshes [15; 27; 28; 29; 30; 31; 32]. Our method can be considered to be related to the neural operator approach, although it learns a mapping from monitor function values to the potential field describing the mesh movement instead of the PDE solution directly. In addition, the networks in the proposed model share similar ideas to mesh-based PDE solvers for processing unstructured meshes.

**Learning for mesh generation and adaptation.** Deep learning methods have been advanced for applications in mesh generation and adaptation. Two tasks need to be differentiated here, the first involves modeling the ideal mesh resolution or density, _e.g._ through learning a metric or error indicator. The second involves the step that actually adapts the mesh in response, where we can distinguish between \(h\)-adaptivity, in which the connectivity structure of the mesh is changed to refine or coarsen the mesh, and \(r\)-adaptivity which maintains the connectivity and only moves the vertices.

An example of the first task is MeshingNet  which employs a neural network to establish the requisite local mesh density, subsequently utilized by a standard Delaunay triangulation-based mesh generator. Similarly, the determination of optimal local mesh density for the purpose of mesh refinement is described in . In , the authors propose a learning-based model to determine optimal anisotropy to guide \(h\)-adaptation.  introduces a neural-network-based approach for predicting the sizing field for use with an external remesher. Instead of learning a metric, some works learn to manipulate the mesh directly. [11; 17; 18] formulate the \(h\)-adaptation process as a reinforcement learning paradigm, learning a policy that guides to adjust the mesh elements.

\(r\)-adaptation (or mesh movement) is generally formulated in a fundamentally different manner to \(h\)-adaptation. Leading \(r\)-adaptation methods are based on a mapping between a fixed reference computational domain and the physical domain encompassing the adapted mesh, which is established through the solution of a nonlinear auxiliary PDE.  first proposed the use of a GNN based mesh movement network.  investigated the unsupervised learning of mesh movement for improving performance of neural PDEs solvers.  introduced a learning based mesh movement method specially tailored for computation fluid dynamics simulation of airfoil design.

Our work focuses specifically on \(r\)-adaptation, _i.e._, mesh movement methods. The approaches proposed in previous work require re-training the model when applied to different problems, or can only generalize within a limited range of PDE parameters. We propose a mesh movement network that aims to be universal across applications to different PDEs without retraining.

## 3 Preliminaries and Problem Statement

**Monge-Ampere mesh movement.** A mesh movement problem can be defined as the search for the transformation between a fixed computational domain \(_{C}\), and a physical domain \(_{P}\). Coordinates in these spaces are denoted \(\) and \(\), respectively. The mesh \(_{C}\) defined in the computational domain is the original, often uniform mesh. The mesh \(_{P}\) defined in the physical domain is the adapted (or moved) mesh.1 The goal of mesh movement is to find a mapping \(=f()\) between the continuous coordinate fields of \(_{C}\) and \(_{P}\), although in practice we deduce a mapping of the discrete vertex sets of \(_{C}\) and \(_{P}\). While the coordinate transformation can also be used to accommodate time-dependent moving boundaries  or the optimisation of the shape of the domain, here we focus on its application to achieve variable resolution such that the solution \(u_{}\) of a PDE solved on the adapted mesh has higher accuracy than the solution \(u_{}\) solved on the original mesh.

A monitor function \(m\) over the spatial domain is used to specify the desired mesh density, which can be based on various characteristics of the solution field \(u\) of the PDE. It prescribes where the mesh should be refined or coarsened, _i.e._ large monitor values indicate where high mesh resolution is required. Therefore, the goal of the mesh movement process can be rephrased as finding a mapping so that \(m\) is equidistributed over the adapted (_i.e._, physical) mesh :

\[m()\ ()=,\] (1)

where \(\) is the Jacobian of the map \(=f()\) with respect to the computational coordinates \(\), \(()\) denotes the determinant of the Jacobian which corresponds to the relative change in volume under the transformation, and \(\) is a normalization constant. By using concepts from optimal transport theory , the problem can be constrained to have a unique solution, with the deformation of the map expressed in terms of the gradient of a scalar potential \(\) such that:

\[()=+_{}().\] (2)

Substituting the additional constraint described by equation (2) into equation (1) gives a nonlinear PDE of Monge-Ampere type:

\[m()\ (+(()))=,\] (3)

where \(\) is the identity matrix and \(()\) is the Hessian of \(\), with derivatives taken with respect to \(\), i.e, \(()_{ij}=}{_{i}_{j}}\). It should be noted that guarantees for existence and uniqueness, and convergence of solution methods for the Monge-Ampere equation generally rely on the domain being diffeomorphic with a convex domain (e.g. ). In practice, the method is known to break down in some cases where the domain is not simply-connected or has non-smooth boundaries.

The MA equation (3) is an auxiliary PDE which is purely associated with the the mesh movement process, and is independent of the underlying PDE or physical problem we wish to solve, i.e., the MA equation keeps the same form for different PDEs. This decoupling benefits learning-based methods in terms of generalization properties, _i.e._, a well-learned MA neural solver has the potential to be applied to different problems with a small cost of fine-tuning or even without re-training.

## 4 UM2N: Universal Mesh Movement Network

### Framework overview.

The proposed UM2N framework is shown in Fig. 1. Given an input mesh, vertex features and edge features are collected separately. The coordinates and monitor function values are gathered from the vertices and input into a graph transformer to extract embeddings. The embedding vector \(\) obtained from the graph transformer encoder is then concatenated with the extracted edge features \(\) to serve as the input for the Graph Attention Network (GAT) decoder. The decoder processes this combined input along with a mesh query to ultimately produce an adapted mesh.

**Graph Transformer encoder.** Transformers  are a popular architecture which have been successfully applied for neural PDE solvers [25; 26; 39]. They have strong expressivity and can naturally handle irregular data structures such as unstructured meshes. Their attention mechanism can capture both the local and global information for a vertex of interest in a mesh. Here we use a

Figure 1: Overview of Universal Mesh Movement Network.

graph transformer encoder as a feature extractor. The input features include the coordinates of the original mesh \(\) and monitor values \(m_{}\). The coordinates serve as the positional encoding. Features are concatenated and encoded into \(\) (query), \(\) (key) and \(\) (value) as inputs using MLPs for a self-attention module. The encoder output embedding \(\) are fed into a downstream GAT based deformer for mesh movement.

**Graph Attention Network (GAT) based decoder.** We choose GATs to construct our decoder. Its attention mechanism can help constrain the mesh vertex movement to within one hop of its neighbors which assists in alleviation of mesh tangling issues. The decoder consists of \(N\) GAT blocks. The first GAT block takes a mesh query \(\), and the embedding \(\) from the transformer encoder as well as the edge features \(\) as inputs. For each following \(k^{}\) block, the inputs consist of the coordinates of the initial mesh \(\), the coordinates of the intermediate moved mesh \(^{(k-1)}\) and extracted features from the previous layer \(^{(k-1)}\).

### PDE-independent dataset and training.

In the existing work of neural mesh movement [19; 20], proposed models are trained on solutions of PDEs, with the training data generated by solving one specific type of PDE, limiting generalizability of the trained model. Aiming here to train universal mesh movement networks, we construct a PDE-independent training dataset \(=\{=(,m_{};_{{}^{r}},_{r})\}\), where \(,m_{}\) denotes the original mesh and monitor values as the model's input, and \(_{{}^{r}},_{r}\) as the pre-calculated (reference) mesh's vertex coordinates and elements as ground truth. To build the dataset, we randomly generate generic solution fields, which are composed as the summation of a random number of Gaussian distribution functions centred in random locations, and with random widths in different directions to introduce anisotropy, samples are shown in Figure A1; refer to Appx. B for a detailed description. The generated fields can be interpreted as representing solutions of any PDE. For mesh movement, a widely used method to translate the PDE solution \(u()\) into a monitor function, is the Hessian based formula :

\[m()=1+,\] (4)

where \(\|H(u)\|\) indicates the Frobenius norm of the Hessian of \(u\) and \(\) is a user chosen constant. This choice results in small cells where the curvature of the solution is high, with a ratio of \(1+\) between the largest and smallest cell volumes. Our network is trained on the values of the monitor function only, which can be computed relatively cheaply from the PDE solution. The expected movement of the mesh vertices is computed by solving the Monge-Ampere equation (3) for each of the monitor functions based on the randomly generated PDE solutions. After training, the model can then be applied using only the monitor values as input, independent of the PDE that is being solved. Other choices of formulae for the monitor function in terms of \(u\) may be appropriate in different cases, but again these can be applied without re-training the model, _e.g._, the flow-past-a-cylinder and tsunami test cases in the following section use a monitor function based on the gradient of the solution.

### Loss functions.

Given the dataset \(\) defined above, the final objective is to find model parameters \(\), by minimizing the total loss \(L_{total}\). Thus, we can formalize the process as

\[*{arg\,min}_{}L_{total}():=_{vol}L_ {vol}()+_{cd}L_{cd}().\] (5)

where \(L_{vol},L_{cd}\) represents the element volume loss and Chamfer distance loss respectively, which are defined later. \(_{cd},_{vol}>0\) represent hyper-parameters balancing these two effects.

We denote the modified (adapted) mesh with model parameters \(\) as \((,m_{};)=\{_{{}^{a}},_{{}^{ a}}\}\), where \(_{{}^{a}}=\{_{i}\}_{i=1}^{n_{1}}\) represents the coordinates of vertices and \(_{{}^{a}}=\{_{i}\}_{i=1}^{n_{2}}\) represents the elements with \(_{i},_{i}\) as the \(i^{}\) vertex and element. For ease of presentation, we omit the \(\) here. Similarly, we define \(_{i},_{i}\) as \(_{{}^{r}},_{{}^{r}}\)'s \(i^{}\) vertex and element.

**Element volume loss.** In contrast to the coordinate loss used in previous work [19; 20], here we use the element volume loss for training. Element volume loss is computed as the averaged volume difference between each element in the adapted mesh (\(_{{}^{a}}\)) and the reference mesh (\(_{{}^{r}}\)) computed from the MA method. It is defined as \[L_{vol}()=_{(,m_{};_{r},_{r}) }[_{a}|}_{i=1}^{n_{2}}|(_{i} )-(_{i})|],\] (6)

where Vol is the function computing the volume of a given element \(\).

The element volume loss is inspired by the equidistribution relation in equation (1). Intuitively, the equidistribution relation enforces deformed mesh elements such that their volumes correspond to rescaling by the monitor function value \(m()\). Therefore, the element volume loss is utilised to encourage the model to learn to move the mesh so as to conform to the equidistribution relation, under the guidance of MA method, given that the MA method provides one good way to achieve this relation. In addition, the element volume loss penalizes negative Jacobian determinants, which helps prevent element inversion, _i.e._, mesh tangling.

**Chamfer distance loss.** Chamfer distance finds for all vertices in the first mesh, the nearest vertex in a second mesh and sums the square of these distances. It encourages the model to output a mesh which has a similar spatial distribution of vertices to that of the reference mesh. To achieve vertex-to-vertex alignment, the bidirectional Chamfer distance is utilized without additional sampling. It is defined as

\[L_{cd}()=_{(,m_{};_{r},_{r}) }[_{a}|}_{_{i}_{a}} _{_{j}_{r}}\|_{i}-_{j}\|_{2}+_{r}|} _{y_{j}_{r}}_{_{i}_{a}}\|_{i}-_{j} \|_{2}].\] (7)

## 5 Experiments

### Experiment setups.

Unlike existing approaches to mesh movement, such as [19; 20], which re-train their model on a case-by-case basis, our study aims to explore the universal applicability of the proposed UM2N. Therefore, all examples shown in this section are tested in a zero-shot generalization manner, _i.e._, without re-training. In addition to PDE type, our training meshes are of small size typically comprising \(500\) vertices, while our test meshes have far more vertices: Advection (\(2,052\) vertices), Cylinder (\(4,993\) vertices), Tsunami (\(8,117\) vertices), which also tests the model's scalability. There are examples with more complicated settings, please refer to Appx. E.

**Training.** The training dataset consists of 600 randomly generated generic solution fields and original meshes with 463 and 513 vertices. The model is trained using the Adam optimizer. The training and experiments are performed on an Nvidia RTX 3090 GPU.

**Metrics.** The main metric for evaluating mesh movement quality is underlying PDE solution error reduction (ER) ratio. Here PDE error is approximated by the difference between the solutions obtained on a coarse mesh and accurate solutions which are obtained on a very high resolution mesh. The PDE error reduction ratio is the difference between the PDE error from an original mesh and that from an adapted mesh. Another important metric for mesh movement is mesh tangling. Once mesh tangling happens, the mesh is invalid for a numerical solver, which breaks the simulation.

### Benchmarking mesh movement.

In the following section, we benchmark the mesh movement using both non-learned Monge-Ampere (MA) mesh movement implemented in _Movement_ and learning-based baseline M2N  over three different scenarios to compare with UM2N. Table 1 shows the quantitative results in three different scenarios, Swirl, Cylinder, and Helmholtz. An additional qualitative result of Tohoku Tsunami simulation, is provided to show our model can handle highly complex boundaries in real-world scenarios. Moreover, to give a fair comparison, we re-trained the model in M2N on our training dataset before evaluation.

    &  &  &  \\   & ER (\%) \(\) & Time (ms) \(\) & ER (\%) & Time (ms) \(\) & ER (\%) \(\) & Time (ms) \(\) \\  MA  & **37.43** & 5615.78 & Fail & - & **17.95** & 3265.23 \\ M2N  & 14.15 & 25.01 & Fail & - & 16.32 & **4.62** \\ UM2N (Ours) & 35.93 & **17.66** & **61.29** & **19.25** & 17.08 & 4.86 \\   

Table 1: Quantitative results across mesh movement methods. ER indicates PDE error reduction ratio. “Fail” indicates that mesh tangling happens during the simulation.

**Helmholtz.** The Helmholtz case is a time-independent problem solving a 2D Helmholtz equation as in (A2). The source terms of the equation are generated use formula (A1). Our model achieves better error reduction than M2N and comparable to MA method in significantly less time.

**Swirl.** The swirl case considers a time-dependent pure advection equation. In this scenario, the initial tracer field takes a narrow ring shape and is advected within a swirling velocity field, see Eq. (A3) and (A4) in Appx. C. The velocity swirling direction is anti-clockwise in the first half of the simulation and clockwise for the second half. Given this setting, as the advection process is reversible, the final state should be consistent with the initial state. This constitutes a problem of significant multi-resolution complexity, as the extremely narrow ring requires a high resolution to accurately resolve the dynamics at the sharply defined interfaces of both inner and outer sides.

The results are shown in Fig. 2. As shown in Table 1, our UM2N shows an average \(35.93\%\) error reduction which clearly outperforms M2N's \(14.15\%\). It is close to that of the full Monge-Ampere (MA) mesh movement approach which achieves an error reduction of \(37.43\%\), but with significantly lower computational time.

**Flow past cylinder.** Simulation of flow past a cylinder in a channel is a classic and challenging multi-resolution case of computational fluid dynamics, solving the Navier-Stokes equations. The cylinder and the channel's top-bottom surfaces require a high resolution mesh to resolve the boundary layers . Given appropriate Reynolds number, the well-known von Karman vortex street phenomena can be observed within the wake flow which also benefits from higher resolution to resolve the time-varying evolution of vorticity structures. The drag \(C_{D}\) and lift \(C_{L}\) coefficients for the cylinder are other quantities of interest in this problem. Here we use a benchmark configuration from , please refer to Appx.C.3 for more details.

The simulation is run for \(8,000\) time steps of size \(0.001\) s, _i.e._, \(8\) s physical time for the whole simulation. The original mesh is a uniform mesh with triangular elements and \(4,993\) vertices. The reference solutions are obtained on a high resolution mesh with \(260,610\) vertices.

We investigate the dynamics in the area around the cylinder and in the wake flow respectively. For the former, we use the measure of \(C_{D}\) as shown in Fig. 3. The results for \(C_{L}\) is shown in Fig. A10 in Appx. E. For the wake flow, we use cross-section probes at \(x=[0.5,1.0,1.5,2.0]\) to measure the intensity of vorticity spatially along the \(y\)-axis as shown in Fig. 4.

Qualitatively, it can be observed that the proposed method moves the mesh in a manner that captures the fluid dynamics for the whole domain in general (see upper part of Fig. 3). At the cylinder and top-bottom surface, the vertices are moved to increase the resolution in order to resolve the boundary layers as expected. Quantitatively, the drag \(C_{D}\) and lift \(C_{L}\) coefficients computed on our moved mesh show a \(61.29\%\) average error reduction compared to that of original mesh as shown in lower part of Fig. 3. The proposed UM2N approach not only improves the accuracy of these coefficients in magnitude but also prevents their periodic variation from phase shifting. For the wake flow, as shown in Fig. 4, we selected a single snapshot at \(t=4.0s\) for qualitative investigation. Our UM2N also shows an accuracy improvement for vorticity intensity on data sampled from all four cross-section probes comparing to the that on original mesh.

Figure 2: Results for swirl case. The plot shows the end state of the swirl simulation (bottom row) and corresponding meshes (top row). As the process is reversible, the end state should be consistent to the initial state. It can be observed that the solution obtained on high resolution almost recover the initial state. The proposed UM2N outperform M2N and achieve comparable performance to MA method. Quantitatively in the rightmost plot, the orange line (UM2N) and blue line (MA) best suppress error accumulation along timesteps.

Note that we intended to compare our UM2N to M2N and the conventional full MA method. However, both MA and M2N fail _i.e._, the solver diverges, within 30 time steps due to mesh tangling and thus provide insufficient data points for comparison. For comparisons with a non-tangled M2N case, please refer to the simplified laminar flow-past-cylinder example presented in Appendix D.1.

**Tohoku tsunami simulation.** Here we present the case of a simulation of the 2011 Tohoku Tsunami, to show that our methods can be applied to real world scenarios with boundaries describing highly complex geometries. The tsunami is simulated by solving the shallow water equations using the Thetis framework . For details on the datasets and software used to set up the Tohoku case study, see Appx. B.2. Note that the mesh (\(8,117\) vertices) has an arbitrarily irregular boundary. It can be

Figure 4: Analysis on wake flow vorticity for the cylinder case. The adapted mesh output by UM2N (see top-left part of the plot). Qualitatively, the error maps at the top-right part indicate that our UM2N reduce the vorticity difference to the high resolution mesh result in general. The quantitative comparison results along the probes are shown in the lower part of the figure. There are four cross-section probes place on \(x=[0.5,1.0,1.5,2.0]\) marked by the black dash line in the middle left plot. The green line (our UM2N) is much more consistent to the blue dash line (high resolution) compared to the orange line (original mesh), which further verifies that our method can reduce the PDE errors.

Figure 3: Results for the flow past cylinder case in time. In the upper part, we visualize \(5\) snapshots of adapted meshes and vorticity intensity from \(4.00s\) to \(4.20s\). Please refer to the full video in the supplementary materials. It shows that our UM2N can output meshes which adapt to the dynamics around the cylinder. It can be observed from the zoom-in mini-plots at the top-left that UM2N reduces errors/noise in vorticity intensity compared to the original mesh. In the lower part, the blue, orange and green lines show the drag \(C_{D}\) coefficients obtained on a high resolution fixed mesh, UM2N adapted mesh and the original coarse mesh for the first 6 seconds (_i.e._, 6000 steps). It can be observed that the UM2N output mesh improves the accuracy of \(C_{D}\) in magnitude and periodicity compared to the original mesh.

observed that the mesh moves in a manner that helps track the wave propagation with enhanced resolution, as shown in Fig. 5. Our model can also robustly handle the highly complex boundary without mesh tangling near the coastline. As a comparison, the conventional Monge-Ampere (MA) mesh movement approach struggles to handle the complex geometries, _i.e._, fails to converge when solving the non-linear MA equation, resulting in highly tangled elements near the coastline as shown in Fig. 6. Therefore, our method not only provides a more efficient approach but also show advantages dealing with complex boundaries compared to the full MA mesh movement approach. Please see the full video of this case in the supplementary materials.

### Tangled results of the UM2N model

There are in fact still cases where UM2N might fail. To investigate these, we perform additional experiments as shown in Figure 7. Starting from a rectangle, we gradually distort the geometry to a more and more non-convex shape, _i.e._, the case becomes more challenging from top to bottom. The UM2N finally fails in the extreme case at sudden jumps in the boundary accompanied by a large variation in the required resolution as shown in the bottom row of Figure 11: a sudden constriction of the flow leads to tangling with UM2N in the two left corners of the channel. In less extreme cases, UM2N does produce a valid mesh, whereas the original MA method still fails (as seen in the second to bottom rows in Figure 7).

Figure 5: Qualitative results for the Tohoku tsunami simulation. The boundary of the simulation is generated based on the real coastline data (see the mesh overlaid on the satellite map). We show 9 snapshots of the wave elevation from 80 steps of the tsunami simulation enhanced by our UM2N. In these visualizations, red and blue hues indicate wave elevations that are, respectively, above or below mean sea level. Regions exhibiting significant elevation magnitudes necessitate increased resolution to accurately resolve the underlying dynamics. Our method dynamically and robustly adjusts the mesh to increase resolution at the wave front, thereby effectively tracking its propagation.

Figure 6: Handling complex boundaries. The Monge-Ampère method generates inverted elements, resulting in mesh tangling near the coastline as shown in the areas delineated by red rectangles. Our UM2N can smoothly handle the elements near the coastline without mesh tangling.

### Ablation study

Volume loss vs coordinate loss.We denote the UM2N variant trained with coordinate loss  as UM2N-coord. As shown in Table 2, UM2N-coord achieves comparable error reduction (\(31.21\%\)) to the proposed UM2N (\(35.93\%\)) on the Swirl case. However, it fails (_i.e._, encounters mesh tangling) on the Cylinder case which has a more complex boundary geometry. This indicates that the element volume loss is mesh-tangling aware, _i.e._, helps to prevent producing inverted elements.

Monitors vs PDE solutions as inputs.We denote the UM2N variant using the PDE solution as input, instead of monitor function values, as UM2N-sol. The UM2N-sol is trained on solutions of the Helmholtz PDE. The UM2N-sol shows a much inferior performance (\(-0.35\%\)) compared to UM2N (\(35.93\%\)) on the Swirl case as well as on the Cylinder case. This indicates that learning mesh movement from monitors directly improves the generalisability of the model.

## 6 Conclusions

We introduce the Universal Mesh Movement Network (UM2N), which once trained on our generated PDE-independent dataset, can be applied in a non-intrusive, zero-shot manner to move meshes with different sizes and structures, for solvers applicable to different PDE types and boundary geometries. Our method demonstrates superior mesh movement results on Advection and Navier-Stokes PDE examples as well as a real-world tsunami case. Our UM2N outperforms the existing learning based method and achieves comparable PDE error reduction to the far more costly Monge-Ampere (MA) PDE based approach. Our UM2N demonstrates effectiveness in cases with complex boundary geometries where existing learning and conventional MA based methods fail. Our method also shows significant acceleration compared to MA based mesh adaptation. See Appx. G for discussions on limitations and broader impacts.

    & Helmholtz & Swirl & Cylinder \\ Method & ER (\%) \(\) & ER (\%) & ER (\%) \(\) \\  UM2N-coord & 16.64 & 31.21 & Fail \\ UM2N-sol & 13.52 & -0.35 & 39.94 \\ UM2N (Ours) & **17.08** & **35.93** & **61.29** \\   

Table 2: Ablation Study for design choices of learning monitors and element volume loss.

Figure 7: Tangled Case of UM2N and MA. Red/blue indicate high/low monitor values, _i.e._, the mesh is expected to stretch towards the right direction. The case is more and more challenging from top to bottom.