# SatLM: Satisfiability-Aided Language Models

Using Declarative Prompting

 Xi Ye &Qiaochu Chen &Isil Dillig &Greg Durrett

Department of Computer Science

The University of Texas at Austin

{xiye,qchen,isil,gdurrett}@cs.utexas.edu

###### Abstract

Prior work has combined chain-of-thought prompting in large language models (LLMs) with programmatic representations to perform effective and transparent reasoning. While such an approach works well for tasks that only require forward reasoning (e.g., straightforward arithmetic), it is less effective for constraint solving problems that require more sophisticated planning and search. In this paper, we propose a new _satisfiability-aided language modeling_ (SatLM) approach for improving the reasoning capabilities of LLMs. We use an LLM to generate a _declarative task specification_ rather than an imperative program and leverage an off-the-shelf automated theorem prover to derive the final answer. This approach has two key advantages. The declarative specification is closer to the problem description than the reasoning steps are, so the LLM can parse it out of the description more accurately. Furthermore, by offloading the actual reasoning task to an automated theorem prover, our approach can guarantee the correctness of the answer with respect to the parsed specification and avoid planning errors in the solving process. We evaluate SatLM on 8 different datasets and show that it consistently outperforms program-aided LMs in the imperative paradigm. In particular, SatLM outperforms program-aided LMs by 23% on a challenging subset of the GSM arithmetic reasoning dataset; SatLM also achieves a new SoTA on LSAT and BoardgameQA, surpassing previous models that are trained on the respective training sets.1

## 1 Introduction

Using large language models (LLMs) to perform complex reasoning has been a central thrust of recent research (Brown et al., 2020; Chowdhery et al., 2022; Rae et al., 2021; Zhang et al., 2022). Techniques like scratchpads (Nye et al., 2021) or chain-of-thought prompting (CoT) (Wei et al., 2022) enable LLMs to follow a sequence of reasoning steps before making a prediction. This paradigm is effective on various multi-step reasoning tasks, especially those with fixed forward reasoning procedures (Wei et al., 2022), e.g., concatenating the last letters of several words. However, CoT prompting can fall short when scaling to problems that involve intensive computation (Gao et al., 2023) or long sequences of reasoning steps (Creswell et al., 2023; Saparov and He, 2023; Ribeiro et al., 2023).

Solving a complex reasoning problem involves three conceptual components: parsing a natural language description into a representation of the problem, deriving a plan to solve the problem, and executing that plan to obtain an answer. Recent work on improving CoT prompting focuses on fixing _execution errors_ by augmenting LLMs with symbolic executors such as a Python interpreter, whichleads to improved performance on arithmetic and symbolic reasoning tasks (Gao et al., 2023; Chen et al., 2022; Lyu et al., 2023). However, CoT prompting (Wei et al., 2022c; Nye et al., 2021) and its executor-augmented successors (Gao et al., 2023; Chen et al., 2022; Lyu et al., 2023) are oriented towards _imperative_ solving procedures: a CoT or a program specifies the reasoning procedure as chained steps (Wei et al., 2022c; Gao et al., 2023) in the order of execution. While this is effective for problems whose natural language already provides a suitably clear "plan" for the reasoning, it only leads to limited success for reasoning problems like in Figure 1 that do not outline such a plan (Ribeiro et al., 2023). These problems often state a set of premises and constraints and ask questions that require sophisticated planning to deductively reason over the inputs, which is still challenging even for modern LLMs (Valmeekam et al., 2022).

Our work tackles both execution errors and, more importantly, _planning errors_. We propose SATisfiablity-aided Language Modeling (SatLM) using declarative prompting. The core idea is to cast a natural language (NL) reasoning problem as a satisfiability (SAT for short) problem. As shown in Figure 1 (right), given a problem in NL, we prompt an LLM to parse it into a SAT problem specification which consists of a set of logical formulas, then obtain the solution by invoking a SAT solver.2 The LLM is specialized towards understanding the preconditions stated in the problem, while the solver is leveraged to plan out the reasoning procedure. In addition, the solver guarantees the correctness of execution, similar to the interpreter used in program-aided LMs (ProgLM).

We evaluate our approach on 8 datasets spanning 4 tasks, including arithmetic reasoning, logical reasoning, symbolic reasoning, and a regex synthesis task. Our SatLM consistently outperforms CoT and ProgLM across all datasets, usually by a large margin. On GSM-Sys, SatLM outperforms ProgLM by a 23%; on GSM, SatLM achieves 84.8% with self-consistency decoding using few-shot prompting, equaling past work that uses the full training set and the same LLM (Li et al., 2022b; Ni et al., 2023). SatLM also sets a new SoTA on LSAT (Zhong et al., 2022), BoardgameQA (Kazemi et al., 2023), and StructuredRegex (Ye et al., 2020).

Our analysis illustrates why the combination of SAT solver and declarative prompting is so effective. We find (1) program-aided LMs often make planning errors (e.g., manipulating equations incorrectly), which can be remedied by the SAT solver. (2) Forcing LLMs to explicitly state a declarative

Figure 1: Illustration of our Satisfiability-aided Language Modeling approach (right). We first parse an NL input into a declarative task specification (a set of logical constraints) using prompting (Section 3.1), then use a SAT solver to solve the problem (Section 3.2). The chain-of-thought strategy in prior work (left) yields imperative reasoning processes.

specification can even improve vanilla CoT prompting. (3) Our SatLM approach can abstain from making uncertain predictions if it parses a problem into an unsatisfiable or ambiguous specification, giving it even higher accuracy in the selective prediction setting (El-Yaniv and Wiener, 2010).

## 2 Overview

This work addresses the challenge of using LLMs to solve NL reasoning tasks. At a high level, an NL reasoning task is a natural language description of a collection of facts \(\) (such as propositions or constraints) about some objects and a question \(Q\) related to these objects. The goal of the reasoning task is to find an answer to \(Q\) that can be deduced from the information provided in \(\).

We conceptualize the general procedure for solving NL reasoning tasks in three steps: _parsing_, _planning_, and _execution_. We are given natural language input \(x_{}=(NL(),NL(Q))\) which describes both \(\) and \(Q\). Our first step is to parse this natural language into a predicted _task specification_\((,)\), which is a _formal_ description of the facts and the query.

Given \((,)\), the planning step then involves determining a sequence of reasoning steps \([r_{1},,r_{n}]\) beginning with the task specification and ending with the answer to the question. Each step involves invoking a function (e.g., arithmetic operator or logical operator) that produces intermediate results which can be utilized in subsequent steps. A plan can be formulated by an LLM with CoT prompting or by a symbolic solver as in our work here. Finally, we execute the plan systematically with either a symbolic executor (our method) or an LLM, returning the output of the last step, \(r_{n}\), as the answer.

Our solution approaches the problem using exactly these three steps.

Parsing into declarative specificationWe prompt an LLM to generate a specification \(s_{}\) for \(x_{}\). Note that the translation from this description into the specification is not straightforward and cannot be done in a rule-based way for most tasks; Figure 4 shows some particularly complex examples involving commonsense reasoning. The specification \(s_{}\) is a sequence of interleaved NL statements and logical formulas (LF): \(s_{}=[z_{1},,z_{n}]\) and \(z_{i}_{NL}_{LF}\), where \(_{NL}\) and \(_{LF}\) denote the space of natural language and logical formulas, respectively. We derive the formal specification \((,)\) by taking all the \(z_{i}\) in \(_{LF}\) from \(s_{}\). An example of the specification is presented on the right of Figure 1. Our specification is declarative since we do not explicitly generate the \(r_{i}\) from the LLM at this stage.

Planning and execution with a SAT solverGiven the predicted formal specification \((,)\), we wish to derive the final answer of the query \(\) from it. We say that a solution \(a\) is correct if \(\) logically entails \(=a\), denoted as \(=a\). The key insight behind our work is to offload _both_ the planning and execution steps to a SAT solver. Specifically, we use a SAT solver to find a satisfying assignment for \(a\) in the formula:

\[ V.\,(=a)\]

where \(V\) denotes the set of all variables used in \(\) and \( V\) is a variable that corresponds to the solution. Note that the only free variable in this formula is \(a\); hence, the assignment to \(a\) returned by the solver is the final answer to the reasoning problem.

The approach outlined above has two important strengths. First, because the SAT solver is _sound_ (i.e., any assignment it produces satisfies the formula), the solution is correct by construction. Thus, assuming that the parsing is correct and \(\) and \(\) match \(\) and \(Q\), we have a proof that the solution is indeed correct. Second, the planning step is done internally to the solver, and the chain of reasoning steps \([r_{1},,r_{n}]\) can be obtained by asking the solver to produce a proof of the validity of the formula \(=a^{*}\) where \(a^{*}\) is the assignment produced by the SAT solver. All solvers we consider can produce such a proof of validity (e.g., in the form of a resolution refutation (Davis and Putnam, 1960)).

Comparison with prior workPrior approaches to NL-based reasoning with LLMs can also be framed in the parse-plan-execute framework proposed above. In particular, the chain-of-thought paradigm (Nye et al., 2021; Wei et al., 2022c) uses LLMs to perform each of the three steps. Program-aided language models (Gao et al., 2023; Chen et al., 2022; Lyu et al., 2023) combine the parsing and planning steps to use an LLM to derive a program that corresponds to the plan.3 The final execution step is then performed by using the interpreter of the underlying programming language to derive the final answer. In contrast to these approaches, our work uses an LLM only to perform the parsing step, which is an easier problem for LLMs than planning.

We show a concrete example comparing CoT and ProgLM with our approach in Figure 2. CoT performs all three steps with the LLM. For instance, "_Alex has caught \(X+5\)_" in the output corresponds to "_Alex has caught 5 more than Stan_" in the NL input (parsing). Later, CoT decides how to solve for the variable \(X\) with "_Combining like terms_..." (planning). At the same time, it also derives the equation "\(5X=334\)" directly in its generation (execution). However, CoT incorrectly uses the same \(X\) in the equation "\(X+5\)" and "\(4X-13\)", when it is supposed to be different. (Note that \(4X-13\) would be correct if Stan and Adelwolfe's roles in the corresponding NL clause were reversed.) By allowing the LLM to focus only on translation, we find a lower incidence of this kind of error, in addition to eliminating planning errors. Notably, planning errors are **not** addressed by ProgLM, which does not use programmatic manipulation at this stage. Different from ProgLM, SatLM only parses the information provided in the input question, passes the parsed formulas to a solver for both planning and execution, and obtains the correct result.

## 3 SAT-Aided Language Models using Declarative Prompting

### Declarative Prompting

We use few-shot prompting to generate the specification \(s_{}\) for the test input \(x_{}\). Specifically, we include few-shot demonstrations \((x_{i},s_{i})_{i=1}^{k}\) in the prompt, append test input \(x_{}\) after the prompt, and let the LLM complete the specification for \(x_{}\), i.e., \(s_{} p(x_{} x_{1},s_{1},,x_{k},s_{k})\).

We show an example specification for a logical reasoning task in Figure 1, and an example specification for an arithmetic reasoning task in Figure 2. Observe that in both examples, our SAT formulas (i.e., the logical formulas of \([z_{1},,z_{n}]\) in \(_{LF}\)) are written as code following Python syntax, while the natural language in \(_{NL}\) is written using comment syntax. We found that including the language here as comments was useful to improve the fidelity of the translation. Our declarative prompts also use meaningful variable names and descriptive comments following the style of prompts in prior work (Gao et al., 2023; Lyu et al., 2023). Finally, we use Python rather than a specialized DSL to be more congruent with our models' pretraining data (Ouyang et al., 2022; Chen et al., 2021). See Appendix F for more details on the SAT specification.

Figure 2: Exemplar specifications for arithmetic reasoning problems generated by different approaches. CoT makes errors when parsing an equation; ProgLM produces an incorrect reasoning chain (both errors are highlighted in red). By only using the LLMs to generate declarative specifications and relying on a solver to handle the reasoning, SatLM generates the correct answer.

### Solving with a SAT Solver

SAT problemA SAT problem is a triple \(=(,,Q)\) where \(\) is a set of first-order logic formulas in some theory \(\)4 and \(Q\) is the query of interest. We use \(()\) to denote the free variables in \(\). \(Q\) contains only variables in \(()\). An example SAT problem is \(=(\{x+y=3,x-y=1\},_{E}_{},x-2)\), where \(_{E}_{}\) indicates that only equality and linear arithmetic operations on integers are allowed in the formulas.

Many NL reasoning tasks in the literature can be formulated as SAT problems and solved using an off-the-shelf solver. For **arithmetic reasoning**, the SAT formulas \(\) are equations encoding the relationships between variables, and \(t\) specifies the target variable asked in the question (see Figure 1). For **logical reasoning**, \(\) encodes preconditions and \(t\) specifies the target statement posed by the question. We also show that symbolic reasoning, regex synthesis, and other problems involving reasoning over arrays or strings can be handled in this framework.

Unlike prior work such as Faithful CoT (Lyu et al., 2023) that uses task-specific formulations and task-specific solvers for different problem types, all the tasks in this paper are formulated as general SAT instances that can be solved by a single solver (as described later in this section).

Parsing NL to a SAT problemRecall that we obtain a specification \(s_{}\) from a test NL task \(x_{}\). To derive the SAT problem \(_{}=(_{},_{},_{})\) from \(s_{}\), we extract the constraints \(_{}\) and the target expression \(_{}\) (marked by solve in our prompt) by taking all the \(z_{i}\) in \(_{LF}\) of \(s_{}\). We identify the theory \(_{}\) by analyzing the formulas in \(_{}\).

Solving the SAT problemGiven the SAT problem \(\), we invoke an automated theorem prover (such as the Z3 SMT solver (De Moura and Bjorner, 2008) used in our implementation) to obtain a model \(M\) that maps each free variable \(v()\) to a concrete value under theory \(\). The final answer is obtained by substituting each free variable \(v_{i}\) in \(\) with \(M[v_{i}]\). For example, given the problem \((\{x+y=3,x-y=1\},_{E}_{},x-2)\), we ask the solver to find a solution to the constraint \(x+y=3 x-y=1\) in the theory \(_{E}_{}\), which yields \(x=2\) and \(y=1\). Then, to obtain the final answer, we substitute \(x\) by \(2\) in the target expression \(x-2\) to obtain the result \(2-2=0\).

Feedback signals from the solverGiven a set of \(\) specified in \(\), the SAT solver will try to search for a satisfying assignment \(M\) which satisfies all constraint formulas in \(\). If the solver succeeds in finding such an assignment within a certain time limit, it will use \(M\) to evaluate the query \(\) and return the final result, otherwise it is a timeout. However, the solver may fail to find a solution for problematic \(\) and provide feedback in one of the following types: (1) _error in execution_ (ERROR) caused by invalid formulas (e.g., syntax errors) or time-out; (2) _unsatisfiable formulas_ (UNSAT), caused by conflicting formulas in the \(\) (e.g. \(=\{x=y+1,y=x+1\}\)) (no feasible solution); (3) _ambiguous formulas_ (AMBIG), caused by the existence of multiple feasible solutions (e.g. \(=\{x=y+1,x>0\}\)). Examples of SAT formulas leading to UNSAT or AMBIG can be found in Appendix G.

Unlike the executor used in ProgLM that can only detect errors in code execution, SAT solver can spot UNSAT and AMBIG in addition to ERROR. We show this unique characteristic allows our SatLM to abstain from potentially incorrect predictions much more effectively compared to ProgLM in the selective prediction setting (El-Yaniv and Wiener, 2010) (Section 4.4).

## 4 Experiments

### Setup

TasksOur work investigates 8 datasets covering 4 tasks, with a focus on arithmetic reasoning and logical reasoning tasks. We list all dataset statistics in Appendix A. For arithmetic reasoning, we use GSM (Cobbe et al., 2021), GSM-Sys, and Algebra (He-Yueya et al., 2023). GSM-Sysis a special subset of GSM containing examples that are paired with human-annotated solutions involving systems of equations (see Appendix A for more details). For logical reasoning, we use LSAT (Zhong et al., 2022), BoardgameQA (Kazemi et al., 2023), Clutrr(Sinha et al., 2019), and ProofWriter(Tafjord et al., 2021). For BoardgameQA, we report the average performance on the three data splits (depth 1 to depth 3).

For Clutrr, we use exemplars requiring up to 3 intermediate steps but evaluate on test examples requiring up to 10 intermediate steps (Sinha et al., 2019), following past work (Lyu et al., 2023). For ProofWriter, we evaluate on the most challenging examples requiring depth-5 proofs (Tafjord et al., 2021). For symbolic reasoning, we use Colored Object (Color) from BIG-bench (et al., 2022) as an exemplar task. This task can be abstracted as finding elements in a list under certain constraints. We also evaluate on a regex synthesis dataset, StRegex(Ye et al., 2020), which requires synthesizing a regex give NL description. We cast this task into synthesizing the surface form (i.e., a string) of the target regex, and use SatLM to parse NL description into constraints over the string.

BaselinesWe compare SatLM against 3 baselines, including standard prompting (directly giving the answer), chain-of-thought prompting (CoT), and executor-augmented LLMs (ProgLM). We do not compare to zero-shot baselines such as zero-shot CoT, which generally underperform few-shot CoT by a large margin on the tasks we investigate (Kojima et al., 2022).

For CoT and ProgLM, we leverage prompts of existing work (Gao et al., 2023; Lyu et al., 2023; Creswell et al., 2023) whenever possible. For SatLM, we manually write prompts for the **same exemplar sets** used in CoT and ProgLM to ensure a fair comparison. We note that some settings, such as ProgLM for LSAT, are not applicable. Please refer to Appendix B for more discussion of the setup, including details on the prompts we use. We also include example prompts for all the datasets in Appendix I.

Language Models & DecodingWe conduct our main experiments and analysis on code-davinci-002 (Chen et al., 2021), a state-of-art LLM for code and code-adjacent tasks. We evaluate the performance with both greedy decoding and self-consistency decoding (Wang et al., 2022b). Following past work (Gao et al., 2023), we use 40 samples on all datasets except for LSAT, BoardgameQA, and ProofWriter; we use 5 samples on these datasets involving long prompts and high computation cost. For CoT and ProgLM, we use a temperature of 0.7; for SatLM, we use a higher temperature of 0.9, which we find to work better.

### Main Results

Table 1 shows the performance of our approach compared to the baselines. In general, our Sat-aided approach outperforms both CoT and ProgLM by a substantial margin except on GSM with greedy decoding. We perform significance tests via bootstrap resampling, and all improvements of SatLM over ProgLM are statistically significant (\(p<0.05\)).

    & GSM-Sys & GSM & Alge & LSAT & Board & Clutrr & Proof & Color & Regex \\   &  \\ Standard & 21.0 & 22.2 & 45.9 & 22.0 & 44.6 & 41.2 & 76.6 & 75.7 & \(-\) \\ CoT & 46.5 & 62.7 & 53.6 & 23.5 & 60.7 & 40.8 & 80.1 & 86.3 & \(-\) \\ ProgLM & 43.4 & **72.7** & 52.3 & \(-\) & \(-\) & 58.9 & 83.7 & 95.1 & 39.1 \\ SatLM & **69.4** & 71.8 & **77.5** & **35.0** & **79.4** & **68.3** & **99.7** & **97.7** & **41.0** \\   &  \\ CoT & 56.1 & 77.3 & 64.9 & 23.1 & 62.8 & 45.7 & 88.7 & 90.6 & \(-\) \\ ProgLM & 53.4 & 82.4 & 57.7 & \(-\) & \(-\) & 71.9 & 91.2 & 98.0 & 56.5 \\ SatLM & **80.9** & **84.8** & **90.9** & **37.4** & **80.7** & **80.1** & **99.7** & **99.4** & **59.7** \\   

Table 1: Comparison of our approach (SatLM) against standard prompting (directly predicting the answer), CoT and ProgLM. Certain settings are not applicable (marked as \(-\)) as described in Appendix B. With greedy decoding, SatLM outperforms CoT and ProgLM on all datasets by a substantial margin except for GSM, where it is on par with ProgLM. With self-consistency decoding, SatLM is consistently better than ProgLM, giving SoTA accuracy on LSAT and BoardgameQA.

The first two columns show the performance on the GSM dataset. CoT and ProgLM achieve much worse performance on GSM-Sys than on GSM, indicating that GSM-Sys is a challenging subset. On this subset, SatLM achieves 69.4% and 80.9% with greedy decoding and self-consistency decoding, surpassing both ProgLM and CoT more than by 20%. On the original GSM dataset, the SatLM model has a slightly lower accuracy than ProgLM with greedy decoding, but outperforms it with self-consistency decoding by 2.4%; we provide detailed analysis accounting for the differences later in this section. This self-consistency accuracy of 84.8% even exceeds recent work that uses the full training set with code-davinci-002 (82.3% in DiVeRSE (Li et al., 2022b); 84.5% in Lever (Ni et al., 2023)). On Algebra, a challenging dataset of math problems extracted from algebra textbooks, SatLM also outperforms CoT and ProgLM by more than 20%.

On LSAT, Clutr, ProofWriter, and Color, SatLM consistently achieves the best performance with either greedy decoding or self-consistency decoding. SatLM also sets the new SoTA on both LSAT and BoardgameQA, surpassing previous models that are trained on the full training set. Specifically, SatLM elevates the SoTA from 30.9% (Zhong et al., 2022) to 37.4% on LSAT and from 73.9% (Kazemi et al., 2023) to 80.7% on BoardgameQA. See Appendix E for detailed performance breakdown on depth 1-3.

In the regex synthesis domain, with greedy decoding, directly translating natural language descriptions to regexes (ProgLM) achieves 37.1%, whereas using declarative prompting achieves 44.0%. With self-consistency, we surpass the previous SoTA performance of 55.6% (Ye et al., 2021).

### Impact of SAT Solver & Declarative Prompting

We conduct analysis to isolate the effectiveness of the two key components, the SAT solver and declarative prompting. Specifically, we test a variant of our approach that still uses declarative prompting but then solves the equations in natural language with CoT rather than using the symbolic solver (see Figure 3). Essentially, the LLM itself carries out planning and execution. This experiment helps isolate the benefits of the solver, which will compute an answer without making any mistakes, from the benefits of the declarative formulation. We also compare to prompting LLMs to directly give the answer (NoSolver).

Impact of Symbolic SolverAs shown in Table 2, completely ablating the solver and directly predicting the answer (\(_{}\)) only yields performance that is on par with Standard. Interestingly, \(_{}\) can solve more SAT problems than NoSolver. This partially reflects the effectiveness of CoT and partially reflects the fact that many dataset instances require relatively simple planning and execution, allowing pure forward reasoning to solve them. However, using a symbolic solver (\(_{}\)), which guarantees correct planning and execution, leads to further improvements.

    & GSM-Sys & GSM & Clutr \\  Standard & 21.0 & 22.2 & 41.2 \\ CoT & 46.5 & 62.7 & 40.8 \\ PAL & 43.4 & 72.8 & 58.9 \\  SAT\({}_{}\) & 69.4 & 71.7 & 68.3 \\  SAT\({}_{}\) & 54.5 & 63.2 & 48.9 \\  SAT\({}_{}\) & 26.6 & 23.7 & 40.7 \\   

Table 2: The performance of variants of our approach that use CoT Solver or No Solver. Using declarative prompting with CoT solver is more effective than imperative CoT prompting.

    & GSM-Sys & GSM & Clutr \\  Plan Err & 72.5 & 42.5 & 47.5 \\ Exec Err & 27.5 & 57.5 & 52.5 \\   

Table 3: Fraction of planning errors (incorrect reasoning chains) and execution errors (numeric errors) made by CoTSolver.

Figure 3: A variant of our approach which replaces the SAT solver with a “CoT solver” that takes the SAT problem as input and solves it in natural language.

We manually analyzed 40 cases where the symbolic solver yields the correct answer but SatCost solver fails to solve them. We categorized the errors as planning errors, where the reasoning chains are incorrect, and execution errors, where the reasoning chains are correct but computations are incorrect (see Appendix H for examples). Table 3 shows that most errors by SatCost solver are planning errors, especially on GSM-Sys which requires solving complex system of equations.

Impact of Declarative PromptingTable 2 also shows that decoupling parsing and planning/solving is still useful, even when not using a symbolic solver: SatCost solver outperforms CoT by 7.9%, and 8.1% on GSM-Sys and Clutrr, respectively. We note that SatCost solver can be viewed as a two-stage CoT prompting strategy, with a prompt showing that the first step is to formulate declaratively, then the next step is to solve.

We hypothesize that parsing a question into declarative formulas is more straightforward than parsing it into an imperative solving procedure. To evaluate this hypothesis, we use log likelihood of the generated tokens to assess how straightforward the translation is, as higher log-likelihood typically indicates the outputs are more fluent to LLMs, a connection demonstrated in recent literature (Gonen et al., 2022; Ye and Durrett, 2023). We show both unnormalized (total) and normalized log likelihood in Table 4. On GSM-Sys and Clutrr where SatLM outperforms ProgLM, its generated outputs are also associated with higher likelihood.

### Advantages of Sat in Selective Prediction

A SAT solver may not always return an answer, particularly if there are parsing errors from the question. We show that this is an advantage of SatLM: these errors allow us to abstain from making likely incorrect predictions. Example outputs leading to different errors can be found in Appendix G.

Table 5 shows the fraction of correct predictions and incorrect predictions when the program or SAT solver successfully returns an answer as well as the fraction of different types of feedback signals. We report the fraction of questions _answered_ as well as _selective accuracy_, defined by the fraction of overall accuracy (% of correct answers) normalized by coverage (% of answered problems). SatLM makes fewer predictions on all three datasets compared to ProgLM, as it can trigger both Unsat and Ambig errors. However, SatLM's selective accuracy is consistently better than ProgLM's, especially on GSM-Sys (77% vs 45%). As a result, SatLM's overall performance is significantly better than ProgLM on GSM-Sys and Clutrr, even when making fewer predictions.

We note that on GSM, SatLM has slightly lower coverage but higher selective accuracy compared to ProgLM. This explains why SatLM lags behind ProgLM with greedy decoding but outperforms ProgLM with self-consistency decoding (Table 1). By drawing multiple samples, SatLM can increase its coverage and achieve higher accuracy than ProgLM since its predictions are more accurate.

    & GSM-Sys & GSM & Clutrr \\  PAL & -9.5/-6.9\({}_{W^{2}}\) & **-9.2/-6.0\({}_{W^{2}}\)** & -3.1/-8.5\({}_{W^{3}}\) \\ SAT & **-8.5/-5.9\({}_{W^{2}}\)** & -9.7/-6.2\({}_{W^{2}}\) & -**2.0/-7.9\({}_{W^{3}}\)** \\   

Table 4: Log likelihood (unnormalized / normalized) of the generated sequences (with greedy decoding) of ProgLM and SatLM on three datasets. Better log likelihood indicates higher LLM confidence in the parsing stage.

    &  &  &  \\  & progLM & SatLM & ProgLM & SatLM & progLM & SatLM \\  Correct & 43.3 & 69.4 & 72.7 & 71.8 & 58.9 & 68.3 \\ Incorrect & 52.5 & 20.6 & 25.7 & 21.2 & 21.0 & 7.7 \\   Error \\ Unsat \\ Ambig \\  & 4.2 & 2.6 & 1.6 & 2.1 & 20.1 & 3.5 \\  Unsat & – & 2.4 & – & 1.5 & – & 15.5 \\  Ambig & – & 5.0 & – & 3.4 & – & 5.0 \\  
 Answered \\ Selective Acc \\  & 95.8 & 90.0 & 98.4 & 93.0 & 79.9 & 76.0 \\  Selective Acc & 45.2 & **77.1** & 73.8 & **77.2** & 73.7 & **89.9** \\   

Table 5: Analysis of accuracy and execution status of SatLM and ProgLM. We present the fraction of tasks solved correctly or incorrectly in GSM-Sys, GSM, and Clutrr, along with the breakdown of feedback from the solver. SatLM generally makes fewer predictions than ProgLM (Answered), but more frequently makes correct predictions when it returns an answer (Selective Acc) _and_ gives a higher absolute number of correct predictions on GSM-Sys and Clutrr.

### Analysis

LLMs Can Perform Commonsense Reasoning While ParsingThere are many problems that do not state premises or constraints in a completely explicit way. Figure 4) shows two examples where commonsense inferences are required during parsing. For example, on the left, the model must recognize that _animals_ refers to the chickens and cows collectively. Similarly, knowing that red is a primary color is needed to successfully apply rules on BoardgameQA (right). We observe from the outputs in both cases that LLMs are capable of implicitly performing commonsense reasoning and produce correct logical formulas in the parsing step. As shown in Table 1, SatLM exhibits strong performance on BoardgameQA, a dataset which requires this implicit background knowledge.

Results Across Different Language ModelsIn addition to the main LLM used in our work, code-davinci-002, we further test whether SatLM can generalize to other LLMs. We choose gpt-3.5-turbo (0613 version), text-davinci-003, and code-davinci-001. gpt-3.5-turbo is optimized for chat. text-davinci-003 is an LLM pre-trained on NL, and tuned to align with human feedback (Ouyang et al., 2022). code-davinci-001 is also an LLM pretrained on code, but less capable compared to 002. As shown in Table 6, SatLM is better than ProgLM on the arithmetic reasoning and logical reasoning datasets except for GSM across these three LLMs. The trend is congruent with the results on code-davinci-002 (Table 1), which suggests the approach's general applicability across different LLMs, regardless of their varying capabilities.

Sensitivity to Different Exemplar SetsWe test whether the advantages of SatLM is sensitive to different sets of exemplars. We experiment with 3 sets of exemplars on code-davinci-002. As shown in Table 7, SatLM consistently outperforms ProgLM by a large margin on GSMSys and Clutrr, and achieves comparable performance on GSM. The results suggest the effectiveness of our approach is insensitive to varying the choice of exemplars.

## 5 Related Work

Our work is built on top of few-shot prompting (Brown et al., 2020), which has proven effective on a wide range of tasks (Wei et al., 2022; Liu et al., 2023; Gehrmann et al., 2021; Reif et al., 2022; Wei et al., 2022; Sanh et al., 2022). In particular, we focus on improving LLMs on reasoning tasks, which are challenging for language models even with recent

    & GSM-SYS & GSM & LSAT & clutrr & Proof \\   &  \\ CoT & 44.8 & 74.4 & 23.9 & 41.2 & 82.3 \\ ProGLM & 51.2 & **77.9** & \(-\) & 45.9 & 76.4 \\ SatLM & **63.4** & 76.4 & **30.0** & **50.6** & **96.4** \\   &  \\ CoT & 42.8 & 62.5 & 21.7 & 34.5 & 83.5 \\ ProGLM & 40.4 & **71.7** & \(-\) & 41.2 & 83.7 \\ SatLM & **63.6** & 70.3 & **30.4** & **58.2** & **99.7** \\   &  \\ ProGLM & 15.5 & **35.6** & \(-\) & 22.2 & 63.8 \\ SatLM & **16.5** & 34.2 & 19.6 & **30.2** & **86.6** \\   

Table 6: Results on gpt-3.5-turbo, text-davinci-003, and code-davinci-001. The effectiveness of SatLM can generalize across LLMs.

    & & GSM-SYS & GSM & CLUTrr \\   & Prog & 43.4 & **72.7** & 58.9 \\ Sat & **69.4** & 71.8 & **68.3** \\   & Prog & 41.4 & **72.5** & 59.0 \\ Sat & **71.8** & 71.3 & **67.9** \\   & Prog & 37.1 & **70.3** & 57.2 \\ Sat & **66.7** & 70.0 & **68.0** \\   

Table 7: The performance of ProgLM and SatLM with varying exemplar sets. SatLM consistently outperforms ProgLM on GSM-Sys and Clutrr.

Figure 4: Examples outputs from GSM (left) and BoardgameQA (right) show that LLMs can perform commonsense reasoning while parsing.

developments (Marcus, 2020; Garcez and Lamb, 2023). Various techniques have been proposed for improving reasoning abilities (Nye et al., 2021; Zhou et al., 2022; Kojima et al., 2022; Khot et al., 2022; Fu et al., 2022; Wang et al., 2022a; Li et al., 2022a; Lyu et al., 2023). They largely follow a chain-of-thought (Wei et al., 2022c) or scratchpad (Nye et al., 2021) paradigm. Among them, our work is the most related to the line of work that generates imperative programs to be executed by a symbolic executor, such as a Python interpreter (Gao et al., 2023; Chen et al., 2022) or domain-specific executors (Lyu et al., 2023). In this work, we propose a different paradigm that parses NL problems into declarative SAT problems and offloads the solving procedure to a SAT solver.

Previous work has also explored equipping LLMs with other tools, including search engines (Yu et al., 2023; Schick et al., 2023), calculators (Cobbe et al., 2021; Chowdhery et al., 2022), or other domain-specific special modules (Schick et al., 2023; Demeter and Downey, 2020). A line of work focuses on using program-related tools such as program executors (Poesia et al., 2022), program analysis tools (Jain et al., 2022), and synthesis tools (Rahmani et al., 2021) to enhance the quality of the generated code. Our works further explores improving LLMs with SAT solvers.

Concurrent work explores the intersection of LLMs and planning, parsing planning problems into PDDL descriptions and leveraging a classical planner to produce the plan (Liu et al., 2023a). Our work differs in that we use the SAT formulation to solve general reasoning tasks, including arithmetic reasoning and logical reasoning, which cannot be specified in PDDL.

Also concurrently, He-Yueya et al. (2023) combine LLMs and symbolic solvers for solving math problems. However, this work _only_ focus on arithmetic reasoning tasks and employs a math-specific symbolic solver (PySym). Our work takes a more general approach by formulating the problem within the scope of first-order logic and therefore is domain-agnostic. We also provide results of SatLM on the Algebra dataset collected by He-Yueya et al. (2023) in Appendix D.

## 6 Conclusion & Limitations

We have presented a framework for satisfiability-aided language models, casting a wide range of reasoning tasks into SAT problems under a unified formulation. We use an LLM to parse an NL query into a declarative specification and leverages a SAT solver to derive the final answer. Evaluation results on 8 datasets spanning 4 tasks across several LLMs demonstrate the effectiveness of our approach over program-aided language models.

LimitationsOur framework parses an NL problems into a set of declarative formulas. The NL description of some problems may already be more compatible with an imperative solving procedure, and our approach is likely to be less effective in these cases (e.g., SatLM slightly lags ProgLM on GSM). Future research can explore an integration or ensemble of these two prompting styles for more flexible reasoning.

SatLM heavily relies on the SAT solver and inherits some limitations of the SAT solver itself, such as computational cost when dealing with complex formulas involving quantifiers or nonlinear arithmetic. Moreover, SAT solvers can be limited by the expressiveness of the underlying theory, as not all theories can be easily encoded in first-order logic. Nevertheless, the wide range of tasks that we can instantiate our SatLM framework on shows its general applicability.

Our current approach parses a problem into a SAT specification, runs the solver, and returns the answer in a one-round fashion. One can imagine that unsatisfiable formulas or ambiguous formulas could be improved by re-prompting the model to improve the specification based on the exception signals, as explored in concurrent work for other problems (Paul et al., 2023; Madaan et al., 2023; Chen et al., 2023). We believe this is an exciting direction for future work.