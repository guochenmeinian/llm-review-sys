# LagrangeBench: A Lagrangian Fluid Mechanics Benchmarking Suite

Artur P. Toshev

equal contribution

artur.toshev@tum.de Gianluca Galletti

g.galletti@tum.de
1 Chair of Aerodynamics and Fluid Mechanics

Technical University of Munich

85748 Garching b. Munchen, Germany

Fabian Fritz

1 Chair of Aerodynamics and Fluid Mechanics

Technical University of Munich

85748 Garching b. Munchen, Germany

Stefan Adami

2 Munich Institute of Integrated Materials, Energy and Process Engineering

Technical University of Munich

85748 Garching b. Munchen, Germany

Nikolaus A. Adams

1 Chair of Aerodynamics and Fluid Mechanics

Technical University of Munich

85748 Garching b. Munchen, Germany

###### Abstract

Machine learning has been successfully applied to grid-based PDE modeling in various scientific applications. However, learned PDE solvers based on Lagrangian particle discretizations, which are the preferred approach to problems with free surfaces or complex physics, remain largely unexplored. We present LagrangeBench, the first benchmarking suite for Lagrangian particle problems, focusing on temporal coarse-graining. In particular, our contribution is: (a) seven new fluid mechanics datasets (four in 2D and three in 3D) generated with the Smoothed Particle Hydrodynamics (SPH) method including the Taylor-Green vortex, lid-driven cavity, reverse Poiseuille flow, and dam break, each of which includes different physics like solid wall interactions or free surface, (b) efficient JAX-based API with various recent training strategies and three neighbor search routines, and (c) JAX implementation of established Graph Neural Networks (GNNs) like GNS and SEGNN with baseline results. Finally, to measure the performance of learned surrogates we go beyond established position errors and introduce physical metrics like kinetic energy MSE and Sinkhorn distance for the particle distribution. Our codebase is available under the URL: [https://github.com/tumaer/lagrangebench](https://github.com/tumaer/lagrangebench).

## 1 Introduction

Partial differential equations (PDEs) are ubiquitous in engineering and physics as they describe the temporal and spatial evolution of dynamical systems. However, for practical applications, a closed analytical solution often does not exist and thus requires numerical methods like finite elements or finite volumes. We can broadly classify such numerical methods into two distinct families: Eulerian and Lagrangian. In Eulerian schemes (grid-based or mesh-based methods), spatially fixed finite nodes, control volumes, cells, or elements are used to discretize the continuous space. In Lagrangian schemes (mesh-free or particle methods), the discretization is carried out using finite material points, often referred to as particles, which move with the local deformation of the continuum. Eulerian and Lagrangian methods offer unique schemes with different characteristics dependent on the PDEs'underlying physics. This work exclusively focuses on the physics of fluid flows, i.e., we study the numerical solution to Navier-Stokes equations (NSEs), but offers the machine learning infrastructure for many more Lagrangian problems.

The smoothed particle hydrodynamics (SPH) method is a family of Lagrangian discretization schemes for PDEs, see, e.g., Monaghan  and Price  for an introduction to SPH. In SPH, the particles move with the local flow velocity, making it a genuine Lagrangian scheme, while the spatial differential operators are approximated using a smoothing operation over neighboring particles. One of the main advantages of SPH compared to Eulerian discretization techniques is that SPH can handle large topological changes with ease since (a) no connectivity constraints between particles are required, and (b) advection is treated exactly . However, SPH is typically more expensive than, e.g., a finite difference discretization on a comparable resolution due to its algorithmic complexity . Despite being initially devised for applications in astrophysics , SPH has gained traction as a versatile framework for simulating complex physics, including (but not limited to) multiphase flows , internal flows with complex boundaries , free-surface flows , fluid-structure interactions , and solid mechanics .

**Eulerian Machine Learning.** In recent years, the application of machine learning (ML) surrogates for PDE modeling has been a very active area of research with approaches ranging from physics-informed neural networks , through operator learning , to U-Net-based ones . Very recent efforts towards better comparability of such methods have resulted in benchmarking projects led by academia  and industry . However, both of these projects exclusively provide the software infrastructure for training models on problems in the Eulerian description and cannot be trivially extended to particle dynamics in 3D space. We note that convolutional neural networks (CNNs) are well suited for problems in the Eulerian description, whereas graph neural networks (GNNs) are best suited to describe points in continuous space. Given the somewhat shifted uprise of research on GNNs with respect to CNNs, we conjecture that particle-based PDE surrogates are still in their early stages of development.

**Lagrangian Machine Learning.** Generic learned physics simulators for Lagrangian rigid and deformable bodies were developed in a series of works using graph-based representations starting with the Interaction Networks  and their hierarchical version . There are numerous successors on this line of research mainly based on the graph networks (GN) formalism  which improve the network architecture , demonstrate great performance on control tasks , or introduce interactions on meshes in addition to the interaction radius-based graph . An alternative approach to modeling fluid interactions builds on the idea of continuous convolutions over the spatial domain , which has recently been extended to a more physics-aware design by enforcing conservation of momentum . An orthogonal approach to enforcing physical symmetries (like equivariance with respect to the Euclidean group of translation, rotations, and reflections) requires working in the spherical harmonics basis and has been originally introduced for molecular interactions , and recently also to fluid dynamics problems . Last but not least, some of the learned particle-based surrogates take inspiration from classical solvers to achieve equivariance  or to improve model performance on engineering systems .

In terms of data analysis, the closest to our work are those by Li and Farimani  and Toshev et al. . In Li and Farimani , a dam break and a water fall datasets are presented, the first of which is similar to our dam break, but without explicit wall particles. The Toshev et al.  paper uses a 3D TGV and a 3D RPF dataset of every 10th step of the numerical simulator. The fluid datasets from Sanchez-Gonzalez et al.  are similar in terms of their physics to the dam break from Li and Farimani , and also do not target temporal coarse-graining. We are the first to propose the challenging task of directly predicting every 100th numerical simulator step, on top of which we also introduce 2D/3D LDC, 2D TGV, and 2D RPF. The datasets we present are of diverse and well-studied engineering fluid mechanics systems, each of which has its unique challenges. To the best of our knowledge, there are still no established Lagrangian dynamics datasets to benchmark the performance of new models and we try to fill this gap.

To address the above shortcomings of existing research, we contribute in the following ways:

* **Seven new fluid mechanics datasets** generated using the SPH method. These include the 2D and 3D Taylor-Green vortex (TGV) , 2D and 3D reverse Poiseuille flow (RPF) , 2D and 3D lid-driven cavity (LDC) , and 2D dam break (DAM) . Each of these datasets captures different dynamics: TGV demonstrates the onset of turbulence, RPF has a spatially dependent external force field, LDC has static and moving wall boundaries, and DAM has a free surface.
* **Efficient JAX-based API** with various recent training strategies including additive random walk-type input noise  and the push-forward trick . Also, we offer three neighbor search backends two of which are the JAX-MD implementation  and a more memory-efficient version thereof, and the third one being the more flexible CPU-based implementation from matscipy.2 * **JAX implementation and baseline results of established GNNs** including: GNS , EGNN , SEGNN , and an adapted PaiNN model .

## 2 Datasets

To generate the datasets introduced in this work, we use the Lagrangian SPH scheme of Adami et al.  to solve the weakly-compressible NSEs  in two- and three-dimensional space. A non-dimensional form of the governing equations reads

\[}{t}() =-(}), \] \[}{t}(}) =- p+}^{2}}+, \]

where we denote with \(\) the density, \(}\) velocity, \(p\) pressure, \(\) Reynolds number (or the inverse of the nondimensional kinematic viscosity), and \(\) an external volumetric force field. For weakly-compressible flows, density fluctuations remain small and the pressure \(p\) is coupled with the density by the barotropic equation of state \(p()=c_{0}^{2}(-_{0})+p_{bg}\), where \(c_{0}\) denotes an (artificial) speed-of-sound, \(_{0}\) a reference density, and \(p_{bg}\) a background pressure .

SPH is a very well-established Lagrangian approximation method of the Navier-Stokes equations. It was introduced in the 70s [23; 35] and has become a standard method for numerical fluid mechanics. The core idea of SPH is to discretize a domain with fluid particles and define the properties of the fluid at some particular locations through a truncated radial kernel interpolation over neighboring particles. By rewriting the NSE in terms of kernel interpolations of the fluid properties (i.e. velocity, pressure, density), we arrive at a system of ODEs for the particle accelerations. By integrating twice we update the velocities and positions of the particles.

Figure 1: Time snapshots of our datasets, at the initial time (top), 40% (middle), and 95% (bottom) of the trajectory. Color temperature represents velocity magnitude. (a) Taylor Green vortex (2D and 3D), (b) Reverse Poiseuille flow (2D and 3D), (c) Lid-driven cavity (2D and 3D), (d) Dam break (2D).

To allow for the most fair runtime comparison in the baselines section, we implemented the SPH method presented in Adami et al.  in JAX and plan to open-source our code in the near future. Until then, we include validation results with more details on the solver parameters in Appendix B.

### Overview of datasets

Our datasets are generated following a few basic design principles:

1. Each physical system should contain different physics and at the same time have a solid theoretical underpinning in fluid mechanics literature.
2. The Reynolds number is selected as large as possible to still resolve all relevant scales and at the same time to not exceed 10k particles. Above this limit and depending on model choice one would need to discuss domain decomposition and multi-GPU computing, which is beyond the scope of the current work.
3. The number of training instances was deduced on the basis of scaling runs, which we discuss in Section 3. The size of the validation and test runs was chosen to achieve a ratio of training/validation/testing splits of 2/1/1. The reason for the comparably large number of validation and testing instances is that we compute up to 20-step rollout errors which are much noisier than 1-step errors and need to be averaged over more trajectories.

Also, all of our datasets are generated by subsampling every 100th step of the SPH solver to train towards an effective particle acceleration, i.e. temporal coarse-graining. As the stepsize of the numerical solver is governed by the CFL condition (see Equation (19) in Adami et al. ), for which we use a speed of sound of 10\(\) the maximum flow velocity and a CFL number of 0.25, then by taking every 100th step the fastest particle would move roughly 2.5\(\) the average particle distance. Learning to directly predict 100 times larger steps is a nontrivial task and given that we use an interaction radius of around 1.5\(\) the average particle distance for the connectivity graph, graph-based approaches need at least two layers to even cover the necessary receptive field.

Table 1 summarizes important physical properties of the datasets including the number of particles and trajectories, as well as the physical time step between training instances \( t\) and the average particle distance \( x\). To generate multiple trajectories of the same system (for TGV and DAM), we randomly draw the positions of the particles and let the system relax under periodic (for TGV) and non-periodic (for DAM) boundary conditions via 1000 steps of SPH relaxation. This relaxed state is then used as the initial state of the trajectories. For the statistically stationary cases (RPF and LDC) the simulation starts with fluid velocities equal to zero and runs until equilibrium. We start collecting data for the datasets after this point. In these cases, the training/validation/testing data is obtained by splitting one very long trajectory in its first half for training, third quarter for validation, and last quarter for testing. All trajectories are generated using the same Reynolds number \(Re\), which is also included in Table 1.

Both lid-driven cavity and dam break have solid wall boundaries, implemented using the established generalized wall boundary conditions approach . This approach relies on representing the walls

   Dataset &  Particle \\ number \\  &  Trajectory \\ length \\  &  Trajectory \\ count \\  &  \( t\) \\ \([ 10^{-3}]\) \\  &  \( x\) \\ \([ 10^{-3}]\) \\  & 
 Box L\(\)H\(\)D \\ \([-]\) \\  & \(\) \\ 
2D TGV & 2500 & 126 & 100/50/50 & 40 & 20 & 1\(\)1 & 100 \\
2D RPF & 3200 & 20k/10k/10k & 1 & 40 & 25 & 1\(\)2 & 10 \\
2D LDC & 2708 & 10k/5k/5k & 1 & 40 & 20 & 1.12\(\)1.12 & 100 \\
2D DAM & 5740 & 401 & 50/25/25 & 30 & 20 & 5.486\(\)2.12 & 40k \\ 
3D TGV & 8000 & 61 & 200/100/100 & 500 & 314.16 & 2\(\)\(\)2\(\)\(\)2\(\) & 50 \\
3D RPF & 8000 & 10k/5k/5k & 1 & 100 & 50 & 1\(\)2\(\)0.5 & 10 \\
3D LDC & 8160 & 10k/5k/5k & 1 & 90 & 41.667 & 1.25\(\)1.25\(\)0.5 & 100 \\   

Table 1: Datasets overview. Either the trajectory length or the number of trajectories is used for splitting into training/validation/testing datasets.

with "dummy" particles and then 1) enforcing a no-slip boundary condition at the wall surface by assigning to the wall particles the opposite velocity of that of the closest fluid particles, and 2) enforcing impermeability by assigning the same pressure to the wall particles as the pressure of the closest fluid. This approach requires using multiple layers of wall particles (in our case three), but we make the ML task even more difficult by leaving only the innermost wall layer in the dataset.

In the following, we briefly describe the datasets. For more details on the datasets we refer to Appendix C, and for dataset visualizations beyond Figure 1 to Appendix D.

Decaying Taylor-Green Vortex (TGV).This problem is characterized by periodic boundary conditions on all sides and a distinct initial velocity field without external driving force, which leads to a flow with decaying kinetic energy under the influence of viscous interactions. This system was first introduced by Taylor and Green  in 3D to study the transition of a laminar flow to turbulence. In **two dimensions**, this problem has an analytical solution being the exponentially decaying velocity magnitude and kinetic energy . We initialize the field with the velocity profile from  given in Equation (3) with \(k=2\). In **three dimensions**, the case has been explored in literature in-depth, and high-fidelity reference solutions have been generated . Unfortunately, with our limit on particle size of around 10k particles, we cannot resolve the Reynolds numbers from the literature and we chose to work with Re=50, for which we generated our own reference solution using the JAX-Fluids solver . The velocity field for the 3D case is given by Equation (4) with \(k=1\).

\[ u=-(kx)(ky), v=(kx)(ky). \] \[ u=(kx)(ky)(kz), v=-(kx)(ky)(kz), w=0. \]

Reverse Poiseuille flow (RPF).We chose the reverse Poiseuille flow problem  over the more popular Poiseuille flow, i.e. laminar channel flow, because it (a) does not require the treatment of boundary conditions as it is fully periodic and (b) has a spatially varying force field. And yet in the laminar case, we still should get the same solution as for the Poiseuille flow. However, our dataset is not fully laminar at \(Re=10\) and some mixing can be observed, making the dynamics more diverse. The physical setup consists of a force field of magnitude 1 in the lower half of the domain and -1 in the upper half. By this constant force, the system reaches a statistically stationary state, which in contrast to the regular Poiseuille flow exhibits rotational motion in the shearing layers between the two opposed streams. The only difference between the **two-dimensional** and **three-dimensional** versions of this dataset is the addition of a third periodic dimension without any significant change in the dynamics.

Lid-driven cavity (LDC).This case introduces no-slip boundaries, including a moving no-slip boundary being the lid that drives the flow. Treating wall boundaries with learned methods is a non-trivial topic that is typically treated by either 1) adding node features corresponding to boundary distance  or 2) having explicit particles representing the wall . The second approach has a greater generalization capability and we choose to include boundary particles in our datasets. However, instead of keeping all three layers of boundary particles required by the generalized boundary approach  in conjunction with the used Quintic spline kernel , we just keep the innermost layer by which we significantly reduce the number of particles in the system. The nominally **three-dimensional** version of the LDC problem with periodic boundary conditions in \(z\)-direction recovers the **two-dimensional** solution and learned surrogates should be able to learn the right dynamics in both formulations.

Dam break (DAM).The dam break system  is one of the most prominent examples of SPH because it demonstrates its capability of simulating free surfaces with a rather small amount of discretization points. In terms of classical SPH, one major difference between dam break and the previous systems is that the density cannot be simply computed by density summation due to the not full support of the smoothing kernel enforcing the use of density evolution . This is a potential challenge for learned surrogates, on top of which this case is typically simulated as inviscid, i.e. \(Re=\). To stabilize the simulation we used the established "artificial viscosity" approach  and added on top a very small amount of physical viscosity (leading to \(Re=40\)k) to reduce artifacts at the walls. We do not include a 3D version of this dataset as resolving all relevant features would result in exceeding our limit on the number of particles of 10k.

### Data format and access, software stack, extensibility

The datasets are stored as HDF5 files with one file for each of the training/validation/testing splits, and one JSON metadata file per dataset. The size of the datasets ranges between 0.3-1.5 GB for the 2D ones and 1.5-2 GB for the 3D ones, resulting in 8 GB total size of all 7 datasets. This size should allow for quick model development and testing, while still covering different types of physics when training on all datasets. The datasets are hosted on Zenodo and can be accessed under the DOI: doi.org/10.5281/zenodo.10021925, . A complete datasheet is provided in Appendix A.

Our benchmarking repository is designed for performance and is built on the JAX library  in Python, which is a high-performance numerical computing library designed for machine learning and scientific computing research. We started working on this benchmarking project before the major 2.0 release of the more popular PyTorch library , but even after this release introduced many of the speedup benefits of JAX, our experience shows that JAX is faster on graph machine learning tasks at the time of writing this paper. Check Appendix F for detailed speed comparison on a variety of problems. With the simple design of our JAX-based codebase and the use of the established PyTorch Dataloader, we plan to maintain the codebase in the foreseeable future. In our codebase we demonstrate how to download and use our datasets, but also how to download, preprocess, and use some of the datasets provided with the Sanchez-Gonzalez et al.  paper. We provide many examples of how to set up machine learning training and inference runs using yaml configuration files and plan to extend our codebase with more models and optimization strategies in the future.

Current limitations of our framework include that to use the speedup of JAX the ML models need to be compiled for the largest training/inference instance if system sizes vary. This limitation to static shapes for the just-in-time compilation is a known weakness of JAX and we note that it might be an issue to run inference on very large systems. To even allow for a varying number of particles during training we integrated the matscipy backend for the neighbors search because, to the best of our knowledge, there is no trivial way to achieve this functionality with the JAX-MD implementation . In addition, we also improve the memory requirements of the JAX-MD neighbor search routine (at the cost of runtime) by serializing a memory-heavy vectorized distance computation over adjacent cells in the cell list. This serialization significantly reduces the memory requirements of the code and could allow for computations with larger batch sizes or larger systems, see Appendix E.

Regarding future extensions of our datasets, we plan to add 1) a multi-phase problem, e.g. Rayleigh-Taylor Instability, and 2) a multi-phase flow with surface tension, e.g. drop deformation in shear flow. By multi-phase, we refer to fluids with different material properties. Introducing such complexity will require learning rich particle embeddings. Surface tension is a phenomenon that relates to how two different media interact with each other, and this would force the learned surrogate to learn complex interactions at low-dimensional manifolds.

## 3 Baselines

### Learning problem

We define the task as the autoregressive prediction of the next state of a Lagrangian flow field. For simplicity, we adapt the notation from . Given the state \(^{t}\) of a particle system at time \(t\), one full trajectory of \(K+1\) steps can be written as \(^{t_{0}:t_{K}}=(^{t_{0}},,^{t_{K}})\). Each state \(^{t}\) is made up of \(N\) particles, namely \(^{t}=(^{t}_{1},^{t}_{2},^{t_{N}})\), where each \(_{i}\) is the state vector of the \(i\)-th particle. Similarly, the system particle positions at time \(t\) are defined as \(^{t}=(^{t}_{1},^{t}_{2},^{t}_{N})\). The input node-wise features \(^{t}_{i}\) of particle \(i\) are extracted for every time step \(t\) based on a window of previous positions \(^{t-H-1:t}_{i}\) and optionally other features. In particular, the node features can be selected from:

1. The current position \(^{t}_{i}\).
2. A time sequence of \(H\) previous velocity vectors \(}^{t-H-1:t}_{i}\)
3. External force vector \(^{t}_{i}\) (if available).
4. The distance to the bounds \(^{t}_{i}\) (optional).

The nodes are connected based on an interaction radius of \( 1.5\) times the average interparticle distance similar to what is done in , which results in around 10-20 one-hop neighbors. Regardingthe edge features, they can be for example the displacement vectors \(_{ij}^{t}\) and/or distances \(d_{ij}^{t}\). The availability of some features is dataset-dependent. For example, the external force vectors are only relevant for reverse Poiseuille and dam break.

For every time step \(t\), the model will autoregressively predict the next step particle positions \(^{(t+1)}\) from the system state \(^{t}\) by indirectly estimating acceleration \(}\) or velocity \(}\), or by directly inferring the next position \(\). When using indirect predictions, the next positions \(^{(t+1)}\) are computed by semi-implicit Euler integration from acceleration or forward Euler from velocity. Finally, the next nodes' state \(^{(t+1)}\) is computed through feature extraction from the updated positions \(^{t-H:t+1}\).

### Baseline models

We provide a diverse set of graph neural networks [24; 22; 6] adapted for our learning task: GNS , which is a popular model for engineering particle problems; EGNN , which has shown promising results on N-body dynamics; SEGNN , which performs well on similar physical problems ; PaiNN , which is another simple yet powerful equivariant model from the molecular property-predictions literature. Our choice of GNNs is motivated by their natural extendibility to point cloud data, with relational information between nodes and local neighborhood interactions. Other models not strictly based on Message Passing, such as PointNet++  and Graph UNets , have also been considered, but go beyond the scope of the current work. Another non-MP alternative is Graph Transformers , but we found them not well-suited for our problems as they would not learn local interactions, which are essential for scaling to larger fluid systems.

**Graph Network-based Simulator (GNS).** The GNS model  is a popular learned surrogate for physical particle-based simulations. It is based on the encoder-processor-decoder architecture , where the processor consists of multiple graph network blocks . Even though the architecture is fairly simple, as it employs only fully connected layers and layer norm building blocks, GNS has been proven to be capable of modeling both 2D and 3D particle systems. However, performance on long rollouts is unstable and strongly depends on the choice of Gaussian noise to perturb the inputs.

**E(n)-equivariant Graph Neural Network (EGNN).** E(n)-equivariant GNNs are a class of GNNs equivariant with respect to isometries of the \(n\)-dimensional Euclidean space, namely rotations, translations, and reflections. While other popular equivariant models such as Tensor Field Networks , NequIP , and SEGNN  rely on expensive Clebsch-Gordan tensor product operations to compute equivariant features, the EGNN model  is an instance of E(\(n\)) equivariant networks that do not require complex operations to achieve higher order interactions; instead, it treats scalar and vector features separately: the scalars are updated similarly to a traditional GNN, while the vectors (positions) are updated following a layer-stepping method akin to a numerical integrator.

**Steerable E(3)-equivariant Graph Neural Network (SEGNN).** SEGNN  is a general implementation of an E(3) equivariant graph neural network. SEGNN layers are directly conditioned on _steerable attributes_ for both nodes and edges. The main building block is the steerable MLP: a stack of learnable linear Clebsch-Gordan tensor products interleaved with gated non-linearities . SEGNN layers are message passing layers  where Steerable MLPs replace the traditional non-equivariant MLPs for both message and node update functions. The flexibility of the SEGNN framework makes the model well suited for a wide array of physical problems, where vectorial and/or tensorial features can be modeled E(3)-equivariantly. Additionally, the steerable node and edge attributes provide a large flexibility for feature engineering choices. SEGNN is designed to work with 3D data and to make it work on the 2D datasets we set the third dimension to zero; this probably results in a less efficient code, but still preserves equivariance.

**Polarizable atom interaction Neural Network (PaiNN).** PaiNN  is yet another variant of E(3) equivariant GNN. Similarly to EGNN, PaiNN models equivariant interactions directly in Cartesian space, meaning separately for scalars and vectors, and does not require tensor products with Clebsch-Gordan coefficients. Because PaiNN was originally designed for molecular property prediction and wasn't intended for general-purpose applications, we had to extend its functionalities in two straightforward yet vital ways: (a) In the original implementation the input vectors are set to the zero vector \(^{F 3}\) (where \(F\) is the latent representation dimension) since there is no directional node information available initially for the problems considered in the paper. We add the possibility of passing non-zero input vectors, which are lifted to \(F\)-dimensional tensors by an embedding layer. (b) We include the Gated readout block  to predict vectorial features, e.g. acceleration.

**Model naming.** The models are named using the scheme _"[model]-[MP layers]-[latent size]"_. SEGNNs have one additional tag, the superscript "\(L=l\)", where \(l\) is the maximum tensor product order considered in the steerable MLP layers.

### Error measures

We measure the performance of the models in three aspects when evaluating on the test datasets:

1. **Mean-squared error** (MSE) of particle positions. \(_{n}\) is the \(n\)-step average rollout loss.
2. **Sinkhorn distance** as an optimal transport distance measure between particle distributions. Lower values indicate that the particle distribution is closer to the reference one.
3. **Kinetic energy error**\(E_{kin}\) (\(=0.5_{i}m_{i}v_{i}^{2}\)) as a global measure of physical behavior. Especially relevant for statistically stationary datasets (e.g. RPF, LDC) and decaying flows (e.g. TGV). \(E_{kin}\) is a scalar value describing all particles at a given time instance, and the \(MSE_{E_{kin}}\) is the MSE between the rollout and dataset \(E_{kin}\) evolution.

### Data scaling

Before we discuss the performance of different GNN baselines, we investigate the complexity of our datasets. One simple way to achieve that is by training one and the same model on different portions of each of the datasets. We chose to train on 1%, 5%, 10%, 20%, 50%, and 100% of our training datasets, and expect to see a saturation of model performance if more data does not add more information to the GNN training. We chose to work with the GNS model as it is probably the fastest (given its simplicity) and most popular one. The number of layers was set to 10 and the latent dimension to 64, which in our experience gives reasonable results. The results are summarized in Figure 2.

We started exploring data scaling with the 2D RPF dataset and that is why it has more training instances than most other datasets (2D RPF and 2D DAM have 20k training frames, whereas all others have 10k). It is 2D RPF from which we saw that 10k samples are enough and that is why most other datasets have roughly 10k training samples. Only dam break seems to keep improving with more data, probably due to the free surface which demonstrates different wave structures, but we decided to restrict the dataset size to twice as much as the others.

Figure 2: Scaling evaluation on all datasets. The \(x\)-axis shows the amount of available data, and the \(y\)-axis shows the position MSE loss values. The model is GNS-10-64 trained for 1M steps (with 40k steps early stopping). Every mark represents a new GNS instance trained with a different amount of data.

### Baseline performance

We benchmark each dataset by training every model with different hyperparameters. We observed that higher tensor product orders in SEGNN lead to better performance, but we restrict ourselves to \(L=1\) as higher values are increasingly expensive (see Table 3 for runtimes of \(L=\{1,2\}\)). Table 2 shows the best model performance we obtained on all the datasets, and thus sets the state-of-the-art on our datasets. We specify the number of layers and hidden dimensions in the same table and refer to Appendix G for a more complete description of the hyperparameters. Also, we refer to Appendix H for a more complete version of Table 2 including all experiments we conducted. Regarding the effect of the training strategies, we performed a comparison study and summarized the results in Appendix I.

An unfortunate result was that we could not make EGNN and our PaiNN version work well on our datasets. EGNNs are unstable in any configurations we tried, and no model converges to reasonable results. It was also reported in other papers  that EGNN gradients are often unstable and produce unfavorable results, especially when predicting the force vectors on larger systems. We leave further investigations to future work. To the best of our knowledge, we are the first to extend PaiNN to general vectorial inputs and consequently apply it to engineering data. We aimed to get similar results to SEGNN with \(L=1\), as in this special case both models only make use of \(L=\{0,1\}\) features. However, the loss we got was on average two orders of magnitude worse than with GNS or SEGNN possibly because, even with our changes, PaiNN is still designed for atomistic systems, which are in a multitude of ways different from our problem. We include our JAX implementation of both EGNN and PaiNN anyway, together with GNS and SEGNN, in the LagrangeBench code repository as working templates for future research. In Appendix G we include more details on what we tried with EGNN and PaiNN.

Looking at Table 2, we see that GNS performs best in most cases with boundary conditions (LDC and DAM) and SEGNN in most pure fluid problems. This result is consistent for smaller and bigger models (see Appendix H) and can be interpreted in two ways: 1) equivariance is not the right inductive bias for problems with boundary conditions, or 2) representing boundaries with one layer of dummy particles is not optimal for equivariant models. We leave this investigation to future work.

Further, we compare the performance of some instances of our baseline models in terms of inference speed and memory usage in Table 3. It is known that Clebsch-Gordan tensor products are slower than matrix-vector multiplications in fully connected layers, and we see this in the GNS-SEGNN comparison. We didn't expect EGNNs to be noticeably slower than GNS. We noticed in profiling that a large portion of EGNN runtime is spent in computing spatial periodic displacements and shifts (JAX-MD space functions, implemented with _modulo_ operations). Interestingly, when using non-periodic displacement and shift functions the inference time drops to 3.49ms for the 2D case (3.2K particles) and to 15.1ms for the 3D case (8.1K particles), which is closer to the expected runtime. On the other hand, PaiNN is quite fast to run despite having a significant memory usage likely caused by its design: PaiNN applies a 3\(\) uplifting to the latent embeddings, which are then

   Dataset & Model & MSE\({}_{5}\) & MSE\({}_{20}\) & Sinkhorn & MSE\({}_{E_{}}\) \\ 
2D TGV & SEGNN-10-64 & \(2.45.8\) & \(4.45.8\) & \(2.12.8\) & \(4.58.3\) \\
2D RPF & GNS-10-128 & \(1.11.2\) & \(3.31.2\) & \(1.42.7\) & \(1.74.4\) \\
2D LDC & GNS-10-128 & \(6.41.4\) & \(1.41.4\) & \(1.01.2\) & \(3.75.2\) \\
2D DAM & GNS-10-128 & \(1.37.2\) & \(3.37.2\) & \(1.42.0\) & \(1.31.7\) \\ 
3D TGV & SEGNN-10-64 & \(1.73.9\) & \(5.23.9\) & \(6.41.5\) & \(2.74.4\) \\
3D RPF & SEGNN-10-64 & \(3.02.9\) & \(1.82.9\) & \(2.91.6\) & \(3.51.5\) \\
3D LDC & GNS-10-128 & \(7.42.1\) & \(4.02.1\) & \(6.01.7\) & \(2.65.0\) \\   

Table 2: Baseline results of the best performing models. During training, the best model weights are tracked and saved based on the MSE\({}_{20}\) loss on the validation dataset. Reported metrics come from the best checkpoint and are averaged on the full test dataset, and over 3 different random seeds. The intervals are the standard deviation over the seeds.

split into three different representations. This uplifting requires a large matrix multiplication and we suspect that this causes the large memory footprint of PaiNN.

## 4 Discussion

In our work, we propose LagrangeBench, a novel JAX-based framework to develop and evaluate machine learning models on Lagrangian systems. To our knowledge, this is the first formalized benchmarking tool for engineering particle systems, and we consider it a necessary step in the future development of Lagrangian machine learning solvers. We provide a diverse set of 2D and 3D datasets with a solid foundation from engineering fluid simulations. Finally, we include a collection of baseline models originating from multiple machine learning fields and adapt them to our problem setting.

There are many possibilities for extensions of our framework, the most crucial of which is probably implementing a multi-GPU parallelization based on domain decomposition with load balancing. This would allow for training and inference of much bigger systems potentially up to tens of millions of particles with models like Allegro [47; 48]. There are also alternatives to the given yaml configuration files in order to automate hyperparameter tuning, which might speed up the development cycles of new machine learning models.

   } &  &  &  \\   & & 2D (3.2K) & 3D (8.1K) & 2D (3.2K) & 3D (8.1K) \\  GNS-5-64 & 161K & 2.05 & 8.63 & 1121 & 1889 \\ GNS-10-64 & 307K & 3.89 & 16.4 & 1121 & 1889 \\ GNS-10-128 & 1.2M & 6.66 & 32.0 & 1377 & 2913 \\  SEGNN-5-64\({}^{L=1}\) & 183K & 15.1 & 81.2 & 1377 & 2913 \\ SEGNN-10-64\({}^{L=1}\) & 360K & 29.7 & 161 & 1379 & 4963 \\ SEGNN-10-64\({}^{L=2}\) & 397K & 86.0 & 470 & 1893 & 9189 \\  EGNN-5-128 & 663K & 50.0 & 206 & 1377 & 4961 \\ PaiNN-5-128 & 1.0M & 9.09 & 54.2 & 3041 & 17505 \\   

Table 3: Inference time and memory usage of the models on 2D and 3D cases (forward only). Runtimes are averaged over 1000 forward passes on one system, RAM is reported as the max memory usage through the rollout. Evaluated on a single Nvidia A6000 48GB GPU.

## Author Contributions

A.T. and G.G. developed the codebase and ran the experiments together. A.T. led the project and focused on data loading, preprocessing, neighbor search, and reimplemented GNS. G.G. implemented the training pipeline, added the SEGNN, PaiNN, and EGNN models, and engineered the software package. F.F. and S.A. developed the first version of the in-house SPH solver. A.T. extended this solver and generated the datasets advised by F.F. and S.A. in terms of problem selection, literature references, and dataset analysis. N.A. supervised the project from conception to design of experiments and analysis of the results. A.T., G.G., F.F., and N.A. contributed to the manuscript.