# Unsupervised Learning for Solving the Travelling Salesman Problem

Yimeng Min

Dept. of Computer Science

Cornell University

Ithaca, NY, USA

min@cs.cornell.edu

&Yiwei Bai

Dept. of Computer Science

Cornell University

Ithaca, NY, USA

bywbilly@gmail.com

&Carla P. Gomes

Dept. of Computer Science

Cornell University

Ithaca, NY, USA

gomes@cs.cornell.edu

Equal contribution

###### Abstract

We propose UTSP, an Unsupervised Learning (UL) framework for solving the Travelling Salesman Problem (TSP). We train a Graph Neural Network (GNN) using a surrogate loss. The GNN outputs a heat map representing the probability for each edge to be part of the optimal path. We then apply local search to generate our final prediction based on the heat map. Our loss function consists of two parts: one pushes the model to find the shortest path and the other serves as a surrogate for the constraint that the route should form a Hamiltonian Cycle. Experimental results show that UTSP outperforms the existing data-driven TSP heuristics. Our approach is parameter efficient as well as data efficient: the model takes \(\) 10% of the number of parameters and \(\) 0.2% of training samples compared with Reinforcement Learning or Supervised Learning methods.

## 1 Introduction

Euclidean Travelling Salesman Problem (TSP) is one of the most famous and intensely studied NP-hard problems in the combinatorial optimization community. Exact methods, such as Concorde Applegate et al. (2006), use the cutting-plane method, iteratively solving linear programming relaxations of the TSP. These methods are usually implemented within a branch-and-cut framework, integrating the cutting-plane algorithm into a branch-and-bound search. While these exact methods can find solutions with guaranteed optimality for up to tens of thousands of nodes, the execution time can be exceedingly expensive. A different strategy is using heuristics such as LKH Helsgaun (2000). These heuristics aim to find near-optimal solutions with a notable reduction in time complexity. Typically, they are manually crafted, drawing upon expert insights and domain-specific knowledge.

Recently, the success of Graph Neural Networks (GNNs) for a variety of machine learning tasks has sparked interests in building data-driven heuristics for approximating TSP solutions. For example, Kwon et al. (2020) uses a data-driven approach known as Policy Optimization with Multiple Optima (POMO), POMO relies on Reinforcement Learning (RL) and avoids the utilization of hand-crafted heuristics. Qiu et al. (2022) proposes a Meta-Learning framework which enhances the stability of RL training. Sun and Yang (2023) applies Supervised Learning (SL) and adopts a graph-based diffusion framework. Additionally, the authors use a cosine inference schedule to improve the efficiency of their model. Joshi et al. (2019) trains their GNN model in a SL fashion, and the model outputs an edge adjacency matrix that indicates the likelihood of edges being part of the TSP tour. The edge predictions form a heat map, which is transformed into a valid tour through a beam search method. Similarly, Fu et al. (2021) trains the GNN model on small sub-graphs to generate the corresponding heat maps using SL. These small heat maps are then integrated to build a large final heat map.

Overall, these learning-based models usually build heuristics by reducing the length of TSP tours via RL or directly learning from the optimal solutions via SL. However, since TSP is NP-hard, SL can cause expensive annotation problems due to the costly search time involved in generating optimal solutions. For RL, when dealing with big graphs, the model will run into the sparse reward problem because the reward is decided after decoding a complete solution. The sparse reward problem results in poor generalization performance and high training variance. Furthermore, both RL and SL suffer from expensive large-scale training. These models take more than one million training samples when dealing with TSP with 100 nodes, making the training process very time-consuming.

## 2 Our Model

In this work, we build a data-driven TSP heuristic in an Unsupervised Learning (UL) fashion and generate the heat map non-autoregressively. We construct a surrogate loss function with two parts: one encourages the GNN to find the shortest path, and the other acts as a proxy for the constraint that the path should be a Hamiltonian Cycle over all nodes. The surrogate loss enables us to update the model without decoding a complete solution. This helps alleviate the sparse reward problem encountered in RL, and thus, it avoids unstable training or slow convergence Kool et al. (2019). Our UTSP method does not rely on labelled data, which helps the model avoid the expensive annotation problems encountered in SL and significantly reduces the time cost. In fact, due to the prohibitive time cost of building training datasets for large instances, many SL methods are trained on relatively small instances only Fu et al. (2021)Joshi et al. (2019). Such SL models scale poorly to big instances, while with our UTSP model, we can train our model on larger instances directly. Overall, our training does not rely on any labelled training data and converges faster compared to RL/SL methods.

The model takes the coordinates as the input of GNN. The distance between two nodes determines the edge weight in the adjacency matrix. After training the GNN, the heat map is converted to a valid tour using local search. We evaluate the performance of UTSP through comparisons on TSP cases of fixed graph sizes up to 1,000 nodes. We note that UTSP is fundamentally different from RL, which may also be considered unsupervised. While RL requires a Markov Decision Process (MDP), and its reward is extracted after obtaining solutions, our method does not use a MDP and the loss function (reward) is determined based on a heat map.

Overall, UTSP requires only a small amount of (unlabelled) data and compensates for it by employing an unsupervised surrogate loss function and an expressive GNN. The heat maps built using UTSP help reduce the search space and facilitate the local search. We further show that the expressive power of GNNs is critical for generating non-smooth heat maps.

## 3 Methodologies

In this paper, we study symmetric TSP on a 2D plane. Given \(n\) cities and the coordinates \((x_{i},y_{i})^{2}\) of these cities, our goal is to find the shortest possible route that visits each city exactly once and returns to the origin city, where \(i\{1,2,3,...,n\}\) is the index of the city.

### Graph Neural Network

Given a TSP instance, let \(_{i,j}\) denote the Euclidean distance between city \(i\) and city \(j\). \(^{n n}\) is the distance matrix. We first build adjacency matrix \(^{n n}\) with \(_{i,j}=e^{-_{i,j}/}\) and node feature \(^{n 2}\) based on the input coordinates, where \(_{i}=(x_{i},y_{i})\) and \(\) is the temperature. The node feature matrix \(\) and the weight matrix \(\) are then fed into a GNN to generate a soft indicator matrix \(^{n n}\).

In our model, we use Scattering Attention GNN (SAG), SAG has both low-pass and band-pass filters and can build adaptive representations by learning node-wise weights for combining multiple different channels in the network using attention-based architecture. Recent studies show that SAG can output expressive representations for graph combinatorial problems such as maximum clique and remain lightweight Min et al. (2022).

Let \(^{n n}\) denote the output of SAG, we first apply a column-wise Softmax activation to the GNN's output and we can summarize this operation in matrix notation as \(_{i,j}=e^{_{i,j}}/_{k=1}^{n}e^{_{k,j}}\).

This ensures that each element in \(\) is greater than zero and the summation of each column is 1. We then use \(\) to build a heat map \(\), where \(^{n n}\).

In our model, we use \(\) to estimate the probability of each edge belonging to the optimal solution and use \(\) to build a surrogate loss of the Hamiltonian Cycle constraint. This will allow us to build a non-smooth heat map \(\) and improve the performance of the local search.

### Building the Heat Map using the soft indicator matrix

Before building the unsupervised loss, let's recall the definition of TSP. The objective of TSP is to identify the shortest Hamiltonian Cycle of a graph. Therefore, the unsupervised surrogate loss should act as a proxy for two requirements: the Hamiltonian Cycle constraint and the shortest path constraint. However, designing a surrogate loss for the Hamiltonian Cycle constraint can be challenging, particularly when working with a heat map \(\). To address this, we introduce the \(\) transformation, which enables the model to implicitly encode the Hamiltonian Cycle constraint.

To better understand the \(\) transformation, we show a binary instance in Figure 1. Figure 1 illustrates a soft indicator matrix \(\), its heat map \(\) following the transformation \(\), and their corresponding routes. When we directly use the soft indicator matrix \(\) as the heat map. It can result in loops (parallel edges) between cities, such as (2,3) and (4,5) in Figure 1 (middle). After we apply the \(\) transformation, the corresponding heat \(\) is a Hamiltonian Cycle, as shown in the right part in Figure 1.

### \(\) transformation

We build the heat map \(\) based on \(\). As mentioned, \(_{i,j}\) is the probability for edge (\(i\),\(j\)) to belong to the optimal TSP solution. We define \(\) as:

\[=_{t=1}^{n-1}p_{t}p_{t+1}^{T}+p_{n}p_{1}^{T},\] (1)

Figure 1: We use a SAG to generate a non-smooth soft indicator matrix \(\). The SAG model is a function of coordinates and weighted adjacency matrix. We then build the heat map \(\) based on \(\) using the transformation in Equation 1.

where \(p_{t}^{n 1}\) is the \(t_{th}\) column of \(\), \(=[p_{1}|p_{2}|...|p_{n}]\). As shown in Figure 1, the first row in \(\) is the probability distribution of directed edges start from city \(1\), and since the third element is the only non-zero one in the first row, we then add directed edge \(1 3\) to our TSP solution. Similarly, the first column in \(\) can be regarded as the probability distribution of directed edges which end in city \(1\). Ideally, given a graph \(\) with \(n\) nodes, we want to build a soft indicator matrix where each row and column are assigned with one value 1 (True) and \(n-1\) values 0 (False), so that the heat map will only contain one valid solution. In practice, we will build a soft indicator matrix \(\) whose heat map \(\) assigns large probabilities to the edges in the TSP solution and small probabilities to the other edges.

Overall, the \(\) transformation in Equation 1 enables us to build a proxy for the Hamiltonian Cycle constraint. We further prove that \(\) represents one Hamiltonian Cycle when each row and column in \(\) have one value 1 (True) and \(n-1\) value 0 (False). We refer to the proof in appendix D.

### Unsupervised Loss

In order to generate such an expressive soft indicator matrix \(\), we minimize the following objective function:

\[=_{1}^{n}(_{j=1}^{n}_{i, j}-1)^{2}}_{}+_{2}^{n}_{i,i}}_{}+^{n}_{j=1}^{n}_{i,j} _{i,j}}_{}.\] (2)

The first term in \(\) encourages the summation of each row in \(\) to be close to 1. As mentioned, we normalize each column of \(\) using Softmax activation. So when the first term is minimized to zero, each row and column in \(\) are normalized (doubly stochastic). The second term penalizes the weight on the main diagonal of \(\), this discourages self-loops in TSP solutions. The third term can be regarded as the expected TSP length of the heat map \(\), where \(_{i,j}\) is the distance between city \(i\) and \(j\). As mentioned, since \(\) corresponds to a Hamiltonian Cycle given an ideal soft indicator matrix with one value 1 (True) and \(n-1\) value \(0\) (False) in each row and column. Then the minimum value of \(_{i=1}^{n}_{j=1}^{n}_{i,j}_{i,j}\) is the shortest Hamiltonian Cycle on the graph, which is the optimal solution of TSP. To summarize, we build a loss function which contains both the _shortest_ and the _Hamiltonian Cycle_ constraints. The _shortest_ constraint is realized by minimizing \(_{i=1}^{n}_{j=1}^{n}_{i,j}_{i,j}\). For the _Hamiltonian Cycle_ constraint, instead of writing it in a Lagrangian relaxation style penalty, we use a GNN which encourages a non-smooth representation, along with the doubly stochastic penalty, and the \(\) transformation.

### Edge Elimination

Given a heat map \(\), we consider \(M\) largest elements in each row (without diagonal elements) and set other \(n-M\) elements as 0. Let \(\) denote the new heat map, we then symmetrize the new heat map by \(^{}=+^{T}\). Let \(_{ij}\{0,1\}\) denote whether an undirected edge (\(i,j\)) is in our prediction or not. Without loss of generality, we can assume \(0<i<j n\) and define \(_{ij}\) as :

\[_{ij}=1,&^{}_{ij}=^{ }_{ji}>0\\ 0,&.\]

Let \(\) denote the set of undirected edges \((i,j)\) with \(_{ij}=1\). Ideally, we would build a prediction edge set \(\) with a small \(M\) value, and \(\) can cover all the ground truth edges so that we can reduce search space size from \(n(n-1)/2\) to \(||\). In practice, we aim to let \(\) cover as many ground truth edges as possible and use \(^{}\) to guide the local search process.

## 4 Local Search

### Heat Map Guided Best-first Local Search

We employ the best-first local search guided by the heat map to generate the final solution. Best-first search is a heuristic search that explores the search space by expanding the most promising node selected w.r.t. an evaluation function \(f(node)\). In our framework, each node of the search tree is a complete TSP solution. For the initialization of one search tree, we randomly generate a valid TSP solution and improve it using the 2-opt heuristic until no better solution is found. The expand action of the search node refers to Fu et al. (2021) and is based on the widely used k-opt heuristic Croes (1958), where it replaces \(k\) old edges (in the current solution) with \(k\) new edges, i.e., transforms the old solution to a new solution. More formally, we use a series of cities, \(u_{1},v_{1},u_{2},,u_{k},v_{k+1}\), to represent an action, where \(v_{k+1}=u_{1}\) to ensure it is a valid solution. All the edges \((u_{i},v_{i})\) (\(1 i k\)) are removed from the tour and \((v_{i},u_{i+1})(1 i k)\) are added to the tour. Note that once we know \(u_{i}\), \(v_{i}\) is deterministically decided. \(u_{1}\) is randomly selected for each expansion, and \(v_{1}\) is decided subsequently. Then we select \(u_{i+1}(i 1)\) as follows: (1) if \(u_{i+1}=u_{1}\), i.e., forms a new TSP tour, leads to an improved solution then we set \(u_{i+1}=u_{1}\) and have a candidate solution. (2) if \(i K\), then we will discard this action and start a new expand action, where \(K\) is a hyper-parameter which controls the maximal edges we can remove in one action. (3) otherwise, we select \(u_{i+1}\) based on the heat map stochastically. We use \(N_{u,v}\) to denote the times the edge \((u,v)\) is selected during the entire search procedure. The likelihood of selecting the edge \((u,v)\) is denoted by \(L_{u,v}~{}=~{}^{}_{u,v}+ +1}}\), where \(\) is a hyper-parameter and \(S\) is the local search's total number of expand actions. The first term encourages the algorithm to select the edge with a high heat map value, while the second term diversifies the selected edges. Moreover, when selecting the city \(v\) given \(u\), we only consider the cities from the candidate set of \(v\). This candidate set consists of cities with the top \(M\) heat map value or the nearest \(M\) cities

Among all the possible new solutions, we use the tour's length as the evaluation function \(f\), i.e., we select the solution of the shortest tour length as the next search node. For each search node, we try at most \(T\) expand actions. From these \(T\) expand actions, if no improved solution is found, we randomly generate a new initial solution and start another round of best-first local search.

### Updating the Heat Map

We borrow the idea of the backpropagation used in Monte Carlo Tree Search (MCTS). We use \(s\) to denote the current search node, \(s^{}\) to denote the next search node (\(s^{}\) has to improve \(s\)), and \(L(s)\) to represent the tour length of node \(s\). The heat map \(^{}\) is updated as:

\[^{}_{v_{i},u_{i+1}}=^{}_{v_{i},u_{i+1}}+ [()}{L(s)})-1],\]

where \(\) is a search parameters and \((v_{i},u_{i+1})(1 i k)\) is the actions used to transform \(s\) to \(s^{}\). We raise the importance of the edges that lead to a better solution. If we cannot find an improved solution for the current node, then no update is executed for the heat map.

### Leveraging Randomness

Randomness is shown to be very powerful in the local search community Gomes et al. (1998); Bresina (1996); Gomes et al. (2000). Our local search procedure also employs it to improve performance. When we stop the current round of local search by not finding an improved solution within \(T\) expand actions and switch to a new best-first local search with a new initial solution, we randomly modify the parameter \(K\). A larger \(K\) value results in more time searching from one initial solution. The intuition is that sometimes we want more initial solutions while sometimes we want to search deeper (replace more edges in k-opt) for a specific solution. Besides that, we also randomly decide how we construct the candidate set (based on the heat map or pairwise distance) for each city before the new round of local search.

## 5 Experiments

### Dataset

Our dataset contains 2,000 samples for training and 1,000 samples for validation. We use the same test dataset in Fu et al. (2021). The test dataset contains \(10,000\) 2D-Euclidean TSP instances for \(n=20,50,100\), and 128 instances for \(n=200,500,1,000\). We train our models on TSP instances with 20, 50, 100, 200, 500, and 1,000 vertices. We then build the corresponding heat maps based on these trained models.

### Results

Table 1, Table 2 and Table 3 present model's performance on TSP 20, 50, 100, 200, 500 and 1,000. The first three lines in the tables summarize the performance of two exact solvers (Concorde and Gurobi) and LKH3 heuristic Helsgaun (2017). The learning-based methods can be divided into RL sub-category and SL sub-category. Greedy decoding (G), Sampling (S), Beam Search (BS), and Monte Carlo Tree Search are the decoding schemes used in RL/SL. The 2-OPT is a greedy local search heuristic.

    &  &  &  \\  & & Length & Gap (\%) & Time & Length & Gap (\%) & Time \\  Concorde & Solver & 3.8303 & 0.0000 & 2.31m & 5.6906 & 0.0000 & 13.68m \\ Gurobi & Solver & 3.8302 & -0.0001 & 2.33m & 5.6905 & 0.0000 & 26.20m \\ LKH3 & Heuristic & 3.8303 & 0.0000 & 20.96m & 5.6906 & 0.0008 & 26.65m \\ GAT-RL1 & RL, S & 3.8741 & 1.1443 & 10.30m & 6.1085 & 7.3438 & 19.52m \\ GAT-RL1 & RL, S & 3.8501 & 0.5178 & 15.62m & 5.8941 & 3.5759 & 27.81m \\ GAT-RL2 & 2-OPT & & & & & & \\ GAT-RL2 & RL, S & 3.8322 & 0.0501 & 16.47m & 5.7185 & 0.4912 & 22.85m \\ GAT-RL2 & RL, G & 3.8413 & 0.2867 & 6.03s & 5.7849 & 1.6568 & 34.92s \\ GAT-RL2 & RL, BS & 3.8304 & 0.0022 & 15.01m & 5.7070 & 0.2892 & 25.58m \\ GCN-SL1 & SL, G & 3.8552 & 0.6509 & 19.41s & 5.8932 & 3.5608 & 2.00m \\ GCN-SL1 & SL, BS & 3.8347 & 0.1158 & 21.35m & 5.7071 & 0.2905 & 35.13m \\ GCN-SL1 & SL, BS * & 3.8305 & 0.0075 & 22.18m & 5.6920 & 0.0251 & 37.56m \\  POMO & RL & 3.83 & 0.00 & 3s & 5.69 & 0.03 & 16s \\  Att-GCRN &  SL+RL \\ MCTS \\  &  3.8300 \\  &  **-0.0074** \\  &  23.33s +** \\ 1.05m \\  &  5.6908 \\  &  0.0032 \\  & 
 2.59m + \\ 2.63m \\  \\ 
**UMSP (ours)** & UL, Search & 3.8303 & -0.0009 &  38.23s + \\ 1.04m \\  &  5.6894 \\  &  **-0.0200** \\  & 
 1.34m+ \\ 2.60m \\  \\   

Table 1: Results of SAG + Local Search w.r.t. existing baselines. We evaluate the models on 10,000 TSP 20 instances and 10,000 TSP 50 instances. Baselines include GAT-RL1: Deudon et al. (2018); GAT-RL2: Kool et al. (2019); GCN-SL1: Joshi et al. (2019); POMO: Kwon et al. (2020) and Att-GCRN Fu et al. (2021).

    &  &  &  \\  & & Length & Gap (\%) & Time & Length & Gap (\%) & Time \\  Concorde & Solver & 7.7609 & 0.0000 & 1.04h & 10.7191 & 0.0000 & 3.44m \\ Gurobi & Solver & 7.7609 & 0.0000 & 3.57h & 10.7036 & -0.1446 & 40.49m \\ LKH3 & Heuristic & 7.7611 & 0.0026 & 49.96m & 10.7195 & 0.0040 & 2.01m \\ GAT-RL1 & RL, S & 8.8372 & 13.8679 & 47.78m & 13.1746 & 22.9079 & 4.84m \\ GAT-RL1 & RL, S & 8.2449 & 6.2365 & 4.95h & 11.6104 & 8.3159 & 9.59m \\ GAT-RL2 & RL, S & 7.9735 & 2.7391 & 1.23h & 11.4497 & 6.8160 & 4.49m \\ GAT-RL2 & RL, G & 8.1008 & 4.3791 & 1.83m & 11.6096 & 8.3081 & 5.03s \\ GAT-RL2 & RL, BS & 7.9536 & 2.4829 & 1.68h & 11.3769 & 6.1364 & 5.77m \\ GCN-SL1 & SL, G & 8.4128 & 8.3995 & 11.08m & 17.0141 & 58.7272 & 59.11s \\ GCN-SL1 & SL, BS & 7.8763 & 1.4828 & 31.80m & 16.1878 & 51.0185 & 4.63m \\ GCN-SL1 & SL, BS * & 7.8719 & 1.4299 & 1.20m & 16.2081 & 51.2079 & 3.97m \\  POMO & RL & 7.77 & 0.14 & 1m & - & - & - \\   &  SL+RL \\ MCTS \\  &  7.7616 \\  &  0.0096 \\  &  3.94m + \\ 5.25m \\  &  10.7358 \\  &  0.1563 \\  & 
 20.62s + \\ 1.33m \\  \\ 
**UMSP (ours)** & UL, Search & 7.7608 & **-0.0011** &  5.68m + \\ 5.21m \\  &  10.7289 \\  & **0.0918** & 
 0.56m+ \\ 1.11m \\  \\   

Table 2: Results of SAG + Local Search w.r.t. existing baselines. We evaluate the models on 10,000 TSP 100 instances and 128 TSP 200 instances. Baselines include GAT-RL1: Deudon et al. (2018); GAT-RL2: Kool et al. (2019); GCN-SL1: Joshi et al. (2019); POMO: Kwon et al. (2020) and Att-GCRN Fu et al. (2021).

We compare our model with existing solvers as well as different learning-based algorithms. The performance of our method is averaged of four runs with different random seeds. The running time for our method is divided into two parts: the inference time (building the heat map \(\)) and the search time (running search algorithm).

On small instances, our results match the ground-truth solutions and generate average gaps of **-0.00009%**, **-0.002%** and **-0.00011%** respectively on instances with \(n=20,50,100\), where the negative values are the results of the rounding problem. The total runtime of our method remains competitive w.r.t. all other learning baselines. On larger instances with \(n\) = \(200,500\) and \(1,000\), we notice that traditional solvers (Concorde, Gurobi) fail to generate the optimal solutions within reasonable time when the size of problems grows. For RL/SL baselines, they generate results far away from ideal solutions, particularly for cases with \(n=1,000\). Our UTSP method is able to obtain **0.0918%**, **0.8394%** and **1.1770%** on TSP \(200,500\) and \(1,000\), respectively. We remark that UTSP outperforms the existing learning baselines on larger instances (TSP 200, 500, 1000) 2. More discussion between Fu et al. (2021) and UTSP can be found in Appendix C.

Our model takes less training time than RL/SL method because we require very few training instances. Taking TSP 100 as an example, RL/SL needs 1 million training instances, and the total training time can take one day using a NVIDIA V100 GPU, while our method only takes about 30 minutes with 2,000 training instances. The training data size does not increase w.r.t. TSP size. Our training data consists of 2,000 instances for TSP 200, 500 and 1,000. At the same time, the UTSP model also remains very lightweight. On TSP 100, we use a 2-layer SAG with 64 hidden units and the model consists of 44,392 trainable parameters. In contrast, RL method in Kool et al. (2019) takes approximately 700,000 parameters and the SL method in Joshi et al. (2022) takes approximately 350,000 parameters.

### Expressive Power of GNNs

Our UL method generalizes well to unseen examples without requiring a large number of training samples. This is because the loss function in Equation 2 is fully differentiable w.r.t. the parameters

    &  &  &  \\  & & Length & Gap (\%) & Time & Length & Gap (\%) & Time \\  Concorde & Solver & 16.5458 & 0.0000 & 37.66m & 23.1182 & 0.0000 & 6.65h \\ Gurobi & Solver & 16.5171 & -0.1733 & 45.63h & - & - & - \\ LKH3 & Heuristic & 16.5463 & 0.0029 & 11.41m & 23.1190 & 0.0036 & 38.09m \\ GAT-RL1 & RL, S & 28.6291 & 73.0293 & 20.18m & 50.3018 & 117.5860 & 37.07m \\ GAT-RL1 & RL, S & & & & & & \\ GAT-RL1 & 2-OPT & 23.7546 & 43.5687 & 57.76m & 47.7291 & 106.4575 & 5.39h \\ GAT-RL2 & RL, S & 22.6409 & 36.8382 & 15.64m & 42.8036 & 85.1519 & 63.97m \\ GAT-RL2 & RL, G & 20.0188 & 20.9902 & 1.51m & 31.1526 & 34.7539 & 3.18m \\ GAT-RL2 & RL, BS & 19.5283 & 18.0257 & 21.99m & 29.9048 & 29.2359 & 1.64h \\ GCN-SL1 & SL, G & 29.7173 & 79.6063 & 6.67m & 48.6151 & 110.2900 & 28.52m \\ GCN-SL1 & SL, BS & 30.3702 & 83.5523 & 38.02m & 51.2593 & 121.7278 & 51.67m \\ GCN-SL1 & SL, BS* & 30.4258 & 83.883 & 30.62m & 51.0992 & 121.0357 & 3.23h \\  DIMES & RL+S & 18.84 & 13.84 & 1.06m & 26.36 & 14.01 & 2.38m \\ DIMES & RL+MCTS & 16.87 & 1.93 & 2.92m & 23.73 & 2.64 & 6.87m \\ DIMES & RL+AS+MCTS & 16.84 & 1.76 & 2.15h & 23.69 & 2.46 & 4.62h \\ DIFUSCO & SL+MCTS & 16.63 & **0.46** & 10.13m & 23.39 & 1.17 & 24.47m \\  Att-GCRN &  SL+RL \\ MCTS \\  &  16.7471 \\  &  1.2169 \\  &   31.17s + \\ 3.33m \\  &  23.5153 \\  &  1.7179 \\  & 
 43.94s + \\ 6.68m \\  \\ 
**UTSP (Ours)** & UL, Search & 16.6846 & 0.8394 &  1.37m + \\ 1.33m \\  &  23.3903 \\  & **1.1770** & 
 3.35m+ \\ 2.67m \\  \\   

Table 3: Results of SAG + Local Search w.r.t. existing baselines. We evaluate the models on 128 TSP 500 instances and 128 TSP 1000 instances. Baselines include GAT-RL1: Deudon et al. (2018); GAT-RL2: Kool et al. (2019); GCN-SL1: Joshi et al. (2019); DIMES: Qiu et al. (2022); DIFUSCO: Sun and Yang (2023) and Att-GCRN Fu et al. (2021).

in SAG and we are able to train the model in an end-to-end fashion. In other words, given a heat map \(\), the model learns to assign large weights to more promising edges and small weights to less promising ones through backpropagation without any prior knowledge of the ground truth or any exploration step. However, when using SL, the model learns from the TSP solutions, which fails when multiple solutions exist or the solutions are not optimal Li et al. (2018). While for RL, the model often encounters an exploration dilemma and is not guaranteed to converge Bengio et al. (2021)Joshi et al. (2019). Overall, UTSP requires fewer training samples and has better generalization compared to SL/RL models.

We aim to generate a non-smooth soft indicator matrix \(\) and build an expressive heat map \(\) to guide the search algorithm. However, most GNNs aggregate information from adjacent nodes and these aggregation steps usually consist of local averaging operations, which can be interpreted as a low-pass filter and causes the oversmoothing problem Wenkel et al. (2022). The low-pass model generates a smooth soft indicator matrix \(\), which finally makes the elements in \(\) become indistinguishable. So it becomes difficult to discriminate whether the edges belong to the optimal solution or not. In our model, we assume all nodes in the graph are connected, so every node has \(n-1\) connected to neighbouring nodes. This means every node receives messages from all other nodes and we have a global averaging operation over the graph, this can lead to severe oversmoothing issue.

To avoid oversmoothing, one solution is to use shallow GNNs. However, this would result in narrow receptive fields and create the problem of underreaching Barcelo et al. (2020). Our model uses SAG because this scattering-based method helps overcome the oversmoothing problem by combining band-pass wavelet filters with GCN-type filters Min et al. (2022). Figure 2 illustrates the training loss on TSP \(100\) and the differences between our SAG model and the graph convolutional network (GCN) Kipf and Welling (2016), where GCN only performs low-pass filtering on graph signals Nt and Maehara (2019). When using GCN, the training loss decreases slowly, and the validation loss reaches a plateau after we train the model for 20 epochs. This is because the low-pass model generates a smooth \(\). Such a smooth \(\) results in an indistinguishable \(\), detrimtally impacting the training process. Instead, we observe lower training and validation loss when using SAG; this suggests that SAG generates a more expressive representation which facilitates the training process.

Figure 3 illustrates the generated heat maps using GCN and SAG on a TSP 100 instance, we choose this instance from the validation set randomly. When using the GCN, due to the oversmoothing problem, the model generates a smooth representation and \(\) becomes indistinguishable. The elements in \(\) have a small variance and most of them are \( 0.01\). Instead, the SAG generates a discriminative representation and the elements in the heat map have a larger variance.

Figure 2: TSP \(100\) training curve using Unsupervised Learning surrogate loss. We compare two GNN models: GCN Kipf and Welling (2016) and SAG Min et al. (2022), where GCN is a low-pass model and SAG is a low-pass + band-pass model.

Here, we train both GCN and SAG with the same loss function. So the differences illustrated in Figure 3 are the direct result of overcoming the oversmoothing problem.

## 6 Search Space Reduction

To understand what happens during our training process, we study how the prediction edge set \(\) changes with training time. As mentioned, let \(\) denote undirected edge set in \(^{}\), and let \(\) denote the ground truth edge set, \(=||/||\) is the extent of how good our prediction set \(\) covers the solution \(\). If \(=1\), then \(\) is a subset of \(\), which means our prediction edge set successfully covers all ground truth edges. Similarly, \(=0.95\) means we cover 95% ground truth edges.

Figure 4 shows how the average overlap coefficient \(\) changes with training epochs. We calculate the coefficient based on 1,000 validation instances in TSP 100. We notice that the coefficient quickly increases to \( 98\%\) after we train SAG for 10 epochs. This suggests that the surrogate loss successfully encourages the SAG to put more weights on the more promising edges. We also compare the performance with GCN. Since the loss does not decrease significantly during our training when using GCN (shown in Figure 2), it is not surprising to see the average overlap coefficient of GCN always maintains at a relatively low level. After training the model for 100 epochs, SAG model has an average coefficient of \(99.756\%\) while GCN only has \(33.893\%\).

We then study the number of cases where our prediction edge set \(\) covers the ground truth solution. Figure 4 (right) illustrates how the number of fully covered instances (\(=1\)) changes with time.

Figure 4: Left:Average edge overlap coefficient \(\) w.r.t. training epochs using SAG and GCN on TSP 100 (\(M=10\)), right: Number of fully covered instances w.r.t. training epochs using SAG and GCN on TSP 100. The validation set consists of 1,000 samples (\(M=10\)).

Figure 3: Left: The heat map \(\) generated using GCN on TSP 100. The diagonal elements are set to 0. \(X\)-axis and \(y\)-axis are the city indices, right: The heat map \(\) generated using SAG on TSP 100. The diagonal elements are set to 0. \(X\)-axis and \(y\)-axis are the city indices.

After training the model for 100 epochs, we observe 780 fully covered instances in 1,000 validation samples using SAG while 0 instances using GCN. Finally, we calculate the average of size \(||\). Our results show that SAG has an average size of \(583.134\) edges, while for GCN, the number is \(738.739\).

These results also indicate a correspondence between the loss and the quality of our prediction. In most SL tasks such as classification or regression tasks, a smaller validation loss usually means we achieve better performance and the minimum of the loss corresponds to the optimal solution (100% accuracy). However, there is no theoretical guarantee that our loss in Equation 2 also measures the solution quality. Our empirical results demonstrate that a lower surrogate loss encourages the model to assign larger weights on the promising edges and reduces the search space. This implies that we can assess the quality of the generated heat maps using our loss in Equation 2.

Overall, the UL training reduces the search space from \(4950\) edges to \(583.134\) edges with over \(99\%\) overlap accuracy on average. This helps explain why our search algorithm is able to perform well within reasonable search time.

## 7 Conclusion

In this paper, we propose UTSP, an Unsupervised Learning method to solve the TSP. We build a surrogate loss that encourages the GNN to find the shortest path and satisfy the constraint that the path should be a Hamiltonian Cycle. The surrogate loss function does not rely on any labelled ground truth solution and helps alleviate sparse reward problems in RL. UTSP uses a two-phase strategy. We first build a heat map based on the GNN's output. The heat map is then fed into a search algorithm. Compared with RL/SL, our method vastly reduces training cost and takes fewer training samples. We further show that our UL training helps reduce the search space. This helps explain why the generated heat maps can guide the search algorithm. On the model side, our results indicate that a low-pass GNN will produce an indistinguishable representation due to the oversmoothing issue, which results in unfavorable heat maps and fails to reduce the search space. Instead, after incorporating band-pass operators into GNN, we can build efficient heat maps that successfully reduce search space. Our findings show that the expressive power of GNNs is critical for generating a non-smooth representation that helps find the solution.

In conclusion, UTSP is competitive with or outperforms other learning-based TSP heuristics in terms of solution quality and running speed. In addition, UTSP takes \(\) 10% of the number of parameters and \(\) 0.2% of (unlabelled) training samples, compared with RL or SL methods. Our UTSP framework demonstrates that by providing a surrogate loss and a GNN which encourages a non-smooth representation, we can learn the hidden patterns in TSP instances without supervision and further reduce the search space. This allows us to build a heuristic by exploiting a small amount of unlabelled data. Future directions include designing more expressive GNNs (such as adding edge features) and using different surrogate loss functions. We anticipate that these concepts will extend to more combinatorial problems.

## 8 Acknowledgement

This project is partially supported by the Eric and Wendy Schmidt AI in Science Postdoctoral Fellowship, a Schmidt Futures program; the National Science Foundation (NSF) and the National Institute of Food and Agriculture (NIFA); the Air Force Office of Scientific Research (AFOSR); the Department of Energy; and the Toyota Research Institute (TRI).