# Extracting Training Data from Molecular Pre-trained Models

Renhong Huang\({}^{1,2}\), Jiarong Xu\({}^{2}\)\({}^{*}\), Zhiming Yang\({}^{2}\), Xiang Si\({}^{2}\),

**Xin Jiang\({}^{3}\)**, **Hanyang Yuan\({}^{1}\)**, **Chunping Wang\({}^{4}\)**, **Yang Yang\({}^{1}\)**

\({}^{1}\)Zhejiang University, \({}^{2}\)Fudan University, \({}^{3}\)Lehigh University, \({}^{4}\)Finvolution Group

{renh2, yuanhanyang, yangya}@zju.edu.cn,

{jiarongxu, zmyang20}@fudan.edu.cn, xsi21@m.fudan.edu.cn

xjiang@lehigh.edu, wangchunping02@xinye.com

This work was done when the author was a visiting student at Fudan University.Corresponding author.

###### Abstract

Graph Neural Networks (GNNs) have significantly advanced the field of drug discovery, enhancing the speed and efficiency of molecular identification. However, training these GNNs demands vast amounts of molecular data, which has spurred the emergence of collaborative model-sharing initiatives. These initiatives facilitate the sharing of molecular pre-trained models among organizations without exposing proprietary training data. Despite the benefits, these molecular pre-trained models may still pose privacy risks. For example, malicious adversaries could perform data extraction attack to recover private training data, thereby threatening commercial secrets and collaborative trust. This work, for the first time, explores the risks of extracting private training molecular data from molecular pre-trained models. This task is nontrivial as the molecular pre-trained models are non-generative and exhibit a diversity of model architectures, which differs significantly from language and image models. To address these issues, we introduce a molecule generation approach and propose a novel, model-independent scoring function for selecting promising molecules. To efficiently reduce the search space of potential molecules, we further introduce a Molecule Extraction Policy Network for molecule extraction. Our experiments demonstrate that even with only query access to molecular pre-trained models, there is a considerable risk of extracting training data, challenging the assumption that model sharing alone provides adequate protection against data extraction attacks. Our codes are publicly available at: https://github.com/renH2/Molecular.

## 1 Introduction

Deep learning has revolutionized various scientific disciplines, inspiring researchers to adopt these advanced techniques in drug discovery to accelerate molecule identification while reducing costs. Molecules are commonly represented by molecular graphs, capturing essential structural information. Consequently, Graph Neural Networks (GNNs) have demonstrated effectiveness in tasks like property prediction , drug discovery , and drug design . However, training these GNNs faces a significant challenge known as "data hunger" ; that is, a substantial amount of molecular data is required for training. For instance, developing a new drug often involves understanding intricate molecular behaviors and responses, which can only be achieved through the analysis of extensive molecular data.

This massive data requirement often exceeds what any single organization can collect and maintain on its own. This limitation leads to the necessity of collaborative efforts. Nevertheless, the direct sharing of data often raises concerns about commercial confidentiality and information privacy [8; 42]. In view of this, various graph pre-training techniques emerge as viable solutions. These techniques have demonstrated remarkable generalizability across various molecular datasets [54; 19; 22; 52], facilitating _model-sharing collaboration_. Organizations can leverage these advancements by sharing molecular pre-trained models that have been trained on proprietary molecular datasets without compromising data privacy. Then, model users are able to query these pre-trained models without access to any training data.

However, such model-sharing collaboration, while highly beneficial, is not devoid of vulnerabilities. One significant risk is the susceptibility to data extraction attacks [6; 7], where those with malicious intentions may attempt to access the private molecular training data. Such breaches could potentially compromise commercial secrets, violate privacy regulations, and undermine trust among collaborative partners . As the first in the literature, this work studies the problem of _molecular data extraction attacks_, aiming to explore the risks of extracting training data from molecular pre-trained models.

Extensive work has been done on data extraction attacks in the realms of image and text, suggesting that training data can be extracted from pre-trained models due to memorization effects [6; 7]. Yet, these methods are not applicable to molecular pre-trained models for three key reasons. _Firstly_, most of the existing data extraction attacks target at generative models (e.g., transformers and diffusion models) in text and image domains. From generative models, training data can be easily inferred via simple prompts (as depicted in Figure 1(a)). In comparison, most molecular pre-trained models are not generative. Instead, users of these models can only query the model with molecular graph and then obtain corresponding representations of this graph [62; 53; 18; 19; 55], which obstructs the direct extraction of molecular data (see Figure 1(b)). _Secondly_, while models in image and text domains typically employ widely recognized architectures like diffusion models  and transformers , molecular pre-trained models feature a much greater diversity in their architectures and training tasks, such as contrastive learning [47; 62; 53], context prediction [18; 55; 51], and graph reconstruction [19; 45]. These architectures often remain undisclosed to potential adversaries, adding an additional layer of complexity to any attempt at data extraction. _Lastly_, the vast combinatorial possibilities of molecules, estimated to number around \(10^{60}\), introduce a level of complexity that necessitates highly efficient and specialized methods for extracting molecular graphs.

In this paper, we first generate molecule candidates by combining a defined template structure, motif banks, and bond connectivity, all within the bounds of established chemical constraints. This serves

Figure 1: Data extraction attacks across text, image, and graph. **(a)** In domains like text and image, by inputting specific text prompts, private training data can be directly extracted from the outputs generated by models. **(b)** Conversely, in the graph domain, the pre-trained models are typically non-generative, and exhibit a diversity of pre-training tasks, such as contrastive learning, graph reconstruction, and context prediction.

as an alternative approach for molecule generation when direct data extraction from non-generative pre-trained models is not feasible. With these molecule candidates, we introduce a novel scoring function to determine whether potential molecules belong to the training data of a pre-trained model. This scoring function is model-independent, making it applicable across various architectures of molecular pre-trained models. To further reduce the search space for molecules and efficiently extract them, we introduce a Molecule Extraction Policy Network for generating those with high-scoring functions and meet the valency rule through reinforcement learning (RL). Extensive experiments break the illusion that sharing molecular pre-trained models, rather than raw data, adequately protects against data extraction attacks: despite only having query access to these black-box models, our findings reveal a significant risk of training data being extracted with an average precision of 49.0%.

## 2 Problem Formulation

In this section, we outline the scenario, describe the adversary's knowledge, and define the problem associated with molecular graph extraction attacks.

**Scenario.** Consider a real-world scenario within the pharmaceutical industry, where two companies collaborate under a commercial arrangement. Company A provides Company B with query access to a molecular pre-trained model to enhance drug research, for which Company B compensates with a usage fee. However, driven by the intent to gain a competitive advantage or reduce development costs, Company B may, with malicious intent, attempt to extract proprietary training data from this model. We explore the risks of data extraction associated with such a model-sharing collaboration, highlighting the potential for misuse and the ethical considerations it raises.

**Adversary's knowledge.** The adversary (in this case Company B) has _black-box_ access to the molecular pre-trained model. This access allows the adversary to query the model with a molecular graph and receive the corresponding graph representation in return, without any insight into the model architecture or the specific pre-training tasks it underwent. This setting mirrors common situations in the industry, particularly for models that are accessed via an API while keeping their internal workings undisclosed [2; 23; 27].

Additionally, adversaries may possess an _auxiliary dataset_ (\(_{}\)), which can be used to assist with data extraction efforts. This assumption is reasonable given that such an auxiliary dataset can be sourced from publicly available molecular databases like ChEMBL , PubChem , ZINC15 , or it could be some data held by the adversaries themselves.

**Molecular graph extraction attack.** In this paper, we explore the potential risk of molecular pre-trained models leaking their training molecule data. To thoroughly investigate this risk, we formally define the problem as follows:

**Problem 1** (Molecular Graph Extraction Attack): _Given the molecular pre-trained model \(f\) that has been pre-trained on a **private dataset**\(\), adversaries who only have query access to the model and access to an auxiliary dataset aim to obtain a subset of graphs \(_{}\) that exist within \(\)._

Here, the private information is defined as the molecular graphs within \(\). Since we are investigating the risks posed by molecular graph extraction attacks, we consider it sufficiently risky to deduce only a portion of the graphs or those similar to \(\).

## 3 Methodology

We first introduce the molecule generation process to generate molecule candidates in SS3.1. Further, we present a model-independent scoring function in SS3.2. Finally, to reduce the vast exploration space, we propose a Molecule Extraction Policy Network in SS3.3.

### Molecule Generation Process

Since molecular pre-trained models are non-generative, conducting a data extraction attack requires generating potential molecules to query the model. Here we design a molecule generation mechanism that specifically takes into account three key elements of molecule data: template structure, motif banks, and bond connectivity. By defining these elements, we can choose a template structure as a starting point and continuously select motifs and bonds that satisfy biochemical constraints to construct viable molecules.

**Template structure.** Before generating a molecule, we need to establish an effective starting point for the molecule, which is referred to as the template structure. This template structure plays a foundational role and should meet two strategic criteria: (1) Functional: the template structure should constitute the core structure of molecules. This structure influences the molecular properties but does not necessarily determine them. (2) Common: the template structure should be prevalent across a wide range of molecules. Both criteria are indispensable: If a template structure is only common but lacks functional significance, like an atom, then it fails to provide useful information on the structure of the molecules under interest. On the other hand, if a template is merely functional, such as thiols (typically found only in antioxidant molecules) , then the diversity of the extracted molecules would be restricted. Rings uniquely meet both criteria: they are prevalent across numerous molecular families, satisfying the common criterion, and as a functional structure, they significantly influence molecular stability, reactivity, and interactions with other molecules [9; 48]. Recognizing these advantages, we select rings as the template structure for molecule generation.

**Motif bank.** After a template structure is selected as the starting point for molecule generation, adversaries can then attach various molecule building blocks. Common choices include atoms [61; 31] and motifs [25; 60]. Yet, atoms might not be informative attachments, due to the limited structural information an individual atom can provide. Moreover, atoms may form atypical chemical fragments, such as alternating bond patterns that form incomplete aromatic rings . Therefore, we opt for motifs as the building blocks for molecule generation. In our implementation, we use the 91 common motifs extracted by . These common motifs constitute the motif bank.

**Bond connectivity.** Once we establish the template structure and motif banks, the next step is to consider the connectivity between the template structure and the motifs. Molecules are generated by forming bonds through specific attachment positions on the template structure and motifs. However, it is often not legal to attach an arbitrary bond to an arbitrary position. So expert chemical knowledge is needed in this process, and common chemical constraints should be satisfied. In this work, we obtain feasible attachment positions by utilizing CReM  for the decomposition of molecules in the auxiliary dataset \(_{}\).

Given a set of template structures and a motif bank, we first select a template structure \(R\) as the starting point and choose a motif \(M\) from the motif bank. Then, a bond \(B=\{a_{R},a_{M}\}\) is formed between the template structure \(R\) and the motif \(M\), subject to the satisfaction of chemical constraints, where \(a_{R}\) and \(a_{M}\) represent the attachment points in \(R\) and \(M\) respectively. This bonding results in \(\) as the union of \(R\) and \(M\) with the bond \(B\), which can be represented as \(:=RM\). In subsequent generation steps, we can take \(\) as our new starting point and select additional motifs and bonds. By repeating this process, we gradually construct a potential molecule.

### Scoring Function Design

This subsection introduces a scoring function to determine the probability of the existence of \(\) in the private training dataset \(\). The scoring function should be independent of any specific model architectures or pre-training tasks. In the following, we first define the scoring function, and then explain its rationality.

Since adversaries can only query the molecular pre-trained model to obtain representations, we derive insights from the representations of template structure \(R\), the motif \(M\), and their combined structure with bond \(B\), denoted as \(\), as provided by the pre-trained model \(f\). We define the scoring function as follows:

\[(R,M,)=(f(), f(R)+(1-)f(M)),\] (1)

where \(\) is a hyper-parameter, \(f()\), \(f(R)\), and \(f(M)\) are representations of \(\), \(R\), and \(M\) respectively, and \((,)\) can be defined as cosine similarity or other forms of similarity measure.

**Rationality of scoring function.** The crux of the scoring function's rationality lies in the observation that, for molecular pre-trained model, the relationship between representations \(f()\), \(f(R)\), and \(f(M)\) exhibits distinct patterns depending on whether \(\) is present in the private training dataset.

Consider Figure 2 as an illustrative example. In the top row, if the molecule \(:=RM\) exists in \(\), the obtained representation of \(R\) often contains information about \(M\), due to their frequent co-occurrence. Conversely, the obtained representation of \(M\) contains information about \(R\). Consequently, there exists a specific relationship: \(f()\) can be effectively approximated as a linear combination of the representations of two other molecules, \(f(R)\) and \(f(M)\), in the representation space, that is, \(f() f(R)+(1-)f(M)\). On the other hand, from the bottom row of this figure, if \(\) does not exist in \(G\), it is highly likely that \(f()\) is dissimilar with \( f(R)+(1-)f(M)\).

Additionally, we show that the scoring function is related to specific molecular pre-trained models with various \(\) values in Eq. (1). For instance, when the molecular pre-trained model employs bond-deletion augmentation in graph contrastive learning [62; 53], the value of \(\) in Eq. (1) is approximately \(\). For the molecular pre-trained model that employs subgraph augmentations in graph contrastive learning , the value of \(\) in Eq. (1) is approximately 1. Detailed proofs supporting these examples, as well as rationale behind the scoring function can be found in Appendix A.5. Furthermore, our analysis of the distribution of \(\) values across different pre-trained models in SS4.2 provide additional evidence.

Learning scoring function using auxiliary dataset.However, directly relying on the scoring function Eq (1) to extract training data still presents two challenges.

Firstly, the graph representations obtained from the pre-trained model may not be optimally suited for data extraction due to the discrepancy between the pre-training tasks and the task of data extraction. To mitigate this issue, we introduce an adapter \(g_{}\), instantiated as an MLP with learnable parameters \(\). This adapter is designed to project the representations obtained from the pre-trained model \(f\) into another representation space that is more conducive to facilitating a graph extraction attack. The transformation of representations is achieved through the mapping \(g_{} f()=g_{}(f())\), with the hope that the output is specifically tailored for the extraction task.

Secondly, treating \(\) as a fixed hyper-parameter in the scoring function introduces challenges in adaptability. A fixed \(\) may not adjust dynamically to different contexts or datasets, potentially limiting the attack's adaptability and leading to suboptimal performance. To overcome this limitation, we introduce a more adaptive mechanism that can optimize \(\) in response to changing contexts, by modeling \(\) as a function of \(=h_{}([f(R);f(M);f()])\).

Based on the above solutions, we transform the scoring function Eq. (1) into a learnable form:

\[_{\{,\}}(R,M,)=(g_{} f( {G}), g_{} f(R)+(1-)g_{} f(M)).\] (2)

We utilize the information contained in the auxiliary dataset \(_{}\) to learn the parameters \(\{,\}\). The key idea is that if the scoring function, parameterized by \(\{,\}\), can effectively determine the presence of a graph \(\) within \(_{}\), it is likely to generalize to the private training dataset \(\). The training process can be formalized as follows:

\[_{,}\ \ _{}_{} (_{\{,\}}(R,M,)),_{\{ _{}\}},\] (3)

where \(_{}\) is the cross-entropy function, \(_{\{\}}\) is the indicator function, and \(_{}\) is the mathematical expectation taken over all the possible generated molecules \(\).

### Molecule Extraction Policy Network

To conduct the molecular extraction attack, the most straightforward way is to enumerate all possible generated molecules and rank them using a specified scoring function, and then select those with the

Figure 2: Illustration of the validity in scoring function design. _Top row:_ the case that generated molecule \(\) exists in the private training dataset \(\). _Bottom row:_ the case that \(\) does not exist in \(\).

highest scores. This approach, inevitably, leads to an exponential increase in complexity due to the vast number of possible combinations.

Given that the molecular generation process involves the iterative selection of template structures and motifs to form bonds, it naturally aligns with the Markov Decision Process (MDP) framework , where each decision is based on the current state and leads deterministically to a new state. This sequential decision-making property allows for a structured exploration of the molecular space. We therefore introduce a Molecule Extraction Policy Network for molecular graph extraction attacks through RL, which significantly narrows the search space for molecules. This network strategically guides the selection of motifs and attachment points, focusing on the most promising options. We further detail our design.

**State space.** The state at time step \(t\), denoted as \(S_{t}\), is defined as the graph \(_{t}\) generated up to that point. The initial state \(_{0}\) represents the template structure \(R\), serving as the starting point for the molecular generation process.

**Action space.** At time step \(t\), the RL agent selects a motif \(M_{t}\) from the motif bank and determines the best attachment positions \(B_{t}=\{a_{_{t-1}},a_{M_{t}}\}\), resulting in the updated graph \(_{t}:=_{t-1}}{}M_{t}\). More specifically, the action at step \(t\) involves three stages: (1) Selecting attachment position \(a_{_{t-1}}\) on \(_{t-1}\); (2) Choosing a motif \(M_{t}\) from the motif bank; (3) Selecting attachment position \(a_{M_{t}}\) on \(M_{t}\) to form the bond \(B_{t}\). In summary, the action at step \(t\) can be expressed as \(A_{t}=\{a_{_{t-1}},M_{t},a_{M_{t}}\}\).

**Reward design.** We employ both delayed reward and intermediate reward to guide the molecular generation. For the delayed reward, we instantiate the reward \(r\) as the scoring function and extend it over multiple steps as follows:

\[r(S_{t},A_{t})=_{i=0}^{t-1}_{i}r(S_{i},A_{i})=_{i=0}^{t-1}_{ i}_{\{,\}}(_{i-1},M_{i-1},_{i}),\] (4)

where \(_{i}\) represents the weight for combining rewards from different \(_{i}\) on the trajectory. Intuitively, if \(_{t-1}\) exists in \(\), then the generated \(_{t}\) based on \(_{t-1}\) is more likely to exist in \(\). Therefore, we consider the molecule generation process as a whole and accumulate rewards by summation. Additionally, when \(t\) is small, the corresponding weight of the reward should be relatively high, whereas when \(t\) is large, the weight should be relatively low. Here, we set \(_{i}\) to \(0.99^{i}\). Regarding intermediate rewards, a positive reward \(\) is allocated when the generated molecules do not violate valency rules , ensuring that each atom has not exceeded its maximum possible valency. For molecules that fail to pass valency rules, the intermediate rewards are set to zero.

**Policy network.** To enable the RL agent to predict actions effectively, obtaining accurate molecular representations is crucial. We utilize a GNN to learn representations from molecules, a method proven effective for learning molecular representations . We can then obtain representations of attachment position \(z(a_{_{t-1}})\) and \(z(a_{M_{t}})\). For graph representations, such as motif representations, we apply sum pooling to derive the graph representation, represented as \(z(M_{t})\). Based on the representations, three networks (\(_{}\), \(_{}\), and \(_{}\)) are designed to predict the action \(A_{t}=\{a_{_{t-1}},M_{t},a_{M_{t}}\}\) across three stages. For the first stage, the RL agent selects an attachment position from \(_{t-1}\) according to the network \(_{}\), i.e.,

\[p_{t}^{}(a_{_{t-1}})=_{}(z(a_{_{t-1}})),\] (5)

where \(_{}\) outputs the probability distribution \(p_{t}^{}\) of \(a_{_{t-1}}\). We then obtain \(a_{_{t-1}}\) by sampling according to the probability \(_{}\). For the second stage, the RL agent tries to select the motif \(M_{t}\) from the motif bank based on selected \(a_{_{t-1}}\), i.e.

\[p_{t}^{}(M_{t})=_{}(z(a_{_{t-1}}):z(M _{t})),\] (6)where \(_{}\) takes in the representations of attachment position \(a_{_{t-1}}\) selected in stage 1 and motif \(M_{t}\), outputs the probability \(p_{t}^{}(M_{t})\) of selecting motif \(M_{t}\). Finally, given selected \(a_{_{t-1}}\) and \(M_{t}\), the agent selects attachment position \(a_{M_{t}}\) in motif \(M_{t}\) as:

\[p_{t}^{}(a_{M_{t}})=_{}z(a_{_{t- 1}}):z(a_{M_{t}}),\] (7)

where \(_{}\) outputs the probability distribution of \(a_{M_{t}}\). In the implementation, the three policy networks, \(_{}\), \(_{}\), and \(_{}\), consist of MLP layers with ReLU activations, followed by a softmax layer to predict the probabilities \(p^{}\), \(p^{}\), and \(p^{}\), respectively.

**Policy gradient training.** To enhance the exploration capability of the RL agent in capturing more molecules from \(\), we leverage the Soft Actor-Critic framework . Soft Actor-Critic integrates the entropy measure of the policy into the reward to promote the exploration of molecular generation. By maximizing entropy, we can obtain molecules with both high scores and diversity. Specifically, the policy network is trained with the objective as follows:

\[_{=\{_{},_{},_{}\}}_{ i=0}^{t-1}_{(S_{i},A_{i})_{}}[r(S_{i},A_{i})+ (( S_{i}))],\] (8)

where \((( S_{i}))\) is the entropy measure of the action distribution given the state \(S_{i}\) and \(\), known as the temperature parameter, controls the trade-off of exploration for molecules. The detailed modifications to the Soft Actor-Critic optimization can be found in Appendix A.3.

**Reward function initialization and update.** Since the reward function depends on the quality of the scoring function's training, and the scoring function's training, in turn, depends on the quality of the generated graphs, we consider initializing the scoring function for a warm-up phase. We first enumerate all possible molecules constructed by appending a motif to the template structure, and use them as the distribution of the generated graph to pre-train adapters \(g_{}\) and \(h_{}\) using Eq. (3). During the training process, as the quality of the generated graphs improves, the generated molecules can, in turn, enhance the RL learning framework. Specifically, we adjust the scoring function using the generated molecules as the distribution of the generated graph and training with Eq. (3).

## 4 Experiments

In this section, we evaluate the performance of molecular extraction attacks against different molecular pre-trained models. Besides, we conduct case studies, and runtime analyses to underscore the effectiveness of our approach. Additional results can be found in Appendix A.4.

### Experimental Setup

**Dataset.** In our experiment, we used datasets containing 2 million molecules sampled from ZINC15  as the pre-training dataset \(\), and an additional 20,000 molecules as the auxiliary dataset \(_{}\). The detailed statistics information is provided in the Appendix A.3.

**Molecular pre-trained models.** We selected the most common and widely used molecular pre-trained models from each category to demonstrate the versatility of the proposed method. These methods include: (1) Contrastive Learning: GraphCL , SimGRACE  InfoGraph ; (2) Graph Reconstruction: GraphMAE , AttrMasking , EdgePred , Mole-BERT ; (3) Context Prediction: ContextPred , Grover . Notably, the encoder architectures of Mole-BERT and Grover are based on Transformers or BERT structures and all the molecular pre-trained models are trained using the default hyper-parameters specified in original papers.

**Baselines.** Since existing methods are not designed for molecular extraction, we first tailor other methods to fit our setting. We enumerate all the potential molecules (constructed within one or two steps generation) and use metrics to select molecules as the prediction of \(_{}\). Our baselines can be roughly categorized into two groups: chemical property-based methods and learning-based methods.

For chemical property-based methods, we compare the _QED_ score , a common estimation of drug-likeness, which predicts the drug-like potential of a molecule. Additionally, the _SA_(Synthetic Accessibility) score is considered to measure the synthetic accessibility and rationality of molecules . We also introduce the _Docking_ score as our scoring function baseline to estimate the binding affinity between a ligand (small molecule) and a receptor (protein target). Specifically, we obtain three variants : _FA7_, _PARP-1_, and 5-_HT1B_. As for learning-based methods, we use an MLP classifier to predict the existence of \(\) in \(\). This classifier is trained by predicting the existence in \(_{}\) based on the representation of \(\). Detailed descriptions of baselines and the implementation of models are provided in the Appendix A.3.

**Metrics.** A molecular graph extraction attack is considered successful if a graph in \(_{}\) exists in \(\) or if \(_{}\) is similar to \(\). Therefore, assuming the model has generated \(_{}\) with \(K\) molecules, we adopt the following metrics to measure the performance of the extraction attack:

* **Precision** measures the ratio of generated molecules that exist within the \(\). The larger the precision is, the better the performance of the molecular extraction attack.
* **FCD**, also known as Frechet ChemNet Distance, offers a distance measure between \(\) and \(_{}\). This metric leverages ChemNet  to capture the differences in both the chemical and biological properties of the molecules. A lower FCD indicates that \(\) and \(_{}\) are similar in terms of chemical and biological properties, suggesting better extraction performance.

### Experimental Results

**Molecular extraction results.** Table 1 demonstrates the superior performance of our model over baselines across various molecular pre-trained models. Chemical property-based methods generally underperform, likely due to the infrequency of target properties in pre-trained datasets (e.g., QED). The better performance of SA indicates that molecular stability could be a significant indicator of molecule presence in real datasets. It is evident that our reinforcement learning approach significantly outperforms MLP method on precision and FCD across several pre-trained models, with average improvements of 30.9% and 3.97%, respectively, highlighting the effectiveness of our method.

We can also observe that AttrMasking is the most vulnerable to privacy leakage among the molecular pre-trained models. Furthermore, we have also compared the performance of proposed model under different model frameworks, and it consistently succeeds in molecular graph extraction across various

   &  &  \\   &  &  &  &  \\  & Prec. & FCD & Prec. & FCD & Prec. & FCD & Prec. & FCD \\  Random & 0.05 & 21.77 & 0.09 & 17.99 & 0.09 & 23.18 & 0.07 & 23.20 \\ QED & 0.14 & 23.95 & 0.37 & 21.75 & 0.05 & 23.71 & 0.06 & 23.47 \\ SA & 0.43 & 23.18 & 0.21 & 21.37 & 0.33 & 25.97 & 0.30 & 24.46 \\ F7 & 0.25 & 19.68 & 0.18 & 18.13 & / & / & / & / \\ PARP-1 & 0.27 & 21.85 & 0.23 & 19.47 & / & / & / & / \\
5-HT1B & 0.25 & 21.49 & 0.25 & 19.08 & / & / & / & / \\  MLP (GraphCL) & 0.48 & 20.47 & 0.32 & 21.06 & 0.29 & 23.17 & 0.19 & 23.17 \\ Ours (GraphCL) & 0.50 & 19.22 & 0.35 & 19.85 & 0.31 & 23.57 & 0.51 & 23.09 \\  MLP (SimGRACE) & 0.43 & 17.44 & 0.32 & 17.09 & 0.50 & 22.81 & 0.38 & 21.58 \\ Ours (SimGRACE) & 0.53 & 17.79 & 0.34 & 16.68 & 0.55 & 22.40 & 0.50 & 22.75 \\  MLP (InfoGraph) & 0.41 & 18.09 & 0.30 & 17.66 & 0.50 & 25.80 & 0.47 & 25.80 \\ Ours (InfoGraph) & 0.51 & 17.12 & 0.32 & 16.51 & 0.55 & 21.47 & 0.61 & 21.16 \\  MLP (GraphMAE) & 0.37 & 18.09 & 0.36 & 17.46 & 0.54 & 38.41 & 0.37 & 38.40 \\ Ours (GraphMAE) & 0.47 & 17.79 & 0.36 & 17.12 & 0.64 & 38.50 & 0.38 & 38.31 \\  MLP (AttrMasking) & 0.61 & 17.56 & 0.37 & 17.42 & 0.48 & 21.93 & 0.24 & 22.15 \\ Ours (AttrMasking) & 0.61 & 17.20 & 0.39 & 16.49 & **0.72** & 21.39 & **0.76** & 20.86 \\  MLP (EdgePred) & 0.61 & 17.56 & 0.37 & 16.98 & 0.59 & 23.82 & 0.59 & 22.77 \\ Ours (EdgePred) & **0.65** & 16.84 & **0.39** & 16.49 & 0.60 & 21.33 & 0.47 & 21.91 \\  MLP (Mode-BERT) & 0.39 & 18.02 & 0.32 & 17.81 & 0.50 & 33.53 & 0.32 & 33.53 \\ Ours (Mode-BERT) & 0.47 & 17.90 & 0.33 & **16.39** & 0.55 & 30.20 & 0.39 & 30.20 \\  MLP (ContextPred) & 0.39 & 18.57 & 0.36 & 17.20 & 0.60 & 21.32 & 0.38 & 21.66 \\ Ours (ContextPred) & 0.45 & 16.76 & 0.36 & 17.18 & 0.65 & 22.12 & 0.44 & 21.33 \\  MLP (Grover) & 0.25 & 17.32 & 0.22 & 17.09 & 0.29 & 18.96 & 0.24 & 18.99 \\ Ours (Grover) & 0.37 & **16.79** & 0.22 & 16.94 & 0.69 & **18.30** & 0.68 & **18.02** \\  

Table 1: We investigate the performance of molecular extraction results across various molecular pre-trained models, examining different values of \(K\) and different types of molecules (constructed in one-step or two-step generation). The notation “\(\)” indicates that the runtime exceeded three days.

pre-trained model architectures, including those based on BERT or transformers.

**Ablation study.** To validate the effectiveness of each component, ablation studies are conducted on: (1) Ours-RL, which adopts enumeration instead of an explorative RL framework. (2) Ours-SA, where the reward function is replaced with the most effective chemical property-based SA shown in Table 1. (3) Ours-adapter, which calculates the scoring function without adapters outlined in Eq.(1). In addition, we consider using an auxiliary dataset \(_{}\) that has lower similarity (_i.e._, higher FCD) to the pre-training dataset \(\) in order to simulate a more challenging molecular graph extraction attack scenario, and we denote it as Ours-hard.

As shown in Table 2, the superior performance of Ours compared to Ours-RL, Ours-SA, and Ours-adapter highlights the indispensable roles of the reinforcement learning framework, the scoring function, and the adapter for computing the scoring function. The degraded performance of Ours-hard can be attributed to training the scoring function via \(_{}\) with lower similarity, which in turn lowers the generalizability of the scoring function. However, Ours-hard still exhibits comparable performance and shows the robustness.

**Case study.** We further investigate the behavior of the scoring function under various molecular pre-trained models. We explore the \(\) distribution as shown in Figure 3. It is evident that self-supervised tasks within the same category exhibit a similar pattern in their \(\) distributions, whereas models from different categories display distinct distribution patterns. For graph reconstruction-based models, the \(\) distributions are predominantly centered around 0.35, with a peak indicating a high concentration. In contrast, for contrastive learning-based models, the \(\) distributions are flat, which may be attributed to the inherent randomness in the augmentations used in contrastive learning. As for context prediction tasks, the \(\) distributions are centered around 0.54. This phenomenon provides an explanation for the rationality of the scoring function in black-box scenarios.

**Runtime analysis.** Table 3 compares the runtime of the proposed method with the baselines across the two categories: chemical property-based methods, and learning-based methods. The proposed method exhibits superior extraction attack performance while maintaining a runtime that is comparable to others. This efficiency is achieved through the explorative RL framework, which replaces the need

   &  &  \\   & \(K=50\) & \(K=100\) & \(K=100\) & \(K=200\) \\  & Prec. FCD & Prec. FCD & Prec. FCD & Prec. FCD \\  Ours & 0.50 & 19.22 & **0.35** & 19.85 & **0.31** & 23.57 & **0.51** & 23.09 \\  Ours-RL & **0.56** & 18.67 & 0.35 & **17.52** & 0.30 & **21.28** & 0.40 & **20.73** \\ Ours-SA & 0.30 & 19.18 & 0.25 & 19.17 & 0.24 & 24.02 & 0.29 & 23.58 \\ Ours-adapter & 0.47 & **17.95** & 0.30 & 18.17 & 0.29 & 22.49 & 0.42 & 22.85 \\ Ours-hard & 0.43 & 18.48 & 0.29 & 18.28 & 0.28 & 21.92 & 0.35 & 21.42 \\  

Table 2: Ablation studies on the performance of molecular extraction results

Figure 3: Visualization of \(\) distribution under different pre-trained models. Models in the same category are assigned similar colors for distinction.

   & QED & SA & MLP & Ours \\  Score calculation & 632 & 259 & 2,000 & 944 \\ Total & 3,003 & 2,710 & 21,342 & 14,160 \\  

Table 3: Comparison of runtime (in seconds) for generating 200 molecules using a 2-step generation process. The learning-based methods are based on the GraphCL molecular pre-trained model.

for exhaustive enumeration of thousands of molecules, significantly reducing the time required for molecular graph extraction attacks.

## 5 Related Works

**Molecular pre-trained models**. Molecular pre-trained models utilize GNNs to capture the intricate non-Euclidean structure of molecular graphs, employing various self-supervised pre-training tasks to enhance generalization [57; 22; 12; 5; 21; 58]. Training on extensive molecular graphs, molecular pre-trained models can acquire generalized molecular graph representations and patterns, thereby benefiting various downstream tasks in the molecular domain [13; 53; 1; 30; 32]. Molecular pre-trained models typically employ self-supervised tasks as follows. (1) Contrastive Learning [47; 62; 53]. The objective of the contrastive pre-training task is to capture the similarities and dissimilarities between instances of subgraphs at the molecular level or motif level. (2) Graph Reconstruction [18; 55; 51]. Certain components (such as atoms, bonds, properties of atoms, and fragments) of molecules are masked out, and models are trained to recover components based on the remaining information. (3) Context Prediction [19; 45]. The objective of graph context prediction is to utilize subgraphs to make predictions of surrounding graph structures. This is achieved by classifying whether a specific neighborhood component and surrounding context belong to the same node within the ego-graph.

**Data extraction attacks.** Effectiveness and reliability of model can be compromised by adversarial attacks in various forms [63; 58]. Pre-trained models contain a large amount of knowledge, and data extraction attacks are among the methods aimed at extracting training data from these models [4; 24]. Research in this area can be broadly classified into two categories: one uses membership inference to deduce information from generative models, while the other exploits the memorization mechanism of networks to carry out attacks. In the first category,  generates text from pre-trained language models and performs membership inference attacks to filter the generated text for extraction. In the second category,  demonstrated that the effectiveness of data extraction is due to duplication in commonly used web-scraped training sets .  analyzed the extracted text from pre-trained language models and found these models do leak personal information as a result of memorization. However, all the aforementioned studies focus solely on the extraction from generative pre-trained models and do not adequately address the challenge of extracting data from graph pre-trained models.

## 6 Broader Impacts

We recognize that our investigation into Molecular Graph Extraction Attacks on graph-pretrained models could be misused, particularly in collaborative model-sharing, where it may lead to privacy risks. However, we emphasize that our primary objective is to identify vulnerabilities in graph pretrained models, and support the creation of more effective defense strategies. To this end, the paper assesses the susceptibility of mainstream graph-pretrained models to the attack, underscoring the need for enhanced defense measures for existing work.

Furthermore, we propose the following potential defense strategies: (1) Behavior Detection: Implement systems for continuous monitoring and identification of malicious queries in shared models to protect data integrity. (2) Prediction Perturbation: Since the efficacy of model extraction attacks is influenced by embeddings, we suggest introducing minor noise into the final outputs of graph-pretrained models without significantly affecting performance. We believe this ongoing interplay between attack and defense will foster a more robust research community, contributing to future studies on defense strategies.

## 7 Conclusion

The presented work, for the first time, aims to extract private training data from molecular pre-trained models. More specifically, we propose a reinforcement learning framework for molecule graph extraction attacks. We introduce a molecule generation approach and propose a well-motivated scoring function for selection. Experiments show that our proposed framework and scoring function can effectively perform the molecule extraction attack.

#### Acknowledgments

This work was partially supported by National Natural Science Foundation of China (No. 62206056, No. 92270121, No. 62176233, No. 62441605), CIPSC-SMP-Zhipu Large Model Cross-Disciplinary Fund (ZPCG20241030332) and the Fundamental Research Funds for the Central Universities.