# LIVE: Learnable In-Context Vector for Visual Question Answering

Yingzhe Peng\({}^{1,2}\), Chenduo Hao\({}^{1,2}\), Xinting Hu\({}^{3}\), Jiawei Peng\({}^{1},2\), Xin Geng\({}^{1,2}\), Xu Yang\({}^{1,2}\)

\({}^{1}\) Southeast University

\({}^{2}\) Key Laboratory of New Generation Artificial Intelligence Technology and

Its Interdisciplinary Applications (Southeast University), Ministry of Education, China

{yingzhe.peng, 213201447, pengjiawei, xgeng, xuyang_palm}@seu.edu.cn

\({}^{3}\) Nanyang Technological University

xinting001@e.ntu.edu.sg

###### Abstract

As language models continue to scale, Large Language Models (LLMs) have exhibited emerging capabilities in In-Context Learning (ICL), enabling them to solve language tasks by prefixing a few in-context demonstrations (ICDs) as context. Inspired by these advancements, researchers have extended these techniques to develop Large Multimodal Models (LMMs) with ICL capabilities. However, applying ICL usually faces two major challenges: 1) using more ICDs will largely increase the inference time and 2) the performance is sensitive to the selection of ICDs. These challenges are further exacerbated in LMMs due to the integration of multiple data types and the combinational complexity of multimodal ICDs. Recently, to address these challenges, some NLP studies introduce non-learnable In-Context Vectors (ICVs) which extract useful task information from ICDs into a single vector and then insert it into the LLM to help solve the corresponding task. However, although useful in simple NLP tasks, these non-learnable methods fail to handle complex multimodal tasks like Visual Question Answering (VQA). In this study, we propose Learnable In-Context Vector (LIVE) to distill essential task information from demonstrations, improving ICL performance in LMMs. Experiments show that LIVE can significantly reduce computational costs while enhancing accuracy in VQA tasks compared to traditional ICL and other non-learnable ICV methods. The code is available at https://github.com/ForJadeForest/LIVE-Learnable-In-Context-Vector.

## 1 Introduction

As language models continue to scale up, Large Language Models (LLMs)  have demonstrated emerging capabilities in In-Context Learning (ICL) : these models can solve language tasks when provided with a few similar examples, termed in-context demonstrations (ICDs), as context. Unlike traditional task-specific fine-tuning, ICL, a efficient method to adapt LLM to downstream task , achieves comparable performance without necessitating updates to millions or trillions of model parameters . By prefixing just a handful of data samples to the query input, ICL configures a model's behavior to produce the corresponding output, thus facilitating rapid adaptation across a wide range of downstream tasks. Inspired by these advancements in the language domain, researchers have extended these techniques to develop Large Multimodal Models (LMMs) with ICL capabilities .

Employing ICL in LLMs meets two challenges: Firstly, although increasing the number of ICDs typically enhances performance , this practice conflicts with computational efficiency constraints. As ICDs are prefixed to the query, the increase in input tokens severely impacts the Transformer's inference speed, causing a marked slowdown in computational performance. Secondly, the effectiveness of ICL is vulnerable to the selection of demonstrations [4; 11; 12; 13], particularly when only a limited number are used. It makes the process of choosing demonstrations critical for optimal performance. However, developing selection strategies and measuring the effectiveness of ICDs remain open questions [14; 15; 16; 17]. For LMMs, the challenges above are further exacerbated: 1) The computational complexity is significantly increased due to the integration of multiple data types as ICDs (as shown in Figure 1(a)). 2) The task of selecting effective multi-modal ICDs becomes more complex and nuanced, as each modality contributes uniquely to understanding the context [18; 19], further complicating the assessment of their combined effect in demonstration selection.

To alleviate these two challenges, recent research on LLMs has introduced In-Context Vector (ICV) to extract the most useful task information from ICDs, and then use it to directly influence the processing in LLMs [20; 21; 22]. For example,  proposes that by using multiple demonstrations and a dummy query as inputs, the representation of the last token from a middle layer of the model can be extracted as the vector. This vector is then used to replace the representation of the corresponding token in the same layer during inference, which can achieve performance comparable to ICL. Such in-context vector alleviates the requirement of multiple ICDs during inference, as well as effectively bypasses the complexity of the individual selection of demonstrations by representing the most effective components across many demonstrations.

However, these studies apply non-learnable strategies to extract ICVs, although useful in some simple NLP tasks, lose the efficacy in complex multi-modal tasks like Visual Question Answering (VQA). Our preliminary experiments have demonstrated that directly applying these non-learnable ICVs yields unsatisfactory results. The principal reason is the intrinsic complexity of VQA compared to the language tasks addressed by these non-learnable ICVs. For example, the previous methods focus on simple NLP task, such as Antonym  and Country-Capital , whose distribution patterns can be easily identified by LLMs. In contrast, as a unified vision-language task, VQA encompasses a diverse array of question types, where each one corresponds to a different vision-understanding task. For instance, questions like "What is this?" or "How many are there?" require classification and counting abilities, respectively. These varied requirements imply that the task information, which non-learnable methods attempt to abstract, cannot be effectively captured by a single ICV.

In this study, to make ICVs abstract more useful VQA task information, we try to distill the task information implied in demonstrations into a single **Learnable In-Context Vector** (LIVE). Our method is motivated by the observation  that ICL can be treated as a process of "shifting" the direction of the latent states of query towards the target, _i.e._, adding this latent state with a shift vector. Then we hope to learn suitable ICVs to replace the ICDs during inference to shift the direction. To achieve this, we train LIVE by minimizing the output distributions of a LMM got by only using LIVE and by inputting a few demonstrations. During training, we use different 32-shot randomly sampled demonstrations for different queries to distill task knowledge. Then LIVE is encouraged to capture the most essential task information from these different combinations by removing the individual characteristics of demonstrations. Moreover,  finds that during ICL, different layers of LLM

Figure 1: (a) Conventional ICL is more sensitive to the ICD selection and requires more inference time. (b) LIVE is more robust and reduces inference time by inputting a shift vector.

have diverse roles in addressing demonstrations. Then in our method, each layer is assigned with a unique ICV to capture more fine-grained task information.

Our LIVE inherits the efficiency of previous non-learnable ICVs, _i.e._, during inference, under the same performance conditions, LIVE only needs 1/24.97 FLOPs number of 32-shot ICL. Additionally, in VQAV2/OKVQA, LIVE improves accuracy by 2.36/1.6 compared to 32-shot ICL. We also compare LIVE to LoRA  that when comparable trainable parameters are used, LIVE requires much fewer training samples than LoRA (500 vs. 8000) to achieve satisfactory performance. Besides, we design lots of analytical experiments to validate whether LIVE can better shift the hidden states of queries to the target direction and analyze why previous non-learnable methods fail to solve VQA.

## 2 Related Work

**In-Context Vector:** Recently, more and more researchers in NLP have begun to focus on using an In-Context Vector (ICV) to modify the activation values during the forward propagation of LLM to simulate the effect of ICDs in ICL.  propose the "Task Vector", which extracts the representation of the middle layer from the LLM during ICL inference as the ICV, and replaces the representation of the same layer during zero-shot inference. Meanwhile,  introduced the "Function Vector", which uses attention weight analysis to take the mean of the activation values of the attention heads that most significantly affect the final result in ICL inference as the final ICV. This vector is then directly added to the representation of the middle layer during zero-shot inference to form a new representation. On the other hand,  propose "PCA In-Context Vector". They believe that the ICV should be closer to the LLM's representation of the task output and farther from the task input representation. Thus, they extract the input and output representations of several demonstrations and using PCA to find the overall principal direction as the ICV. These efforts mainly focus on using non-learnable methods to find the specific ICV for NLP tasks, achieving effects similar to ICL in various tasks. However, these methods only are tested on some simple tasks in NLP. When LMMs face with more complex tasks, the performance of these methods remains uncertain.

**ICL in LLM:** Prompt engineering allows LLMs to tackle specific tasks without requiring fine-tuning [26; 27; 28; 29; 30; 31; 32; 33]. A specific form of this approach, ICL, further improves these capabilities by creating prompts that include several demonstrations. ICL has already demonstrated superior performance and good generalization on many tasks [34; 7; 35; 36], and can be easily adapted to downstream tasks. However, the use of ICL faces several issues: first, ICL is very sensitive to the selection and arrangement order of demonstrations [37; 38; 39; 4; 11; 12; 4]; poor demonstrations can severely impact ICL performance. Second, too many demonstrations can significantly slow down the inference speed of LLMs . While ICVs can effectively address these two issues, as it can use only queries as input to the model while preserving ICL performance, without the need for demonstrations as input.

**ICL in LMM:** As the performance of LLMs continues to improve, an increasing number of researchers begin to adapt LLMs to the multimodal domain [41; 42; 43; 44; 45; 46]. Relying on the powerful inference capabilities of LLMs, some LMMs have started to exhibit ICL capabilities, such as Flamingo  and IDEFICS . Moreover, these models have significantly enhanced their ICL capabilities by concatenating multiple samples as contextual information during the training process. Currently, researchers mainly focus on how to configure demonstrations to address the sensitivity of ICL performance in LMMs. [18; 19] have respectively adopted heuristic retrieval methods for selecting demonstrations in Image Captioning and VQA. However, no researchers have yet extracted ICV from LMMs and evaluated it. Therefore, the effectiveness of ICV in LMMs still needs further exploration. Considering that the IDEFICS model shares the same model structure as Flamingo and possesses stronger ICL capabilities, we primarily focus on valid our method on the IDEFICS model.

## 3 LIVE: Learnable In-Context Vector

Here we show how to derive the formulation of the shift vector from Self-Attention (SA) mechanism and then introduce how to design LIVE based on this formulation. Generally, to implement In-Context Learning (ICL) using a language or multimodal model (LLM/LMM) \(\), the input has the following form: \(=\{_{D},}\}\), where \(_{D}=\{_{1},...,_{k}\}\) represents the concatenation of \(k\) In-Context Demonstrations (ICDs), and \(}\) denotes the query input, as shown in Figure 2. Given \(\) as _Key_ and _Value_, for each token \(_{i}\) of \(}\), applying _Self-Attention (SA)_ once yields:

\[(_{i},,)=(_{i},[ _{D}\\ }],[_{D}\\ }])=([_{i}_{D}^{ }_{i}}^{}])[_{D }\\ }],\] (1)

where vector \([_{i}_{D}^{}_{i}}^{}] ^{1 l}\) and \(l\) denotes the sequence length of the entire input \([_{D},}]\). Expanding the softmax function, we obtain:

\[([_{i}_{D}^{}_{i} }^{}]) =[_{i}_{D}^{})_{1}} {Z_{1}+Z_{2}},,_{i}_{D}^{})_{l_{c}}}{Z_{1}+ Z_{2}}}_{_{i}_{D}^{}},_{i}}^{ })_{1}}{Z_{1}+Z_{2}},,_{i}}^{})_{l_ {q}}}{Z_{1}+Z_{2}}}_{_{i}}^{}}]\] (2) \[=[_{i}_{D}^{})}{Z_{1}+Z_{2}} _{i}}^{})}{Z_{1}+Z_{2}}],\]

where \(l_{c}\) and \(l_{q}\) represent the lengths of the \(_{D}\) and \(}\), respectively. \(Z_{1}\) and \(Z_{2}\) are the sum of exponential scores between the query token \(_{i}\) with each token in \(_{D}\) and \(}\): \(Z_{1}=_{l_{c}}(_{i}_{D}^{})\) and \(Z_{2}=_{l_{q}}(_{i}}^{})\). This leads to the following formulation of SA:

\[(_{i},,) =_{i}_{D}^{})_{D}}{Z_{1}+Z_{2}} +_{i}}^{})}}{Z_{1}+Z_{2}}\] (3) \[=}{Z_{1}+Z_{2}}_{i}_{D}^{}) _{D}}{Z_{1}}+}{Z_{1}+Z_{2}}_{i}}^ {})}{Z_{2}}\] \[=}{Z_{1}+Z_{2}}(_{i}_{D}^{})_{D}+}{Z_{1}+Z_{2}}(_{i}}^{})}\] \[=\,(_{i},_{D},_{D})+(1-)\, (_{i},},}),\]

where \(=Z_{1}/(Z_{1}+Z_{2})\). Let \(h(z)=(_{i},z,z)\). The output of \((_{i})\) can then be expressed as:

\[(_{i},,)= h(_{D})+(1-)h(})\] (4)

As noted in Equation 4, we observe that \(h(})\) is the representation obtained with self-attention over the query \(}\) without appending any ICD; \(h(_{D})\) functions similarly to a "shift" vector, altering the attention representation \(h(})\) by incorporating contextual information from the ICDs \(_{D}\). The coefficient \(\) quantifies the degree of influence \(X_{D}\) has over the original query representation. For a visual demonstration of how ICDs shift the representation space, see Figure 2 (b). Consequently, once learning a general shift direction to replace the effect of \(h(_{D})\), we can employ this shift direction to simulate the ICL process of LMMs without actual demonstrations.

We propose a novel method that involves a **Learnable In-Context Vector** (LIVE) to simulate the ICL process without actual demonstrations. This approach aims to abstract general task information from demonstrations, enabling it to shift the model's representation toward the direction influenced by the ICDs. Figure 2 shows the training pipeline of LIVE. The LIVE training dataset, denoted as \(=\{_{1},,_{N}\}\), is a subset of the VQA dataset training split, created by randomly selecting \(N\) question-answer pairs from it. We use each training sample \(_{i}\) to simulate the query sample \(}\) in ICL, and randomly select \(k\) demonstrations from \(\{_{i}\}\) for it. Additionally,  shows that during

Figure 2: The LIVE training pipeline: (a) The distribution \((}|,;)\) of LMMs output when using LIVE. (b) Adding LIVE into the representations of the query to simulate the shift effect brought by demonstrations. (c) The distribution \((}|_{D};)\) of LMMs output when using demonstrations.

ICL, each layer of an LLM performs a distinct role. Motivated by this, we assume that for LMM, each layer also requires a specific shift direction. We assign a learnable vector \(_{l}\) and a weight factor \(_{l}\) for each layer \(l\) to learn the unique shift effect. Our final LIVE comprises of the vector set \(\) and the corresponding weight factor set \(\) as:

\[ =\{_{1},_{2},...,_{L}\}, v_{i}^{1  d}\] (5) \[ =\{_{1},_{2}...,_{L}\},_{i} ^{1 1},\]

where \(L\) is the number of layers. To train \(\) and \(\), we align the distribution of the model's outputs for the query when shifted by demonstrations, \((}|_{D};)\), with that shifted by our LIVE, \((}|,;)\). This alignment is achieved by minimizing the Kullback-Leibler (KL) divergence:

\[_{d}=((}|_{D};) |(}|,;))\] (6)

To obtain the distribution \((}|_{D};)\), for each query \(}\), we randomly select \(k\) demonstrations to form \(_{D}\). These are concatenated with the query to form the inputs for the model. The model's output for the query is then considered as the shifted distribution \((}|_{D};)\).

To obtain the output of \(}\) by using LIVE, we follow [20; 22], we use the vector \(_{l}\) to shift the each layer's output representation \(_{l}(_{i})\) and get: \(_{l}(_{i})^{}=_{l}(_{i})+_{l} _{l}\), which is shown in Figure 2(a). After applying LIVE to shift the representations at each layer, we obtain the output distribution \((}|,;)\). Notably, during training, \(_{D}\) for each query \(}\) includes randomly sampled 32-shot demonstrations. This strategy encourages our LIVE to extract the most useful common information from various demonstration combinations and prevents it from being influenced by the individual characteristics of certain demonstrations.

In addition, to facilitate the LIVE in acquiring more task-specific information, we also optimize the \((}|,;)\) with the ground truth by \(_{}\). Thus, the overall loss \(\) is defined as:

\[=_{}+_{}\,,\] (7) \[\ \ _{}=-_{i} (_{i},;).\]

where \(\) is the hyper-parameter to control the importance of ground truth loss.

## 4 Experiments

### Setting and implementation details

**Model and Dataset:** We evaluate our approach using the IDEFICS-9B model  across two datasets: VQAv2  and OKVQA . **VQAv2** emphasizes open-ended VQA tasks, encompassing \(4,437,570\) question-answer pairs in its training split, supplemented by an additional \(2,143,540\) pairs in the validation split. **OKVQA** is a large-scale dataset designed for models that require external knowledge to answer questions. It consists of \(14,055\) question-answer pairs, with \(9,009\) allocated for training and \(5,046\) for validation. For both VQAv2 and OKVQA datasets, We train our LIVE on \(8,000\) pairs from each training set. Due to computational resource limitations, we randomly sample \(10,000\) question-answer pairs from the VQAv2 validation split for evaluation . For OKVQA, we utilize the entire validation split.

**LIVE Setting:** During training, we assign 32-shot demonstrations for each query, enabling LIVE to acquire better directions of shifting vectors for VQA tasks. The \(_{i}\) is initialized using a normal distribution with a mean of \(0\) and a standard deviation of \(0.01\), and all \(_{i}\) are initialized to \(0.1\). More detailed training parameters can be found in Appendix.

### Results

#### 4.2.1 Compared Methods

We primarily compare the following methods:

**Zero-Shot**: The model uses only the query as input.

**k-Shot ICL**:The model uses \(k\) demonstrations, randomly selected from the VQA dataset training split, along with the query as input.

**Non-Learnable ICV Methods**: We extend three established non-learnable ICV methods from language models to our multimodal settings: (1) **Task Vector (TV) ** uses \(k\) demonstrations and a dummy query to extract the representation of the last token from a middle layer of the model as the ICV. During inference, this vector replaces the representation of the last token in the same layer. We conduct evaluations on **TV** by implementing it across various layers and select the layer where it achieves the highest performance improvement. (2) **Function Vector (FV) ** employs a small subset of the validation data to derive the mean output from critical attention heads, forming the ICV. During inference, this vector is added to the representations of the last token within a specific layer. We conduct evaluations on **FV** by implementing it across various layers and select the layer where it achieves the highest performance improvement. (3) **PCA In-Context Vector (PCA-ICV) ** computes the ICV by applying PCA to the difference between the question and question-answer representations from \(k\) demonstrations. During inference, these vectors are added to the representations of all tokens at each layer,

**LoRA **: This method finetunes the LMMs with the same number of samples of training LIVE. We add the LoRA module in the token classification head of the last layer. In this way, the number of trainable parameters is comparable to that of LIVE.

#### 4.2.2 Performance and Inference Efficiency on VQA.

We present performance comparisons with various methods in Table 1. Certain existing methods show only marginal improvements over Zero-Shot baselines, _e.g._, FV improves by 0.96/0.48 on VQAv2/OKVQA and PCA-ICV improves by 0.04 on OKVQA. Besides, we observe that all the previous non-learnable ICV methods do not reach the performance of the standard 32-shot ICL, _e.g._, the best non-learnable method, TV, is still 12.5/15.8 lower than 32-shot ICL on VQAv2/OKVQA. In contrast, our LIVE achieves an accuracy improvement of 2.36 on VQAv2 and 1.6 on OKVQA over 32-shot ICL. These results highlight the inefficacy of non-learnable methods in capturing essential task-specific information for VQA, whereas LIVE, by leveraging diverse 32-shot ICL demonstrations for each query during training, manages to abstract useful task information effectively. We further show that our LIVE outperforms LoRA with less trainable parameters, suggesting LIVE can abstract task information more efficiently.

Figure 3 displays the efficiency of LIVE during inference compared to other methods. We average the FLOPs and actual inference time consumption per forward pass over 1000 randomly sampled queries.1 We observe that LIVE only needs 1/24.97 FLOPs and 1/8.25 inference time of 32-shot ICL per forward pass. Additionally, LIVE maintains almost the same inference speed as Zero-Shot. These comparisons validate the efficiency of LIVE during inference.

### Ablation Studies

We use ablation studies to explore the effects of diverse settings, including different training losses, the shot number of demonstrations \(k\) used during training, and the number of training data \(N\).

Training Loss:Table 2 compares the results of using different losses: only \(_{gt}\) in Eq. (7) or \(_{d}\) in Eq. (7). We find that only using \(_{gt}\) (same as standard fine-tuning) significantly damages the performance, _e.g._, \(_{gt}\) achieves 16.9/6.12 lower accuracy on VQAv2/OKVQA compared to using the combined loss \(\); yet using only \(_{d}\) results in a smaller performance drop - 3.78/3.14 lower VQAv2/OKVQA than when using \(\). This suggests that with a limited number of trainable parameters, LIVE trained with \(_{d}\) is more robust and capable of capturing essential

    & **Zero-Shot** & **32-shot ICL** & **TV** & **FV** & **PCA-ICV** & **LoRA** & **LIVE (Ours)** \\  VQAv2 & 29.25 & 56.18 & 43.68 & 30.21 & 34.75 & 49.02 & **58.54** \\ OKVQA & 30.54 & 48.48 & 32.68 & 31.02 & 30.59 & 34.21 & **50.08** \\  Total Trainable Parameters & - & - & - & - & - & \(1,155,136( 8.8)\) & \(131,104( 1.0)\) \\   

Table 1: Accuracy (%) with Different ICVs Methods and Finetuning Methods, where numbers in parentheses indicate multiples of LIVE trainable parameters.

task information than \(_{gt}\). It underscores that the LIVE cannot solely rely on fine-tuning with LMMs on specific datasets, but should effectively leverage abstracted insights from demonstrations.

Number of Demonstrations \(k\):We compare the performance of LIVE trained with \(k\) demonstrations per query and the corresponding \(k\)-shot ICL in Table 3. The result shows that an increase in the number of demonstrations enhances the performance of ICL and LIVE, indicating that more demonstrations can provide each query with a richer context to help train LIVE. Additionally, LIVE consistently surpasses the performance of \(k\)-shot ICL across different training sizes, showcasing the robustness of our LIVE in utilizing demonstrations. Notably, when the number of demonstrations is limited, the performance gap between LIVE and ICL becomes more pronounced. This is because ICL is highly sensitive to the choice of demonstrations; with insufficient demonstrations, the model may shift the query representations in an incorrect direction. In contrast, LIVE continuously by learning the main shift direction of the query representations from the demonstrations, reduces the negative impact of poor demonstrations on the query during training and is more robust that can extract essential task information.

Size of Training Set:Figure 4 illustrates how varying the number of training samples impacts the performance of LIVE and LoRA. On the VQAv2 dataset, both methods show improved performance with increasing data sizes. Notably, LIVE performs exceptionally well across both low and high training sizes. It achieves performance close to that of 1-shot ICL with just 700 training samples and surpasses 32-shot ICL with 4,000 training samples. In contrast, LoRA does not exceed the performance of 1-shot ICL, even when expanded to 8,000 samples. For OKVQA, the performance of LoRA with small data sizes is even worse than Zero-Shot. This is because OKVQA requires external knowledge to answer questions, while learning external knowledge from a small amount of data can disrupt the inherent knowledge of the pre-trained model, leading to a significant drop in performance. Conversely, LIVE excels by focusing on learning shift direction, thus preserving the model's inherent reasoning abilities. With just 500 samples, LIVE outperforms 1-shot ICL, and with 4,000 samples, it nearly matches the performance of 32-shot ICL. These observations underscore LIVE's superior efficiency over LoRA in capturing and utilizing complex reasoning capabilities with much fewer training samples.

    & \(_{d}\) & \(_{gt}\) & \(\) \\  VQAv2 & 54.76 & 41.64 & 58.54 \\ OKVQA & 46.94 & 43.96 & 50.08 \\   

Table 2: Accuracy (%) of LIVE with Different Training Loss on VQA.

Figure 3: The total number of FLOPs and real inference time consumption of ICL, Zero-Shot, LIVE for 1000 query samples.

    &  &  \\   & & 1 & 4 & 8 & 16 & 32 \\   & LIVE & **56.84** & **57.60** & **58.25** & **58.27** & **58.54** \\  & ICL & 51.39 & 53.72 & 54.24 & 55.70 & 56.18 \\   & LIVE & **47.51** & **47.68** & **49.40** & **49.71** & **50.08** \\  & ICL & 40.75 & 46.11 & 46.79 & 47.70 & 48.48 \\   

Table 3: Accuracy (%) of Different Number of Demonstrations on VQA.

### Analysis

#### 4.4.1 The Shifting Effect in Latent Space

To better demonstrate the shifting effect of LIVE on query samples, we randomly select 200 query samples and conduct different methods of inference in LMMs. We extract the representation vector of the first answer token for T-SNE dimensionality reduction, shown in Figure 5. Additionally, to quantitatively evaluate the effect of shift directions of different ICV methods, we calculate the following metrics. Given a query \(}\), we use \(_{icl}\), \(_{zs}\), \(^{*}\) to denote the representation of the first answer token obtained by 32-shot ICL, Zero-Shot, specific ICV methods, respectively. Then we calculate the standard shift direction as \(_{gt}=_{icl}-_{zs}\) and the shift direction of specific ICV as \(^{*}=^{*}-_{zs}\). Finally, we define the shift direction similarity as the cosine similarity between \(^{*}\) and \(_{gt}\), indicating how closely the shift direction of the ICV method aligns with the standard shift direction. The results are presented in Table 4. From Figure 5, we can find that 32-shot ICL exhibits a significant shift compared to Zero-Shot, visualizing the shift effects given in Eq. 4. Considering both Table 4 and 1, we find that the shift direction similarity has positive correlation to the accuracy: if a method has large direction similarity, it also has better performance. For example, among non-learnable methods, TV has higher shift direction similarity than other ones, then it has better accuracy in Table 1. Furthermore, for LIVE which has the best accuracy in Table 1, its shift direction similarity is also the highest, which is 0.742/0.829 on VQAv2/OKVQA, validating that LIVE can produce shifts in query samples similar to 32-shot ICL, as visualized in Figure 5.

   & **TV** & **FV** & **PCA-ICV** & **LIVE** \\  VQAv2 & 0.486 & -0.106 & 0.027 & **0.742** \\ OKVQA & 0.326 & 0.218 & -0.190 & **0.829** \\  

Table 4: The shift direction similarities of different ICV methods.

Figure 4: Accuracy (%) of LIVE and LoRA with different size of training set.

Figure 5: T-SNE visualization of first answer token representations over 200 queries.

Such positive correlation validates the effectiveness of our motivation that a single LIVE can indeed simulate the ICL capability of LMMs by shifting the direction of the query representation.

#### 4.4.2 Why Non-Learnable Methods are Poor on VQA?

**Decoding ICV To Tokens:** We follow previous studies  to analyze the parameters of Transformers by directly decoding them into vocabulary tokens. Specifically, given a vector \(^{1 d}\), it can be projected using the unembedding matrix \(^{d}\) of LMMs to obtain the corresponding token probability distribution \(\), where \(\) is the vocabulary size:

\[=()=)}{_{j}()_{j}}.\] (8)

We calculate the \(\) of the vectors got from different methods in VQAv2 and select the top-\(10\) tokens with the highest probabilities in \(\) shown in Table 5. We can see that the tokens got from FV are not highly relevant to the VQA task, which proves that FV does not capture the task information of VQAv2. On the other hand, the frequency of "yes" and "no" tokens is relatively high in the decoding results of PCA-ICV and TV, suggesting that they prefer to capture the simple patterns from demonstrations, _e.g._yes/no, but struggle to grasp the overall task information of complex VQA. In contrast, the tokens of LIVE decoding are not biased to specific answers like yes/no, suggesting it abstracts more summary task knowledge of VQA.

**Hallucinations and Invalid Responses.**

VQA contains various answer types and for convenience, VQAv2 divides them into three categories: "yes/no", "number", and "other". After delving deeper into the answer details, interestingly, we find that TV frequently answers "yes or no" to number/other questions as shown in Figure 6 (1)(2)(3). We term this phenomenon the **yes/no hallucination** and count the frequency of the yes/no hallucination over all test data samples for different methods in Table 6. We can find that TV appears \(111\) times of yes/no hallucination, being consistent with the observations in Table 5, suggesting TV is biased to yes/no type question. We also observe that non-learnable methods tend to respond meaningless text (_e.g._"\(\)n") when responding to "number/other" questions as shown in Figure 6 (1)(2)(4). Table 6 shows the number of meaningless answers. We find that PCA-ICV and TV have more chance to return

    &  & **TV** & **FV** & **PCA-ICV** & **LIVE** \\  yes/no Hallucination & 5 & 111 & 7 & 4 & **3** \\  Meaningless Answer in yes/no & 0 & 0 & 0 & 2 & **0** \\ Meaningless Answer in number & 2 & 0 & 2 & 522 & **0** \\ Meaningless Answer in other & 257 & 0 & 247 & 2072 & **2** \\   

Table 6: The frequency of yes/no hallucinations and meaningless responses.

  
**Methods** & **Decoding Top-10 Tokens of different methods in order of decreasing probability** \\  TV & ‘No’, ‘Yes’, ‘no’, ‘It’, ‘I’, ‘To’, ‘The’, ‘A’, ‘yes’, ‘Not’ \\ FV & ‘\(\)’, ‘in’, ‘\(\)’, ‘(’, for’, ‘and’, ‘..., ‘to’, ‘on’, ‘I \\ PCA-ICV & ‘none’, ‘there’, ‘no’, ‘the’, ‘not’, ‘None’, ‘dep’, ‘yes’, ‘unknown’, ‘yes’ \\ LIVE & ‘Question’, ‘\(\)’, ‘\(\)’, ‘no’, ‘QUEST’, ‘questions’, ‘$?, ‘answer’, ‘Short’, ‘\(\)_questions’ \\   

Table 5: Direct decoding of the different ICV methods.

Figure 6: Visualizations of the cases where non-learnable methods appear yes/no hallucinations and meaningless responses.

meaningless answers for "other" questions, suggesting these methods do not capture the overall task information of VQA and are not able to answer some less frequently appeared questions. However, for LIVE, it has less yes/no hallucination and meaningless responses, validating that LIVE captures more robust task information of VQA.

## 5 Conclusion

To address the two major drawbacks of ICL in LMM--long computation time and sensitivity to demonstration selection--we try to apply non-learnable ICV methods from NLP to solve VQA. However, due to the complexity of VQA and the significant biases often inherent in non-learnable methods, the performance is unsatisfactory. Then we propose the Learnable ICV (LIVE) to overcome this drawback. By learning the general shift direction from a large amount of ICL data, LIVE successfully replaces the role of demonstrations in ICL. Experiments validate that LIVE outperforms traditional ICL methods and other non-learnable ICV methods on two VQA datasets. Experiments also show that LIVE, compared to LoRA, maintains excellent performance with minimal data, suggesting LIVE is a new research direction for LMMs to solve multimodal tasks. In the future, we will explore the application of LIVE on more multimodal tasks by various LMMs.