# Neural Synaptic Balance

Anonymous Author(s)

Affiliation

Address

email

###### Abstract

For a given additive cost function \(R\) (regularizer), a neuron is said to be in balance if the total cost of its input weights is equal to the total cost of its output weights. The basic example is provided by feedforward layered networks of ReLU units trained with \(L_{2}\) regularizers, which exhibit balance after proper training. We develop a general theory that extends this phenomenon in three broad directions in terms of: (1) activation functions; (2) regularizers, including all \(L_{p}\) (\(p>0\)) regularizers; and (3) architectures (non-layered, recurrent, convolutional, mixed activations). Gradient descent on the error function alone does not converge in general to a balanced state where every neuron is in balance, even when starting from a balanced state. However, gradient descent on the regularized error function must converge to a balanced state, and thus network balance can be used to assess learning progress. The theory is based on two local neuronal operations: scaling which is commutative, and balancing which is not commutative. Finally, and most importantly, given any initial set of weights, when local balancing operations are applied to each neuron in a stochastic manner, global order always emerges through the convergence of the stochastic algorithm to the same unique set of balanced weights. The reason for this convergence is the existence of an underlying strictly convex optimization problem where the relevant variables are constrained to a linear, only architecture-dependent, manifold. The theory is corroborated through simulations carried out on benchmark data sets. Balancing operations are entirely local and thus physically plausible in biological and neuromorphic networks.

## 1 Introduction

When large neural networks are trained on complex tasks, they produce large arrays of synaptic weights that have no clear structure and are difficult to interpret. Thus finding any kind of structure in the weights of large neural networks is of great interest. Here we study a particular kind of structure we call neural synaptic balance and the conditions under which it emerges. Neural synaptic balance is different from the biological notion of balance between excitation and inhibition (Froemke, 2015; Field et al., 2020; Howes and Shatalina, 2022; Kim and Lee, 2022; Shirani and Choi, 2023). We use this term to refer to any systematic relationship between the input and output synaptic weights of individual neurons or layers of neurons. Here we consider the case where the cost of the input weights is equal to the cost of the output weights, where the cost is defined by some regularizer. One of the most basic examples of such a relationship is when the sum of the squares of the input weights of a neuron is equal to the sum of the squares of its output weights.

**Basic Example:** The basic example where this happens is with a neuron with a ReLU activation function inside a network trained to minimize an error function with \(L_{2}\) regularization. If we multiply the incoming weights of the neuron by some \(>0\) (including the bias) and divide the outgoing weights of the neuron by the same \(\), it is easy to see that this scaling operation does not affect in any way the contribution of the neuron to the rest of the network. Thus, the component of the overallerror function that depends only on the input-output function of the network is unchanged. However, the value of the \(L_{2}\) regularizer changes with \(\) and we can ask what is the value of \(\) that minimizes the corresponding contribution given by:

\[_{i IN}( w_{i})^{2}+_{i OUT}(w_{i}/)^{2}=^{2} A+}B\] (1.1)

where \(IN\) and \(OUT\) denote the set of incoming and outgoing weights respectively, \(A=_{i IN}w_{i}^{2}\), and \(B=_{i OUT}w_{i}^{2}\). The product of the two terms on the right-hand side of Equation 1.1 is equal to \(AB\) and does not depend on \(\). Thus, the minimum is achieved when these two terms are equal, which yields: \((^{*})^{4}=B/A\) for the optimal \(^{*}\). The corresponding new set of weights, \(v_{i}=^{*}w_{i}\) for the input weights and \(v_{i}=w_{i}/^{*}\) for the outgoing weights, must be balanced: \(_{i IN}v_{i}^{2}=_{i OUT}v_{i}^{2}\). This is because its optimal scaling factor can only be \(^{*}=1\). Thus, we can define two operations that can be applied to the incoming and outgoing weights of a neuron: scaling and balancing. It is easy to check that scaling operations applied to any two neurons commute, whereas balancing operations do not commute if the two neurons are directly connected (Appendix). If a network of ReLU neurons is properly trained using a standard error function with an \(L_{2}\) regularizer, at the end of training one observes a remarkable phenomenon: for each ReLU neuron, the norm of the incoming synaptic weights is approximately equal to the norm of the outgoing synaptic weights, i.e. every neuron is balanced.

There have been isolated previous studies of this kind of synaptic balance (Du et al., 2018; Stock et al., 2022) under special conditions. For instance, in Du et al. (2018), it is shown that if a deep network is initialized in a balanced state with respect to the sum of squares metric, and if training progresses with an infinitesimal learning rate, then balance is preserved throughout training. Here, we take a different approach aimed at uncovering the generality of neuronal balance phenomena, the learning conditions under which they occur, as well as new local balancing algorithms and their convergence properties. We study neural synaptic balance in its generality in terms of activation functions, regularizers, network architectures, and training stages. In particular, we systematically answer questions such as: Why does balance occur? Does it occur only with ReLU neurons? Does it occur only with \(L_{2}\) regularizers? Does it occur only in fully connected feedforward architectures? Does it occur only at the end of training? And what happens if we balance neurons at random in a large network?

## 2 Generalization of the Activation Functions

What enables scaling ReLU neurons without changing their input-output function is the homogeneous property of ReLU activation function. An activation function \(f\) is said to be _homogeneous_ if for every \(>0\), \(f( x)= f(x)\). To fully characterize the class of homogeneous activation functions, we first define a new class of activation functions, corresponding to bilinear units (BiLU), consisting of two half-lines meeting at the origin.

**Definition 2.1**.: _(BiLU) A neuronal activation function \(f:\) is bilinear (BiLU) if and only if \(f(x)=ax\) when \(x<0\), and \(f(x)=bx\) when \(x 0\), for some fixed parameters \(a\) and \(b\) in \(\)._

BiLU units include linear units (\(a=b\)), ReLU units (\(a=0,b=1\)), leaky ReLU (\(a=;b=1\)) units, and symmetric linear units (\(a=-b\)), all of which can also be viewed as special cases of piece-wise linear units (Tavakoli et al., 2021), with a single hinge. One advantage of ReLU and more generally BiLU neurons, which is very important during backpropagation learning, is that their derivative is very simple and can only take one of two values (\(a\) or \(b\)). We have the following equivalence.

**Proposition 2.2**.: _A neuronal activation function \(f:\) is homogeneous if and only if it is a BiLU activation function._

Proof.: Every function in BiLU is clearly homogeneous. Conversely, any homogeneous function \(f\) must satisfy: (1) \(f(0x)=0f(x)=f(0)=0\); (2)\(f(x)=f(1x)=f(1)x\) for any positive \(x\); and (3) \(f(x)=f(-u)=f(-1)u=-f(-1)x\) for any negative \(x\). Thus \(f\) is in BiLU with \(a=-f(-1)\) and \(b=f(1)\). 

In the Appendix, we provide a simple proof that networks of BiLU neurons, even with a single hidden layer, have universal approximation properties.

While in the rest of this work we use BiLU neurons, it is possible to generalize the notions of scaling and balancing even further. To see this, suppose that there is a neuron with an activation function \(f: R\), and functions \(g:(a,b)\) and \(h:(a,b)\), such that: \(f(g()x)=h()f(x)\), for any \((a,b)\). Then if we multiply the incoming weights by \(g()\) and divide the outgoing weights by \(h() 0\) (generalized scaling), we see again that the influence of the neuron on the rest of the network is unchanged. And thus, again, we can try to find the value of \(\) that minimizes the regularization cost (generalized balancing). Here we provide an example of such an activation function, with \(g()=\) and \(h()=^{c}\). Additional details are given in the Appendix.

**Proposition 2.3**.: _The set of activation functions \(f\) satisfying \(f( x)=^{c}f(x)\) for any \(x\ \) and any \(>0\) consist of the functions of the form:_

\[f(x)=Cx^{c}& x 0\\ Dx^{c}& x<0.\] (2.1)

_where \(c\), \(C=f(1) R\), and \(D=f(-1)\). We call these bi-power units (BiPU). If, in addition, we want \(f\) to be continuous at \(0\), we must have either \(c>0\), or \(c=0\) with \(C=D\)._

Note that in the general case where \(c>0\), \(C\) and \(D\) do not need to be equal. In particular, one of them can be equal to zero, and the other one can be different from zero giving rise to rectified power units.

## 3 Generalization of the Regularizers

As we have seen, given a BiLU neuron, scaling its input and output weights by \(\) and \(1/\) respectively does not alter its contribution to the rest of the network and thus we can adjust \(\) to reduce or even minimize the contribution of the corresponding weights to the regularizer. It is reasonable to assume that the regularizer has the general additive form: \(R(W)=_{w}g_{w}(w)\) where \(W\) denotes all the weights in the network. Without much loss of generality, we can assume that the \(g_{w}\) are continuous, and lower-bounded by \(0\). To ensure the existence and uniqueness of a minimum during the balancing of any neuron, We will assume that each function \(g_{w}\) depends only on the magnitude \(|w|\) of the corresponding weight, and that \(g_{w}\) monotonically increases from \(0\) to \(+\). Clearly, \(L_{2},L_{1}\) and more generally all \(L_{p}\) regularizers are special cases where, for \(p>0\), \(L^{p}\) regularization is defined by: \(R(W)=_{w}|w|^{p}\). Differentiability conditions can be added to be able to derive closed form solutions for the balance (optimal scaling). This is satisfied by all forms of \(L_{p}\) regularization, for \(p>0\). We have the following theorem.

**Theorem 3.1**.: _(Balance and Regularizer Minimization) Assume an additive regularizer with the properties described above, where in addition we assume that the functions \(g_{w}\) are continuously differentiable, except perhaps at the origin. Then, for any neuron, there exists one optimal value \(^{*}\) that minimizes \(R(W)\). This value must be a solution of the consistency equation:_

\[^{2}_{w IN(i)}wg^{}_{w}( w)=_{w OUT(i)}wg^{ }_{w}(w/)\] (3.1)

_Once the weights are rebalanced accordingly, the new weights must satisfy the generalized balance equation:_

\[_{w IN(i)}wg^{}(w)=_{w OUT(i)}wg^{}(w)\] (3.2)

_In particular, if \(g_{w}(w)=|w|^{p}\) for all the incoming and outgoing weights of neuron \(i\), then the optimal value \(^{*}\) is unique and equal to:_

\[^{*}=|w|^{p}}{_{w IN(i)}|w|^{p}} ^{1/2p}=}{||IN(i)||_{p}}^{1/2}\] (3.3)

_After balancing, the decrease \( R 0\) in the value of the \(L_{p}\) regularizer \(R=_{w}|w|^{p}\) is given by:_\[ R=_{w IN(i)}|w|^{p}^{1/2}-_{w OUT (i)}|w|^{p}^{1/2}^{2}\] (3.4)

_After balancing neuron \(i\), its new weights satisfy the generalized \(L_{p}\) balance equation:_

\[_{w IN(i)}|w|^{p}=_{w OUT(i)}|w|^{p}\] (3.5)

Proof.: The results are obtained by setting the derivative of the regularizer with respect to the scaling factor \(\) to 0. Note that the theorem applies to regularizers combining different \(L_{p}\)'s (e.g. of the form \(\$alphaL_{2}+ L_{1}\)). The details are given in the Appendix. 

## 4 Generalization of the Architectures

It is straightforward to check that the scaling and balancing operations can be extended in the following cases (see Appendix for additional details):

1. Mixed networks containing both BiLU and non-BiLU units. One can just restrict those operations to the BiLU neurons.
2. Recurrent networks containing BiLU neurons, not just feedforward networks.
3. Networks that are not layered, or not fully connected.
4. In addition, scaling and balancing operations can be applied layer-wise to an entire layer of BiLU neurons in a tied manner, by using the same scaling factor \(\) with a single optimal value \(^{*}\) for all the neurons in the layer. In particular, this allows the application of scaling and balancing to convolutional layers of BiLU neurons.

## 5 Balancing Algorithms

**Gradient Descent:** When a network of BiLU neurons is trained by gradient descent to minimize an error function \(E(W)\), such as the negative log-likelihood of the data, there is no reason for the final weights to be balanced. However, when a network is properly trained to minimize a regularized error function \(=E(W)+R(W)\), the final weights ought to be balanced. The reason is that if a neuron is not in a balanced state at the end of training, then we can further reduce its contribution to \(R\) smoothly by balancing it. This implies that the gradient of \((W)\) is not equal to zero at the end of training, and thus training has not properly converged. The converse is that the degree of balance can be used as a proxy for assessing whether learning has converged or not.

**Stochastic Balancing:** More interestingly, we now investigate what happens if we fix the weights \(W\) of a network and iteratively balance its BiLU neurons.

**Theorem 5.1**.: _(Convergence of Stochastic Balancing) Consider a network of BiLU neurons with an error function \((W)=E(W)+R(W)\) where \(R\) is any \(L_{p}\)\((p>0)\) regularizer. Let \(W\) denote the initial weights. When the neuronal stochastic balancing algorithm is applied throughout the network so that every neuron is visited from time to time, then \(E(W)\) remains unchanged but \(R(W)\) must converge to some finite value that is less or equal to the initial value, strictly less if the initial weights are not balanced. In addition, for every neuron \(i\), \(_{i}^{*}(t) 1\) and the weights themselves must converge to a limit \(W^{*}\) which is globally balanced, with \(E(W)=E(W^{*})\) and \(R(W) R(W^{*})\), and with equality if only if \(W\) is already balanced. Finally, \(W^{*}\) is unique as it corresponds to the solution of a strictly convex optimization problem with special linear constraints that depend only on the network architecture (and not on \(W\)). Stochastic balancing projects to stochastic trajectories in the linear manifold that run from the origin to the unique optimal configuration._

Proof.: Each individual balancing operation leaves \(E(W)\) unchanged because the BiLU neurons are homogeneous. Furthermore, each balancing operation reduces the regularization error \(R(W)\), or leaves it unchanged. Since the regularizer is lower-bounded by zero, the value of the regularizer must approach a limit as the stochastic updates are being applied. However, this alone does not imply that the weights are converging and whether the limit is unique or not. To address these issues, for simplicity, we use a continuous time notation. After a certain time \(t\) each neuron has been balanced a certain number of times. While the balancing operations are not commutative as balancing operations, they are commutative as scaling operations. Thus we can reorder the scaling operations and group them neuron by neuron so that, for instance, neuron \(i\) has been scaled by the sequence of scaling operations of the form:

\[S_{_{1}^{*}}(i)S_{_{2}^{*}}(i) S_{_{n_{it}}^{*}}(i)= S_{_{i}(t)}(i)\] (5.1)

where \(n_{it}\) corresponds to the count of the last update of neuron \(i\) prior to time \(t\), and:

\[_{i}(t)=_{1 n n_{it}}_{n}^{*}(i)\] (5.2)

For the input and output units, we can consider that their balancing coefficients \(^{*}\) are always equal to 1 (at all times) and therefore \(_{i}(t)=1\) for any visible unit \(i\). At time \(t\) the weight connecting unit \(j\) to unit \(i\) is given by: \(w_{ij}(t)=w_{ij}(0)_{i}(t)/_{j}(t)\), where \(w_{ij}(0)\) corresponds to the initial value. In the Appendix, we show upfront that for all BiLU units \(i\), \(_{i}(t)\) converges to some limit \(_{i}>0\), and thus the weights converge too. Here, we first suppose that the coefficients \(_{i}(t)\) converge to some limit \(_{i}\), and recover the convergence at the end from understanding the overall proof. As a result, for any \(L_{p}\) regularizer, the coefficients \(_{i}\) corresponding to a globally balanced state must be solutions of the following optimization problem:

\[_{}R()=_{ij}|}{_{j}}w_{ij}|^{p}\] (5.3)

under the simple constraints: \(_{i}>0\) for all the BiLU hidden units, and \(_{i}=1\) for all the visible (input and output) units. In this form, the problem is not convex. Introducing new variables \(M_{j}=1/_{j}\) is not sufficient to render the problem convex. Using variables \(M_{ij}=_{i}/_{j}\) is better, but still problematic for \(0<p 1\). However, let us instead introduce the new variables \(L_{ij}=(_{i}/_{j})\). These are well defined since we know that \(_{i}/_{j}>0\). The objective now becomes:

\[ R(L)=_{ij}|e^{L_{ij}}w_{ij}|^{p}=_{ij}e^{pL_{ij}}|w_{ij}|^{p}\] (5.4)

This objective is strictly convex in the variables \(L_{ij}\), as a sum of strictly convex functions (exponentials). However, to show that it is a convex optimization problem we need to study the constraints on the variables \(L_{ij}\). In particular, from the set of \(_{i}\)'s it is easy to construct a unique set of \(L_{ij}\). However what about the converse?

**Definition 5.2**.: _A set of real numbers \(L_{ij}\), one per connection of a given neural architecture, is self-consistent if and only if there is a unique corresponding set of numbers \(_{i}>0\) (one per unit) such that: \(_{i}=1\) for all visible units and \(L_{ij}=_{i}/_{j}\) for every directed connection from a unit \(j\) to a unit \(i\).__Remark 5.3_.: This definition depends on the graph of connections, but not on the original values of the synaptic weights. Every balanced state is associated with a self-consistent set of \(L_{ij}\), but not every self-consistent set of \(L_{ij}\) is associated with a balanced state.

**Proposition 5.4**.: _A set \(L_{ij}\) associated with a neural architecture is self-consistent if and only if \(_{}L_{ij}=0\) where \(\) is any directed path connecting an input unit to an output unit or any directed cycle (for recurrent networks)._

Proof.: If we look at any directed path \(\) from unit \(i\) to unit \(j\), it is easy to see that we must have:

\[_{}L_{kl}=_{i}-_{j}\] (5.5)

This is illustrated in Figure 1. Thus along any directed path that connects any input unit to any output unit, we must have \(_{}L_{ij}=0\). In addition, for recurrent neural networks, if \(\) is a directed cycle we must also have: \(_{}L_{ij}=0\). Thus in short we only need to add linear constraints of the form: \(_{}L_{ij}=0\). Any unit is situated on a path from an input unit to an output unit. Along that path, it is easy to assign a value \(_{i}\) to each unit by simple propagation starting from the input unit which has a multiplier equal to 1. When the propagation terminates in the output unit, it terminates consistently because the output unit has a multiplier equal to 1 and, by assumption, the sum of the multipliers along the path must be zero. So we can derive scaling values \(_{i}\) from the variables \(L_{ij}\). Finally, it is easy to show that there are no clashes, i.e. that it is not possible for two different propagation paths to assign different multiplier values to the same unit \(i\) (see Appendix). 

_Remark 5.5_.: Thus the constraints associated with being a self-consistent configuration of \(L_{ij}\)' s are all linear. This linear manifold of constraints depends only on the architecture, i.e., the graph of connections. The strictly convex function \(R(L_{ij})\) depends on the actual weights \(W\). Different sets of weights \(W\) produce different convex functions over the same linear manifold.

_Remark 5.6_.: One could coalesce all the input units and all output units into a single unit, in which case a path from an input unit to and output unit becomes also a directed cycle. In this representation, the constraints are that the sum of the \(L_{ij}\) must be zero along any directed cycle. In general, it is not necessary to write a constraint for every path from input units to output units. It is sufficient to select a representative set of paths such that every unit appears in at least one path.

We can now complete the proof of Theorem 5.1. Given a neural network of BiLUs with a set of weights \(W\), we can consider the problem of minimizing the regularizer \(R(L_{ij})\) over the self-admissible configuration \(L_{ij}\). For any \(p>0\), the \(L_{p}\) regularizer is strictly convex and the space of self-admissible configurations is linear and hence convex. Thus this is a strictly convex optimization

Figure 2: The problem of minimizing the strictly convex regularizer \(R(L_{ij})=_{ij}e^{L_{ij}}|w_{ij}|^{p}\) (\(p>0\)), over the linear (hence convex) manifold of self-consistent configurations defined by the linear constraints of the form \(_{}L_{ij}=0\), where \(\) runs over input-output paths. The regularizer function depends on the weights. The linear manifold depends only on the architecture, i.e., the graph of connections. This is a strictly convex optimization problem with a unique solution associated with the point \(A\). At \(A\) the corresponding weights must be balanced, or else a self-consistent configuration of lower cost could be found by balancing any non-balanced neuron. Finally, any other self-consistent configuration \(B\) cannot correspond to a balanced state of the network, since there must exist balancing moves that further reduce the regularizer cost (see main text). Stochastic balancing produces random paths from the origin, where \(L_{ij=} M_{ij}=0\), to the unique optimum point \(A\).

problem that has a unique solution (Figure 2). Note that the minimization is carried over self-consistent configurations, which in general are not associated with balanced states. However, the configuration of the weights associated with the optimum set of \(L_{ij}\) (point \(A\) in Figure 2) must be balanced. To see this, imagine that one of the BiLU units-unit \(i\) in the network is not balanced. Then we can balance it using a multiplier \(_{i}^{*}\) and replace \(_{i}\) by \(_{i}^{}=_{i}^{*}\). It is easy to check that the new configuration including \(_{i}^{}\) is self-consistent. Thus, by balancing unit \(i\), we are able to reach a new self-consistent configuration with a lower value of \(R\) which contradicts the fact that we are at the global minimum of the strictly convex optimization problem.

We know that the stochastic balancing algorithm always converges to a balanced state. We need to show that it cannot converge to any other balanced state, and in fact that the global optimum is the only balanced state. By contradiction, suppose it converges to a different balanced state associated with the coordinates \((L_{ij}^{B})\) (point \(B\) in Figure 2). Because of the self-consistency, this point is also associated with a unique set of \((_{i}^{B})\) coordinates. The cost function is continuous and differentiable in both the \(L_{ij}\)'s and the \(_{i}\)'s coordinates. If we look at the negative gradient of the regularizer, it is non-zero and therefore it must have at least one non-zero component \( R/_{i}\) along one of the \(_{i}\) coordinates. This implies that by scaling the corresponding unit \(i\) in the network, the regularizer can be further reduced, and by balancing unit \(i\) the balancing algorithm will reach a new point (\(C\) in Figure 2) with lower regularizer cost. This contradicts the assumption that \(B\) was associated with a balanced stated. Thus, given an initial set of weights \(W\), the stochastic balancing algorithm must always converge to the same and unique optimal balanced state \(W^{*}\) associated with the self-consistent point \(A\). A particular stochastic schedule corresponds to a random path within the linear manifold from the origin (at time zero, all the multipliers are equal to 1, and therefore \(M_{ij}=1\) and \(L_{ij}=0\) for any \(i\) and any \(j\)) to the unique optimum point \(A\).

_Remark 5.7_.: From the proof, it is clear that the same result holds also for any deterministic balancing schedule, as well as for tied and non-tied subset balancing, e.g., for layer-wise balancing and tied layer-wise balancing. In the Appendix, we provide an analytical solution for the case of tied layer-wise balancing in a layered feed-forward network.

_Remark 5.8_.: From the proof, it is also clear that the same convergence to the unique global optimum is observed if each neuron, when stochastically visited, is favorably scaled rather than balanced, i.e., it is scaled with a factor that reduces \(R\) but not necessarily minimizes \(R\). Stochastic balancing can also be viewed as a form of EM algorithm where the E and M steps can be taken fully or partially.

Figure 3: **SGD applied to \(E\) alone, in general, does not converge to a balanced state, but SGD applied to \(E+R\) converges to a balanced state.****(A-C)** Simulations use a deep fully connected autoencoder trained on the MNIST dataset. **(D-F)** Simulations use a deep locally connected network trained on the CFAR10 dataset. **(A,D)** Regularization leads to neural balance. **(B,E)** The training loss decreases and converges during training (these panels are not meant for assessing the quality of learning when using a regularizer). **(C,F)** Using weight regularization decreases the norm of weights. **(A-F)** Shaded areas correspond to one s.t.d around the mean (in some cases the s.t.d. is small and the shaded area is not visible).

## 6 Simulations

To further corroborate the results, we ran multiple experiments. Here we report the results from two series of experiments. The first one is conducted using a six-layer, fully connected, autoencoder trained on MNIST (Deng, 2012) for a reconstruction task with ReLU activation functions in all layers and the sum of squares errors loss function. The number of neurons in consecutive layers, from input to output, is 784, 200, 100, 50, 100, 200, 784. Stochastic gradient descent (SGD) learning by backpropagation is used for learning with a batch size of 200.

The second one is conducted using three locally connected layers followed by three fully connected layers trained on CFAR10 (Krizhevsky and Hinton, 2009) for a classification task with leaky ReLU activation functions in the hidden layers, a softmax output layer, and the cross entropy loss function. The number of neurons in consecutive layers, from input to output, is 3072, 5000, 2592, 1296, 300, 100, 10. Stochastic gradient descent (SGD) learning by backpropagation is used for learning with a batch size of 5.

In all the simulation figures (Figures 3, 4, and 5) the left column presents results obtained from the first experiment, while the right column presents results obtained from the second experiment. While we used both \(L_{1}\) and \(L_{2}\) regularizers in the experiments, in the figures we report the results obtained with the \(L_{2}\) regularizer, which is the most widely used regularizer. In Figures 3 and 4, training is done using batch gradient descent on the MNIST and CIFAR data. The balance deficit for a single neuron \(i\) is defined as: \((_{w IN(i)}w^{2}-_{w OUT(i)}w^{2})^{2}\), and the overall balance deficit is defined as the sum of these single-neuron balance deficits across all the hidden neurons in the network. The overall deficit is zero if and only if each neuron is in balance. In all the figures, \(||W||_{F}\) denotes the Frobenius norm of the weights.

Figure 3 shows that learning by gradient descent with a \(L_{2}\) regularizer results in a balanced state. Figure 4 shows that even when the network is initialized in a balanced state, without the regularizer the network can become unbalanced if the fixed learning rate is not very small. Figure 5 shows that the local stochastic balancing algorithm, by which neurons are randomly balanced in an asynchronous fashion, always converges to the same (unique) global balanced state.

Figure 4: **Even if the starting state is balanced, SGD does not preserve the balance unless the learning rate is infinitely small. (A-C)** Simulations use a deep fully connected autoencoder trained on the MNIST dataset. **(D-F)** Simulations use a deep locally connected network trained on the CFAR10 dataset. **(A-F)** The initial weights are balanced using the stochastic balancing algorithm. Then the network is trained by SGD. **(A,D)** When the learning rate (Ir) is relatively large, without regularization, the initial balance of the network is rapidly disrupted. **(B,E)** The training loss decreases and converges during training (these panels are not meant for assessing the quality of learning when using a regularizer). **(C,F)** Using weight regularization decreases the norm of the weights. **(A-F)** Shaded areas correspond to one s.t.d around the mean (in some cases the s.t.d. is small and the shaded area is not visible).

## 7 Conclusion

While the theory of neural synaptic balance is a mathematical theory that stands on its own, it is worth considering some of its possible consequences and applications, at the theoretical, algorithmic, biological, and neuromorphic hardware levels. At the theory level, for instance, it suggests extending theorems obtained with ReLU neurons to BiLU neurons, using balance ideas to study learning in _linear_ regularized networks, and using the manifolds of equivalent weights to study issues of over-parameterization (e.g. the data needs only to specify the balanced state, not the entire equivalence class). At the algorithmic level, balancing algorithms could be used for instance to balance networks at any stage of learning, including at the beginning, and as an alternative way to regularize networks. Finally, because scaling and balancing are local operations, they are potentially of interest in physical, as opposed to digitally-simulated, neural networks. In particular, it would be interesting to know if some notion of balance applies to biological neurons. Unfortunately, current recording technologies do not allow the measurement of all incoming and outgoing synapses of a neuron. Perhaps some approximation could be obtained statistically and at the population level, or perhaps approximate measurements could be carried in very simple networks (e.g. _C. elegans_)or using neurons in culture. Finally, in neuromorphic hardware, the balance could be relevant for training spiking neural networks with low energy consumption (Sorbaro et al., 2020; Rueckauer et al., 2017)). In particular, ReLU scaling can influence the number of spikes generated in each layer and the average energy consumption at each layer. Similarly, in memristor networks (Ivanov et al., 2022; Liang and Wong, 2000), \(L_{2}\) minimization is directly connected to power consumption. Moreover, the issue of the limited conductivity range of memristors is mentioned in Ivanov et al. (2022) and in Ji et al. (2016) Therefore, a local algorithm to reduce the norm of the weights could help mitigate this issue as well.

The theory of neural synaptic balance explains some basic findings regarding \(L_{2}\) balance in feedforward networks of ReLU neurons and extends them in several directions. The first direction is the extension to BiLU and other activation functions (BiPU). The second direction is the extension to more general regularizers, including all \(L_{p}\) (\(p>0\)) regularizers. The third direction is the extension to non-layered architectures, recurrent architectures, convolutional architectures, as well as architectures with mixed activation functions. The theory is based on two local neuronal operations: scaling which is commutative, and balancing which is not commutative. Finally, and most importantly, given any initial set of weights, when local balancing operations are applied in a stochastic or deterministic manner, global order always emerges through the convergence of the balancing algorithm to the same unique set of balanced weights. The reason for this convergence is the existence of an underlying convex optimization problem where the relevant variables are constrained to a linear, only architecture-dependent, manifold. Scaling and balancing operations are local and thus may have applications in physical, non-digitally simulated, neural networks where the emergence of global order from local operations may lead to better operating characteristics and lower energy consumption.

Figure 5: **Stochastic balancing converges to a unique global balanced state (A-B) Simulations use a deep fully connected autoencoder trained on the MNIST dataset. (C-D) Simulations use a deep locally connected network trained on the CFAR10 dataset. (A,C) The weights of the network are initialized randomly and saved. The stochastic balancing algorithm is applied and the resulting balanced weights are denoted by \(W_{balanced}\). The stochastic balancing algorithm is applied 1,000 different times. In all repetitions, the weights converge to the same value \(W_{balanced}\). (B,D) Stochastic balancing decreases the norm of the weights. (A-D) Shaded areas correspond to one standard deviation around the mean.**