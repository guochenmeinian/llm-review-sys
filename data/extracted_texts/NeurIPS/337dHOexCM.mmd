# Retrieval & Fine-Tuning for In-Context Tabular Models

Valentin Thomas

valentin.t@layer6.ai

&Junwei Ma

jeremy@layer6.ai

&Rasa Hosseinzadeh

rasa@layer6.ai

&Keyvan Golestan

&Guangwei Yu

bguang@layer6.ai

&Maksims Volkovs

maks@layer6.ai

&Anthony Caterini

anthony@layer6.ai

Equal contribution

###### Abstract

Tabular data is a pervasive modality spanning a wide range of domains, and this inherent diversity poses a considerable challenge for deep learning. Recent advancements using transformer-based in-context learning have shown promise on smaller and less complex tabular datasets, but have struggled to scale to larger and more complex ones. To address this limitation, we propose a combination of retrieval and fine-tuning: we can adapt the transformer to a local subset of the data by collecting nearest neighbours, and then perform task-specific fine-tuning with this retrieved set of neighbours in context. Using TabPFN as the base model - currently the best tabular in-context learner - and applying our retrieval and fine-tuning scheme on top results in what we call a locally-calibrated PFN, or LoCalPFN. We conduct extensive evaluation on 95 datasets curated by TabZilla from OpenML, upon which we establish a new state-of-the-art with LoCalPFN - even with respect to tuned tree-based models. Notably, we show a significant boost in performance compared to the base in-context model, demonstrating the efficacy of our approach and advancing the frontier of deep learning in tabular data.

## 1 Introduction

Tabular data is the most pervasive modality for practical problems in data science, spanning across a wide variety of domains including finance, healthcare, and science . The diversity and heterogeneity of tabular data pose great challenges for deep learning approaches , unlike modalities such as text and images in which neural networks can be designed to specifically exploit inductive biases underlying the data . As such, obtaining a performant neural network on a particular tabular data task often results in expensive iterations of training and hyperparameter tuning. Meanwhile, tree-based methods such as XGBoost  and CatBoost  have proven to be more robust to the inherent challenges of tabular data, and thus have remained the dominant approach for this setting . Yet recently, there has been progress made with transformers and In-Context Learning (ICL): one such example is TabPFN , which is trained using a prior-fitting procedure  that exposes the network to millions of possible data-generating processes, thus taking a step towards encapsulating the heterogeneity of tabular data. Such approaches differ from classical algorithms in that they process entirely new datasets in a single forward pass and obviate the need for training and hyperparameter tuning.

Despite the promise of transformer-based ICL methods in the tabular setting - particularly on smaller datasets - scaling remains an issue: memory scales _quadratically_ with the size of the context. This limits performance when the entire dataset cannot fit into memory, and contrasts with classical algorithms that tend to improve as the amount of available data increases. In addition to this, and as depicted in Figure 1, TabPFN in particular can struggle with underfitting as dataset _complexity_increases, even when the entire dataset fits into the context; we observe this shortcoming in real datasets as well, and suspect this could apply to any ICL-based model for tabular data.

To improve the scaling of tabular ICL methods in both dataset size and complexity, we draw on two techniques that have been incredibly successful in foundational large language models: retrieval  and fine-tuning . On the retrieval side, we use the \(k\)-Nearest Neighbours (\(k\)NN) of a given query point as the context for classification; modifying the context in this way empirically allows for both enhanced processing of larger datasets and more complex decision boundaries. We also fine-tune end-to-end for each task, using an approximate neighbour scheme to facilitate backpropagation, and demonstrate significant performance gains beyond just \(k\)NN. We named our model Locally-Calibrated PFN - or LoCalPFN for short - to represent the addition of retrieval and fine-tuning on top of a base TabPFN model, although this idea should naturally transfer to potential future ICL-based tabular foundation models as well . We demonstrate that LoCalPFN is state-of-the-art when comparing against both neural approaches and well-tuned tree-based techniques across a 95-dataset benchmark from TabZilla . We summarize our contributions below:

1. Provide insights into TabPFN - the current state-of-the-art tabular ICL transformer-based framework - and analyze how its performance scales across several axes in both synthetic and real datasets. We identify failures to scale in both dataset size and complexity.
2. Propose LoCalPFN to address the scaling failures mentioned above, using a combination of retrieval and fine-tuning to allow for more effective use of the context.
3. Show LoCalPFN compares favourably to strong baselines on a large variety of datasets through extensive experimentation, analysis, and ablation.

## 2 Improving Tabular In-Context Learning with Retrieval and Fine-Tuning

In this section, we describe ICL applied to tabular data - in particular TabPFN - and the limitations of such an approach. Then, we present our contributions where we treat the in-context learner as a base model on top of which retrieval and fine-tuning are applied.

### Preliminaries on In-Context Learning for Tabular Data and TabPFN

Our method generally applies to in-context learners, specifically for classification tasks on tabular data. While, at the time of writing the only successful model of that type is TabPFN , we expect other such base models to be published in the future. TabPFN is trained using a prior-fitting procedure  where a large number of synthetic datasets are generated using randomly initialized neural networks. This approach trains an underlying transformer-based network on various generative processes designed to simulate the diverse interrelations that exist among the features of realistic tabular datasets.

Figure 1: a) TabPFN – even when using the entire training data as context – underfits and cannot classify patterns such as three pairs of concentric circles of two classes. Decision boundaries are in black and shaded areas show the predicted class. b) Applying an adaptive local context for each point using its \(k\) nearest neighbours can easily solve this problem. c) We observe that this approach is robust to the numbers of neighbours used (\(k\)) even when the dataset complexity increases and always performs better than vanilla TabPFN using full context (\(N=1000\)). Each point is averaged over 25 seeds.

After the prior-fitting procedure, the learned TabPFN model ingests an entire training dataset \(_{}\{(x_{}^{i},y_{}^{i}) \}_{i=1}^{N}\) consisting of feature-label pairs \(x_{}^{i}^{D}\) and \(y_{}^{i}\{1,,C\}\) for \(i\{1,,N\}\), along with features of a query point \(x_{}\) (potentially in a batch), and outputs a distribution over labels \(y_{}\{1,,C\}\). Specifically, denoting the TabPFN network (outputting logits) with parameters \(\) as \(f_{}\), the resulting posterior predictive distribution is modelled by:

\[p_{}(y_{} x_{},_{})=(x_{},_{})[y_{}])}{ _{c=1}^{C}(f_{}(x_{},_{})[c])},\] (1)

where \([]\) denotes the vector indexing operation.

Contrary to classical machine learning methods which are trained on one dataset and then evaluated on the same distribution, TabPFN has been shown to be able to perform classification on a wide range of tasks without training, thanks to its diverse prior-fitting procedure. This makes it one of the rare foundation models for tabular data. Key to this is the ICL ability of TabPFN: by using various training _examples_ as context, analogous to how transformers on language use the preceding _tokens_ as context, TabPFN can classify new query points in a single forward pass.

### What Constitutes a Good Context for Tabular Data?

The quadratic growth of memory usage with context length in transformers presents a challenge: the number of support examples we can use is limited. For instance, while TabPFN performs best on small and simple datasets, where the entire training set fits within the context, it is unclear how to best use TabPFN for large and complex datasets. Naively, we might consider a random subsample of the training data as context [35; 19]. However, Ma et al.  show that this method does not scale either and observe a drop in performance as the dataset size increases.

Given these limitations, it is natural to ask _"What constitutes a good context for tabular data?"_. This topic has been thoroughly researched in natural language processing, which resulted in various techniques for prompt engineering. The situation is more complicated in the tabular domain, as there is no natural order to tabular data as opposed to the natural order of the words in language.

Specifically for TabPFN, some attempts have been made to use a summary of the dataset as context, through either \(k\)-means centroids  or direct prompt optimization [19; 34]. Yet in either case the flexibility of the method is limited by the use of a single context for all query points. Instead, we propose a different approach here, where we use a local context tailored to each individual point we wish to classify. For tabular data, we hypothesize that the most critical information to classify a query point \(x_{}\) is contained in its vicinity. Extensive evaluations  support this fact by showing that a simple \(k\)NN classifier can rival modern deep architectures designed for tabular data, such as TabNet  and VIME . We thus believe that using nearby points as context is a good inductive bias for tabular data classification.

### Better Expressivity and Scaling Using Local Information

To do this, the first step is to replace the _global_ context by a _local_ context, i.e., with \(k(x_{})\) as the \(k\)-nearest neighbours of the query \(x_{}\) in the training data \(_{}\), we replace equation 1 by

\[p_{}(y x_{},_{})=(x_{},k(x_{}))[y])}{_{c=1}^{C}(f_{ }(x_{},k(x_{}))[c])}.\] (2)

#### Better Expressivity

It is well known that in \(k\)NN regression and classification, the number of neighbours \(k\) controls the bias/variance trade-off and as such the expressivity of the model. More precisely, large \(k\) tends to "oversmooth" and suffer from high bias/underfitting, while small \(k\) enables more complex decision boundaries but can suffer from more variance/overfitting . We show that this phenomenon is still true for transformers, beyond the simple \(k\)NN classifier, in Figure 1. We generate datasets of size \(N=1000\) so that it can be used as context by TabPFN without subsampling. As we increase the complexity of the dataset, measured by the number of concentric circles in this case, TabPFN fails to accurately classify (e.g., for 3 pairs of circles in (a) and more generally in (c)). Retrieving fewer samples (\(k=10\), \(30\), \(100\), or \(300\)) for each query point using its \(k\)-nearest neighbours from the training data leads to large improvements in AUC over TabPFN as the complexity of the data increases ((b) and (c)). Note that \(k=1000\) would correspond to using all samples as context, and thus is equivalent to vanilla TabPFN. As such there is a continuum between TabPFN using the full dataset as context and our local context method using \(k\)NN, which we call TabPFN-\(k\)NN.

While Figure 1 is on toy synthetic data, we believe this result remains surprising: _a priori_, we would expect a \(25\)-million-parameter model (TabPFN) to be able to learn a few circles, even with just ICL. Meanwhile, we believe that using local contexts allows TabPFN to fit more complex patterns, such as the three circles of Figure 1, in the same way that using local linear regression enables more expressive (and in that case nonlinear) decision boundaries .

**Better Scaling** Using a local context has another benefit: it allows our method's performance to scale with the training dataset size. In machine learning, it is generally expected that the performance of an algorithm improves as the training set size \(N\) increases, since the empirical risk converges to the expected risk . However, ICL-based methods (such as TabPFN) that require subsampling when the maximum context length is smaller than \(N\) do not scale with \(N\). TabPFN-\(k\)NN, on the other hand, can still benefit from larger training set sizes \(N\) even when the number of neighbours \(k\) is much smaller than \(N\), as the search is performed over the whole training set. We demonstrate this fact in Figure 2 for three real datasets. While the exact patterns in the loss curves differ, we observe a similar trend across many datasets, where the benefits of using TabPFN-\(k\)NN grow as the dataset becomes larger. In Figure 9 we provide more detailed figures which include training loss.

### Efficient End-to-End Fine-Tuning With Retrieved Samples

In addition to retrieval, we fine-tune the model end-to-end on each dataset to further improve performance, as is common in Retrieval-Augmented Generation (RAG) . However, naive fine-tuning is not computationally efficient. Transformer-based in-context models work with inputs of shape \((B,L_{}+L_{},d)\) where \(B\) is the batch size, \(L_{}\) and \(L_{}\) are the context and query lengths, and \(d\) is the embedding dimension. TabPFN uses only one fixed context for all points, with \(B=1\), \(L_{}\) the training dataset size (or maximum context length if too large), and \(L_{}=N_{}\) the number of points to classify. Contrary to text, there is no auto-regressive attention mask: the context examples all attend to each other (blue arrows on Figure 2(a)) while the queries only attend to the context and not to each other (red arrows on Figure 2(a)). Therefore, the predicted classes can be computed in parallel and at a reduced memory footprint.

By comparison, when using a local context with exact neighbours, the context is no longer shared, and therefore the batch dimension must be used for queries: the input has shape \(B=N_{}\), \(L_{}=k\) - the number of neighbours - and \(L_{}=1\), since the queries use distinct contexts. This is significantly less efficient than the inference performed by TabPFN, which both requires much less memory, and also allows the queries to be processed in parallel. Therefore, our main limitation is in fact the forward and backward passes when using exact neighbours, unlike most applications where retrieval is the bottleneck. As such, most common approximate \(k\)NN methods cannot address this issue.

Figure 2: Example of the behaviour of TabPFN and TabPFN-\(k\)NN as we vary the dataset size and the context length for three large datasets. TabPFN is in shades of green and TabPFN-\(k\)NN is in shades of blue. The opacity represents the context length used (also labelled on each line). It corresponds to random training samples for TabPFN and nearest neighbours for TabPFN-\(k\)NN. TabPFN is limited by context size and cannot make efficient use of larger datasets. While for context length \(=\) dataset size (\(k=N\)), TabPFN and TabPFN-\(k\)NN have the same performance, TabPFN-\(k\)NN can leverage larger datasets with \(k\)NN-based contexts and shows improvements, often even for lower context lengths. Each point on this plot is the average of \(100\) random resamplings of the data.

Instead, to improve computational efficiency during the end-to-end fine-tuning, we opt for a simple neighbour approximation technique wherein many queries share the same context. An illustration of the method is provided in Figure 2(b) for a single batch dimension. More generally, let us assume that we want to pass gradients on \(N_{}\) examples at once, using a context length of \(L_{}\). We propose to only use \(B\) different contexts, which we will use to classify \(N_{}/B\) samples each: First, \(B\) training examples are sampled. Then, their individual \(k\)NN search is performed with \(k=L_{}+L_{}\)2 for \(L_{}=N_{}/B\). Finally, those batches of \(k\) samples are each shuffled and split into a context vector of length \(L_{}\), and a query vector of length \(L_{}\), constructing the input vector of size \((B,L_{}+L_{},d)\). This allows us to efficiently trade-off accuracy of the neighbours versus computational complexity: with lower \(B\) we share contexts between many points but this comes at the cost of an approximation in the \(k\)NN search as the notion of neighbourhood is not transitive, i.e., the neighbour of your neighbour might not be your neighbour. However each sequence in each batch only contains examples which are in the general vicinity of each other. In practice, we observe that this method does not lead to any significant degradation in performance while allowing much faster training.

## 3 Related work

**Foundational Techniques to Improve Tabular Deep Learners** Deep learning techniques have historically struggled on tabular data , where inductive biases are much harder to capture architecturally  as compared to text or images. The comparative lack of progress on a large foundation model for tabular data  is yet more evidence of this. However, recent approaches have successfully begun to leverage foundational ideas to improve performance. For example, Non-Parametric Transformers  and SAINT  both combine row-attentive transformer-based backbones with some form of self-supervised pre-training; however, the former is limited by context size (a common theme for naive ICL-based learners), whereas the latter is not based on ICL and thus does not as easily apply to novel datasets. Models such as RIM  and TabR  on the other hand demonstrate how to effectively design tabular deep learners incorporating retrieval modules, but still require costly and brittle rounds of hyperparameter tuning to adapt to any specific dataset. Our approach is meant to target some combination of all these methods: provide ICL-based generalization capabilities, but without limitations on the context size. The retrieval mechanism within TabR itself relies on \(k\)NN, which is one of the most straightforward and widely used retrieval-based machine learning methods . In fact, \(k\)NN is still being actively studied in the literature, e.g., in Differential Nearest Neighbours Regression (DNNR)  and follow-up work , which aims to make \(k\)NN

Figure 3: Details of the architecture and the efficient context used during fine-tuning. a) During inference, for each query \(x_{}\), we compute its \(k\)NNs and use them as context. b) During fine-tuning, we have a modified procedure allowing shared context between many queries. We first select a random training point, then compute its \(k\)NNs. Finally we randomly split those into a context and a query set, allowing us to have a shared (yet local) context for many queries, similarly to vanilla TabPFN. Colours correspond to classes, highlighting that different classes can (and should) appear in the same context.

differentiable; this showcases the potential of simple methods like \(k\)NN in different forms, although DNNR tackles a separate scope from our method.

TabPFN and ExtensionsTabPFN  is a transformer-based in-context learner that has emerged as a popular model for tabular data, demonstrating strong performance on some benchmarks . It uses a prior-fitting process  allowing for rapid adaptation to new tasks. This strong ability to quickly generalize makes TabPFN somewhat of a foundation model for tabular data , from which techniques for generation  and dataset distillation  for example can emerge - interpretability is also being studied . TuneTables  attempts to use tabular sketching  to summarize the incoming dataset and more effectively scale TabPFN's context; however, much like Ma et al. , this approach is limited by the use of a single context for all datapoints, as opposed to an adaptive local context. den Breejen et al.  is able to show some limited improvements by fine-tuning TabPFN, which we extend here by more closely pairing the retrieval and fine-tuning aspects. Concurrently, Xu et al.  are able to improve TabPFN by first clustering the training data with K-Means and routing each testing point to a given cluster, which is then used as a prompt; our method does not require any clustering of the data.

Links with LLMsThe idea of pre-training a model on corpora of text prior to fine-tuning has been explored in the Natural Language Processing domain for both classification and generation tasks [14; 27; 42]. Later iterations refined this idea to train a model and use its in-context learning abilities for new tasks . This elicited research into prompt engineering to determine what to actually put in a model's context [39; 51]. Similar to prompt engineering, to better utilize the model's context, one can search for similar examples from a corpora and use them to facilitate the task; this is known as Retrieval-Augmented Generation (RAG)  in the generative context. Other variants of the idea include training jointly with retrieval [22; 8] and augmenting the output of the model with \(k\)NN via interpolating . These ideas are analogous to our approach of (i) fine-tuning and retrieving jointly, and (ii) disjoint \(k\)NN and fine-tuning in our ablations, respectively. LLMs have also been directly applied to tabular data [16; 25; 18] however, due to the pre-training of these foundation models on large text corpora, there is the possibility of data leakage, which causes concern with evaluations . Note that this is not the case with TabPFN as it has been trained on synthetic data.

## 4 Experiments

In this section, we showcase the performance of LoCalPFN against a wide range of alternatives. We release all code to reproduce our results at https://github.com/layer6ai-labs/LoCalPFN.

### Experimental Setup

We evaluate our methods against competitive baselines using 95 out of the 176 datasets from TabZilla , originally sourced from OpenML . These datasets originate from diverse sources, including academic research, competitions, government agencies, and corporations. The 95 datasets are filtered from TabZilla to meet TabPFN's architectural requirements by ensuring that each dataset has at most 100 features, at most 10 classes, does not contain NaN values, and has at least one instance per class for each split. The details of the datasets are described in Appendix A.1. We further split the datasets into two subsets: "small" datasets which contain less than 2,000 instances, and "medium/large" which contain at least 2,000 instances (up to 130,064). For each dataset, we use the splits from TabZilla with train-validation-test ratio of 80:10:10. Since TabPFN was trained with a maximum of 1,024 data points as context size, the small datasets are roughly considered in-distribution for TabPFN whereas the large datasets are considered out-of-distribution.

We conduct our experiments using 10-fold cross-validation over all datasets for all methods. For all baselines, we apply 30 rounds of hyperparameter tuning as in McElfresh et al.  and choose the best hyperparameters for each fold according to validation AUC. In addition, the TabPFN baseline is reported without further ensembling or transformations, unless otherwise noted. Our methods also build on top of this same TabPFN baseline without further processing. We also compare against TabPFN with transformations in Section 4.4. More details of the baseline models can be found in Appendix A.2.1. We use the faiss[28; 17] library for efficient \(k\)NN search in our methods; this enables us to harness parallel computation to accelerate the nearest neighbour search. We evaluate our methods TabPFN-\(k\)NN and LoCalPFN against other models in the following sections. Notably, without further fine-tuning, LoCalPFN is identical to TabPFN-\(k\)NN. Details of our method are in Appendix A.2.2.

For LoCalPFN we also conducted some small experiments on hyperparameter optimization, but saw no real difference in performance across hyperparameter choices, besides learning rate which we tuned by hand on a global level (i.e., not on a per-dataset basis). Thus, we retained the default hyperparameters we had initially from the TabPFN repository (other than learning rate). We will see later in this section that LoCalPFN is also insensitive to choices in embedding and retrieval metric; combining this with the strong performance across hyperparameter choices shows that the approach is quite robust overall.

**Note on evaluation and the computation of proper confidence intervals:** While many works evaluate tabular data methods on a small set of datasets and report confidence intervals/standard deviations for those, we choose to evaluate on a large number of datasets in order to have more meaningful results. However, this makes it harder to compute meaningful uncertainty. Agarwal et al.  dealt with a related problem in reinforcement learning; we follow their lead by, for example, reporting the interquartile mean (IQM, i.e., the mean of the middle \(50\%\) of scores), and we use their library3 to compute \(95\%\) confidence intervals via stratified bootstrapping.

### Main Experiments

As shown in Table 1, averaged over 95 datasets, LoCalPFN outperforms all other baselines, with significant improvement over TabPFN itself. Among the 47 small datasets, we found that TabPFN is in fact quite competitive with other methods, similar to what had been reported by McElfresh et al. . Nevertheless, LoCalPFN further improves the performance even in this setting and positions itself as the best method. For the 48 medium/large datasets, TabPFN underperforms the tree-based methods by a wide margin. Simply applying \(k\)NN on top of TabPFN leads to a drastic performance increase on top of TabPFN. Finally, LoCalPFN further improves on TabPFN-\(k\)NN, and either performs on par with, or outperforms, all other methods. We also measure the accuracy, F1 score, and relative AUC metrics such as average rank and z-score and see a similar pattern; those details can be found in Tables 6 to 8.

**Deep Learning Model Comparisons:** Note that most deep learning baselines are significantly more expensive to train and tune on larger datasets, and as such, most of them could not be run on all datasets . Nevertheless, in Table 5 we compare TabPFN-\(k\)NN and LoCalPFN to other deep learning based methods on the datasets on which the baselines have been able to run, and show an even larger improvement in performance. The datasets we used for this comparison can be found in Table 4.

### Analysis: Scaling with Dataset Size and Complexity

In this section, we further validate that LoCalPFN addresses the scaling problems of TabPFN. We see in Figures 1 and 2 that TabPFN scales badly with both size and complexity; here, we verify this phenomenon in real datasets. While this may appear contradictory to Table 1 of McElfresh et al. , which shows TabPFN excelling on a large benchmark suite, we note that the aforementioned study mostly contained small datasets and thus it did not show the same performance drop-off observed here.

**Scaling with Size** In Figure 3(a), we report the AUC of different algorithms relative to the AUC of Random Forest for different dataset sizes. We choose relative AUC for clarity as there is no clear correlation between the maximum AUC attainable on a dataset and its size. We see that, compared to the Random Forest baseline, TabPFN's performance drops drastically when the dataset size increases

    &  &  &  \\ Algorithm & IQM AUC & Mean AUC & IQM AUC & Mean AUC & IQM AUC & Mean AUC \\  \(k\)NN & 0.843 & 0.833 (0.847) & 0.812 (0.880-0.516) & 0.807 (0.798-0.516) & 0.781 (0.720-0.759) & 0.882 (0.880-0.584) & 0.848 (0.847-0.850) \\ TabPFN & 0.917 (0.944-0.919) & 0.867 (0.844-0.871) & 0.898 (0.892-0.540) & 0.849 (0.846-0.583) & 0.927 (0.952-0.529) & 0.884 (0.883-0.888) \\ TabPFN 3k & 0.924 (0.873-0.925) & 0.873 (0.903-0.925) & 0.903 (0.874-0.901) & 0.852 (0.884-0.888) & 0.938 (0.919-0.919) & 0.893 (0.924-0.941) \\ LightGBM & 0.940 (0.977-0.942) & 0.885 (0.918-0.980) & 0.884 (0.976-0.901) & 0.838 (0.831-0.945) & **0.966** (0.964-0.967) & 0.931 (0.930-0.92) \\ RandomForest & 0.936 (0.934-0.959) & 0.886 (0.933-0.980) & 0.895 (0.938-0.980) & 0.848 (0.941-0.952) & 0.955 (0.951-0.996) & 0.920 (0.918-0.921) \\ CaBoost & 0.942 (0.939-0.941) & 0.891 (0.988-0.959) & 0.907 (0.931-0.941) & 0.856 (0.938-0.926) & 0.961 (0.936-0.962) & 0.926 (0.932-0.927) \\ XGBoost & 0.943 (0.940-0.946) & 0.892 (0.948-0.950) & 0.907 (0.936-0.941) & 0.861 (0.948-0.947) & 0.965 (0.966-0.964) & 0.931 (0.932-0.932) \\  TabPFN-\(k\)NN & 0.943 (0.941-0.948) & 0.891 (0.937-0.949) & 0.922 (0.916-0.927) & 0.864 (0.857-0.871) & 0.955 (0.953-0.946) & 0.916 (0.915-0.917) \\ LoCalPFN & **0.958** (0.956-0.956) & **0.908** (0.956-0.911) & **0.937** (0.951-0.942) & **0.882** (0.857-0.889) & **0.968** (0.956-0.949) & **0.934** (0.933-0.935) \\   

Table 1: AUC scores and confidence intervals for all 95 datasets, 47 small datasets, and 48 medium/large datasets, respectively.

beyond 3,000, indicating poor scaling with \(N\). On the other hand, the other methods we report scale more favourably with the dataset size. We also see that LoCalPFN scales favourably compared to the Random Forest baseline, and even outperforms XGBoost for large datasets. Error bars represent the \(95\%\) confidence interval.

**Scaling with Complexity** While in Figure 1 we could easily control the complexity of the task, there is no generally accepted measure of complexity for an arbitrary dataset. Here, we propose a simple proxy for complexity: for a given dataset, we measure the difference between the best and worst AUCs of a given set of algorithms, similarly to McElfresh et al. . The rationale is that AUC itself cannot capture complexity, as for instance learning to separate two Gaussians can be done optimally by a linear classifier, but the error rate depends on their variances. In Figure 3(b), we analyze performance across different levels of this complexity measure. We first calculate the difference in AUC for each dataset using all listed methods in Table 1, then we divide the datasets into five quantiles on the \(x\)-axis, with increasing complexity as we move to the right; on the \(y\)-axis, we report the mean AUC relative to Random Forest across 10 folds and across the datasets in each bin. We see that TabPFN scales poorly with increasing complexity, and LoCalPFN still outperforms all other methods in the quantiles of higher complexity, demonstrating that its improvements are not just limited to "easy" datasets.

### Ablation Studies

In this section, we provide ablation studies on different design choices for LoCalPFN.

**Importance of Joint Retrieval and Fine-Tuning** One could naively consider simply fine-tuning the in-context learner on randomly sampled context during training. In Figure 5 (left) and Table 9, we see that this indeed improves performance over the original TabPFN baseline. However, applying TabPFN-\(k\)NN on top of a naively fine-tuned model does not improve performance further. Therefore, it is crucial to fine-tune the model end-to-end _with_ the retrieval (LocalPFN).

**Choice of Embedding** We also try different embeddings. The simplest approach is to use the raw standardized features for the nearest neighbour retrieval. In Figure 5 (centre) and Table 10, it is shown that this simple approach is actually very competitive. We compare it to two additional approaches: using one hot encodings (when the size of the resulting vector does not exceed 100 features), and the output of the encoder layer of TabPFN. For the latter, we recompute the search index every 30 gradient steps. The results show that the former, using one hot encodings, does lead to some improvement, however mostly for smaller datasets (see Figure 10 and Figure 11).

**Why do simple embeddings work so well?** While tabular data is complex in many regards , features in tabular data are often semantically meaningful. For this reason, we expect metrics that decompose over individual features, i.e., \(d(x,x^{})=_{i}d_{i}(x_{i},x^{}_{i})\), to be a good inductive bias for tabular data, especially when it is normalized. This would not be the case for most natural signals. We experimented with two different metrics here, including the Euclidean (L2) distance and cosine similarity; in practice, these two choices are quite similar when applied to standardized features and so we stuck with the Euclidean distance.

Figure 4: Analysis of AUC as a function of size and complexity. TabPFN fails to scale both in size and complexity while LoCalPFN is able to still outperform on the far end of the spectrum. See Figure 8 for a version with absolute AUC. Note that each of the plots contain all datasets in the 95-dataset benchmark, and no subsampling is performed.

[MISSING_PAGE_FAIL:9]

### Runtime Study

We also conduct a runtime analysis for LoCalPFN, TabPFN-\(k\)NN, and other tree-based models, showing mean test-set AUC as a function of runtime. In Figure 6(a), we measure this runtime as the total time taken for training and evaluation. We can see that the general trend for all our algorithms shows a positive correlation between runtime and AUC. We also observe that TabPFN-\(k\)NN runs surprisingly fast while still achieving quite high AUC on the 95 datasets. The fast runtime together with very few hyperparameters suggests that TabPFN-\(k\)NN will perform very well in practical machine learning engineering and research. LoCalPFN achieves significantly higher performance than all other techniques, and even though it obtains this performance which a much higher runtime, it is also worth noting that the deep learning baselines shown in Table 5 take an even longer time for training and evaluation.

One of the drawbacks of using a local context, though, is that TabPFN-\(k\)NN's and LoCalPFN's inference time is slower by 1 to 2 orders of magnitudes when compared to tree-based methods. This fact is to be taken into account when extremely high throughput inference is needed.

## 5 Conclusion and Limitations

In this paper, we demonstrate how to use retrieval and fine-tuning to improve performance on tabular data classification tasks, introducing LoCalPFN as a version of this framework that uses TabPFN as the base model. LoCalPFN breaks new ground for neural approaches on tabular data, even showing improvements over workhorse tree-based techniques. We also provide TabPFN-\(k\)NN as a variant without fine-tuning, demonstrating its superiority over the base TabPFN model and practical utility.

However, despite its successes, our framework also has some limitations. The first is that we have only shown that retrieval and fine-tuning improve TabPFN, since it is the only proven ICL-based tabular model. Thus, we cannot be certain that our ideas would directly transfer to new base models, although the success of these concepts in other domains provides some evidence. It is also worth noting that the original RAG paper  only initially demonstrated success on BART. Next, the reliance on TabPFN as a base model brings some limitations: besides the constraints on number of features and classes discussed in Section 4.1, we are also unable to easily test our ideas in regression tasks since TabPFN is not designed for them. Although we expect these constraints to gradually be lifted as tabular foundation models improve and increase their scope, we also note that tree-based methods are not nearly as susceptible to these issues. Going further on the comparison with tree-based methods, while we note that LoCalPFN performs better than them in our experimental study, we also point out in Section 4.5 that the runtime of LoCalPFN is slower. However, it is still faster than other deep learning approaches, and the cheaper TabPFN-\(k\)NN variant runs as fast as any tree-based method on datasets we studied, while still attaining respectable performance. Overall, we believe that the benefits of our framework far outweigh the limitations, as LoCalPFN greatly expands the capabilities of deep learning on tabular data.

Figure 7: a) AUC vs. Runtime for all 95 datasets. TabPFN-\(k\)NN has very low runtime and strong performance, while LoCalPFN is able to achieve the highest AUC overall. We use bold text to denote maximum number of neighbours \(k\) used. b) Breakdown of the total time in training time and inference time for all algorithms. As local in-context methods are all significantly larger than tree-based methods, their raw inference time is slower.