# Learning rigid-body simulators over implicit shapes

for large-scale scenes and vision

 Yulia Rubanova\({}^{*}\)   Tatiana Lopez-Guevara Kelsey R. Allen William F. Whitney Kimberly Stachenfeld Tobias Pfaff

Corresponding email: rubanova@google.comCo-senior authorship

Google Deepmind

###### Abstract

Simulating large scenes with many rigid objects is crucial for a variety of applications, such as robotics, engineering, film and video games. Rigid interactions are notoriously hard to model: small changes to the initial state or the simulation parameters can lead to large changes in the final state. Recently, _learned_ simulators based on graph networks (GNNs) were developed as an alternative to hand-designed simulators like MuJoCo  and PyBullet . They are able to accurately capture dynamics of real objects directly from real-world observations. However, current state-of-the-art learned simulators operate on meshes and scale poorly to scenes with many objects or detailed shapes. Here we present SDF-Sim, the first learned rigid-body simulator designed for scale. We use learned signed-distance functions (SDFs) to represent the object shapes and to speed up distance computation. We design the simulator to leverage SDFs and avoid the fundamental bottleneck of the previous simulators associated with collision detection. For the first time in literature, we demonstrate that we can scale the GNN-based simulators to scenes with hundreds of objects and up to 1.1 million nodes, where mesh-based approaches run out of memory. Finally, we show that SDF-Sim can be applied to real world scenes by extracting SDFs from multi-view images.

## 1 Introduction

Simulating real-world environments, such as a bookshelf with books and decorations or a dinner table with plates and glasses, presents a significant challenge for traditional physics simulators. These simulators require precise 3D shape, location, and corresponding physical parameters of each object, making the simulation of arbitrary scenes a difficult task.

Recently, _learned_ simulators based on graph networks (GNNs)  have been introduced as a powerful alternative to traditional hand-designed simulators like MuJoCo  or PyBullet . Graph networks can capture a range of complex physical dynamics, learn physical properties directly from real data and generalize to new scenes. However, current GNN-based methods do not scale well to large scenes. Similarly to the traditional simulators, they rely on 3D meshes to describe object shapes. In scenes with a large number of objects or objects with detailed meshes, these scenes might contain thousands of nodes and mesh triangles, making collision detection between objects extremely costly. In the context of graph networks, large meshes also lead to input graphs that might contain hundreds of thousands of nodes and edges, crippling runtime and memory performance.

To remedy the issue with expensive collision detection, a common approach in the classic simulation literature is to use _signed-distance functions_ or _fields_ (SDFs). SDFs implicitly represent the objectshapes and allow to find the distance and the closest point on the object surface from an arbitrary location in 3D space in constant-time. Since distance queries are a main driver of the compute cost in traditional rigid body simulation, they can be significantly sped up using SDFs. However, in practice, SDFs are frequently pre-computed from a mesh and stored as a 3D grid, which trades off the runtime efficiency for increased memory cost and limits their usefulness for large real scenes.

An orthogonal line of work started to explore SDFs _learned_ from a set of images to reconstruct the 3D shape from vision. Those SDFs store the shape implicitly in the MLP weights and are fast to train and query. They are less memory-hungry compared to 3D grids, making them a perfect candidate for simulation. However, despite these advantages, learned SDFs were applied for dynamics scenes only in a limited context .

We present SDF-Sim, a learned graph-network-based simulator for rigid interactions that uses learned SDFs to represent object shapes, Figure 1. Using a special design of the input graph, SDF-Sim allows us to substantially reduce the runtime and memory requirements compared to mesh-based learned simulators. This is the first demonstration of a learned simulator generalizable to extremely large scenes up to 1.1 million nodes in Figure 2, orders of magnitude larger than what have been shown in any previous work on learned rigid simulation. These simulations include concave shapes (shoes, a hanger) and thin structures (screwdriver, baking form). Finally, we show that SDF-Sim can directly work with SDFs obtained from multi-view RGB images, Figure 3, supporting rich 3D simulation of objects extracted from real scenes.

## 2 Background

Mesh-based simulationA simulation can be represented as a time series of system states \(^{1},,^{T}\). The goal is to learn a neural simulator that predicts the next state \(^{t+1}\) given a history of previous states \(\{^{t-h+1},,^{t}\}\). Simulators based on graph networks (GNNs)  encode the system state into a graph \(=(,)\) with nodes \(\) and edges \(\). For rigid body simulation, this graph can be constructed from the triangle mesh of the individual objects: mesh vertices become the graph nodes, and mesh edges act as graph edges. The object motion is computed by message passing across the nodes and edges in the graph. Within individual objects, the position, rotation and velocity of the object can be computed by message passing through the nodes and edges of that object.

Why learned simulators?Analytical simulators like MuJoCo, PyBullet or Drake, are most commonly used for modelling rigid bodies. However, the traditional simulators rely on hard-coded approximations of physical interactions that might not match the properties of real objects, even with careful hyperparameter tuning. The predictions from these simulators inevitably diverge from observations of real objects - a so-called sim-to-real gap .

Learned simulators have unique advantages that analytical simulators don't provide. First, learned simulators can be trained directly on real-world observations. They can track the real object trajectory better than analytical simulators, solving a well-known sim-to-real gap. Another common issue is precisely estimating the initial states, which analytical simulators rely on - learned simulators can compensate for these inaccuracies . Finally, learned simulators are differentiable and can be used for optimization and design. At the same time, learned simulators are not optimized for runtime and memory, are slower and more memory-constrained than analytical simulators. In this work, we address that limitation of memory constraint and unlock the ability to run learned simulators on larger scenes in comparison to previous learned simulators.

Figure 1: Overview of SDF-Sim pipeline. SDFs parameterized by MLPs are learned for each object to implicitly represent the object shape and the distance field. A GNN-based simulator uses learned SDFs to predict object dynamics for the next simulation step.

Modelling collisions in GNN simulatorsThe most challenging component of the simulation is computation of collision impulses between objects. To do so, GNN simulators introduce collision edges \(^{coll}\) between nodes  or triangles  on the mesh surface that belong to different objects and are within a predefined distance threshold. However, the amount of these edges is the main bottleneck of GNN-based simulators. Asymptotically, the number of potential collision edges grows quadratically with the number of simulated nodes, leading to prohibitive compute and memory costs. Another challenge is identifying which pairs of triangles/nodes to connect with collision edges in the first place, by computing the distance to the closest point on a mesh. Typically, this procedure is implemented with tree search methods over all mesh triangles in the scene, such as BVH , that are difficult to integrate into deep learning pipelines. In this work, we address both of these challenges by using SDFs.

Signed distance functionsSigned-distance functions (SDFs) are widely used in computer graphics, game engines, and robotics for fast collision detection and computation of distances to an object . SDF defines a field \(f():\ ^{3}\) that represents the signed distance from an arbitrary point \(\) to the closest point on the surface of the object. The sign of the SDF determines whether a point is outside (positive) or inside (negative) of the object. The zero level of the SDF \(\{^{3}|f()=0\}\) implicitly represents the object surface. SDFs permit constant-time queries of the distance to an object surface, irrespective of the number of nodes/faces in the object mesh, which is an essential component of collision detection.

Figure 3: Simulating assets extracted from vision. (a) We extract the SDF from the images of a real-world scene with a garden table . (b) We simulate a virtual shoe object falling onto a vase and a table using SDF-Sim. SDF-Sim is able to predict realistic dynamics, even for the collision of the shoe with the intricate shape of the vase (frames 50-70). See section 4.4 for details and the video on the website.

Figure 2: Example of rollouts from SDF-Sim scaled to large simulations, all simulated for 200 steps. (Top) 300 shoes (object from Movi-C), with 851k nodes, falling onto the floor (Middle) 270 knots from Movi-B, 384k nodes (Bottom) 380 objects from Movi-C, 1.1M nodes. See simulation videos on https://sites.google.com/view/sdf-sim.

Constructing an SDFIn the computer graphics and simulation literature, SDF is often pre-computed as a high-resolution 3D grid containing signed distances from the points on the grid to the object surface [26; 37]. The grid SDF allows to speed up distance queries by trading off memory: for example, 512x512x512 grid would take \(\)134M voxels (0.5Gb of memory) for a single object.

Learned SDFs started to gain popularity for reconstruction of water-tight 3D shapes from images. They approximate the continuous distance field \(f(;)\) with an MLP parameterized by \(\)[23; 28; 43]. Unlike 3D-grid-SDFs, learned SDFs are not tied to a fixed grid resolution and can represent detailed shapes using a small set of parameters \(\). Despite these advantages, _learned_ SDFs have not been sufficiently explored to speed up physical simulations. Limited available works combine learned SDFs with classic physics solvers [5; 33]. They demonstrate that learned SDFs can massively reduce the distance query time thanks to parallelization on a GPU compared to mesh-based computation, while taking \(\)32x less memory than traditional 3D-voxel-grid SDFs.

Computing closest pointsFor any point in 3D space \(\) an SDF \(f_{}\) allows us to easily compute the closest point \(^{*}\) on the object surface that it represents, as:

\[^{*}=-f_{}() f_{}(),\] (1)

where, by definition, \(f_{}()\) is the distance between \(\) and \(^{*}\), and the gradient \( f_{}()\) points in the opposite direction of the shortest path from \(\) to the surface of the object and is unit-norm. If \(f_{}()\) is parameterized as an MLP, this calculation requires only one forward and one backward pass of the network. This provides an efficient way to calculate the closest points for collision resolution in the simulation. In this work, for the first time in the literature, we use learned SDFs to accelerate distance computation in SOTA graph-network simulators.

## 3 SDF-Sim

We introduce SDF-Sim, a graph-network-based simulator for rigid objects that uses learned SDFs to represent object shapes and to perform fast and memory-efficient distance computation between the objects. By leveraging SDF properties, we propose a new way to construct the input graph for the graph network, allowing us to use a smaller graph size and to get an order-of-magnitude reduction in runtime and memory on large simulations.

### Training SDF functions per object

We represent SDF \(f_{}()\) as an MLP that takes in a 3D point \(^{3}\) and outputs a scalar SDF value. Learned SDFs are pre-trained separately for each object and remain fixed throughout the simulation.

_Meshes_ To compare to the existing mesh-based baselines, we apply SDF-Sim on benchmarks where meshes are available and train the learned SDF \(f_{}()\) from a mesh. To train an SDF, we sample points in 3D space and compute the ground-truth signed distances from these points to the mesh surfaces using a classic BVH  algorithm. Finally, we train an MLP \(f_{}()\) to fit these distances with supervision. See more details in section C. We use the same architecture and the model size for each object shape of 8 MLP layers with 128 units each, unless otherwise stated.

_Vision_ We use VolSDF  to distill an SDF from a set of images representing a 360-degree view of the outdoor garden scene first described in  with camera poses estimated via COLMAP . See visualisation in Figure 3 and section C.2 for details.

Figure 4: Construction of graph edges in SDF-Sim.

### Learned simulator

Object representationWe represent the shape of the object \(O_{i}\) in the reference pose (centered at zero) as a learned SDF function \(f_{_{i}}\). At a simulation step \(t\), a rigid transformation \(^{t}_{i}=(^{t}_{i},^{t}_{i})\) transforms the object from reference pose to the current pose in the simulation. Here, \(^{t}_{i}\) is an object translation, corresponding to the object's center of mass at timestep \(t\); \(^{t}_{i}\) is a rotation. The task of the learned simulator is predicting the next-step transformation \(^{t+1}_{i}\) for each object. In the following text, we omit the time index \(t\) for brevity.

To represent \(I\) objects in the input graph, we introduce _object_ nodes \(_{O}=\{_{i}|i=1..I\}\), located at position \(_{i}\), and a set of _surface_ nodes \(_{S}=\{_{ik} O_{i}|i=1..I,k=1..K_{i}\}\) on the surface of the objects, where the number of nodes \(K_{i}\) may differ for each object. These surface nodes \(\{_{ik}\}\) move with their corresponding object according to the transformation \(^{t}_{i}\). With a slight abuse of notation, we will refer to \(\{_{ik}\}\) both as the node entities and their 3D position in the simulation space.

Nodes and edges within the objectTo construct the graph connectivity _within_ an object, we follow an established line of work on learned simulators . We connect surface nodes \(\{_{ik}\}\) to their corresponding object node \(_{i}\) using edges \(^{}_{i}=\{_{_{i} _{ik}}|_{ik} O_{i}\}\). Thus, all the information about object motion, e.g., impulses from collision events, is propagated between the nodes via the object node \(_{i}\). As shown by  we can omit the surface edges between the nodes \(\{_{ik}\}\) without loss of accuracy.

In graph networks, nodes and edges are associated with feature vectors that can hold the information about the motion and the relation between the nodes. We follow the approach of  to construct a set of nodes and edge features that are necessary for simulation: To construct the node features for surface nodes \(_{ik}\), we compute the finite-difference velocity estimates in the simulation space using a history of the latest three timesteps \(_{ik}=(^{t}_{ik}-^{t-1}_{ik},^{t-1}_ {ik}-^{t-2}_{ik})\). We set node features to be \([_{ik},||_{ik}||,_{i}]\) where \(_{i}\) are the constant object parameters: mass, friction and restitution. We use the same procedure for the object nodes \(\{_{i}\}\) using their positions \(_{i}\). For intra-object edges \(^{}_{i}\), we use displacement vector between the surface node position and the object center as the edge feature \(_{_{i}_{ik}}=[_{i}- _{ik},||_{i}-_{ik}||]\).

SDF-based inter-object edges.Here we introduce a new way to construct collision edges between the objects by leveraging their SDF representations (Figure 4). We design these edges such that they contain sufficient information to detect collisions, while their number remains linear in the number of nodes. This is unlike quadratic number of collision edges in mesh-based simulators.

Consider two objects \(O_{i}\) and \(O_{j}\). For a node \(_{ik}\) on \(O_{i}\), we directly query the SDF \(f_{_{j}}\) of object \(O_{j}\) to get the distance \(d^{j}_{ik}\) from \(_{ik}\) to the closest point on \(O_{j}\). We note that unlike mesh-based approaches, this is a single test, and we do not need to calculate the distance from \(_{ik}\) to _each_ node/triangle on \(O_{j}\). Then, if this distance \(d^{j}_{ik}\) is within a predefined distance threshold \(\), we connect the surface node \(_{ik}\) directly to the opposing _object_ node \(_{j}\) and refer to this edge as \(_{_{j}_{ik}}\). Thus, we define the set of inter-object edges as \(^{}_{ji}=\{_{_{j} _{ik}}|_{ik} O_{i}:f_{j}(_{ik}) \}\). This approach is different from mesh-based simulators  that connect pairs of nodes or triangles on the two surfaces.

We construct the features for collision edges \(_{_{j}_{ik}}\) such that they contain information about potential points of collision. First, we compute the closest point \(^{j}_{ik}\) from \(_{ik} O_{i}\) to the surface of object \(O_{j}\). To do so, we transform the position of \(_{ik}\) into the reference space of \(O_{j}\) using \(^{-1}_{j}(_{ik})\). We call an SDF function to get the distance from the node \(_{ik}\) to the closest point on \(O_{j}\) as \(d^{j}_{ik}=f_{_{j}}(^{-1}_{j}(_{ik}))\). The closest point on the surface of \(O_{j}\) is then computed similarly to Eq. 1:

\[^{j}_{ik}=_{ik}-d^{j}_{ik}_{j} f_{ _{j}}(^{-1}_{j}(_{ik}))\] (2)

Note that \(^{j}_{ik}\) lies on the surface defined by \(f_{_{j}}\), but does not have to coincide with any surface node and is not part of node set \(\). Thus, SDFs allow us to test contact between two objects at higher fidelity, without relying on the density of the surface nodes.

Finally, we construct the features for the collision edges as follows: \(_{_{j}_{ik}}=[^{j}_{ik}- _{ik},^{j}_{ik}-_{j},||^{j}_{ik}- _{ik}||,||^{j}_{ik}-_{j}||]\). These features provide information about the relative position of the closest point (a potential collision point) within the object \(O_{j}\) as well as its relative locationto the node \(_{ik}\) on the opposing object. This information is sufficient for the neural network to resolve collisions. Through message-passing over such input graph, the object node \(_{j}\) can collect the information from all the nodes that are within a collision radius relative to the object \(O_{j}\). The model also has access to the velocity and rotation history for both objects through node features, so it is able to infer how fast the node \(_{ik}\) is changing its position w.r.t. \(O_{j}\).

With such construction, SDF-Sim requires significantly fewer edges than mesh-based methods, because a single collision edge can test a node against an entire object surface. Asymptotically, SDF-Sim has \((I K)\) edges in the worst case, with the number of objects \(I\) being magnitudes smaller than the total number of surface nodes \(K=_{i}K_{i}\), instead of \((K^{2})\) for mesh-based simulators. As we demonstrate below, this choice of input graph and simulator unlocks the ability to scale to very large scenes that has not been previously shown in the literature.

Graph network simulatorWe encode the input graph using MLPs for each node and edge type. We process the graph using 10 message passing steps as in [4; 29]. We decode the processed surface node features into an acceleration estimate \(_{ik}\) for each surface node \(_{ik}\), and compute a per-node position update \(}_{ik}^{t+1}\) using Euler integration. Finally, next-step rigid transformations \(\{}_{i}^{t+1}\}\) are computed from \(}_{ik}^{t+1}\) using shape matching , following . The simulator is trained on a single-step prediction task using a per-node L2 loss on the acceleration estimate \(_{ik}\).

## 4 Results

We start by evaluating the accuracy and efficiency of SDF-Sim on small-scale simulation benchmarks, where evaluation of the baselines is feasible as well. Subsequently, we demonstrate the scaling properties of the models on scenes with an increasing number of objects. We show that SDF-Sim produces realistic rollouts of extremely large scenes with up to 1.1M nodes, which was not possible with the previous generation of learned simulators. We emphasize that the benefits of SDF-Sim are not specific to simulations with similar object shapes, where separate SDFs are used for each object. Finally, we present ablations for how the quality of the learned SDFs affects the simulation. All simulation videos are available on the website https://sites.google.com/view/sdf-sim.

Kubric datasetsWe evaluate SDF-Sim on the benchmark Kubric datasets  (shared with Apache 2.0 license), consisting of simulated trajectories of rigid objects thrown towards the center of the scene. We evaluate on two difficulty tiers: Movi-B and Movi-C. Movi-B simulations contain eleven synthetic shapes (e.g., cube, torus, cow) with up to 1142 nodes each. Movi-C comprises 930 scanned real-world household objects, including hollow, flat, or otherwise non-trivial surfaces with thousands of triangles. Both Movi B/C contain only 3-10 objects per simulation. We provide more details about mesh sizes in Movi-B/C in supplement A.1.

We perform many of our quantitative comparisons on Movi-B/C datasets with small-scale scenes because these domains are small enough for us to run also baseline methods to quantify efficiency and accuracy. On Movi-C we compare only to FIGNet* , because other baselines run out of memory during training due to the large number of collision edges, as reported by Allen et al. .

Baseline modelsWe compare SDF-Sim to the existing state-of-the-art learned simulators for rigid-body interactions: FIGNet  and FIGNet* . Both methods are based on graph networks. Unlike SDF-Sim, they operate directly over object meshes and use a special type of graph edges between mesh triangles. Their runtime and memory costs grow with the number and size of the object meshes used for the simulation. FIGNet* is a memory-efficient version of FIGNet that omits edges between the surface nodes of each object. In their original publication, FIGNet was demonstrated to scale up to 10 objects with a few thousands nodes each , while FIGNet* was tested up to a larger table scene with 40k triangles, but with only one moving object .

Figure 5: Comparison of the last frames of rollouts predicted on Movi-C. See more frames in Figure S9 and on the website.

We additionally include previously reported results from Allen et al.  on Movi-B for the following models: DPI  that represents the objects as a set of disjoint particles; as well as MeshGraphNets (MGN) and MGN-Large-Radius  that use inter-object edges between mesh surface nodes. As reported by Allen et al. , DPI, MGN and MGN-Large-Radius baselines suffer from a prohibitively large size of the inputs graph and can only run on small Movi-B simulations.

### Baseline comparison on datasets of small scenes.

First, we evaluate SDF-Sim on Movi-B/C datasets with up to 10 objects. As shown in Figure 6, our SDF-Sim uses substantially sparser graphs to represent the scenes, with 28% fewer graph edges compared to FIGNet* on Movi-B and 33% fewer on Movi-C. This translates into reduction of peak memory required to execute one step of the simulation; 39% reduction on Movi-B and 42.8% on Movi-C. The reduction in the number of edges in SDF-Sim is enabled by object-to-node collision edges that scale linearly with the number of nodes, as opposed to quadratic number of face-face collision edges in FIGNet and FIGNet* (in the worst case, see section 2). Sparser graphs in SDF-Sim also lead to lower average runtime per step of a rollout, by 36% in Movi-B and 43% in Movi-C, because the graph network performs edge updates for/over fewer edges even though the number of nodes in the graph remains the same. Figure S2(a) shows that the runtime of SDF-Sim is consistently lower than that of FIGNet* for varying sizes of the input graph. In the next section we show how these efficiency improvements translate into order-or-magnitude gains on large-scale simulations.

In terms of simulation accuracy, measured as object translation and rotation RMSE errors, SDF-Sim has substantially lower errors than previous baselines DPI, MGN and MGN-Large-Radius on Movi-B. However, in comparison to SOTA models FIGNet and FIGNet*, SDF-Sim has a slightly higher error. Note that the errors of SDF-Sim are already very low: the translation error of SDF-Sim is 0.24 meters, which is only 4.9% of the average object travel distance of 4.92 meters in Movi-C dataset (see tables Tables 3 and 4 for exact numbers). In rigid-body systems, even small discrepancies in predicted positions/rotations can lead to a drastically different object trajectory after a collision, and we consider 4.9% deviation to be a good result. Finally, in the next section we will demonstrate that _on large scenes_ SDF-Sim is actually _more accurate_ in comparison to FIGNet*.

Figure 6: Accuracy, memory and runtime comparisons between the SDF-Sim model and the mesh-based baselines on the Movi-B/C benchmarks. On Movi-C, most baselines except FIGNet* run out of memory and are not shown. As “Peak Memory” we report the peak memory used by the model per single step of the simulation. DPI, MGN-Large-Radius and MGN results were reported by . See Tables 3 and 4 for the exact numbers.

Figure 7: Large-scale simulation of **Spheres-in-Bowl**, simulated for 200 timesteps. Left: the final step of SDF-Sim rollout on the scene with 512 spheres. Right: number of edges and runtime w.r.t. the number of spheres in the simulation (max 512). In complex simulations with lots of contacts, FIGNet and FIGNet* generate an excessive number of collision edges, quickly exceeding GPU memory (end of the orange and blue lines). SDF-Sim generates an order-of-magnitude fewer collision edges, and can easily simulate scenes with 100s of objects without running out of memory.

### SDF-Sim scales to scenes with up to 512 objects

To study the scaling properties of the model, we created **Spheres-in-Bowl**: a set of simulations with a variable number of spheres, ranging from 1 to 512, being dropped into a bowl (Figure 7). We create the ground-truth for these scenes using PyBullet, the same simulator as used for Kubric Motivation-B/C. We evaluate a set of learned simulators: SDF-Sim and FIGNet* models trained on Movi-C, as well as FIGNet trained on Movi-B. Note that the largest version, with 512 spheres, has over 50 times more objects than in Movi-B/C datasets used for training.

As shown in Figure 7, SDF-Sim has an order-of-magnitude fewer collision edges, compared to FIGNet* and FIGNet. This difference is substantial, as the number of edges dominates the memory cost. FIGNet and FIGNet* run out of memory for simulations with >140 and >160 objects, respectively, whereas SDF-Sim can simulate the entire set of 512 interacting objects using the same Nvidia V100 GPU. In terms of total runtime, SDF-Sim is up to 5 times faster than FIGNet*, even including the time for querying learned SDFs. To the best of our knowledge, this is the first demonstration of a learned simulator successfully scaling to scenes with hundreds of objects and thousands of collisions, despite being trained only on ten objects per scene.

Next, we evaluate the accuracy of these simulations. SDF-Sim has the lowest penetration distance throughout the simulation, as shown in Figure 8(a). Figure 8(b) shows the rollout errors across different steps of the simulation. Notably, SDF-Sim generalizes to these larger scenes better than FIGNet* and has lower error, despite slightly lower accuracy on datasets with smaller scenes (section 4.1). FIGNet has the lowest error out of learned models, likely because it was trained on Movi-B, which contains a sphere object, while Movi-C dataset, used for training Fignet* and SDF-Sim, does not. Despite not having seen a sphere object in training, SDF-Sim performs very well on both penetration and rollout metrics, indicating that the SDF representation is not only efficient, but also shows good generalization over geometry.

### Scaling to extra-large scenes with up to 1.1 million nodes

Next, we provide a further qualitative demonstration that SDF-Sim can scale to extra-large scenes and produce realistic rollouts. We design three scenes with falling stacks of shoes, metal knots, and mixed objects taken from the Movi-C dataset, shown in Figure 2. Such contact-rich simulations are challenging even for analytical simulators and are classic test examples in the computer graphics literature. These simulations consist of: 300 shoes with 851k nodes, 270 knots with 384k nodes, and 380 various Movi-C objects with 1.1M nodes, respectively. All of these scenes are orders of magnitude larger than those in Movi-C dataset used for SDF-Sim training.

Simulations in Figure 2 show that SDF-Sim can scale to these massive scenes without running out of memory and produce qualitatively realistic rollouts of 200 steps; see videos. Note that we cannot run any other learned baseline on these scenes, as due to the large number of potential contacts, these models produce a vast number of collision edges and exceed the GPU memory.

### Simulating real-world scenes from vision

Simulating large real-world scenes is the primary area where the ability to generalize to new, larger scenes is crucial, e.g., in virtual reality applications. Here we present a proof-of-concept that SDF-Sim can successfully handle real scenes, despite being trained only on small simulated assets. We take a Garden scene , represented by a sequence of RGB images and use VolSDF  to distill a 3D SDF representation of the table and the vase from this scene. SDF-Sim allows to cleanly integrate this 3D representation into a simulation, where it would interact with another object. Finally, we add a shoe object from Movi-C to this scene. Figure 3 shows a rollout from the SDF-Sim model of a shoe

Figure 8: Accuracy metrics w.r.t. simulation time step for **Spheres-in-Bowl** simulation shown in Figure 7. (a) Penetration metrics. (b) Rollout RMSE. Both metrics are averaged over simulation runs with up to 140 spheres, the maximum for which all baselines could be run.

falling on top of the vase and the table SDF extracted by VolSDF. With its over 80k nodes, this mesh exceeds the limits of FIGNet baseline that runs out of memory. In contrast, SDF-Sim can capture the nuanced interactions between the objects, which is particularly evident in frames 50 to 70; see the video on the website. This experiment demonstrates that SDF-Sim can generalize to new scenes, despite being trained on synthetic data of small scenes.

### Ablation of learned SDF quality

We investigate the quality of the estimated SDF values and their impact on simulator performance. We train SDF using MLPs with 32, 64 and 128 units per layer, and 8 layers total. Figure 9(c) shows that larger SDF models help to improve the quality of estimated SDFs. Overall, the learned SDF models of all three layer sizes can reproduce the shape, although the reconstruction from a smallest 32-unit model is more coarse (Figure 9(d), see Figure S8 for more examples). However, Figure 9(a,b) shows that SDF-Sim accuracy is similar across different SDF MLP sizes, suggesting that the learned simulator can learn to compensate for noise in the estimated SDFs. We provide additional metrics on SDF accuracy, SDF gradients and SDF projected closest points in section D.2. We also provide the comparison of memory footprint of SDF versus storing meshes in section D.5.

## 5 Related Work

Dynamics over learned SDFsOverall, using implicit shapes, e.g., learned SDFs, for simulation has been explored only in limited settings. DiffSDFSim  and DANO  use learned object shapes (SDFs and NeRFs respectively) in combination with an analytic contact model on a scene with a single object. Argila et al.  and Qiao et al.  model the interaction of a learned SDF with a cloth via an analytic simulator. In the space of learned simulators, FIGNet*  uses a GNN-based model on a 3D scene reconstructed via NeRF and converted into a mesh. Driess et al.  learn latent dynamics over NeRFs. Whitney et al.  convert a NeRF 3D scene into a set of particles and use them in a GNN simulator. Unlike these pipelines, SDF-Sim avoids the costly simulation of large meshes or sets of particles and operates directly over the SDFs. Mani et al.  use learned SDFs to represent large rigid scenes for the sake of efficiency and use the SDF values directly in the GNN simulator. However, this model is designed to use only a _single_ SDF per scene. In contrast, we focus on more challenging interactions of many rigid objects, that is much more prevalent in real applications.

Learning SDFs from visionLearned SDFs started to gain popularity for reconstructing an 3D surfaces from a sequence of images. Unlike NeRFs , SDFs are more likely to represent closed, watertight, smooth surfaces. Wang et al. , Yariv et al. , Yu et al.  train an MLP to represent an SDF of a single object. Other works train a single generative model for many SDF shapes, allowing to amortise the training cost, generate new shapes and perform shape completion from partial inputs [9; 10; 28; 34]. Recent works also offer ways to use SDFs for deformable objects , articulated objects , or to edit SDFs .

One can also reconstruct SDFs from other modalities, e.g., [24; 40] demonstrate how to reconstruct a new unseen object as an SDF using an RGB-D video from a single camera view. SDFs can be

Figure 9: Ablation on learned SDF model sizes: 8 layer MLPs with layer sizes of 32, 64, or 128 hidden units. (a, b) Translation and rotation error for SDF-Sim trained on Movi-B with different SDF sizes. (c) Mean squared error of the predicted SDF estimates near the surface. (d) Visualisations of the cow shape from Movi-B with different SDF sizes. (e) A cross-section of the learned SDF field for the Movi-B cow shape.

recovered for large room-scale scenes  or even in real time as the camera moves through the space , or from noisy point clouds, e.g., from Lidar [21; 22]. We note that although we can leverage the SDFs extracted by these methods, these works pursue a different goal and focus only on accurate reconstruction of the 3D surface and do not aim to use these SDFs for simulation.

## 6 Discussion and Limitations

We introduce a rigid-body simulator, SDF-Sim, that uses learned SDFs to represent the object shapes and employs a graph network to learn dynamics over these objects. We re-design the construction of the input graph for the simulator to make use of SDFs and reduce the number of inter-object edges from quadratic to linear, unlocking the ability to scale to large scenes. We provide detailed study on both small-scale benchmarks and large scenes with up to 50x more objects than seen in the training. Additionally, we investigate the impact of SDF quality on the simulation results. Our work demonstrates, for the first time in the learning simulation literature, that we can use these simulators on scenes with hundreds of objects and up to 1.1 million nodes and produce realistic rollouts, potentially unlocking applications to virtual reality, film, robotics, and more.

**Limitations** One limitation of SDF-Sim is that it requires training an SDF MLP for every new shape we want to include in a simulation. A promising future direction is to train one model on a dataset of many shapes, amortising the cost of training SDFs, similarly to [28; 34]. We also note that SDF-Sim has slightly higher error on small-scale datasets (section 4.1), although SDF-Sim is closer to the ground-truth on large scenes than FIGNet* (section 4.2). We believe it is justifiable to trade a slight increase in model error in exchange for the ability to run on larger scenes than previously possible. We believe that SDF-Sim is therefore best suited for the applications that favour scaling over physical accuracy, such as animation and film. Finally, in this paper we only focus on rigid-rigid interactions, but SDFs can be extended to incorporate deformable or articulated objects [24; 42], fluids , and even a mix of SDFs, meshes, and particles.

**Broader impact** We see our work as a step in making applications that require simulation, such as augmented reality or animation, more accessible to everyday consumers. As such, our work allows us to directly use 3D assets filmed on a mobile phone, and simulate large scenes using a commodity hardware with a single GPU, without requiring a specialized skill of creating meshes appropriate for simulation. Overall, we see SDF-Sim as an important step towards learning physically realistic dynamics models from real-world data, and for enabling physical reasoning over complex, large-scale physical scenes.