# Robust Knowledge Transfer in Tiered RL

Jiawei Huang

Department of Computer Science

ETH Zurich

jiawei.huang@inf.ethz.ch &Niao He

Department of Computer Science

ETH Zurich

jiawei.huang@inf.ethz.ch

###### Abstract

In this paper, we study the Tiered Reinforcement Learning setting, a parallel transfer learning framework, where the goal is to transfer knowledge from the low-tier (source) task to the high-tier (target) task to reduce the exploration risk of the latter while solving the two tasks in parallel. Unlike previous work, we do not assume the low-tier and high-tier tasks share the same dynamics or reward functions, and focus on robust knowledge transfer without prior knowledge on the task similarity. We identify a natural and necessary condition called the "Optimal Value Dominance" for our objective. Under this condition, we propose novel online learning algorithms such that, for the high-tier task, it can achieve constant regret on partial states depending on the task similarity and retain near-optimal regret when the two tasks are dissimilar, while for the low-tier task, it can keep near-optimal without making sacrifice. Moreover, we further study the setting with multiple low-tier tasks, and propose a novel transfer source selection mechanism, which can ensemble the information from all low-tier tasks and allow provable benefits on a much larger state-action space.

## 1 Introduction

Comparing with individual learning from scratch, transferring knowledge from other similar tasks or side information has been proven to be an effective way to reduce the exploration risk and improve sample efficiency in Reinforcement Learning (RL). Multi-Task RL (MT-RL)  and Transfer RL [26; 18; 37] are two mainstream knowledge transfer frameworks; however, both are subject to limitations when dealing with real-world scenarios. MT-RL studies the setting where a set of similar tasks are solved concurrently, and the main objective is to accelerate the learning by sharing information of all tasks together. However, in practice, in many MT-RL scenarios, the tasks are not equally important and we are more interested in the performance of certain tasks. For example, in robot learning, a few robots are more valuable and hard to fix, while the others are cheaper or just simulators. Most existing works on MT-RL treat all tasks equally and focus primarily on the reduction of the total regret of all tasks as a whole [3; 8; 36; 11], with no guarantee of improving a particular task. In contrast, transfer RL distinguishes the priority of different tasks by categorizing them into source and target tasks and aims at transferring the knowledge from source tasks (or some side information like value predictors) to facilitate the learning of target tasks [21; 27; 9; 10]. However, a key assumption in transfer RL is that the source task is completely solved before the learning of the target task, and this is not always practical. For example, in some sim-to-real domain, the source task simulator may require a long time to solve , and in some user-interaction scenarios , the source and target tasks refer to different user groups and they have to be served simultaneously. In these cases, it's more reasonable to solve the source and target tasks in parallel and transfer the information immediately once available.

Recently,  proposed a new "parallel knowledge transfer" framework, called Tiered RL, which is promising to fill the gap. Tiered RL considers the case when a source task \(M_{}\) and a target task\(M_{}\) are learned in parallel, by two separate algorithms \(^{}\) and \(^{}\), and its goal is to reduce the exploration risk and regret in learning \(M_{}\) by leveraging knowledge transfer from \(M_{}\) to \(M_{}\).  showed that under the strong assumption that \(M_{}=M_{}\), it's possible to achieve constant regret in learning \(M_{}\) while keeping regret in \(M_{}\) optimal in gap-dependent setting. Yet, their algorithm based on Pessimistic Value Iteration (PVI)  can be hardly applied when the assumption \(M_{}=M_{}\) breaks, given its pure exploitation nature, making their result very restrictive.

In this paper, we study the general Tiered RL setting _without prior knowledge_ about how similar the tasks are 1. The key question we would like to address is: **Can we design algorithms s.t.: (1) Regret in \(M_{}\) keeps near-optimal; (2) Regret in \(M_{}\) achieves provable benefits when \(M_{}\) and \(M_{}\) are similar while retaining near-optimal otherwise?** Note for \(^{}\), we expect it to achieve near-optimal regret bounds, which is reasonable since the source task is often important and our results still hold if relaxing it. As for \(^{}\), we expect it to be _robust_, i.e., it can adaptively exploit from \(M_{}\) if it is close to \(M_{}\), while avoiding negative transfer in other cases. Notably, our setting strictly generalizes  and is much more challenging, for balancing the exploitation from \(M_{}\) and exploration from \(M_{}\) without prior knowledge of task similarity. We give positive answers to the above question in this paper and demonstrate provable benefits with robust knowledge transfer for Tiered RL framework. Below, we summarize our main contributions in three aspects.

**Our first contribution** is to identify essential conditions and notions about when and how our objective is achievable. We first provide a mild condition called _Optimal Value Dominance_ (OVD), and in Sec. 3, we justify its necessity to our objective by a lower bound result. Our lower bound holds even if \(M_{}\) is fully known to the learner, and therefore, it also justifies the necessity of similar assumptions in previous transfer RL literatures [9; 10]. Besides, we introduce the notion of _transferable states_ to characterize states on which \(M_{}\) is expected to achieve benefits by transferring knowledge from \(M_{}\). We believe those findings also provide useful insights for further works.

As **our second contribution**, in Sec. 4, we propose novel algorithms for Tiered Multi-Armed Bandit (MAB) and Tiered RL, which can achieve robust parallel transfer by balancing between pessimism-based exploitation from \(M_{}\) and optimism-based online learning in \(M_{}\). Depending on the similarity between \(M_{}\) and \(M_{}\), our algorithms can enjoy constant regret on a proportion of state-action pairs or even on the entire \(M_{}\) by leveraging information from \(M_{}\), while timely interrupting negative transfer and retaining near-optimal regret on states dissimilar between two tasks. Moreover, in the bandit setting, our result implies a strictly improved regret bound when \(M_{}=M_{}\), compared with previous results under the same setting [22; 13].

Beyond the single low-tier task setting, in many real-world scenarios, it's reasonable to assume there are multiple different low-tier tasks \(_{}=\{M_{,w}\}_{w=1}^{W}\) available. As **our third contribution**, in Sec. 5, we extend our algorithm to this setting with a new source task selection mechanism. By novel techniques, we show that, even if each \(M_{,w}\) may only share similarity with \(M_{}\) on a small portion of states, we are able to ensemble the information from each source task together to achieve constant regret on a much larger state-action space "stitched" from the transferable state-action set in each individual \(M_{,w}\), at the expense of an additional \( W\) factor in regret. Besides, our algorithm is still robust to model difference and retains near-optimal regret in general. Although we only study the Tiered RL setting in this paper, we believe our task selection strategy can be applied to standard transfer RL setting [9; 10] when multiple (partially correct) side information or value predictors are provided, which is an interesting direction for future work. Finally, we conduct experiments in toy examples to verify our theoretical results.

### Closely Related Work

For the lack of space, we only discuss closely related work here and defer the rest to Appx. A.2. The most related to us is the Tiered RL framework , which was originally motivated by Tiered structure in user-oriented applications. However, they only studied the case when \(M_{}=M_{}\), which limits the practicability of their algorithms. Although there is a sequence of work studying parallel transfer learning in multi-agent system [25; 19], but they mainly focused on heuristic empirical algorithms and did not have theoretical guarantees.

Transfer RL , compared to learning from scratch, can reduces exploration risk of target task by leveraging information in similar source tasks or side information [21; 27; 9; 10]. Comparing with transfer RL setting, our parallel transfer setting has some additional challenges. Firstly, \(M_{}\) can only leverage estimated value/model/optimal policy from \(M_{}\) with uncertainty, which implies we need additional efforts to control failure events with non-zero probability comparing with normal transfer RL setting. Secondly, the constraints on the optimality of \(_{K}(M_{})\), although reasonable, restrict the transferable information because in \(M_{}\) estimation uncertainty can only be controlled on those states frequently visited. Moreover, none of these previous work studies how to leverage multiple partially correct side information like what we did in Sec. 5. In MT-RL setting, the benefits of leveraging information gathered from other tasks has been observed from both empirical and theoretical works [31; 3; 8; 24; 36; 11]. But MTRL treats each task equally, and the reduction of total regret over all tasks does not directly imply benefits achieved in a particular task.

## 2 Preliminary and Problem Formulation

**Tiered Stochastic MAB and Tiered Episodic Tabular RL** In Tiered MAB setting, we consider a low-tier task \(M_{}\) and a high-tier task \(M_{}\) sharing the arm/action space \(=\{1,2,...,A\}\). By pulling the arm \(i[A]\) in \(M_{}\) or \(M_{}\), the agent can observe a random variable \(r_{}(i)\) or \(r_{}(i)\). We will use \(_{}(i)=[r_{}(i)]\) and \(_{}(i)=[r_{}(i)]\) to denote the expected return of the \(i\)-th arm in \(M_{}\) and \(M_{}\), respectively, and note that it's possible that \(_{}(i)_{}(i)\).

For Tiered RL, we assume that two tasks \(M_{}=\{,,H,_{},r_{}\}\) and \(M_{}=\{,,H,_{},r_{}\}\) share the finite state \(\) and action space \(\) across episode length \(H\) (i.e. \(_{h}=,_{h}=\) for any \(h[H]\)), but may have different time-dependent transition and reward functions \(_{}=\{_{,h}\}_{h=1}^{H},r_{}= \{r_{,h}\}_{h=1}^{H}\) and \(_{}=\{_{,h}\}_{h=1}^{H},r_{}= \{r_{,h}\}_{h=1}^{H}\). W.l.o.g., we assume the initial state \(s_{1}\) is fixed, and the reward functions \(r_{}\) and \(r_{}\) are deterministic and bounded by \(\). In episodic MDPs, we study the time-dependent policy specified as \(:=\{_{1},...,_{H}\}\) with \(_{h}:_{h}(_{h})\) for all \(h[H]\), where \((_{h})\) denotes the probability simplex over the action space. With a slight abuse of notation, when \(_{h}\) is a deterministic policy, we use \(_{h}:_{h}_{h}\) to denote the deterministic mapping. Besides, we use \(Q_{h}^{}(s,a)=[_{h^{}=h}^{H}r_{h^{}}(s_{h^{ }},a_{h^{}})|s_{h}=s,a_{h}=a,],\;V_{h}^{}(s)=_{a} [Q_{h}^{}(s,a)]\) to denote the value function for \(\) at step \(h[H]\), and denote \(d_{h}^{}():=(s_{h}=|)\) and \(d_{h}^{}(,):=(s_{h}=,a_{h}=|)\) as the state and state-action occupancy w.r.t. policy \(\). We use \(^{*}\) to denote the optimal policy, and \(h_{h}^{*},Q_{h}^{*},d_{h}^{*}\) as a short note when \(=^{*}\). To avoid confusion, we will specify the policy and value functions in \(M_{}\) and \(M_{}\) by Lo and Hi in subscription, respectively. For example, in \(M_{}\) we have \(_{}:=\{_{,1},...,_{,H}\}\), \(Q_{,h}^{_{}}/V_{,h}^{_{}}\) and \(Q_{,h}^{*}/V_{,h}^{*}\), \(d_{,h}^{_{}},d_{,h}^{*}\), and similarly for \(M_{}\).

**Gap-Dependent Setting** Throughout, we focus on gap-dependent setting [17; 23; 34; 7]. Below we introduce the notion of gap for \(M_{}\) as an example, and those for \(M_{}\) follows similarly. In MAB case, the gap in \(M_{}\) w.r.t. arm \(i\) is defined as \(_{}(i):=_{j[A]}_{}(j)-_{}(i),  i[A]\), and for tabular RL setting, we have \(_{}(s_{h},a_{h}):=V_{,h}^{*}(s_{h})-Q_{,h}^{*} (s_{h},a_{h}), h[H],s_{h}_{h},a_{h}_{h}\). We use \(_{,}\) to refer to the minimal gap such that \((s_{h},a_{h})_{,}\) for all non-optimal actions \(a_{h}\), and use \(_{}:=\{_{,},_{,}\}\) to denote the minimal gap over two tasks. In the gap-dependent setting, we assume \(_{}>0\).

**Knowledge Transfer from Multiple Low-Tier Tasks** In this case, we assume there are \(W>1\) different source tasks \(_{}=\{M_{,w}\}_{w=1}^{W}\) and all the tasks share the same state and action spaces but may have different transition and reward function. We defer the extended framework for this setting to Appx. A. We specify the task index \(w[W]\) in sub-scription to distinguish the notation for different source tasks (e.g. \(_{,w,h},Q_{,w,h}^{()}\)). Moreover, we define \(_{}:=\{_{,1,},...,_{,W,}, _{,}\}\). For convenience, in the rest of the paper, we use TRL-MST (Tiered RL with Multiple Source Task) as a short abbreviation for this setting.

**Performance Measure** We use Pseudo-Regret as performance measure: \(_{K}(M_{}):=[_{k=1}^{K}V_{1}^{*}(s_{1})-V_{ 1}^{_{}^{k}}(s_{1})];\;\;_{K}(M_{}):= [_{k=1}^{K}V_{1}^{*}(s_{1})-V_{1}^{_{}^{k}}(s_{ 1})],\) where \(K\) is the number of iterations, \(\{_{}^{k}\}_{k=1}^{K}\) and \(\{_{}^{k}\}_{k=1}^{K}\) are generated by the algorithms.

**Frequently Used Notations** We denote \([n]=\{1,2,...,n\}\). Given a transition matrix \(:()\), and a function \(V:\), we use \(V(s_{h},a_{h})\) as a short note of \(_{s^{}(|s,a)}[V(s^{})]\). We will use \(i_{}^{*}/i_{}^{*}\) to denote the optimal arm in bandit setting, and \(_{}^{*}/_{}^{*}\) denotes the optimal policy in RL setting. In TRL-MST setting, we use \(i_{,w}^{*}/_{,w}^{*}\) to distinguish different source tasks.

### Assumptions and Characterization of Transferable States

Throughout the paper, we make several assumptions. The first one is the uniqueness of the optimal policy, which is common in the literature [22; 4].

**Assumption A**.: Both \(M_{}\) (or \(\{M_{,w}\}_{w=1}^{W}\)) and \(M_{}\) have unique optimal arms/policies.

Next, we introduce a new concept called "Optimal Value Dominance" (OVD for short), which says that for each state (or at least those states reachable by optimal policy in \(M_{}\)), the optimal value of \(M_{}\) is an approximate overestimation for the optimal value of \(M_{}\). In Sec. 3, we will use a lower bound to show such a condition is necessary to attain the robust transfer objective.

**Assumption B**.: In single source task setting, we assume \(M_{}\) has Optimal Value Dominance (OVD) over \(M_{}\), s.t., \( h[H]\), for all \(s_{h}_{h}\) (or only for those \(s_{h}\) with \(d^{}_{,h}(s_{h})>0\)), we have: \(V^{}_{,h}(s_{h}) V^{}_{,h}(s_{h})-}{2(H+1)}\). In TRL-MST setting, we assume each \(M_{,w}\) has OVD over \(M_{}\).2

We remark that Assump. B is a rather mild condition that naturally holds with reward shaping. Note that since \(V^{}_{,h}() H-h\), by shifting the reward function of \(M_{}\) to \(r^{}_{,h}(,)=r_{,h}(,)+1\), we immediately obtain the OVD property. Even though, such a reward shift may impair the set of transferable states as we will introduce in Def. 2.2. We provide several reasonable settings in Appx. A.3 including identical model , small model difference, and known model difference, where Assump. B is satisfied and there exists a non-empty set of transferable states. We also point out that several existing work on transfer RL assumed something similar or even stronger [9; 10], which we defer a thorough discussion to Appx. A.2.

**Assumption C**.: The learner has access to a quantity \(_{}\) satisfying \(0_{}_{}\).

The final one is about the knowledge of a lower bound of \(_{}\), which can always be satisfied by choosing \(_{}=0\). Nevertheless, it would be more beneficial if the learner has access to some quantity \(_{}\) closer to \(_{}\) than 0. As we introduce below, the magnitude of \(_{}\) is related to how we quantify the similarity between \(M_{}\) and \(M_{}\) and which states we expect to benefit from knowledge transfer. Below we focus on the single source task setting and defer the discussion for TRL-MST setting to Sec. 5.

**Definition 2.1** (\(\)-Close).: Task \(M_{}\) is \(\)-close to task \(M_{}\) on \(s_{h}\) at step \(h\) for some \(>0\), if \(V^{}_{,h}(s_{h})-V^{}_{,h}(s_{h})\) and \(^{}_{}(s_{h})=^{}_{}(s_{h})\).

**Definition 2.2** (\(\)-Transferable States).: State \(s_{h}\) is \(\)-transferable for some \(>0\), if \(d^{}_{}(s_{h})>\) and \(M_{}\) is \(_{}}{4(H+1)}\)-close to \(M_{}\) on \(s_{h}\). The set of \(\)-transferable states at \(h[H]\) is denoted as \(^{}_{h}\).

We regard \(s_{h}\) in \(M_{}\) has transferable knowledge to \(M_{}\), if it can be reached by optimal policy in \(M_{}\) and the optimal value and action at \(s_{h}\) for two tasks are similar. Here the condition \(d^{}_{}(s_{h})>0\) is necessary since in \(M_{}\), only the states reachable by \(^{}_{}\) can be explored sufficiently by \(^{}\) due to its near optimal regret. Combining with Assump. B, one can observe that the value difference on transferable states are controlled by \(|V^{}_{,h}(s_{h})-V^{}_{,h}(s_{h})|=O(_{}}{H}) O(}{H})\). As we will show in Thm. 3.2 in Sec. 3, the term \(O(_{})\) is indeed unimprovable if we expect robustness.

## 3 Lower Bound Results: Necessary Condition for Robust Transfer

Now we establish lower bounds that show Assump. B is necessary and how the magnitude of \(_{}\) restricts the robust transfer objective. The results in this section are based on two-armed Bernoulli bandits for simplicity, and the proofs are deferred to Appx. B. By extending these hard instances to RL case, there is a gap caused by the additional \(\) in Assump. B and Def. 2.2, which comes from the requirement of our algorithm design, and we leave it to the future work.

**Justification for Assump. B** We show that if Assump. B is violated, it is impossible to have algorithms \((^{},^{})\) to simultaneously achieve constant regret when \(M_{}=M_{}\), while retaining sub-linear regret for all the cases regardless of the similarity between \(M_{}\) and \(M_{}\). Here we require constant regret on \(M_{}=M_{}\) since we believe it is a minimal expectation to achieve benefits in transfer whenthe two tasks are identical. Intuitively, without Assump. B, even if we know \(_{}(i_{}^{*})=_{}(i_{}^{*})\), we cannot ensure \(i_{}^{*}\) is the optimal arm in \(M_{}\). Then, if \((^{},^{})\) can achieve constant regret on \(M_{}=M_{}\), the algorithm must stop exploration on the arm \(i i_{}^{*}\) after finite steps, and thus, it suffers from linear regret in another instance of \(M_{}\) where \(i_{}^{*} i_{}^{*}\).

Moreover, Thm. 3.1 holds even if the learner has full information of \(M_{}\), where the setting degenerates to normal transfer RL since there is no need to explore \(M_{}\). This explains why similar assumptions to Assump. B are considered in previous transfer RL works [9; 10].

**Theorem 3.1**.: _Under the violation of Assump. B, even regardless of the optimality of \(^{}\), for each algorithm pair \((^{},^{})\), it cannot simultaneously (1) achieve constant regret for the case when \(M_{}=M_{}\) and (2) ensure sub-linear regret in all the other cases._

\(_{}\) in Tolerance Error is InevitableNext, we show that, if \(M_{}\) and \(M_{}\) are \(\)-close for some \(}{2}\), in general we cannot expect to achieve constant regret on \(M_{}\) by leveraging \(M_{}\) without other loss. Similar to Thm. 3.1, the main idea is to construct different instances for \(M_{}\) with different optimal arms and cannot be distinguished within finite number of trials.

**Theorem 3.2**.: _[Transferable States are Restricted by \(_{}\)] Under Assump. B, regardless of the optimality of \(^{}\), given arbitrary \(_{}\) and arbitrary \([}{2},_{}]\), for each algorithm pair \((^{},^{})\), it cannot simultaneously (1) achieve constant regret for the case when \(M_{}\) and \(M_{}\) with minimal gap \(_{}\) are \(\)-close, and (2) ensure sub-linear regret in all other cases._

## 4 Robust Tiered MAB/RL with Single Source Task

In this section, we study Tiered MAB and Tiered RL when a single low-tier task \(M_{}\) is available. The key challenge compared with  is that we do not have knowledge about whether \(M_{}\) and \(M_{}\) are similar or not so the pure exploitation will not work. Instead, the algorithm should be able to identify whether \(M_{}\) and \(M_{}\) are close enough to transfer by data collected so far, and balance between the exploration by itself and the exploitation from \(M_{}\) at the same time.

To overcome the challenge, we identify a state-wise checking event, such that, under Assump. B, if \(s_{h}\) is transferable, the event is true almost all the time, and otherwise, every mistake will reduce the uncertainty so the chance the event holds is limited. By utilizing it, our algorithm can wisely switch between optimistic exploration and pessimistic exploitation and achieve robust transfer. In Sec. 4.1, we start with the MAB setting and illustrate the main idea, and in Sec. 4.2, we generalize our techniques to RL setting, and discuss how to overcome the challenges brought by state transition.

### Robust Transfer in Tiered Multi-Armed Bandits

The algorithm is provided in Alg. 1. We choose \(^{}\) as UCB, and \(^{}\) as an exploitation-or-UCB style algorithm branched by a checking event in line 7, which is the key step to avoid negative transfer.

```
1Initialize:\(>2;\ N_{}^{1}(i),\ N_{}^{1}(i),\ _{}^{1}(i),\ _{}^{1}(i) 0,\  i;\)\(f(k):=1+16A^{2}(k+1)^{2}\)
2 Pull each arm at the beginning \(A\) iterations
3for\(k=A+1,A+2,...,K\)do
4\(_{}^{k}(i)_{}^{k}(i)+ }^{k}(i)}},_{ }^{k}_{i}_{}^{k}(i), _{}^{k}_{}^{k}.\)
5\(_{}^{k}(i)_{}^{k}(i)- }^{k}(i)}},_{ }^{k}_{i}_{}^{k}(i).\)
6\(_{}^{k}(i)_{}^{k}(i)+ } f(k)}{N_{}^{k}(i)}}, _{}^{k}_{i}_{}^{k}(i).\)
7if\(_{}^{k}(_{}^{k})_{ }^{k}(_{}^{k})+\) and \(N_{}^{k}(_{}^{k})>k/2\)then\(_{}^{k}_{}^{k}\)else\(_{}^{k}_{}^{k}.\)
8 Interact \(M_{}/M_{}\) by \(_{}^{k}/_{}^{k}\); Update \(N_{}^{k+1}/N_{}^{k+1}\) and empirical mean \(_{}^{k+1}/_{}^{k+1}\).
9 end for
```

**Algorithm 1**Robust Tiered MAB

Key Insights: Separation between Transferable and Non-Transferable CasesTo understand our checking event, we consider the following two cases: (1) \(M_{}\) and \(M_{}\) are \(\)-close, and (2)(in the rest cases we have \(i^{*}_{}=i^{*}_{}\) but \(_{}(i^{*}_{})>_{}(i^{*}_{})+\), so exploiting from \(M_{}\) is harmless). Recall Assump. B, in Case 1, we have \(_{}(i^{*}_{})_{}(i^{*}_{})+\), while in Case 2, with an appropriate choice of \(\) (e.g. \(=_{}}{4}<}{4}\)), we have \(_{}(i^{*}_{})_{}(i^{*}_{})- }{2}_{}(i^{*}_{})++ }(i^{*}_{})}{2}\), which reveals the separation between two cases. As a result, if we can construct an uncertainty-based upper bound \(^{k}_{}(i^{*}_{})\) for \(_{}(i^{*}_{})\), we should expect the event \(:=_{}(i^{*}_{})<^{k}_{}(i^{*}_{})+\) almost always be true in Case 1, while in Case 2, everytime \(\) occurs and \(^{}}\) takes \(i^{*}_{}\), the "self-correction" is triggered: the uncertainty is reduced so the estimation \(^{k}_{}(i^{*}_{})\) gets closer to \(_{}(i^{*}_{})\), and because of the separation between \(_{}(i^{*}_{})\) and \(_{}(i^{*}_{})\), the number of times that \(\) is true is limited. The remaining issue is that we do not know \(_{}(i^{*}_{})\) and \(i^{*}_{}\), and we approximate them with LCB value \(^{k}_{}()\) and its greedy policy. The additional checking event \(N^{k}_{}(^{k}_{})>k/2\) is used to increase the confidence that \(^{k}_{}=i^{*}_{}\) once transfer, which also contributes to reducing the regret. Finally, to achieve constant regret, we use \(\) to control the total failure rate to be \(_{k=1}^{+}k^{-()}=C\) for some constant \(C\). We summarize the main result in Thm. 4.1 and defer the proof to Appx. C.

**Theorem 4.1**.: _[Tiered MAB with Single Source Tasks] Under Assump. A, B and C, by running Alg. 1 with \(=_{}}{4}\) and \(>2\), we always have \(_{K}(M_{})=O(_{_{}(i)>0}}(i)} K)\). Moreover, if \(M_{}\) and \(M_{}\) are \(_{}}{4}\)-close, we have: \(_{K}(M_{})=O(_{_{}(i)>0}}(i)}})\)._

**Comparison with [22; 13]** As we can see, our algorithm can automatically achieve constant regret if tasks are similar while retaining near-optimal otherwise. Notably, even when \(M_{}=M_{}\), our regret bound \((_{_{}(i)>0}}(i)})\) is strictly better than \((}}}(i)> 0}}(i)}})\) in  and \((_{_{}(i)>0}(A-i)( }(i)}-}(i)}{_{}(i-1)^{2}}))\) in  under the same setting.

### Robust Transfer in Tiered Tabular RL

In this section, we focus on RL setting. We provide the algorithm in Alg. 2, where we defer the details of **ModelLearning** function and the requirements for **Bonus** function to Appx. D.1. In the following, we first highlight our main result.

**Theorem 4.2**.: _[Tiered RL with Single Source Tasks] Under Assump. A, B and C, Cond. D.1 for \(^{Lo}\) and Cond. D.3 for **Bonus** function, by running Alg. 2 with \(=_{}}{4(H+1)}\), \(>2\), an arbitrary \(>0\), we have_

\[_{K}(M_{})=OSH_{h=1}^{H}_{(s_{h},a_{h}) _{h}_{h}^{}_{h}}( }}(s_{h},a_{h})})( SAHK).\]

Here the set \(^{}_{h}_{h}_{h}\) captures the benefitable state-action pairs to be introduced later. For simplicity, in Thm. 4.2 above, we omit all constant terms independent with \(K\) that may include \(^{-1}\), \(_{}^{-1}\) or \( 1/d^{*}_{h}()\). The complete version of Thm. 4.2 can be found in Thm. D.16. As we can see, comparing with pure online learning algorithms [23; 34; 7], in our setting, \(M_{}\) only suffers non-constant regret on a subset of the state-action space. The \(SH\) factor may be further improved by choosing better **Bonus** functions than our Example D.4 given in Appx. D.1.

Different from the bandit setting, the state transition causes more challenges. In the following, we first explain the algorithm design to highlight how we overcome the difficulties, and then provide the analysis and proof sketch. Detailed proofs can be found in Appx. D.

**Technical Challenges and Algorithm Design** Similar to MAB setting, for \(M_{}\) we choose an arbitrary near-optimal algorithm, and for \(M_{}\) we set up a state-wise checking event \(^{k}_{,h}()^{k}_{,h}(,^{k}_{,h})+\) in line 15 to determine whether to exploit from \(M_{}\) or not. Here \(V^{k}_{,h}\) and \(^{k}_{,h}\) serve as lower and upper bounds for \(V^{*}_{}\) and \(Q^{*}_{}\), and \(^{k}_{,h}\) and \(^{k}_{,h}\) are constructed by Pessimistic Value Iteration , which can be shown to converge to \(V^{*}_{,h}\) and \(^{*}_{,h}\), respectively. Similar to , for the choice of \(^{}\) and the bonus term used to construct lower/upper confidence estimation, we consider general algorithm framework under Cond. D.1 and Cond. D.3 in Appx. D.1.

To overcome challenges resulting from state transition, we make two major modifications when moving from MAB to RL setting. First of all, because of the constraint on the optimality of \(^{}\)we cannot expect \(M_{}\) to provide useful information on those \((s_{h},a_{h})\) with \(d^{*}_{}(s_{h},a_{h})=0\) since they will not be explored sufficiently. Therefore, in the checking event in line 15, we include \(_{a}N^{k}_{,h}(s_{h},a)>( k)\) as a criterion, where \(\) is a hyper-parameter chosen and input to the algorithm. Intuitively, for all \(s_{h},a_{h}\), we should expect \(N^{k}_{,h}(s_{h},a_{h})(d^{*}_{}(s_{h}, a_{h}) k)\) when \(k\) is large enough. Therefore, by comparing \(N^{k}_{,h}\) with \( k\), we can filter out those \(s_{h}\) with \(d^{*}_{}(s_{h})<\) to avoid harm from inaccurate estimation.

Secondly and more importantly, different from MAB setting, besides the error occurred at a particular step, we also need to handle the error accumulated during the back-propagation process of value iteration. In our case, this is reflected by the loss of overestimation when we incorporate selective exploitation into the optimism-based exploration framework. To see this, suppose at some \(s_{h}\), we have an overestimation on optimal value \(Q^{*}_{,h}\) denoted as \(^{k}_{,h}\). When the checking criterion is satisfied, if we mimic the MAB setting, i.e., assign \(^{k}_{,h}\) to \(^{k}_{,h}\) and update value by \(^{k}_{,h}(s_{h})^{k}_{,h}(s_{h},^{k}_{,h})\), when \(^{*}_{}(s_{h})^{*}_{,h}(s_{h})\), \(^{k}_{,h}(s_{h})\) is no longer guaranteed to be an overestimation for \(V^{*}_{,h}(s_{h})\). As \(^{k}_{,h}(s_{h})\) involves in back-propagation, it will pull down the estimation value for its ancestor states, thus reducing the chance to visit \(s_{h}\) and slowing down the "self-correction process" which works well in MAB setting.

```
1Input: Ratio \((0,1)\); \(>2\); Auxiliary functions Bonus and ModelLearning; Sequence of confidence level \((_{k})_{k 1}\) with \(_{k}=1/SAHk^{}\); \(:=_{}/4(H+1)\) for some \(_{}_{}\)
2Initialize:\(D^{0}_{}/D^{0}_{}\{\}; k,\;^ {k}_{(),H+1},^{k}_{(),H+1},^{k}_{,H+1},^{k}_{,H+1} 0\).
3for\(k=1,2,...\)do
4\(_{}^{}(D^{k-1}_{})\);
5\(\{}^{k}_{,h}\}_{H=1}^{H}(D^{k-1}_{})\), \(\{b^{k}_{,h}\}_{h=1}^{H}(D^{k-1}_{},\;_{k})\).
6for\(h=H,H-1...,1\)do
7\(Q^{k}_{,h}(,)\{0,r_{,h}(,) +}^{k}_{,h}^{k}_{,h+1}( ,)-b^{k}_{,h}(,)\}\)
8\(^{k}_{,h}(,)\{H,r_{,h} (,)+}^{k}_{,h}^{k}_{,h+1}(,)+b^{k}_{,h}(,)\}\).
9for\(s_{h}_{h}\)do
10if\(^{k}_{,h}(s_{h})^{k}_{,h}(s_{h}, ^{k}_{,h})+\) and \(_{a}N^{k}_{,h}(s_{h},a)>k\)then
11\(^{k}_{}(s_{h})_{a}N^{k}_{,h}(s_{h},a)\). / "Trust and Exploit" Branch
12
13 end if
14else\(^{k}_{}()_{a}^{k}_{,h}(,a)\). / "Explore by itself" Branch ;
15\(^{k}_{,h}(s_{h})\{H,^{k}_{ ,h}(s_{h},^{k}_{})+(^{k}_{,h}(s_{h},^{k}_{})-^{^{k}_{}}(s_{h},^{k}_{}))\}\)
16\(^{^{k}_{,h}}(s_{h})=Q^{^{k}_{}}_{,h}(s_{h},^{k}_{})\).
17
18 end if
19
20 end for
21
22 end for
23
24
```

**Algorithm 2**Robust Tiered RL

The key insight to overcome such difficulty is that, if the checking event holds yet \(^{*}_{}(s_{h})^{*}_{,h}(s_{h})\), the gap between \(^{k}_{,h}(s_{h},^{*}_{})\) and \(Q^{*}_{,h}(s_{h},^{*}_{})\) should not be small, and we can show that \(^{k}_{,h}(s_{h},^{k}_{}) ^{k}_{,h}(s_{h},^{*}_{}) Q^{*}_{,h}(s_{h},^{*}_{})+(_{}(s_{h},^{*}_{ }))\) with the choice of \(=O(_{}/H)\). Therefore, revising \(^{k}_{,h}(s_{h},^{k}_{})\) by adding \(1/H\) of the gap \(^{k}_{,h}(s_{h},^{k}_{})-Q^{*}_{,h}(s_{h}, ^{*}_{})\) (line 19) is enough to guarantee the overestimation. Lastly, since \(Q^{*}_{,h}(s_{h},^{*}_{})\) in unknown, we construct an underestimation \(^{^{k}_{,h}}_{,h}(s_{h},^{*}_{})\) and use it instead. As a result, we have the following theorem, where the clip function is defined by \([x|w]:=x[x w]\).

**Theorem 4.3**.: _There exists \(k_{}=(S,A,H,^{-1},^{-1}_{})\), such that, for all \(k k_{}\), on some event \(_{k}\) with \((_{k}) 3_{k}\), we have \(Q^{*}_{,h}(s_{h},a_{h})^{k}_{,h}(s_{h},a_{h}), \;V^{*}_{,h}(s_{h})^{k}_{,h}(s_{h}), h [H],\;s_{h}_{h},\;a_{h}_{h}\) and_

\[V^{*}_{,1}(s_{1})-V^{^{k}_{}}_{,1}(s_{1}) 2 e_{^{k}_{}}[_{h=1}^{H}[\{H,4b ^{k}_{,h}(s_{h},a_{h})\}|}{4eH}}(s_{h},a_{h})}{4e}]]. \]

Benefits of Knowledge TransferWe first take a look at \(k k_{}\). As implied from Eq. (1), we can upper bound the regret on each \(s_{h},a_{h}\) by summing over the RHS of Eq. (1). Note that by Cond. D.3, \(b^{k}_{,h}(s_{h},a_{h})=O((SAH) k}{_{ ,h}(s_{h},a_{h})}})\) and \([N^{k}_{,h}(s_{h},a_{h})]=_{k^{}=1}^{k-1}d^{^ {}}_{}(s_{h},a_{h})\), we can establish the near-optimal regret bound with similar techniques in  regardless of the similarity between \(M_{}\) and \(M_{}\). Moreover, because of the knowledge transfer from \(M_{}\), we can achieve better regret bounds for \(M_{}\). In the following, we characterize three subclasses of state-action pairs, on which Alg\({}^{}\) only suffers constant regret. _First of all_, for those \(s_{h}^{1}_{h}\), we can expect the checking event almost always hold for arbitrary \(k\). Hence, when \(k\) is large enough, \(^{k}_{,h}(s_{h})=^{k}_{,h}(s_{h}) ^{*}_{,h}(s_{h})\), implying Alg\({}^{}\) will almost never take sub-optimal actions at \(s_{h}\) since then. We denote this first subclass as \(^{1,}_{h}:=\{(s_{h},a_{h})|s_{h}^{1}_{h},a_{h} ^{*}_{,h}(s_{h})\}\). _Secondly_, note that, given a state \(s_{h}\), if all possible trajectories starting from \(s_{1}\) to \(s_{h}\) have overlap with \(^{1,}_{h^{}}\) for some \(h^{}[h-1]\), when \(k\) is large enough, \(^{k}_{}\) will almost have no chance to reach \(s_{h}\) and will not suffer the regret at \(s_{h}\). For convenience, we define function \((\{^{1,}_{h}\}_{h^{}=1}^{h-1},s_{h})\) which takes True for those states described above, and takes False for the others. Then, we define the second subclass by \(^{2,}_{h}:=\{(s_{h},a_{h})|(\{^{1, }_{h^{}}\}_{h^{}=1}^{h-1},s_{h})=,\;s_{h} ^{}_{h},\;a_{h}_{h}\}\). _Finally_, for those \(s_{h},a_{h}\) with \(d^{*}_{}(s_{h},a_{h})>0\), we can show \(N^{k}_{,h}(s_{h},a_{h}) d^{*}_{}(s_{h},a_{h})k\). Therefore, \(b^{k}_{,h}(s_{h},a_{h}) k/_{,h}(s_{h}, a_{h})}\) in Eq. (1) will decay and the clipping operator will take effect, which leads to constant regret. This third subclass is denoted by \(^{*}_{h}:=\{(s_{h},a_{h})|d^{*}_{}(s_{h},a_{h})>0\}\). Based on the above discussion, we define \(^{}_{h}:=^{,1}_{h}^{,2}_{h}^{*}_{h}\) to be the benefitable states set in Thm. 4.2.

For \(k k_{}\), for the lack of overestimation, we simply use \(H\) to upper bound the value gap \(V^{*}-V^{^{k}_{}}\). This results in a \((S,A,H,^{-1},^{-1}_{})\) burn-in term, which was omitted in Thm. 4.2 since it is independent with \(K\). Besides, by the definition of \(k_{}\) in Thm. 4.3, we can see the trade-off of choosing \(\): a smaller \(\) can enlarge \(^{}_{h}\) so we have constant regret on more state-action pairs, while it also results in the delay of overestimation by the larger \(k_{}\).

Constant Regret in the Entire MDPWe may expect constant regret in the entire \(M_{}\) in some special cases. Note that, if \( h[H], s_{h}\) with \(d^{*}_{}(s_{h})>0\), \(s_{h}^{}_{h}\), we have \(^{}_{h}=_{h}_{h}\), \(_{K}(M_{})\) will be independent w.r.t. \(K\). From this perspective, if \(\) is chosen appropriately, e.g. \(_{s_{h}}d^{*}_{}(s_{h})\), we can recover the constant regret under the setting \(M_{}=M_{}\) in .

Choice of \(\)In this paper, we do not treat \(\) as a parameter to optimize. In practice, without prior knowledge about \(_{s_{h}}d^{*}_{}(s_{h})\), one may choose \(=O(1/S)\) to ensure some chance that transferable states exist, since there exists at least some states satisfying \(d^{*}_{}(s_{h}) 1/S\).

## 5 Robust Tiered MAB/RL with Multiple Low-Tier Tasks

Now, we focus on the case when a source task set \(_{}:=\{M_{,w}\}_{w=1}^{W}\) is available (see Frw. 5 in Appx. A). Our objective is to achieve benefits on those states \(s_{h}\) as long as there exists some task \(w[W]\) such that \(M_{,w}\) and \(M_{}\) are close on \(s_{h}\), while retaining near-optimal regret in other cases under Assump. B. The key challenge comparing with single task case is that, Alg\({}^{}\) has to identify for each state which task in \(_{}\) is the appropriate one to leverage. The main novelty and contribution in this section is a task selection mechanism we call _"Trust till Failure"_, which can automatically adapt to the similar task if it exists. We first highlight the main results for MAB and RL setting.

**Theorem 5.1**.: _[Tiered MAB with Multiple Source Tasks] Under Assump. A, B, and C, by running Alg. 3 with \(_{}=\{M_{,w}\}_{w=1}^{W}\) and \(M_{}\), with \(=}{4}\) and \(>2\), we always have: \(_{K}(M_{})=O(_{_{}(i)>0}}(i)}(WK))\). Moreover, if at least one task in \(_{}\) is \(_{}}{4}\), close to \(M_{}\), we further have: \(_{K}(M_{})=O(_{_{}(i)>0}}(i)}})\)._

**Theorem 5.2**.: _[Tiered RL with Multiple Source Tasks] Under Assump. A, B, C, and Cond. D.3, F.4, by running Alg. 7 in Appx. F.1 with \(=_{}}{4(H+1)}\), \(>2\) and any \(>0\), we have_

\[_{K}(M_{})=OSH_{h=1}^{H}_{(s_{h},a_{h}) _{h}_{h}_{h}^{,[W]} }(}}(s_{h},a_{h})}) (SAHWK).\]

```
1Initialize: \(>2;\ N_{}^{1}(i),\ N_{}^{1}(i),\ _{}^{1}(i),\ _{}^{1}(i) 0,\  i;\,f(k):=1+16TA^{2}(k+1)^{2}\)
2 Pull each arm at the beginning \(A\) iterations. Set \(w^{A}\).
3for\(k=A+1,2,...,K\)do
4for\(w=1,2...,W\)do
5\(_{,w}^{k}(i)_{,w}^{k}(i)+,w}(i)}}\), \(_{,w}^{k}_{i}_{,w}^{k}(i)\), \(_{,w}^{k}_{,w}^{k}\).
6\(_{,w}^{k}(i)_{,w}^{k}(i)-,w}(i)}}\), \(_{,w}^{k}_{i}_{,w}^{k}(i)\).
7 end for
8\(_{}^{k}(i)_{}^{k}(i)+ }^{k}(i)}}\), \(_{}^{k}_{i}_{}^{k}(i)\). \(^{k}\{w[W]_{,w}^{k}(_{,w}^{k})_{}^{k}(_{,w}^{k})+\) and \(N_{,w}^{k}(_{,w}^{k})>k/2\}\)
9if\(^{k}=\)then\(w^{k},_{}^{k} _{}^{k}\) ;
10else
11if\(w^{k-1}\) and \(w^{k-1}^{k}\)then\(w^{k} w^{k-1},_{}^{k}_{,w^{k}}^{k}\) ;
12else if\(w^{k-1}\) and \( w^{k}\) such that \(_{}^{k-1}=_{i}N_{,w}^{k}(i)\)then
13\(w^{k} w,_{}^{k}_{,w}^{k}\)
14 end if
15else\(w^{k}(^{k}),_{}^{k}_{,w^{k}}^{k}\) ;
16
17 end if
18
19 Interact with \(M_{}/\{M_{}\}_{w=1}^{W}\) by \(_{}^{k}/\{_{,w}^{k}\}_{w=1}^{W}\);
20 Update \(\{N_{,w}^{k+1}\}_{w=1}^{W},N_{}^{k+1}\) and empirical mean \(\{_{,w}^{k+1}\}_{w=1}^{W},_{}^{k+1}\) for each arm.
21
2 end for
```

**Algorithm 3**Robust Tiered MAB with Multiple Source Tasks

For the lack of space, in the following, we only analyze the bandit setting to explain the key idea of our task selection strategy. For the RL setting, we defer to Appx. F the algorithm Alg. 7, detailed version of Thm. 5.2 (Thm. D.16), defintion of transferable set \(_{h}^{,[W]}\) (Def. F.2), and technical details.

**Algorithm Design and Proof Sketch for Bandit Setting** The algorithm is provided in Alg. 3. Comparing with Alg. 1 in single task setting, the main difference is the task selection strategy from line 9 to line 17. We first examine each source task with a checking event similar to single task setting, and collect those feasible tasks passing the test to \(^{k}\). Intuitively, for those \(M_{,w^{*}}\) close to \(M_{}\), we expect \(M_{,w}^{k}\) holds almostly for arbitrary \(k>0\), while for the other \(M_{,w^{}}\), if it takes the position of \(w^{k}\), following \(M_{,w^{}}\) will reduce the uncertainty and it will be ruled out from \(^{k}\), eventually. So we expect \(w^{k}\) can "escape" from dissimilar source tasks but be absorbed to the similar task if exists. Therefore, if \(^{k}\) is empty, \(^{}\) will do exploration by itself. Otherwise, we choose one from \(^{k}\) to transfer the action until it fails on the checking event. However, for any \(\) the algorithm chosen, those "marginally similar" source tasks (denoted as \(M_{,}\)), which are \(^{}\)-close to \(M_{}\) for some \(^{}\) only slightly larger than \(\), may cause some trouble. Because the checking event will finally eliminate \(M_{,}\) since they are not \(\)-close, but it may occupy the position \(w^{k}\) for a long time before elimination, especially when \(^{}\) is extremely close to \(\). After eliminating \(M_{,}\), Alg\({}^{i}\) needs to re-select one from \(^{k}\). Now since other sub-optimal arms in \(M_{}\) haven't been chosen for a long time and the confidence level \(_{k}=O(1/k^{})\) is decreasing, \(^{k}\) will include those dissimilar tasks again, which causes difficulty to identify the true similar task. To solve this issue, once the previous trusted task fails, we give priority to the task recommending the same action as the previous one (line 14). As a result, since \(M_{,}\) and \(M_{,w^{*}}\) share the optimal action, after the elimination of \(M_{,}\), we can expect \(w^{k}\) to only switch among those tasks \(M_{,w}\) with \(^{*}_{,w}=^{*}_{}\). We highlight this technical novelty to Lem. 5.3 below, and defer all the proofs to Appx. E.

**Lemma 5.3**.: _[Absorbing to Similar Task] Under Assump. A, B and C, there exists a constant \(c^{*}\), s.t., if there exists at least one \(w^{*}[W]\) such that \(M_{,w^{*}}\) is \(_{}}{4}\)-close to \(M_{}\), by running Alg. 3 with \(=_{}}{4}\) and \(>2\), for any \(k k^{*}:=c^{*}^{}}_{}}\), we have \((^{k}_{} i^{*}_{})=O(})\)._

## 6 Experiments

In this section, we evaluate our most representative algorithm, Alg. 7, in multiple source tasks setting.

**Experiments Setting3** We set \(S=A=3\) and \(H=5\). The details for construction of source and target tasks are defered to Appx. G. We adapt StrongEuler in  as online learning algorithm to solve source tasks, and use the bonus function in  as the bonus function in our Alg. 7. We evaluate our algorithm when \(W=0,1,2,5\), where \(W=0\) means the high-tier task \(M_{}\) is simply solved by normal online learning method (StrongEuler) without any parallel knowledge transfer. We choose \(=0.3 1/S\) in Alg. 7, and in the MDP instance we test, across all \(S H=15\) states, for \(W=1,2,5\), the number of transferable states would be 6, 9 and 13, respectively.

We choose iteration number \(K=1e7\), where we start the transfer since \(k=5e5\) to avoid large "burn-in" terms. As we can see, after the transfer starts, the regret in target task will suddenly increase for a while, because the target task has to make some mistakes and learn from it as a result of the model uncertainty. However, because of our algorithm design, the negative transfer will terminate after a very short period. As predicted by our theory, by adding more and more source tasks which can introduce new transferable states, the target task will suffer less and less regret.

## 7 Conclusion and Future Work

In this paper, we study how to do robust parallel transfer RL when single or multiple source tasks are available, without knowledge on models' similarity. The possible future directions include relaxing assumptions, better strategies to leveraging multiple source tasks, and identifying mild structural assumptions allowing for more aggressive transfer, and we defer to Appx. A.4 for more details.

Figure 1: **Regret in the Target Task given Multiple Source Tasks** We report the result when \(W\) source tasks are available with \(W=0,1,2,5\). The shadows indicate 96% confidence interval.