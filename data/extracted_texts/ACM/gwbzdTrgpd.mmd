# HetGPT: Harnessing the Power of Prompt Tuning in Pre-Trained Heterogeneous Graph Neural Networks

Anonymous Author(s)

###### Abstract.

Graphs have emerged as a natural choice to represent and analyze the intricate patterns and rich information of the Web, enabling applications such as online page classification and social recommendation. The prevailing "_pre-train, fine-tune_" paradigm has been widely adopted in graph machine learning tasks, particularly in scenarios with limited labeled nodes. However, this approach often exhibits a misalignment between the training objectives of pre-text tasks and those of downstream tasks. This gap can result in the "negative transfer" problem, wherein the knowledge gained from pre-training adversely affects performance in the downstream tasks. The surge in prompt-based learning within Natural Language Processing (NLP) suggests the potential of adapting a "_pre-train, prompt_" paradigm to graphs as an alternative. However, existing graph prompting techniques are tailored to homogeneous graphs, neglecting the inherent heterogeneity of Web graphs. To bridge this gap, we propose HetGPT, a general post-training prompting framework to improve the predictive performance of pre-trained heterogeneous graph neural networks (HGNNs). The key is the design of a novel prompting function that integrates a virtual class prompt and a heterogeneous feature prompt, with the aim to reformulate downstream tasks to mirror pretext tasks. Moreover, HetGPT introduces a multi-view neighborhood aggregation mechanism, capturing the complex neighborhood structure in heterogeneous graphs. Extensive experiments on three benchmark datasets demonstrate HetGPT's capability to enhance the performance of state-of-the-art HGNNs on semi-supervised node classification.

## 1. Introduction

The Web, an ever-expanding digital universe, has transformed into an unparalleled data warehouse. Within this intricate web of data, encompassing diverse entities and patterns, graphs have risen as an intuitive representation to encapsulate and examine the Web's multifaceted content, such as academic articles (Bahdanau et al., 2014), social media interactions (Bahdanau et al., 2014), chemical molecules (Bahdanau et al., 2014), and online grocery items (Shen et al., 2015). In light of this, graph neural networks (GNNs) have emerged as the state of the art for graph representation learning, which enables a wide range of web-centric applications such as online page classification (Shen et al., 2016), social recommendation (Bahdanau et al., 2014), pandemic trends forecasting (Shen et al., 2016), and dynamic link prediction (Shen et al., 2016; Wang et al., 2016).

A primary challenge in traditional supervised graph machine learning is its heavy reliance on labeled data. Given the magnitude and complexity of the Web, obtaining annotations can be costly and often results in data of low quality. To address this limitation, the "_pre-train, fine-tune_" paradigm has been widely adopted, where GNNs are initially pre-trained with some self-supervised pretext tasks and are then fine-tuned with labeled data for specific downstream tasks. Yet, this paradigm faces the following challenges:

* (**C1**) Fine-tuning methods often overlook the inherent gap between the training objectives of the pretext and the downstream task. For example, while graph pre-training may utilize binary edge classification to draw topologically proximal node embeddings closer, the core of a downstream node classification task would be to ensure nodes with the same class cluster closely. Such misalignment makes the transferred node embeddings suboptimal for downstream tasks, _i.e._, negative transfer (Wang et al., 2016; Wang et al., 2016). The challenge arises: _how to reformulate the downstream node classification task to better align with the contrastive pretext task?_
* (**C2**) In semi-supervised node classification, there often exists a scarcity of labeled nodes. This limitation can cause fine-tuned networks to highly overfit these sparse (Shen et al., 2016) or potentially imbalanced (Shen et al., 2016) nodes, compromising their ability to generalize to new and unlabeled nodes. The challenge arises: _how to capture and generalize the intricate characteristics of each class in the embedding space to mitigate this overfitting?_
* (**C3**) Given the typically large scale of pre-trained GNNs, the attempt to recalibrate all their parameters during the fine-tuning phase can considerably slow down the rate of training convergence. The challenge arises: _how to introduce only a small number of trainable parameters in the fine-tuning stage while keeping the parameters of the pre-trained network unchanged?_

One potential solution that could partially address these challenges is to adapt the "_pre-train, prompt_" paradigm from natural language processing (NLP) to the graph domain. In NLP, prompt-based learning has effectively generalized pre-trained language models across diverse tasks. For example, a sentiment classification task like "_The WebConf will take place in the scenic city of Singapore in 2024_" can be reframed by appending a specific textual prompt "_1 feel so [MASK] to end. It is highly likely that a language model pre-trained on next word prediction will predict "[MASK]" as "_excited_" instead of "_frustrated_", without necessitating extensive fine-tuning. With this methodology, certain downstream tasks can be seamlessly aligned with the pre-training objectives. While few prior work (Bahdanau et al., 2014; Wang et al., 2016; Wang et al., 2016; Wang et al., 2016) has delayed into crafting various prompting templates for graphs, their emphasis remains strictly on homogeneous graphs. This narrow focus underscores the last challenge inherent to the heterogeneous graph structures typical of the Web:

* (**C4**) Homogeneous graph prompting techniques typically rely on the pre-trained node embeddings of the target node or the aggregation of its immediate neighbors' embeddings for downstream node classification, which ignores the intricate neighborhood structure inherent to heterogeneous graphs. The challenge arises: _how to leverage the complex heterogeneous neighborhood structure of a node to yield more reliable classification decisions?_

To comprehensively address all four aforementioned challenges, we propose HetGPT, a general post-training prompting framework tailored for heterogeneous graphs. Represented by the acronymHeterogeneous Graph Prompt Tuning, HetGPT serves as an auxiliary system for HGNNs that have undergone constrastive pre-training. At the core of HetGPT is a novel _graph prompting function_ that reformulates the downstream node classification task to align closely with the pretext contrastive task. We begin with the the _virtual class prompt_, which generalizes the intricate characteristics of each class in the embedding space. Then we introduce the _heterogeneous feature prompt_, which acts as a task-specific augmentation to the input graph. This prompt is injected into the feature space and the prompted node features are then passed through the pre-trained HGNN, with all parameters in a frozen state. Furthermore, a _multi-view neighborhood aggregation_ mechanism, that encapsulates the complexities of the heterogeneous neighborhood structure, is applied to the target node, generating a node token for classification. Finally, Pairwise similarity comparisons are performed between the node token and the class tokens derived from the virtual class prompt via the contrastive learning objectives established during pre-training, which effectively simulates the process of deriving a classification decision. In summary, our main contributions include:
* To the best of our knowledge, this is the first attempt to adapt the "_pre-train_, _prompt_" paradigm to heterogeneous graphs.
* We propose HetGPT, a general post-training prompting framework tailored for heterogeneous graphs. By coherently integrating a virtual class prompt, a heterogeneous feature prompt, and a multi-view neighborhood aggregation mechanism, it elegantly bridges the objective gap between pre-training and downstream tasks on heterogeneous graphs.
* Extensive experiments on three benchmark datasets demonstrate HetGPT's capability to enhance the performance of state-of-the-art HGNNs on semi-supervised node classification.

## 2. Related Work

**Heterogeneous graph neural networks.** Recently, there has been a surge in the development of heterogeneous graph neural networks (HGNNs) designed to learn node representations on heterogeneous graphs (Gardner et al., 2017; Wang et al., 2018; Wang et al., 2019). For example, HAN (Wang et al., 2019) introduces hierarchical attention to learn the node-level and semantic-level structures. MAGNN (Chen et al., 2019) incorporates intermediate nodes along metapaths to encapsulate the rich semantic information inherent in heterogeneous graphs. HetGNN (Wang et al., 2019) employs random walk to sample node neighbors and utilizes LSTM to fuse heterogeneous features. HGT (Han et al., 2019) adopts a transformer-based architecture tailored for web-scale heterogeneous graphs. However, a shared challenge across these models is their dependency on high-quality labeled data for training. In real-world scenarios, obtaining such labeled data can be resource-intensive and sometimes impractical. This has triggered numerous studies to explore pre-training techniques for heterogeneous graphs as an alternative to traditional supervised learning.

**Heterogeneous graph pre-training.** Pre-training techniques have gained significant attention in heterogeneous graph machine learning, especially under the scenario with limited labeled nodes (Gardner et al., 2017; Wang et al., 2019). Heterogeneous graphs, with their complex types of nodes and edges, require specialized pre-training strategies. These can be broadly categorized into generative and contrastive methods. Generative learning in heterogeneous graphs primarily focuses on reconstructing masked segments of the input graph, either in terms of the underlying graph structures or specific node attributes (Chen et al., 2019; Wang et al., 2019; Wang et al., 2019). On the other hand, contrastive learning on heterogeneous graphs aims to refine node representations by magnifying the mutual information of positive pairs while diminishing that of negative pairs. Specifically, representations generated from the same data instance form a positive pair, while those from different instances constitute a negative pair. Some methods emphasizes contrasting node-level representations (Gardner et al., 2017; Wang et al., 2019; Wang et al., 2019; Wang et al., 2019), while another direction contrasts node-level representations with graph-level representations (Gardner et al., 2017; Wang et al., 2019; Wang et al., 2019). In general, the efficacy of contrastive methods surpasses that of generative ones (Wang et al., 2019), making them the default pre-training strategies adopted in this paper.

**Prompt-based learning on graphs.** The recent trend in Natural Language Processing (NLP) has seen a shift from traditional fine-tuning of pre-trained language models (LMs) to a new paradigm: "_pre-train_, _prompt_" (Chen et al., 2019). Instead of fine-tuning LMs through task-specific objective functions, this paradigm reformulates downstream tasks to resemble pre-training tasks by incorporating textual prompts to input texts. This not only bridges the gap between pre-training and downstream tasks but also instigates further research integrating prompting with pre-trained graph neural networks (Wang et al., 2019). For example, GPPT (Wang et al., 2019) and GraphPrompt (Gardner et al., 2017) introduce prompt templates to align the pretext task of link prediction with downstream classification. GPF (Chen et al., 2019) and VNT-GPPE (Wang et al., 2019) employ learnable perturbations to the input graph, modulating pre-trained node representations for downstream tasks. However, all these techniques cater exclusively to homogeneous graphs, overlooking the distinct complexities inherent to the heterogeneity in real-world systems.

## 3. Preliminaries

**Definition 1: Heterogeneous graph.** A heterogeneous graph is defined as \(=(,)\), where \(\) is the set of nodes and \(\) is the set of edges. It is associated with a node type mapping function \(:\) and an edge type mapping function \(:\). \(\) and \(\) denote the node type set and edge type set, respectively. For heterogeneous graphs, we require \(||+||>2\). Let \(=\{_{A} A\}\) be the set of all node feature matrices for different node types. Specifically, \(X_{A}^{|_{A}|_{A}}\) is the feature matrix where each row corresponds to a feature vector \(_{A}^{}\) of node \(i\) of type \(A\). All nodes of type \(A\) share the same feature dimension \(d_{A}\), and nodes of different types can have different feature dimensions.

Figure 1(a) illustrates an example heterogeneous graph with three types of nodes: author (A), paper (P), and subject (S), as well as two types of edges: "write" and "belong to".

**Definition 2: Network schema.** The network schema is defined as \(=(,)\), which can be seen as a meta template for a heterogeneous graph \(\). Specifically, network schema is a graph defined over the set of node types \(\), with edges representing relations from the set of edge types \(\).

Figure 1(b) presents the network schema for a heterogeneous graph. As per the network schema, we learn that a paper is written by an author and that a paper belongs to a subject.

**Definition 3: Metapath.** A metapath \(P\) is a path defined by a pattern of node and edge types, denoted as \(A_{1}}A_{2}}}A_{ }\) (abbreviated as \(A_{1}A_{2} A_{}\)), where \(A_{i}\) and \(R_{i}\).

Figure 1(c) shows two metapaths for a heterogeneous graph: "PAP" represents that two papers are written by the same author, while "PSP" indicates that two papers share the same subject.

**Definition 4: Semi-supervised node classification.** Given a heterogeneous graph \(=\{,\}\) with node features \(\), we aim to predict the labels of the target node set \(_{T}\) of type \(T\). Each target node \(v_{T}\) corresponds to a class label \(v_{e}\). Under the semi-supervised learning setting, while the node labels in the labeled set \(_{L}_{T}\) are provided, our objective is to predict the labels for nodes in the unlabeled set \(_{U}=_{T}_{L}\).

**Definition 5: Pre-train, fine-tune.** We introduce the "_pre-train, fine-tune_" paradigm for heterogeneous graphs. During the pre-training stage, an encoder \(f_{}\) parameterized by \(\) maps each node \(v\) to a low-dimensional representation \(_{v}^{d}\). Typically, \(f_{}\) is an HGN that takes a heterogeneous graph \(=\{,\}\) and its node features \(\) as inputs. For each target node \(v_{T}\), we construct its positive \(_{v}\) and negative sample sets \(_{v}\) for contrastive learning. The contrastive head \(g_{}\), parameterized by \(\), discriminates the representations between positive and negative pairs. The pre-training objective can be formulated as:

\[^{*},^{*}=*{arg\,min}_{,}_{ conq}(g_{},f_{},_{T},,), \]

where \(_{con}\) denotes the contrastive loss. Both \(=\{_{v} v_{T}\}\) and \(=\{_{v} v_{T}\}\) can be nodes or graphs. They may be direct augmentations or distinct views of the corresponding data instances, contingent on the contrastive learning techniques employed.

In the fine-tuning stage, a prediction head \(h_{}\), parameterized by \(\), is employed to optimize the learned representations for the downstream node classification task. Given a set of labeled target nodes \(_{L}\) and their corresponding label set \(\), the fine-tuning objective can be formulated as:

\[^{**},^{*}=*{arg\,min}_{,}_{ sup}(h_{},f_{^{*}},_{L},), \]

where \(_{sup}\) is the supervised loss. Notably, the parameters \(\) are initialized with those obtained from the pre-training stage, \(^{*}\).

## 4. Method

In this section, we introduce HetGPT, a novel graph prompting technique specifically designed for heterogeneous graphs, to address the four challenges outlined in Section 1. In particular, HetGPT consists of the following key components: (1) _prompting function design_; (2) _virtual class prompt_; (3) _heterogeneous feature prompt_; (4) _multi-view neighborhood aggregation_; (5) _prompt-based learning and inference_. The overall framework of HetGPT is shown in Figure 2.

### Prompting Function Design (C1)

Traditional fine-tuning approaches typically append an additional prediction head and a supervised loss for downstream tasks, as depicted in Equation 2. In contrast, HetGPT pivots towards leveraging and tuning prompts specifically designed for node classification.

In prompt-based learning for NLP, a prompting function employs a pre-defined template to modify the textual input, ensuring its alignment with the input format used during pre-training. Meanwhile, within graph-based pre-training, contrastive learning has overshadowed generative learning, especially in heterogeneous graphs (Han et al., 2018; Wang et al., 2019; Wang et al., 2019), as it offers broader applicability and harnesses overlapping task subspaces, which are optimal for knowledge transfer. Therefore, these findings motivate us to reformulate the downstream node classification task to align with contrastive approaches. Subsequently, a good design of graph prompting function becomes pivotal in matching these contrastive pre-training strategies.

Central to graph contrastive learning is the endeavor to maximize mutual information between node-node or node-graph pairs. In light of this, we propose a graph prompting function, denoted as \(l()\). This function transforms an input node \(v\) into a pairwise template that encompasses a node token \(_{v}\) and a class token \(_{c}\):

\[l(v)=[_{v},_{c}]. \]

Within the framework, \(_{c}\) represents a trainable embedding for class \(c\) in the downstream node classification task, as explained in Section 4.2. Concurrently, \(_{v}\) denotes the latent representation of node \(v\), derived from the pre-trained HGNN, which will be further discussed in Section 4.3 and Section 4.4.

### Virtual Class Prompt (C2)

Instead of relying solely on direct class labels, we propose the concept of a virtual class prompt, a paradigm shift from traditional node classification. Serving as a dynamic proxy for each class, the prompt bridges the gap between the abstract representation of nodes and the concrete class labels they are affiliated with. By leveraging the virtual class prompt, we aim to reformulate downstream node classification as a series of mutual information calculation tasks, thereby refining the granularity and adaptability of the classification predictions. This section delves into the design and intricacies of the virtual class prompt, illustrating how it can be seamlessly integrated into the broader contrastive pre-training framework.

#### 4.2.1. Class tokens.

We introduce class tokens, the building blocks of the virtual class prompt, which serve as representative symbols for each specific class. Distinct from discrete class labels, these tokens can capture intricate class-specific semantics, providing a richer context for node classification. We formally define the set of class tokens, denoted as \(\), as follows:

\[=\{_{1},_{2},,_{C}\}, \]

Figure 1. A example of a heterogeneous graph.

where \(C\) is the total number of classes in \(\). Each token \(_{c}^{d}\) is a trainable vector and shares the same embedding dimension \(d\) with the node representations from the pre-trained network \(f_{^{*}}\).

#### 4.2.2. Prompt initialization

Effective initialization of class tokens facilitates a smooth knowledge transfer from pre-trained heterogeneous graphs to the downstream node classification. We initialize each class token, \(_{c}\), by computing the mean of embeddings for labeled nodes that belong to the respective class. Formally,

\[_{c}=}_{_{b}\\ _{c}=c}_{}, c\{1,2,,C\}, \]

where \(N_{c}\) denotes the number of nodes with class \(c\) in the labeled set \(_{L}\), and \(_{}\) represents the pre-trained embedding of node \(v\). This initialization aligns each class token with the prevalent patterns of its respective class, enabling efficient prompt tuning afterward.

### Heterogeneous Feature Prompt (C3)

Inspired by recent progress with visual prompts in the vision domain (Bengio et al., 2017; Chen et al., 2017), we propose a heterogeneous feature prompt. This approach incorporates a small amount of trainable parameters directly into the feature space of the heterogeneous graph \(\). Throughout the training phase of the downstream task, the parameters of the pre-trained network \(f_{^{*}}\) remain unchanged. The key insight behind this feature prompt lies in its ability to act as task-specific augmentations to the original graph. It implicitly taifors the pre-trained node representations for an effective and efficient transfer of the learned knowledge from pre-training to the downstream task.

Prompting techniques fundamentally revolve around the idea of augmenting the input data to better align with the pretext objectives. This makes the design of a graph-level transformation an important factor for the efficacy of prompting. To illustrate, let's consider a homogeneous graph \(\) with its adjacency matrix \(\) and node feature matrix \(\). We introduce \(t_{}\), a graph-level transformation function parameterized by \(\), such as changing node features, adding or removing edges, _etc._ Prior research (Chen et al., 2017; Wang et al., 2017) has proved that for any transformation function \(t_{}\), there always exists a corresponding feature prompt \(^{*}\) that satisfies the following property:

\[f_{^{*}}(,+^{*}) f_{^{*}}(t_{}( ,))+O_{}, \]

where \(O_{}\) represents the deviation between the node representations from the graph that's augmented by \(t_{}\) and the graph that's prompted by \(^{*}\). This discrepancy is primarily contingent on the quality of the learned prompt \(^{*}\) as the parameters \(^{*}\) of the pre-trained model are fixed. This perspective further implies the feasibility and significance of crafting an effective feature prompt within the graph's input space, which emulates the impact of learning a specialized augmentation function tailored for downstream tasks.

However, in heterogeneous graphs, nodes exhibit diverse attributes based on their types, and each type has unique dimensionalities and underlying semantic meanings. Take a citation network for instance: while paper nodes have features represented by word embeddings derived from their abstracts, author nodes utilize one-hot encoding as features. Given this heterogeneity, the approach used in homogeneous graph prompting methods may not be effective or yield optimal results when applied to heterogeneous graphs, as it uniformly augments node features for all node types via a single and all-encompassing feature prompt.

Figure 2. Overview of the HetGPT architecture: Initially, an HCNN is pre-trained alongside a contrastive head using a contrastive learning objective, after which their parameters are frozen. Following this, a _heterogeneous feature prompt_ (Sec. 4.3) is injected into the input graphâ€™s feature space. These prompted node features are then processed by the pre-trained HCNN, producing the prompted node embeddings. Next, a _multi-view neighborhood aggregation_ mechanism (Sec. 4.4) captures both local and global heterogeneous neighborhood information of the target node, generating a node token. Finally, pairwise similarity comparisons are performed between this node token and class tokens derived from the _virtual class prompt_ (Sec. 4.2) via the same contrastive learning objective from pre-training. _As an illustrative example of employing HetGPT for node classification: consider a target node \(P_{2}\) associated with class 1, its positive samples during prompt tuning are constructed using the class token of class 1, while negative samples are drawn from class tokens of classes 2 and 3 (_i.e.,_ all remaining classes).

#### 4.3.1. Type-specific feature tokens

To address the above challenge, we introduce type-specific feature tokens, which are a set of designated tokens that align with the diverse input features inherent to each node type. Given the diversity in scales and structures across various graphs, equating the number of feature tokens to the node count is often sub-optimal. This inefficiency is especially obvious in large-scale graphs, as this design demands extensive storage due to its \(O(||)\) learnable parameters. In light of this, for each node type, we employ a feature prompt consisting of a limited set of independent basis vectors of size \(K\), _i.e._, \(f_{K}^{A}^{d_{A}}\), with \(d_{A}\) as the feature dimension associated with node type \(A\):

\[=\{_{A} A\}, _{A}=\{f_{1}^{A},f_{2}^{A},,f_{K}^{A}\}, \]

where \(K\) is a hyperparameter and its value can be adjusted based on the specific dataset in use.

#### 4.3.2. Prompted node features

For each node \(i\) of type \(A\), its node feature vector \(_{i}^{A}\) is augmented by a linear combination of feature token \(f_{k}^{A}\) through an attention mechanism, where the attention weights are denoted by \(_{i,k}^{A}\). Consequently, the prompted node feature vector evolves as:

\[}_{i}^{A}=_{i}^{A}+_{k=1}^{K}_{i,k}^ {A} f_{k}^{A}, \]

\[_{i,k}^{A}=^{A})^{} _{i}^{A}))}{_{j=1}^{K}(((f_{j}^ {A})^{}_{i}^{A}))}, \]

where \(()\) represents a non-linear activation function. Subsequently, we utilize these prompted node features, represented as \(}\), together with the heterogeneous graph, \(\). They are then passed through the pre-trained HGNN \(f_{0}\)- during the prompt tuning phase to obtain a prompted node embedding matrix \(}\):

\[}=f_{0}(,})^{| | d}. \]

### Multi-View Neighborhood Aggregation (C4)

In prompt-based learning for homogeneous graphs, the node token \(_{0}\) in Equation 3 for a given node \(v\) is directly equated to \(_{v}\), which is the embedding generated by the pre-trained network \(f_{0}\)(Han et al., 2017). Alternatively, it can also be derived from an aggregation of the embeddings of its immediate neighboring nodes (Han et al., 2017). However, in heterogeneous graphs, such aggregations are complicated due to the inherent heterogeneity of neighboring structures. For example, given a target node with the type "paper", connections can be established either with other "paper" nodes through different metapaths (_e.g._, PAP, PSP) or with nodes of varied types (_i.e._, author or subject) based on the network schema. Furthermore, it is also vital to leverage the prompted pre-trained node embeddings \(}\) (as detailed in Section 4.3) in the aggregation. Taking all these into consideration, we introduce a multi-view neighborhood aggregation mechanism. This strategy incorporates both type-based and metapath-based neighbors, ensuring a comprehensive representation that captures both local (_i.e._, network schema) and global (_i.e._, metapath) patterns.

#### 4.4.1. Type-based aggregation

Based on the network schema outlined in Definition 2, a target node \(i_{T}\) can directly connect to \(M\) different node types \(\{A_{1},A_{2},,A_{M}\}\). Given the variability in contributions from different nodes of the same type to node \(i\) and the diverse influence from various types of neighbors, we utilize a two-level attention mechanism (Han et al., 2017) to aggregate the local information of node \(i\). For the first level, the information \(R_{i}^{A_{m}}\) is fused from the neighbor set \(_{i}^{A_{m}}\) for node \(i\) using node attention:

\[_{i}^{A_{m}}=(_{\{i_{i}^{A_{m}}\{i\}}} a_{i,j}^{A_{m}}}_{j}), \]

\[_{i,j}^{A_{m}}=_{A_{m}}^{} [}_{i}||}_{j}]))}{_{k _{i}^{A_{m}}\{i\}}((_{A_{m}}^{ }[}_{i}||}_{k}]))}, \]

where \(()\) is a non-linear activation function, \(\|\) denotes concatenation, and \(_{A_{m}}^{2d 1}\) is the node attention vector shared across all nodes of type \(A_{m}\). For the second level, the type-based embedding of node \(i\), denoted as \(_{1}^{T}\), is derived by synthesizing all type representations \(\{R_{i}^{A_{i}},_{i}^{A_{2}},,_{i}^{A_{M}}\}\) through semantic attention:

\[_{i}^{T}=_{i=1}^{M}_{A_{m}}_{i}^{A_ {m}},_{A_{m}}=})}{_{k=1}^{M}(w_{A_{k}})}, \] \[w_{A_{m}}=_{T}|}_{i_{T}} _{}^{}(_{}_{i}^{A_ {m}}+_{}), \]

where \(_{}^{d 1}\) is the type-based semantic attention vector shared across all node types, \(_{}^{d d}\) is the weight matrix, and \(_{}^{d 1}\) is the bias vector.

#### 4.4.2. Metapath-based aggregation

In contrast to type-based aggregation, metapath-based aggregation provides a perspective to capture global information of a target node \(i_{T}\). This is attributed to the nature of metapaths, which encompass connections that are at least two hops away. Given a set of defined metapaths \(\{P_{1},P_{2},,P_{N}\}\), the information from neighbors of node \(i\) connected through metapath \(P_{n}\) is aggregated via node attention:

\[_{i}^{P_{n}}=(_{i_{i}^{P_{n}} \{i\}}a_{i,j}^{P_{n}}}_{i}), \]

\[_{i,j}^{P_{n}}=_{P_{n}}^{} [}_{i}||}_{j}]))}{_{k _{i}^{P_{n}}\{i\}}((_{P_{n}}^{} [}_{i}||}_{k}]))}, \]

where \(_{P_{n}}^{2d 1}\) is the node attention vector shared across all nodes connected through metapath \(P_{n}\). To compile the global structural information from various metapaths, we fuse the node embeddings \(\{_{i}^{P_{1}},_{i}^{P_{2}},,_{i}^{P_{N}}\}\) derived from each metapath into a single embedding using semantic attention:

\[_{i}^{}=_{i=1}^{N}_{P_{n}}_{i}^{P_{n}}, _{P_{n}}=})}{_{k=1}^{N}(w_{P_{k}})}, \] \[w_{P_{n}}=_{T}|}_{i_{T}} _{}^{}(_{}_{i}^{P_{n}}+ _{}), \]

where \(_{}^{d 1}\) is the metapath-based semantic- attention vector shared across all metapaths, \(_{}^{d d}\) is the weight matrix,and \(b_{}^{d 1}\) is the bias vector. Integrating the information from both aggregation views, we obtain the final node token, \(z_{i}\), by concatenating the type-based and the metapath-based embedding:

\[z_{i}=(W[z_{i}^{}|z_{i}^{}]+), \]

where \(()\) is a non-linear activation function, \(^{2d d}\) is the weight matrix, and \(^{d 1}\) is the bias vector.

### Prompt-Based Learning and Inference

Building upon our prompt design detailed in the preceding sections, we present a comprehensive overview of the prompt-based learning and inference process for semi-supervised node classification. This methodology encompasses three primary stages: (1) _prompt addition_, (2) _prompt tuning_, and (3) _prompt-assisted prediction_.

#### 4.5.1. Prompt addition

Based on the graph prompting function \(l()\) outlined in Equation (3), we parameterize it using the trainable virtual class prompt \(\) and the heterogeneous feature prompt \(\). To ensure compatibility during the contrastive loss calculation, which we detail later, we use a single-layer Multilayer Perceptron (MLP) to project both \(z_{}\) and \(_{c}\), onto the same embedding space. Formally:

\[z_{o}^{}=(z_{o}),_{c}^{}=( _{c}), l_{Q,}(v)=[z_{o}^{},_{c}^{}]. \]

#### 4.5.2. Prompt tuning

Our prompt design allows us to reuse the contrastive head from Equation 1 for downstream node classification without introducing a new prediction head. Thus, the original positive \(_{o}\) and negative samples \(_{o}\) of a labeled node \(v_{}\) used during pre-training are replaced with the virtual class prompt corresponding to its given class label \(y_{o}\).

\[_{o}=\{_{y_{o}}\},_{o}= \{_{y_{o}}\}, \]

Consistent with the contrastive pre-training phase, we employ the InfoNCE (Zhou et al., 2017) loss to replace the supervised classification loss \(_{sup}\):

\[_{}=-_{v_{}}((z_{o}^{},_{y_{o}}^{})/)}{_{c=1}^{C} ((z_{o}^{},_{c}^{})/)}). \]

Here, \(()\) denotes a similarity function between two vectors, and \(\) denotes a temperature hyperparameter. To obtain the optimal prompts, we utilize the following prompt tuning objective:

\[^{*},^{*}=*{arg\,min}_{,} _{}(g_{(^{*},f_{},l_{Q, },_{})+_{}}. \]

where \(\) is a regularization hyperparameter. The orthogonal regularization (Bishop, 2006) loss \(_{orth}\) is defined to ensure the label tokens in the virtual class prompt remain orthogonal during prompt tuning, fostering diversified representations of different classes:

\[_{orth}=\|^{}-\|_{F}^{2}, \]

where \(=[_{1},_{2},,_{C}]^{}^{C d}\) is the matrix form of the virtual class prompt \(\), and \(^{C C}\) is an identity matrix.

#### 4.5.3. Prompt-assisted prediction

During the inference phase, for an unlabeled target node \(v_{U}\), the predicted probability of node \(v\) belonging to class \(c\) is given by:

\[P(y_{v}=c)=(z_{o}^{},q_{c}^{}))}{_{k=1}^ {C}((z_{o}^{},_{k}^{}))}. \]

This equation computes the similarity between the projected node token \(_{o}^{}\) and each projected class token \(_{c}^{}\), using the softmax function to obtain class probabilities. The class with the maximum likelihood for node \(v\) is designated as the predicted class \(_{o}\):

\[_{o}=*{arg\,max}_{c}P(y_{v}=c), \]

## 5. Experiments

In this section, we conduct a thorough evaluation of our proposed HetGPT to address the following research questions:

* (**RQ1**) Can HetGPT improve the performance of pre-trained heterogeneous graph neural networks on the semi-supervised node classification task?
* (**RQ2**) How does HetGPT perform under different settings, _i.e._, ablated models and hyperparameters?
* (**RQ3**) How does the prompt tuning efficiency of HetGPT compare to its fine-tuning counterpart?
* (**RQ4**) How interpretable is the learned prompt in HetGPT?

### Experiment Settings

#### 5.1.1. Datasets

We evaluate our methods using three benchmark datasets: ACM (Yang et al., 2017), DBLP (Chen et al., 2019), and IMDB (Chen et al., 2019). Detailed statistics and descriptions of these datasets can be found in Table 1. For the semi-supervised node classification task, we randomly select 1, 5, 20, 40, or 60 labeled nodes per class as our training set. Additionally, we set aside 1,000 nodes for validation and another 1,000 nodes for testing. Our evaluation metrics include Macro-F1 and Micro-F1.

#### 5.1.2. Baseline models

We compare our approach against methods belonging to three different categories:

* **Supervised HGNNs:** HAN (Yang et al., 2017), HGT (Huang et al., 2017), MAGNN (Chen et al., 2019);
* **HGNNs with "_pre-train, fine-tune_":*
* **Generative**:**: HGMAE (Yang et al., 2017);
* **Contrastive (our focus):** DMGI (Zhou et al., 2017),HeCo (Yang et al., 2017),HDM (Huang et al., 2017);
* **GNNs with"_pre-train, prompt_":** GPPT (Chen et al., 2019).

#### 5.1.3. Implementation details

For the homogeneous method GPPT, we evaluate using all the metapaths and present the results with the best performance. Regarding the parameters of other baselines, we adhere to the configuration specified in their original papers.

In our HetGPT model, the heterogeneous feature prompt is initialized using Kaiming initialization (Kaiming, 1999). During the prompt tuning phase, we employ the Adam optimizer (Kingma and Ba, 2014) and search within a

  
**Dataset** & **\# Nodes** & **\# Edges** & **Metapaths** & **\# Classes** \\   & Paper: 4.019 &  &  &  \\  & Author: 7.167 & & & P-A: 4,019 & \\    & Subject: 6.0 & & & \\   & Author: 4.057 &  &  &  \\  & Paper: 14.328 & & P-T: 85,810 & \\  & Term: 7,723 & & P-C: 14,328 & \\   & Conference: 20 & & \\   & Movie: 4.278 &  &  &  &  \\  & Director: 2.081 & & M-A: 12,828 & \\   & Actor: 5,257 & & & \\   

Table 1. Detailed statistics of the benchmark datasets. Underlined node types are the target nodes for classification.

[MISSING_PAGE_FAIL:7]

as the most pivotal component, indicated by the significant performance drop when it's absent. This degradation mainly stems from the overfitting issue linked to the negative transfer problem, especially when labeled nodes are sparse. The virtual class prompt directly addresses this issue by generalizing the intricate characteristics of each class within the embedding space.

#### 5.3.2. Hyper-parameter sensitivity

We evaluate the sensitivity of HetGPT to its primary hyperparameter: the number of basis feature tokens \(K\) in Equation (7). As depicted in Figure 4, even a really small value of \(K\) (_i.e._, 5 for ACM, 20 for DBLP, and 5 for IMDB) can lead to satisfactory node classification performance. This suggests that the prompt tuning effectively optimizes performance without the need to introduce an extensive number of new parameters.

### Prompt Tuning Efficiency Analysis (RQ3)

Our HetGPT, encompassing the virtual class prompt and the heterogeneous feature prompt, adds only a few new trainable parameters (_i.e._, comparable to a shallow MLP). Concurrently, the parameters of the pre-trained HGNNs and the contrastive head remain unchanged during the entire prompt tuning phase. Figure 5 illustrates that HetGPT converges notably faster than its traditional "_pre-train_, _fine-tune_" counterpart, both recalibrating the parameters of the pre-trained HGNNs and introducing a new prediction head. This further demonstrates the efficiency benefits of our proposed framework, allowing for effective training with minimal tuning iterations.

### Interpretability Analysis (RQ4)

To gain a clear understanding of how the design of the virtual class prompt facilitates effective node classification without relying on the traditional classification paradigm, we employ a t-SNE plot to visualize the node representations and the learned virtual class prompt on ACM and DBLP, as shown in Figure 6. Within this visualization, nodes are depicted as colored circles, while the class tokens from the learned virtual class prompt are denoted by colored stars. Each color represents a unique class label. Notably, the embeddings of these class tokens are positioned in close vicinity to clusters of node embeddings sharing the same class label. This immediate spatial proximity between a node and its respective class token validates the efficacy of similarity measures inherited from the contrastive pretext for the downstream node classification task. This observation further reinforces the rationale behind our node classification approach using the virtual class prompt, _i.e._, a node is labeled as the class that its embedding is most closely aligned with.

## 6. Conclusion

In this paper, we propose HetGPT, a general post-training prompting framework to improve the node classification performance of pre-trained heterogeneous graph neural networks. Recognizing the prevalent issue of misalignment between the objectives of pretext and downstream tasks, we craft a novel prompting function that integrates a virtual class prompt and a heterogeneous feature prompt. Furthermore, our framework incorporates a multi-view neighborhood aggregation mechanism to capture the complex neighborhood structure in heterogeneous graphs. Extensive experiments on three benchmark datasets demonstrate the effectiveness of HetGPT. For future work, we are interested in exploring the potential of prompting methods in tackling the class-imbalance problem on graphs or broadening the applicability of our framework to diverse graph tasks, such as link prediction and graph classification.

Figure 4. Performance of HetGPT with the different number of basis feature vectors on ACM, DBLP, and IMDB.

Figure 5. Comparison of training losses over epochs between HetGPT and its fine-tuning counterpart on DBLP and IMDB.

Figure 3. Ablation study of HetGPT on ACM and IMDB.

Figure 6. Visualization of the learned node tokens and class tokens in virtual class prompt on ACM and DBLP.