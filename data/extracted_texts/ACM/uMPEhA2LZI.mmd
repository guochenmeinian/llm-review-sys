# [MISSING_PAGE_FAIL:1]

[MISSING_PAGE_FAIL:1]

exhibit myopic behavior by not altering or undoing chosen facilities. Empirical results corroborate this observation, indicating that interchange algorithms achieve lower optimality gaps (Kumar et al., 2017), albeit at the expense of increased runtime.

The recent advancement in machine learning, particularly deep learning, offers an alternative perspective on solving these classical problems. Compared to general-purpose constraint programming solvers, the strong expressiveness and rapid inference capabilities of neural networks make them powerful tools for tackling complex combinatorial optimization problems (Bach et al., 2016). This is particularly advantageous in times of emergency that demand real-time responses to large-scale problems. However, previous works in this field predominantly follow the constructive approach of creating solutions (Kumar et al., 2017; Kundu et al., 2017; Kundu et al., 2018; Kundu et al., 2019). Moreover, previous studies are limited to a simplified geometrical setting without considering graph structures. In many scenarios, such as urban planning and network routing, graph distances can portray actual traveling costs more accurately than straight-line distance (Kundu et al., 2019).

To address these limitations, we propose a highly scalable swap-based approach to solve facility location problems in combination with reinforcement learning. Our model demonstrates a keen awareness of the complex graph structures of the instances and the solving states, enabling it to make improvement decisions effectively and efficiently. Experiments reveal that our improving-style method demonstrates stronger generalizability compared to constructive-style peer methods with deep learning.

In conclusion, the main contributions of this paper are as follows:

* Unified approach: We introduce a unified algorithm capable of simultaneously solving two FLPs, i.e. the relocation problem and the \(p\)-median problem.
* Generalizability: The novel improving-style algorithm showcases superior generalizability across varying graph sizes and facility numbers. It has more steady performance and is less sensitive to instance parameters.
* Performance and scalability: Our method makes rapid responses to large instances up to thousands of nodes within seconds, yielding high-quality solutions and making significant acceleration to peer methods.
* Complexity handling: Through delicately designed features, our model can handle FLPs with complex structures and graph distances.

## 2. Related Work

We consider facility location problems in discrete solution spaces, categorizing them as combinatorial optimization (CO) problems. The survey (Bach et al., 2016) provides a comprehensive review of the intersection of machine learning and combinatorial optimization.

### Machine Learning for Facility Location Problems

Several works have explored solving PMP with machine learning techniques. Most of these approaches formulate the solution construction scheme as a Markov decision process and build solutions step-by-step. For the \(p\)-median problem, Wang et al. (Wang et al., 2019) first propose to solve the uncapacitated \(p\)-median problem in the Euclidean space with reinforcement learning and graph attention networks. They use the REINFORCE (Wang et al., 2019) algorithm to choose the next facility in the solution. Zhao et al. (Zhao et al., 2019) use DQN (Mnih et al., 2015) to address the capacitated \(p\)-median problem. Matis and Tarabek (Matis and Tarabek, 2018) solve the weighted \(p\)-median problem with reinforcement learning and convolutional neural networks. (Matis and Tarabek, 2018) is a recent work that approaches a line of spatial optimization problems with an encoder-decoder structure called Spoknet. The above formulation has been adapted to other FLPs, including the maximal covering location problem (MCLP) (Zhou et al., 2019), \(p\)-center problem (PC) (Bach et al., 2016), etc. As for FRP, Luo et al. (Luo et al., 2019) address the facility relocation problem with a twofold objective of facility exposure and user convenience. They use a reinforcement learning module as an assistive component to a greedy algorithm that maximizes the single-step reward.

Our work is the first machine learning method that addresses the FLPs from an improving perspective and handles complex graph structures of instances. Our agent exhibits a much higher level

Figure 1. The general pipeline of solving real-world facility locations problems on graphs. Real-world networks are converted into abstract graph representations. The demands of each node and pairwise distances are used to encode the problems as mathematical optimization models. This quantitative representation along with problem constraints is fed into constraint solvers, yielding the final solutions for various FLPs.

 of autonomy compared to (Kumar et al., 2017), as it can choose which facility to relocate and its destination.

### Machine Learning for Solution Improvement

Though most machine learning solutions to CO problems build solutions incrementally, there are some works exploring general improvement-style algorithms in a broader scope. The pioneering work of Chen and Tian (Chen and Tian, 2016) introduces NeuRewriter, a reinforcement learning model that learns region-picking and rewriting-rule policies. This model is applied to expression simplification, job scheduling, and capacitated vehicle routing problems. In Lu et al. (Lu et al., 2017), the focus is on enhancing solutions to the capacitated vehicle routing problem, incorporating perturbation operators for a larger search space. Additionally, Wu et al. (Wu et al., 2017) consider improving heuristics for two routing problems using a compatibility layer computed based on query and key from self-attention layers. Summarizing three intervention points of meta-heuristics, Falkner et al. (Kalmer et al., 2017) design a policy model based on graph neural networks to assist local search, conducting experiments on job shop scheduling and capacitated vehicle routing problems. Garmendia et al. (Garmendia et al., 2017) combine graph neural networks with hill-climbing-based algorithms to improve solutions for preference ranking problem, traveling salesman problem, and the graph partitioning problem. Zhang et al. (Zhang et al., 2018) propose a RL-guided improvement heuristic for solving job-shop scheduling problems. It's noteworthy that most works in this domain primarily focus on routing problems, which are sensitive to the sequential order of nodes, with objective functions solely defined by adjacent nodes in the solution sequence. The different problem structure of FLP introduces more complexity and poses unique challenges.

## 3. Preliminaries and Formulation

In this section, we formally define two typical types of FLPs on undirected weighted graphs.

### P-median Problem

We study the \(p\)-median problem defined on a graph \(G(V,E)\), given coordinates \((x_{i},y_{i})\) and demand \(p_{i}\) for each node \(i V\). The edges \(E\) represent available routes for traveling between nodes, and the traveling costs are determined by the lengths of the shortest paths rather than straight-line distances. Assuming each facility possesses infinite capacity and one node can only accommodate one facility, the objective of PMP on \(G\) is to select a facility set \(F V\) of the predefined size \(p\) to minimize the overall traveling cost. This cost is defined as the weighted sum of costs from nodes to their nearest facilities. Let \(n=|V|\) denote the number of nodes. The traveling cost between nodes is defined by the shortest paths on \(G\), expressed through the distance matrix \(D^{n nX}\), where \(d_{ij}\) signifies the distance between nodes \(i\) and \(j\). The distance matrix can be conveniently computed offline using Dijkstra's algorithm Dijkstra (1995). Formally, the objective function \((F)\) and the optimal facility set \(F^{*}\) are articulated as follows:

\[(F) =_{i V}p_{i}_{j F}d_{ij},F V,|F|=p. \] \[F^{*} =*{arg\,min}_{F}(F). \]

### Facility Relocation Problem

Different from the classical \(p\)-median model, the facility relocation problem considers a dynamic demand changed over time and the facilities should be relocated correspondingly to meet people's needs. For example, in urban areas, the population density may shift due to new residential developments or changes in public transportation routes, leading to varying demands. For a predefined set of facilities \(F_{0} V\) and a limited budget \(k\), we study the improvement achieved by moving at most \(k|F_{0}|\) facilities within \(F_{0}\). This relocation is represented by a pair of sets \((R_{k},I_{k})\). The updated facility set is defined as \(F=F_{0} I_{k} R_{k}\). The fundamental assumptions regarding traveling costs and demands remain consistent with the \(p\)-median model. Formally, the objective of relocation problem \(_{k}(R_{k},I_{k}|F_{0})\) is defined based on (2):

\[_{k}(R_{k},I_{k}|F_{0})=(F_{0} I_{k}  R_{k}), \] \[ R_{k} F_{0},\ I_{k} V F _{0},\ |R_{k}|=|I_{k}| k. \]

We further define the improvement ratio \(Q\) of a relocation set pair as the ratio of decreased cost to original cost before relocation:

\[Q(R_{k},I_{k}|F_{0})=(F_{0})-_{k}(R_{k},I_{k}|F_{0 })}{(F_{0})}. \]

## 4. Methods

We start with a general swap-based framework for solving the facility relocation problem, as shown in Algorithm 1. This framework presents the high-level logic of an improving-style algorithm. Given the set of existing facilities \(F_{0}\) and the maximum number of relocation \(k\), it incrementally builds the relocation set pair with the instructions of the given agent. The agent selects a removed facility \(u_{1}\) and an inserted facility \(u_{2}\) for \(k\) iterations, and the best 

[MISSING_PAGE_FAIL:4]

and the total traveling cost in cell \(_{w P(V_{i})}p_{u}d_{f(r)u}\). The facility features are padded with zero for non-facility nodes. Ablation experiments in Section 5.2 prove that Voronoi cells provide valuable insights into the quality of facility placement and guide the relocation process effectively. For node embedding, the concatenation of the aforementioned features serves as initial node features and is fed into GNH. The initial edge embeddings are the lengths of the edges. Let \(_{i}^{L_{i}}\) denote the node embedding of node \(i\) after the GNN module. Wedefine a global embedding for the graph by \((G)=(_{(1}^{V}(_{i}^{L_{i}}) \|_{_{i=1}^{V}(_{i}^{L_{i}})})\), where \(\|\) stands for vector concatenation. The critic MLP takes \((G)\) as input and yields a scalar to score the current state.

### Attention-based Relocation Pair Selection

The action space for one relocation involves choosing two nodes: the facility to remove \(u_{1}\) and the new facility to insert \(u_{2}\). As the action space is quadratic to the number of nodes \((u_{1},u_{2}) F(V F)\), we break down the target into a two-stage task, i.e. \(P(u_{1},u_{2}|_{})=P(u_{1}|_{})P(u_{2}| _{},u_{1})\), where \(_{}\) denotes the learnable parameters of the actor.

After the GNN module extracts an embedding \(_{i}^{L_{i}}\) for each node \(i\), a global embedding can be expressed by \(}=_{(1}^{V}(_{i} ^{L_{i}})\). Given the global context and node embeddings, subsequent \(L_{2}\) layers of MLPs evaluate the priority of removing node (facility) \(i\) by

\[_{i}^{L_{2}}=(_{i}^{L_{1}}||}), \]

which yields the final probability distribution of removing \(i\):

\[P^{-}(i|_{})=(log{i_{1}(i)}), log{i_{1}(i)}= _{i},&i F\\ -,&i F, \]

where \(\) represents the Softmax function.

Let \(u_{1}\) be the removed node sampled from \(P^{-}\). Next, we consider choosing the new facility \(u_{2}\) given node embeddings and \(u_{1}\). This is implemented by an attention layer

\[_{j}=(_{j}^{L_{1}})=(_{j}^{L_{1}})^ {}((_{}^{L_{1}})), \]

\[P^{+}(j|_{},u_{1})=(log{i_{2}(j)}), logit_{2}(j)= _{j},&j V F\\ -,&j V F. \]

The inserted facility \(u_{2}\) is sampled from \(P^{+}\), completing the relocation pair \((u_{1},u_{2}) F(V F)\).

### From Relocation to Location

One advantage of Algorithm 1 is its versatility, allowing it to solve not only the facility relocation problem but also to extend seamlessly to the \(p\)-median problem. Algorithm 2 demonstrates how Algorithm 1 can be integrated as a subroutine within an interchange framework to address PMP. By introducing a hyper-parameter \(S\) that controls the number of swaps, we can utilize the function SwapRelocate following the initial setup. The best solution obtained over \(T\) trials is then returned as the final solution. Interestingly, employing a greedy agent for SwapRelocate results in the classical exchange algorithm (Spiegel and Schapire, 1996), a well-studied heuristic for solving PMP (Brandt et al., 2015).

## 5. Experiments

Previous works in the field often lack rigorous experimental setups, either not using separate test data (Spiegel and Schapire, 1996) or evaluating models only on small instances (Spiegel and Schapire, 1996), resulting in limited assessments of model performance. In contrast, our evaluation thoroughly assesses the efficiency and effectiveness of our algorithm for solving both FRP and PMP on complex graph data sets. Our model achieves a speedup of more than 2000 times to Gurobi on large instances while providing competitive solutions. Additional experiments show how our improving-style algorithm generalizes better than the constructive paradigm. Furthermore, the experiment on Shanghai road networks showcases how our method readily solves problems in real-world scenarios.

### Solving Facility Relocation Problem on Weighted Graphs

Facility relocation is a useful modeling of problems that requires making limited modifications to an existing plan. For example, the bicycle-sharing system needs timely rebalancing to match users' traveling demands. To simulate the complex urban road networks, we construct a synthetic weighted graph data set based on Gabriel graphs (Gabriel, 1996), a type of planar graph that captures the geometric proximity of nodes. Node coordinates are generated with a bivariate normal distribution in \(^{2}\). The demand for each node is generated randomly with the total demand controlled around 3,000,000.

#### 5.1.1. Baselines

We implement two variants of Algorithm 1, namely Random-swap and Greedy-swap. Random-swap randomly selects relocation pairs and updates the solution if the new objective value is improved, representing the gain of relocation out of pure "luck". Greedy-swap always chooses the optimal swap at each step, selecting the pair that results in the greatest reduction in the objective function among all possible pairs. Furthermore, we compare two state-of-the-art heuristics for solving the facility relocation problem: the BestResponse algorithm from (Gabriel, 1996) based on Nash equilibrium and FR2FP from (Gabriel, 1996). The BestResponse algorithm is adapted to align with our settings (see Appendix for details). The optimal solutions are computed by Gurobi (Gurobi, 2010) by setting MTPGap=0.

#### 5.1.2. Settings

To assess the efficacy and scalability of different methods, we conduct experiments with varying graph sizes, specifically \(n\). We generate 10 graphs of each graph size as our test set and evaluate the performance under various values of \(p\), ranging from 5 to 40. For each instance, a random set of \(p\) nodes is designated as the initial facility set, and the relocation budget is set to \( p/2\). Each undetermined algorithm runs for \(T=20\) iterations and records the best solution. PPO-swap is trained on 1000 graphs of size 100. The average results over \(p\) are reported in Table 1, including improvement ratio \(Q\) (defined in (5)), the optimality gap, and running time. The optimality gap of an improvement ratio \(Q_{1}\) is defined as \(-Q_{1}}{Q_{0}} 100\%\), where \(Q_{0}\) is the optimal improvement ratio. Higher \(Q\)-s and lower gaps are better.

#### 5.1.3. Efficiency and Effectiveness Analysis

Figure 3 visualizes the results in Table 1, with bars representing improvement ratios \(Q\) and lines indicating the running times (in log scale). Greedy-swap is a strong heuristic and generates near-optimal solutions. However, it suffers rapid increases in computational overhead as the instance size and facility number grow, as it must iterate over an action space of size \(p(n-p)\) at each step, which scales quadratically with the instance size. The BestResponse algorithm is also based on greedy strategies and has similar time complexity with slight speedup. The FR2FP algorithm falls in the middle with lower improvement ratios and higher efficiency.

PPO-swap stands out from peer methods with remarkable scalability and generalizability. Even if it was only trained on small instances, PPO-swap yields competitive solutions steadily for various graph sizes. Moreover, it performs fast inference and actions, taking under 0.2 seconds in all cases, with only slightly increasing running time for large instances. PPO-swap achieves a speedup of over 2000 compared to Gurobi when \(n=1000\), stressing its value in making real-time responses in times of emergency. The results of Random-swap, on the other hand, represent how much improvement comes from random swapping decisions, showcasing our model's ability to make wise choices.

### Solving P-Median Problem on Weighted Graphs

This section evaluates the performance of PPO-swap on the \(p\)-median problem, where we choose \(p\) facilities to minimize the global objective. We compare our method against established baselines on graph data sets. The evaluation focuses on solution quality and computational efficiency, highlighting the robustness of PPO-swap across different facility numbers.

#### 5.2.1. Baselines

As described in Section 4.5, three swap-based methods can be transplanted to solve PMP. Random-swap, Greedy-swap (essentially the interchange algorithm [(14)]), and PPO-swap. Additionally, we compare with a heuristic Maranzana [(22)] and a meta-heuristic simulated annealing (SA). We further introduce a variant of PPO-swap, namely PPO-no-vor, by replacing the Voronoi-based facility features introduced in Section 4.3 with zeros. This design of ablation is intended to prove the effectiveness of the features we have devised with domain knowledge. The optimal solution is computed by Gurobi [(15)] by setting MPGap=0.

#### 5.2.2. Settings

The graph data sets replicate those in Section 5.1. Default hyper-parameters are set as follows: iteration number \(T=5\), swap trial \(K=20\), and swap budget \(S=p\). SA runs for 1000 iterations. The average results over \(p\) for different graph sizes are reported in Table 2, including the optimality gap and running time. The optimality gap of an objective \(x\) and optimal objective \(y\) is defined as \( 100\%\). Lower gaps are better.

#### 5.2.3. Efficiency and Effectiveness Analysis

Figure 4 illustrates five algorithms, with bars representing optimality gaps and lines indicating the running times (in log scale). Similarly, Gurobi and Greedy-swap produce high-quality solutions, but their running time grows exponentially with \(n\), becoming intolerable for large

   &  &  &  &  \\   & \(Q\) (\%) & Gap (\%) & Time (s) & \(Q\) (\%) & Gap (\%) & Time (s) & \(Q\) (\%) & Gap (\%) & Time (s) & \(Q\) (\%) & Gap (\%) & Time (s) \\  Gurobi & 51.77 & 0.00 & 0.15 & 51.90 & 0.00 & 0.94 & 63.39 & 0.00 & 12.15 & 70.09 & 0.00 & 128.20 \\ Greedy-swap & 51.26 & 1.09 & 1.67 & 51.37 & 1.15 & 6.50 & 62.76 & 1.83 & 30.08 & 69.60 & 1.80 & 99.52 \\ Random-swap & 25.22 & 72.86 & 0.04 & 25.54 & 68.46 & 0.04 & 31.49 & 100.63 & 0.07 & 36.80 & 125.76 & 0.08 \\ BestResponse & 49.21 & 6.27 & 1.49 & 49.36 & 6.37 & 4.60 & 61.32 & 6.04 & 21.89 & 68.89 & 4.22 & 68.77 \\ FR2FP & 46.53 & 10.87 & 0.11 & 46.18 & 13.22 & 0.24 & 59.54 & 10.77 & 0.86 & 66.78 & 11.21 & 3.42 \\
**PPO-swap** & 47.68 & 8.92 & 0.13 & 48.05 & 8.24 & 0.14 & 60.76 & 7.63 & 0.15 & 67.80 & 7.84 & 0.16 \\  

Table 1. Results of Facility Relocation Problem

Figure 3. FRP results on different scales.

graphs. PPO-swap, on the other hand, excels in generating stable and superior solutions even when faced with instances ten times larger than the training data. Its ability to maintain near-constant running times highlights its superior scalability compared to other heuristics, which often exhibit degraded performance and increased runtime as the problem size grows. The trade-off between solution quality and computational time favors PPO-swap in many cases, making it especially suitable for scenarios like emergency facility selection, where both rapid response and good solutions are crucial. By comparing PPO-no-vor and PPO-swap, we conclude that the Voronoi-based features indeed enhance both performance and stability, validating our model design.

### Generalizability of Improving Algorithms

SpoNet is a latest model proposed by Liang et al. (Liang et al., 2018) that solves FLP with deep learning models in a constructive way. To compare the generalizability of two algorithm paradigms, we align with the PMP experiments in (Liang et al., 2018) and compare the optimality gaps of the two methods.

#### 5.3.1. Settings

Each instance comprises 100 nodes with 2D coordinates uniformly distributed in the range \(^{2}\). Nodes are connected if their distance is within a radius of 0.16. Given that (Liang et al., 2018) exclusively handles unweighted problems, we set the node demands to 1. The number of facilities is fixed at \(p=15\). PPO-swap is trained on 1000 graphs following the same distribution, with 10 new graphs reserved for testing. We use the published model1 from (Liang et al., 2018) for evaluation and denote it as SpoNet_pub. SpoNet_pub samples with a beam search width of 1280, and PPO-swap has the same hyperparameters as outlined in Section 5.2.

#### 5.3.2. Results and Analysis

Figure 5 depicts the optimality gaps observed in SpoNet_pub and PPO-swap across the test data. Notably, while both models are trained with a fixed facility number \(p\). SpoNet's constructive solving approach exhibits a greater dependency on this parameter. Consequently, it struggles to generalize effectively when this parameter changes. In contrast, PPO-swap demonstrates a smoother performance curve, indicating its superior adaptability to varying problem settings, a critical aspect of generalizability inherent in our improving-style algorithm.

### Tackling Graph Complexity

In addressing the complexity of graph-based facility location problems, prior approaches (Liang et al., 2018; Li et al., 2018) rely on simplified graph constructions from 2D coordinates using Euclidean distances, while our method natively supports graph structures as direct input and incorporates non-Euclidean graph metrics. In these graphs, edges represent more complex metrics, such as shortest paths or travel times, reflecting real-world transportation networks with spatial

    &  &  &  &  \\   & Gap (\%) & Time (s) & Gap (\%) & Time (s) & Gap (\%) & Time (s) & Gap (\%) & Time (s) \\  Gurobi & 0.00 & 0.14 & 0.00 & 0.88 & 0.00 & 13.43 & 0.00 & 126.40 & 760 \\ Greedy-swap & 0.07 & 10.04 & 0.09 & 48.69 & 0.10 & 234.92 & 0.11 & 733.11 & 761 \\ Random-swap & 25.94 & 0.33 & 27.41 & 0.39 & 27.62 & 0.60 & 26.97 & 0.84 & 762 \\ SA & 25.66 & 0.13 & 15.21 & 0.16 & 15.33 & 0.24 & 20.68 & 0.37 & 763 \\ Maranzana & 42.71 & 0.52 & 43.83 & 0.97 & 59.24 & 2.54 & 65.03 & 7.52 & 764 \\
**PPO-swap** & 6.36 & 1.33 & 8.35 & 1.38 & 8.87 & 1.40 & 10.16 & 1.53 & 765 \\
**PPO-no-vor** & 10.24 & 1.30 & 13.27 & 1.34 & 12.28 & 1.36 & 14.73 & 1.48 & 766 \\   

Table 2. Results of P-median Problem

Figure 4. PMP results on different scales.

Figure 5. SpoNet_pub vs. PPO-swap on plane graphs.

constraints. We devise the following experiments to demonstrate the non-triviality of this advance.

#### 5.4.1. Settings

To demonstrate our method's effectiveness on complex graphs, we compared it against two variants of SpoNet (Gurboli et al., 2018). The first one is SpoNet_pub as mentioned in Section 5.3, with its Euclidean distance matrix substituted with a pairwise shortest path matrix during inference. The second version SpoNet is trained by using the shortest path matrix as the cost matrix for various values of \(p\) incrementally since it has to be trained with fixed \(p\). We use unweighted graphs for training and testing since SpoNet does not support weighted graphs.

#### 5.4.2. Results and Analysis

As illustrated in Figure 7, SpoNet achieves acceptable gaps when \(p\) is small, but the performance declines as \(p\) increases even with incremental training. For SpoNet_pub, its performance is consistent with the fact that it was trained with fixed \(p=15\). PPO-swap outperforms both versions of SpoNet significantly across different \(p\). This experiment reveals the intrinsic advantage of our model, as it learns a general strategy to swap on complex graph data in spite of changes in instance parameters. This capability allows our method to capture richer graph-based information in applications, particularly when the objective is influenced by travel cost, a key factor in many road network applications.

### Placing Facilities on Urban Road Networks

Besides the experiments on synthetic graphs, we demonstrate how PPO-swap can solve facility location problems in real-world scenarios. We use the road networks and population data of Shanghai to construct a city data set. Specifically, graph nodes consist of aggregated 5000m grids, and edges are connected based on the shape of the road network. For model training, we disturb the original population and generate 1000 sets of node weights. Other settings for inference are identical to Section 5.2.

Figure 6 illustrates the solutions of three methods on the city data set for \(p=20\), where the size of red circles denotes the amount of population and blue crosses are suggested locations to place facilities. Compared to SA, PPO-swap achieves lower costs and places facilities in a more efficient manner. As observed, PPO-swap increases the density of facilities in high-population areas, which reduces average travel distances for the population. Additionally, the spatial distribution of the PPO-swap solution is closer to that of the Gurobi solver, making it a practical and scalable solution for large-scale urban applications, especially for real-time deployment.

## 6. Conclusion

In conclusion, our work provides a novel and robust solution to facility location problems on graphs. We introduce a versatile swap-based framework addressing both the \(p\)-median problem and facility relocation on graphs, achieving a commendable balance between solution quality and running time. Extensive experiments on synthetic and real-world data sets show that it is capable of producing high-quality solutions on large graphs with fast inference.

Our work has certain limitations that warrant consideration for future research. First, there is room for improvement in performance, which could be achieved through the exploration of more intricate model architectures. Second, while our approach demonstrates competitive performance, the computation of node features may require acceleration to ensure that the model remains competitive with heuristics on small instances. Addressing these limitations could further enhance the applicability and efficiency of our approach in real-world settings.

In summary, our work contributes significantly to the field of facility location optimization, providing a robust framework that addresses complex challenges.

Figure 6. PMP solutions of different methods on Shanghai road networks. The gray layer represents the urban road networks. The size of red circles is proportional to the regional population. Blue crosses stands for suggested locations for facilities.

Figure 7. SpoNet vs. PPO-swap on unweighted graphs.