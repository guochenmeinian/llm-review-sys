# Fast and Accurate Fair \(k\)-Center Clustering in Doubling Metrics

Anonymous Author(s)

###### Abstract.

We study the classic \(k\)-center clustering problem under the additional constraint that each cluster should be _fair_. In this setting, each point is marked with one or more _colors_, which can be used to model protected attributes (e.g., gender or ethnicity). A cluster is deemed _fair_ if, for every color, the fraction of its points marked with that color is within some prespecified range. We present a coreset-based approach to fair \(k\)-center clustering for general metric spaces which attains almost the best approximation quality of the current state of the art solutions, while featuring running times which can be orders of magnitude faster for large datasets of low doubling dimension. We devise sequential, streaming and MapReduce implementations of our approach and conduct a thourough experimental analysis to provide evidence of their practicality, scalability, and effectiveness.

**ACM Reference Format:**

Anonymous Author(s). 2023. Fast and Accurate Fair \(k\)-Center Clustering in Doubling Metrics. In _Proceedings of ACM Conference (Conference'17)_. ACM, New York, NY, USA, 11 pages. [https://doi.org/10.1145/nnnmnm.nnnmnm](https://doi.org/10.1145/nnnmnm.nnnmnm)

## 1. Introduction

Clustering, in its many variants, is a fundamental primitive in unsupervised learning and data analysis, aiming at grouping points according to some notion of similarity. In the most common setting, the input to clustering is a set of points \(S\) from a metric space \((M,d)\), where \(d:M M_{0}^{+}\) is a distance function, modeling dissimilarity (Kang and Yang, 2017). A popular variant is \(k\)-clustering, which requires to select a set of \(k\) centers and to build an assignment of each input point to one of the \(k\) centers while minimizing some cost, which is a function of the distances between points and centers. Different cost functions define different clustering objectives to be minimized. This paper focuses on the popular _\(k\)-center clustering_ problem (\(k\)-center problem, for short), which aims at minimizing the maximum distance between a point and its assigned center.

A very natural assignment strategy for \(k\)-center associates each point with its closest center (Kang and Yang, 2017). Imagine, however, that each point is a representation of some features of individuals, and that clustering implies decisions that may impact individual livelihoods. In this scenario, the decisions being made, i.e., the clustering, should not have a _disproportionate_ effect on the people involved. For instance, people from a particular protected group cannot be segregated in a single cluster. This intuition is captured by the notion of _disparate impact_(Kang and Yang, 2017): people in different protected classes should not experience disproportionately different outcomes. Blindly ignoring protected attributes, however, is no solution (Kang and Yang, 2017): correlated features (e.g., height which correlates with biological sex) can leak information about the protected attributes and may influence the clustering, leading to _unfair_ solutions. This suggests that to achieve fairness in the clustering we need to explicitly take into account protected attributes when assigning points to centers.

The study of fair \(k\)-clustering under the disparate impact notion has been initiated by Chierichetti et al. (Chierichetti et al., 2017) and generalized in subsequent works (Chierichetti et al., 2017; Chen et al., 2017; Li et al., 2017). Each point is assigned one or more colors to model the protected attributes, and the clustering has to be built so that in each cluster the fraction of points of each color is within a color-specific range. For instance, if the input set has half blue points and half red points, each cluster could be required to have roughly half blue points and half red points. State of the art approaches to fair clustering with multiple colors are based on Linear Programming, which limits their scalability to large datasets. Coresets are an effective way of dealing with scalability issues for big data analytics (Li et al., 2017). A coreset is a compact representation of a large instance on which computationally demanding (e.g., LP-based) algorithms can be run to efficiently obtain good solutions for the whole instance. For fair clustering in the big data setting, coresets have been recently used in (Chen et al., 2017) to reduce the size of the linear programs, yielding a 2-pass streaming algorithm and a 2-round MapReduce/MPC algorithm, attaining, respectively, \((7+)\) and 9 approximations.

### Our contribution

In this paper, we present an improved coreset-based strategy for fair \(k\)-center clustering of multi-colored points in general metrics, whose accuracy/performance tradeoffs are analyzed in terms of the doubling dimension of the data set. We devise implementations of our strategy in the sequential, streaming and MapReduce/MPC frameworks, yielding the following contributions, where \(S\), \(\), and \(D\) represent, respectively, the input dataset, the set of colors, and the doubling dimension of \(S\).

* A sequential algorithm for fair \(k\)-center which attains a \((3+)\) approximation, and whose running time is linear in (Chen et al., 2017) for constant \(k\), \(||\), \(\), and \(D\). (See Theorem 4.5 for the general statement.)
* A \(2\)-pass streaming algorithm for fair \(k\)-center which attains a \((3+)\) approximation and requires working memory which, for constant \(k\), \(||\), \(\), and \(D\), is \(O((d_{max}/d_{min}))\), where \(d_{min}\) and \(d_{max}\) are, respectively, the minimum and maximum pairwise distance in \(S\). (See Theorem 5.1 for the general statement.)
* A \(5\)-round MapReduce/MPC algorithm for fair \(k\)-center which attains a \((3+)\) approximation and requires a local memory which, for constant \(k\), \(||\), \(\), and \(D\), is \(O(\{|S|/p,p\})\), when \(p\) processors are used. (See Theorem 6.1 for the general statement.)As in (Bera et al., 2017; Bera et al., 2017), all of the above algorithms return solutions where the color distribution in each cluster complies with the fairness constraints within a modest additive violation of \(4+3\), where \(||\) is the maximum number of colors per point.

We implemented and ran our algorithms on real-world datasets, scaling up to 16 million points, to assess the effectiveness and scalability of our coreset-based strategy. The experiments show that our algorithms return solutions whose quality is comparable to the best attained by state-of-the-art algorithms but exhibit significantly better performance.

The main novelty of our approach is that it adapts (obliviously) to the dimensionality of the input dataset, becoming extremely accurate (abating considerably the approximation ratios of (Bera et al., 2017)), and time and space efficient for low-dimensional datasets, in all computational settings. Also, our experiments provide evidence of its practicality.

**Structure of the paper.** The rest of the paper is organized as follows. Section 2 summarizes the relevant related work. Section 3 formally defines the problem and states some basic technical facts. Sections 4, 5, and 6 describe and analyze, respectively, our sequential, streaming and MapReduce algorithms. Finally, our experimental results are reported in Section 7. For space limitations, some technical details are reported in an appendix.

## 2. Related Work

For space limitations, in this section we limit our literature review to the fair \(k\)-center clustering problem, in which a fair assignment to \(k\) cluster centers has to be built while minimizing the maximum distance of a point from its assigned center. For a survey of other fair clustering objective functions and notions, we refer the interested reader to the recent tutorial1 offered at _AAAI 2022_.

In the pioneering work by Chierichetti et al. (Chierichetti et al., 2013), each point of the input is colored either red or blue, and a feasible solution is an assignment that preserves the balance of colors in each cluster, i.e., the ratio of blue to red points in each cluster must be the same as the ratio in the input dataset. The authors provide a combinatorial algorithm yielding a 3 approximation for the \(k\)-center objective.

The main limitation of their approach, however, is that it is limited to the case of a single binary protected attribute. An extension to the case where the protected attribute can face one out of many colors has been devised by Rosner and Schmidt (Rosner and Schmidt, 2013), who provide a 14-approximation algorithm.

The notion of balance has been generalized by Bercea et al. in (Bercea et al., 2017). In their work, the ratio of each color in each cluster is allowed to take values within user-specified color-specific ranges. The paper proposes approaches based on Linear Programming, obtaining a 5 approximation for fair \(k\)-center with exact preservation of the ratios, and a bicriteria 3 approximation that incurs a small violation of the fairness constraints. The main drawback of their approach is that it generates linear programs with a number of variables _quadratic_ in the size of the input set.

Bera et al. (Bera et al., 2017) provide a further extension to the fairness notion, allowing each point to have multiple colors (thus supporting the notion of multiple protected attributes). As in (Bercea et al., 2017), the balance of each individual color in a cluster is then required to be within pre-specified color-specific ranges. The paper proposes a two-step approach valid for all \(k\)-clustering problems with a \(_{p}\) norm objective (thus including \(k\)-center, \(k\)-median, and \(k\)-means, among the others), where the centers are first identified using an _unfair_ approximation algorithm for the unconstrained \(k\)-clustering objective and then the assignment of points to centers is obtained using an LP-based technique. For \(k\)-center, their approach leads to a 3 approximation2, with an additive \(4+3\) violation of the fairness constraints, where \(\) is the maximum number of colors of a point. Importantly, this approach reduces the number of variables in the LP program to \(O(k n)\), where \(n\) is the input size.

Coreset-based streaming and MapReduce/MPC instantiations of the aforementioned strategy are presented in (Bera et al., 2017). In both cases, the approach still relies on first determining a good set of unfair centers, together with the determination of a weighted summary of the input set upon which a variant of the LP introduced in (Bera et al., 2017) is solved to identify a suitable assignment of points to centers. The resulting algorithms achieve a 2-pass \(7+\) approximation in the Streaming setting, and a 2-round 9 approximation for the MPC.

Ahmadian et al. (Ahmadian et al., 2017) study a different \(k\)-center variant, where there is an upper bound \(\) to the ratio of each color in each cluster, but there are no lower constraints on the ratios. They devise a 3-approximate LP-based solution to the problem, and they also provide a combinatorial 12-approximation algorithm for the special case of \(=0.5\).

The goal of reducing the size of the LP used to build the fair assignment of points is further pursued by Harb and Lam (Harb and Lam, 2017), that are thus able to achieve the same approximation factors as in (Bera et al., 2017) while being considerably faster in practice.

## 3. Preliminaries

This section formally defines the problems studied in this paper, and states some important technical facts. Consider a metric space \((M,d)\). We will analyze the performance of our algorithms in terms of the dimensionality of the input set \(S M\) which, for general metric spaces, can be captured by the notion of _doubling dimension_, reviewed below.

For any \(p S\) and \(r>0\), let the _ball of radius \(r\) centered at \(p\)_, denoted as \(B(p,r) S\), be the subset of all points of \(S\) at distance at most \(r\) from \(p\). Then, the _doubling dimension_ of \(S\) is the minimum value \(D\) such that, for all \(p S\), any ball \(B(p,r)\) is contained in the union of at most \(2^{D}\) balls of radius \(r/2\) centered at points of \(S\). The notion of doubling dimension has been used extensively for a variety of applications (e.g., see (Bera et al., 2017; Bera et al., 2017; Bera et al., 2017; Bera et al., 2017) and references therein).

Given an input set \(S\), we assume that each point \(x S\) is colored with a _color combination_ of at most \(\) colors out of a set of colors \(\).3 With \(S_{} S\) we denote the set of points whose color combination contains \(\). For \(x S\) we use \(col(x)\) to denote its color combination, and define \(C_{S}^{}\) to be the family of all color combinations associated with at least one point in \(S\).

A \(k\)-clustering of a set \(S\) is a pair \((C,)\) where \(C S\) is the set of _centers_, and \(:S C\) is the _assignment function_ that maps each point of \(S\) to a center. The \(k\)-center cost, also called _radius_, of a \(k\)-clustering \((C,)\) is the largest distance between a point and its assigned center:

\[r_{C,}(S)=_{x S}d(x,(x))\]

Given a set of centers, the standard, color-oblivious way of building a clustering is by assigning each point to its closest center (with ties broken arbitrarily). Let this assignment function be denoted by \(_{unf}()\), where \(unf\) stands for _unfair_, and let \(OPT_{unf}(S,k)\) be the minimum radius of any \(k\)-clustering of \(S\) under \(_{unf}()\). (We will omit \(S\) and \(k\) when clear from context.)

For the unfair \(k\)-center problem, the classic \(O(kn)\)-time algorithm by Gonzalez (2001) provides a 2 approximation. The algorithm, which we refer to as GMM (Greedy Minimum Maximum) implements the following simple greedy strategy. The set of centers is initialized with an arbitrary point. Then, the next center is selected to be a point at maximum distance from all previously selected centers. The procedure is repeated until there are \(k\) centers.

Our analysis will make use of the following result, which was proved in (Bauer et al., 2011, Lemma 1).

Lemma 3.1 ().: _Let \(X S\). For a given \(k\), let \(T_{X}\) be set of \(k\) centers computed by GMM on \(X\). We have_

\[r_{T_{X},_{unf}}(X) 2 OPT_{unf}(S,k)\]

Clearly, the aforementioned standard assignment function might lead to unfair results, in the sense that different clusters might exhibit different proportions of points with the same color. This motivates the following additional constraint. A clustering \((C,)\) for \(S\) is called _fair_ if, for each \(\), for given parameters \(_{}_{}:\)

\[_{}\}|}{|\{x S:(x)=c_{i}\}|} _{} c_{i} C.\]

In other words, fairness requires that the fraction of points whose color combination includes color \(\) is between parameters \(_{}\) and \(_{}\) in every cluster. Our algorithms will enforce this notion of fairness within some (small) tolerance. More precisely, as in (Bauer et al., 2011) we say that a clustering \((C,)\) for \(S\) is _fair with additive violation \(\)_ if for every \(c_{i} C\) and \(\),

\[_{}|\{x S:(x)=c_{i}\}|-|\{x S:(x)=c_{i}\}|\]

and

\[|\{x S_{}:(x)=c_{i}\}|_{}|\{x S:(x)=c_{i} \}|+.\]

Note that the fairness conditions are stated for each color _independently_. This means that a point with multiple colors will be involved in multiple fairness constraints. An alternative approach would be that of considering every color combination in \(C_{S}\) as a new, different color and enforcing a fairness constraint for each of these new colors. Clearly, this simpler approach can be modeled as the case of a single color per point. It is important to observe that no fair clustering may exist for a given multicolored pointsset \(S\) under a certain set of fairness constraints.

An optimal fair clustering is a fair clustering which minimizes the radius, denoted as \(OPT_{fair}(S,k)\). (In case no fair clustering exists, we set \(OPT_{fair}(S,k)=+\).) The following basic fact trivially holds.

Fact 1.: _For a given set \(S\) and any fairness constraint, we have_

\[OPT_{unf}(S,k) OPT_{fair}(S,k)\]

### Big-data models of computation

In the MapReduce model (Kipf and Welling, 2017), an algorithm executes in a sequence of _parallel_ rounds. In each round a multiset \(X\) of _key-value_ pairs is transformed in a new multiset \(Y\) by means of a _mapper_ function, followed by the application of a _reducer_ function to obtain a final multiset \(Z\). Crucially, the local memory available to each _mapper_ and _reducer_ is limited by a parameter \(M_{L}\), whereas the _aggregate_ memory across all mappers and reducers is limited by parameter \(M_{A}\). An algorithm in this model strives to minimize the number of rounds while complying with the memory limits.

We emphasize that our MapReduce algorithms admit a straightforward porting to the MPC model (Bauer et al., 2011), maintaining the same round and space complexity. Hence, all the results in this paper stated for MapReduce hold identically for the MPC model.

## 4. Sequential algorithm

This section describes our sequential coreset-based algorithm for fair k-center clustering. The input consists of a set of colored points \(S\), the number of clusters \(k\), the fairness constraints, represented by the two vectors \(=\{_{}:\}\) and \(=\{_{}:\}\), and an accuracy parameter \((0,1)\). The algorithm executes three main steps. In the first step, a small coreset \(T\) of colored and weighted points is computed from \(S\), so that each \(x S\) has a _proxy_\((x) T\) with the same color combination, and each \(t T\) carries a weight denoting the number of original points for which it acts as a proxy. In the second step, a solution \(C T\) consisting of \(k\) centers is computed running GMM on \(T\), and a skeleton of the final clustering is computed by suitably distributing the weights of the coreset points among the centers. Finally, in the third step, the skeleton is turned into the final clustering. The pseudocode for this high-level structure of the algorithm is depicted in Algorithm 1. The three steps and the procedures that they use are described in detail in the following subsections.

```
Input: Set of points \(S\), parameters \(k\), \(\), \(\) and \(\) Output: Set of centers \(C\), assignment function \(\) /* Step 1 */ \((T,)(S,k,)\); /* Step 2 */ \(C(T,k)\); \((T,C,,)\); /* Step 3 */ \((,S,T,C)\); return\((C,)\);
```

**Algorithm 1**Sequential Fair k-Center Clustering

### Step 1: Coreset construction

We build the weighted coreset \(T\) as follows (see Algorithm 2 for the pseudocode). First we run \(k\) iterations of GMM on \(S\) to determine a set of \(k\) centers, which we denote as \(T^{k}\), and compute the radius \(r_{T^{k},_{unf}}\). Then, we continue to run GMM until the first iteration \( k\) such that

\[r_{T^{k},_{unf}}(/6) r_{T^{k},_{unf}}.\]
```
Input: Set of points \(S\), parameters \(k\) and \(\)
21 /* Identify coreset points */ \(T\{\)an arbitrary point of \(S\}\); while\(|T|<k\)do\(T T\{_{x S}d(x,T)\}\) ; \(r_{k}_{x S}d(x,T)\); while\(_{x S}d(x,T)>(/6)r_{k}\)do\(T T\{_{x S}d(x,T)\}\); /* Build the proxy function and weights */ for\(t T\)do Build \(|C_{S}|\) copies of \(t\) with distinct color combinations; Set the weight \(w(t)\) of each copy to \(0\); for\(x S\)do\(t^{}_{t T(t)(x)}d(x,t)\) ; \(w(t^{}) w(t^{})+1\); \((x) t^{}\); return\(T,w,\);
```

**Algorithm 2**CoresetConstruction

Now, for each point \(t T^{r}\) we create \(|C_{S}|\) copies, each colored with a distinct color combination in \(C_{S}\). The resulting set of \(|C_{S}||T^{r}|\) copies will be our coreset \(T\). Then, we determine a proxy function \(:S T\) which assigns to each point \(x S\) the closest coreet point of the same color combination, namely

\[(x)=*{arg\,min}_{t T\;:\;(t)(x)}d( x,t) x S.\]

Also, for each coreset point \(t T\) we compute a weight \(w(t)\), corresponding to the number of points of \(S\) for which \(t\) is a proxy :

\[w(t)=|\{x S:(x)=t\}|.\]

Points of \(T\) with zero weight (i.e. which are the proxy of no input point) are simply discarded. Observe that all the points proxied by the same coreset point \(t\) have the same color combination.

The following lemma upper bounds the distance between each input point from its representative in \(T\).

**Lemma 4.1**.: _Let \(T\) be the coreset constructed above for the set \(S\), and let \(\) be the associated proxy function. Then, for each \(x S\) we have:_

\[d(x,(x))(/3) OPT_{}\]

Proof.: We have that

\[r_{T^{r},_{}}(/6) r_{T^{k}, _{}}\] \[(/3) OPT_{}\]

where the first inequality holds by construction, and the second by Lemma 3.1. 

We now bound the size of the coreset.

**Lemma 4.2**.: _If \(S\) has doubling dimension \(D\), then_

\[|T||C_{S}| k(12/)^{D}\]

Proof.: We first prove an upper bound on the number \(\) of iterations needed by GMM to obtain a radius

\[r_{T^{r},_{}}(/6) r_{T^{k},_{}}.\]

Consider the unfair \(k\)-center clustering induced by \(T^{k}\) using \(_{}\), whose radius is \(r_{T^{k},_{}}\). By the doubling dimension property, each of the \(k\) clusters can be covered using at most \((12/)^{D}\) balls of radius \((/12)r_{T^{k},_{}}\), for a total of at most \(h=k(12/)^{D}\) balls.

Consider now the execution of \(h\) iterations of GMM on \(S\), with \(T^{h}\) being the set of centers and \(x S\) being the point farthest from any center in \(T^{h}\). It is easy to see that GMM ensures that any two points in \(T^{h}\{x\}\) are at distance at least \(r_{T^{h},_{}}\) from one another. Since two of these points must fall into one of the \(h\) balls mentioned above, by the triangle inequality we have that

\[r_{T^{h},_{}} 2(/12) r_{T^{k},_{}}=(/6) r_{T^{k},_{}}\]

Hence, we are guaranteed that after running \(h\) iterations of GMM we find a set of points meeting the stopping condition, which implies \( h\). The lemma follows by noting that each point in \(T^{h}\) is replicated at most \(|C_{S}|\) times in \(T\). 

### Step 2: creating the clustering skeleton

Recall that coreset \(T\) computed in Step 1 is such that each \(t T\) represents \(w(t)\) points of \(S\) with the same color combination, which, by virtue of Lemma 4.1, are rather close to \(t\). In Step 2, our algorithm first computes a set \(C\) of \(k\) centers by running GMM on \(T\), and then invokes a procedure called WeightDistribution, described below, to distribute the weight of each \(t T\) among one or more centers of \(C\), so to minimize the maximum distance between coreset points and one of the centers receiving their weights (which we will refer to as the _radius of the distribution_) while, at the same time, enforcing the fairness constraints. This distribution will be modeled through a weight assignment function \(:T C N\) which will provide a skeleton of the final clustering and will be used in Step 3 to extract the assignment function \(\).

To achieve the aforementioned weight distribution, we make use of a weighted version of the Frequency Distributor LP of Harb and Shan (1999). Let \(R\) be a guess on the radius of the distribution and consider the power set \(2^{C}\) of the set of centers \(C\). For each color combination \(L C_{S}\) and each subset of centers \(C^{} 2^{C}\), define \(JC_{,L,R}\) as the set of points with color combination \(L\) that are within distance \(R\) from all and only the points of \(C^{}\), namely

\[J_{C^{},L,R}&=&\{t T:(t)=L d(t,c)  R\, c C^{}\\ && d(t,)>R\,\,\,\,^{}\}\]

Each \(J_{C^{},L,R}\) is referred to as a _joiner_ in (1999). For a joiner \(J\), we introduce the following notation: \(C_{J}\) denotes the subset of centers defining \(J\), \((J)\) denotes the color combination common to all of its points and

\[w(J)=_{t J}w(t)\]

denotes the total weight carried by the points of the joiner. Let \((R)\) be the set of joiners obtained for the guess \(R\) and observe that they define a partition of \(T\). For every \(\) we also define

\[(R)_{}=\{J(R):(J)\}\]

The crucial observation is that a joiner \(J(R)\) acts as a _super point_ in the sense that the weight of any of its points can be indifferently distributed to _any_ center in \(J_{C}\). Thus, the weight distribution can be computed at the joiner level rather than the coreset point level. To this purpose, the following linear program is defined which uses a variable \(z_{J,c}\) for every joiner \(J\) and center \(c C_{J}\).

**LP-WPD**(\((R),C\))

(1) \[z_{J,c} 0 J(R),c C_{J}\] \[_{c C_{J}}z_{J,c}= w(J)  J(R)\] (2) \[_{}_{J(R)}z_{J,c}_{J^{} (R)_{}}z_{J^{},c}  c C,\] (3) \[_{J^{}(R)_{}}z_{J^{},c} _{}_{J(R)}z_{J,c}  c C,\] (4)

Condition (2) ensures that all the weight is assigned to some center, whereas Conditions (3) and (4) encode the fairness constraints. Note that the fairness constraints (3) and (4) are defined cluster-wise, and can be specified through variables \(z_{J,c}\) which exploit the aggregation of the points defined by the joiners.

By construction, in a feasible solution to the above LP the nonzero \(z_{J,c}\)'s define an association between joiners and centers, such that for every coreset point \(t\) belonging to some joiner \(J\) and any center \(c\) with \(z_{J,c}>0\), we have \(d(t,c) R\). Clearly, for small values of \(R\) no feasible solution may exist. The following lemma provides a crucial lower bound to values \(R\) which yield feasible solutions.

**Lemma 4.3**.: _Suppose that the weighted coreset \(T\) computed for \(S\) features a proxy function \(\) such that \(d(x,(x))/3\), for every \(x S\). Then, for \(R(3+(2/3))OPT_{fair}\), the linear program above has a feasible solution._

Proof.: Consider the set of centers \(C\) selected by GMM, and the optimal fair clustering \((C^{},^{})\) of cost \(OPT_{fair}\). We will show that we can distribute the weight of points in \(T\) to points in \(C\) within distance \(R\) so that the constraints of the linear program are satisfied.

For each point \(x S\), consider its optimal fair center \(^{}(x)\), and let \(((^{}(x)))\) be the center of \(C\) nearest to \((^{}(x))\). By Lemma 3.1, we have that \(d(((^{}(x))),( ^{}(x)) 2OPT_{unf}\). Figure 1 depicts all the points involved, along with relevant bounds on their distances. Let \(J\) be the joiner such that \((x) J\). By following the chain of inequalities of Figure 1, we have that \(d((x),((^{}(x) ))) R\), hence \(((^{}(x))) C_{J}\). We determine values for the variables of \(((R),C)\) by "moving" one unit of weight from \((x)\) to the variable \(z_{J,((^{}(x)))}\). After processing all points in \(S\), it is immediate to see that the group of constraints (2) is satisfied.

As for the fairness constraints (3) and (4), for \(c C^{}\), let \(C^{}(c)=\{x S:^{}(x)=c\}\) be the optimal cluster centered in \(c\). Similarly, let \(C^{}_{}(c)=\{x S:^{}(x)=c\}\) for \(c C^{}\), \(\) be the set of points of color \(f\) assigned to the cluster centered in \(c\). Clearly, each optimal cluster \(C^{}(c)\) must respect the fairness constraints, i.e.

\[_{}_{}(c)|}{|C^{}(c)|}_{} \]

for each \(c C^{}\) and \(\). Now, for each \(c C\) let \(N(c)=\{e^{} C^{}:((c^{}) )=c\}\) be the set of optimal centers for which \(c\) is the closest center in \(C\) to their proxy in the coreset. By the weight assignment procedure described above, we have that any center \(c C\) is assigned a weight equal to the number of points in \(_{^{} N(c)}C^{}(c^{})\). Therefore we have that for any color \(\) and any center \(c C\)

\[_{} N(c)}|C^{}_{}(c^{})|}{ _{c^{} N(c)}|C^{}(c^{})|}_{}\]

by Fact 2 (in the Appendix) and Inequality (5), which proves that the set of constraints (3) and (4) are also satisfied. 

In Step 2, after computing the centers \(C\) we run Procedure WeightDistribution which performs the following operations (see Algorithm 3 for the pseudocode). First it computes and sorts the \(|T|k\) distances between the coreset points and the centers, and then performs a binary search over these distances to identify the smallest value \(R\) such that the LP-WFD yields a feasible solution \(Z_{LP-WFD}=\{z_{J,c}\ :\ (R) c C$}\}\). Note that this solution may be fractional. In order to derive an integral weight assignment to the centers, we run Procedure CoRESTAsign. The procedure first transforms \(Z_{LP-WFD}\) into an integral solution \(Z_{LP-WFD}^{int}=\{z_{J,c}^{int}\ :\ J(R) c C\}\), by using the iterative rounding procedure presented in (Bartlett and Barthelemy, 2009), and then derives the weight assignment function \(\) by distributing the weight of the coreset points of each joiner \(J\) among the centers, as specified by the \(z_{J,c}^{int}\)'s. The rounding introduces a mere additive violation of the fairness constraints, as stated in the following lemma. For space limitations, the details of Procedure CoRESTAsign and the proof of the lemma are moved to Appendix B.

**Lemma 4.4**.: _Procedure CoRESTAsign returns a weight distribution function \(:T C\) such that for every color \(\) and every center \(c C\)_

\[_{}_{t T}(t,c)-(4+3)_{t T_{ }}(t,c)_{}_{t T}(t,c)+(4+3),\]

_where \(T_{}\) is the subset of coreset points whose color combination contains \(\)._

### Step 3: Final assignment

In the last step, the algorithm uses the weight assignment function \(\) computed in Step 2 to compute the final assignment function \(\)

Figure 1.

between the original points of \(S\) and the centers in \(C\). Observe that, by construction, \(\) ensures that for each \(t T\)

\[_{c C}(t,c)=w(t)=|\{x S:(x)=t\}|.\]

Therefore, we can compute \(\) through a sequential scan of \(S\), where for each \(x S\) an arbitrary center \(c\) with \(((x),c)>0\) is chosen, and \((x)\) is set equal to \(c\) while \(((x),c)\) is decreased by \(1\). The pseudocode is depicted in Algorithm 4.

```
Input: Weighted coreset \(T\), set of centers \(C\), parameters \(a\), \(\) Output: Assignment \(:T C\) \(\) Sorted list of distances \(d(t,c),\  t T,c C\);  Do binary search on \(\) to find the smallest \(R\) such that \(((R),C)\) yields a feasible solution \(z^{*}=\{z_{Jc}:J(R),c C_{J}\}\): \((T,(R),C,z^{*})\);
``` Input: Sets \(S,T\) and \(C\), and assignment \(:T C\) Output: Assignment \(:S C\) for\(x S\)do \(t(x)\); \(c\ e C:(t,c)>0\); \((x) c\); \((t,c)(t,c)-1\); return\(\); ```

**Algorithm 4**FinalAssignment

### Putting all pieces together

The following theorem concludes the analysis.

**Theorem 4.5**.: _For an input set \(S\) of doubling dimension \(D\), the above sequential algorithm returns a \((3+)\)-approximation to the optimum fair k-center clustering, with an additive violation \( 4+3\) of the fairness constraints. For fixed values of \(R\), \(D\), and \(||\), the algorithm requires linear time in the input set size._

Proof.: The compliance with the fairness constraints is an immediate consequence of Lemma 4.4 and the derivation of \(\) from \(\). As for the radius, the above assignment procedure, combined with the result of Lemma 4.3, ensures that for every \(x S\)

\[d(x,(x))  d(x,(x))+_{e C,z^{*} C,z^{* } C,z^{*}>0}d((x),c)\] \[(/3)OPT_{}+(3+(2)/3)\ OPT_{ {fair}}\] \[(3+)OPT_{}.\]

The running time of the algorithm is dominated by the run of GMM to identify \(T\), the cost of solving \(O((|T|k))\) instances of \(((R),C)\), and the cost of computing the final assignment. By Lemma 4.2 we have that \(|T||C_{S}| k(12/)^{D}\), and by adapting the analysis in (Hardt et al., 2016), we have that each \(((R),C)\) entails \(O(k\{2^{k}|C_{S}|,|T|\})\) variables and \(O(k(|T|+\{2^{k}|C_{S}|,|T|\}))\) constraints. Thus, since \(|C_{S}| 2^{||}\), for fixed values of \(k\), \(D\), and \(||\), the algorithm exhibits only linear dependence in \(|S|\). 

It is important to remark that our algorithm attains an approximation factor that can be made arbitrarily close to the one of (Bauer, 2016) but, for wide ranges of the involved parameters, reduces dramatically the size of the linear programs required to compute the solution, which dominate by far the computation costs.

## 5. Streaming Algorithm

In this section, we describe a 2-pass streaming implementation of the sequential algorithm (Algorithm 1). We now regard the input \(S\) as a stream of points. The first pass constructs the weighted coreset \(T\) and, at the end of the pass, Step 2 of Algorithm 1, whose space requirements are independent of the stream size, is performed as is, returning the weight distribution function \(\). Then, in the second pass the final assignment \(\) is computed.

The coreset construction requires the knowledge of the smallest and largest pairwise distances in the stream (or suitable approximations), denoted respectively as \(d_{}\) and \(d_{}\).4. The first pass runs in parallel several _instances_ for geometric guesses \(R\) of the optimal radius of \(OPT_{}(S,k)\), namely \(R=2^{j}d_{}\), with \(0 j_{2}(d_{}/d_{})\). Let \(S_{i}\) be the set of the first \(i\) points of \(S\). For \(i 1\), each instance maintains two sets of points:

* A set \(C_{R}\) of up to \(k+1\) points with \(d(x,C_{R}) 2R, x S_{i}\),
* A set \(T_{R}\) of weighted points with \(d(x,T_{R})R, x S_{i}\).
* \(C_{R}\) is used to detect when the guess \(R\) is too small, while \(T_{R}\) is the candidate coreset. For each point \(x\) in the stream, if \(d(x,C_{R})>2R\), then \(x\) is added to \(C_{R}\). In case the size of \(C_{R}\) exceeds \(k\), this instance fails because the guess \(R\) is too small. Otherwise, \(x\) is processed as follows. If \(d(x,T_{R})>R\), then we add \(x\) to \(T_{R}\) with weight \(1\), and also add \(|C_{S}|-1\) copies of \(x\) to \(T_{R}\), with the other color combinations from \(C_{S}\) and weights \(0\). If instead \(d(x,T)R\), then we take the point \(t T_{R}\) which arrived the earliest (rather than the closest), and such that \(col(t)=col(x)\) and \(d(x,t)R\), and increase \(w(t)\) by one, thus making \(t\) proxy of \(x\). It is important to remark that we do not store the proxy function explicitly, since it would require linear memory. By using the earliest valid coreset point as the proxy, the proxy function can be reconstructed on the fly, a fact that will be used in the second pass of the algorithm. We select the output \((C_{R},T_{R},R)\) of the non-failing instance associated with the smallest guess \(R\). The pseudocode for the first pass is depicted as Algorithm 5

As mentioned above, at the end of the first pass, Step 2 of Algorithm 1 is run on \(T\) to compute the weight distribution function \(\) based on \((C_{R},T_{R})\). In the second pass, the final assignment \(\) is computed using the naturally streamlined algorithm FinalAssignment (Algorithm 4) with the only difference that, for every \(x S\), its proxy \((x)\) is obtained as the earliest coreset point \(t\) such that \(col(t)=col(x)\) and \(d(x,t)(/12)R\). We have:

**Theorem 5.1**.: _For an input stream \(S\) of doubling dimension \(D\), the above 2-pass algorithm returns a \((3+)\) approximation to the optimum fair k-center clustering, with an additive violation \( 4+3\) of the fairness constraints using working memory \(O(k|C_{}|((24/)^{D}(d_{}/d_{min})+| |(2^{k},k(24/)^{D})))\)

Proof.: First, we prove that the set \(C_{R}\) returned by Algorithm 5 provides a 4 approximation to the unfair k-center problem. Consider the smallest integer \(j\) such that \(d_{min} 2^{j-1}<r_{k}^{*} d_{min} 2^{j}\), where \(r_{k}^{*}\) is the radius of an optimal solution to unfair k-center on the stream \(S\), and define \(=2^{j}\). Clearly, \( 2r_{k}^{*}\) Observe that the instance associated to guess \(\) indeed terminates successfully, since the points put in \(C_{}\) must necessarily belong to different optimal unfair clusters. Also, at the end of the stream, we will have that for each \(x S\), \(d(x,C_{}) 2 4 r_{k}^{*}\). Therefore, Algorithm 5 will return a triple \((C_{R},T_{R},R)\) with \( 4 r_{k}^{*}\). Consider now coreset \(T_{R}\). For each \(x S\), we have

\[d(x,T_{R})(/12)R(/12)4r_{k}^{*}( /3)OPT_{},\]

hence \(T_{R}\) has the same quality of the coreset computed by the sequential algorithm, and the approximation guarantee exhibited by the final solution can thus be argued similarly.

Let us now bound the working memory required by the streaming algorithm. By virtue of the doubling dimension property, for every instance associated with a generic guess \(R\) and until the instance is non-failed, each of the \( k\) clusters of radius \(2R\) induced by \(C_{}\) can be covered by using at most \((24/)^{D}\) clusters of radius \( R/12\), and each subset may contribute \(|C_{}|\) coreset points to \(T_{R}\). Also, in the first pass, we have \((d_{}/d_{min})\) instances of the algorithm running in parallel. The bound on the working memory is a consequence of the bounds on the \(|T_{R}|\)'s and on the size of the linear programs executed at the end of the first pass. 

## 6. Mapreduce algorithm

In this section, we adapt the sequential strategy presented in the Section 4 to the distributed setting, devising the following 5-round MapReduce algorithm. In the first round, the input \(S\) is partitioned arbitrarily across the \(p\) workers, and worker \(i\) extracts a subset \(T_{i}\) of points by executing the first two while-loops of Algorithm 2 on its partition, using accuracy parameter \(/2\) rather than \(\). In the second round, the \(T_{i}\)'s are gathered in a single worker, and their union, say \(T^{}\), is further processed through the first two while-loops of Algorithm 2, using again accuracy \(/2\), to extract a subset \(T^{} T^{}\). In the third round, a copy of \(T^{}\) is sent to each worker, which makes \(|C_{}|\) copies of each \(t T^{}\) and computes their weights with respect to the points of \(S\) in its partition, as specified in the last two for-loops of Algorithm 2. In the fourth round, the final coreset \(T\) is built by gather all copies of the points of \(T^{}\) created by the different workers in a single worker, and coalescing the \(p\) like-colored copies of each \(t T^{}\) by adding up their weights. This produces the final weighted coreset \(T\), on which Step 2 of Algorithm 1 is run sequentially to compute the set \(C\) of centers and \(p\) projections \(_{l},i[p]\), of the weight distribution function \(\), relative to the \(p\) partitions of \(S\). The final assignment is then built in the fifth round, by sending to the \(i\)-th worker the projection \(_{l}\), so that procedure FinalAssignment can be applied independently within its partition. The following theorem, whose proof is deferred to Appendix C for lack of space, summarizes the accuracy-space tradeoffs featured by the above algorithm.

**Theorem 6.1**.: _For an input set \(S\) of doubling dimension \(D\), the above 5-round MapReduce algorithm returns a \((3+)\) approximation to the optimum fair k-center clustering, with an additive violation \( 4+3\) of the fairness constraints, using local memory_

\[M_{L}=O(\{,k|C_{}|(p(24/ )^{D}+||\{2^{k},k(24/) ^{D}\})\})\]

## 7. Experiments

Our experiments aim at: **(a)** comparing the performance of different algorithms for different values of \(k\) in terms of radius and running time; **(b)** verifying the influence of the coreset size on the quality of the approximation; **(c)** demonstrating the efficiency of the streaming and MapReduce approaches on large datasets. We compare our approach against the following baselines: unfarm, the classic GMM algorithm (Gardner et al., 2011), which returns the unfair clustering radius that we use as a reference point; Bera-et-al, the algorithm from (Bera-et-al, 2017); KFC, the algorithm of (Bera-et-al-stream and Bera-et-al-MR the streaming and MapReduce algorithms from (Bera-et-al, 2017), respectively. We devised best-effort implementations of all of the above algorithms, always improving on the running time of the original ones while maintaining the same accuracy, but for KFC, for which we used the author's code. We experiment with the same datasets used by

   dataset &  &  &  &  &  &  &  &  \\  lmdata & 16 07 906 & 8 & 18 & adult & 32 561 & 5 & 7 & 78 \\ census1990 & 245 285 & 66 & 8 & creditcard & 30 000 & 14 & 7 & 789 \\ athlete & 206 165 & 3 & 2 & bank & 4521 & 9 & 3 & 780 \\ diabetes & 89 782 & 9 & 5 & victorian & 4 500 & 10 & 45 & 761 \\ area & 35 385 & 8 & 4 & reuter\_50 & 50 & 2 500 & 10 & 50 \\   

Table 1. Datasets used in the experimental evaluation.

previous works (Bera-et-al-stream, 2017; 2017; 2017), whose features are given in Table 1. Due to space constraints, in this section we report only on the four largest ones, providing the results for the others in Appendix D, along with details about our experimental setup. As in (Bera-et-al-stream, 2017), we set strict fairness constraints: \(_{l}=r_{l}(1-)\) and \(_{l}=r_{l}/(1-)\), for \(r_{l}=|S_{l}|/|S|\) and \(=0.01\). For our algorithms, rather than governing the coreset size indirectly through \(\), we fix it directly as a multiple of \(k\), allowing for more interpretable results. Our source code is publicly available (see [https://anonymous.4open.science/r/fair-clustering-C8EF/](https://anonymous.4open.science/r/fair-clustering-C8EF/))

Sequential settingFigure 2 reports the radius and the running time of different sequential algorithms for \(k=2^{t}\), \(i\). unear always has the smallest radius and the fastest running time, as expected. The best fair clustering radius is up to 15 times larger (hnda) than the unfair clustering radius. Notably, while an unfair clustering sees its radius constantly decreasing with \(k\), for some datasets (hnda, census1990) the fair radius tends to remain constant as \(k\) becomes larger. We observed that in these cases the fairness constraints encourage the assignment of the majority of points to a few (\( k\)) large clusters, whose radius remains large irrespective of the value of \(k\). Two instances of our algorithm, dubbed coreset, were run with coreset sizes \(k\) and \(32k\). As expected, using a larger coreset gives a clustering with a smaller radius, which becomes comparable (at most 1.39 times larger) to the one attained by KFC and Bera-et-al-Note: Noteeably, the slight increase in the radius is compensated by the significantly faster execution time (Figure 2, bottom), even with a coreset of size \(32k\). Indeed, in our experiments, Bera-et-al timed out after one hour on census1990 and hnda, and on athlete for large \(k\), whereas KFC timed out on hnda, with 16 million points. In contrast, our coreset-based algorithm completed just in under 5 minutes for \(k=64\) and a coreset of size \(32k\).

StreamingWe compare our algorithm (coreset-stream) with Bera-et-al-stream (2017) for different amounts of memory allowed to both algorithms, and for \(k=32\). For coreset-stream, larger memory implies that each of the \(_{2}d_{max}/d_{min}\) instances of the algorithm builds a larger coreset, whereas for Bera-et-al-stream, larger memory implies that a smaller \(\) is used, hence more parallel instances are run, each building a \(k\)-clustering. Both implementations feature the same level of optimization. Figure 3 reports the running time and the radius achieved by both algorithms on the two largest datasets of the testbed. The dashed lines, used for reference, mark the best running time and radius attainable by the sequential fair algorithms. We observe that for comparable memory usage, our coreset-stream algorithm runs faster than Bera-et-al-stream. As for the radius, coreset-stream provides a radius closer to the best radius found by sequential algorithms. The figure highlights the fundamental tradeoff of our coreset construction: larger coresets allow for better approximations. Interestingly, for small memories, both algorithms are faster than the fastest sequential one. This is due both to the low aspect ratio \(d_{max}/d_{min}\) (\( 56K\) for hnda, \( 43\) for census1990) and to the streaming clustering strategy which may require less than \(n\) distance computations per center.

MapReduceWe compare our algorithm (coreset-MR) with Bera-et-al-MR (2017) for different numbers of processors and \(k=32\). Figure 4 reports the results in terms of time and radius. The line in the time plots marks the total running time, whereas the shaded area represents the time required to solve the linear program on the pointset created by each algorithm. As already noted in (2017), the running time of Bera-et-al-MR increases with the number of processors because it is dominated by the time to solve the linear program (shaded red area) whose size increases with the number of processors, thus annulling scalability. Conversely, in coreset-MR the size of the linear program is independent of the number of processors: in fact, the blue shaded area marks a constant running time for all processor counts. Consequently coreset-MR features good scalability. As for the radius, both approaches provide solutions of comparable quality.

Figure 4. MapReduce algorithms performance vs. parallelism: time (left) and radius (right).

Figure 3. Streaming algorithms performance vs. memory (log scale): time (left, log scale) and radius (right).

Figure 2. Radius (top) and running time (bottom, in log scale) of different algorithms vs. \(k\) (in logarithmic scale). Missing points are for timed-out runs.