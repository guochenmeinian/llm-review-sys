# [MISSING_PAGE_FAIL:1]

[MISSING_PAGE_FAIL:1]

in the blockchain. UTP is responsible for recording and processing all unconfirmed transactions in real time. It comprises five nodes, each of which runs a modified Bitcoin Core. Subsequently, we propose two novel clustering heuristics specifically designed for unconfirmed transactions, aiming to uncover additional address associations that are beyond the capabilities of the SOTA clustering heuristics. The principles of our proposed clustering heuristics are derived from the Replace-by-fee (RBF) proposed by Bitcoin Improvement Proposal (BIP)125 (Ferrari et al., 2017) and the unconfirmed transaction dependency chain mentioned in BIP141 (Shi et al., 2017). Experimental results reveal the effectiveness of our approach in leveraging unconfirmed transactions to uncover address associations, significantly improving the clustering results of the SOTA clustering heuristics. To validate our approach, we construct a labeled dataset based on Bitcoin ordinal insertions (Shi et al., 2017) and demonstrate that our approach improves the recall with high precision by at least three times compared to the SOTA clustering heuristics. The increase in recall indicates that our approach uncovers additional address associations, thus reducing entities incorrectly clustered. Furthermore, we show that our approach reduces the number of entities in the clustering results of the SOTA clustering heuristics by at least 20.28%, which can reduce the error of addresses that should belong to the same entity, but being clustered into multiple entities. Finally, we find that unconfirmed transactions have a greater impact on the clustering results for future periods than those from past periods.

To the best of our knowledge, our study is the first to explore unconfirmed transactions to cluster addresses in Bitcoin. In summary, our main contributions in this paper are threefold:

* **Novel heuristics**: We propose two novel clustering heuristics to uncover additional address associations by analyzing the specific behavior patterns in unconfirmed transactions, in order to improve Bitcoin address clustering. Experimental results show that our proposed clustering heuristics can effectively utilize unconfirmed transactions to uncover address associations, significantly improving recall with high precision by at least three times.
* **Data collection**: We introduce a reliable data collection framework to record and process all unconfirmed transactions in Bitcoin in real time. We release a part of the dataset2 as a benchmark for future studies.
* **Labeling method**: We present a method for constructing a labeled dataset based on Bitcoin ordinal insertions. This method addresses, to some extent, the critical issue in the field of Bitcoin address clustering, i.e., the lack of labeled datasets to validate clustering results. In this paper, we construct and release a dataset3 encompassing 20 entities and 62,971 addresses.

## 2. Background

### Mempool in a Bitcoin Node

Bitcoin is established on a set of Bitcoin nodes, each of which stores a ledger of confirmed transactions. Bitcoin blockchain acts as the distributed ledger.

As shown in Figure 1, before a transaction is stored in the blockchain, it (as an _unconfirmed_ transaction) will be temporarily stored in the mempool of a node. The node will validate (or reject) the transaction that is from other nodes or initiated by itself based on established criteria. For instance, it validates the correctness of signatures. If the transaction meets the established criteria, the node will add the transaction to its mempool. Miners select transactions from their own mempools and then packaging these transactions to a block. They compete to append the block to the blockchain through proof-of-work. The winning miner propagates his or her block to other nodes, while other nodes append the block to their own ledgers. When the block is appended to the ledgers of all nodes, it indicates that the block is appended to the blockchain. Then, the transactions in the block become _confirmed_ transactions. Note that a portion of unconfirmed transactions might never get confirmed due to, e.g., being replaced or paying insufficient fees. These transactions are considered as _failed_ transactions.

Each unconfirmed transaction in the mempool has some additional fields, e.g., _replaceable, time, depends_, and _spentby_, which are not present in confirmed transactions. The latter three fields are exclusively available when a transaction is in Bitcoin mempool and disappear once the transaction is confirmed. (1) The field _replaceable_ is a Boolean value, indicating whether this transaction can be replaced by another transaction. (2) The field _time_ annotates the moment at which the transaction enters a particular node's mempool that may exhibit minor variances across different mempools. (3) The field _depends_ of a transaction records unconfirmed transactions whose UTXO(s) is spent by this transaction. (4) The field _spentby_ of a transaction records unconfirmed transactions spending outputs of this transaction. These fields contain rich information about a transaction before it is confirmed, which can be utilized in our study for Bitcoin address clustering.

### Bitcoin Address Clustering

The SOTA clustering heuristics rely on behavior patterns in confirmed transactions to uncover address associations, which indicate whether these addresses are controlled by the same entity. For example, a common heuristic, known as the _co-spend_ heuristic, considers that all inputs of a transaction are controlled by the same entity, because a valid transaction requires the signature of private keys corresponding to all inputs. In practice, however, a few studies (Ferrari et al., 2017; Shi et al., 2017; Shi et al., 2017) advocate the exclusion of Conjoin transactions (Shi et al., 2017) prior to applying the _co-spend_ heuristic. This is mainly because Conjoin transactions employ a trustless method for combining

Figure 1. Life-cycle of a Bitcoin transaction.

multiple Bitcoin payments into a single transaction, thereby obfuscating the relationship between senders and recipients.

In addition, various heuristics, known as the _change_ heuristics, have been introduced in previous studies (Bittlestone et al., 2017; Bittlestone et al., 2017; Bittlestone et al., 2018; Bittlestone et al., 2019). In Bitcoin, an Unspent Transaction Output (UTXO) represents a certain amount of bitcoins. It is an indivisible unit and must be fully spent in a transaction. This results in the need for senders to use a change address to receive the remaining amount of bitcoins. Thus, the address of the sender (the input address) and the change address should be controlled by the same entity. For such heuristics, it is key to identify change addresses in transactions.

So far, the SOTA clustering heuristics focus only on behavior patterns in confirmed transactions that are already stored in the blockchain. However, they all ignore the additional information of a transaction before it is stored in the blockchain.

## 3. Approach

### Overview

As shown in Figure 2, our approach consists of two components: Data Collector and Heuristics Executor. Data Collector contains two sub-components: Confirmed Transaction Collector (CTC) and Unconfirmed Transaction Processor (UTP). CTC copies confirmed transactions from the ledger of a node, while UTP collects and processes all unconfirmed transactions that appeared in mempools of deployed nodes. Data Collector subsequently transfers both confirmed and unconfirmed transactions to Heuristics Executor. Then, Heuristics Executor, consisting of our proposed clustering heuristics and the SOTA clustering heuristics, clusters Bitcoin addresses.

### Data Collector

**CTC.** As shown in Figure 2, CTC with one node running a Bitcoin client, referred to as Bitcoin Core, copies confirmed transactions from the ledger of the node. In CTC, we optimize BlockSci (Bittlestone et al., 2017), a widely used Bitcoin transaction parsing tool, as BlockSci-modified4, which can parse Taproot addresses (Kumar et al., 2018).

**UTP.** UTP consists of a set (five in this paper) of nodes, each of which runs a modified Bitcoin Core. It aims to collect as many unconfirmed transactions as possible in Bitcoin and continuously reconstruct the state of the Bitcoin mempool in each node. This state hereby contains the details of each transaction in the mempool at a moment. Here, UTP tries to solve two key issues as follows:

(1) _How can UTP collect unconfirmed transactions in real time?_

When using the Remote Procedure Call interface provided by Bitcoin Core to collect unconfirmed transactions, the first call has to obtain hashes of unconfirmed transactions in the mempool presently. Then, the second call retrieves detailed transactions based on these hashes. Due to the time gap between these two calls, part of the transactions may be removed from the mempool, resulting in missing these removed transactions. To collect unconfirmed transactions in real time, we modify Bitcoin Core. Our modified Bitcoin Core5 can monitor the arrival of each transaction, then record transaction details from the moment it enters the mempool until it is confirmed or failed. The arrival of each unconfirmed transaction triggers UTP of a node for recording in real time to ensure that no unconfirmed transactions received by the node are missed.

(2) _How can UTP collect unconfirmed transactions in Bitcoin as many as possible?_ Due to multiple factors such as the decentralized network of Bitcoin, network latency, and bandwidth limitations, unconfirmed transactions received by different nodes might vary. To achieve a comprehensive collection of unconfirmed transactions in Bitcoin, we perform experiments to evaluate the completeness of unconfirmed transactions collected by UTP. We increase the

Figure 3. The number of transactions collected vs. the number of nodes running a modified Bitcoin core.

Figure 2. Our approach for Bitcoin address clustering by combining unconfirmed transactions and confirmed transactions.

number of nodes and measure the number of deduplicated unconfirmed transactions collected per day from May 1, 2022 to May 7, 2022. Figure 3 shows that the number of deduplicated unconfirmed transactions rarely increases when the number of nodes reaches five. That is, UTP can collect approximately all unconfirmed transactions in Bitcoin when deploying five nodes. Therefore, we deploy five nodes, each of which runs a modified Bitcoin Core, to collect all unconfirmed transactions in Bitcoin. Table 1 shows the fields of an unconfirmed transaction in the mempool. In this paper, we focus on seven fields, i.e., _fee, vsize, time, removetime, depends, spentby_, and _replaceable_, which are relevant to subsequent analysis of behavior patterns in unconfirmed transactions. As shown in Table 1, there are additional fields that are not present in confirmed transactions, such as the field _ancestorount_.

Finally, we build a mempool state database for the mempools of five nodes. In the database, we set _time_ and _removetime_ as indexes for each unconfirmed transaction. Given a specific time, the database is able to retrieve all unconfirmed transactions in each mempool at the moment. Note that a transaction output may be spent by multiple unconfirmed transactions. We make two adjustments to the original transaction structure. Specifically, the first field _output.is_, spent_, a Boolean type, indicates whether the _output_ has been spent by transactions. The second field _output.spent_,_tx_ is a list containing hashes of transactions that spend this _output_.

Since failed transactions are removed from the mempool and no longer exist in Bitcoin, we can simply identify failed transactions by excluding confirmed transactions from unconfirmed transactions.

### Novel Clustering Heuristics

We explore two mechanisms in unconfirmed transactions to design novel clustering heuristics.

**(1) Replace-by-fee (RBF)**(Gupta et al., 2017). It allows a sender to replace his or her unconfirmed transaction by initiating another transaction that pays a higher fee. Due to the limitation of fixed block size, miners give priority to transactions with a higher feenerate (_fee/vsize_) to maximize their profit. Note that a transaction can only be replaced when the field _replaceable_ of the transaction is set to true.

**(2) Unconfirmed transaction dependency chain**(Zhou et al., 2018). The Bitcoin mempool is designed to accept unconfirmed transactions that spend UTXO(s) of other unconfirmed transactions. The user can initiate a new transaction to spend UTXO(s) of his or her unconfirmed transactions. As a result, it is common to form an unconfirmed transaction dependency chain in the mempool. In a dependency chain, each unconfirmed transaction spends UTXO(s) of the preceding unconfirmed transaction, which in turn spends UTXO(s) of another unconfirmed transaction, and so forth. Dependency chains typically form for two reasons. One is that users want miners to store their multiple transactions in the blockchain at one time, without waiting for a transaction to be confirmed before initiating a new one that spends UTXO(s) of the transaction. The other reason is related to a transaction pattern known as Child-Pays-for-Parent (CPF). To incentivize miners to store the parent transaction of a user in the blockchain early, the user can initiate a child transaction that pays a high fee and spends UTXO(s) of the parent transaction.

For the first mechanism, we design a clustering heuristic, _replacement change_ shown in Figure 2, to identify the change address.

**Replacement Change heuristic.** Let \(T\) denote a set of transactions, defined as \(T=\{tx_{1},tx_{2},,tx_{N}\}\) with \(n 2\). We identify the change address if (1) the field _replaceable_ of each transaction in \(T\) is True; (2) transactions in \(T\) spend the same UTXO; (3) fees of transactions in \(T\) increase as the field _time_ increases; and (4) the address appears in the output of each transaction in \(T\) and the amounts received by the address decrease as the field _time_ increases.

This heuristic works for the following reason. In real-world trade of goods, the price of goods is typically negotiated between two parties and does not change arbitrarily. When the sender increases the fee, the amount paid to the recipient remains the same, while the amount received by the change address decreases. As shown in Figure 4, _tx2_, _tx3_, and _tx4_ all attempt to spend the 0.35 BTC in _addr1_. When the fee increases, the amount received by _addr2_ remains the same, and the amount received by _addr3_ decreases. Therefore, we can identify _addr2_, which consistently receives the same amount, as the recipient address, and identify _addr3_, which receives a gradually smaller amount, as the sender's change address.

For the second mechanism, we design another clustering heuristic, _dependency chain_ shown in Figure 2, for the unconfirmed transaction dependency chain.

**Dependency Chain heuristic.** Let \(T\) denote a sequence of unconfirmed transactions, defined as \(T= tx_{1},tx_{2},,tx_{n}\) with \(n 2\).

 
**Name** & **Content** \\ 
1 &  kid \\ wtsid \\ inputs \\ outputs \\  & 
 hash of transaction, not including witness data. \\ hash of transaction, including witness data. \\ the inputs of transaction. \\ the outputs of transaction. \\  \\
2 &  \\ few \\ vsize \\  & 
 transaction fee in BTC \\ virtual transaction size \\  \\
3 & 
 weight \\ transaction weight \\  \\
3 &  time & 
 local time when the transaction enters mempool \\  \\
3 &  time when the transaction is removed \\ height\({}^{*}\) \\  & 
 block height when transaction enters mempool \\  \\
4 &  descendantcount\({}^{*}\) \\  & 
 number of descendant transactions \\  \\
4 &  descendantsize\({}^{*}\) \\  & 
 size of descendant transactions \\  \\
4 &  descendantsize\({}^{*}\) \\  & 
 modified fees of descendant transactions \\  \\
4 &  ancestorcount\({}^{*}\) \\  & 
 number of ancestor transactions \\  \\
4 &  ancestorsize\({}^{*}\) \\  & 
 modified fees of ancestor transactions \\  \\
4 &  descendantsize\({}^{*}\) \\  & 
 unconfirmed transactions used as inputs \\  \\
5 &  **spentby\({}^{*}\)** \\  & 
 unconfirmed transactions spending outputs \\  \\
6 &  replaceable\({}^{*}\) \\  & 
 whether this transaction could be replaced \\  \\  

* Fields with a star (\({}^{*}\)) are only present in unconfirmed transactions.

Table 1. Fields of an unconfirmed transaction.

Figure 4. Example of _replacement change_ heuristic.

Each transaction \(tx_{k}\) in the range \(2 k n\) spends partial outputs of the previous transaction \(tx_{k-1}\), denoted as \(O_{k-1}\). Considering that \(tx_{1}\) is the first transaction and spends outputs of confirmed transactions, we use \(O_{0}\) to represent all inputs of \(tx_{1}\). For every \(k\) in the range \(2 k n\), if (1) the hash of \(tx_{k}\) is in the field _spenthy_ of \(tx_{k-1}\); or (2) the hash of \(tx_{k-1}\) is in the field _depends_ of \(tx_{k}\), all transactions in \(T\) are initiated by one same entity, i.e., \(_{k=0}^{n}O_{k}\) are all controlled by the same entity.

This heuristic works for two reasons. First, in the design of popular Bitcoin wallets like Binance, Coinbase, Electrum, and BlueWallet, users can view and spend UTXO(s) of unconfirmed transactions initiated by themselves. To protect funds for users, these wallets do not allow users to view and spend UTXO(s) sent to them in the unconfirmed transactions initiated by others. Second, a Bitcoin transaction is considered irreversible after the blockchain receives six new blocks. Therefore, for commercial trades, users do not use unconfirmed transactions as an indicator of fund arrival and do not spend UTXO(s) of unconfirmed transactions. Instead, they have to wait for new blocks to ensure the security and irreversibility of the transactions. As a result, transactions between different entities do not form an unconfirmed transaction dependency chain.

As shown in Figure 5, we can identify two dependency chains: (\(tx_{1}\), \(tx_{2}\), \(tx_{4}\)) and (\(tx_{1}\), \(tx_{2}\), \(tx_{3}\)), while the three transactions \(tx_{1}\), \(tx_{3}\) and \(tx_{6}\) and the two transactions \(tx_{1}\) and \(tx_{3}\) do not form a dependency chain. Applying this new heuristic, we can cluster \(\{addr_{0},addr_{1},addr_{3}\}\) into the first entity and \(\{addr_{0},addr_{1},addr_{4}\}\) into a second entity. These two entities can be further merged into a larger entity due to the common address \(addr_{0}\) in both clusters.

## 4. Evaluation

To evaluate the effectiveness of our approach, this section presents the experimental results to address three key issues as follows:

1. **Clustering result validation.** Is the clustering result of our approach accurate, and does our approach possess the capability to uncover additional address associations? (Section 4.3)
2. **Impact measurement.** How much impact does our approach have on the clustering results of the SOTA clustering heuristics? (Section 4.4)
3. **Temporal analysis.** What pattern does the impact of our approach show across different periods? (Section 4.5)

### Dataset

We collect a total of 116,514,258 unconfirmed transactions (from May 1, 2022 to May 31, 2023). Among these, 113,296,795 (97.24%) unconfirmed transactions become confirmed transactions, while the rest of them become failed transactions. These confirmed transactions involve 179,352,220 Bitcoin addresses, while the failed transactions involve 12,366,745 Bitcoin addresses, 843,892 of which are not recorded in any confirmed transactions. As shown in Appendix A, we perform two case studies on these unconfirmed transactions. Both demonstrate the presence of behavior patterns in unconfirmed transactions, while not present in confirmed transactions.

### Baseline

As shown in Figure 2, we employ six SOTA clustering heuristics as the baseline.

**Co-spend** (short for CS) considers all inputs of a transaction are controlled by the same entity if the transaction is not a Coinjoin transaction. We use the algorithm developed by Goldfeder _et al._(Goldfeder et al., 2016) to determine whether a transaction is a Coinjoin transaction.

**Androulaki _et al._** (short for A) (A) identify the change address of a transaction sender if (1) the transaction must have exactly two outputs; and (2) the address is the only _fresh_ address in the outputs, meaning that it has not been previously used in the blockchain.

**Meiklejohn _et al._** (short for M) (Makel et al., 2016) identify the change address of a transaction sender if (1) the transaction is not a coinbase transaction; (2) the address is the only _fresh_ address in the outputs; and (3) there is no address used as both an input and an output in this transaction.

**Goldfeder _et al._** (short for G) (Goldfeder et al., 2016) utilize the criteria established by Meiklejohn _et al._(Makel et al., 2016), but they also add a further condition: (4) the transaction cannot be a Coinjoin transaction.

**Ermilov _et al._** (short for E) (Goldfeder et al., 2016) identify the change address of a transaction sender if (1) the number of inputs is not two; (2) the transaction has exactly two outputs; (3) there is no address used both as an input and an output in the transaction; (4) the address is the only _fresh_ address in outputs; and (5) the amount received by the address is precise to a minimum of four decimal places.

**Kappos _et al._** (short for K) (Makel et al., 2016) identify the change address of a transaction sender if (1) the transaction is a node in a _peel chain_; (2) the amount received by the address is spent and the spent transaction is also a node in the _peel chain_.

To describe experimental results clearly, we assign a name for each clustering result, composed of the heuristic and the state of transactions. The SC clustering result refers to the result of applying one of the SOTA clustering heuristics to confirmed transactions. The SF clustering result refers to the result of applying one of the SOTA clustering heuristics to failed transactions. The NU clustering result refers to the result of applying our proposed clustering heuristics to unconfirmed transactions. We denote the merging of clustering results with a plus sign. For instance, SC-SF represents a merge of SC and SF clustering results under the same heuristic. In cases where no clustering heuristic is applied, we refer to it as None, with each address being considered as an isolated entity.

### Clustering Result Validation

To validate clustering results, we construct a labeled dataset and analyze the clustering results from multiple metrics.

**Labeling method.** Validating clustering results requires the availability of labeled datasets. However, there is no publicly available

Figure 5. Example of _dependency chain_ heuristic.

labeled dataset since Bitcoin is pseudo-anonymous, and the transactions we analyze are relatively recent. Thus, we propose a method for constructing a labeled dataset to validate our clustering results.

The labeling method is based on Bitcoin ordinal inscriptions (Shen et al., 2017). Bitcoin ordinal inscriptions are digital assets created by attaching information to an individual satoshi, the smallest denomination in Bitcoin, through the Ordinals protocol (Shen et al., 2017). Two features are worth noting in this protocol. First, creating an individual ordinal inscription must follow a two-phase procedure: a commit transaction and a reveal transaction (Shen et al., 2017). Thus, both commit and reveal transactions are initiated by the same entity. Second, an ordinal inscription collection consists of a set of individual ordinal inscriptions created by an artist or a group of artists. The parent-child inscription mechanism is utilized to create a collection, with child inscriptions being created exclusively by the owner of the parent inscription, resulting in all children being members of the same collection (Shen et al., 2017). Thus, all ordinal inscriptions of a collection are created by the same entity. In summary, the input addresses of both commit and reveal transactions for each inscription in a collection are controlled by the same entity (see more details in Appendix B.1).

The specific process of the labeling method is given as follows. First, we gather a Bitcoin ordinal inscription collection, defined as \(S=\{o_{1},o_{2},,o_{n}\}\) with \(n 2\). For each ordinal inscription \(o_{k}\) in \(S\), we identify its corresponding commit transaction \(ctx_{k}\) and reveal transaction \(ctx_{k}\). Next, we extract the input addresses of transaction \(ctx_{k}\) and \(ctx_{k}\) in the range \(1 k n\), denoted as \(l_{k}\). Finally, we consider \(_{k=0}^{n}l_{k}\) are controlled by the same entity.

For this paper, we gather 20 collections (entities) from the website (Shen et al., 2017) and label 62,971 addresses as the validation dataset. Specific details of the dataset are described in Appendix B.2.

**Validation metrics.** We measure clustering results from two aspects. First, we show the number of entities successfully identified (\(N\)). Second, we evaluate the quality of addresses in each identified entity through four metrics: Precision (\(P\)), Recall (\(R\)), Weighted Precision (\(WP\)), and Weighted Recall (\(WR\)). The first two metrics are commonly used in the study (Bahdanau et al., 2016), while the last two metrics are introduced in the study (Shen et al., 2017). The definitions of these four metrics are as follows, where \(m\) denotes the total number of entities, i.e., 20, and \(E_{i}\) denotes \(i\)th entity. Addresses of \(E_{i}\) are clustered into \(n\) clusters, with \(c_{ij}\) representing the \(j\)th cluster of \(E_{i}\). We denote the union of these clusters as \(C_{i}\). We use the set \(v_{ij}\) to denote the addresses of \(E_{i}\) that are clustered into the cluster \(c_{ij}\). We denote the union of \(v_{ij}\) as \(V_{i}\). \(v_{ij}\) represents the proportion of the set \(c_{ij}\) within entity \(E_{i}\). The greater the number of addresses within a cluster, the more accurately it reflects the characteristics of the entity and, thus, the higher its significance in the clustering results.

\[P=^{m}|V_{i}|}{_{i=1}^{m}|C_{i}|}, R= ^{m}|V_{i}|}{_{i=1}^{m}|E_{i}|}\] \[WP=_{i=1}^{m}_{j=1}^{n}w_{ij}|}{| C_{i}|}, WR=_{i=1}^{m}_{j=1}^{n}w_{ij}|}{|E_{ i}|}\]

where \(v_{ij}=E_{i} c_{ij}\), \(V_{i}=_{j=1}^{n}w_{ij}\), \(C_{i}=_{j=1}^{n}c_{ij}\), \(w_{ij}=|}{|C_{i}|}\).

**Validation results.** Table 2 demonstrates the effectiveness of our proposed clustering heuristics compared to the SOTA clustering heuristics. Our proposed clustering heuristics identify more entities while achieving a precision of over 90%. Notably, our proposed heuristic significantly improves recall. Even in the cases of CS+M and CS+G, where the improvement is the smallest, our proposed clustering heuristics still improve recall by three times. This indicates that our proposed clustering heuristics can uncover many additional address associations that are beyond the scope of the SOTA clustering heuristics. Both weighted precision and weighted recall exhibit a significant improvement, further showing our proposed clustering heuristics can uncover additional address associations and identify more addresses belonging to the same entity. Significantly, the results for both CS+M and CS+G are identical. This is because CS already achieves the exclusion of Coinjoin transactions, which is the sole distinction between CS+G and CS+M.

### Impact Measurement

Building upon the demonstrated effectiveness of our proposed clustering heuristics in Section 4.3, we proceed with measuring their impact on the SC clustering results.

**Settings.** We apply the SOTA clustering heuristics to failed transactions and our proposed clustering heuristics to unconfirmed transactions to uncover additional address associations. When no clustering heuristic is applied, we consider each address in the confirmed transactions between May 1, 2022 and May 31, 2023 as an isolated entity, resulting in a total count of 179,352,220 isolated entities.

**Measurement metric.** We employ the reduced number of entities in the clustering results as the metric to measure the impact of our approach. Suppose the SOTA clustering heuristics cluster addresses of an entity into \(n\) clusters, denoted as \(\{C_{1},C_{2},,C_{n}\}\) with \(n 2\). Our proposed clustering heuristics produce an additional cluster, denoted as \(C_{n+1}\). If \(C_{n+1} C_{i}\) for \(i\) in the range \(1 i n\), \(C_{n+1}\) can merge these \(n\) clusters, resulting in a reduced number of entities. It is worth noticing that \(C_{i}\) may contain only one Bitcoin address for \(i\) in the range \(1 i n\). Therefore, the reduction in the number of entities reflects the ability of our approach to reduce the error of addresses that should belong to the same entity being clustered into multiple entities.

**Measurement results.** Figure 6(a) shows the impact of failed transactions on the SC clustering results. The SC+SF clustering result has a reduced number of entities compared to the SC clustering result across various SOTA clustering heuristics. Notably, the most

   Heuristics & N & P(\%) & R(\%) & WP(\%) & WR(\%) \\  CS & 8 & 0.09 & **4.47** & 7.37 & 2.81 \\ CS+NU & 18 & 94.27 & **74.32** & 42.23 & 18.73 \\  CS+A & 10 & 26.89 & **3.93** & 14.11 & 2.85 \\ CS+A-NU & 10 & 94.49 & **95.58** & 35.53 & 18.24 \\  CS+M & 12 & 55.29 & **11.84** & 11.75 & 0.24 \\ CS+M-NU & 15 & 90.29 & **52.04** & 27.89 & 6.23 \\  CS+G & 12 & 55.29 & **11.84** & 11.75 & 0.24 \\ CS+G+NU & 15 & 90.29 & **52.04** & 27.89 & 6.23 \\  CS+E & 9 & 35.43 & **4.96** & 11.96 & 2.81 \\ CS+E+NU & 19 & 94.58 & **73.87** & 42.15 & 18.74 \\  CS+K & 12 & 75.21 & **12.46** & 12.52 & 8.32 \\ CS+K+NU & 16 & 90.43 & **77.53** & 27.72 & 16.28 \\   

Table 2. Comparison between our proposed clustering heuristics and SOTA clustering heuristics.

significant reduction is observed in the result of the CS heuristic, with a reduction of 1,770,474 entities (2.41% of the total entities). This highlights that failed transactions contain additional address associations that can be uncovered by the SOTA clustering heuristics but are currently ignored.

Figure 6(b) shows the impact of our proposed clustering heuristics on the SC clustering results. The SC+NU clustering result has significantly fewer entities than the SC clustering result across various clustering heuristics. Notably, the CS+M clustering result is the most affected, with a reduction of 9,377,248 entities (21.01% of the total entities). This indicates that our proposed clustering heuristics reveal numerous address associations in unconfirmed transactions that are beyond the scope of the SOTA clustering heuristics.

Figure 6(c) shows the comprehensive impact of both failed transactions and our proposed clustering heuristics on the SC clustering results. The results indicate that a portion of the SF clustering results and NU clustering results exhibit no overlap, further reducing the number of entities. The CS+M clustering result is the most affected, with a reduction of 10,214,920 entities (22.89% of the total entities). Our approach utilizes failed transactions and our proposed clustering heuristics to uncover numerous additional address associations, significantly improving the SC clustering results.

### Temporal Analysis

Considering that the state of a transaction changes over time, and UTP and CTC capture distinct state information about the same transaction at different moments, our approach has varying degrees of impact on the SC clustering results across different periods. In the following, we conduct a monthly temporal analysis of our approach's impact on the SC clustering results in different periods. Moreover, we also measure this impact by the reduced number of entities in the clustering results.

First, as shown in Figure 7, our approach has the most significant impact on the SC clustering results in the current month, and the impact on other months decreases month by month. Notably, we observe that the clustering results of our approach in the current month have a more significant impact on the SC clustering results in the subsequent month compared to the previous month. This is primarily attributed to the fact that unconfirmed transactions collected by UTP in the current month may be confirmed in the subsequent month, thus leading to a more significant impact on the SC clustering results in the subsequent month.

Second, as shown in the diagonal, the impact of our approach exhibits a growing trend over time, indicating its enduring effect. Notably, the impact experiences a significant enhancement in January 2023. Our analysis attributes this phenomenon primarily to the emergence and widespread adoption of Bitcoin ordinal insertions in January 2023 (Mikolov et al., 2013). When users create a collection of ordinal inscriptions, they often utilize unconfirmed transaction dependency chains to create numerous ordinal inscriptions at the same time.

## 5. Discussion

### The impact of Coinjoin transactions on clustering heuristics

Coinjoin transactions render the SOTA clustering heuristics ineffective. However, our proposed clustering heuristics utilize replacement transactions and unconfirmed transaction dependency

Figure 6. Comparison of the number of entities in the SC clustering result and other three clustering results. While an isolated entity contains only one Bitcoin address, a non-isolated entity contains multiple Bitcoin addresses.

Figure 7. Temporal impact of our approach on the SC clustering results.

chains. To ensure timely transaction confirmation, users avoid employing Coinjoin transactions to facilitate operations in both cases. Furthermore, the _replacement transaction_ heuristic identifies the change address definitely, unlike the SOTA clustering heuristics, which may produce false positives.

**False positive of our proposed clustering heuristics.** The _dependency chain_ heuristic may produce false positives under the following specific situation. To accelerate the confirmation of a transaction, the sender transmits the transaction hash and the corresponding UTXO to the recipient before the transaction is confirmed. The recipient then utilizes this UTXO to initiate a new transaction, forming an unconfirmed transaction dependency chain. In this dependency chain, the Bitcoin addresses involved are not controlled by the same entity. However, this situation remains infrequent due to its potential association with unconfirmed transaction attacks, a subtype of double-spend attacks.

**Labeled dataset construction.** With the development of third-party platforms (no-code inscription tools) for Bitcoin ordinal inscriptions, users often use these platforms to create ordinal inscription collections for convenience. In this situation, a third-party platform creates multiple collections on behalf of users. Consequently, all input addresses for the ordinal inscription creation transactions in these collections are controlled by the third-party platform. While this situation introduces certain imperfections into the labeled dataset we construct, the address associations within each entity in our dataset remain accurate. Furthermore, a significant portion of ordinal inscription collections in our dataset are created in the early days when Bitcoin ordinal inscriptions are prevalent, predating the development of third-party platforms. Therefore, our dataset is minimally affected by this situation.

**User privacy leakage in unconfirmed transactions.** The experimental results in Section 4 reveal that unconfirmed transactions can significantly reduce the anonymity of Bitcoin, but it ultimately benefits Bitcoin users by motivating further research into privacy protocols for the mempool. Individuals who are worried about protecting their privacy may opt to cryptocurrencies that prioritize privacy, such as Zcash. However, prior studies demonstrate that even these cryptocurrencies do not guarantee complete anonymity (Kallurkar et al., 2016; Kallurkar et al., 2016).

## 6. Related Work

### Clustering Bitcoin Addresses

Many studies attempt to achieve de-anonymization by proposing various clustering heuristics. The SOTA clustering heuristics can generally be categorized into two main groups: the co-spend heuristic and the change heuristic. The co-spend heuristic, observed in the white paper (Sandvikumar et al., 2016), is applied in many studies (Bahdanau et al., 2015; Kallurkar et al., 2016; Kallurkar et al., 2016; Kallurkar et al., 2016). On the basis of the co-spend heuristic, Kalodner _et al._(Kallurkar et al., 2016) propose to reduce clustering interference caused by Coinjoin transactions. Then, Meiklejohn _et al._(Meiklejohn et al., 2016) and Androulaki _et al._(Bahdanau et al., 2015) propose the change heuristic to determine which transaction output is the address to receive change. Goldfeder _et al._(Goldfeder et al., 2016) and Ermilov _et al._(Ermilov et al., 2016) further refine this heuristic. The change heuristic has been used in multiple studies to track illicit final flows (Kallurkar et al., 2016; Kallurkar et al., 2016; Kallurkar et al., 2016; Kallurkar et al., 2016; Kallurkar et al., 2016; Kallurkar et al., 2016; Kallurkar et al., 2016). Recently, Kappos _et al._(Kappos et al., 2016) consider the transaction pattern _peel chain_ to identify the change address.

There are also studies on analyzing the effectiveness of various clustering heuristics (Bahdanau et al., 2015; Kallurkar et al., 2016; Kallurkar et al., 2016; Kallurkar et al., 2016; Kallurkar et al., 2016; Kallurkar et al., 2016). Cazabet _et al._(Cazabet et al., 2016) highlight that only employing the co-spend heuristic has a relatively low recall but a high precision. Nick _et al._(Nick et al., 2016) assess the accuracy of various clustering heuristics using a ground-truth dataset and find that, on average, over 69% of an entity's addresses could be successfully clustered using only the co-spend heuristic. Zheng _et al._(Zheng et al., 2016) demonstrate that the existing clustering heuristics do not guarantee the comprehensiveness, accuracy, and efficiency of the clustering results. Liu _et al._(Liu et al., 2016) point out that all clustering heuristics rely on confirmed transactions stored in the blockchain. In this paper, we propose two clustering heuristics to uncover additional address associations in unconfirmed transactions.

### Analyzing Bitcoin Mempool

Related studies focus on two issues: predicting the transaction confirmation time and analyzing unconfirmed transactions.

**Predicting the transaction confirmation time.** Many studies (Bahdanau et al., 2015; Kallurkar et al., 2016; Kallurkar et al., 2016; Kallurkar et al., 2016; Kallurkar et al., 2016) propose various methods to estimate the confirmation time. Gundlach _et al._(Gundlach et al., 2015) predict the confirmation time of Bitcoin transactions by modeling the confirmation time as the time to ruin of a Cramer-Lundberg (CL) model. Ko _et al._(Kallurkar et al., 2016) and Zhang _et al._(Zhang et al., 2016) employ machine learning techniques to predict confirmation time of unconfirmed transactions, taking into account various factors such as the confirmation time of historical transactions, block states, and mempool states.

**Analyzing unconfirmed transactions.** Saad _et al._(Saad et al., 2016; Kallurkar et al., 2016) investigate the impact of DDoS attacks on the mempool size and the fees paid by users. Meanwhile, Dae-Yong _et al._(Cazabet et al., 2016) examine the variation of unconfirmed transactions in different mempools through the Jaccard similarity index. They find that unconfirmed transactions in mempools are significantly different when a new block is produced. Kallurkar _et al._(Kallurkar et al., 2016) focus on statistics of failed transactions and the primary reasons for the transaction failure. Furthermore, they point out that the area of failed transactions remains unexplored. To further explore the impact of the mempool on users, we focus on the user privacy disclosed by unconfirmed transactions (including failed transactions) in the mempool, and design clustering heuristics for unconfirmed transactions.

## 7. Conclusion and Future Work

In this paper, we present a practical approach to cluster Bitcoin addresses by combining confirmed and unconfirmed transactions, significantly improving Bitcoin address clustering. The key idea is to explore specific behavior patterns in unconfirmed transactions and propose two novel clustering heuristics for unconfirmed transactions. Then, we construct a labeled dataset based on Bitcoin ordinal insertion to validate the clustering result, and measure the impact of our approach. Experimental results reveal that our proposed clustering heuristics can uncover additional address associations and reduce the error of addresses controlled by the same entity being clustered into multiple entities.

In future, we aim to extend our analysis to other cryptocurrencies based on the UTXO model, such as Litecoin and Dogecoin. We will also analyze the Ethereum mempool and use the mempool data to explore the traceability of funds under the account-balance model.