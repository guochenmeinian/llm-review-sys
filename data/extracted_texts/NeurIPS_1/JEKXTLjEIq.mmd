# Binary Search with Distributional Predictions

Michael Dinitz

Johns Hopkins University

mdinitz@cs.jhu.edu

Supported in part by NSF awards 1909111 and 2228995.

Supported in part by NSF awards 1844939, 2121745, and 2423106, and by ONR grant N00014-22-1-2701.

[MISSING_PAGE_POST]

want to inherit the traditional worst-case guarantee. In other words, we want the best of both worlds: good performance in the average case thanks to machine learning, but also robustness and good performance in the worst-case from traditional algorithms.

Consider the basic problem of searching for a key in a sorted array. This problem is the first example considered in the survey of Mitzenmacher and Vassilvitskii (2021), as it is perhaps one of the simplest yet also best-motivated settings. Given a sorted array with \(n\) elements and a target key \(i\), we can of course do a binary search for \(i\) using only \(O( n)\) comparisons to find its location \((i)\). But suppose that we additionally receive a _prediction_\((i)[n]\) of the location of the target key \(i\) in the array, possibly from some machine learning system which attempts to predict the correct location for each key. If the prediction is perfect (\((i)=(i)\)), then it is easy to use this prediction: only one comparison is needed! On the other hand, if the prediction is meaningless, then we can run classical binary search. But what if the prediction is "close"? It turns out that "doubling binary search" from the predicted point can be used to design an algorithm which makes at most \(O((|(i)-(i)|))\) comparisons (Mitzenmacher and Vassilvitskii, 2021). So if the prediction is very close to the true location then we make very few queries, while if it is very far away then we recover the traditional binary search comparison bound.

The ability to obtain these types of results has led to an explosion of interest in algorithms with predictions; see Section 1.2 for some references. Sometimes the prediction itself is simple, as in the search problem, while sometimes it is quite complex, for instance encompassing a multi-dimensional vector. However, with only a few exceptions such as Diakonikolas et al. (2021); Angelopoulos et al. (2024), which will be discussed in Section 1.2 in detail, all of these papers share an important feature: the prediction itself is non-probabilistic. That is, the prediction is a single (potentially high-dimensional) point (or maybe a small number of such points). While making the setting simpler, this is not a good match with the actual output of most ML systems (particularly modern neural networks), which inherently output a _distribution_. The question we study in this work is how to take advantage of the full richness of the prediction. Of course, we can always turn a distribution into a single point in any number of ways (using a max likelihood estimator (MLE), sampling from the distribution, etc.). But is that always the right thing to do? Or, can we in fact do _better_ by taking full advantage of the entire predicted distribution?

### Our Results and Contributions

In this paper we initiate the study of algorithms with _distributional predictions_, focusing on the basic search in a sorted array problem described above. In addition to the classic \(O( n)\) comparisons binary search for an array of size \(n\), we recall the "median" or "bisection" algorithm (first described by Knuth (1971) and analyzed by Mehlhorn (1975)) which probes the cell representing the median of the distribution, and recurses appropriately. When the target keys are indeed drawn from the given distribution, the expected query complexity (i.e. number of comparisons between elements in the array and the target) is bounded by \(H(p)+1\), where \(H(p)\) is the entropy of the distribution (Mehlhorn, 1975). (Note that when the distribution is uniform over \(n\) elements, this recovers the \(O( n)\) binary search bound). This is in fact essentially optimal: it is known that every algorithm requires at least \(H(p)/3\) queries in expectation when target keys are drawn from \(p\)(Mehlhorn, 1975).

On the other hand, it is easy to see that if target keys are _not_ drawn from \(p\), then this algorithm can be arbitrarily bad: it can easily be made to use \((n)\) comparisons in expectation. So our main question is the following: how can we best utilize a prediction \(\) which is _not_ the true distribution \(p\)? Can we recover the near-optimality of the median algorithm without being subject to its worst-case performance?

Reduction to point distributions.We first show in Section 2.1 that the obvious approach, of reducing \(\) to a point prediction (whether by sampling, using a max-likelihood prediction, or some other method) and then using previous algorithms, is a bad idea that can lead to poor worst-case performance. In addition to ruling out a natural class of algorithms, this gives additional motivation to our study of distributional predictions: as discussed, essentially all previous work studies the case in which the prediction is a single point (in this case, location); yet, most machine-learning systems will actually output a distribution. So our lower bound implies that any of these traditional point-based algorithms, no matter how good the bound obtained compared to their prediction, must suffer fundamentally poor performance in the real world where target keys actually come from a distribution.

Main algorithm.We then give our main result in Section 3: an algorithm which interleaves phases of the "median" algorithm and classical binary search to obtain a query complexity of \(O(H(p)+)\), where \(\) is the earth mover's distance (EMD, also known as the Wasserstein \(W_{1}\) metric) between \(p\) and \(\), See Section 3 for precise details. Note that \(H(p) O( n)\) and \( n\). So if our prediction \(\) is close to \(p\), then our algorithm has performance essentially equal to the best possible bound \(H(p)\). On the other hand, if our prediction \(\) is far from \(p\) (so provides essentially no information), we do not suffer the poor performance of naively believing in \(\) and running the median algorithm on it, instead recovering a bound of \(O(H(p)+)=O( n)\).

While there are many notions of "distance" between distributions, EMD is a natural one in our setting. Many other notions of distance, like \(_{1}\), do not take the geometry of the line into account. For example, consider some distribution \(p\) over \([n]\), and let \(p^{}\) be the distribution obtained from \(p\) by moving \(/2\) probability mass from \(1\) to \(2\), and let \(p^{}\) be the distribution obtained from \(p\) by moving \(/2\) probability mass from \(1\) to \(n\). Then the \(_{1}\) distance between \(p\) and \(p^{}\) is \(\), and so is the \(_{1}\) distance between \(p\) and \(p^{}\). Yet clearly \(p^{}\) is a "more accurate" prediction for \(p\). The earth mover's distance recognizes this fact, and so is a more appropriate measure than \(_{1}\). Similarly, popular measures such as KL-divergence (which are not technically metrics, but do give a notion of distance) suffer the same flaws as \(_{1}\) while also being extraordinarily sensitive to mismatches in the support (the KL-divergence can be infinite if the supports of the two distributions do not agree).

Distributional Robustness of Optimal Binary Search Trees.We have so far discussed a distributional prediction setting where a target key arrives with a predicted distribution \(\) of its location. This is a strict generalization of Mitzenmacher and Vassilvitskii (2021), where the prediction is a single location in the array. In their model, the location is error prone and in ours the distribution over locations is error prone. Our goal is to construct an effective search strategy given the target and the prediction.

But there is another related setting: there is a single (unknown) distribution over target keys, and we are given a (possibly erroneous) prediction of this distribution and are asked to design a search algorithm with minimum expected lookup time when target keys are drawn from the true distribution. In other words, instead of each target key coming with a predicted distribution \(\) over _locations_ in \([n]\) and the true location being drawn from some true distribution \(p\), we are given ahead of time a predicted distribution \(\) over _target keys_\([n]\), and are asked to design a lookup algorithm for inputs that use this distribution. But then these target keys in the input are actually drawn from \(p\) rather than \(\), and do not come with target-specific predictions.

Since any comparison-based search algorithm is equivalent to a particular binary search tree, if \(=p\) then this is precisely the classical problem of computing an _optimal binary search tree_(Mehlhorn, 1975). So we can interpret our results as providing distributionally-robust optimal BSTs: given \(\), we can efficiently compute a BST where the expected lookup time under the true (but unknown) query distribution \(p\) is at most \(O(H(p)+)\). Surprisingly, given the classical nature of computing optimal (or near-optimal) BSTs, this simple question of "what if my distribution is incorrect?" has not been considered in the data structures and algorithms literature.

Worst case lower bound.We complement our algorithmic development with a lower bound in Section 3.2, proving that no algorithm can use fewer than \(()\) queries in the worst case. Since \((H(p))\) is a known lower bound as well even if \(p\) is known perfectly (Mehlhorn, 1975), this implies that our algorithm is asymptotically tight. So if we measure accuracy of the prediction via EMD, no algorithm can make asymptotically better use of a distributional prediction.

Portfolios of predictions.There has been recent interest in the study of algorithm with _multiple_ predictions, sometimes called prediction _portfolios_. See, for example, (Balcan et al., 2021; Dinitz et al., 2022; Anand et al., 2022; Kevi and Nguyen, 2023). The goal is usually to do as well as the _best_ of the predictions in the portfolio, with the difficulty being that we do not know _a priori_ which of these predictions is best. We extend our main algorithm to this setting in Section 4, showing that it is possible to use _multiple_ distributional predictions effectively.

Experiments.Finally, in Section 5 we give empirical evidence of the efficacy of the algorithm we propose. We first use synthetic data to demonstrate the effect of distribution error on the performance of the algorithm. We then evaluate it on a number of real world datasets.

### Other Related Work

Machine learning augmented algorithms have found applications in various areas -- for example, online algorithms (Lykouris and Vassilvitskii, 2021; Purohit et al., 2018), combinatorial algorithms (Dinitz et al., 2021; Davies et al., 2023), differential privacy (Amin et al., 2022), data structures (Lin et al., 2022; Vaidya et al., 2021; McCauley et al., 2024; Mccauley et al., 2024) and mechanism design (Agrawal et al., 2022), to name a few. In particular, online algorithms have been extensively studied with ML advice for various problems, such as online caching (Lykouris and Vassilvitskii, 2021), ski-rental (Purohit et al., 2018), scheduling (Lattanzi et al., 2020), knapsack (Im et al., 2021), set cover (Bamas et al., 2020), and more (Lindermayr and Megow, 2022). Due to the vast literature, we only provide a few samples.

Particularly relevant to our setting is the work of Lin et al. (2022), which initiated the study of predictions for binary search trees. This work investigates how to improve a treap's guarantees when item frequencies follow distributions such as the Zipfian distribution.

As discussed earlier, in ML augmented algorithms, predictions are typically given in the form of specific values, rather than distributions. Here, we discuss a few exceptions. The work by Diakonikolas et al. (2021) studies the ski-rental problem and prophet inequalities with access to i.i.d. samples from an unknown distribution. Their focus lies on the sample complexity and not on the correctness of the distribution. Indeed, they obtain robustness by combining their consistent algorithm and the best worst-case algorithm in a black-box manner. In contrast, we assume full access to a distributional prediction and develop new ideas to obtain a tight trade-off between consistency and robustness, in conjunction with natural error measures involving entropy and the earth mover's distance, which take the accuracy of the distributional prediction into account.

More broadly the question of how to improve performance of problems where either full instances, or some model parameters come from a known distribution is well studied under the rubric of two-stage stochastic optimization (Swamy and Shmoys, 2006; Ahmed, 2010), with techniques like Sample Average Approximation (SAA) (Kim et al., 2015) having a rich history. Similar to our setting, one can look at the robust setting, where the distribution available to the algorithm is different from the true distribution that examples are drawn from, see e.g., (Bertsimas and Goyal, 2010; Dutting and Kesselheim, 2019; Bertsimas et al., 2022; Besbes et al., 2022). Typically in these cases one assumes a bound on the difference between the two distributions, explicitly choosing what to hedge against, and then derives optimal strategies. In contrast, in this work we aim to find a smooth trade-off on the performance of the algorithm as a function of the distance between the two distributions, coupled with an upper bound on worst-case performance.

Finally, the very recent work of Angelopoulos et al. (2024) is one of the few that consider distributional predictions. It shows an optimal tradeoff between consistency and robustness for a scheduling problem. However, their solution space explored is considerably more limited than ours, essentially consisting of geometric sequences with a multiplicative ratio of 2, each characterized by its starting point. Further, their bound analysis is restricted to cases where the error is sufficiently small. In contrast, our work demonstrates how a binary search algorithm can compare generally to earth mover's distance (EMD) and a lower bound on the optimum for any predicted distribution. As a result, we develop novel algorithmic solutions that build upon a close connection to EMD.

## 2 Preliminaries

We now formally describe our problem and setting. Let \(a_{1}<<a_{n}\) be a set of \(n\) keys, and \(p=(p_{1},,p_{n})\) be a probability distribution over the keys. Our goal is to develop a search strategy (or search algorithm), which takes a target key \(a\) as input, and finds a position \(i\) such that \(a_{i}=a\). We aim to find search strategies with low expected search cost when the target key \(a\) is sampled according to the distribution \(p\). In our analysis we will consider the number of comparisons, also known as the _query complexity_, as the main metric of study. This metric captures the information theoretic complexity of the problem, and ignores computational overhead. Formally, let the search cost \(C(a_{i})\) of finding \(a_{i}\) be the number of comparisons done by the algorithm when the target key is \(a_{i}\). The expected search cost is then \(_{i=1}^{n}p_{i}C(a_{i})\).

To aid in this goal, we are given a prediction, \(=(_{1},,_{n})\), of \(p\). To account for the fact that the predicted distribution may be incorrect, we let \(\) denote the earth mover's distance (EMD) between \(p\) and \(\). The EMD between two distributions \(P\) and \(Q\) is the solution to the optimal transport problem between them, or more formally, it is \(_{(P,Q)}_{(x,y)}[d(x,y)]\), where \((P,Q)\) is the set of joint distributions with marginals \(P\) and \(Q\).

Finally, for a distribution \(p\), we let \(H(p)=-_{i=1}^{n}p_{i}(p_{i})\) be the entropy of \(p\). Throughout the paper, all logarithms are in base 2.

Given the breadth of work on point predictions, it is tempting to try and reduce the distributional prediction problem to point predictions. We show that this approach does not lead to good results.

### Point Predictions from Distributions

Given prediction \(\) of \(p\), suppose the algorithm first computes some point \(\) from \(\) and then uses the doubling binary search algorithm from Mitzenmacher and Vassilvitskii (2021) with prediction \(\). This will have expected running time of \(O((|-|))\), where \(\) is the true location of the key. A natural question is whether there is some \(\) so that \(O((|-|))\) is comparable to \(O(H(p)+)\).

Unfortunately, this is not possible, necessitating our more involved algorithm and analysis. Let \(p\) be the distribution on two atoms, with \(p_{n/4}=1/2\) and \(p_{3n/4}=1/2\), and let \(=p\). Clearly \(=0\), and \(H(p)=1\), so any competitive algorithm must terminate after a constant number of comparisons in expectation. On the other hand, consider some \([n]\). If \( n/2\), then since \(=3n/4\) with probability \(1/2\) we have that \([(|-|)](n/4))=( n)\). Similarly, if \( n/2\), then since \(=n/4\) with probability \(1/2\) we have that \([(|-|)]( n)\). Hence converting \(\) to a point prediction and then using the algorithm of Mitzenmacher and Vassilvitskii (2021) as a black box is doomed to failure.

## 3 Algorithm

To develop our robust approach, recall the two baseline algorithms--traditional binary search with an \(O( n)\) running time and the algorithm that recurses on the median element of the distribution, with an \(O(H(p))\) running time (assuming it has access to the true distribution \(p\)).

In our algorithm we interleave these two approaches to get the best of both worlds. Let \(a\{a_{1},,a_{n}\}\) be the target key. We proceed recursively, keeping track of an active search range \([,r]\) (if \(a=a_{i}\), we always have \(i[,r]\)). Initially, we start with \(=1\) and \(r=n\). The algorithm proceeds in iterations. Each iteration \(i\) for \(i=0,1,\) has two phases

* **Bisection.** Divide the search range in half based on the predicted probabilities \(\). Formally, find an index \(k\), \( k r\) such that \(_{j=}^{k-1}_{j}S\) and \(_{j=k+1}^{r}_{j}S\), where \(S=_{j=}^{r}_{j}\). Compare \(a\) to \(a_{k}\). If they are equal, return \(k\). Otherwise, based on the result of the comparison, continue the search on the ranges \([,k-1]\) or \([k+1,r]\). Continue this process for \(2^{i}\) steps, and if \(a\) is not found, begin the second phase.
* **Binary Search at the Endpoints.** Let \([,r]\) be the current search range. Set \(d=(2^{2^{i}},r-)\). Check if \(a\) is in the range \([,+d]\) or \([r-d,r]\) (by comparing \(a\) to \(a_{+d}\) and \(a_{r-d}\)). If \(a\) is in one of these ranges, say \([,+d]\), do a regular binary search (by choosing the middle point of the range each time) on the range \([,+d]\), until \(a\) is found. Otherwise, start the next iteration with the new search range \([+d+1,r-d-1]\).

The algorithm continues until \(a\) is found.

### Analysis

The goal is to show the following theorem with respect to the algorithm.

**Theorem 3.1**.: _The expected query complexity of the described algorithm is at most \(4H(p)+8(()+2,1)+8=O(H(p)+((),0))\).4_

Before formally proving the theorem, we give key intuition about the analysis. In iteration \(k\), the Bisection phase is continued for \(2^{k}\) steps. In each step, one comparison is made, which makes the cost of this phase \(2^{k}\).

Consider the Binary Search at the Endpoints phase. Two comparisons are made during the phase unless \(a[,+d]\) or \(a[r-d,r]\). In those cases, we run a traditional binary search on an interval of length \(d+1\), whose cost is \( d= 2^{2^{k}}=2^{k}\).

For each key \(a_{i}\), it takes at most \((})+1\) iterations of the Bisection phase to get to a search range that has a predicted probability mass of at most \(p_{i}/2\). We can charge the total cost of the iterations up to this point to the term \(p_{i}(})\) in \(H(p)\).

Either we find \(a_{i}\) earlier, in which case the total cost of the iterations can be charged to \(H(p)\), or there is an at least \(p_{i}/2\) mass that was predicted to lie outside the interval, allowing us to lower bound \(\). We make this argument formal below.

Proof of Theorem 3.1.: With probability \(p_{i}\), the target key \(a\) that we are looking for is \(a_{i}\). The goal is to bound the expected cost of the algorithm, which is \(_{i=1}^{n}p_{i}C(a_{i})\), where \(C(a_{i})\) is the cost of the algorithm when \(a=a_{i}\). Let \(k_{i}\) be the first iteration at which \(a\) is found, assuming \(a=a_{i}\). As mentioned earlier, the total cost of the first phase of the iterations 0 to \(k_{i}\) is \(_{j=0}^{k_{i}}2^{j}<2^{k_{i}+1}\). Also, the cost of the second phase in each iteration before \(k_{i}\) is 2, and in iteration \(k_{i}\) is at most \(2^{k_{i}}\). So the total cost of the algorithm for iterations \(0\) to \(k_{i}\) is at most \(3 2^{k_{i}}+2k_{i} 4 2^{k_{i}}\). We partition the keys based on \(k_{i}\) into two sets, and bound the cost of each set separately. Let \(I_{1}:=\{i:k_{i}((4/p_{i}))\}\) and \(I_{2}:=\{i:k_{i}>((4/p_{i}))\}\).

First, we bound the cost of indices in \(I_{1}\) by a constant factor of \(H(p)\):

\[_{i I_{1}}p_{i}C(a_{i}) 4_{i I_{1}}p_{i}2^{k_{i}} 4_{i  I_{1}}p_{i}(4/p_{i}) 4H(p)+8.\]

Now we bound the cost of the indices in \(I_{2}\) by a constant factor of \(()\). Let \(i I_{2}\). We know that during iteration \(j\) of searching for \(a_{i}\), in the Bisection phase, the predicted probability mass in the search range decreases by a factor of at least \(2^{2^{j}}\). Therefore the predicted probability mass in the search range \([,r]\) at the end of the first phase in iteration \(k_{i}-1\) is at most

\[^{k_{i}-1}2^{2^{j}}}=}-1}}=}}}}=}{2},\]

where the inequality holds because \(i I_{2}\). So \(_{j=}^{r}_{j} p_{i}/2\). Let \(D_{i}:=(i-,r-i)\). In the transportation problem corresponding to the earth mover's distance between \(p\) and \(\), a probability mass of at least \(p_{i}/2\) needs to be moved from point \(i\) to the outside of the interval \([,r]\). The cost of this movement in the objective function of the transportation problem is at least \(D_{i} p_{i}/2\). Therefore we have \(_{i I_{2}}D_{i} p_{i}/2\). In the Binary Search at the Endpoints phase of iteration \(k\), we probe indices within distance \(d=2^{2^{k}}\) around the two endpoints of the search range. Since \(a_{i}\) is not found before iteration \(k_{i}\), we conclude that \(2^{2^{k_{i}-1}}<D_{i}\), which means that \(2^{k_{i}} 2(D_{i})\). Let \(p(I_{2}):=_{i I_{2}}p_{i}\). We have

\[_{i I_{2}}p_{i}C(a_{i}) 4_{i I_{2}}p_{i}2^{k_{i}} 8_{i  I_{2}}p_{i}(D_{i})=8(_{i I_{2}}p_{i}(D_{i})+(1-p(I_{2 }))(1)).\]

By concavity of the \(()\) function and Jensen's inequality we have

\[8(_{i I_{2}}p_{i}(D_{i})+(1-p(I_{2}))(1)) 8 (_{i I_{2}}p_{i}D_{i}+(1-p(I_{2}))) 8(()+2,1).\]The last inequality follows from the fact that if \(_{i I_{2}}p_{i}D_{i} 1\) we have \(_{i I_{2}}p_{i}D_{i}+(1-p(I_{2})) 2\), and otherwise we have

\[(_{i I_{2}}p_{i}D_{i}+(1-p(I_{2})))(_{i  I_{2}}p_{i}D_{i})+1(2)+1=()+2.\]

### Lower Bound

It is well known that there is a lower bound of \((H(p))\) on the expected query complexity for binary search (Mehlhorn, 1975). We now show that there is a lower bound of \(()\) on the expected query complexity as well, even on instances with \(H(p)=0\). This shows that there must fundamentally be a \(\) dependence on the earth mover's distance, even for instances where it is not absorbed by the dependence on the entropy.

**Theorem 3.2**.: _For any \([n]\), any comparison-based (deterministic or randomized) algorithm must make \(()\) queries on some instance where \(H(p)=0\) and the earth mover's distance between \(p\) and \(\) is \(O()\)._

Proof.: Thanks to Yao's principle, it suffices to give a distribution over instances of this problem and argue that any deterministic algorithm has a large expectation over this distribution. Let the set of keys be \([n]\). We present a family of problem instances \(I_{1},,I_{}\), where each instance can happen with probability \(\). In instance \(I_{i}\), the true access distribution is a singleton on location \(i\), i.e., in \(I_{i}\) we have \(p_{i}=1\) and \(p_{j}=0\) for each \(j[n]\{i\}\). In all the problem instances \(I_{1},,I_{}\), the prediction is the uniform distribution over \([]\). Note that for each instance \(I_{i}\), we have \(H(p)=0\). Also, the earth mover's distance between \(\) and \(p\) is at most \(\).

Our claim is that any deterministic algorithm has an expected cost of \(()\) over this distribution. To see this, note that the expected cost of any deterministic algorithm over this distribution of instances exactly equals the cost of that algorithm on an instance \(I^{*}\) where the true access distribution is uniform over \([]\). Now by the lower bound of Mehlhorn (1975), the cost of any deterministic comparison-based algorithm on \(I^{*}\) is \((H(p^{*}))\), where \(p^{*}\) is the uniform distribution over \([]\). To conclude the proof, note that \(H(p^{*})=()\). 

Combining Theorem 3.2 with the \((H(p))\) lower bound due to Mehlhorn (1975) results in the following worst-case lower bound, asymptotically matching Theorem 3.1.

**Corollary 3.3**.: _Any comparison-based algorithm for binary search with distributional predictions has worst-case expected query complexity \((H(p)+())\)._

## 4 A Portfolio of Predictions

In the previous section we showed an algorithm that is optimal given a single distributional prediction. Here we extend this result to the setting where there are \(m\) different distributions given as a prediction. That is, for \(k\{1,2,,m\}\), there are predictions \(_{k}=(_{1,k},,_{n,k})\) of \(p\) given. Let \(_{k}\) be the earth mover's distance between \(_{k}\) and \(p\). The goal is to design an algorithm competitive with _single best_ distribution \(_{k}\). That is, comparable to \(_{k[m]}_{k}\) and \(H(p)\).

### Algorithm for Multiple Predictions

We proceed in a similar manner, alternating the two phases. However, we change the algorithm so that in the first phase the algorithm performs a binary search on the medians of each distribution. The goal of this is to ensure that each distribution has its probability mass drop by at least half in each step.

As before, the initial search range is \([1,n]\). The algorithm proceeds in iterations. For \(i=0,1,\), iteration \(i\) has two phases.

* **Bisection.** Let \([,r]\) be the current search range. Let \(S_{k}=_{j=}^{r}_{j,k}\) be the remaining probability mass in the \(k\)'th prediction.

Let \(t_{k}\) be such that \(_{j=t}^{t_{k}-1}_{j,k}S_{k}\) and \(_{j=t_{k}+1}^{r}_{j,k}S_{k}\). That is, \(t_{k}\) is the median of the \(k\)'th distribution. Sort the indices \(k[m]\) so that \(t_{1} t_{2} t_{m}\). For convenience, let \(t_{0}=\) and \(t_{m+1}=r\). Perform a binary search on \(a_{t_{0}},a_{t_{1}},a_{t_{2}}, a_{t_{m+1}}\) to find the interval where \(a(a_{t_{j}},a_{t_{j+1}})\) for some \(j\{0,1,2, m\}\). The new search range is \([t_{j}+1,t_{j+1}-1]\). Continue this for \(2^{i}\) steps, and if \(a\) is not found, begin the second phase described below.
* **Binary Search at the Endpoints.** Let \([,r]\) be the current search range. Set \(d=(2^{2^{i}},r-)\). Check if \(a\) is in the range \([,+d]\) or \([r-d,r]\) (by comparing \(a\) to \(a_{+d}\) and \(a_{r-d}\)). If \(a\) is in one of these ranges, say \([,+d]\), do a regular binary search (by choosing the middle point of the range each time) on the range \([,+d]\), until \(a\) is found. Otherwise, start the next iteration with the new search range \([+d+1,r-d-1]\).

The algorithm continues until \(a\) is found.

### Analysis for Multiple Predictions

We now state the following theorem regarding the algorithm for multiple predictions. The overhead of using multiple predictions is a \( m\) factor. The proof is very similar to the proof of Theorem 3.1 and has been deferred to Appendix A.

**Theorem 4.1**.: _Given \(m\) different distributions, the expected query complexity of the algorithm is \((m) O(H(p)+(_{k[m]}_{k},0))\)._

## 5 Experiments

We now present an empirical evaluation of the proposed algorithms on both synthetic and real datasets. Our goal is to show how predictions can be used to improve the running time of traditional binary search approaches. Since our theoretical results are about query complexity, and to keep the results implementation-independent, our main metric will be the number of comparisons performed by each method. Our implementation can be found at [https://github.com/AidinNiaparast/Learned-BST](https://github.com/AidinNiaparast/Learned-BST).

We compare the performance of the following algorithms:

* The prediction agnostic approach that recursively queries the midpoint of the array.
* The bisection algorithm recursively queries the median of the predicted distribution (when the predicted probability in the search range is 0, this algorithm queries the midpoint of the array). This strategy is nearly optimal when the predicted distribution is correct ; however, it is not robust to errors in the predicted distribution.
* The algorithm described in Section 3. We make one modification, setting the parameter \(d\) larger to broaden the search space in the very early iterations, setting d to \((2^{8 2^{i}},r-)\).
* This is a heuristic approach to make the Bisection algorithm more robust. Given a prediction \(\) we generate a new distribution, \(q=+(1-)u\), where \(u\) is the uniform distribution on \([n]\). We then run the Bisection algorithm on \(q\). In our experiments, \(=0.5\) is used.

### Synthetic Data Experiments

We begin with experiments on synthetic data where we can vary the prediction error in a controlled environment to show the algorithms sensitivity and robustness to mispredictions.

In this setting, let the keyspace be the integers in \([-10^{5},10^{5}]\). We then generate \(t=10^{4}\) independent points from a normal distribution with mean \(0\) and standard deviation \(10\), rounding down each to the nearest integer. This results in a concentrated distribution in a very large key space. The \(t\) points form the predicted distribution, \(\). To generate the test distribution, we proceed in the same manner, but shift the mean of the normal distribution away from \(0\) by some value \(s>0\). Note that for \(s=100\) the train and test distributions have 0 overlap with high probability. For each value of \(s\), we repeat the experiment \(5\) times and report the average and standard deviation of the costs.

Our results for this setting can be found in Fig. 1, where we plot the average search cost (query complexity) of each algorithm against the shift amount for the test distribution. At one extreme, where there is no shift in the test distribution, we observe that all three algorithms which utilize the predicted distribution perform well. Since the bisection algorithm is optimal when the error is 0, it performs the best, as expected, while the Learned BST approach exhibits some overhead due to hedging against possible errors. However, a perturbation to the predicted distribution causes the bisection algorithm to perform worse than classical binary search. Both the convex combination and learned BST algorithms demonstrate a smoother degradation in performance, with our proposed method (learned BST) giving more robust performance to even large shifts in the test distribution. When the error becomes very high, then the additional overhead of the learned BST algorithm makes it slightly worse than the Classic baseline.

### Real Data Experiments

Dataset Description.In order to test our approach on real-world data, we use temporal networks from Stanford Large Network Dataset Collection5. These datasets represent the interactions on stack exchange websites StackOverflow, AskUbuntu, and SuperUser . In all cases, we use the answers-to-questions dataset, which contains entries of the form \((u,v,t)\), which represents user \(u\) answering user \(v\)'s question at time \(t\). In this interaction, \(u\) is the source and \(v\) is the target user. Our data sequences consist of the source users from each interaction sorted in increasing order of timestamp, and we restrict the dataset to the first one million entries.

Keys, Predictions, and Test Data.For each data sequence, the set of elements in the first 10% of the sequence is used as the set of keys of the binary search trees. Let \(A\) be the remaining 90% of the sequence and let \(a_{1}<a_{2}<<a_{n}\) be the set of keys. For each element \(x A\), if \(a_{i} x<a_{i+1}\), we replace \(x\) by \(a_{i}\). For \(t=5,10,,50\), we use the first \(t\) percent of \(A\) as training data and the rest as test data. The training and test data are used to obtain the predictions (\(\)) and actual access distribution (\(p\)), respectively. To obtain these distributions we use the normalized frequencies of each key in the training and test data.

For completeness, we show the distributions of the keys when \(t=50\) both for the training set and the test set in Figure 2.

Figure 1: Results for synthetic data experiments. The y-axis measures the average cost (query complexity) of each algorithm and the x-axis measures the amount of shift in the test distribution. The training and test data are regenerated 5 times. The solid lines are the mean and the clouds around them are the standard deviation of these experiments.

Figure 2: The train and test distributions when \(t=50\) for the three datasets.

We present the results on these experiments in Figures 3 and 4. In Figure 3 we plot the average cost of the algorithms against the size of the training data. As we expect, as the size of the training data increases, the performance of all distribution-dependent algorithms get better, as the distribution error decreases. We make this more precise in Figure 4 where we plot the average cost against log of the EMD error.

We note a few observations. The learning agnostic, Classic, is suboptimal in all but a handful of cases, showing that there is value in using the distribution of the data to improve performance. Second, we validate the theory, showing that the learned BST's performance degrades smoothly as \(\) increases. Third, the convex combination heuristic is not very effective on real world data, giving only marginal improvements over the bisection method.

Finally, on both AskUbuntu and SuperUser datasets, the learned BST approach performs significantly better than all of the baselines, saving 20-25% comparisons on average. Unlike the Bisection algorithm it is also never worse than the Classic baseline. On the StackOverflow dataset our approach is about 10% worse than bisection method, owing to the distribution being less concentrated around the median. In these cases, the overhead of learned BST is apparent, given that the second phase is unlikely to be fruitful in the first few iterations.

Overall, these results show that the Learned BST method is robust against errors, and performs well against other approaches. Further improving the constant factors so that the learned approach has strong worst-case guarantees and performs well against other learned approaches remains a challenging open problem.

## 6 Conclusion

There has been a growing line of work showing how to improve optimization algorithms using machine learned predictions. Predominately, prior work has leveraged non-probabilistic predictions, despite the fact that most ML systems, such as neural networks, output a distribution.

This work introduces a model where the prediction is a distribution. We show that algorithms can perform better by taking full advantage of the distributional nature of the prediction, and that reduction to a point prediction is insufficient to provide competitive algorithms.

Given the breadth of work in the Algorithms with Predictions area Mitzenmacher and Vassilvitskii (2021), there is a wide variety of open questions concerning how to adapt algorithms to the setting of distributional predictions.

Figure 4: Results for real data experiments. The y-axis measures the average cost of each algorithm and the x-axis indicates the logarithm of the earth mover’s distance between \(\) and \(p\).

Figure 3: Results for real data experiments. The y-axis measures the average cost of each algorithm and the x-axis indicates the fraction of the dataset used for training