# Bio-inspired parameter reuse: Exploiting inter-frame representation similarity with recurrence for accelerating temporal visual processing

Bio-inspired parameter reuse: Exploiting inter-frame representation similarity with recurrence for accelerating temporal visual processing

Zuowen Wang  Longbiao Cheng  Joachim Ott  Pehuen Moure  Shih-Chii Liu

Institute of Neuroinformatics, University of Zurich and ETH Zurich

{zuowen, longbiao, jott, pehuen, shih}@ini.uzh.ch

Marco Fumero, Emanuele Rodola, Clementine Domine, Francesco Locatello, Gintare Karolina Dziugaite, Mathilde Caron

###### Abstract

Feedforward neural networks are the dominant approach in current computer vision research. They typically do not incorporate recurrence, which is a prominent feature of biological vision brain circuitry. Inspired by biological findings, we introduce **RecSlowFast**, a recurrent slow-fast framework aimed at showing how recurrence can be useful for temporal visual processing. We perform a variable number of recurrent steps of certain layers in a network receiving input video frames, where each recurrent step is equivalent to a feedforward layer with weights reuse. By harnessing the hidden states extracted from the previous input frame, we reduce the computation cost by executing fewer recurrent steps on temporally correlated consecutive frames, while keeping good task accuracy. The early termination of the recurrence can be dynamically determined through newly introduced criteria based on the distance between hidden states and without using any auxiliary scheduler network. RecSlowFast **reuses a single set of parameters**, unlike previous work which requires one computationally heavy network and one light network, to achieve the speed versus accuracy trade-off. Using a new _Temporal Pathfinder_ dataset proposed in this work, we evaluate RecSlowFast on a task to continuously detect the longest evolving contour in a video. The slow-fast inference mechanism speeds up the average frame per second by \(279\%\) on this dataset with comparable task accuracy using a desktop GPU. We further demonstrate a similar trend on CamVid, a video semantic segmentation dataset.

## 1 Introduction

Current deep learning based computer vision research is largely dominated by feedforward neural networks . However, various studies on biological visual systems have indicated the importance of recurrent neural activities in functionalities such as attentive and conscious vision , perceptual grouping , pattern completion  and object recognition . These neurophysiological findings have inspired researchers to incorporate recurrence in their networks to achieve better performances or better biological plausibility. For example, the studies of  show that the output of shallow recurrent CNNs aligns better with measurements from the ventral stream on an object recognition task, and a higher correlation corresponds to better generalization of the model. The authors in  propose that top-down and horizontal connections between neurons in the cortex are crucial for supporting incremental perceptual grouping and utilizing high-level object cues. A related work  demonstrates a single-layer recurrent CNN with substantially fewer parametersoutperforms all feedforward baselines in long-range spatial dependencies modeling. However, the traditional application of iterative recurrent structures involves imposing a fixed number of recurrent steps, disregarding the characteristics and demands of both the input data and the task.

It has been observed in  that primate visual systems required extended processing time for more complex object recognition tasks compared to the simpler control group. This phenomenon was attributed to recurrent activities within the visual ventral stream, suggesting that biological visual systems can dynamically allocate different amounts of computation depending on the complexity of the task at hand, all within the same biological network. Inspired by these findings, we developed the **Recurrent Slow-Fast (RecSlowFast)** framework that uses varying recurrent steps for different frames in a video and leverages layer reuse and the similarity between frames for better performance-speed trade-off and parameter efficiency. The major contributions are as follows1:

* Introduction of a biologically motivated recurrent neural network (RNN) framework named _recurrent slow-fast networks (RecSlowFast)_. RecSlowFast uses **within input timestep recurrence** achieved by layer reuse for dynamically adjusting the amount of computation spent on an input frame and **cross-input timestep recurrence** by leveraging hidden states from earlier frames to reduce the number of recurrent steps needed for subsequent frame processing.
* Based on the hidden states similarities obtained across input frames, we introduce a novel recurrence halting criteria that dynamically allocates computational resources (recurrent steps). Notably, our approach circumvents the need for an auxiliary neural network to make halting decisions.
* Construction of a Temporal Pathfinder dataset (_T-Pathfinder_), which extends the widely used static pathfinder variants [13; 17; 24; 25] to the temporal domain by gradually changing the lengths of the contours across frames. The dataset has two subsets with different difficulty levels. The RecSlowFast framework is evaluated and compared against other baselines including recurrent and feedforward convolutional networks on T-Pathfinder.

## 2 Related work

**Recurrence in visual processing** Recurrence has been found vital for various functionalities in the visual ventral stream. [15; 14] show it requires a longer processing duration for the visual ventral stream to solve difficult object recognition tasks than the easy ones. Several works focus on better neural recording alignment with recurrent structures for object recognition [19; 20; 16] and natural movie stimuli . The authors of  found that architecture search with evolutionary algorithms yields layer-local recurrence and long-range feedback which achieve better trade-offs between task performance and small network size. Our work aims to exploit recurrence with temporal similarities of hidden states to reduce the amortized computation cost.

**Iterative inference** The architectural flexibility offered by recurrent structures through the configurable number of recurrent steps has long been of research interest. The early work of adaptive computing time (ACT)  introduces a halting unit into the RNN to terminate the recurrence. Similarly,  proposed a self-instantiating recurrent structure. In  the authors proposed a network that reuses the weights and concatenates the resulting feature map with the input of each residual block , achieving high parameter and computation efficiency compared with ResNet. Several other works [32; 4; 40] studied methods of deciding when to halt the recurrence, including the use of auxiliary gating neural networks . In the two related works [33; 5] the authors discovered that RNNs are able to extrapolate to larger maze sizes or longer prefix sum length even when trained on smaller problem scales, by simply running more recurrent steps during inference. Different from these works, RecSlowFast employs the variable recurrent step inference for temporal visual processing to exploit the correlation and redundancy in the frames.

**Implicit layers** Another line of work attempts to model sequential data by directly finding these equilibrium points with root-finding [3; 7]. Such methods are equivalent to feedforward networks with infinite depths. Subsequent works [2; 27; 9] studied reusing the states obtained from the equilibrium point of the previous input timestep in order to accelerate the root-finding of the next timestep. Our work is different from implicit layer works in the sense that RecSlowFast does not require a root-finder solver which typically comes with additional computing and memory overhead and puts constraints on the types of usable layers. We conducted comparisons and the results are in A.3.

**Two-path video processing** In the domain of video processing with deep neural networks, several studies have proposed ways of exploiting the temporal correlation nature of videos to accelerate the networks. One approach involves calculating optical flow between frames with a light network and wrapping the features extracted by a computationally heavy network [43; 39]. Another line of work [26; 42; 10] uses both a heavy and a light network to extract features in an interleaved manner with the heavy network operating less frequently. Unlike the aforementioned methods, our design utilizes a single network that operates in a two-path-like manner, as the amount of computation can be dynamically adjusted for an RNN.

## 3 Recurrent slow-fast networks

We hypothesize that the hidden state information from processing past temporally correlated visual inputs could accelerate the processing of incoming inputs. Taking two consecutive frames \(_{1}\) and \(_{2}\) in Figure 1(a) as an example, in a semantic segmentation task, it is much easier to complete the task for \(_{2}\) after \(_{1}\), despite minor changes on the sidewalk. Meanwhile, modifying the solution of \(_{2}\) for processing \(_{3}\) is slightly more challenging since the difference between \(_{2}\) and \(_{3}\) is larger than \(_{1}\) and \(_{2}\).

This concept forms the basis of our generic building block. Formally, for a given input sequence \(x=(x_{1},...,x_{T})\), consisting of either raw frames or feature maps, the corresponding hidden states \(h^{n}_{t}\) for timestep \(t\{1,...,T\}\) and the \(n^{}\) recurrent step is computed by the recurrent function \(r_{}\) parameterized with \(\) as follow:

\[h^{n}_{t}  r_{}(h^{n-1}_{t},x_{t}) \] \[h^{0}_{t+1}  h^{N(t)}_{t} \]

where \(h^{0}_{1}\) is the hidden states initialization \(h_{init}\) for the input, \(x_{1}\), on the 1st timestep. \(N(t)\) gives the number of recurrent steps to be executed for input \(x_{t}\) at timestep \(t\), allowing a variable computation workload across inputs. For consecutive inputs \(x_{t}\) and \(x_{t+1}\), we reuse the last hidden state resulting from \(x_{t}\) as the initial state for \(x_{t+1}\), as shown in Equation 2. The \(h_{init}\) state is initialized to zero.

There exist two types of hidden states transition in the RecSlowFast framework. One is _within input timestep transition_ (depicted in Equation 1 and marked with solid blue arrows in Figure 1), which feedback the output hidden state \(h^{n-1}_{t}\) for computing the next hidden state \(h^{n}_{t}\), on the same input

Figure 1: Illustration of the RecSlowFast framework. The three input frames are from the CamVid dataset . The major differences between frames are highlighted with yellow circles and arrows.

\(x_{t}\). Another is _across input timestep transition_ (depicted in Equation 2 and marked with dashed blue arrows in Figure 1). At the end of the recurrence for an input timestep \(t\), we recycle the extracted hidden state \(h_{t}^{N(t)}\) and use it as the initial state \(h_{t+1}^{0}\) for the processing of the next input timestep \(t+1\). For processing consecutive frames, the network does not have to start the processing from initialization state \(h_{}\) but instead starts from the hidden state extracted on the previous frame, and this enables reduced computation while maintaining task accuracy. We verify this in Section 4.2 by comparing RecSlowFast with networks that do not conduct across input timestep transitions, namely \( t\{1,...,T\},h_{t}^{0}=h_{}\), which are called _Stateless_ in the rest of the paper.

We also incorporate the findings in  of the _recall_ connections, inspired by skip connections [12; 36] which pass information from an earlier layer to a later layer for more stable training of very deep networks. We use recall to stabilize the training of the RecSlowFast network. As shown in Figure 1 and Equation 1, the recall connections forward the same input \(x_{t}\) to every recurrent step at timestep \(t\).

**Instantiating RecSlowFast with horizontal gated recurrent unit and convolutional long short-term memory** In this work, we focus on two versions of simple instantiations of recurrent block in RecSlowFast in order to rule out other deep network architectural factors and focus on studying the variable recurrent step mechanism. We use the horizontal gated recurrent unit (hGRU)  and convolutional long short-term memory (cLSTM)  in our experiment (complete description is in Appendix A.1). Both types of recurrent blocks are preceded and followed by two convolutional layers. Thus the whole network is described as follows:

\[x_{t}  f_{}(I_{t}) \] \[h_{t}^{n}  r_{}(h_{t}^{n-1},x_{t}),\ \ n=1,...,N(t)\] (4) \[y_{t}^{}  f_{}(h_{t}^{N(t)}) \]

where \(I_{t}\) is the raw input frame, \(f_{}\) and \(f_{}\) are the head and output convolutional layers.

## 4 The Temporal-Pathfinder dataset and experiment results

### Construction of the Temporal Pathfinder (_T-Pathfinder_) dataset

For evaluating the recurrent slow-fast framework, we first construct a new _T-Pathfinder_ dataset, which is a temporally extended variant of several similar synthetic visual tasks [24; 17] inspired by cognitive science . The _T-Pathfinder_ dataset consists of videos of visually consecutive frames (see Figure 2 for examples). The starting frame of a video contains several contours, where one of them is longer than the rest. The shorter contours are _distractors_. In each succeeding frame of the video, every contour can grow longer by certain segments with a predefined probability. The task for the network

Figure 2: (a) and (b) shows two examples from the _T-Pathfinder-Easy_ and _T-Pathfinder-Hard_ subset respectively. For the example in (b) the ground truth longest contour is annotated with red color on top of the original contour, which is grey scale. Notice the changes between frames caused by the growing of contour segments in the longest contour as well as the distractors. See Appendix A.6 for the complete sequence and more examples. Zoom-in for better visibility.

on this _T-Pathfinder_ dataset is to detect the longest contour in each frame and output a dense binary segmentation map with two classes, where pixel value 1 indicates this pixel is a member of the longest contour, otherwise, the pixel value is 0.

We constructed two subsets with different difficulty levels, named _T-Pathfinder-Easy_ and _T-Pathfinder-Hard_. In _T-Pathfinder-Easy_, the distractors are designed to never surpass the initial longest contour candidate, despite their random growths in each frame. In _T-Pathfinder-Hard_, there is a probability that distractors could grow longer than the initial longest contour candidate in the first frame. The bottom row in Figure 2 shows an example where one of the distractors grew from 9 segments in frame \(_{3}\) to 12 segments in frame \(_{4}\). Thus resulting in a new longest contour candidate for \(_{4}\). In _T-Pathfinder-Hard_, if one or multiple distractors grew to the same length as the longest contour, the ground truth is still set to the previous longest contour.

All frames in the _T-Pathfinder_ dataset have a resolution of \(128 128\) pixels. The _T-Pathfinder-Easy_ and _T-Pathfinder-Hard_ datasets, both begin with the creation of 4 distractors, but they differ in the length range and contour growth probability. In the _T-Pathfinder-Easy_ dataset, each video consists of 6 consecutive frames. The longest contour in the initial frame is set to be 10 segments. Distractors have lengths uniformly and randomly chosen from a range of 1 to 3. The extension probability is 0.5 for every contour in each consecutive frame. In contrast, the _T-Pathfinder-Hard_ dataset features 8 consecutive frames per video. The longest contour in the initial frame is set to be 10. The distractors have lengths uniformly and randomly chosen from a range of 1 to 8. Furthermore, the distractors grow in each new frame with a probability of 0.8, while the longest contour grows with a probability of 0.2. This makes the contours more likely to surpass the current longest contour. Each time a contour is allowed to grow, it does so uniformly and randomly with 1 to 3 segments. 10,000 sequences are generated for each subset and for each 2000 are randomly selected as test split.

### RecSlowFast results on _T-Pathfinder_

We applied our RecSlowFast framework on the two _T-Pathfinder_ subsets and compare them with baselines. We start our experiment with a _fixed schedule_. For both subsets of _T-Pathfinder_, the model uses more steps to process the first frame of the sequence, then uses a smaller or equal number of steps per frame to process the rest of the sequence. We annotate this type of fixed schedule with "\(\)[_slow steps_]**f**[_fast steps_]", where s represents the number of recurrent steps executed on the beginning frame and f represents the number of steps per frame for the rest of the video. For example, "s6f1" in Table 1 indicates the hGRU model spends 6 recurrent steps on the first frame (\(N(t=1)=6\)), and 1 recurrent step for each of the rest (\(N(t 1)=1\)), while "s6f6" represents the model spending 6 recurrent steps on every frame of the video. Unless stated, we use the same schedule for training and inference. The computation complexity (excluding \(f_{}\) and \(f_{}\)) can be estimated by counting the total recurrent steps for the video. For a 6-frame-sequence, if the schedule is "s6f2", then in total \(1 6+5 2=21\) recurrent steps will be spent for processing this sequence. In comparison with always spending 6 recurrent steps on every frame, the schedule "s6f2" will be approximately \((36-21)/36 42\%\) cheaper in computation for the recurrent block.

We use backpropagation through time (BPTT) for training the RecSlowFast framework. For each input frame \(_{t}\) a loss \(L_{t}(y_{t}^{},y_{t}^{})\) is computed for the ground truth \(y_{t}^{}\) and prediction \(y_{t}^{}\) pair. The total loss is \(L_{}=(_{t=1}^{T}L_{t})/T\). To mitigate the excessive computational graph size and associated memory requirements during BPTT training, we truncate the gradient flow from later timesteps to earlier ones. As a result, BPTT is confined within each individual input timestep, significantly reducing memory demands. We use the focal loss  with \(=2\) as the loss function. It is used to address the class imbalance problem and prevents the model from always outputting zeros because the majority of pixels are zero in the ground truth frames. The Adam optimizer  with a starting learning rate of 0.001 is used and the learning rate is multiplied by 0.7 after every 25 epochs. Batch size 10 is used for all experiments. The validation split is randomly selected from 10% of the training split. We train in a total of 100 epochs and use the checkpoint with the best validation loss for testing. The evaluation metric used is the mean intersection of union (mIoU). All mIoU values presented are averages from three runs. The original mIoU scores and corresponding standard deviations can be found in the Appendix. All the frame per second (FPS) measurements were conducted on an Nvidia RTX 3080 GPU with an AMD Ryzen 7 5800X CPU.

**Cross-input-timestep hidden state transition boosts temporal visual processing performance** We first compare the RecSlowFast with their _Stateless_ counterparts, which always reset the hidden state to initialization for every new input frame. Table 1 shows that when trained and tested with the same schedule, RecSlowFast always outperforms the Stateless version of the hGRU network. Meanwhile, even with **only 1** recurrent step per frame, the RecSlowFast-hGRU-s1f1 is able to outperform the Stateless hGRU with 4 recurrent steps per frame. A similar trend is observed on the more difficult _T-Pathfinder-Hard_ subset. In Figure 3 both the hGRU and cLSTM instantiations of RecSlowFast are shown. Although the absolute value of mIoU is lower than on the _T-Pathfinder-Easy_ subset, RecSlowFast always outperforms the Stateless version by a large margin, when the same recurrent block and schedule are being used. The RecSlowFast-hGRU-s3f3 beats the Stateless-hGRU-s8f8 in task accuracy while having an average frame per second \(2.6\) more. For both the RecSlowFast framework and Stateless networks, increasing recurrent steps up to a certain number improves the task performance, even though the model does not use more parameters. This finding is similar to [5; 33; 19; 20], however, we show this improvement in a temporal visual processing task. The comparison between RecSlowFast and Stateless shows that the network is continuously improving the prediction based on the cross-input-timestep hidden states.

    &  \\    &  &  &  &  &  \\  & mIoU & FPS & mIoU & FPS & mIoU & FPS & mIoU & FPS & mIoU & FPS \\  RecSlowFast &.994 &.972 & 110 &.994 &.966 &.965 & 311 &.879 &.879 &.992 &.586 &.992 &.586 &.992 \\  Stateless &.972 & 110 &.991 & 164 &.685 & 311 &.879 &.536 & 561 &.586 &.982 &.586 & 342 \\   

Table 1: RecSlowFast-hGRU task accuracy and inference speed on _T-Pathfinder-Easy_. For comparison, a feedforward CNN baseline with 6 convolutional layers and residual connections has mIoU of 0.895 and FPS of 213 with \( 3\) parameters of RecSlowFast-hGRU (846k vs. 284k). More detailed results and architecture description of the feedforward CNN baseline are in A.3 and A.2.

Figure 3: Different RecSlowFast schedules with hGRU and cLSTM instantiations, compared with their Stateless counterparts and feedforward CNN baselines on _T-Pathfinder-Hard_. The green shade shows the trend that we could reduce recurrent steps for non-initial frames to lower computation costs while maintaining performance. The red arrow indicates by reusing the hidden state from last timestep, the performance get boosted even with fewer recurrent steps. Circle sizes represent the number of parameters. Detailed descriptions for feedforward baselines FF-* and Conv3D-* are in Appendix A.2.

**Reduced recurrence steps for non-initial frames lower computation cost** Since the cross-input-timestep hidden state helps to improve the accuracy, one natural question is whether we need the same number of recurrent steps for processing the later input frames, even if the hidden states from the earlier timesteps are reused. We study this question by setting the number of fast steps differently from the slow steps for both training and testing. In Table 1 we studied the "s6f1" schedule for RecSlowFast-hGRU, which is \(3.1\) faster than RecSlowFast-hGRU-s6f6, but is still able to have the same high mIoU. RecSlowFast-hGRU-s6f1 also outperforms RecSlowFast-hGRU-s1f1 by a large margin, indicating a better quality starting hidden state helps to solve the later frames more easily, under the assumption that the frames are temporally highly correlated. Figure 3 shows more fine-grained scheduling on _T-Pathfinder-Hard_ with hGRU and cLSTM. RecSlowFast-hGRU-s8f2 is able to run \( 3\) as fast as "s8f8" with a small drop of the mIoU. For RecSlowFast with cLSTM, the speed up from "s8f8" to "s8f4" is \( 1.8\) with \( 0.6\%\) of absolute mIoU loss. Feedforward CNNs, although having the largest number of parameters, are worse than RecSlowFast-hGRUs at modeling the visual temporal sequence and having lower mIoUs in both _T-Pathfinder_ subsets. In summary, these results demonstrate that by using cross-input-timestep hidden states, we can decrease the overall computational cost for temporal visual processing by employing fewer recurrent steps.

**Correlation between input features distance and hidden states distance** We attempt to heuristically explain why having fewer recurrent steps for subsequent frames is possible, especially when the input frame changes are small, by analyzing the relationship of the distances between input features of two consecutive frames and the distances between their last recurrent step hidden states, namely \(d(x_{t},x_{t+1})\) and \(d(h^{N(t)}_{t},h^{N(t+1)}_{t+1})\) where \(d(,)\) denotes the distance metric. In our analysis, we first flatten the feature maps or hidden states and then calculate the \(_{2}\) distances. We use the RecSlowFast-hGRU-s8f8 (one of the top performing checkpoints from Figure 3) to calculate the feature maps and hidden states. The first feature map \(x_{1}\) and hidden state \(h^{8}_{t=1}\) are not used to compute their distance with initialization \(h_{}\), since that will create a false strong correlation. The per video normalized distance correlation is shown in Figure 4(a). \(_{2}(x_{t},x_{t+1})\) and \(_{2}(h^{N(t)}_{t},h^{N(t+1)}_{t+1})\) are highly correlated with correlation coefficient 0.8. This shows that if the input feature \(x_{t+1}\) changed a lot from \(x_{t}\), reflected by the large distance, then the distance between the end hidden states \(h^{N(t+1)}_{t+1}\) and \(h^{N(t)}_{t}\) will also likely to be large. Conversely, two similar or same feature maps will induce small hidden states distance in the RecSlowFast framework. Figure 4(b) shows an exemplary PCA visualization of hidden states. Four input frames with ground truth annotated with red are overlaid on top of the hidden state trajectory. From \(_{5}\) to \(_{6}\), lots of segments were added and the ground truth longest contour candidate also changed. This causes a long traverse of the hidden states when processing \(_{6}\).

**The limit of recurrence with the same weights** When we increased the number of recurrent steps for RecSlowFast with hGRU on _T-Pathfinder-Hard_ from s8f8 (mIoU: 0.79), we observed that model

Figure 4: **(a) There exists a strong correlation (correlation coefficient=0.8) for \(d(h^{N(t)}_{t},h^{N(t+1)}_{t+1})\) and \(d(x_{t},x_{t+1})\). The model used is RecSlowFast with hGRU-s8f8 and the dataset is the test split of _T-Pathfinder-Hard_. (b) A visualization for an exemplary hidden states trajectory of the model used for (a). Symbols with the same shape represent hidden states extracted from the same frame. A lighter color indicates a further recurrent step in that frame. The PCA reduction details are in Section A.4 and the full example is shown in Section A.6 Figure 8.**performance did not continue to improve with s10f10 (mIoU: 0.77) or s12f12 (mIoU: 0.77). A potential solution to enhance expressiveness could involve incorporating multiple recurrent blocks, each equipped with a different set of parameters and its own variable recurrent step schedule.

## 5 Distance-based recurrence halting criteria

Inspired by the empirical findings in Figure 4, we design distance-based recurrence halting criteria that do not impose a fixed inference schedule and can dynamically choose the executed recurrent steps without any auxiliary neural network for scheduling. In Algorithm 1 the pseudo code is given. In each recurrent step, we calculate the distance \(d_{}=d(h_{t}^{n},h_{t}^{n-1})\) between the current and previous hidden states, and compare it with the previous distance \(d_{}=d(h_{t}^{n-1},h_{t}^{n-2})\) (proper initial value and indices are assumed here). The comparison is conducted by calculating the distance ratio \(d_{}/(d_{}+)\), where \(\) is a small value used for preventing zero division. A thresholding hyperparameter \(\) is selected, so that if the distance ratio is below this threshold, we regard the recurrence as already converged, thus exiting it. Conversely, if the distance ratio surpasses \(\), the model is likely adapting to new input so another recurrent step will be carried out until reaching the preset maximum number of steps \(N_{}\). We set \(N_{}\) to 12 which is \(1.5\) of the original training steps, meaning we allow the model to extrapolate outside of its training regime if it is not converging within the training steps. This is similar to [5; 33].

**Experiment results** For the results in Table 2, the model being studied for different inference strategies is the RecSlowFast-hGRU-s8f8 trained on _T-Pathfinder-Hard_. We studied two distance metrics, \(_{2}\) and \(_{1}\). Threshold values from 0.8 to 1.1 with step 0.1 are being examined, and the average number of recurrent steps spent on the videos is recorded. Notice that **no** finetuning was conducted. For both distance metrics \(_{2}\) and \(_{1}\), the average number of steps is effectively reduced, when \(\) is increasing. Our distance based halting method enables controlling the performance-speed trade-off with one single threshold hyparameter, which is a desired property. If we compare distance based halting whose averaged steps is similar to naively running same number of recurrent steps on every frames, it provides a better task accuracy. This indicates that distance based halting works better in allocating the total computing budget.

## 6 Video semantic segmentation

To verify the RecSlowFast framework on larger-scale task, we carried out preliminary experiments with the semantic segmentation task on the CamVid dataset . We use the commonly studied CamVid version first processed in the SegNet work . Each frame is of resolution \(360 480\) pixels. There are 11 semantic classes and one unlabeled class. 367, 101 and 233 frames are included in the train, validation, and test split respectively. The dataset is collected by

   inference &  &  & averaged \\ strategy & & & & steps \\  \)} & 0.8 &.78 & 6.7 \\  & 0.9 &.77 & 5.7 \\  & 1.0 &.76 & 4.3 \\  & 1.1 &.74 & 3.3 \\  \)} & 0.8 &.79 & 9.5 \\  & 0.9 &.78 & 6.3 \\  & 1.0 &.76 & 3.6 \\  & 1.1 &.73 & 2.8 \\  \)} & s8f8 &.79 & 8.0 \\  & s6f6 &.73 & 6.0 \\   & s4f4 &.71 & 4.0 \\   & s3f3 &.67 & 3.0 \\   

Table 2: Distance based halting with different thresholdsa camera on a driving car and the frame rate 1 Hz, thus two consecutive frames can be quite different with a driving speed and a low camera frame rate. We train and test on consecutive frame pairs instead of entire video sequences.

We use a dual-gated recurrent unit (DRU) from  with U-Net  type of skip connections, to implement the RecSlowFast framework. The DRU network consists of an encoder with 4 downsampling convolutional layers and a decoder with 4 upsampling convolutional layers. The DRU recurrent unit is placed in the middle as a recurrent structure with memory. The output of the entire pipeline is also fed back as the input. Details on the DRU network, training, and dataset are in Section A.5.

When comparing RecSlowFast-DRU with 3 recurrent steps, the test mIoU is better than with 1 recurrent step (0.63 vs. 0.6). When we further finetune the 3-step checkpoint with s3f1 schedule, the averaged mIoU became 0.62 while saving 33% computation cost compare to s3f3 on the test pair. We also show qualitatively in Figure 5, that RecSlowFast-DRU is able to out perform the Stateless version with just 1 additional recurrent step on the second input frame \(_{2}\) and successfully solved ambiguous area in \(_{2}\) (marked with green circle) while Stateless DRU failed with 3 recurrent steps (marked with red circle).

## 7 Conclusion

In this work, we propose the RecSlowFast framework to show the usefulness of exploiting hidden representation similarities from temporally correlated input frames with recurrence for accelerating temporal visual processing. We constructed a new dataset _T-Pathfinder_, which requires tracking of the longest contour in a sequence of frames. The number of recurrent steps could be reduced for later frames in the sequence, thus cutting down the computation cost, with the help of representation similarities between two consecutive frames. Moreover, such cross-input hidden states reuse enables the model to continuously improve the prediction and boost task accuracy by a large margin on the _T-Pathfinder_ dataset. We also analyze the correlation between input feature distances and hidden states distances, providing empirical support for the feasibility of saving computation on temporally correlated inputs. Based on this correlation, we propose early halting criteria based on the hidden state distance ratio, which enables dynamic scheduling without presetting a fixed inference schedule or sophisticated auxiliary scheduling networks. RecSlowFast also maintains high parameter efficiency via the layer reuse property of recurrence. We perceive the potential for implementing RecSlowFast on hardware with constrained resources. In such contexts, the reuse of parameters through a recurrent structure becomes particularly advantageous.