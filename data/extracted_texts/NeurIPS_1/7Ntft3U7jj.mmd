# Uncovering the Redundancy in Graph

Self-supervised Learning Models

Zhibiao Wang1, Xiao Wang1, Haoyue Deng1, Nian Liu2, Shirui Pan3, Chunming Hu1

1 Beihang University, China

2 Beijing University of Posts and Telecommunications, China

3 Griffith University, Australia

{wzb2321, xiao_wang, haoyue_deng, hucm}@buaa.edu.cn,

nianliu@bupt.edu.cn, s.pan@griffith.edu.au

Corresponding authors.

###### Abstract

Graph self-supervised learning, as a powerful pre-training paradigm for Graph Neural Networks (GNNs) without labels, has received considerable attention. We have witnessed the success of graph self-supervised learning on pre-training the parameters of GNNs, leading many not to doubt that whether the learned GNNs parameters are all useful. In this paper, by presenting the experimental evidence and analysis, we surprisingly discover that the graph self-supervised learning models are highly redundant at both of neuron and layer levels, e.g., even randomly removing \(51.6\%\) of parameters, the performance of graph self-supervised learning models still retains at least \(96.2\%\). This discovery implies that the parameters of graph self-supervised models can be largely reduced, making simultaneously fine-tuning both graph self-supervised learning models and prediction layers more feasible. Therefore, we further design a novel graph pre-training and fine-tuning paradigm called SLImming DE-correlation Fine-tuning (SLIDE2). The effectiveness of SLIDE is verified through extensive experiments on various benchmarks, and the performance can be even improved with fewer parameters of models in most cases. For example, in comparison with full fine-tuning GraphMAE on Amazon-Computers dataset, even randomly reducing \(40\%\) of parameters, we can still achieve the improvement of \(0.24\%\) and \(0.27\%\) for Micro-F1 and Macro-F1 scores respectively.

## 1 Introduction

Graph self-supervised learning, aiming at learning the parameters of Graph Neural Networks (GNNs) without labels, has been a popular graph pre-training paradigm . Usually, graph self-supervised learning is naturally divided into two learning methods, i.e., graph contrastive learning  and graph generative self-supervised learning . After pre-training the parameters of self-supervised GNNs, graph self-supervised learning achieves state-of-the-art performance on a variety of tasks by fine-tuning an additional prediction layer .

Various researches have attempted to improve and understand graph self-supervised learning from different perspectives. For example, the graph augmentation techniques , graph spectrum feature of graph self-supervised learning , and others . Despite their remarkable achievements, little efforts have been made to understand the behavior of the learned model parameters by graph self-supervised learning. Here, we ask: Are the model parameters all always useful? Orwhat part of model parameters is useful? Whether there is the model redundancy in self-supervised GNNs? Understanding the model property in graph self-supervised learning, particularly the model redundancy, can provide valuable guidelines and insights for the development of advanced graph self-supervised learning.

For this purpose, we conduct experiments and surprisingly find out that the graph self-supervised learning models are actually highly redundant. We start with the experiments (Section 2) to investigate the downstream performance of different graph self-supervised learning models with randomly removed parameters at both neuron and layer levels. Our findings indicate that graph self-supervised learning models with even half of the neurons randomly removed have virtually no impact on the performance of the node classification task. Moreover, by closely examining the learned representations, we find out that the representations in each layer with a substantial number of neurons removed are quite similar to the representations obtained by the full set of neurons. Meanwhile, there is also a strong similarity between the representations of each layer and its adjacent layer. All results demonstrate that graph self-supervised models exhibit high model redundancy at both neuron level and layer levels.

The above findings hold great potential to improve current graph self-supervised learning models. On the one hand, it may provide valuable guideline for the pruning or the sparsity of GNNs [14; 15]. On the other hand, the phenomenon of model redundancy provides a new opportunity for designing a full fine-tuning graph self-supervised learning model. Previously, considering that the number of parameters to be fine-tuned is excessive when we directly fine-tune both GNNs and prediction layers, we usually only have to fine-tune the attached prediction layer, i.e., linear probing [3; 5; 7]. Here, if the parameters can be greatly reduced, we can simultaneously fine-tune both graph self-supervised learning models and prediction layers. Besides, the findings imply that de-correlating the learned representations is also necessary. Therefore, we propose a novel pre-training and fine-tuning paradigm called **SLIDE** by obtaining **SLIm** GNNs from the self-supervised GNNs and using the **DE**-correlation strategy to reduce the correlation between features during the fine-tuning phase. Extensive experiments on various benchmark datasets validate the effectiveness of SLIDE.

In summary, our contributions are three-fold:

* To the best of our knowledge, we are the first to uncover that graph self-supervised models exhibit high model redundancy at both neuron and layer levels. The model redundancy allows for the removal of a majority of model parameters with almost no impact on the performance of the downstream task. This discovery can significantly enhance model efficiency while maintaining acceptable task performance.
* This discovery provides two key guidelines for the subsequent graph pre-training and fine-tuning framework: one is that the parameters can be reduced, and the other is the representations should be de-correlated. These motivate us to propose a novel method, SLIDE, to achieve a pre-training and fine-tuning paradigm with fewer parameters and better performance on the downstream task.
* Comprehensive experiments demonstrate that our SLIDE outperforms baselines across multiple benchmark datasets. For example, using the Amazon-Computers dataset  with GRACE , compared to full fine-tuning, we achieve improvements of \(0.37\%\) and \(0.16\%\) for Macro-F1 and Micro-F1 scores respectively with a random reduction of \(30\%\) of parameters.

## 2 The Model Redundancy in Graph Self-supervised Learning

In this section, we investigate the model redundancy in two representative graph self-supervised learning models (GraphMAE  and GRACE ) on node classification tasks. Specifically, we pre-train these graph self-supervised models on Cora, Citeseer, Pubmed , Amazon-Photo, Amazon-Computers , Ogbn-arxiv , and then we evaluate the performance again after removing neurons in various ways. If the performance gap between the original GNNs and the slim GNNs with fewer neurons is small, it indicates great model redundancy in self-supervised GNNs. In other words, even with reduced neurons, the performance remains largely unaffected, suggesting that many neurons in self-supervised GNNs are dispensable. Notably, model redundancy is not limited to node classification tasks. We conduct experiments in Appendix A demonstrating that model redundancy also persists in link prediction and graph classification tasks.

[MISSING_PAGE_FAIL:3]

both the slim GNNs and the original GNNs, we individually attach an additional prediction layer which is trained while keeping the original GNNs frozen on the node classification task to evaluate the Micro-F1 (F1-Mi) and Macro-F1 (F1-Ma) scores, as shown in Table 1 and Table 2, where "-" means that there are only two layers in the original GNNs (i.e.,"2-Original" and "Original" have the same performance) and "Change-Param" means the percentage change of the number of parameters compared to "Original". Surprisingly, we have following observations:

* **In all cases, "half GNNs" retain at least 96.2% of the performance of the original GNNs while the numbers of parameters are reduced by at least 51.6%.** In most of the cases, "quarter GNNs" still retain at least 90% of the performance of the original GNNs while the number of parameters are reduced by at least 76.2%. As can be seen, "quarter GNNs" of GRACE on Computers retains 95.5% of the Micro-F1 score and 94.7% of the Macro-F1 score, while the number of parameters is reduced by 82.5%.
* **The removal of layers after the second layer has a negligible impact on the performance.** The performance of "2-original GNNs" with GraphMAE on Ogbn-arxiv dataset demonstrates that even when layers after the second layer are removed, **both the Micro-F1 score and the Macro-F1 score retain 99.4% of the performance, while the number of parameters is reduced by 47.0%**.

The observations indicate that the graph self-supervised learning models are highly redundant, both at the neuron level and at the layer level. More details about the hyperparameters and the number of parameters can be found in Appendix B.

Redundancy analysis on neuron levelHere, we further analyze the model redundancy by closely examining the learned representations in order to explore why the slim GNNs achieve similar performance to the original GNNs. Specifically, we get the slim GNNs by dropping the neurons of each layer in 25%, 50% and 75% to analyze the model redundancy at the neuron level. Given the learned representations of the \(i\)-th layer of the slim GNNs and the original GNNs, Centered Kernel Alignment (CKA) is adopted to calculate their similarity . A high CKA score implies a strong similarity. As shown in Figure 2, compared to the original GNNs, the CKA scores are over \(85\%\) when \(50\%\) neurons are dropped. Even if the neurons are removed by \(75\%\), the CKA scores are still almost over \(80\%\). This indicates that removing a significant number of neurons from each layer has a minimal impact on the significance of representations of each layer and task performance consequently.

Figure 2: CKA scores between the representations of the slim GNNs and the same layer in the original GNNs with GraphMAE and GRACE on several datasets. “all” means we remove the neurons from all layers in the same proportion. “11” means that we calculate CKA scores of the representations from the first layer, and “l2” means CKA scores from the second layer, and so on.

### Redundancy analysis on layer level

As for the model redundancy at the layer level, given the learned representations of the \(i\)-th layer and the \((i+1)\)-th layer of the original GNNs, we also adopt CKA to calculate their similarity, where the \(0\)-th layer represents the original features of the nodes from the datasets. As shown in Figure 3, we report the CKA scores between the representations of each layer and its adjacent layer of the original GNNs for GraphMAE and GRACE. "data-layer1" means that we calculate CKA scores between the original features of the nodes from the datasets and the representations of the first layer, and so on. As can be seen, CKA scores between the original features and the representations of the first layer are relatively low, while CKA scores between the representations of the layers after the first layer and their next layer are much closer to 1 in most of the cases, indicating the model redundancy at the layer level.

## 3 Our Proposed Tuning Approach: Slimming De-correlation Fine-tuning

In general, for the self-supervised pre-trained GNNs, we attach an additional prediction layer which is fine-tuned while keeping the GNNs frozen to conduct the downstream tasks. Ideally, if we are able to tune the parameters of both the GNNs and the linear layer, it is possible to achieve the best performance. However, the number of parameters to be fine-tuned is excessive. Here, since we identify the model redundancy in the self-supervised pre-trained GNNs, this motivates us that we actually only need to tune the additional classifier and the slim GNNs, so as to obtain a better trade-off between the model performance and the number of fine-tunable parameters. Therefore, we propose a novel pre-training and fine-tuning paradigm called **SLI**mming **DE**-correlation Fine-tuning (SLIDE), as shown in Figure 4. Specifically, firstly it reduces model redundancy in self-supervised pre-trained GNNs by randomly removing redundant neurons to obtain the slim GNNs. Then, we input the graph data into the slim GNNs to obtain the embeddings of the nodes, combined with an additional prediction layer, we can predict the label of each node. Meanwhile, we design another model de-correlation module based the squared Frobenius norm [20; 21] (an analogue corresponding to the Hilbert-Schmidt Independence Criterion, i.e., HSIC  in Euclidean space). The module learns the de-correlation weights for the classification loss, so as to reduce the redundancy among embeddings and make the embeddings more informative.

Figure 4: The overall framework of SLIDE.

Figure 3: CKA scores between the representations of each layer and its adjacent layer of the original GNNs for GraphMAE and GRACE on several datasets.

Specifically, let \(G=(A,V,X)\) denote the input graph, where \(V\) is the node set, \(N=|V|\) is the number of nodes, \(N_{tr}\) is the number of nodes in the training set and \(d\) is the dimension of the node features, \(A\{0,1\}^{N N}\) is the adjacency matrix, and \(X R^{N d}\) is the input node feature matrix. For model slimming, we first pre-train the original GNNs through the existing pre-training frameworks, e.g., the graph contrastive learning [1; 4; 5] or graph generative self-supervised learning [3; 7; 2]. Then the slim GNNs \(f_{S}\) can be obtained by randomly reducing both the neurons and the layers. Furthermore, given \(G\), we can get the node embeddings \(H R^{N d_{h}}\) as \(H=f_{S}(A,X)\), where \(d_{h}\) is the dimension of the node embeddings.

Motivated by Section 2 that the neurons, as well as the learned embeddings, in self-supervised GNNs are highly redundant, we aim to de-correlate the learned embeddings \(H\) in the fine-tuning phase, making models with fewer parameters more informative. In particular, in inspiration of the de-correlation methods [21; 23], given the i-th dimension and j-th dimension of the node embeddings \(_{*,i}\) and \(_{*,j}\), we obtain Random Fourier Features (RFF) [24; 25] as

\[ u(_{*,i})&:=(u_{1}(_{*,i}),u_{2}(_{*,i}),,u_{N_{RFF}}(_{*,i})),\\ v(_{*,j})&:=(v_{1}(_{*,j}),v_{ 2}(_{*,j}),,v_{N_{RFF}}(_{*,j})), \]

where \(N_{RFF}\) is the number of functions in the random fourier space, \(u_{q}\) and \(v_{q}\) denote the functions from the space of Random Fourier Features. Then, we elaborate on reweighting of the weights, which encourages the independence of the node embeddings. Define the weights of the nodes in the training set as \(W=\{w_{n}\}_{n=1}^{N_{tr}}\), where \(w_{n}\) is the learnable weight for the \(n\)-th node of the training set in \(G\). Consequently, the reweighted partial cross-covariance matrix can be calculated as:

\[^{}_{_{*,i},_{*,j}}=-1}_{n=1}^{N_{tr}}[(w_{n}u( _{n,i})-}_{m=1}^{N_{tr}}w_{m}u(_{m,i}) )^{}.\\ .(w_{n}v(_{n,j})-}_{m= 1}^{N_{tr}}w_{m}v(_{m,j}))]. \]

The learnable weights \(W\) participate in the process of optimization to eliminate as much as possible the correlation between the dimensions of the node embeddings by minimizing the partial cross-covariance matrix in Eq. 2. Specifically, for the process of optimization, given the labels of the nodes \(_{n} R^{N_{tr}}\), we iteratively optimize the weights of the nodes \(W\), the slim GNNs \(f_{S}\), and the additional prediction layer \(R\):

\[f_{S}^{s},R^{*} =*{argmin}_{f_{S},R}_{n=1}^{N_{tr}}w_{n} (R f_{S}(X_{n}),_{n}), \] \[^{*} =*{argmin}_{}_{1 i<j d_{h}} \|^{}_{_{*,i},_{*,j}}\|_{ }^{2}, \]

where \(\) denotes the cross-entropy loss for the node classification task. The optimization of the weights \(W\) encourages the slim GNNs \(f_{S}\) to generate the node embeddings \(H\), and eliminates the correlations between embeddings. The optimization of the slim GNNs \(f_{S}\) and the additional classifier \(R\) will lead to good performance on the node classification task.

To put it in a nutshell, SLIDE is a general pre-training and fine-tuning framework in graph, which balances the number of parameters and the performance of self-supervised pre-trained GNNs. Therefore, SLIDE can be implemented using different ideas of reducing parameters and de-correlation methods. We use the methods mentioned above as examples and conduct some experiments to demonstrate the feasibility of SLIDE.

## 4 Experiments

**Datasets.** For a comprehensive comparison, we use six real-world datasets to evaluate the performance of node classification (i.e., Cora, Citeseer, Pubmed, Amazon-Photo, Amazon-Computers and Ogbn-arxiv). More details about the datasets are in Appendix C.1.

[MISSING_PAGE_FAIL:7]

are shown in Table 3 - 5, where "LP" means "linear probe", "FT" means "full fine-tune", and "OOM" means "out of memory". We have the following observations: (1) In general, SLIDE improves the performance compared to "LP" because SLIDE is able to fine-tune both "2-half GNNs" and the additional prediction layer. For example, in comparison with "LP" on Computers with these three competitive pre-training frameworks, SLIDE achieves an average improvement of \(0.75\%\) and \(0.69\%\) for Micro-F1 and Macro-F1 scores, respectively. (2) Although SLIDE significantly reduces the number of parameters in self-supervised GNNs, SLIDE still achieves better performance than "FT". Especially on large-scale graphs like Ogbn-arxiv with GraphMAE, SLIDE is able to fine-tune both the pre-trained GNNs and the additional prediction layer.

### Model Analysis

Ablation studyHere, we test the performance of the slim GNNs with and without model de-correlation on the node classification task. The results are shown in Figure 5, where "w/o dec" means that the slim GNNs are directly fine-tuned without model de-correlation. We find that the slim GNNs with de-correlation perform much better than the GNNs without de-correlation, proving that correlation is still present when self-supervised GNNs are directly fine-tuned.

Figure 5: Ablation studies of model de-correlation on six benchmark datasets and three pre-training frameworks. "w/o de" means that we fine-tune the slim GNNs without model de-correlation methods. "Mi" means Micro-F1 scores and "Ma" means Macro-F1 scores. The results of Ogbn-arxiv with GRACE are unseen because of "out of memory".

Figure 6: The number of parameters on several datasets with GraphMAE and GRACE.

Related Work

Graph self-supervised learningSelf-supervised methods on graphs can be naturally divided into contrastive and generative domains according to objective designs and model architectures [9; 27; 28; 29]. Graph Contrastive Learning (GCL) has shown its outstanding ability in unsupervised setting, and many studies have been proposed [1; 4; 5; 8]. On the other hand, Generative self-supervised learning [6; 2] aims to recover missing parts of the input data. Among them, methods which have emerged in the last two years [3; 7] have significantly enhanced the performance of generative methods, resulting in competitive performance on downstream tasks and attracting much attention. Despite the remarkable achievements of these methods, the issue of model redundancy in these self-supervised GNNs remains unexplored in the current research landscape.

Model redundancyIn recent years, researchers have investigated redundancy in several pre-trained model architectures for different domains. Among them, in , researchers dissect two pre-trained models, BERT  and XLNet , studying how much redundancy they exhibit by using feature selection to choose the subset of neurons. In , researchers dissected several pre-trained visual models and randomly removed neurons of the penultimate layer in proportion, proving that redundancy exists in the penultimate layer. In , researchers find that many layers of LLMs exhibit high similarity. By removing some of the layers of large language models (LLMs), LLMs can still maintain good performance, proving that model redundancy exists in LLMs. Graph Neural Networks (GNNs) [35; 36; 37] have been widely applied in recent years and there are some studies focusing on graph sparsification and graph lottery ticket [14; 15]. Graph sparsification approximates a graph to a sparse graph by reducing the number of edges instead of parameters. And graph lottery ticket reduces parameters in networks systematically, not randomly. However, the study of model redundancy in self-supervised GNNs remains largely unexplored.

Pre-training and fine-tuningTraditional pre-training and fine-tuning paradigms mainly include "linear probe" and "full fine-tune". The former faces the challenge of insufficient performance, while the latter requires high computational cost and memory. In recent years, several Parameter-Efficient Fine-Tuning (PEFT) methods have been introduced to address these issues. Among them, Low Rank Adaptation (LoRA)  alters the fine-tuning phase by keeping the original model parameters frozen and introducing modifications to a separate, smaller set of parameters. These changes are then incorporated into the original parameters. On the other hand, Adapter Tuning  adds new modules, called adapters, between the layers of a pre-trained model. The parameters from the pre-training phase are frozen, and a smaller set of additional parameters is introduced for the new task. A common feature of these methods is the addition of a small number of additional parameters to the complete model for fine-tuning. The focus of this paper is orthogonal to these methods, as it aims to fine-tune the model under the condition of reduced parameters. In this paper, we provide a unique perspective on the pre-training and fine-tuning paradigm and contribute to the ongoing exploration of effective fine-tuning strategies.

## 6 Conclusion and Broader Impacts

In this paper, we make an exploration of model redundancy in self-supervised pre-trained GNNs. We find out that model redundancy in self-supervised GNNs exists at both neuron level and layer level, which deepens our understanding of self-supervised GNNs. We then propose a novel pre-training and fine-tuning paradigm, SLIDE, which achieves better performance with fewer number of parameters for fine-tuning. Our experiments validate the effectiveness of SLIDE.

Limitations and broader impactAlthough we discover that the graph self-supervised learning models are highly redundant at neuron and layer levels and deepen our understanding of self-supervised GNNs, a potential limitation is that some theoretical foundations are still lacking. Our findings hold great potential to improve current graph self-supervised learning models and may provide valuable guideline for the pruning or the sparsity of GNNs. In the future, we will further understand self-supervised GNNs from the perspective of model redundancy by theoretical analysis. Beyond that, we do not expect any immediate negative impact on society.