# SLowcal-SGD: Slow Query Points Improve Local-SGD

for Stochastic Convex Optimization

Tehila Dahan

Department of Electrical Engineering

Technion

Haifa, Israel

t.dahan@campus.technion.ac.il

&Kfir Y. Levy

Department of Electrical Engineering

Technion

Haifa, Israel

kfirylevy@technion.ac.il

###### Abstract

We consider distributed learning scenarios where \(M\) machines interact with a parameter server along several communication rounds in order to minimize a joint objective function. Focusing on the heterogeneous case, where different machines may draw samples from different data-distributions, we design the first local update method that provably benefits over the two most prominent distributed baselines: namely Minibatch-SGD and Local-SGD. Key to our approach is a slow querying technique that we customize to the distributed setting, which in turn enables a better mitigation of the bias caused by local updates.

## 1 Introduction

Federated Learning (FL) is a framework that enables huge scale collaborative learning among a large number of heterogeneous1 clients (or machines). FL may potentially promote fairness among participants, by allowing clients with small scale datasets to participate in the learning process and affect the resulting model. Additionally, participants are not required to directly share data, which may improve privacy. Due to these reasons, FL has gained popularity in the past years, and found use in applications like voice recognition , fraud detection , drug discovery , and more .

The two most prominent algorithmic approaches towards federated learning are Minibatch-SGD  and Local-SGD (a.k.a. Federated-Averaging) . In Minibatch-SGD all machines (or clients) always compute unbiased gradient estimates of the same query points, while using large batch sizes; and it is well known that this approach is not degraded due to data heterogeneity . On the downside, the number of model updates made by Minibatch-SGD may be considerably smaller compared to the number of gradient queries made by each machine; which is due to the use of minibatches. This suggests that there may be room to improve over this approach by employing local update methods like Local-SGD, where the number of model updates and the number of gradient queries are the same. And indeed, in the past years, local update methods have been extensively investigated, see e.g.  and references therein.

We can roughly divide the research on FL into two scenarios: the _homogeneous_ case, where it is assumed that the data on each machine is drawn from the same distribution; and to the more realistic _heterogeneous_ case where it is assumed that data distributions may vary between machines.

For the _homogeneous_ case it was shown in  that the standard Local-SGD method is not superior to Minibatch-SGD. Nevertheless,  have designed an accelerated variant of Local-SGD that provably benefits over the Minibatch baseline. These results are established for the fundamental Stochastic Convex Optimization (SCO) setting, which assumes that the learning objective is convex.

Similarly to the homogeneous case, it was shown in  that Local-SGD is not superior to Minibatch-SGD in _heterogeneous_ scenarios. Nevertheless, several local approaches that compare with the Minibatch baseline were designed in . Unfortunately, we have so far been missing a local method that provably benefits over the Minibatch baseline in the heterogeneous SCO setting.

Our work focuses on the latter heterogeneous SCO setting, and provide a new Local-SGD-style algorithm that provably benefits over the minibatch baseline. Our algorithm named SLovcal-SGD, builds on customizing a recent technique for incorporating a _slowly-changing sequence of query points_, which in turn enables to better mitigate the bias induced by the local updates. Curiously, we also found importance weighting to be crucial in order to surpass the minibatch baseline.

In Table 1 we compare our results to the state-of-the-art methods for the heterogeneous SCO setting. We denote \(M\) to be the number of machines, \(K\) is the number of local updates per round, and \(R\) is the number of communications rounds. Additionally, \(G\) (or \(G_{*}\)) measures the dissimilarity between machines. Our table shows that Local-SGD requires much more communication rounds compared to Minibatch-SGD, and that the dissimilarity \(G\) (or \(G^{*}\)) substantially degrades its performance. Conversely, one can see that even if the dissimilarity measure is \(G_{*}=O(1)\), our approach SLovcal-SGD still requires less communication rounds compared to Minibatch-SGD.

Similarly to the homogeneous case, accelerated-Minibatch-SGD, obtains the best performance among all current methods, and it is still open to understand whether one can outperform this accelerated minibatch baseline. In App. A we elaborate on the computations of \(R_{}\) in Table 1.

Related Work.We focus here on centralized learning problems, where we aim to employ \(M\) machines in order to minimize a joint learning objective. We allow the machines to synchronize during \(R\) communication rounds through a central machine called the _Parameter Server_ (\(\)); and allow each machine to draw \(K\) samples and perform \(K\) local gradient computations in every such communication round. We assume that each machine \(i\) may draw i.i.d. samples from a distribution \(_{i}\), which may vary between machines.

The most natural approach in this context is Minibatch-SGD, and its accelerate variant , which have been widely adopted both in academy and in industry, see e.g. . Local update methods like Local-SGD , have recently gained much popularity due to the rise of FL, and have been extensively explored in the past years.

Focusing on the SCO setting, it is well known that the standard Local-SGD is not superior (actually in most regimes it is inferior) to Minibatch-SGD . Nevertheless,  devised a novel accelerated local approach that provably surpasses the Minibatch baseline in the homogeneous case.

The heterogeneous SCO case has also been extensively investigated, with several original and elegant approaches . Nevertheless, so far we have been missing a local approach that provably benefits over Minibatch-SGD. Note that  improve the communication

 
**Method** & **Rate** & \(_{}(=)\) \\  MinBatch SGD & \(+R}\) & \(MK\) \\  Accelerated MiniBatch SGD & \(}+R}\) & \((MK)^{1/3}\) \\  Local SGD  & \(^{2/3}}{^{2/3}}+}{(})^{2/3}}++KR}\) & \(G^{4}(MK)^{3}+M^{3}K\) \\  SCAFFOLD & \(+R}\) & \(MK\) \\  \(\) & \(+KR}\) & \(MK\) \\  \(}{}\) & \(+}{^{1/4}}++R^{4/3}}+}+KR}}{G_{*}  MK^{1/2}+MK^{1/2}}\) \\ 
**Lower Bound:** Local-SGD  & \(^{2/3}}{^{2/3}}+}{(})^{2/3}}++KR}\) & \(G_{*}^{4}(MK)^{3}+M^{3}K\) \\  

Table 1: We compare the best known guarantees for parallel learning, to our SLovcal-SGD approach for the heterogeneous SCO case. The bolded term in the **Rate** column is the one that compares least favourably against Minibatch SGD. Where \(G\) and \(G_{*}\) relate to the dissimilarity measures that are defined in Equations (1) and (3). The \(_{}\) column presents the minimal number of communication rounds that are required to obtain a linear speedup (we fixed values of \(K,M\) and take \(=1\)). Note that we omit methods that do not enable a wall-clock linear speedup with \(M\), e.g. .

complexity with respect to the condition number of the objective; However their performance does not improve as we increase the number of machines \(M\)2, which is inferior to the minibatch baseline.

The heterogeneous non-convex setting was also extensively explored [21; 20; 14]; and the recent work of  has developed a novel algorithm that provably benefits over the minibatch baseline in this case. The latter work also provides a lower bound which demonstrates that their upper bound is almost tight. Finally, for the special case of quadratic loss functions, it was shown in  and in  that it is possible to surpass the minibatch baseline.

It is important to note that excluding the special case of quadratic losses, there does not exist a local update algorithm that provably benefits over _accelerated_-Minibatch-SGD. And the latter applies to both homogeneous and heterogeneous SCO problems.

Our local update algorithm utilizes a recent technique of employing slowly changing query points in SCO problems . The latter has shown to be useful in designing universal accelerated methods [22; 12; 5], as well as in improving asynchronous training methods .

## 2 Setting: Parallel Stochastic Optimization

We consider Parallel stochastic optimization problems where the objective \(f:^{d}\) is convex and is of the following form,

\[f(x):=_{i[M]}f_{i}(x):=_{i[M]}_{ z^{i}_{i}}f_{i}(x;z^{i})\;.\]

Thus, the objective is an average of \(M\) functions \(\{f_{i}:^{d}\}_{i[M]}\), and each such \(f_{i}()\) can be written as an expectation over losses \(f_{i}(,z^{i})\) where the \(z^{i}\) are drawn from some distribution \(_{i}\) which is unknown to the learner. For ease of notation, in what follows we will not explicitly denote \(_{z^{i}_{i}}\) but rather use \(\) to denote the expectation w.r.t. all randomization.

We assume that there exist \(M\) machines (computation units), and that each machine may independently draw samples from the distribution \(_{i}\), and can therefore compute unbiased gradient estimates to the gradients of \(f_{i}()\). Most commonly, we allow the machines to synchronize during \(R\) communication rounds through a central machine called the _Parameter Server_ (\(\)); and allow each machine to perform \(K\) local computations in every such communication round.

We consider first order optimization methods that iteratively employ samples and generate a sequence of query points and eventually output a solution \(x_{}\). Our performance measure is the expected excess loss, \(:=[f(x_{})]-f(w^{*})\;,\) where the expectation is w.r.t. the randomization of the samples, and \(w^{*}\) is a global minimum of \(f()\) in \(^{d}\), i.e., \(w^{*}_{x^{d}}f(x)\).

More concretely, at every computation step, each machine \(i[M]\) may draw a fresh sample \(z^{i}_{i}\), and compute a gradient estimate \(g\) at a given point \(x^{d}\) as follows, \(g:= f_{i}(x,z^{i})\;.\) and note that \([g|x]= f_{i}(x)\), i.e. \(g\) is an unbiased estimate of \( f_{i}(x)\).

General Parallelization Scheme.A general scheme for parallel stochastic optimization is described in Alg. 1. It can be seen that the \(\) communicates with the machines along \(R\) communication rounds. In every round \(r[R]\) the \(\) distributes an anchor point \(_{r}\) which is a starting point for the local computations in that round. Based on \(_{r}\) each machine performs \(K\) local gradient computations based on \(K\) i.i.d. draws from \(_{i}\), and yields a message \(_{r}^{i}\). At the end of round \(r\) the \(\) aggregates the messages from all machines and updates the anchor point \(_{r+1}\). Finally, after the last round, the \(\) outputs \(x_{}\), which is computed based on the anchor points \(\{_{r}\}_{r=1}^{R}\).

Ideally, one would hope that using \(M\) machines in parallel will enable to accelerate the learning process by a factor of \(M\). And there exists a rich line of works that have shown that this is indeed possible to some extent, depending on \(K,R\), and on the parallelization algorithm.

Next, we describe the two most prominent approaches to first-order Parallel Optimization,

**(i) Minibatch SGD:** In terms of Alg. 1, one can describe Minibatch-SGD as an algorithm in which the \(\) sends a weight vector \(x_{r}^{d}\) in every round as the anchor point \(_{r}\). Based on that anchor \(_{r}:=x_{r}\), each machine \(i\) computes an unbiased gradient estimate based on \(K\) independent samples from \(_{i}\), i.e. \(g_{r}^{i}:=_{k=1}^{K} f_{i}(x_{r},z_{Kr+k}^{i})\), and communicates \(g_{r}^{i}\) as the message \(_{r}^{i}\) to the \(\). The latter aggregates the messages \(\{_{r}^{i}:=g_{r}^{i}\}_{i[M]}\) and compute the next anchor point \(x_{r+1}\),

\[x_{r+1}=x_{r}-_{i[M]}g_{r}^{i}\;,\]

where \(>0\) is the learning rate of the algorithm. The benefit in this approach is that all machines always compute gradient estimates at the same anchor points \(\{x_{r}\}_{r}\), which highly simplifies its analysis. On the downside, in this approach the number of gradient updates \(R\) is smaller compared to the number of stochastic gradient computations made by each machine which is \(KR\). This gives the hope that there is room to improve upon Minibatch SGD, by mending this issue.

**(ii) Local SGD:** In terms of Alg. 1, one can describe Local-SGD as an algorithm in which the \(\) sends a weight vector \(x_{rK}^{d}\) in every round \(r[R]\) as the anchor information \(_{r}\). Based on the anchor \(_{r}:=x_{rK}\), each machine performs a sequence of local gradient updates based on \(K\) independent samples from \(_{i}\) as follows, \( k[K]\),

\[x_{rK+k+1}^{i}=x_{rK+k}^{i}- f_{i}(x_{rK+k}^{i},z_{rK+k}^{i})\;,\]

where for all machines \(i[M]\) we initialize \(x_{rK}^{i}=x_{rK}:=_{r}\), and \(>0\) is the learning rate of the algorithm. At the end of round \(r\) each machine communicates \(x_{(r+1)K}^{i}\) as the message \(_{r}^{i}\) to the \(\) and the latter computes the next anchor as follows,

\[_{r+1}:=x_{(r+1)K}=_{i[M]}x_{(r+1)K}^{i}\;.\]

In local SGD the number of gradient steps is equal to the number of stochastic gradient computations made by each machine which is \(KR\). The latter suggests that such an approach may potentially surpass Minibatch SGD. Nevertheless, this potential benefit is hindered by the bias that is introduced between different machines during the local updates. And indeed, as we show in Table 1, this approach is inferior to Minibatch SGD in the prevalent case where \(=O(1)\).

**Assumptions.** We assume that \(f()\) is convex, and that the \(f_{i}()\) are smooth i.e. \( L>0\) such,

\[\| f_{i}(x)- f_{i}(y)\| L\|x-y\|\;,\;\; i[M]\;,\;  x,y^{d}\]

We also assume that variance of the gradient estimates is bounded, i.e. that there exists \(>0\) such,

\[\| f_{i}(x;z)- f_{i}(x)\|^{2}^{2}\;,\; x ^{d}\;,\; i[M]\;.\]

Letting \(w^{*}\) be a global minimum of \(f()\), we assume there exist \(G_{*} 0\) such that,

\[_{i[M]}\| f_{i}(w^{*})\|^{2} G_{*}^{2}/2\;,\;\; $-)} \]The above assumption together with the smoothness and convexity imply (see App. B),

\[_{i[M]}\| f_{i}(x)\|^{2} G_{*}^{2}+4L(f(x)-f(w^{*}))\;, x^{d} \]

A stronger dissimilarity assumption that is often used in the literature is the following,

\[_{i[M]}\| f_{i}(x)- f(x)\|^{2} G^{2}/2\;, \;\; x^{d})} \]

**Notation:** For \(\{y_{t}\}_{t}\) we denote \(y_{t_{1}:t_{2}}:=_{=t_{1}}^{t_{2}}y_{}\). For \(N^{+}\) we denote \([N]:=\{0,,N-1\}\).

## 3 Our Approach

Section 3.1 describes a basic (single machine) algorithmic template called Anytime-GD. Section 3.2 describes our \(\)Lowcal-SGD algorithm, which is a Local-SGD style algorithm in the spirit of Anytime GD. We describe our method in Alg. 2, and state its guarantees in Thm. 2.

### Anytime GD

The standard GD algorithm computes a sequence of iterates \(\{w_{t}\}_{t[T]}\) and queries the gradients at theses iterates. It was recently shown that one can design a GD-style scheme that computes a sequence of iterates \(\{w_{t}\}_{t[T]}\) yet queries the gradients at a _different_ sequence \(\{x_{t}\}_{t[T]}\) which may be _slowly-changing_, in the sense that \(\|x_{t+1}-x_{t}\|\) may be considerably smaller than \(\|w_{t+1}-w_{t}\|\).

Concretely, the Anytime-GD algorithm  that we describe in Equations (4) and (5), employs a learning rate \(>0\) and a sequence of non-negative weights \(\{_{t}\}_{t}\). The algorithm maintains two sequences \(\{w_{t}\}_{t},\{x_{t}\}_{t}\) that are updated as follows \( t\),

\[w_{t+1}=w_{t}-_{t}g_{t}\;, t[T]\;,g_{t}=  f(x_{t})\;, \]

and then,

\[x_{t+1}=}{_{0:t+1}}x_{t}+}{_{0: t+1}}w_{t+1}\;. \]

It can be shown that the above implies that \(x_{t+1}=}_{=0}^{t+1}_{}w_{}\), i.e. the \(x_{t}\)'s are weighted averages of the \(w_{t}\)'s. Thus, at every iterate the gradient \(g_{t}\) is queried at \(x_{t}\) which is a weighted average of past iterates, and then \(w_{t+1}\) is updated similarly to GD with a weight \(_{t}\) on the gradient \(g_{t}\). Moreover, at initialization \(x_{0}=w_{0}\).

Curiously, it was shown in  that Anytime-GD obtains the same convergence rates as GD for convex loss functions (both smooth and non-smooth). It was further shown and that one can employ a stochastic version (Anytime-SGD) where we query noisy gradients at \(x_{t}\) instead of the exact ones, and that approach performs similarly to SGD.

**Slowly changing query points.** A recent work , demonstrates that if we use projected Anytime-SGD, i.e. project the \(w_{t}\) sequence to a given bounded convex domain; then one can immediately show that for both \(_{t}=1\) and \(_{t}=t+1\) we obtain \(\|x_{t+1}-x_{t}\| 2D/t\), where \(D\) is the diameter of the convex domain. Conversely, for standard SGD we have \(\|w_{t+1}-w_{t}\|\|g_{t}\|\), where \(g_{t}\) here is a (possibly noisy) unbiased estimate of \( f(w_{t})\). Thus, while the change between consecutive SGD queries is controlled by \(\) which is usually \( 1/\), and by magnitude of stochastic gradients; for Anytime-SGD the change decays with time, irrespective of the learning rate \(\). In , this is used to design better and more robust asynchronous training methods.

**Relation to Momentum.** In the appendix we show that Anytime-SGD can be explicitly written as a momentum method, and therefore is quite different from standard SGD. Concretely, for \(_{t}=1\) we show that \(x_{t+1} x_{t}-_{=1}^{t}(/t^{2}) g_{}\), and for \(_{t} t\) we show that \(x_{t+1} x_{t}-_{=1}^{t}(/t)^{3} g_{}\). Where \(g_{}\) here is a (possibly noisy) unbiased estimate of \( f(x_{})\). This momentum interpretation provides a complementary intuition regarding the benefit of Anytime-SGD in the context of local update methods. Momentum brings more stability to the optimization process which in turn reduces the bias between different machines.

For the sake of this paper we will require a specific theorem that does not necessarily regard Anytime-GD, but is rather more general. We will require the following definition,

**Definition**: _Let \(\{_{t} 0\}_{t}\) be a sequence of non-negative weights, and let \(\{w_{t}^{d}\}_{t}\), be an arbitrary sequence. We say that a sequence \(\{x_{t}^{d}\}_{t}\) is an \(\{_{t}\}_{t}\) weighted average of \(\{w_{t}\}_{t}\) if \(x_{0}=w_{0}\), and for any \(t>0\) Eq. (5) is satisfied._

Next, we state the main theorem for this section, which applies for any sequence \(\{w_{t}^{d}\}_{t}\),

**Theorem 1** (Rephrased from Theorem 1 in ).: _Let \(f:^{d}\) be a convex function with a global minimum \(w^{*}\). Also let \(\{_{t} 0\}_{t}\), and \(\{w_{t}^{d}\}_{t},\{x_{t}^{d}\}_{t}\) such that \(\{x_{t}\}_{t}\) is an \(\{_{t}\}_{t}\) weighted average of \(\{w_{t}\}_{t}\). Then the following holds for any \(t 0\),_

\[0_{0:t}(f(x_{t})-f(w^{*}))_{=0}^{t}_{ } f(x_{})(w_{}-w^{*})\;.\]

### SLowcal-SGD

Our approach is to employ an Anytime version of Local-SGD, which we name by \(\)Lowcal-SGD.

**Notation:** Prior to describing our algorithm we will define \(t\) to be the total of _per-machine_ local updates up to step \(k\) of round \(r\), resulting \(t:=rK+k\). In what follows, we will often find it useful to denote the iterates and samples using \(t\), rather than explicitly denoting \(t=rK+k\). Additionally we use \(\{_{t}\}_{t}\) to denote a pre-defined sequence of non-negative weights. Finally, we denote \(T:=RK\).

In the spirit of Anytime-SGD our approach is to maintain two sequences per machine \(i[M]\): \(\{w^{i}_{t}^{d}\}_{t}\) and \(\{x^{i}_{t}^{d}\}_{t}\). Our approach is depicted explicitly in Alg. 2. Next we describe our algorithm in terms of the scheme depicted in Alg. 1:

**(i) Distributing anchor.** At the beginning of round \(r\) the \(\) distributes \(_{r}=(w_{t},x_{t})=(w_{rK},x_{rK})^{d}^{d}\) to all machines.

**(ii) Local Computations.** For \(t=rK\), every machine initializes \((w^{i}_{t},x^{i}_{t})=_{r}\), and for the next \(K\) rounds, i.e. for any \(rK t(r+1)K-1\), every machine performs a sequence of local Anytime-SGD steps as follows,

\[w^{i}_{t+1}=w^{i}_{t}-_{t}g^{i}_{t}\;, \]

where similarly to Anytime-SGD we query the gradients at the averages \(x^{i}_{t}\), meaning \(g^{i}_{t}= f_{i}(x^{i}_{t},z^{i}_{t})\). And query points are updated as weighted averages of past iterates \(\{w_{t}\}_{t}\),,

\[x^{i}_{t+1}=(1-}{_{0:t+1}})x^{i}_{t}+}{_{0:t+1}}w^{i}_{t+1}\;,\;rK t(r+1)K-1\;. \]

At the end round \(r\), i.e. \(t=(r+1)K\), each machine communicates \((w^{i}_{t},x^{i}_{t})\) as a message to the \(\).

**(iii) Aggregation.** The \(\) aggregates the messages and computes the next anchor point \(_{r+1}=(w_{t},x_{t})=_{i[M]}^{i}_{r}:=(_{i[M]}w^{i}_{t},_{i[M]}x^{i}_{t})\), where \(t=(r+1)K\).

**Remark:** Note that for \(t=rK\) our notation for \((w^{i}_{t},x^{i}_{t})\) is inconsistent: at the end of round \(r-1\) these values may vary between different machines, while at the beginning of round \(r\) these values are all equal to \(_{r}:=(w_{t},x_{t})\). Nevertheless, for simplicity we will abuse notation, and explicitly state the right definition when needed. Importantly, in most of our analysis we will mainly need to refer to the averages \((_{i[M]}w^{i}_{t},_{i[M]}x^{i}_{t})\), and note the latter are consistent at the end and beginning of consecutive rounds due to the definition of \(_{r}\), and \(^{i}_{r-1}\).

#### 3.2.1 Guarantees & Intuition

Below we state our main result for \(\)Lovcal-SGD (Alg. 2),

**Theorem 2**.: _Let \(f()\) be a convex and \(L\)-smooth function. Then under the assumption that we make in Sec. 2, invoking Alg. 2 with weights \(\{_{t}=t+1\}_{t[T]}\), and an appropriate learning rate \(\) ensures,_

\[_{T}\,\,O(LB_{0}^{2}(+}+R^{4/3}})+}{}+(^{1/2}+G_{*}^{1/2}) B_{0}^{3/2}}{K^{1/4}R})\;,\]

_where \(_{T}:=f(x_{T})-f(x^{*})\), \(B_{0}:=\|w_{0}-w^{*}\|\), and we choose the learning rate as follows,_

\[=\{,}, },-w^{*}\|}{ T^{3/2}},-w^{*}\|^{1/2}}{ L^{1/2}K^{7/4}R(^{1/2}+G_{*}^{1/2})}\}\; \]

As Table 1 shows, Thm. 2 implies that \(\)Lovcal-SGD improves over all existing upper bounds for Minibatch and Local SGD, by allowing less communication rounds to obtain a linear speedup of \(M\).

**Intuition.** The degradation in local SGD schemes (both standard and Anytime) is due to the bias that it introduces between different machines during each round, which leads to a bias in their gradients. Intuitively, this bias is small if the machines query the gradients at a sequence of slowly changing query points. This is exactly the benefit of \(\)Lovcal-SGD which queries the gradients at averaged iterates \(x^{i}_{t}\)'s. Intuitively these averages are slowly changing compared to the iterates themselves \(w^{i}_{t}\); and recall that the latter are the query points used by standard Local-SGD. A complementary intuition to the benefit of our approach, is the interpretation of Anytime-SGD as a momentum method (see Sec. 3.1 and the appendix) which leads to decreased bias between machines.

To further simplify the more technical discussion here, we will assume the homogeneous case, i.e., that for any \(i[M]\) we have \(_{i}=\) and \(f_{i}()=f()\).

So a bit more formally, let us discuss the bias between query points in a given round \(r[R]\), and let us denote \(t_{0}=rK\). The following holds for standard **Local SGD**,

\[w^{i}_{t}=w_{t_{0}}-_{=t_{0}}^{t-1}g^{i}_{}\;,\;\; i [M],t[t_{0},t_{0}+K]\;. \]

where \(g^{i}_{t}\) is the noisy gradients that Machine \(i\) computes in \(w^{i}_{}\), and we can write \(g^{i}_{}:= f(w^{i}_{})+^{i}_{}\), where \(^{i}_{}\) is the noisy component of the gradient. Thus, for two machines \(i j\) we can write,

\[\|w^{i}_{t}-w^{j}_{t}\|^{2}=^{2}\|_{=t_{0 }}^{t-1}g^{i}_{}-g^{j}_{}\|^{2}^{2}\| _{=t_{0}}^{t-1} f(w^{i}_{})- f(w^{j}_{})\|^ {2}+^{2}\|_{=t_{0}}^{t-1}^{i}_{}-^{j}_{ }\|^{2}\]

And it was shown in , that the noisy term is dominant and therefore we can bound,

\[}\|w^{i}_{t}-w^{j}_{t}\|^{2} \|_{=t_{0}}^{t-1}^{i}_{}-^{j}_{}\|^{2} t -t_{0} K\;. \]

Similarly, for **SLovcal-SGD** we would like to bound \(\|x^{i}_{t}-x^{j}_{t}\|^{2}\) for two machines \(i j\); and in order to simplify the discussion we will assume uniform weights i.e., \(_{t}=1\;,\; t[T]\). Now the update rule for the iterates \(w^{i}_{t}\), is of the same form as in Eq. (9), only now \(g^{i}_{}:= f(x^{i}_{})+^{i}_{}\), where \(^{i}_{}\) is the noisy component of the gradient. Consequently,

\[_{=t_{0}}^{t}(w^{i}_{}-w^{j}_{})-_{=t_{0}}^{ t-1}(t-)(g^{i}_{}-g^{j}_{})- K_{=t_{0}}^{t-1}(g^{i}_{ }-g^{j}_{})\;,\]where we took a crude approximation of \(t- K\). Now, by definition of \(x_{t}^{i}\) and \(_{t}=1\), \(x_{t}^{i}=}{t} x_{t_{0}}+_{=t_{0}}^{t}w_{ }^{i}\;,\;\; i[M],t[t_{0},t_{0}+K]\;.\) Thus, for two machines \(i j\) we have,

\[}\|x_{t}^{i}-x_{t}^{j}\|^{2} =}\|_{=t_{0}}^ {t}w_{}^{i}-w_{}^{j}\|^{2}}K^{2}}{t^{2}}\|_{=t_{0}}^{t-1}g_{}^{i}-g_{ }^{j}\|^{2}\] \[}{t^{2}}\|_{=t_{0}}^{t-1 } f(x_{}^{i})- f(x_{}^{j})\|^{2}+}{t^{2} }\|_{=t_{0}}^{t-1}_{}^{i}-_{}^{j}\| ^{2}\;.\]

As we show in our analysis, the noisy term is dominant, so we can therefore bound,

\[}\|x_{t}^{i}-x_{t}^{j}\|^{2}} {t^{2}}\|_{=t_{0}}^{t-1}_{}^{i}-_{}^{j} \|^{2}(t-t_{0})}{t^{2}}}{t^{2}}\;. \]

Taking \(t T=RK\) above yields a bound of \(O(K/R^{2})\). Thus Equations (10), (11), illustrate that the bias of \(\)Lowcal-SGD is smaller by a factor of \(R^{2}\) compared to the bias of standard Local-SGD. In the appendix we demonstrate the same benefit of Anytime-SGD over SGD when both use \(_{t} t\).

Finally, note that the biases introduced by the local updates come into play in a slightly different manner in Local-SGD compared to \(\)Lowcal-SGD 3. Consequently, the above discussion does not enable to demonstrate the exact rates that we derive. Nevertheless, it provides some intuition regarding the benefit of our approach. The full and exact derivations appear in the appendix.

**Importance Weights.** One may wonder whether it is necessary to employ increasing weights \(_{t}=t+1\), rather than employing standard uniform weights \(_{t}=1\;, t\). Surprisingly, in our analysis we have found that increasing weights are crucial in order to obtain a benefit over Minibatch-SGD, and that upon using uniform weights \(\)Lowcal-SGD performs worse compared to Minibatch SGD! We elaborate on this in Appendix L. Below we provide an intuitive explanation.

**Intuitive Explanation.** The intuition behind the importance of using increasing weights is the following: Increasing weights are a technical tool to put more emphasis on the last rounds. Now, in the context of Local update methods, the iterates of the last rounds are more attractive since the bias between different machines shrinks as we progress. Intuitively, this happens since as we progress with the optimization process, the expected value of the gradients that we compute goes to zero (since we converge); and consequently the bias between different machines shrinks as we progress.

### Proof Sketch for Theorem 2

Proof Sketch for Theorem 2.: As a starting point for the analysis, for every iteration \(t[T]\) we will define the averages of \((w_{t}^{i},x_{t}^{i},g_{t}^{i})\) across all machines as follows,

\[w_{t}:=_{i[M]}w_{t}^{i}\;,\& x_{t}:= _{i[M]}x_{t}^{i}\& g_{t}:=_{i[M]}g_{t}^{i}\;.\]

Note that Alg. 2 explicitly computes \((w_{t},x_{t})\) only once every \(K\) local updates, and that theses are identical to the local copies of every machine at the beginning of every round. Combining the above definitions with Eq. (6) yields,

\[w_{t+1}=w_{t}-_{t}g_{t}\;,\; t[T] \]

Further combining these definitions with Eq. (7) yields,

\[x_{t+1}=(1-}{_{0:t+1}})x_{t}+}{ _{0:t+1}}w_{t+1}\;,\; t[T] \]

The above implies that the \(\{x_{t}\}_{t[T]}\) sequence is an \(\{_{t}\}_{t[T]}\) weighted average of \(\{w_{t}\}_{t[T]}\). This enables to employ Thm. 1 which yields, \(_{0:t}_{t}_{=0}^{t}_{} f(x_{}) (w_{}-w^{*})\;,\) where we denote \(_{t}:=f(x_{t})-f(w^{*})\). This bound highlights the challenge in the analysis: our algorithm does not directly compute unbiased estimates of \(x_{t}\), except for the first iterate of each round. Concretely, Eq. (12) implies that our algorithm effectively updates using \(g_{t}\) which is a biased estimate of \( f(x_{t})\)It is therefore natural to decompose \( f(x_{})=g_{}+( f(x_{})-g_{})\) in the above bound, yielding,

\[_{0:t}_{t}^{t}_{}g_{} (w_{}-w^{*})}_{(A)}+^{t}_{}(  f(x_{})-g_{})(w_{}-w^{*})}_{(B)} \]

Thus, we intend to bound the weighted error \(_{0:t}_{t}\) by bounding two terms: \((A)\) which is related to the update rule of the algorithm, and \((B)\) which accounts for the bias between \(g_{t}\) and \( f(x_{t})\).

**Notation:** In what follows we will find the following notation useful, \(_{t}:=_{i[M]} f_{i}(x_{t}^{i})\), and note that \(_{t}=[g_{t}|\{x_{t}^{i}\}_{i[M]}]\). We will also employ the following notations: \(V_{t}:=_{=0}^{t}_{}^{2}\|_{}- f(x_{}) \|^{2}\), and \(D_{t}:=\|w_{t}-w^{*}\|^{2}\), where \(w^{*}\) is a global minimum of \(f()\). We will also denote \(D_{0:t}:=_{=0}^{t}\|w_{}-w^{*}\|^{2}\).

Bounding (A):Due to the update rule of Eq. (12), one can show by standard regret analysis that: \((A):=_{=0}^{t}_{}g_{}(w_{}-w^{*})-w^{*}\|^{2}}{2}+_{=0}^{t}_{}^{2}\| g_{}\|^{2}\),

Bounding (B):We can bound \((B)\) in expectation using \(V_{t}\) and \(D_{0:t}\) as follows for any \(>0\): \([()]V_{t}+D_{0:t}\),

Combining (A) and (B):Combining the above boounds on \((A)\) and \((B)\) into Eq. (14) we obtain the following bound which holds for any \(>0\) and \(t[T]\),

\[_{0:t}_{t}-w^{*}\|^{2}}{2}+_{=0}^{T}_{}^{2}\|g_{}\|^{2}+V_{T}+D_{0:T} \]

Now, to simplify the proof sketch we shall assume that \(D_{t} D_{0}\  t\), implying that \(D_{0:T} TD_{0}\). Plugging this into the above equation and taking \(=\) gives,

\[_{0:t}_{t}-w^{*}\|^{2}}{}+ _{=0}^{T}_{}^{2}\|g_{}\|^{2 }}_{(*)}+4 TV_{T}. \]

Next we will bound \((*)\) and \(V_{T}\), and plug them back into Eq. (16).

Bounding \((*)\):To bound \((*)\) it is natural to decompose \(g_{}=(g_{}-_{})+(_{}- f(x_{}))+ f (x_{})\). Using this decomposition we show that, \((*)\  3}{M}_{t=0}^{T}_{t}^{2}+3V_{T}+12L _{t=0}^{T}_{0:t}_{t}\).

Bounding \(V_{T}\)The definition of \(V_{t}\) shows that it is encompasses the bias that is introduced due to the local updates, which in turn relates to the distances \(\|x_{t}^{i}-x_{t}^{j}\|\), \( i,j[M]\). Thus, \(V_{T}\) is therefore directly related to the dissimilarity between the machines. Our analysis shows the following: \(V_{T} 400L^{2}^{2}K^{3}_{=0}^{T}_{0:} (G_{*}^{2}+4L_{})+90L^{2}^{2}K^{6}R^{3}^{2}\). Plugging the above into Eq. (16), and using our choice for \(\), gives an almost explicit bound,

\[_{0:t}_{t}-w^{*}\|^{2}}{}+ }{M}_{t=0}^{T}_{t}^{2}+L^{2}^{3}TK^{6}R^{3} ^{2}+L^{2}^{3}TK^{3}_{=0}^{T}_{0:}G_{*}^{2}+ {1}{2(T+1)}_{t=0}^{T}_{0:t}_{t}\.\]

The theorem follows by plugging above the choices of \(,_{t}\), and using a technical lemma. 

## 4 Experiments

To assess the effectiveness of our proposed approach, we conducted experiments on the MNIST  dataset--a well-established benchmark in image classification comprising 70,000 grayscale images of handwritten digits (0-9), with 60,000 images designated for training and 10,000 for testing. The dataset was accessed via torchvision (version 0.16.2). We implemented a logistic regression model  using the PyTorch framework and executed all computations on an NVIDIA L40S GPU. To ensure robustness, results were averaged over three different random seeds. The complete codebase for these experiments is publicly available on our GitHub repository.4

We evaluated our approach using parameters derived from our theoretical framework (\(_{t}=t\)) in comparison to Local-SGD and Minibatch-SGD under various configurations. Specifically, experiments were conducted with 16, 32, and 64 workers to examine the scalability and robustness of the proposed method. We also varied the number of local updates \(K\) (or minibatch sizes for Minibatch-SGD) among 4, 8, 16, 32, and 64 to investigate how different local iteration counts impact performance. Data subsets for each worker were generated using a Dirichlet distribution  with \(=0.1\) to simulate real-world non-IID data scenarios characterized by high heterogeneity. For fairness, the learning rate was selected through grid search, with a value of 0.01 for \(\)Lowcal-SGD and Local-SGD, and 0.1 for Minibatch-SGD. More details about the data distribution across workers and complete experimental results are provided in Appendix M.

Our results on the MNIST dataset, presented in Figure 1 and detailed in Appendix M.2, demonstrate the effectiveness of our approach, showing consistent performance improvements compared to Local-SGD and Minibatch-SGD as the number of local steps increases. Notably, this improvement becomes even more significant compared to the other methods as the number of workers increases, underscoring the scalability of our method and aligning with the theoretical guarantees outlined in our framework. These results highlight the robustness of our approach in handling highly heterogeneous, distributed environments.

Upon closer inspection, when a small number of local steps are performed, the differences between the approaches are negligible, with a slight advantage for Minibatch-SGD. However, as the number of local steps increases, the minibatch size grows, and the need for significant variance reduction diminishes. In this regime, making more frequent optimization updates becomes more impactful, as demonstrated by the superior performance of the local approaches compared to Minibatch-SGD. Importantly, with \(\)Lowcal-SGD, which keeps local updates closely aligned among workers throughout the training process, we can achieve significantly better and more stable performance compared to both Minibatch-SGD and Local-SGD as the number of local steps \(K\) and the number of workers \(M\) increase.

## 5 Conclusion

We have presented the first local approach for the heterogeneous distributed Stochastic Convex Optimization (SCO) setting that provably benefits over the two most prominent baselines, namely Minibatch-SGD, and Local-SGD. There are several interesting avenues for future exploration:

**(a)** developing an adaptive variant that does not require the knowledge of the problem parameters like \(\) and \(L\); **(b)** Allowing a per dimension step-size that could benefit in (the prevalent) scenarios where the scale of the gradients considerably changes between different dimensions; in the spirit of the well known AdaGrad method . Finally, **(c)** it will be interesting to understand whether we can find an algorithm that provably dominates over the Accelerated Minibatch-SGD baseline, which is an open question also in the homogeneous SCO setting.

Figure 1: Performance vs. Local Iterations (\(K\)) for different numbers of workers (\(M\)).