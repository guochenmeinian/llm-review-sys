# Polynomial Width is Sufficient for Set Representation with High-dimensional Features

Anonymous Author(s)

Affiliation

Address

email

###### Abstract

Set representation has become ubiquitous in deep learning for modeling the inductive bias of neural networks that are insensitive to the input order. DeepSets is the most widely used neural network architecture for set representation. It involves embedding each set element into a latent space with dimension \(L\), followed by a sum pooling to obtain a whole-set embedding, and finally mapping the whole-set embedding to the output. In this work, we investigate the impact of the dimension \(L\) on the expressive power of DeepSets. Previous analyses either oversimplified high-dimensional features to be one-dimensional features or were limited to analytic activations, thereby diverging from practical use or resulting in \(L\) that grows exponentially with the set size \(N\) and feature dimension \(D\). To investigate the minimal value of \(L\) that achieves sufficient expressive power, we present two set-element embedding layers: (a) linear + power activation (LP) and (b) logarithm + linear + exponential activations (LLE). We demonstrate that \(L\) being \((N,D)\) is sufficient for set representation using both embedding layers. We also provide a lower bound of \(L\) for the LP embedding layer. Furthermore, we extend our results to permutation-equivariant set functions and the complex field.

## 1 Introduction

Enforcing invariance into neural network architectures has become a widely-used principle to design deep learning models . In particular, when a task is to learn a function with a set as the input, the architecture enforces permutation invariance that asks the output to be invariant to the permutation of the input set elements . Neural networks to learn a set function have found a variety of applications in particle physics , computer vision  and population statistics , and have recently become a fundamental module (the aggregation operation of neighbors' features in a graph ) in graph neural networks (GNNs)  that show even broader applications.

Previous works have studied the expressive power of neural network architectures to represent set functions . Formally, a set with \(N\) elements can be represented as \(=\{^{(1)},,^{(N)}\}\) where \(^{(i)}\) is in a feature space \(\), typically \(=^{D}\). To represent a set function that takes \(\) and outputs a real value, the most widely used architecture DeepSets  follows Eq. (1).

\[f()=(_{i=1}^{N}(^{(i)})),:^{L}:^{L}. \]

DeepSets encodes each set element individually via \(\), and then maps the encoded vectors after sum pooling to the output via \(\). The continuity of \(\) and \(\) ensure that they can be well approximated by fully-connected neural networks , which has practical implications. DeepSets enforces permutation invariance because of the sum pooling, as shuffling the order of \(^{(i)}\) does not changethe output. However, the sum pooling compresses the whole set into an \(L\)-dimension vector, which places an information bottleneck in the middle of the architecture. Therefore, a core question on using DeepSets for set function representation is that given the input feature dimension \(D\) and the set size \(N\), what the minimal \(L\) is needed so that the architecture Eq. (1) can represent/universally approximate any continuous set functions. The question has attracted attention in many previous works  and is the focus of the present work.

An extensive understanding has been achieved for the case with one-dimensional features (\(D=1\)). Zaheer et al.  proved that this architecture with bottleneck dimension \(L=N\) suffices to _accurately_ represent any continuous set functions when \(D=1\). Later, Wagstaff et al. proved that accurate representations cannot be achieved when \(L<N\) and further strengthened the statement to _a failure in approximation_ to arbitrary precision in the infinity norm when \(L<N\).

However, for the case with high-dimensional features (\(D>1\)), the characterization of the minimal possible \(L\) is still missing. Most of previous works  proposed to generate multi-symmetric polynomials to approximate permutation invariant functions . As the algebraic basis of multi-symmetric polynomials is of size \(L^{*}=-1\) (exponential in \(\{D,N\}\)), these works by default claim that if \(L L^{*}\), \(f\) in Eq. 1 can approximate any continuous set functions, while they do not check the possibility of using a smaller \(L\). Zweig and Bruna  constructed a set function that \(f\) requires bottleneck dimension \(L>N^{-2}(O(\{D,\}))\) (still exponential in \(\{D,\}\)) to approximate while it relies on the condition that \(\), \(\) only adopt analytic activations. This condition is overly strict, as most of the practical neural networks allow using non-analytic activations, such as ReLU. Zweig and Bruna thus left an open question _whether the exponential dependence on \(N\) or \(D\) of \(L\) is still necessary if \(,\) allow using non-analytic activations._

**Present work** The main contribution of this work is to confirm a negative response to the above question. Specifically, we present the first theoretical justification that \(L\) being _polynomial_ in \(N\) and \(D\) is sufficient for DeepSets (Eq. (1)) like architecture to represent any _continuous_ set functions with _high-dimensional_ features (\(D>1\)). To mitigate the gap to the practical use, we consider two architectures to implement feature embedding \(\) (in Eq. 1) and specify the bounds on \(L\) accordingly:

* \(\) adopts _a linear layer with power mapping_: The minimal \(L\) holds a lower bound and an upper bound, which is \(N(D+1) L<N^{5}D^{2}\).
* Constrained on the entry-wise positive input space \(^{N D}_{>0}\), \(\) adopts _two layers with logarithmic and exponential activations respectively_: The minimal \(L\) holds a tighter upper bound \(L 2N^{2}D^{2}\).

We prove that if the function \(\) could be any continuous function, the above two architectures reproduce the precise construction of any set functions for high-dimensional features \(D>1\), akin to the result in  for \(D=1\). This result contrasts with  which only present approximating representations. If \(\) adopts a fully-connected neural network that allows approximation of any continuous functions on a bounded input space , then the DeepSets architecture \(f()\) can approximate any set functions universally on that bounded input space. Moreover, our theory can be easily extended to permutation-equivariant functions and complex set functions, where the minimal \(L\) shares the same bounds up to some multiplicative constants.

Another comment on our contributions is that Zweig and Bruna  use difference in the needed dimension \(L\) to illustrate the gap between DeepSets  and Relational Network  in their expressive powers, where the latter encodes set elements in a pairwise manner rather than in a separate manner. The gap well explains the empirical observation that Relational Network achieves better expressive power with smaller \(L\). Our theory does not violate such an observation while it shows that the

  
**Prior Arts** & \(L\) & \(D>1\) & **Exact Rep.** & **Equivariance** \\  DeepSets  & \(D+1\) & ✗ & ✓ & ✓ \\ Wagstaff et al.  & \(D\) & ✗ & ✓ & ✓ \\  Segol et al.  & \(-1\) & ✓ & ✗ & ✓ \\ Zweig \& Bruna  & \((\{,D\})\) & ✓ & ✗ & ✗ \\  Our results & \((N,D)\) & ✓ & ✓ & ✓ \\   

Table 1: A comprehensive comparison among all prior works on expressiveness analysis with \(L\). Our results achieve the tightest bound on \(L\) while being able to analyze high-dimensional set features and extend to the equivariance case.

gap can be reduced from an exponential order in \(N\) and \(D\) to a polynomial order. Moreover, many real-world applications have computation constraints where only DeepSets instead of Relational Network can be used, e.g., the neighbor aggregation operation in GNN being applied to large networks , and the hypergraph neural diffusion operation in hypergraph neural networks . Our theory points out that in this case, it is sufficient to use polynomial \(L\) dimension to embed each element, while one needs to adopt a function \(\) with non-analytic activities.

## 2 Preliminaries

### Notations and Problem Setup

We are interested in the approximation and representation of functions defined over sets 1. In convention, an \(N\)-sized set \(=\{^{(1)},,^{(N)}\}\), where \(^{(i)}^{D}, i[N](\{1,2,...,N\})\), can be denoted by a data matrix \(=^{(1)}&&^{(N)}^{} ^{N D}\). Note that we use the superscript \((i)\) to denote the \(i\)-th set element and the subscript \(i\) to denote the \(i\)-th column/feature channel of \(\), i.e., \(_{i}=x_{i}^{(1)}&&x_{i}^{(N)}^{}\). Let \((N)\) denote the set of all \(N\)-by-\(N\) permutation matrices. To characterize the unorderedness of a set, we define an equivalence class over \(^{N D}\):

**Definition 2.1** (Equivalence Class).: If matrices \(,}^{N D}\) represent the same set \(\), then they are called equivalent up a row permutation, denoted as \(}\). Or equivalently, \(}\) if and only if there exists a matrix \((N)\) such that \(=}\).

Set functions can be in general considered as permutation-invariant or permutation-equivariant functions, which process the input matrices regardless of the order by which rows are organized. The formal definitions of permutation-invariant/equivariant functions are presented as below:

**Definition 2.2**.: (Permutation Invariance) A function \(f:^{N D}^{D^{}}\) is called permutation-invariant if \(f()=f()\) for any \((N)\).

**Definition 2.3**.: (Permutation Equivariance) A function \(f:^{N D}^{N D^{}}\) is called permutation-equivariant if \(f()=f()\) for any \((N)\).

In this paper, we investigate the approach to design a neural network architecture with permutation invariance/equivariance. Below we will first focus on permutation-invariant functions \(f:^{N D}\). Then, in Sec. 5, we show that we can easily extend the established results to permutation-equivariant functions through the results provided in  and to the complex field. The obtained results for \(D^{}=1\) can also be easily extended to \(D^{}>1\) as otherwise \(f\) can be written as \(f_{1}&&f_{D^{}}^{}\) and each \(f_{i}\) has single output feature channel.

### DeepSets and The Difficulty in the High-Dimensional Case \(D>1\)

The seminal work  establishes the following result which induces a neural network architecture for permutation-invariant functions.

**Theorem 2.4** (DeepSets , \(D=1\)).: _A continuous function \(f:^{N}\) is permutation-invariant (i.e., a set function) if and only if there exists continuous functions \(:^{L}\) and \(:^{L}\) such that \(f()=(_{i=1}^{N}(x^{(i)}))\), where \(L\) can be as small as \(N\). Note that, here \(x^{(i)}\)._

_Remark 2.5_.: The original result presented in  states the latent dimension should be as large as \(N+1\).  tighten this dimension to exactly \(N\).

Theorem 2.4 implies that as long as the latent space dimension \(L N\), any permutation-invariant functions can be implemented by a unified manner as DeepSets (Eq.(1)). Furthermore, DeepSets suggests a useful architecture for \(\) at the analysis convenience and empirical utility, which is formally defined below (\(=_{L}\)):

**Definition 2.6** (Power mapping).: A power mapping of degree \(K\) is a function \(_{K}:^{K}\) which transforms a scalar to a power series: \(_{K}(z)=z&z^{2}&&z^{K}^{}\).

However, DeepSets  focuses on the case that the feature dimension of each set element is one (i.e., \(D=1\)). To demonstrate the difficulty extending Theorem 2.4 to high-dimensional features, we reproduce the proof next, which simultaneously reveals its significance and limitation. Some intermediate results and mathematical tools will be recalled along the way later in our proof.

We begin by defining sum-of-power mapping (of degree \(K\)) \(_{K}()=_{i=1}^{N}_{K}(x_{i})\), where \(_{K}\) is the power mapping following Definition 2.6. Afterwards, we reveal that sum-of-power mapping \(_{K}()\) has a continuous inverse. Before stating the formal argument, we formally define the injectivity of permutation-invariant mappings:

**Definition 2.7** (Injectivity).: A set function \(h:^{N D}^{L}\) is injective if there exists a function \(g:^{L}^{N D}\) such that for any \(^{N D}\), we have \(g f()\). Then \(g\) is an inverse of \(f\).

And we summarize the existence of continuous inverse of \(_{K}()\) into the following lemma shown by  and improved by . This result comes from homeomorphism between roots and coefficients of monic polynomials .

**Lemma 2.8** (Existence of Continuous Inverse of Sum-of-Power ).: \(_{N}:^{N}^{N}\) _is injective, thus the inverse \(_{N}^{-1}:^{N}^{N}\) exists. Moreover, \(_{N}^{-1}\) is continuous._

Now we are ready to prove necessity in Theorem 2.4 as sufficiency is easy to check. By choosing \(=_{N}:^{N}\) to be the power mapping (cf. Definition 2.6), and \(=f_{N}^{-1}\). For any scalar-valued set \(=x^{(1)}&&x^{(N)}^{}\), \((_{i=1}^{N}(x^{(i)}))=f_{N}^{-1}_{N}( )=f()=f()\) for some \((N)\). The existence and continuity of \(_{N}^{-1}\) are due to Lemma 2.8.

Theorem 2.4 gives the _exact decomposable form_ for permutation-invariant functions, which is stricter than approximation error based expressiveness analysis. In summary, the key idea is to establish a mapping \(\) whose element-wise sum-pooling has a continuous inverse.

Curse of High-dimensional Features.We argue that the proof of Theorem 2.4 is not applicable to high-dimensional set features (\(D 2\)). The main reason is that power mapping defined in Definition 2.6 only receives scalar input. It remains elusive how to extend it to a multivariate version that admits injectivity and a continuous inverse. A plausible idea seems to be applying power mapping for each channel \(_{i}\) independently, and due to the injectivity of sum-of-power mapping \(_{N}\), each channel can be uniquely recovered individually via the inverse \(_{N}^{-1}\). However, we point out that each recovered feature channel \(}_{i}_{i}\), \( i[D]\), does not imply \([}_{1}}_{D}]\), where the alignment of features across channels gets lost. Hence, channel-wise power encoding no more composes an injective mapping. Zaheer et al.  proposed to adopt multivariate polynomials as \(\) for high-dimensional case, which leverages the fact that multivariate symmetric polynomials are dense in the space of permutation invariant functions (akin to Stone-Wasserstein theorem) . This idea later got formalized in  by setting \((^{(i)})=&_{j[D]}(x_{j}^{(i)})^{ _{j}}&\) where \(^{D}\) traverses all \(_{j[D]}_{j} n\) and extended to permutation equivariant functions. Nevertheless, the dimension \(L=\), i.e., exponential in \(\{N,D\}\) in this case, and unlike DeepSets  which exactly recovers \(f\) for \(D=1\), the architecture in  can only approximate the desired function.

## 3 Main Results

In this section, we present our main result which extends Theorem 2.4 to high-dimensional features. Our conclusion is that to universally represent a set function on sets of length \(N\) and feature dimension

Figure 1: Illustration of the proposed linear + power mapping embedding layer (LP) and logarithm activation + linear + exponential activation embedding layer (LLE).

\(D\) with the DeepSets architecture  (Eq. (1)), a dimension \(L\) at most polynomial in \(N\) and \(D\) is needed for expressing the intermediate embedding space.

Formally, we summarize our main result in the following theorem.

**Theorem 3.1** (The main result).: _Suppose \(D 2\). For any continuous permutation-invariant function \(f:^{N D}\), \(\), there exists two continuous mappings \(:^{D}^{L}\) and \(:^{L}\) such that for every \(^{N D}\), \(f()=(_{i=1}^{N}(^{(i)}))\) where_

* _For some_ \(L[N(D+1),N^{5}D^{2}]\) _when_ \(\) _admits_ _linear layer + power mapping (LP) architecture:_ \[()=[_{N}(_{1})^{}_{N}( _{K})^{}]\] (2) _for some_ \(_{1},,_{K}^{D}\)_, and_ \(K=L/N\)_._
* _For some_ \(L[ND,2N^{2}D^{2}]\) _when_ \(\) _admits_ _logarithm activations + linear layer + exponential activations (LLE) architecture:_ \[()=[(_{1}())(_{L }())]\] (3) _for some_ \(_{1},,_{L}^{D}\) _and_ \(_{>0}\)_._

The bounds of \(L\) depend on the choice of the architecture of \(\), which are illustrated in Fig. 1. In the LP setting, we adopt a linear layer that maps each set element into \(K\) dimension. Then we apply a channel-wise power mapping that separately transforms each value in the feature vector into an \(N\)-order power series, and concatenates all the activations together, resulting in a \(KN\) dimension feature. The LP architecture is closer to DeepSets  as they share the power mapping as the main component. Theorem 3.1 guarantees the existence of \(\) and \(\) (in the form of Eq. (2)) which satisfy Eq. (1) without the need to set \(K\) larger than \(N^{4}D^{2}\) while \(K D+1\) is necessary. Therefore, the total embedding size \(L=KN\) is bounded by \(N^{5}D^{2}\) above and \(N(D+1)\) below. Note that this lower bound is not trivial as \(ND\) is the degree of freedom of the input \(\). No matter how \(_{1},...,_{K}\) are adopted, one cannot achieve an injective mapping by just using \(ND\) dimension.

In the LLE architecture, we investigate the utilization of logarithmic and exponential activations in set representation, which are also valid activations to build deep neural networks . Each set entry will be squashed by a element-wise logarithm first, then linearly embedded into an \(L\)-dimensional space via a group of weights, and finally transformed by an element-wise exponential activation. Essentially, each \((_{i}()),i[L]\) gives a monomial of \(\). The LLE architecture requires the feature space constrained on the positive orthant to ensure logarithmic operations are feasible. But the advantage is that the upper bound of \(L\) is improved to be \(2N^{2}D^{2}\). The lower bound \(ND\) for the LLE architecture is a trivial bound due to the degree of freedom of the input \(\). Note that the constraint on the positive orthant \(_{>0}\) is not essential. If we are able to use monomial activations to process a vector \(\) as used in , then, the constraint on the positive orthant can be removed.

_Remark 3.2_.: The bounds in Theorem 3.1 are non-asymptotic. This implies the latent dimensions specified by the corresponding architectures are precisely sufficient for expressing the input.

_Remark 3.3_.: Unlike \(\), the form of \(\) cannot be explicitly specified, as it depends on the desired function \(f\). The complexity of \(\) remains unexplored in this paper, which may be high in practice.

Importance of Continuity.We argue that the requirements of continuity on \(\) and \(\) are essential for our discussion. First, practical neural networks can only provably approximate continuous functions . Moreover, set representation without such requirements can be straightforward (but likely meaningless in practice). This is due to the following lemma.

**Lemma 3.4** ().: _There exists a discontinuous bijective mapping between \(^{D}\) and \(\) if \(D 2\)._

By Lemma 3.4, we can define a bijective mapping \(r:^{D}\) which maps the high-dimensional features to scalars, and its inverse exists. Then, the same proof of Theorem 2.4 goes through by letting \(=_{N} r\) and \(=f r^{-1}_{N}^{-1}\). However, we note both \(\) and \(\) lose continuity.

Comparison with Prior Arts.Below we highlight the significance of Theorem 3.1 in contrast to the existing literature. A quick overview is listed in Tab. 1 for illustration. The lower bound in Theorem 3.1 corrects a natural misconception that the degree of freedom (i.e., \(L=ND\) for multi-channel cases) is not enough for representing the embedding space. Fortunately, the upper bound in Theorem 3.1 shows the complexity of representing vector-valued sets is still manageable as it merely scales polynomially in \(N\) and \(D\). Compared with Zweig and Bruna's finding , our result significantly improves this bound on \(L\) from exponential to polynomial by allowing non-analytic functions to amortize the expressiveness. Besides, Zweig and Bruna's work  is hard to be applied to the real domain, while ours are extensible to complex numbers and equivariant functions.

## 4 Proof Sketch

In this section, we introduce the proof techniques of Theorem 3.1, while deferring a full version and all missing proofs to the supplementary materials.

The proof of Theorem 3.1 mainly consists of two steps below, which is completely constructive:

1. For the LP architecture, we construct a group of \(K\) linear weights \(_{1},_{K}\) with \(K N^{4}D^{2}\) such that the summation over the associated LP embedding (Eq. (2)): \(()=_{i=1}^{N}(^{(i)})\) is injective and has a continuous inverse. Moreover, if \(K D\), such weights do not exist, which induces the lower bound.
2. Similarly, for the LLE architecture, we construct a group of \(L\) linear weights \(_{1},_{L}\) with \(L 2N^{2}D^{2}\) such that the summation over the associated LLE embedding (Eq. (3)) is injective and has a continuous inverse. Trivially, if \(L<ND\), such weights do not exist, which induces the lower bound.
3. Then the proof of upper bounds can be concluded for both settings by letting \(=f^{-1}\) since \((_{i=1}^{N}(^{(i)}))=f^{-1}( )=f()=f()\) for some \((N)\).

Next, we elaborate on the construction idea which yields injectivity for both embedding layers in Sec. 4.1 and 4.2, respectively. To show injectivity, it is equivalent to establish the following statement for both Eq. (2) and Eq. (3), respectively:

\[,}^{N D},_{i=1}^{N}(^{(i)})=_{i=1}^{N}(}^{(i)})} \]

In Sec. 4.3, we prove the continuity of the inverse map for LP and LLE via arguments similar to .

### Injectivity of LP

In this section, we consider \(\) follows the definition in Eq. (2), which amounts to first linearly transforming each set element and then applying channel-wise power mapping. This is, we seek a group of linear transformations \(_{1},,_{K}\) such that \(}\) can be induced from \(_{i}}_{i}, i[K]\) for some \(K\) larger than \(N\) while being polynomial in \(N\) and \(D\). The intuition is that linear mixing among each channel can encode relative positional information. Only if \(}\), the mixing information can be reproduced.

Formally, the first step accords to the property of power mapping (cf. Lemma 2.8), and we can obtain:

\[_{i=1}^{N}(^{(i)})=_{i=1}^{N}(^{(i)}) _{i}}_{i}, i[K]. \]

To induce \(}\) from \(_{i}}_{i}, i[K]\), our construction divides the weights \(\{_{i},i[K]\}\) into three groups: \(\{_{i}^{(1)}:i[D]\}\), \(\{_{j}^{(2)}:j[K_{1}]\}\), and \(\{_{i,j,k}^{(3)}:i[D],j[K_{1}],k[K_{2}]\}\). Each block is outlined as below:

1. Let the first group of weights \(_{1}^{(1)}=_{1},,_{D}^{(1)}=_{D}\) to buffer the original features, where \(_{i}\) is the \(i\)-th canonical basis.
2. Design the second group of linear weights, \(_{1}^{(2)},,_{K_{1}}^{(2)}\) for \(K_{1}\) as large as \(N(N-1)(D-1)/2+1\), which, by Lemma 4.4 latter, guarantees at least one of \(_{j}^{(2)},j[K_{1}]\) forms an anchor defined below:

**Definition 4.1** (Anchor).: Consider the data matrix \(^{N D}\), then \(^{N}\) is called an anchor of \(\) if \(_{i}_{j}\) for any \(i,j[N]\) such that \(^{(i)}^{(j)}\).

And suppose \(=_{j^{*}}^{(2)}\) is an anchor of \(\) for some \(j^{*}[K_{1}]\) and \(}=}_{j^{*}}^{(2)}\), then we show the following statement is true by Lemma 4.3 latter:

\[[_{i}][} }_{i}], i[D]}. \]
3. Design a group of weights \(_{i,j,k}^{(3)}\) for \(i[D],j[K_{1}],k[K_{2}]\) with \(K_{2}=N(N-1)+1\) that mixes each original channel \(_{i}\) with each \(_{j}^{(2)},j[K_{1}]\) by \(_{i,j,k}^{(3)}=_{i}-_{k}_{j}^{(2)}\). Then we show in Lemma 4.5 that:

\[_{i}}_{i}, i[K][ _{j}^{(2)}_{i}][}_{j }^{(2)}}_{i}], i[D],j[K_{1}] \]

With such configuration, injectivity can be concluded by the entailment along Eq. (5), (7), (6): Eq. (5) guarantees the RHS of Eq. (7); The existence of the anchor in Lemma 4.4 paired with Eq. (6) guarantees \(}\). The total required number of weights \(K=D+K_{1}+DK_{1}K_{2} N^{4}D^{2}\).

Below we provides a series of lemmas that demonstrate the desirable properties of anchors and elaborate on the construction complexity. Detailed proofs are left in Appendix. In plain language, by Definition 4.1, two entries in the anchor must be distinctive if the set elements at the corresponding indices are not equal. As a consequence, we derive the following property of anchors:

**Lemma 4.2**.: _Consider the data matrix \(^{N D}\) and \(^{N}\) an anchor of \(\). Then if there exists \((N)\) such that \(=\) then \(_{i}=_{i}\) for every \(i[D]\)._

With the above property, anchors defined in Definition 4.1 indeed have the entailment in Eq. (6):

**Lemma 4.3** (Union Alignment based on Anchor Alignment).: _Consider the data matrix \(,}^{N D}\), \(^{N}\) is an anchor of \(\) and \(}^{N}\) is an arbitrary vector. If \([_{i}][}}_{i}]\) for every \(i[D]\), then \(}\)._

However, the anchor \(\) is required to be generated from \(\) via a point-wise linear transformation. The strategy to generate an anchor is to enumerate as many linear weights as needs, so that for any \(\), at least one \(j\) such that \(_{j}^{(2)}\) becomes an anchor. We show that at most \(N(N-1)(D-1)/2+1\) linear weights are enough to guarantee the existence of an anchor for any \(\):

**Lemma 4.4** (Anchor Construction).: _There exists a set of weights \(_{1},,_{K}\) where \(K=N(N-1)(D-1)/2+1\) such that for every data matrix \(^{N D}\), there exists \(j[K]\), \(_{j}\) is an anchor of \(\)._

We wrap off the proof by presenting the following lemma which is applied to prove Eq. (7) by fixing any \(i[D],j[K_{1}]\) in Eq. (7) while checking the condition for all \(k[K_{2}]\):

**Lemma 4.5** (Anchor Matching).: _There exists a group of coefficients \(_{1},,_{K_{2}}\) where \(K_{2}=N(N-1)+1\) such that the following statement holds: Given any \(,},,}^{N}\) such that \(}\) and \(}\), if \((-_{k})(}-_{k}})\) for every \(k[K_{2}]\), then \([][}}]\)._

For completeness, we add the following lemma which implies LP-induced sum-pooling cannot be injective if \(K ND\), when \(D 2\).

**Theorem 4.6** (Lower Bound).: _Consider data matrices \(^{N D}\) where \(D 2\). If \(K D\), then for every \(_{1},,_{K}\), there exists \(}^{N D}\) such that \(}\) but \(_{i}}_{i}\) for every \(i[K]\)._

_Remark 4.7_.: Theorem 4.6 is significant in that with high-dimensional features, the injectivity is provably not satisfied when the embedding space has dimension equal to the degree of freedom.

### Injectivity of LLE

In this section, we consider \(\) follows the definition in Eq. (3). First of all, we note that each term in the RHS of Eq. (3) can be rewritten as a monomial as shown in Eq. (8). Suppose we are able to use monomial activations to process a vector \(^{(i)}\). Then, the constraint on the positive orthant \(_{>0}\) in our main result Theorem 3.1 can be even removed.

\[()=[(_{i}())]=[ _{j=1}^{D}_{j}^{_{i,j}}] \]Then, the assignment of \(_{1},,_{L}\) amounts to specifying the exponents for \(D\) power functions within the product. Next, we prepare our construction with the following two lemmas:

**Lemma 4.8**.: _For any pair of vectors \(_{1},_{2}^{N},_{1},_{2}^{N}\), if \(_{i[N]}_{1,i}^{l-k}_{2,i}^{k}=_{i[N]}_{1,i}^{l- k}_{2,i}^{k}\) for every \(l,k[N]\) such that \(0 k l\), then \([_{1}_{2}][_{1}_{2}]\)._

The above lemma is to show that we may use summations of monic bivariate monomials to align every two feature columns. The next lemma shows that such pairwise alignment yields union alignment.

**Lemma 4.9** (Union Alignment based on Pairwise Alignment).: _Consider data matrices \(,}^{N D}\). If \([_{i}_{j}][}_{i}}_{j}]\) for every \(i,j[D]\), then \(}\)._

Then the construction idea of \(_{1},,_{L}\) can be drawn from Lemma 4.8 and 4.9:

1. Lemma 4.8 indicates if the weights in Eq. (8) enumerate all the monic bivariate monomials in each pair of channels with degrees less or equal to \(N\), i.e., \(_{i}^{p}_{j}^{q}\) for all \(i,j[D]\) and \(p+q N\), then we can yield: \[_{i=1}^{N}(^{(i)})=_{i=1}^{N}(}^{(i)}) [_{i}_{j}][}_{i}}_{j}], i,j[D].\] (9)
2. The next step is to invoke Lemma 4.9 which implies if every pair of feature channels is aligned, then we can conclude all the channels are aligned with each other as well. \[[_{i}_{j}][}_{i}}_{j}],  i,j[D]}.\] (10)

Based on these motivations, we assign the weights that induce all bivariate monic monomials with the degree no more than \(N\). First of all, we reindex \(\{_{i},i[L]\}\) as \(\{_{i,j,p,q},i[D],j[D],p[N],q[p+1]\}\). Then weights can be explicitly specified as \(_{i,j,p,q}=(q-1)_{i}+(p-q+1)_{j}\), where \(_{i}\) is the \(i\)-th canonical basis. With such weights, injectivity can be concluded by entailment along Eq. (9) and (10). Moreover, the total number of linear weights is \(L=D^{2}(N+3)N/2 2N^{2}D^{2}\), as desired.

### Continuous Lemma

In this section, we show that the LP and LLE induced sum-pooling are both homeomorphic. We note that it is intractable to obtain the closed form of their inverse maps. Notably, the following remarkable result can get rid of inversing a functions explicitly by merely examining the topological relationship between the domain and image space.

**Lemma 4.10**.: _(Theorem 1.2 ) Let \((,d_{})\) and \((,d_{})\) be two metric spaces and \(f:\) is a bijection such that **(a)** each bounded and closed subset of \(\) is compact, **(b)**\(f\) is continuous, **(c)**\(f^{-1}\) maps each bounded set in \(\) into a bounded set in \(\). Then \(f^{-1}\) is continuous._

Subsequently, we show the continuity in an informal but more intuitive way while deferring a rigorous version to the supplementary materials. Denote \(()=_{i[N]}(^{(i)})\). To begin with, we set \(=^{N D}/\) with metric \(d_{}(,^{})=_{(N)}\|- ^{}\|_{1}\) and \(=\{()|\}^{L}\) with metric \(d_{}(,^{})=\|-^{}\|_{}\). It is easy to show that \(\) satisfies the conditions **(a)** and \(()\) satisfies **(b)** for both LP and LLE embedding layers. Then it remains to conclude the proof by verifying the condition **(c)** for the mapping \(\), i.e., the inverse of \(()\). We visualize this mapping following our arguments on injectivity:

\[(LP))}_{} ()}}}{{ }}}_{}()}}}{{}}}_{} ()}}}{{ }}}_{}()}}}{{}}}_{} ()}}}{{ }}}_{}()}}}{{}}}_{} ()}}}{{ }}}_{},\]

for some \(\) dependent \(\), \(\). Here, \(_{i},i[K]\) and \(_{i,j},i,j[D](N)\). According to homeomorphism between polynomial coefficients and roots (Theorem 3.4 in ), any bounded set in \(\) will induce a bound set in \(\). Moreover, since elements in \(\) contains all the columns of \(\) (up to some changes of the entry orders), a bounded set in \(\) also corresponds to a bounded set in \(\). Through this line of arguments, we conclude the proof.

Extensions

In this section, we discuss two extensions to Theorem 3.1, which strengthen our main result.

Permutation Equivariance.Permutation-equivariant functions (cf. Definition 2.3) are considered as a more general family of set functions. Our main result does not lose generality to this class of functions. By Lemma 2 of , Theorem 3.1 can be directly extended to permutation-equivariant functions with _the same lower and upper bounds_, stated as follows:

**Theorem 5.1** (Extension to Equivariance).: _For any permutation-equivariant function \(f:^{N D}^{N}\), \(\), there exists continuous functions \(:^{D}^{L}\) and \(:^{D}^{L}\) such that \(f()_{j}=(^{(j)},_{i[N]}( ^{(i)}))\) for every \(j[N]\), where \(L[N(D+1),N^{5}D^{2}]\) when \(\) admits LP architecture, and \(L[ND,2N^{2}D^{2}]\) when \(\) admits LLE architecture (\(_{>0}\))._

Complex Domain.The upper bounds in Theorem 3.1 is also true to complex features up to a constant scale (i.e., \(\)). When features are defined over \(^{N D}\), our primary idea is to divide each channel into two real feature vectors, and recall Theorem 3.1 to conclude the arguments on an \(^{N 2D}\) input. All of our proof strategies are still applied. This result directly contrasts to Zweig and Bruna's work  whose main arguments were established on complex numbers. We show that even moving to the complex domain, polynomial length of \(L\) is still sufficient for the DeepSets architecture . We state a formal version of the theorem in the supplementary material.

## 6 Related Work

Works on neural networks to represent set functions have been discussed extensively in the Sec. 1. Here, we review other related works on the expressive power analysis of neural networks.

Early works studied the expressive power of feed-forward neural networks with different activations . Recent works focused on characterizing the benefits of the expressive power of deep architectures to explain their empirical success . Modern neural networks often enforce some invariance properties into their architectures such as CNNs that capture spatial translation invariance. The expressive power of invariant neural networks has been analyzed recently .

The architectures studied in the above works allow universal approximation of continuous functions defined on their inputs. However, the family of practically useful architectures that enforce permutation invariance often fail in achieving universal approximation. Graph Neural Networks (GNNs) enforce permutation invariance and can be viewed as an extension of set neural networks to encode a set of pair-wise relations instead of a set of individual elements . GNNs suffer from limited expressive power  unless they adopt exponential-order tensors . Hence, previous studies often characterized GNNs' expressive power based on their capability of distinguishing non-isomorphic graphs. Only a few works have ever discussed the function approximation property of GNNs  while these works still miss characterizing such dependence on the depth and width of the architectures . As practical GNNs commonly adopt the architectures that combine feed-forward neural networks with set operations (neighborhood aggregation), we believe the characterization of the needed size for set function approximation studied in  and this work may provide useful tools to study finer-grained characterizations of the expressive power of GNNs.

## 7 Conclusion

This work investigates how many neurons are needed to model the embedding space for set representation learning with the DeepSets architecture . Our paper provides an affirmative answer that polynomial many neurons in the set size and feature dimension are sufficient. Compared with prior arts, our theory takes high-dimensional features into consideration while significantly advancing the state-of-the-art results from exponential to polynomial.

Limitations.The tightness of our bounds is not examined in this paper, and the complexity of \(\) is uninvestigated and left for future exploration. Besides, deriving an embedding layer agnostic lower bound for the embedding space remains another widely open question.