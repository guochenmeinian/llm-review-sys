# MALT Powers Up Adversarial Attacks

Odelia Melamed

Weizmann Institute of Science, Israel, odelia.melamed@weizmann.ac.il

Gilad Yehudai

Center for Data Science, New York University, gy2219@nyu.edu

Adi Shamir

Weizmann Institute of Science, Israel, adi.shamir@weizmann.ac.il.

###### Abstract

Current adversarial attacks for multi-class classifiers choose the target class for a given input naively, based on the classifier's confidence levels for various target classes. We present a novel adversarial targeting method, _MALT - Mesoscopic Almost Linearity Targeting_, based on medium-scale almost linearity assumptions. Our attack wins over the current state of the art AutoAttack on the standard benchmark datasets CIFAR-100 and ImageNet and for a variety of robust models. In particular, our attack is _five times faster_ than AutoAttack, while successfully matching all of AutoAttack's successes and attacking additional samples that were previously out of reach. We then prove formally and demonstrate empirically that our targeting method, although inspired by linear predictors, also applies to standard non-linear models.

## 1 Introduction

Neural networks are widely known to be susceptible to adversarial perturbations (Szegedy et al. ), which are typically imperceptible by humans. Many different papers have shown how to construct such attacks, where adding a small perturbation to the input significantly changes the output of the model (Carlini and Wagner , Papernot et al. , Athalye et al. ). To protect from these attacks, researchers have tried to develop more robust models using several different techniques, such as adversarial training using different attacks (Madry et al. , Papernot et al. , Liu et al. , Wang et al. ).

The current state of the art adversarial attack, known as AutoAttack (Croce and Hein ), combines several different parameter-free attacks, some targeted and some untargeted. AutoAttack currently leads the RobustBench benchmark (Croce et al. ), which is the standard benchmark for adversarial robustness. Notably, the targeted attacks used in AutoAttack pick the adversarial target classes according to the model's confidence levels and attack the top nine classes, even though CIFAR-100 and ImageNet have many more possible target classes. The reason for attacking only a limited number of classes, rather than all possible classes, is computational, as each such attack has a significant running time.

The reason that adversarial examples exist remains a hot topic of debate, specifically, whether it is due to the highly non-linear landscape of neural networks or rather to their local linearity properties. In Goodfellow et al. , the authors provide several strong arguments for the local linearity hypothesis while presenting FGSM, a one-step gradient attack. Following Bubeck et al. , we consider three distance scales around each fixed data point where linearity properties should be studied separately. On the _macroscopic_ scale, neural networks are highly non-linear functions and have very complicated decision boundaries. On the other hand, neural networks with ReLU activation are piecewise linear, and thus at the _microscopic_ scale (in which no ReLU input changes signs), they can be seen as completely linear functions. The third is the intermediate _mesoscopic_ scale, which characterizes the typical distances between inputs to their nearest adversarial examples.

At this mesoscopic scale, Bubeck et al. (2021) proved that random networks are _locally almost linear_, hinting that for adversarial examples, we can use prediction techniques that are motivated by the behavior of linear functions.

In this paper, we present a novel adversarial attack, _MALT_ (Mesoscopic Almost Linearity Targeting), which is five times faster than the current SOTA attack while exceeding its success rate. It uses the common fast APGD attack (Croce and Hein (2020)) with a new targeting algorithm. The basic idea of MALT is that instead of sorting the target classes only by the confidence levels of the attacked model, _MALT_ normalizes the class's confidence by the norm of the row of the Jacobian corresponding to it. This ordering is motivated by the case of linear classifiers that can be fully analyzed, and makes use of the almost linearity of the model at the mesoscopic scale.

Our attack wins over AutoAttack on both CIFAR-100 and ImageNet datasets for different robust models from the standard RobustBench benchmark. In particular, in all of our experiments, we show that the MALT targeting algorithm eliminates the need to use any attacks other than APGD: for every image that AutoAttack successfully attacks, MALT also succeeds while reaching several additional images on which AutoAttacks fails. A major benefit of MALT is that on SOTA robust models, our attack runs _five times faster_ than AutoAttack on the ImageNet attack test dataset.

To further support the mesoscopic almost linearity hypothesis presented in Goodfellow et al. (2014) and Bubeck et al. (2021), we demonstrate both theoretically and empirically that our targeting method, though inspired by linearity considerations, also applies to non-linear models. On the theoretical side, we consider the setting of Melamed et al. (2023), Haldar et al. (2024) where the data resides on a low dimensional manifold, and prove that the network remains "almost linear" at the mesoscopic scale around data points, deducing that the ordering provided by our targeting method is preserved in that scale. Empirically, we demonstrate that models tend to be almost linear close to data points by showing that a linear approximation successfully predicts the model's output when taking random or adversarial steps away from a data point.

## 2 Related Works

Linearity and adversarial attacks The local linearity of non-linear classifier in the context of adversarial example was first hypothesized for explaining the adversarial examples' existence (Goodfellow et al. (2014)), presenting the successful FGSM attack. Later, multi-step attacks with higher success rates have shown that the standard classifiers, indeed, are not entirely linear in the mesoscopic scale (Madry et al. (2017), Carlini and Wagner (2017)). Local linearity was also researched in the robustness context, finding linearity constraints increases the classifier robustness (Uesato et al. (2018), Sarkar and Iyengar (2020), Qin et al. (2019)) and the attack transferability (Papernot et al. (2017), Guo et al. (2020)).

Targeting methods As a non-naive targeting method has yet to be proposed, the FAB attack (Croce and Hein (2020)) and DeepFool attack (Moosavi-Dezfooli et al. (2016)) are using a step-wise targeting method to boost the untargeted version of the attack. The step-wise point of view, looking at the microscopic scale, allows assuming linearity, and estimating the best target becomes an easy linear problem. Sarkar and Iyengar (2020) uses the same simple method for linearity-enforced classifiers. Our targeting method implements the same linearity-based targeting idea but is calculated once at the starting point.

Theory of adversarial attacks The source of adversarial examples has been extensively researched in recent years. Building on Shamir et al. (2019), it was shown in Daniely and Shaacham (2020) that adversarial perturbations appear in random networks. This result was extended to a larger family of networks with random weights (Bartlett et al. (2021), Bubeck et al. (2019, 2021), Montanari and Wu (2022)). In Vardi et al. (2022), Frei et al. (2024), the authors show that the gradient method is implicitly biased towards non-robust networks. The hypothesis of the data lies in a low-dimensional manifold, which the adversarial examples are perpendicular to was suggested in both theoretical (Gilmer et al. (2018), Tanay and Griffin (2016), Melamed et al. (2023)) and applied (Song et al. (2017), Stutz et al. (2019), Shamir et al. (2021)) settings. Melamed et al. (2023) proved that for data that lies on a linear subspace, there exist adversarial perturbations. Their result is extended in Haldar et al. (2024) to clustered data.

## 3 MALT - Mesoscopic Almost Linearity Targeting

The targeted attacks in AutoAttack choose nine target classes to attack, while ImageNet, for example, contains \(1000\) classes. This is done since the running time of each such targeted attack is long, and attacking each image in the entire ImageNet test dataset for a large number of classes will be cumbersome. Hence, it is extremely important to choose the right nine target classes. Otherwise, the attack may fail on those target classes, while it may succeed on other classes that are not chosen.

The naive targeting in AutoAttack chooses the top nine classes sorted by the output of the model, which corresponds to the confidence the model gives to each class. In Figure 1, we show two examples of images from the ImageNet dataset on which AutoAttack fails, both with targeted and untargeted attacks, while MALT succeeds. For each image \(\), after finding the adversarial perturbation \(\) we divide it into \(100\) equal parts, namely \(_{i}=\) for \(i=0,,100\). We plot the network's confidence levels for each class \(N(+_{i})\) (y-axis) w.r.t the interval \(i=0,...,100\) (x-axis). The advantage of MALT here is that it allows targeting classes that are overlooked by AutoAttack. Before presenting the MALT attack, we motivate it by analyzing adversarial attacks in linear models. Additional examples where MALT finds adversarial examples while AutoAttack fails can be found in Appendix A.

### Motivation - The best target in a linear function

Naive targeting methods consider the top-\(c\) classes with the largest output of the model, i.e., the top-\(c\) logits (often, for \(c=9\)), which corresponds to the classes that receive the highest confidence from the model. However, our goal is to find the target class for which its adversarial perturbation is the smallest from a given data point. In fact, it is not the case in general that the targets with the highest confidence will also have a small adversarial perturbation. For linear predictors, it is possible to fully analyze and find the target class with the smallest adversarial perturbation, as shown in the following:

**Lemma 3.1**.: _Consider a linear predictor over \(k\) classes of the form \(F()=W+\) where \(^{d},W^{k d}\) and \(^{k}\). Denote the \(i\)-th row of \(W\) by \(_{i}\) and by \(F_{i}()=_{i},+b_{i}\) the \(i\)-th output of \(F\) for every \(i[k]\). Let \(_{0}^{d}\) with \(*{arg\,max}_{i}F_{i}(_{0})=\) and denote by \(_{i}:=_{i}-_{},_{0} }{\|_{i}-_{}\|^{2}}\). Then, the adversarial perturbation \(\) that changes the label of \(_{0}\) with the smallest \(L_{2}\) norm is equal to \(:=_{j}(_{j}-_{})\) for the target class \(j:=*{argmin}_{i}_{i}-_{}, _{0}}{\|_{i}-_{}\|}\)._

The full proof is deferred to Appendix B. The above lemma states that, for a data point \(_{0}\) classified by the linear predictor as class \(\), the class \(i\) with the smallest linear perturbation will minimize the term \(_{i}-_{},_{0}}{\| _{i}-_{}\|}\). Note that the term \(_{i}-_{},_{0}\) represents the distance between the output of

Figure 1: Examples of images from the ImageNet dataset that AutoAttack fails to attack while MALT succeeds. The top row shows an APGD attack on the target class with the highest logit, and the bottom row shows an APGD attack on the class which MALT finds and succeeds, corresponding to the (a) \(18\)th and (b) \(52\)nd classes with the highest logits. The images are shown before and after the attack, and the change in logits is presented in the middle column.

the model on class \(\) and class \(i\), which are the logits that are commonly used in selecting the targets for adversarial attacks. The lemma states that this term should be divided by \(\|_{i}-_{}\|\), which corresponds to the norm of the difference between the gradients.

There is an intuitive explanation as to why this targeting method is optimal for linear predictors. While the term \(_{i}-_{},_{0}\) represents the "distance" that the adversarial perturbation should move to change the prediction class, the term \(\|_{i}-_{}\|\) represents the "speed" at which this change happens. Thus, the fastest way to change the prediction class is to consider the target for which the ratio between the distance and the speed is the smallest.

### Targeting method

We now formalize MALT, which is an adversarial attack that is applicable to any model, not only linear. The basic idea is to re-order the target classes using our targeting method, and then employ a fast targeted adversarial attack towards those targets.

Consider a classification model over \(k\)-classes (e.g., a neural network) \(N:^{d}^{k}\). Suppose we are given a data point \(_{0}^{d}\) classified in class \(\) by \(N\), meaning that \(=_{j\{1,,k\}}(N(_{0}))_{j}\). We look at the top \(c\) (\(c k\)) classes ordered by their output on \(_{0}\), and for each such class \(j\) calculate a score of the form \(_{0}))_{j}-(N(_{0}))_{0}}{(| N(_{ 0}))_{j}-( N(_{0}))_{0}\|}\). We now pick the top \(a\) (\(a c k\)) classes re-ordered by our score and perform a targeted adversarial attack towards it. The two hyperparameters in our algorithm are \(c\), which represents the number of candidates for which we calculate the score, and \(a\), which represents the number of classes we perform a targeted attack towards. The full attack algorithm is presented in Algorithm 1.

Note that to calculate a score for some target class, we need to calculate the gradient of the model on \(_{0}\) w.r.t this class. For datasets with many possible classes (e.g. ImageNet) we would like to limit these calculations. In all of our experiments, we used \(c=100\) and \(a=9\).

We note that our targeting method is compatible with any targeted attack. We empirically found that APGD (Croce and Hein (2020)) with the default DLR loss performs well across datasets and models, improving the current state of the art - AutoAttack (Croce and Hein (2020)). Full empirical results are in Section 5.

```
Input: Trained classification model \(N:^{d}^{k}\), data point \(_{0}^{d}\), hyperparameters \(a,c\).  set \(=_{j\{1,,k\}}(N(_{0}))_{j}\)  Set CandidateClasses \(=[0,,0]\), a list of size \(c\) fortop \(c\) classes \(i\{1,k\}\{\}\) ordered by \((N(_{0}))_{i}\)do  Set AttackScore\({}_{i}=_{0}))_{i}-(N(_{0}))_{}}{\|( N( _{0}))_{i}-( N(_{0}))_{}\|}\)  Append \((i,_{i})\) to the CandidateClasses list endfor  Sort CandidateClasses list by AttackScore for class \(i\) in the top \(a\) classes of the CandidateClasses list do  Run TargetedAttack\((N,_{0},i)\) if Adversarial perturbation found then  return the adversarial perturbation endif endfor
```

**Algorithm 1** MALT attack algorithm

### Complexity analysis

We now calculate the time complexity of MALT with APGD, and compare it with the time complexity of AutoAttack. We calculate the complexity in terms of forward and backward passes (i.e., gradient calculations). We also consider the default hyperparameters of each adversarial attack, e.g., for APGD, we perform an attack with \(100\) iterations.

**MALT with APGD.** Calculating the targeting order takes \(c\) backward passes, since the corresponding row of the Jacobian is calculated. For the top \(a\) classes in this ordering, we perform an APGD attack which takes \(a 100\) backward passes and \(a 100\) forward passes.

**AutoAttack.** We calculate the complexity of each attack separately: (1) Untargeted APGD with CE loss takes \(100\) forward and \(100\) backward passes; (2) Targeted APGD with DLR loss attack the top \(9\) targets, which takes \(900\) forward and \(900\) backward passes; (3) Targeted FAB also attack the top \(9\) targets, runs for \(100\) iterations and takes one backward, two forward passes for each iteration, in addition to three forward passes for each target. In total, it takes \(900\) backward and \(1827\) forward passes; and (4) Untargeted Square black-box attack for \(5000\) steps, which takes \(1\) forward pass each for a total of \(5000\) forward passes.

Finally, we sum the total complexity, and use the hyperparameters \(c=100,\ a=9\) for MALT (which are used in our experimental results). MALT takes \(1000\) backward and \(900\) forward passes, while AutoAttack takes \(1900\) backward and \(7827\) forward passes. Since each forward pass takes approximately the same time as a backward pass, we conclude that MALT requires \(1900\) passes, while AutoAttack takes \(9727\) passes, which is more than _five times_ faster. In Section 5, we complement this analysis with experiments, showing that also in practice, MALT is on average five times faster than AutoAttack on the ImageNet test dataset.

## 4 Mesoscopic Almost Linearity in Neural Networks

In the previous section, we defined MALT, which relies on normalizing the output of the model by the magnitude of the gradients. This method was motivated by analyzing a linear predictor and finding the target class with the closest adversarial example. However, neural networks are highly non-linear, and the gradient can potentially change significantly when traversing the trajectory from a data point to an adversarial example. In this section, we claim that neural networks behave as though they are almost linear in the mesoscopic scale, in the sense that the norm of the gradient does not change very much when moving from a data point towards an adversarial example. This means that the target classes which MALT chooses to attack remain good target classes also when moving away from the attacked data point.

### Almost Linearity for Data Residing on a Low-Dimensional Subspace

In this subsection, we prove theoretically that \(2\)-layer neural networks are almost linear in the mesoscopic scale and in certain directions under the setting where the high-dimensional data lies on a low-dimensional manifold. This setting was studied in several works such as Fawzi et al. (2018); Khoury and Hadfield-Menell (2018); Shamir et al. (2021); Melamed et al. (2023). In particular, we consider the setting from Melamed et al. (2023), where the authors analyzed two-layer networks, and the data lies on a low-dimensional linear subspace. All the proofs can be found in Appendix C.

**Model.** Our model is a two-layer fully-connected ReLU network \(N:^{d}\) with input dimension \(d\) and hidden dimension \(m\): \(N(,_{1:m})=_{i=1}^{m}u_{i}(_{i}^{} )\), where \(:\) is a non-linear activation, and \(_{1:m}=(_{1},,_{m})\). We additionally assume that \(\) is \(L\)-smooth and there exists \(>0\) such that \(^{}(z)\) for every \(z\). An example of such an activation is a smoothed version of Leaky ReLU. We initialize the first layer using standard Kaiming initialization He et al. (2015), i.e. \(_{i}(,I)\), and the output layer as \(u_{i}(\{}\})\). Note that in standard Kaiming initialization, each \(u_{i}\) would be initialized normally with a standard deviation of \(}\). For ease of analysis, we fix these weights to their standard deviation and only randomize the sign (this was also done in Melamed et al. (2023); Bubeck et al. (2021)).

**Data.** Following Melamed et al. (2023), our main assumption on the data is that it lies on a low dimensional linear subspace. Namely, we consider a binary classification dataset \((_{1},y_{1}),,(_{m},y_{r})^{d}\{  1\}\). We assume there exists a linear subspace \(P\) of dimension \(<d\) such that \(_{i} P\) for every \(i\).

**Loss and training.** Given a loss function \(L:\) (e.g. MSE, BCE), we consider the optimization problem: \(_{_{1:m}}_{i=1}^{r}L(y_{i},N(_{i},_{1:m }))\), which is optimized using standard gradient descent. For ease of analysis, we assume only the weights of the first layer are trained (i.e. the \(_{i}\)'s) while the weights of the second layer (i.e. the \(u_{i}\)'s) are fixed at their initial values, this wasalso done in Melamed et al. (2023). Since we consider trained networks in our results, we will write \(N()\), and omit the \(_{1:m}\) as an input to the network.

**Mesoscopic local linearity.** Following Bubeck et al. (2021), we say that the network \(N\) is _mesoscopic locally linear_ at a point \(_{0}\) with \(\|\|\) if for every \(\) with \(\|\|=o()\) we have:

\[\| N(_{0})- N(_{0}+)\|=o(\| N( _{0})\|)\;. \]

We now show an upper bound on the l.h.s of Eq. (1) and a lower bound on the r.h.s of Eq. (1) when projecting the gradients on the orthogonal subspace on which the data lies on. In the following theorems, \(_{P^{}}\) means an orthogonal projection on the subspace \(P^{}\).

**Theorem 4.1**.: _Suppose that the network \(N(,_{1:m})=_{i=1}^{m}u_{i}(_{i}^{} )\) is trained on a dataset which lies on a linear subspace \(P\) of dimension \(\). Then, w,p \(>1-\) over the initialization for every \( P^{}\) with \(\|\| R\) and every \( P\) we have that:_

\[\|_{P^{}}( N()- N(+) )\| 20LR()}{d-}} +)}{m})\]

**Theorem 4.2**.: _Under the same assumptions as in Theorem 4.1 and that \(d 2()\), w,p \(>1-\) over the initialization we have that:_

\[\|_{P^{}}(_{}N())\| )}{d}}}\]

Using both theorems, we can prove that the network is mesoscopic almost linear in directions orthogonal to the data subspace:

**Corollary 4.1**.: _Suppose that the network \(N()=_{i=1}^{m}u_{i}(_{i}^{})\) is trained on a dataset which lies on a linear subspace \(P\) of dimensions \(\). Let \( P^{}\) with \(\|\| R\) and \( P\). Assume that \(=(1),\ d-=(d)\), \(R=o()\) and \(m=(d-)\), then we have that:_

\[\|_{P^{}}( N(_{0})- N(_{0}+) )\|=o(\|_{P^{}}( N(_{0}))\|)\;.\]

The reason that the directions orthogonal to the data subspace are interesting, is because it is proven in previous works that in those directions, there exist adversarial perturbations, see for example Melamed et al. (2023); Haldar et al. (2024). This means that if we consider an adversarial perturbation in those directions, the ordering of the target classes from our targeting method should remain approximately the same throughout the trajectory of the perturbation. This is because the norm of the difference between the gradients is not too big, at least compared to the norm of the gradient itself.

**Remark 4.1** (Assumption in the theoretical part).: _For the formal statements to work, we make several simplifying assumptions. In Appendix C.4, we provide further explanation on the necessity of those assumptions and whether they could be relaxed. In a nutshell, most assumption (especially the ones on the activation) are made since we consider a very general setting, where our only assumption on the data is that it lies on a low dimensional manifold, note that we don't assume a more intricate structure or limit the number of training points. By introducing more assumptions on the data, we could relax our other assumptions._

### Empirical local linearity

In this section, we study mesoscopic almost linearity empirically using state of the art robust networks from RobustBench (Croce et al. (2020)), and for both the CIFAR100 and ImageNet datasets. In the first experiment, for each image \(_{0}\) in the test dataset, we consider an \(\)-norm ball in \(L_{}\) around it (with \(=8/255\) and \(4/255\) for CIFAR100 and ImageNet respectively). Our goal is to study how the gradient changes when moving from \(_{0}\) to a \(_{0}+\), where \(\) is some direction inside the \(\)-ball.

We use two strategies to choose the direction \(\). The first is drawing a random direction for each image, and the second is the direction of the gradient at each image, which corresponds to an adversarial direction. After choosing \(\) we divide it into \(100\) equal parts, namely \(_{1}=,_{2}=, ,_{100}=\). We will consider two measures to study the mesoscopic linearity:\[=_{0})- N(_{0}+_{i})\|} {\| N(_{0})\|},\;\;\;_{}=_{0}+_{i+1})- N(_{0}+_{i})\|}{\|  N(_{0})\|}\;.\]

Namely, \(\) corresponds to Eq. (1) and measures the total change in gradient norm from \(_{0}\) until \(_{i}\), while \(_{}\) measure this change but only for consecutive steps. In Figure 1(a) and Figure 1(b) we plot \(\) and \(_{part}\) for all \(i\) for both adversarial and random step \(\), respectively, for the ImageNet Swin-L (Liu et al., 2023) classifier and the CIFAR100 WRN-28-10 (Wang et al., 2023) classifier. The experiment details are in Appendix D.1.

It can be seen that for random directions (Figure 1(b)), both \(\) and \(_{}\) are very small for both datasets, and with a very small variance. For adversarial directions (Figure 1(a)), \(_{}\) is still very small, while \(\) is larger since it accumulates small deviations from linearity when moving further away from \(_{0}\). We emphasize that by Eq. (1), mesoscopic almost linearity means that \(=o_{d}(1)\), where \(d\) is the dimension of the input. In other words, a larger input dimension should decrease, or at least not increase, the value of \(\). In this experiment, the CIFAR100 and ImageNet datasets have very different input dimensions, namely, \(d=3072\) and \(d=150528\). We see that although the input dimension is almost \(50\) times larger for ImageNet compared to CIFAR100, the average value of \(\) is nearly the same. This implies that mesoscopic almost linearity also happens in adversarial directions, and it would be interesting to further study how \(\) changes when having even more drastic changes in the input dimension.

In our second experiment, we take a small adversarial step and compare the change of the logits of the output of the network and its linear approximation. In Figure 3, for each image \(_{0}\), we find an adversarial direction \(\), which we split into \(100\) equal parts similarly to the previous experiment. For a network \(N\) we calculate its linear approximation \(L\) at \(_{0}\) using Taylor's expansion, and compare \(N(_{0}+_{i})\) to \(L(_{0}+_{i})\). Note that since \(L\) is a linear function, \(L(_{0}+_{i})\) is always a straight line when plotting the output for every \(i=1,,100\). It can be seen that although \(N(_{0}+_{i})\) is not necessarily linear, it does closely resemble the linear approximation, which suggests that almost linearity happens in the mesoscopic scale. We note that the logits from Figure 0(b) look less linear than in the figures below. We conjecture that this is because it is difficult to find an adversarial example for this image (and indeed, AutoAttack fails to do so). Hence, the network is less linear in those adversarial directions, and such examples are what causes the high variance in Figure 1(a). This may require additional investigation, which we leave for future research.

## 5 Experiments

In this section, we compare the MALT attack (using a standard APGD attack) to the current state of the art AutoAttack. Our comparison is made to be compatible with RobustBench (Croce et al. (2020)), which is the standard benchmark for testing adversarial robustness. Namely, we consider attack on CIFAR-100 (Krizhevsky et al. (2009)) with an \(_{}\) budget of \(=8/255\) and on ImageNet (Deng et al. (2009)) with an \(_{}\) budget of \(=4/255\). We compare the two attacks on several robust models from the top RobustBench benchmark.

For MALT, we consider calculating the score for the \(c=100\) classes with the highest model's confidence and attacking the top \(a=9\) classes according to this score. This corresponds to the

Figure 2: Measurement of **mesoscopic almost linearity** experimentally when taking a step \(\) away from test image \(x_{0}\) for CIFAR100 and ImageNet. The results are averaged over all the images in the test set, where (a) random step; and (b) Direction of the gradient (adversarial step).

targeted attacks in AutoAttack, which attempt to attack the top \(9\) classes according to the model's confidence. All the hyperparameters of APGD and the other attacks used in AutoAttack are set to their default values. Full details for all experiments in this section are in Appendix D.

In Table 1 (CIFAR-100) and Table 2 (ImageNet), we present the results of the experiments. Note that MALT is able to attack more images than AutoAttack across all robust models and for both datasets. Also, there is an inclusion of successful attacks in the sense that for every image that AutoAttack successfully attacks, MALT also succeeds. Thus, the improvement contains only images that AutoAttack fails on. Note that in Table 2, the robust and clean accuracy is not exactly equal to those reported on the RobustBench website since newer versions of the Python libraries in use give slightly different results.

   &  \\   & acc. & MALT & SOTA & diff & speed-up \\  WRN-28-10  & \(72.58\%\) & \(38.79\%\) & \(38.83\%\) & \(-0.04\%\) & \(\) 3.36 \(\)0.18 \\  WRN-70-16  & \(75.22\%\) & \(42.66\%\) & \(42.67\%\) & \(-0.01\%\) & \(\) 3.87 \(\)0.08 \\  WRN-28-10  & \(73.83\%\) & \(39.18\%\) & \(39.18\%\) & \(0\%\) & \(\) 3.43 \(\)0.08 \\  WRN-70-16  & \(69.15\%\) & \(36.81\%\) & \(36.88\%\) & \(-0.07\%\) & \(\) 3.42 \(\)0.09 \\  

Table 1: **CIFAR100 - \(L_{}\) robust accuracy _(lower is better)_, comparing MALT and AutoAttack, which is the current state of the art.

   &  \\   & acc. & MALT & SOTA & diff. & speed-up \\  Swin-L  & \(79.18\%\) & \(59.84\%\) & \(59.90\%\) & \(-0.06\%\) & \(\) 5.18 \(\)0.04 \\  ConvNeXT-L  & \(78.20\%\) & \(58.82\%\) & \(58.88\%\) & \(-0.06\%\) & \(\) 5.22 \(\)0.1 \\  ConvNeXT-L+  & \(77.02\%\) & \(57.94\%\) & \(57.96\%\) & \(-0.02\%\) & \(\) 4.86 \(\)0.06 \\  Swin-B  & \(76.22\%\) & \(56.54\%\) & \(56.56\%\) & \(-0.02\%\) & \(\) 5.02 \(\)0.03 \\  ConvNeXT-B+  & \(76.00\%\) & \(56.48\%\) & \(56.52\%\) & \(-0.04\%\) & \(\) 5.00 \(\)0.07 \\  

Table 2: **ImageNet - \(L_{}\) robust accuracy _(lower is better)_, comparing MALT and AutoAttack, which is the current state of the art.

Figure 3: Empirical **mesoscopic almost linearity**: demonstrating the logits changes from an image \(_{0}\) to its adversarial example. In the third row, we plot the model’s output logits changes, and in the bottom row are the results of the linear approximation of the model at \(_{0}\).

Attack Running TimeFor the speed-up column, we first sampled uniformly from the test dataset five batches of size \(200\) for ImageNet and \(400\) for CIFAR100, which corresponds to \(5 4\%\) of the entire test set. We timed both MALT and AutoAttack, when running on the exact same GPU chip and on the same samples, we present the mean and variance of these experiments for each robust model. On the ImageNet dataset there is on average a five times speed up, while for CIFAR100 it is \(3.5\) times on average. The lower rate can be explained by the higher attack success rates for CIFAR100. In other words, the complexity analysis from Section 3 is of the worst case, and since fewer test examples pass through all four different attacks in AutoAttack, the running time is lower.

Integrating MALT with different attacksOur experiments found that MALT operates well across datasets and models with the standard and fast APGD attack. We also integrated MALT with the targeted FAB attack (Croce and Hein (2020)) as well as with the APGD attack with the CE loss, on the Swin-L robust model (Liu et al. (2023)). Both attacks achieved a worse results of \(60.64\%\) for the FAB attack and \(60.52\%\) for the APGD attack with CE loss, compared to the superior \(59.84\%\) robust accuracy using APGD with the DLR loss.

### Targeting analysis

In this subsection, we analyze the targeting mechanism of MALT and whether other targeting techniques could have improved it. In Figure 4, we show how the successful attacks are distributed according to the score given either by MALT or the naive targeting (i.e., according to the model's confidence). It is evident that the score provided by MALT leans much more towards the top \(-1\) than naive targeting. This indicates that the score provided by MALT has a higher correlation with successful attacks than the naive targeting method. Also, since MALT successfully attacks more images for the top \(9\) targets (achieving robust accuracy of \(59.84\%\), compared to \(59.94\%\) for naive targeting), the sum over the columns of MALT attacks is larger than that of the naive targeting.

Finally, we test whether the choice of \(c=100\) is enough, namely calculating the score for MALT only for the top \(100\) classes sorted by the confidence level of the model. To this end, we ran MALT with \(c=1000\) for the ImageNet test dataset on the Swin-L robust network. Note that the number of gradient calculations for each test image has increased by a factor of more than two. This attack reached a robust accuracy of \(59.84\%\), _exactly the same as \(c=100\)_. This means that calculating the score for the top \(100\) classes is enough to find the top classes to attack. It may be possible to optimize this hyperparameter even more, although the benefit in running time will be negligible.

## 6 Conclusions

In this paper we present MALT, an adversarial attack which is based on a targeting method that assumes almost linearity in the mesoscopic scale. MALT wins over the current state of the art adversarial attack AutoAttack on several robust models, and for both CIFAR100 and ImageNet, while also speeding up the runtime by more than _five times_. We also present theoretical and empirical evidence that our almost linearity assumption is applied to neural network, in the mesoscopic scale where adversarial examples exist.

There are several future research directions that we think are interesting. First, it would be interesting to further study the mesoscopic almost linearity property of neural networks. In particular, whether this property is affected by (or affecting) the robustness of the network to adversarial perturbations, and the perturbation's transferability capabilities. Theoretically, it would be interesting to extend our

Figure 4: Comparing targeting methods for Liu et al. (2023) SOTA model: The number of successful attacks for each target order by two targeting methods: In blue, we use MALT targeting and APGD, and in orange, we compare to APGD with top logits targeting performed in AutoAttack.

analysis to deeper networks. As for the applied results, a good future direction would be to conduct a more extensive empirical study of MALT on more robust models and datasets, even beyond the scope of the RobustBench benchmark. Finally, it would be interesting to understand whether there exists a better targeting method to find adversarial classes, e.g., using a second-order approximation of the network.