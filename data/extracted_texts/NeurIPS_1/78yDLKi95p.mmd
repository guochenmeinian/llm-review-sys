# Language Model Tokenizers Introduce

Unfairness Between Languages

Aleksandar Petrov, Emanuele La Malfa, Philip H.S. Torr, Adel Bibi

University of Oxford

aleks@robots.ox.ac.uk

###### Abstract

Recent language models have shown impressive multilingual performance, even when not explicitly trained for it. Despite this, there are concerns about the quality of their outputs across different languages. In this paper, we show how disparity in the treatment of different languages arises at the tokenization stage, well before a model is even invoked. The same text translated into different languages can have drastically different tokenization lengths, with differences up to 15 times in some cases. These disparities persist even for tokenizers that are intentionally trained for multilingual support. Character-level and byte-level models also exhibit over 4 times the difference in the encoding length for some language pairs. This induces unfair treatment for some language communities in regard to the cost of accessing commercial language services, the processing time and latency, as well as the amount of content that can be provided as context to the models. Therefore, we make the case that we should train future language models using multilingually fair subword tokenizers.

## 1 Introduction

Language models are increasingly important in natural language processing tasks, as they can understand and generate human-like language. They have been deployed in applications such as virtual assistants (Chen et al., 2021; Ouyang et al., 2022), chatbots (Kuhail et al., 2023; Lee et al., 2023), machine translation (Stahlberg, 2020; Ranathunga et al., 2023), and text summarization (Kryscinski et al., 2019; Xu et al., 2020). As general-purpose technologies, it is also projected that Large Language Models (LLMs) will have a significant impact on the economy and the labour market (Teubner et al., 2023; Eloundou et al., 2023).

Such LLMs are often trained using large swaths of internet content regardless of language. Hence, these models often end up being multilingual, even if not by design. ChatGPT (OpenAI, 2022) is a prominent recent example (Bang et al., 2023; Jiao et al., 2023; Johnson, 2023). Given the economic benefits of LLMs and LLM-derived technology, it's beneficial that they support multiple languages. Equal access is crucial, and multilingual support is a key component of this.

However, this multilingualism is currently treated as a curious emergent phenomenon rather than a carefully designed, controlled and managed process. The performance of LLMs has been shown to be generally lower in non-target languages, a problem especially pronounced for low-resource languages (Virtanen et al., 2019; Ahuja et al., 2023). Providing access to the same technology in different languages but moderation and safety tools only for some has resulted in dire societal consequences before (Stecklow, 2018; Facebook, 2021; Leung, 2022). Differing cost of access could also reinforce inequality in opportunities for economic mobility and social participation (Lythreatis et al., 2022). Therefore, as LLM multilingualism emerges,

[MISSING_PAGE_FAIL:2]

The existence of glitch tokens like "\(\)\(\)\(\)"and "\(\)\(\)\(\)\(\)"despite the lack of a dedicated token for "\(}}}{{=}}\)" shows that tokenizers are heavily influenced by the biases of the corpus source. If one uses non-natural inputs, log files, or specialist forums, the tokenizer vocabulary would reflect this. While cl100K_base, the tokenizer used for the newer ChatGPT and GPT-4, may not have glitch tokens it still requires two tokens to represent some Cyrillic letters and three tokens for more than 65% of kanji characters. Therefore, to place all languages on an equal footing, it is important to have the tokens balanced across languages.

## 3 Measuring Tokenizer Parity

To demonstrate that the above examples are not anecdotal evidence, we introduce the notion of _tokenizer parity_ to systematically assess how fairly tokenizers treat equivalent sentences in different languages. Parity occurs when a tokenizer exhibits similar tokenized lengths for the same sentence in different languages. Take a sentence \(s_{A}\) in language \(A\) and its translation \(s_{B}\) to language \(B\). Then, a tokenizer \(t\) achieves parity for \(A\) with respect to \(B\) at \(s_{A}\) and \(s_{B}\) if \()|}}{{|t(s_{B})|}} 1\), where \(t(s_{A})\) is the tokenization of the sentence \(s_{A}\) and \(|t(s_{A})|\) represents its length. The ratio \()|}}{{|t(s_{B})|}}\) is the _premium_ for \(A\) relative to \(B\). 2

## 4 Tokenization Length Differences Across Languages

Languages vary significantly in the number of tokens required to encode the same content, as demonstrated in the examples in Section 2. Hence, following Section 3, we measure the tokenization premium of different tokenizers. To this end, we use the FLORES-200 parallel corpus, comprising of the same 2000 sentences taken from Wikipedia and human-translated to 200 different languages (Guzman et al., 2019; Goyal et al., 2021; Costa-jussa et al., 2022). We look at subword tokenization models which target English, languages other than English, language varieties, multi-lingual tokenizers, as well as tokenizer-free (byte-level) modelling.

### Parity for English-centric Models

As most models target English, we report in Table 1 the tokenization parity for a subset of languages in FLORES-200. The parities for all 200 languages are in Appendix C. 3 GPT-2 (Radford et al., 2019), RoBERTa (Liu et al., 2019), and the r50K_base, p50k_base and p50K_edit tokenizers (OpenAI, 2022) have close4 tokenization lengths so we report them together. ChatGPT and GPT-4 share the same cl100k_base tokenizer and are also reported together. Some models, such as FlanT5 (Chung et al., 2022), use a special UNK token to model unknown symbols not encountered during training. Hence, to ensure a fair comparison, we report only languages where no more than 10% of the input characters are mapped to UNK tokens (marked with --).

Table 1 shows large variations in the tokenizer parity for all tokenizers. For GPT-2 and RoBERTa, Pangasinan, the language with shortest tokenization, is already 66% more expensive to process than English. ChatGPT and GPT-4 are slightly closer to parity, likely

    &  &  &  \\  & RoBERTa & GPT-4 &  \\  Bulgarian & 5.51 & 2.64 & — \\ Burmese & 16.89 & 11.70 & — \\ Chinese (Simplified) & 3.21 & 1.91 & — \\ Dzongkha & 16.36 & 12.33 & — \\ English & 1.00 & 1.00 & 1.00 \\ French & 2.00 & 1.60 & 1.60 \\ German & 2.14 & 1.58 & 1.37 \\ Italian & 2.01 & 1.64 & 2.18 \\ Japanese & 3.00 & 2.30 & — \\ Jingpho & 2.65 & 2.35 & 3.41 \\ Maori & 2.45 & 2.35 & 3.28 \\ Norwegian Bokmål & 1.86 & 1.56 & 2.24 \\ Odia & 13.38 & 12.48 & — \\ Pangasinan & 1.66 & 1.57 & 2.18 \\ Portuguese & 1.94 & 1.48 & 2.21 \\ Romanian & 2.48 & 1.88 & 1.50 \\ Santali & 12.86 & 12.80 & — \\ Shan & 18.76 & 15.05 & — \\ Spanish & 1.99 & 1.55 & 2.23 \\ Standard Arabic & 4.40 & 3.04 & — \\ Tumbuka & 2.78 & 2.57 & 3.29 \\ Vietnamese & 4.54 & 2.45 & — \\   

Table 1: Premiums with respect to English on FLORES-200 for several **English-centric** models. The languages in the top or bottom three for any tokenizer, as well as the ones discussed in the text, are shown.

due to their larger vocabulary size. However, the cheapest languages, Portuguese, Pangasinan and German, still see a premium of 50% when compared to English. Shan has the worst tokenizer parity for all four models. Take as an example "\(\):", one of the Shan words for "you". It is tokenized by ChatGPT and GPT-4 as:

This word is constructed from one consonant and three diacritics. As the diacritics are encoded separately, there are four Unicode codepoints for this Shan character, resulting in 9 tokens. The English "you" has three characters but a single token.

FlanT5 has more than 10% UNK tokens for 42% of languages (-- in Table 1). It has a higher premium than the other tokenizers for all other languages except German and Romanian.

Summary.All four English-centric tokenizers we consider are far from tokenization parity. Portuguese is closest to parity with English for the ChatGPT and GPT-4 tokenizer but still requires about 50% more tokens for the same content. Shan is furthest from parity for this tokenizer with 15 times longer encodings compared to English. FlanT5 is closer to parity with its premium range 1.37-3.41 but it encodes only 54% of the languages, so we cannot say that it is more multilingually fair than the other tokenizers.

### Parity for Models with Other Target Languages

There are models targeting languages other than English as well. Table 2 shows six such models based on the BERT architecture (Devlin et al., 2019): ArabicBERT (Safaya et al., 2020), RoCBert for Chinese (Su et al., 2022), CamemBERT for French (Martin et al., 2020), GottBERT for German (Scheible et al., 2020), BERT Japanese (Tohoku NLP Group, 2019) and PhoBERT for Vietnamese (Nguyen and Nguyen, 2020).

    &  &  &  \\  Belarusian & 4.74 & — & — & 5.62 & — & 3.46 \\ Bulgarian & 4.30 & — & — & 4.73 & — & 3.09 \\ Catalan & 2.36 & 2.86 & 1.59 & 1.89 & 1.95 & 1.57 \\ Chinese (Simp.) & — & 1.00 & — & 3.95 & 0.82 & — \\ Chinese (Trad.) & — & 0.94 & — & 3.82 & 0.84 & — \\ Dutch & 2.52 & 2.92 & 1.68 & 1.73 & 1.98 & 1.58 \\ Dzongkha & — & — & — & 16.12 & — & — \\ English & 1.83 & 2.60 & 1.20 & 1.35 & 1.49 & 1.20 \\ French & 2.42 & 3.10 & 1.00 & 1.99 & 2.03 & 1.66 \\ Frulian & 2.33 & 2.79 & 1.66 & 1.98 & 1.92 & 1.59 \\ German & 2.63 & 3.12 & 1.85 & 1.00 & 2.04 & 1.67 \\ Greek & 4.93 & 3.00 & — & 6.73 & — & 3.73 \\ Italian & 2.58 & 3.10 & 1.63 & 1.93 & 2.04 & 1.60 \\ Japanese & 1.85 & 1.34 & — & 4.35 & 1.00 & \\ Jingpho & 3.12 & 3.12 & 2.13 & 2.55 & 2.47 & 1.84 \\ Luxembourgish & 2.56 & 2.97 & 1.82 & 1.75 & 1.96 & 1.72 \\ N. Lev. Arabic & 1.00 & — & — & 6.52 & — & — \\ Shan & — & — & — & 16.88 & — & — \\ Standard Arabic & 1.00 & — & — & 7.03 & — & — \\ Tagalog & 2.84 & 3.28 & 2.00 & 2.20 & 2.39 & 1.74 \\ Task Albanian & 2.66 & 2.90 & 2.17 & 2.39 & — & 2.02 \\ Tsonga & 3.01 & 3.09 & 2.03 & 2.29 & 2.46 & 1.76 \\ Tumbuka & 3.27 & 3.49 & 2.21 & 2.61 & — & 2.00 \\ Vietnamese & 2.52 & 2.55 & — & 4.12 & — & 1.00 \\ Yue Chinese & — & 0.92 & — & 3.75 & — & — \\   

Table 2: Tokenizer premiums on the FLORES-200 dataset for **non-English centric models**. The premium is computed with respect to the target language (Modern Standard Arabic was used for Arabic BERT and Simplified Chinese for RoCBert). The languages that are in the top or bottom two for any tokenizer as well as the ones discussed are shown.

    &  \\  English & 1.00 \\ Nepali & 1.01 \\ Bengali & 1.01 \\ Tamil & 1.06 \\ Marathi & 1.06 \\ Kannada & 1.06 \\ Hindi & 1.16 \\ Malayalam & 1.18 \\ Gujarati & 1.19 \\ Sanskrit & 1.21 \\ Telugu & 1.21 \\ Odia & 1.21 \\ Sindhi & 1.22 \\ Assamese & 1.24 \\ Urdu & 1.26 \\ Eastern Panjabi & 1.35 \\ Kashmiri (Arabic) & 1.75 \\ Kashmiri (Devanagari) & 1.75 \\ Tumbka & 3.27 \\ Vietnamese & 2.55 & — & 4.12 & — & 1.00 \\ Yue Chinese & — & 0.92 & — & 3.75 & — \\   

Table 3: Tokenizer premiums on the FLORES-200 dataset for the MuRIL model focusing on **16 Indian languages and English**. The premium is computed with respect to English.

The English premium for GottBERT (1.35) is lower than those for Dutch (1.73) and Luxembourgish (1.75), which are more linguistically similar to German. CamemBERT is similar: English has the lowest premium (1.20), while Catalan (1.59) and Friulian (1.66) have higher premiums. PhoBERT also has English with the lowest tokenizer premium (1.20). Thus, even models targeting other languages exhibit a preference for English tokenization.

RoCBert and BERT Japanese differ by having the other target language as the one closest to parity, possibly due to the partially shared script. ArabicBERT demonstrates a similar behaviour, with Central Kanuri (1.27) and Acehnese (1.73), both written in Arabic script, and with English at 1.82. Sharing writing systems seems to improve tokenization parity.

Across all tokenizers, the premium for English relative to the respective target language is significantly lower than the premium of RoBERTa for that target language. This asymmetry between English and all other languages likely stems from the extensive incorporation of English in documents written in other languages (Zhang et al., 2022).

We also consider MuRIL, a BERT-based model trained on 16 Indian languages and English (Khanuja et al., 2021). Despite the model's focus on Indian languages, it remains most token-efficient for English (see Table 3).

Unequal treatment of dialects or linguistic varieties can lead to social and economic disadvantages making it important to also study the tokenization differences between the "standard" language and its varieties. For Swiss German and the Mauritian and Haitian Creoles, there are large differences in tokenization lengths compared respectively to High German (on GottBERT) and French (on CamemBERT). English is much closer to parity for both models than these language varieties. Therefore subword tokenizers might not be able to generalize to language varieties, such as dialects and creoles. The tokenizers of ArabicBERT and BERT Japanese, however, are close to parity across various dialects of both languages and have lower premiums for the dialects than for English. This is likely due to the good representation of the dialects in the dataset as well as the dialects being linguistically closer to the respective standard languages. The detailed analysis is deferred to Appendix B.

Summary.We observed that the tokenizers targeting French, German and Vietnamese have English as the language closest to parity, rather than more linguistically close languages. On the other hand, tokenizers for Arabic, Chinese and Japanese have lower premiums for languages they share a script with. Notably, despite targeting Indian languages, MuRIL still has the shortest tokenizations for English. Finally, across all tokenizers, the premium for English is lower than the premium for the same language for the English-centric RoBERTa. Hence, we conclude that tokenizers for other languages give English preferential treatment.

    &  &  &  &  \\  Bulgarian & 1.16 & 1.31 & 1.28 & 1.23 & 2.49 \\ Central Kanuri & 2.60 & 2.54 & 2.43 & 2.49 & 2.10 \\ Chinese (Simp.) & 0.97 & 1.11 & 0.92 & 1.05 & 0.95 \\ Dzongkha & — & 1.48 & 4.24 & — & 7.36 \\ English & 1.00 & 1.00 & 1.00 & 1.00 & 1.00 \\ Indonesian & 0.94 & 0.93 & 1.08 & 0.98 & 0.96 \\ Italian & 1.19 & 1.25 & 1.34 & 1.25 & 1.62 \\ Japanese & 1.11 & 1.01 & 0.90 & 1.20 & 1.81 \\ Kabije & 2.98 & 1.56 & 2.83 & 2.71 & 3.34 \\ Santali & — & 2.49 & — & — & 12.71 \\ Shan & 4.43 & 1.94 & 3.28 & 4.63 & 12.06 \\ Std. Arabic & 1.18 & 1.40 & 1.35 & 1.29 & 1.14 \\ Std. Tibetan & — & 1.44 & 3.68 & — & 6.66 \\ Uyghur & 1.41 & 1.40 & 2.57 & 3.00 & 3.67 \\ Yue Chinese & 0.93 & 1.05 & 0.95 & 1.03 & 0.93 \\   

Table 4: Tokenizer premiums with respect to English on FLORES-200 for **multilingual models**. The languages that are in the top or bottom two for any tokenizer, as well as the ones discussed in the text, are shown.

    &  &  \\  &  &  \\  Bulgarian & 1.04 & 1.89 \\ Burmeese & 1.24 & 3.51 \\ Chinese (Simplified) & 0.34 & 0.93 \\ Chinese (Traditional) & 0.32 & 0.89 \\ Dzongkha & 1.25 & 3.64 \\ English & 1.00 & 1.00 \\ Italian & 1.18 & 1.19 \\ Japanese & 0.44 & 1.27 \\ Shan & 1.42 & 3.94 \\ Standard Arabic & 0.88 & 1.60 \\ Standard Tibetan & 1.13 & 3.31 \\ Tok Pisin & 1.28 & 1.28 \\ Tumbuka & 1.30 & 1.32 \\ Yue Chinese & 0.31 & 0.87 \\   

Table 5: Tokenizer premiums with respect to English on FLORES-200 for **byte-level models**. The languages that are in the top or bottom two for any tokenizer, as well as the ones discussed in the text, are shown.

### Parity for Multilingual Models

There has been a growing interest in multilingual language models, particularly for translation (Dabre et al., 2020). As these models are intended to support a variety of languages, one would expect them to be close to tokenizer parity. We compare several such multilingual models: XML-R (Conneau et al., 2020), NLLB (Costa-jussa et al., 2022), M2M100 (Fan et al., 2021) and mT5 (Xue et al., 2020). All of these models use the SentencePiece tokenizer with upsampling for rare languages. The final model, BLOOM (Scao et al., 2022), uses byte-level BPE instead of SentencePiece and is designed to maintain similar ratios of tokens per word for each language as reference monolingual tokenizers.

BLOOM and NLLB encode all languages with less than 10% UNK tokens, respectively thanks to byte-level BPE tokenization and being trained on the same 200 languages as FLORES-200 (see Table 4). The other three models fail to encode at least one language. All five models have languages with premiums of more than 2.5. Still, all models are better than the English-centric models in Table 1. Figure 1 shows how XLM-R is much closer to parity than RoBERTa (on which it is based), over all languages it can encode. However, none of the models uniformly reaches parity across all languages. Therefore even models which are intentionally designed to be multilingual suffer from a lack of tokenization parity.

Summary:Multilingual models can improve the tokenization parity for different languages but challenges remain in achieving tokenization parity across all languages.

### Parity for Byte-level Tokenization Models

Byte-level representation is crucial for multilingual support, as it encodes any Unicode codepoint, even if unseen during training. One can also bypass vocabulary construction and directly employ the 256 byte values, enabling end-to-end training (_byte-level tokenization_). CANINE (Clark et al., 2022) is a large model that operates at the Unicode codepoint level rather than the byte level. The CANINE tokenizer is thus equivalent to the UTF-32 encoding, resulting in an implicit tokenizer with a vocabulary of 1,114,112. ByT5 (Xue et al., 2022), on the other hand, uses the UTF-8 encoding: an implicit vocabulary of 256 tokens.5

Figure 1: Comparison of the tokenization premiums for XLM-R and RoBERTa for the subset of languages that XLM-R encodes with less than 10% to the UNK token.

Figure 2: Average processing time and length of the tokenized inputs of RoBERTa. Each FLORES-200 sentence is processed for 20 independent runs. The script family designation is only for illustration purposes.

These byte-level models can represent any Unicode codepoint without an explicit tokenization step but there are still significant tokenization disparities. For CANINE, Shan has a premium of 4.58 relative to Yue Chinese. This can be attributed to the fact that CANINE provides a single token for each Unicode codepoint, which results in Chinese being more token-efficient (with a premium range 0.31-0.34 relative to English for the three Chinese languages) as each character is treated as a single token. This encoding also puts Shan at a disadvantage, as its encoding relies on diacritics represented as separate Unicode codepoints. Other languages, such as Tok Pisin and Tumbuka, which use the Latin script but require more characters than English for the same text, also face similar challenges.

Tokenization disparity is also present in the ByT5 model. The tokenization premium for ByT5 ranges from 0.87 (for Yue Chinese) to 3.94 (for Shan). The introduction of the variable-width UTF-8 encoding of Unicode characters in ByT5 creates another issue of unequal treatment. ASCII characters, which are sufficient for English, require only one byte. Other Latin script characters, as well as Greek, Cyrillic, Coptic, Armenian, Hebrew, Arabic and Syriac, require two bytes, while Chinese, Japanese and Korean characters require three bytes. Therefore, the tokenization of Chinese and Japanese is about three times as long for ByT5 as it is for CANINE (Table 5). Shan's premium of 3.94 is due to the fact that all its consonants and diacritics require three bytes. For example, the word "\(\)." is encoded by ByT5 as 12 tokens, whereas the corresponding "you" requires 3 tokens. The situation is similar for other languages like Dzongkha, Tibetan and Burmese.

Summary.Byte-level models also fail to achieve parity among the languages from FLORES-200 exhibiting a premium of over 4 times for some language pairs. There are two sources of multilingual tokenizer disparities. First, there are natural differences in the number of characters used in different languages to communicate the same content. Second, the UTF-8 standard uses different number of bytes to encode codepoints of different scripts.

## 5 Fairness Implications of Tokenization Length Differences

We showed that no matter whether one uses subword, multilingual, or byte-level tokenization, none of the tokenizers gets close to parity for all languages in FLORES-200. This lack of tokenization parity is not merely a curiosity: it leads to unfairness in the cost to access language models, the latency of the service and the amount of data that can be processed.

### Cost

It is increasingly common to access LLMs as paid API services. One pricing approach, employed by OpenAI at the time of writing,6 is to charge per token. Therefore, the tokenization premiums discussed in Section 4 directly map to cost premiums. For ChatGPT and GPT-4, the cost to process a text in German or Italian is about 50% higher than to process the same text in English (Table 1). Using them in Dzongkha, Odia, Santali or Shan, the most expensive languages for these services, costs more than 12 times more than in English.

Another pricing strategy is per Unicode character: the approach currently taken by the Google Cloud Natural Language service.7 However, as we showed in Section 4.4, the same content can have very different lengths when measured in Unicode characters. Burmese, Dzongkha, Shan, Tok Pisin or Tumbuka require more than 4 times more characters than Yue Chinese for the same text, resulting in a proportional cost difference. Therefore, both the per-token and the per-character approaches result in large disparities in the cost for users of different languages to use the exact same service.

### Latency

High latency of real-time interactions for users of certain languages can result in a suboptimal experience and communication breakdowns. For customer support or emergency services, delays in response time can lead to miscommunication or delayed assistance.

As some languages have significantly longer tokenized inputs, they would also experience longer processing times. The transformer attention mechanism has a quadratic complexity in the number of input tokens (Keles et al., 2023). However, the full model architecture contains other submodules and therefore the overall complexity might be different.

To assess the effect of the tokenization length on the latency, in Figure 2 we plot the computation time of RoBERTa against the tokenization lengths. It appears that the processing time is linear in the tokenization length rather than quadratic, showing a strong correlation between sequence length and execution time. Therefore, tokenization disparities across languages also affect the latency and processing time for text in these languages.

As expected, English is on the left lower corner, having the shortest tokenization and one of the fastest processing times. Shan is on the other extreme with the longest tokenization length and execution time (almost twice that of English). We can also observe clear trends dependent on the script used. Latin script and other Greek-derived scripts show the shortest tokenization lengths and processing times followed by the Chinese-Japanese-Korean (CJK) and Arabic languages. Other predominantly Asian and African scripts have longer tokenization lengths and processing times.

The latency implications of tokenization disparity are not limited to text models. Speech recognition models often produce a series of tokens as their output sequentially. Similarly, speech synthesis takes as an input tokenized text (Latif et al., 2023). Therefore, differences in tokenization affect speech models too.

### Long context processing

Transformers models have difficulty processing long inputs (Liu et al., 2023). Given that the size of the input is contingent upon the tokenization process, inputs of greater length may impose a challenge for language models to adequately reason over. Such a predicament may result in reduced abilities or limited applicability for languages with high tokenization premiums. For example, RoBERTa has a fixed block size of 512, GPT-2 has 768, 1024, 1280, or 1600 Radford et al. (2019), GPT-4 comes in 8,000 and 16,000 context variants.8 These models cannot process inputs longer than that. Therefore, one can process less than a tenth of the content in languages like Burmese and Dzongkha than they can in English.

Alongside inconveniencing the users of these languages, this can also result in diminished performance on automated systems, such as content moderation. Reliable content moderation is crucial for tackling hate speech and diminished performance has already been shown to fail to prevent its spread (Stecklow, 2018; Facebook, 2021). Therefore, reduced long context capabilities for some languages could have severe real-world impacts.

## 6 Towards Multilingual Tokenization Fairness

Section 5 showed that high values of tokenization parity for a language lead to increased cost and latency and decreased capacity for long context processing. In this section, we argue that training language models from scratch with a multilingually fair subword tokenizer is the only approach that can effectively address all these aspects of tokenization unfairness.

Subword tokenization is necessary to achieve parity.In Section 4.4, we showed that neither character-level nor byte-level input representation can achieve tokenization parity. Therefore, a variation of subword tokenization is necessary. For example, Chinese characters could be individual tokens, Latin characters might be represented as tokens with an average length of about 3 characters while pairs of Burmese characters and their diacritics being assigned single tokens. Such an approach would account for Chinese requiring one-third the characters English does (as shown in Table 5).

A separate tokenizer for determining the processing cost is not sufficient.An easy patch for existing models is to use a separate tokenizer for calculating how much a user should be charged. Using one tokenizer for computing the cost and another to process the input can easily be applied to existing systems without the need to retrain the LLM itself. However, as the tokenizer for the language model is unchanged, this approach would still suffer from latency and inability to process long contexts. Therefore, to ensure similar processing times and long context capabilities across languages, the language model has to be trained with a multilingually fair tokenizer.

The tokenization needs to support all Unicode codepoints.Amongst all tokenizers we examine in this paper, the ones which encode all FLORES-200 languages all have one thing in common: they build their tokenization on top of Unicode representation, allowing them them to represent all characters. Therefore, a multilingually fair tokenizer should also start from a Unicode (or equivalent) encoding. Considering that subword tokenization is necessary, building the vocabulary from UTF-8 would likely result in a smaller dictionary than building it on top of UTF-32. Hence, UTF-8 is likely the more appropriate choice.

Building a multilingually fair parallel corpus.Building and evaluating multilingually fair tokenizers requires attention to the parallel corpus used. One must ensure a balanced representation of topics, otherwise, the resulting tokenizer might end up being multilingually fair only for a subset of topics. The presence of named entities must also be balanced. For example, in FLORES-200, there are many English-centric names and institutions, which might skew the results in favour of English. Additionally, the same sentence can have different translations with varying tokenization lengths. To account for this, a diversity of translations could ensure tokenization fairness across languages. These limitations also hold for the results in this paper. Hence, developing a well-curated and diverse parallel corpus is crucial for the development and evaluation of a multilingually fair tokenizer.

Building a multilingually fair tokenizer from monolingual tokenizers.As discussed in Section 4, byte-level, character-level and word-level tokenizers cannot achieve tokenization parity and subword tokenization is needed. However, simply training a subword tokenizer on a balanced dataset is also not sufficient as languages can share tokens. For example, "hotel" is written the same way in English, Spanish, Italian, Portuguese, Dutch, Danish, Hungarian, Polish, etc. Hence, languages from more numerous language families will also witness shorter tokenization lengths while more isolated languages and scripts, e.g. Korean, would see larger language premiums: "hotel" in Korean is "\(\)" and no other language has the same spelling as no other language uses the Korean script.

To address this issue, we suggest a two-stage process towards building a multilingually fair tokenizer. First, train individual monolingual tokenizers for all target languages. Then, merge them while maintaining parity. The merging can be done by starting with the 256 tokens corresponding to each value a byte can take and then repeatedly adding the most frequently used token for the language with the highest premium.

While a multilingually fair tokenizer would lead to more tokens being needed for the dominant language, this additional cost would likely be much smaller than the benefit for the rest of the languages. The vocabulary size has diminishing returns: the additional tokens correspond to increasingly rare (parts of) words. For example, with only a third of the vocab

Figure 3: How much longer will English language tokenization be if we dedicate a fraction of the cl1100k_base vocabulary to other languages? This plot shows how many tokens will be necessary to encode the English language corpus of FLORES-200 for different subsets of the cl100k_base vocabulary.

ulary, English sequences will become just 10% longer for ChatGPT/GPT-4 (see Figure 3). Therefore, by removing rarely used tokens of the dominant language and replacing them with frequently used tokens in other languages, we would likely see an overall net benefit.

## 7 Related Works

Fairness and bias in language models.The rapid increase in the size of language models has raised concerns regarding their biases and unfairness (Bender et al., 2021). For example, Bolukbasi et al. (2016), May et al. (2019) and Nadeem et al. (2021) showed that stereotypes and biases exist in language models, while Magee et al. (2021) identified the presence of intersectional biases which may be resistant to debiasing techniques. Language models were also shown to rely on social biases in question answering (Parrish et al., 2022). Another challenge is the generation of toxic content which can occur even without prompting (Gehman et al., 2020). Interestingly, Gururangan et al. (2022) point out that datasets consider one type of English as a higher quality depending on the location of the writer rather than on factuality or literary acclaim. Moreover, Ramesh et al. (2023) and Levy et al. (2023) highlighted the need to consider fairness issues of languages other than English, as they may have distinct sources of bias and solutions for English may not be applicable.

Multilingual performance.One approach towards similar multilingual performance is to frame languages as entities as recently proposed by Choudhury and Deshpande (2021). Another method is to separately train vocabularies for different language clusters to balance cross-lingual and language-specific tokens (Chung et al., 2020). Still, multilingual models struggle to deliver on the promises of deep transfer learning for lower-resourced languages (Virtanen et al., 2019) and perform differently depending on the script and resource level of the language (Bang et al., 2023). Ahuja et al. (2023) found that generative models perform better on higher-resource languages and languages that use the Latin script, possibly due to the context length restrictions for some languages. Zhang et al. (2022) show that a balanced tokenizer corpus results in better translation performance. Separately, Hofmann et al. (2021, 2022) show that the BPE results in suboptimal token choices even for English and demonstrate that addressing this issue boosts performance. Similarly, Rajab (2022) and Oladipo et al. (2022) discuss how tokenization affects performance for African languages.

Measuring tokenization lengths.Zhang et al. (2022) suggested using the ratio of the average sentence length in tokens to the length in characters as a measure of closeness to the character level. However, this method may not be suitable for comparing languages due to differences in sentence length across languages. On the other hand, Acs (2019) and Scao et al. (2022) measure the number of tokens created per word, but this method may not be effective for comparing languages due to differences in semantic content per word and the lack of word delineation in some languages. Rust et al. (2021) show that mBERT (Devlin et al., 2019) breaks down English words the least, in line with our findings of English receiving special treatment. However, to the best of our knowledge, we are the first to leverage a parallel corpus to compare tokenization lengths across languages.

## 8 Conclusion

This paper highlights the significant disparities in tokenization across different languages which can lead to unequal treatment and disadvantages for certain language communities. The findings reveal that even tokenizers explicitly trained for multilingual support exhibit tokenization lengths that vary by up to a factor of 13. Furthermore, character-level and byte-level models also demonstrate encoding length discrepancies that are more than 4 times longer. These disparities have important real-world implications including increased costs for accessing commercial language services, longer processing times and limitations on the amount of contextual information provided to language models. To address these issues, we propose the development of multilingually fair tokenizers for future language models emphasizing the importance of ensuring comparable performance and accessibility across supported languages. By achieving tokenization parity, we can mitigate inequalities and promote fair access to language technologies across diverse linguistic communities.