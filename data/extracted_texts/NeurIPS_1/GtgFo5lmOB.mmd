# Joint Data-Task Generation for Auxiliary Learning

Hong Chen\({}^{1}\), Xin Wang\({}^{1,2,}\) Yuwei Zhou\({}^{1}\), Yijian Qin\({}^{1}\), Chaoyu Guan\({}^{1}\), Wenwu Zhu\({}^{1,2}\)

\({}^{1}\)Department of Computer Science and Technology, Tsinghua University

\({}^{2}\)Beijing National Research Center for Information Science and Technology, Tsinghua

{h-chen20,zhou-yw21,qinyj19,guancy19}@mails.tsinghua.edu.cn

{xin_wang,wuzhu}@tsinghua.edu.cn

Corresponding Authors.

###### Abstract

Current auxiliary learning methods mainly adopt the methodology of reweighing losses for the manually collected auxiliary data and tasks. However, these methods heavily rely on domain knowledge during data collection, which may be hardly available in reality. Therefore, current methods will become less effective and even do harm to the primary task when unhelpful auxiliary data and tasks are employed. To tackle the problem, we propose a joint data-task generation framework for auxiliary learning (DTG-AuxL), which can bring benefits to the primary task by generating the new auxiliary data and task in a joint manner. The proposed DTG-AuxL framework contains a joint generator and a bi-level optimization strategy. Specifically, the joint generator contains a feature generator and a label generator, which are designed to be applicable and expressive for various auxiliary learning scenarios. The bi-level optimization strategy optimizes the joint generator and the task learning model, where the joint generator is effectively optimized in the upper level via the implicit gradient from the primary loss and the explicit gradient of our proposed instance regularization, while the task learning model is optimized in the lower level by the generated data and task. Extensive experiments show that our proposed DTG-AuxL framework consistently outperforms existing methods in various auxiliary learning scenarios, particularly when the manually collected auxiliary data and tasks are unhelpful.

## 1 Introduction

Auxiliary learning aims to improve the model generalization ability on the primary task with the help of related auxiliary tasks . This learning paradigm has been widely adopted and has shown its effectiveness in various areas, like image classification , recommendation  and reinforcement learning . Different auxiliary tasks are often chosen manually according to the primary task, e.g.,  utilize the task of visual attribute classification to help the fine-grained bird classification and  improve the click conversion rate prediction with the help of click-through rate prediction task.

Most existing works utilize the auxiliary information by first reweighing the losses of the auxiliary data and tasks, and then use the sum of the weighted losses together with the primary loss to optimize the task learning model. The weights are employed to balance the primary loss and the auxiliary losses to avoid negative auxiliary transfer, which are tuned with HPO tools . More recent works  propose to dynamically weigh different auxiliary losses during training.

However, the existing methods require that there exists beneficial information in the auxiliary data and tasks, so that the beneficial loss terms can be selected through the loss reweighing process. This condition cannot always be satisfied because whether the auxiliary data or task is beneficial depends on many factors including _the chosen auxiliary task, the scale of primary task dataset_ and _the selectedlearning model for the tasks_[1; 11], making it difficult to manually collect the beneficial auxiliary data and task via prior knowledge. Therefore, existing approaches may adopt useless auxiliary information and finally do harm to the primary task when the involved auxiliary data and tasks are improperly collected, as observed in [1; 12]. Although  propose to generate fine-grained auxiliary classification tasks, this method can be only applied to the classification primary task. Additionally, they only generate the new task without considering new data, while the data-level information is pointed out to be an important factor in auxiliary learning .

To address the problem, in this paper, we propose to simultaneously generate the auxiliary data and task for auxiliary learning in a joint manner. However, there are three challenges for the joint generation. First, it is challenging to design a generic framework that can accommodate various tasks with different inputs. This is because the types of data and tasks are quite diversified in different auxiliary learning scenarios, e.g., the primary task of image classification takes visual images as input and outputs categorical labels for classification , while the primary task of rating prediction for recommendation takes tabular data as input and outputs numeric labels for regression . Second, it is challenging to develop a generation framework that is expressive enough to produce beneficial data and tasks for the primary task. Finally, to guarantee the jointly generated auxiliary data and task are beneficial to primary task, how to effectively optimize the parameters in the generation framework is a challenging problem as well.

To tackle these challenges, we propose a joint Data-Task Generation framework for Auxiliary Learning (DTG-AuxL), which involves a joint generator and a bi-level optimization strategy. Specifically, the joint generator consists of a feature generator and a label generator, which generates the new auxiliary data and new task based on the existing manually collected data and tasks. The data generation process is conducted in the feature space so that it can accommodate various input types, while the label generator architecture is inspired by the model in recommendation which can accommodate both categorical labels for classification and numeric labels for regression. Moreover, we introduce nonlinear interaction terms in the joint generator, making it more expressive to produce beneficial auxiliary data and tasks. To effectively optimize the joint generator and the task learning model, we propose the bi-level optimization strategy with instance regularization. In the lower optimization, the task learning model is optimized by the generated auxiliary data and task. In the upper optimization for the joint generator, we not only utilize the implicit gradient from the primary loss but also the explicit gradient from the proposed instance regularization, to avoid label generation mode collapse. Extensive experiments show that DTG-AuxL outperforms existing methods in various auxiliary learning scenarios, especially when the manually collected auxiliary data and task are unhelpful to the primary task. We summarize our contributions as follows,

* We propose to simultaneously generate auxiliary data and tasks in a joint manner in auxiliary learning for the first time, to the best of our knowledge.
* We propose DTG-AuxL, a joint data-task generation framework applicable in various auxiliary learning scenarios, containing a joint generator and a bi-level optimization strategy.
* Extensive experiments in various auxiliary learning scenarios demonstrate the superiority of our proposed DTG-AuxL framework. We further analyze when and how DTG-AuxL works to bring performance boost.

## 2 Related Work

**Auxiliary Learning** The most widely adopted way in auxiliary learning is to combine the loss of the primary task and the losses of the auxiliary tasks in a linear way [3; 7; 4; 5], where the linear weights are tuned manually or with HPO methods. More recent works [9; 6; 10] propose to automatically assign dynamic weights to the auxiliary losses.  propose to assign weights to each loss based on the cosine gradient similarity between the primary loss and each auxiliary loss. Later work  aims to make the weighted auxiliary gradient sum closest to the gradient of the primary loss. [13; 1] utilize the bi-level optimization strategy to learn the auxiliary weights, where  even propose to combine the losses not only limited to a linear form, but also a nonlinear form. [11; 14] point out that only considering the task-level information is not sufficient, so they jointly consider the weights of different tasks and different data samples within the same task through a joint selector. As aforementioned, these reweighing methods will easily fail to bring improvement when the chosen auxiliary tasks and data are unhelpful. There are also works [2; 1] that generate fine-grained classification auxiliary tasks for the primary classification task. However, they can only be applied to a classification problem. Additionally, they only generate auxiliary tasks without new data, limiting their performance especially when the data of the primary task is inadequate, which is an often encountered scenario in auxiliary learning [9; 1].

**Multi-task learning**  Multi-task learning aims to share information among tasks to improve model performance. However, the goal of multi-task learning is to obtain good performance for all the tasks, while auxiliary learning only focuses on the primary task. Multi-task learning methods can be categorized into three parts : multi-task architecture design [16; 17], multi-task optimization [18; 19] and multi-task relationship learning , where the multi-task optimization methods involve techniques for optimizing several losses, like loss reweighing  and gradient modulation .

## 3 The Proposed Method

The overall DTG-AuxL framework is shown in Figure 1. Next, we give the problem formulation, describe the designs of the joint generator, and present the proposed bi-level optimization strategy.

### Preliminaries and Problem Formulation

In auxiliary learning, we have one primary task \(T_{p}\), and totally \(K\) auxiliary tasks \(\{T_{ai}\}_{i=1}^{K}\). Each of these tasks has its corresponding training dataset, including the primary dataset \(D_{p}=\{(x_{p,j},y_{p,j})\}_{j=1}^{|D_{p}|}\), and the dataset for each auxiliary task \(D_{ai}=\{(x_{ai,j},y_{ai,j})\}_{j=1}^{|D_{ai}|}\), where \(||\) denotes the data sample number of the dataset. If the auxiliary tasks share the same input with the primary task, which is a widely encountered and studied scenario in previous works [11; 1; 9; 10], we have \(x_{ai,j}=x_{p,j}\) and \(|D_{ai}|=|D_{p}|\). Besides the datasets, we have a task learning model parameterized by \(\) which is used to learn all the tasks together. There is also a validation dataset \(D_{v}\) which is used to evaluate the model performance on the primary task. With these notations, the widely adopted training objective of auxiliary learning is:

\[_{t}()=_{p}(D_{p};)+_{i=1}^{K}w_{i} _{ai}(D_{ai};), \]

where \(_{p}\) and \(_{ai}\) indicate the loss functions of the primary and each auxiliary task. Current reweighing methods focus on how to decide \(w_{i}\) so that the task learning model \(\) can achieve the best

Figure 1: The overall DTG-AuxL framework. In the model design part, the joint generator contains a feature generator and a label generator. The feature generator utilizes the primary and auxiliary features to generate the new auxiliary feature \(f_{g,j}\), whose label \(_{g,j}\) is generated by the label generator by combining the information of all the auxiliary and primary labels. The optimization part shows that we optimize the task learning model and the joint generator in an alternating bi-level manner.

performance on \(D_{v}\). However, as aforementioned, the terms \(_{ai}(D_{ai},)\) are defined by the manually collected auxiliary data and tasks, with no guarantee to bring benefits for the primary task. Therefore, we propose to simultaneously generate the new beneficial auxiliary data and task in a joint manner, with the following training objective:

\[_{t}(,)=_{p}(D_{p};)+_{i=1}^{K}w_{i} _{ai}(D_{ai};)+w_{g}_{g}(D_{g}();), \]

where the last term is the loss on the generated auxiliary data and task. \(D_{g}()=\{x_{g,j},_{g,j}\}_{j=1}^{|D_{g}|}\) is the generated dataset which contains the new data together with the new label defining the new task, and \(\) denotes the parameters of the joint generator that are used to generate \(D_{g}\). Since we only care about the performance of the primary task in auxiliary learning, we keep \(_{g}\) the same loss function as \(_{p}\), which can be cross entropy or MSE loss, etc. Note that we still keep the original auxiliary loss terms in our training objective, so that it can accommodate the scenario where the existing manually collected auxiliary data and tasks are beneficial. The task weights \(w_{i}\) and \(w_{g}\) are also learnable, which will be optimized together with the generator parameters, and we uniformly denote them all as \(\) for convenience. Next, we discuss the details of the generator and how we optimize \(\) and \(\).

### Joint Generator Design

The joint generator involves a feature generator to generate new features and a label generator to generate a new task for the new feature, as shown in the Model Design of Figure 1.

#### 3.2.1 Feature Generator

Since we expect that our data generator can tackle different types of data, a neat and elegant solution is to conduct the generation process in the feature space. In the feature space, different types of input data are transformed to vectors, so we can tackle these vectors in a unified way. Specifically, for the input from different tasks \([x_{p,j},x_{a1,j},,x_{aK,j}]\), the task learning model will first map them to the feature space with an encoder which is generally noted as "backbone", and then use different task-specific heads to tackle each of the tasks. We generate the new features based on the features extracted via the backbone. In another word, the input of the feature generator is a feature list \([f_{p,j},f_{a1,j},,f_{aK,j}]\), where \(f_{p,j}=f_{backbone}(x_{p,j};)\) is a \(d\)-dimension feature. We next describe how the new features are generated.

**Feature linear term.** A natural way to generate new features is to combine different features with linear masks. We assign an individual feature mask to each of the \(K+1\) features, i.e., we have a mask list \([m_{p},m_{a1},,m_{aK}]\), where each mask is a \(d\)-dimension vector. Then, we denote the subscript set for the task IDs \(\{p,a1,,aK\}\) as \(S\), and the linear combination is conducted as follows:

\[f_{gl,j}=_{i S}_{i}*f_{i,j},\;_{i}[k]=[k]}}{ _{j S}e^{m_{j}[k]}},k=1 d, \]

where \(gl\) indicates "generated linearly", \(*\) means the element-wise multiplication, and \(_{i}\) is the normalized mask. \(m_{i}[k]\) is the \(k^{th}\) element of the mask \(m_{i}\), and is normalized by softmax with the elements in the same dimension in other masks. This linear combination with normalized mask works as feature selection from all the input features, and then combines them into a new one.

**Feature nonlinear term.** To make the generated features more expressive, we introduce an MLP (Multi-Layer-Perceptron) to capture the nonlinear feature interaction:

\[f_{gn,j}=MLP_{F}([f_{p,j};f_{a1,j};;f_{aK,j}]), \]

where \(gn\) indicates "generated nonlinearly". All the features are concatenated together and the nonlinear feature interactions are modeled by an MLP, whose output dimension is \(d\). Finally, the generated feature is the sum of the linear and nonlinear term, i.e., \(f_{g,j}=f_{gl,j}+f_{gn,j}\).

#### 3.2.2 Label Generator

The label generator aims to generate a proper label for the feature produced by the feature generator. We use the labels of all the input data as the input of the label generator to make the generated label expressive enough, i.e., the input of the label generator is a list of labels \([y_{p,j},y_{a1,j},,y_{aK,j}]\)However, this label list may contain both numeric labels (if the corresponding task is regression) and categorical labels (if the corresponding task is classification). How to utilize different types of label information to generate a new label is the key problem. Inspired by the CTR (click-through rate) model in recommendation , which predicts the user's preference towards an item also based on both their numeric and categorical features, we design the label generator with both linear terms and deep nonlinear terms similar to those in the CTR model.

**Label linear term.** The linear term models the direct and independent relationship between each input label and the generated label. We simply keep the dimension of the generated label the same as the primary label \(y_{p,j}\) and more adaptive ways to choose the dimension can be an interesting future work. Here, we assume that the dimension of \(y_{p,j}\) is \(m\), where \(m=1\) if the primary task \(T_{p}\) is regression, or \(m\) equals to the number of the total categories if \(T_{p}\) is classification. If the primary task is regression, the generated label is also a scalar value for regression, while if the primary task is classification, the generated label is an \(m\)-dimension probability distribution vector. Specifically, for each task ID \(i S\), if \(T_{i}\) is a classification task and it has totally \(d_{i}\) categories, there is an embedding table \(E_{i}\) with dimension \(d_{i} m\) for this task. We directly map the label \(y_{i,j}\) in task \(T_{i}\) to its \(m\)-dimension embedding space through the embedding table:

\[y_{gl,i,j}=E_{i}(y_{i,j}). \]

If \(T_{i}\) is a regression task, we follow  to map \(y_{i,j}\) to its \(m\)-dimension embedding. Specifically, we also have an embedding table \(E_{i}\) for this task \(T_{i}\), whose dimension is \(d_{i} m\), where \(d_{i}=H\) is a hyper-parameter which is fixed to 10 in our experiments. Then \(y_{i,j}\) is mapped into the \(m\)-dimension embedding space as follows:

\[c_{i,j}=Softmax(Linear(y_{i,j})),c_{i,j} R^{H},y_{gl,i,j}=_{k=1}^{H}c_{i,j}[k]E_{i}[k], \]

where the numeric label \(y_{i,j}\) is linearly transformed to a \(H\)-dimension vector \(c_{i,j}\), which is used to weigh all the embeddings in the embedding table to obtain the final embedding. Then the final label linear term is obtained by the sum of all the input label embeddings \(y_{gl,j}=_{i S}y_{gl,i,j}\).

**Label nonlinear term.** In addition to the label linear term capturing how each input label independently influences the final generated label, we also propose a nonlinear term to model the influence of more complex label interactions on the generated label. Specifically, we introduce another group of embedding tables for all the input tasks \(\{EN_{i}\}_{i S}\), where the ways to obtain the embeddings of the categorical and numeric labels are the same as eq. (5) and eq. (6), respectively. The dimension of \(EN_{i}\) is \(d_{i} m_{n}\), where \(d_{i}\) equals to the number of total categories if \(T_{i}\) is classification. \(d_{i}\) equals to \(H\) (i.e.,10) for regression task, and \(m_{n}\) is a hyper-parameter. With these embedding tables, we can map all the input label list \([y_{p,j},y_{a1,j},,y_{aK,j}]\) to an embedding list \([e_{p,j},e_{a1,j},,e_{aK,j}]\). Then the nonlinear label interactions are captured through an MLP:

\[y_{gn,j}=MLP_{L}([e_{p,j};e_{a1,j};;e_{aK,j}]). \]

The final generated label for the generated feature \(f_{g,j}\) is the sum of the linear and nonlinear terms,

\[y_{g,j}=y_{gl,j}+y_{gn,j}. \]

**Label bias term.** Besides the linear and nonlinear terms, we also introduce a label bias term that guides the generated label to possess similar semantic meaning to the label from the target primary task, \(y_{p,j}\). As such, we add \(y_{p,j}\) as the label bias term as follows,

\[_{g,j}= y_{p,j}+(1-)*norm(y_{g,j}), \]

where \((0,1)\) is a learnable parameter initialized as 0.5 and \(norm()\) is the normalization function. If the primary task is classification, \(norm()\) will be \(softmax()\) and \(y_{p,j}\) will be converted to the one-hot form. If the primary task is regression with range \((a,b)\), then \(norm()\) is set to be \((b-a)sigmoid()+a\). This bias term makes the generated label lie in the same space as the original label, enabling us to more conveniently explore its semantic meaning, which is also verified to improve model performance in our experiments.

#### 3.2.3 Discussion about the Share Input Scenario

The proposed generator can generate the new feature by combining the features from the primary and auxiliary tasks. However, in the most widely studied auxiliary learning scenario , all the tasks share the same input data. We only have the training dataset \(\{(x_{p,j},y_{p,j},y_{a1,j},,y_{aK,j})\}_{j=1}^{|D_{p}|}\). Therefore, we cannot obtain the auxiliary data \([x_{a1,j},,x_{aK,j}]\) from the auxiliary tasks to conduct the feature generation. To tackle this problem, we obtain the new auxiliary data by randomly sampling another data sample in the dataset, which is easy to implement with randomly shuffling the training batch to match another sample for the original sample. Specifically, for a sample \((x_{p,j},y_{p,j},y_{a1,j},,y_{aK,j})\), we consider another sample \((x_{p,j2},y_{p,j2},y_{a1,j2},,y_{aK,j2})\) in the dataset to provide new auxiliary data information. The input of the feature generator is \([f_{p,j},f_{p,j2}]\), which are the features extracted by the backbone with \([x_{p,j},x_{p,j2}]\) as input. When generating new labels, we need to combine all the existing labels of the two samples, i.e., the input of the label generator is \([y_{p,j},y_{a1,j},,y_{aK,j},y_{p,j2},y_{a1,j2},,y_{aK,j2}]\), and then the label generation process is the same as before. Note that there are two small details: 1) During the label embedding process, \(y_{ai,j}\) and \(y_{ai,j2}\) share the same embedding table, because they both belong to the same task. ii) For the bias term in eq. (9), we now have two labels from the primary task, \(y_{p,j}\) and \(y_{p,j2}\), and then eq. (9) can be adjusted to:

\[_{g,j}=( y_{p,j}+(1-)y_{p,j2})+(1-)*norm(y_{g,j}), \]

where \((0,1)\) is a learnable parameter of the generator. Till now, we have described the designs of the joint generator, which is applicable in various auxiliary learning scenarios. However, the generator has several parameters to be optimized, like the masks and MLPs. We denote all the learnable parameters in the generator together with the task weights \(w_{i}\) in eq. (2) as \(\). Next, we will elaborate how we optimize the task learning model parameters \(\) and the generator parameters \(\).

### Optimization Strategy

**Bi-level optimization.** In our whole framework, the task learning model parameters \(\) are expected to minimize the loss of all the selected and generated tasks, while the generator parameters \(\) aim to make \(\) achieve the best performance on the primary task. These two different goals give rise to the following bi-level optimization problem:

\[&^{*}=_{}_{p}(^{*}( );D_{v}),\\ & s.t.\ ^{*}()=_{}_{t}(,),  \]

where \(_{t}(,)\) is the objective in eq. (2), and \(_{p}(^{*}();D_{v})\) is the primary task loss of the task learning model on the validation dataset. The lower optimization is easy, we can directly obtain the gradient of \(\) as \(_{}_{t}(,)\). However, in the upper optimization, \(_{p}(^{*}();D_{v})\) directly relies on \(\) instead of \(\). Assuming that the Hessian \(_{}^{2}_{t}(^{*}(),)\) is positive-definite, we can use the implicit theorem to obtain its implicit gradient \(_{}_{p}(^{*}();D_{v})\),

\[_{}_{p}(^{*}();D_{v})=-_{} _{p}(_{}^{2}_{t})^{-1}_{ }_{}_{t}(_{,^{*}()}). \]

Detailed derivation can be found in Appendix 1. Since the inverse of the Hessian is often intractable, we follow  to use truncated Neumann series to approximate it. \((_{}^{2}_{t})^{-1}_{i=0}^{n}(I-_{ }^{2}_{t})^{i}\), and \(n\) is fixed to 3 in all our experiments. Thus, the complete implicit gradient is approximated as:

\[_{}_{p}(^{*}();D_{v})-_{} _{p}_{i=0}^{n}(I-_{}^{2}_{t})^{i} _{}_{}_{t}. \]

**Instance regularization.** In the upper optimization, we additionally introduce an instance regularization for the parameterized label \(y_{g,j}\) in eq. (8) as follows, to prevent generation mode collapse.

\[_{reg}(;D_{g})=\{_{j=1}^{|D_{g}|} _{j^{} j}cos(y_{g,j},y_{g,j^{}})&categorical\\ -_{j=1}^{|D_{g}|}_{g,j}log(_{g,j})&numerical. \]

where if the generated label is categorical, we expect that the cosine similarity of different generated labels is small. This regularization means we expect that the generated label can keep its instance-level uniqueness, preventing the generated labels of all the generated features from being the same. Similarly, if the generated label is numerical, since it is 1-dimension, we use the entropy regularization to achieve this goal, where \(_{g,j}=e^{y_{g,j}}/_{j^{}=1}^{|D_{g}|}e^{y_{g,j^{}}}\). Then in the upper optimization, the gradient of \(\) is the sum of the implicit gradient and explicit gradient from the regularization:

\[_{}=_{}_{p}(^{*}();D_{v})+_{ }_{reg}(;D_{g}). \]Now the gradients of \(\) and \(\) are obtained, and we follow previous works [1; 11] to alternatingly update \(\) and \(\). The update loop will continue until convergence, where in each loop we first update \(\) for \(N\) times, and then update \(\) using the upper gradient eq. (15) as shown in Figure 1. \(N\) is the interval between two upper updates. We summarize the complete algorithm in Appendix 2, where we do not require an additional validation dataset \(D_{v}\) to calculate the upper objective but reuse the training primary set \(D_{p}\) as done in [13; 14].

## 4 Experiments

### Experimental Setup

**Task and Dataset.** We conduct our experiments on two scenarios to validate the generalization ability of our method. One is the most widely studied scenario in previous auxiliary learning works, where the auxiliary tasks share the same input as the primary task (share input). The other one is that the inputs of the primary and auxiliary tasks are different (different input). In the **Share Input** setting, **(i) CUB**: we follow previous works [1; 11] to use the bird visual attribute classification (e.g., whether the bird has white belly) to help the bird species classification primary task, where both the auxiliary and primary labels are categorical. **(ii) CIFAR100**: it is a widely adopted image classification dataset, where there are totally 100 categories. Additionally, each image has a coarse class, e.g., a car belongs to the "vehicles 1" coarse class. We use the coarse classification as the auxiliary task to help the 100-classification primary task. **(iii)** Besides the classification problem, we also focus on the regression problem, where we follow previous works [11; 12] to regard the rating prediction in recommender system as the primary task, and the CTR prediction as the auxiliary task. The primary task is regression and the auxiliary task is binary classification. We choose the widely used Amazon **Toys** and **Movies** datasets, where we use the user ID, item ID and item category as the input data. In the **Different Input** setting, **(i) CIFAR10-100** is a setting where our primary task is the CIFAR10 classification problem, and the auxiliary task is the CIFAR100 classification problem. **(ii) Pet-CUB** is a similar setting where our primary task is fine-grained pet classification on the Pet  dataset, while our auxiliary task is the bird species classification in the previously mentioned CUB dataset. More detailed data information is presented in Appendix 4.

**Baselines.** We compare with SOTA auxiliary learning methods, including the reweighing methods and the auxiliary task generation method. Single task learning(STL) is a natural baseline where we only train on the primary task. Equal is a baseline where we assign equal weights 1.0 to all the tasks. Uncert  is a dynamic weighting method for multi-task learning based on task uncertainty. GCS  and AuxL  dynamically reweight the auxiliary losses, and JTDS  not only reweighs the tasks but also each data sample within each task. MAXL  is a method that automatically generates a fine-grained auxiliary task for the primary classification task. We provide detailed differences between our work and the baselines in Appendix 3.1.

**Implementation details.** In CUB dataset, we respectively adopt ResNet18  and ResNet50 as our backbone. In CIFAR100, we respectively adopt ResNet18 and a 4-layer ConvNet composed of Convolution, Batch Normalization and Relu layers as our backbone. In Amazon Toys and Movies, we adopt AutoINT  as the backbone. In CIFAR10-100, the backbone is the 4-layer ConvNet and in Pet-CUB the backbone is ResNet18. For the head of each task, we adopt Multi-Layer-Perceptron(MLP) whose layer is searched from \(\{1,2\}\). In the generator, the embedding dimension \(m_{n}\) is searched from \(\{32,64\}\), and the layer number of the MLP is searched from \(\{2,3,4\}\). More details are presented in Appendix 4.

### Experimental Results

#### 4.2.1 Method Performance

**Main results.** Table 1 presents the overall experimental results, showing that our proposed method consistently outperforms existing methods on the diversified auxiliary learning scenarios. During training in the CUB dataset and Pet-CUB dataset, different from  that does not use the learning rate scheduler, we found that applying a learning rate scheduler to all the baselines can obtain better or at least on-par performance. Therefore, we report the results with the scheduler. From the results, we have the following observations. **(i)** As expected, our proposed method brings benefits for the primary task when the original manually collected auxiliary data and task are unhelpful. For example,

[MISSING_PAGE_FAIL:8]

[MISSING_PAGE_FAIL:9]

can not only combine information from the label of the same task but also label from other tasks. **(ii)** Our method can not only model linear relations in generation but also non-linear relations. **(iii)** Our method can handle the Different Input scenario, while MixUp cannot.

To further show the advantage of our proposed generation compared to MixUp, we apply Auto-F-Mix on top of auxiliary learning methods (AuxL, JTDS, MAXL) and the experimental results are presented in Table 6. The results show that both directly combining auxiliary weighting methods(AuxL, JTDS) with Auto-F-Mix and combining the current auxiliary generation method (MAXL) with Auto-F-mix are not as effective as our method, indicating the advantage of our proposed joint generation.

## 5 Conclusion

In this paper, we propose to jointly generate beneficial auxiliary data and tasks for auxiliary learning, so that the primary task can still obtain benefits when the manually collected auxiliary data and tasks are unhelpful. We propose the DTG-AuxL framework with a joint generator and a bi-level optimization strategy, which can be applied in various auxiliary learning scenarios. Future works like designing more adaptive generators and more efficient bi-level optimization algorithms can further improve the generation.

  
**Dataset** & **CUB** & **CUB-5shot** & **Toys** \\ 
**Metric** & **Acc(\%)\(\)** & **Acc(\%)\(\)** & **RMSE\(\)** \\ 
**Backbone** & ResNet50 & ResNet50 & AutoINT \\  AFM & 80.30\({}_{0.57}\) & 46.97\({}_{0.95}\) & 0.9187\({}_{0.0003}\) \\ AuxL+AFM & 79.70\({}_{1.07}\) & 47.84\({}_{1.25}\) & 0.9195\({}_{0.0011}\) \\ MAXL+AFM & 80.76\({}_{0.38}\) & 47.96\({}_{0.89}\) & - \\ JTDS+AFM & 80.52\({}_{0.90}\) & 48.14\({}_{0.87}\) & 0.9189\({}_{0.0013}\) \\  ours & **81.73\({}_{0.20}\)** & **52.33\({}_{1.36}\)** & **0.9153\({}_{0.0004}\)** \\   

Table 6: Comparison to the combination of Auto-F-Mix and current auxiliary learning methods. We denote Auto-F-Mix as AFM.

  
**Dataset** & **CUB** & **Pet-CUB** & **Toys** \\ 
**Metric** & **Acc(\%)\(\)** & **Acc(\%)\(\)** & **RMSE\(\)** \\ 
**Backbone** & ResNet50 & ResNet18 & AutoINT \\  w/o F-nonlinear & 81.22\({}_{0.27}\) & 67.76\({}_{0.17}\) & 0.9195\({}_{0.0021}\) \\ w/o L-nonlinear & 80.96\({}_{0.37}\) & 66.58\({}_{1.22}\) & 0.9213\({}_{0.0026}\) \\ w/o L-bias & 79.28\({}_{0.34}\) & 69.36\({}_{0.37}\) & 0.9204\({}_{0.0011}\) \\  w/o bi-level & 80.32\({}_{0.42}\) & 68.53\({}_{0.49}\) & 0.9163\({}_{0.0008}\) \\ w/o instance reg & 80.44\({}_{0.34}\) & 67.53\({}_{0.95}\) & 0.9174\({}_{0.0012}\) \\  complete & **81.73\({}_{0.20}\)** & **70.48\({}_{0.28}\)** & **0.9153\({}_{0.0004}\)** \\   

Table 4: Effectiveness of framework designs. The first three rows explore the effectiveness of the generator components, while the rest show the effectiveness of the training strategies.

  
**Dataset** & **CUB** & **Movies** \\ 
**Metric** & **Acc(\%)\(\)** & **RMSE\(\)** \\ 
**Backbone** & ResNet18 & AutoINT \\  MixUp & 75.88\({}_{0.50}\) & - \\ Auto-Mix & 76.53\({}_{0.36}\) & - \\ F-MixUp & 75.33\({}_{0.67}\) & 1.0460\({}_{0.0023}\) \\ Auto-F-Mix & 76.88\({}_{0.52}\) & 1.0464\({}_{0.0003}\) \\  ours & **77.75\({}_{0.27}\)** & **1.0426\({}_{0.0009}\)** \\   

Table 5: Comparison with MixUp Methods. Note that MixUp cannot be applied to the recommendation scenario where the input are categorical features.