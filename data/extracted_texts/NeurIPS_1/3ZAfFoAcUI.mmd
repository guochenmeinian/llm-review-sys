# On the Inductive Bias of Stacking Towards Improving Reasoning

Nikunj Saunshi

Google Research

nsaunshi@google.com

&Stefani Karp

Google Research

stefanik@google.com

&Shankar Krishnan

Google Research

skrishnan@google.com

&Sobhan Miryoosefi

Google Research

miryoosefi@google.com

&Sashank J. Reddi

Google Research

sashank@google.com

&Sanjiv Kumar

Google Research

sanjivk@google.com

Corresponding author

###### Abstract

Given the increasing scale of model sizes, efficient training strategies like gradual stacking  have garnered interest. Stacking enables efficient training by gradually growing the depth of a model in stages and using layers from a smaller model in an earlier stage to initialize the next stage. Although efficient for training, the model biases induced by such growing approaches are largely unexplored. In this work, we examine this fundamental aspect of gradual stacking, going beyond its efficiency benefits. We propose a variant of gradual stacking called **Midas** that can speed up language model training by up to 40%. Furthermore we discover an intriguing phenomenon: **Midas** is not only training-efficient but surprisingly also has an inductive bias towards improving downstream tasks, especially tasks that require reasoning abilities like reading comprehension and math problems, despite having similar or slightly worse perplexity compared to baseline training. To further analyze this inductive bias, we construct _reasoning primitives_ - simple synthetic tasks that are building blocks for reasoning - and find that a model pretrained with stacking is significantly better than standard pretraining on these primitives, with and without fine-tuning. This provides stronger and more robust evidence for this inductive bias towards reasoning. These findings of training efficiency and inductive bias towards reasoning are verified at 1B, 2B and 8B parameter language models. Finally, we conjecture the underlying reason for this inductive bias by exploring the connection of stacking to looped models and provide strong supporting empirical analysis.

## 1 Introduction

With the advent of very large deep learning models, efficient training to reduce the compute and time requirements is becoming increasingly important. Along with efficient optimization procedures, there has been a surge in interest to design efficient training strategies. One practical approach is to use smaller models to initialize larger models. Usually, this results in much faster convergence compared to vanilla training . Stacking and growing based approaches have particularly gained traction recently. For instance, gradual stacking  is a prominent approach where in each stage the last few layers of the modelare stacked onto itself to initialize the model's next stage, until the desired depth is reached. This has been shown to significantly speed up BERT pretraining and also has some theoretical justification for the efficiency aspect. While these methods can speed up training, such changes can also induce specific biases into the model. However, the effect of stacking-based approaches on generalization remains a fundamental open question and is largely unexplored.

Modern deep learning models, when trained carefully, have been shown to exhibit interesting inductive biases, and their success is partially attributed to them. Such biases can arise either from model architecture, optimization techniques, or training strategies, and these biases come in various forms including simplicity bias, flatness of learned function, and sparsity. The implicit bias of optimizers, in particular, has been subject to extensive research. For instance, the implicit bias of first-order methods like stochastic gradient descent has been studied extensively in overparametrized settings (Gunasekar et al., 2018; Liu et al., 2023). Similarly, the inductive biases of architecture components like self-attention and convolution have also been studied (Edelman et al., 2022; Wang and Wu, 2023). More recently, there has also been interest in constructs like looped models (Lan et al., 2020; Dehghani et al., 2018) that share weights across layers. They have been shown to be powerful enough to emulate programmable computers (Gianou et al., 2023) and have the inductive bias to simulate iterative solutions (Yang et al., 2023), thereby yielding models with algorithmic abilities. However, in this vein, very little is known about the implicit biases of newer training strategies (e.g., greedy layerwise training or gradual stacking) that are gaining popularity.

In this work, we investigate the inductive bias of stacking-based approaches beyond training efficiency. We uncover an intriguing phenomenon -- _pretraining with a variant of stacking is not only efficient, but also has a desirable inductive bias towards improving downstream benchmarks_. First, through comprehensive empirical analysis, we discover a novel variant of gradual stacking called **Midas** (MIDdie grAdual Stacking) which copies the middle block of layers of a small network to initialize a larger network (see Figure 1). We demonstrate that **Midas** is more efficient in training compared to standard training and the previous leading stagewise training approach. However, remarkably, it also yields _significantly better performance on many downstream reasoning tasks_. For instance, we see in Figure 1 that **Midas** has significantly better performance on math word problems and reasoning primitives. This performance boost should come as a surprise, since **Midas** uses exactly the same data and fewer training FLOPS compared to standard training. In fact, the pretraining perplexity of **Midas** on a validation set matches that of standard baseline training. This strongly suggests that there is some inductive bias for **Midas** at play.

In this paper, we formalize and provide strong evidence for such an "inductive bias" - **Midas** achieves better downstream evaluations despite performing similarly in terms of pretraining validation perplexity. Thus, the improved quality of **Midas** is not because of better generalization in the pretraining objective, but rather due to its ability to extract more skills and abilities from the pretraining process. This kind of inductive bias phenomenon was first formalized in Saunshi et al. (2022) for contrastive learning and later in Liu et al. (2023) for language modeling on synthetic data. However, this is the first evidence of a strong inductive bias for a training procedure in real language model

Figure 1: (a) Pictorial depiction of gradual stacking and **Midas**. (b) Accuracy improvements (in %) for model trained with **Midas** over baseline for various task groups, despite having the same perplexity. For both 1B, 2B and 8B models, we see that improvements are mostly positive, and are much larger for tasks that require a lot of reasoning.

training. While our real-world benchmarks already provide strong evidence, in order to better isolate the contributing factors, we construct simple synthetic tasks that are building blocks for reasoning, called _reasoning primitives_. We find that a model pretrained with **Midas** has much better performance on the reasoning primitives than a model obtained through standard pretraining, as is evident in Figure 1. In light of the above discussion, we state the main contributions of our paper.

* We propose a novel variant of gradual stacking, called **Midas**, that achieves better training efficiency than gradual stacking.
* Our investigation of the inductive bias in gradual stacking approaches, particularly with **Midas**, reveals a surprising benefit: _beyond enabling efficient training, it also enhances performance on downstream tasks_. This improvement is especially notable in tasks that rely on context and reasoning abilities.
* We provide strong evidence of the aforementioned phenomenon on several datasets that have previously been used to demonstrate reasoning capabilities.
* We construct simple synthetic tasks that are building blocks for reasoning and demonstrate that **Midas** performs significantly better than baseline training on these tasks. These datasets may be of independent interest to the LLM reasoning community.
* Finally, we conjecture the reason behind improved reasoning capabilities of **Midas** by presenting connections between gradual stacking and looped models and provide strong empirical evidence to support it.

## 2 Problem Setup

In this section, we first present the problem setup and background material needed for this paper. Before we discuss the problem setting, we set up the following notation for the rest of the paper.

**Notation.** For a deep network \(f\), we use \(f_{i}\) and \(\#(f)\) to denote the \(i^{}\) layer and the number of layers of the network, respectively. With slight abuse of notation, we use \(f_{i,b}\) (where \(i,b Z^{+}\)) to denote the layers between \((i-1) b\) to \(i b\) of a deep network \(f\). In other words, \(f_{i,b}\) denotes the \(i^{}\) block of \(b\) layers in a deep network \(f\). \(a_{1:k}\) is used to denote a sequence of \(k\) scalars \(\{a_{1},,a_{k}\}\).

Our goal is to learn a function \(f:\) which minimizes the loss \(_{(x,y)}(f(x),y)\), for some loss function \(:^{+}\{0\}\) and data distribution \(\) on \(\). We are interested in functions of the form \(f=f_{L} f_{L-1} f_{1}\) where \(\) and \(L\) represent function composition and depth of the network, respectively. We use \(_{L}\) to denote the function class consisting of functions of this form. Given samples from the distribution \(\), we typically use an iterative stochastic optimizer (e.g., SGD) to learn a function that minimizes the loss. We note that the optimization procedure is inconsequential to the arguments in the paper. For standard training, each iteration is of the form:

\[f^{t}=f^{t-1}+(f^{t-1},_{t},_{t}),\] ( **Standard Training** )

where \(_{t}\) is a mini-batch from distribution \(\) and \((f^{t-1},_{t},_{t})\) represents the iterative optimizer update at \(f^{t-1}\) on \(_{t}\) and learning rate \(_{t}\). The computation cost and memory requirement for training typically increases linearly with the depth, making even simple algorithms, like SGD, slow for very large models. Throughout this paper, we use \(T\) to denote the total number of training iterations.

### \(k\)-stage training

Since we primarily focus on stagewise training approaches, it is useful to formally define a stagewise training procedure. In contrast to standard training, \(k\)-stage training involves dividing the training process into \(k\) stages, and at each stage, using the the model from the previous stage to initialize the model in the current stage. For simplicity, we assume \(L\) is divisible by \(k\). The following are the key ingredients:

1. **Function class across stages.** At stage \(i\), we use function class \(_{d(i)}\) where \(d(i)\) denotes the depth of the network at that stage. When \(d(i) L\), training is more efficient.
2. **Training schedules across stages.** As training is divided into \(k\) stages, we use \(T_{1},,T_{k}\) steps across stages such that \(_{i=1}^{k}T_{i}=T\).

3. **Stage initialization.** This is the key component of stagewise training. Given a network \(f_{d(i-1)}\) trained in the \((i-1)^{}\) stage, let \(_{i}(f)\) denote the network initialization for the next stage where \(_{i}:_{d(i-1)}_{d(i)}\) is a growth operator.

Almost all the recent stagewise training procedures are different instantiations of this framework, using different training schedules and stage initializations. We will revisit some prominent instantiations of the framework in the next section.

### Progressive & Gradual Stacking

Progressive and gradual stacking are two special instantiations of the aforementioned framework. We provide a brief description of these approaches since they are important for our discussion.

**Progressive Stacking**(Gong et al., 2019). This is a simple instance of \(k\)-stage training setup where model in the previous stage is stacked onto itself to initialize the model in the next stage. In particular, **(1)** depth \(d(i)=2^{i-1}d(1)\) grows exponentially, **(2)** schedule \(T_{i}\) is typically \(T/k\) or proportional to \(d(i)\), and **(3)** the growth function \(_{i}(f)=f f\).

**Gradual Stacking**(Reddi et al., 2023). In contrast to progressive stacking, gradual stacking linearly increases the model depth by \(k\) in each stage. It only stacks the last \(L/k\) layers of model from the previous stage to initialize the model in the next stage, as follows.

1. The depth \(d(i)=\) grows linearly with the stage.
2. \(T_{i}\) is typically either \(T/k\) or allocated proportional or exponential to depth.
3. \(_{i}(f_{d(i-1)} f_{1})=f_{d(i-1)} f_{d(i -1)-(L/k)+1} f_{d(i-1)} f_{1}\). This corresponds to stacking the last \(L/k\) layers onto the network to initialize the next stage model.

In the next section, we study a novel variant of gradual stacking that enables faster training and exhibits an interesting inductive bias, which we examine carefully.

## 3 Algorithm: Midas

We present the **Midas** algorithm in this section. We first discuss the motivation behind this variant of gradual stacking and then formally define the algorithm.

### Motivation

The motivation for **Midas** touches upon two crucial aspects: (a) the role of different layers in a deep network and (b) a connection to looped models. Before delving into more technical details, it is important to illustrate these points. We present the case for **Midas** based on three observations.

Figure 2: (a) For an ALBert model trained with weight sharing across all layers, we measure the functional similarity between layers by looking at the top 1% activated neurons in each MLP layer and measure the intersection-over-union (IoU) metric for each pair of layers. Despite all layers having the same parameters, a natural functional similarity structure emerges around the middle. (b) For a UL2 model trained with GradStack, we measure the cosine similarity between every pair of layer blocks for the first feedforward layer weights. (c) The same similarity measured for **Midas**. The cosine similarities for stacking based models suggests a strong connection to looped models, and **Midas** has a closer similarity structure to ALBert style looped models than GradStack.

**Observation 1: gradual stacking breaks the natural role of layers.** Recall that gradual stacking initializes a larger model by duplicating and stacking the last block of \(b\) from the smaller model. Thus in the newly initialized model, the second-last block of \(b\) layers will be the same as the last \(b\) layers of the smaller model (see Figure 1). Intuitively, this is undesirable since the last few layers have been shown to play a different role compared to other layers for Transformer models (Belrose et al., 2023). We further validate this in Figure 6. Thus, duplicating the last few layers can break the natural role of layers at the initialization, making it a suboptimal choice. However, it is plausible that the similarity structure across layers is broken after continued training and the initialization is inconsequential. The next observation shows that this is not true, and establishes a connection to looped models - networks with shared parameters between layers.

**Observation 2: gradual stacking leads to models resembling looped models.** To check the effect of the initialization, we measure the cosine similarity between weights of layers for a model pretrained with gradual stacking. In Figure 1(b), we observe that indeed the layers continue to have very high cosine similarity at the end of training, thus establishing a connection between stacking and looped models like ALBert (Lan et al., 2020) and Universal Transformers (Dehghani et al., 2018). Unsurprisingly, the similarity structure for gradual stacking is lopsided towards the end of the model, which raises the question: _Is this similarity structure natural for looped models?_

**Observation 3: looped models exhibit similarity in the middle.** In order to study this, we train a prototypical looped model, ALBert, where all layers share the same parameters. Surprisingly, despite parameters being shared, a natural similarity structure emerges between layers: yet again the first and last layers tend to be functionally dissimilar to other layers, whereas the functional similarity between layers is the highest in the middle (see Figure 1(a)).

The above observations provides a strong motivation for stacking in the middle rather than at the end, thus inspiring our Midas algorithm.

### Midas algorithm

First we define the following mapping operator that is useful for stage initialization in Midas.

\[(f,b)=f_{n,b}  f_{ n/2,b}}_{} f_{1,b}, \]

where \(n=\#(f)/b\) is the number of blocks of \(b\) layers in deep network \(f\). Note that operator \((f,b)\) expands the size of the network by size \(b\). Based on this operator, Midas can again be described as a simple instantiation of the \(k\)-stage training framework, as seen below. For completeness, the pseudocode for Midas in listed in Algorithm 1.

```
Schedule \(T_{1:k}\), \(_{1:T}\), optimizer update \(\) (see Section 2), data distribution \(\). Initialize\(f^{1,0}_{L/k}\). for\(s=1 k\)do for\(t=1 T_{s}\)do  Sample batch \(_{t}\) from \(\). \(f^{s,t}=f^{s,t-1}+(f^{s,t-1},_{t},_{t})\) endfor  Initialize for next stage: \(f^{s+1,0}=(f^{s,T_{s}},L/k)\) (see Equation 1) endfor return\(f^{k,T}\)
```

**Algorithm 1****Midas**

Figure 3: Histogram of accuracy improvements for models trained with Midas over baseline. The data points are Midas 1B models listed in Table 1. The figure shows that Midas-based models have much higher improvement in the contextual version of TyDiQA compared to the non-contextual version.

1. The depth \(d(i)=}{k}\) grows linearly with the stage, similar to gradual stacking.
2. \(T_{i}\) is typically either proportional to \(i\) (linear proportional) or \(i^{2}\) (square proportional) or \((i)\) (exponential). We will revisit this during our empirical analysis.
3. We use growth operator \(\) in equation 1 for initializing the next stage, which corresponds to replicating the middle \(L/k\) layers to initialize the next stage model.

### Experiments: UL2 Pretraining

In this section, we evaluate **Midas** for standard language model pretraining. We train a 24L decoder-only model with 1.5B parameters using the UL2 objective (Tay et al., 2022) on a mixture of C4, Wikipedia, Arxiv and Github. The observations also hold for GPT-style autoregressive language modeling. To enable fair comparison, we cached the pretraining dataset and so all methods are trained for the same number 500B tokens in the same order, using the same batch size (refer to Appendix A.1 for more details on the training setup). We pretrain models with three methods: (a) standard training (_Baseline_), (b) gradual stacking (GradStack) and (c) our proposed method **Midas**. The goal is to compare them with respect to validation loss and downstream performance on several diverse benchmarks. Motivated by the proportional schedules from prior work, we try the following generalized proportional schedules for gradual stacking and **Midas**.

**Definition 3.1** (Prop-\(\) schedule).: _For a total training budget of \(T\) steps, the schedule Prop-\(\) spends time \(T_{i}\) in each stage such that \(T_{i} i^{}\) for all stages \(i[k]\). Thus \(T_{i}=}{_{j=1}^{i^{}}j^{}}T\)_

Prop-1 schedule has been found to work very well for BERT pretraining (Reddi et al., 2023). Since UL2 pretraining is a harder task, we also explore less aggressive schedules like Prop-2 and Prop-3 that spend more time on larger models.

**Efficiency and perplexity findings.** We summarize the main results in Table 1, for various stacking methods and schedules. Firstly, we note that for all schedules, **Midas** has significantly better validation log perplexity than GradStack at the same speedup level. This suggests that stacking in the middle is a lot more effective for optimization than stacking at the end of the model. With the Prop-2 schedule, **Midas** is 24% faster and nearly matches the baseline's log perplexity. Additionally, we observe that the findings are robust to the choice of block size for stacking.

**Downstream benchmark evaluations.** While perplexity can serve as a decent proxy for model quality, there is growing evidence that it is not the best measure (Liang et al., 2023). Downstream benchmark evaluations serve as a more holistic measure for quality and are out-of-distribution evaluations of skills. To this effect, we evaluate **Midas** on many standard benchmarks and these are grouped into task categories in Table 1 (refer to Appendix A.2 for more detailed evaluations on individual tasks). The accuracy for task category is an average over representative tasks from that group. For instance, for closed book QA task, we consider an average accuracy on TriviaQA, TydiQA (no context), NaturalQuestions and WebQuestions.

Surprisingly, we find that downstream improvements for **Midas** are significantly larger than the improvements in perplexity. In particular, **Midas** with Prop-2 schedule has very similar perplexity to baseline at 24% speedup, but the average downstream performance for **Midas** (26.8%) is much better than baseline (24.0%). In fact, even **Midas** with Prop-1 schedule which has worse log perplexity is much better on downstream evaluations. Similar trends of better downstream evals holds for the 2B parameter model. The improvements are particularly large for open book QA and math word problems, both of which are tasks that require reasoning abilities whereas memorization tasks like closed book QA do not improve. We conjecture that these downstream improvements are due to an _inductive bias_ induced by stacking and we dive deeper into this in the next section.

## 4 Inductive bias of stacking

Results in Table 1 demonstrate that **Midas** not only yields training speedups, but also improves downstream evaluations when trained on the same number of tokens as standard training. This suggests that stacking can extract more _skills_ out of the same data. Here, we take a closer look at these improvements in downstream evaluations through the lens of an _inductive bias_ of stacking.

### Downstream performance vs log perplexity

A reasonable expectation from pretraining is that improvements in the pretraining objective would correlate with improvements in model quality and downstream performance. This notion of transfer has even been theoretically formalized for language modeling in Saunshi et al. (2020), Arora and Goyal (2023). Thus, based on this, a natural explanation for the downstream improvements of stacking would be that it generalizes better on the pretraining objective. However, as we see in Table 1, downstream performance of **Midas** is better despite having similar or worse _validation_ perplexity - hence this is not simply the case of better generalization to unseen pretraining data. It is natural to ask: _If not perplexity, what explains this downstream phenomenon?_

Since pretraining objective is just a proxy objective for model quality, it is plausible that different training strategies and model architectures can extract different levels of skills from it. This is because there are multiple ways of doing well on the pretraining tasks, and some training strategies can be biased to pick one solution over another one. This behavior has been formalized as the inductive bias in pretraining by recent work (Saunshi et al., 2022; Liu et al., 2023) - at the same level of validation pretraining loss, different optimization algorithms could have vastly different downstream performance. We hypothesize that a similar phenomenon is at play when it comes to stacking.

**Isoplots.** Inspired by this phenomenon of different downstream performance at the same perplexity, we visualize the inductive bias of a method by plotting downstream accuracy vs log perplexity isoplots as training proceeds. We use the UL2 1B models that are pretrained with standard (baseline) training and with **Midas** using the Prop-2 schedule (refer to Section 3.3 for more details). In Figure 4, we visualize the downstream vs log perplexity plots for different task groups - closed-book QA, open-book QA and math word problems. We observe a very interesting trend - **Midas** and baseline training can have different isoplot behaviors and the divergence is different for different tasks.

    & \(d(i)/i\) (black line) & Schedule & Speedup &  Loss (\(\)) \\ (validation) \\  & Closed & Open & Math Word & All Tasks \\ Book QA (\(\)) & Book QA (\(\)) &  Problems (\(\)) \\ (\(\) value) \\  &  Average (\(\)) \\ (\(\) value) \\  & 
 Average (\(\)) \\ (\(\) value) \\  \\    \\  Baseline & 24 & & 1x & **1.996** & **13.2** & 33.3 & 23.5 & 24.0 \\  GradStack & 4 & Prop-1 & 1.39x & 2.045 & 10.3 & 31.4 & 23.5 & 22.6 \\
**Midas** & 4 & Prop-1 & 1.39x & 2.028 & 11.6 & 34.5 & 30.3 & 26.7 \\
**Midas** & 3 & Prop-1 & 1.41x & 2.032 & 10.6 & 36.1 & 27.0 & 25.6 \\  GradStack & 4 & Prop-2 & 1.24x & 2.024 & 11.0 & 31.6 & 17.3 & 20.4 \\
**Midas** & 4 & Prop-2 & 1.24x & 2.009 & 11.7 & 36.3 & 29.0 & 26.8 \\
**Midas** & 3 & Prop-2 & 1.26x & 2.012 & 11.9 & **37.3** & 29.8 & 27.5 \\ 
**Midas** & 4 & Prop-3 & 1.16x & 1.999 & 12.5 & 34.8 & **33.3** & **28.3** \\    \\  Baseline & 48 & & 1x & **1.926** & 15.2 & 39.1 & 27.1 & 28.0 \\ 
**Midas** & 8 & Prop-1 & 1.39x & 1.947 & 14.0 & 38.9 & 32.0 & 29.5 \\  GradStack & 8 & Prop-2 & 1.24x & 1.945 & 14.2 & 37.0 & 24.5 & 25.9 \\
**Midas** & 8 & Prop-2 & 1.24x & 1.929 & **15.7** & **40.2** & **38.2** & **32.9** \\    \\  Baseline & 72 & & 1x & **1.841** & 21.1 & 39.6 & 34.9 & 32.8 \\ 
**Midas** & 9 & Prop-2 & 1.26x & 1.844 & **21.8** & **40.0** & **43.1** & **36.4** \\   

Table 1: Downstream evaluations for UL2 pretrained models with 1B, 2B and 8B parameters. Comparisons include standard training (Baseline), gradual stacking (GradStack) from (Reddi et al., 2023) and our proposed method **Midas**. The downstream evaluations are averaged over tasks within 3 task groups. See Appendix A for precise tasks included in each task group. For each category and model size, we highlight the top model is **bolded** and the second best model is underlined. Firstly, **Midas** is much better than GradStack, thus justifying stacking in the middle. Secondly, **Midas** can match the log perplexity of baseline training while being roughly 24% faster. Furthermore, even the schedule with 40% speedup has much better downstream evaluations compared to baseline, even though it has worse log perplexity. The improvements are particularly large for task groups that require reasoning (open book QA, math word problems).

### Reasoning vs memorization for QA

For a clearer display of the inductive bias, we measure the improvements due to **Midas** on closed book vs open book QA tasks. It is reasonable to assume that closed book QA tasks require strong memorization abilities whereas open book QA tasks require some reasoning abilities to infer answers from the context that is provided. On average, we see much larger improvements on open book QA tasks compared to closed book QA tasks, as already evident in Figure 1 and Table 1.

**Midas is significantly better on Open book QA.** To make a direct comparison, we consider TydiQA-GoldP and TydiQA-NoContext tasks - the datasets are identical and the only difference is whether or not additional context is provided (the answer for the contextual version is guaranteed to be inferred from the given context). In Figure 3, we see that the improvements by various **Midas** based models on the contextual version of TydiQA are much higher than those on the non-contextual version. This provides direct evidence of the bias of **Midas** towards improving tasks that require reasoning. Furthermore, we find that the memorization performance of stacking improves as the schedule spends more time on the larger model.

### Reasoning in math tasks

To test reasoning abilities, we evaluate the language models on various math word problem datasets like SVAMP (Patel et al., 2021), ASDiv (Miao et al., 2020), AQuA dataset for algebraic word problems, the MAWPS benchmark (Koncel-Kedziorski et al., 2016). We report 5-shot evaluation for the pretrained model on these tasks. Following Wei et al. (2022), we use an external calculator to do the arithmetic and evaluate the models on their ability to compute the correct expression for the answer. This is because small models have bad arithmetic accuracy. The choice of using calculator or not does not significantly affect the trends of the results. For stacking, we use **Midas**Prop-2 model because it achieves nearly the same perplexity as the baseline model (while being 24% faster), thus, leading to a fair comparison based on the previous notion of inductive bias.

**Midas is significantly better on Math/Reasoning tasks.** Detailed results can be found in Table 5. For most math tasks, we observe that the **Midas**-based pretrained model is significantly better than the baseline model, especially for the MAWPs benchmark. This provides further evidence of better math and reasoning capabilities of **Midas**.

**GSM8K fine-tuning.** We also evaluate the 2B and 8B models on harder math problems from the GSM8k dataset (Cobbe et al., 2021) through few-shot prompting and fine-tuning. Full results are presented in Table 2. For **Midas** we use the Prop-2 model that has very similar perplexity as the

Figure 4: Downstream evaluation vs validation log perplexity isoplots as training proceeds for baseline and **Midas** 1B models trained on the same data (stacking is 24% faster here). On the y-axis we track the performance on various task groups – closed book QA, open book QA, math word problems and our reasoning primitives from Section 5. On the x-axis the log perplexity is presented in the reverse order, thus downstream performance for both methods improves as log perplexity gets lower. For closed book QA (memorization) tasks **Midas** has very similar trends to baseline. For open book QA tasks and math word problems, **Midas** has much better downstream performance at an equivalent log perplexity. This showcases the inductive bias of **Midas** towards better overall quality and better reasoning abilities.

baseline model. We find that **Midas** has much higher accuracy after fine-tuning, thus suggesting that the benefits of the inductive bias continue after fine-tuning and are not just restricted to few-shot evaluations. In particular, on the test set, the accuracy metric increased from 5.3% (for the baseline model) to 10.4% (for **Midas**) for the 2B model (these numbers were produced by computing the average score over three runs with different random seeds). Similarly the GSM8k accuracy of the 8B model improves from 12.3% to 15.2%. This suggests that **Midas** not only improves the performance on harder math tasks, but also that the gains remain or improve after fine-tuning.

Effect of calculator.For LLMs with less than 20B parameters, Wei et al. (2022) found that models often solve math problems correctly but make arithmetic errors, leading to low accuracy. Wei et al. (2022) remedied this by computing all arithmetic expressions using a Python program as an external calculator. In Table 2 we find that this improves the accuracy for our models too. Interestingly, the gap between **Midas** and baseline gets even larger with calculator use in almost all comparisons. We believe this is because arithmetic abilities are closer to memorization for smaller models (Razeghi et al., 2022) and calculator use makes the problem closer to reasoning, since now the model only has to infer the right expression. We believe this interplay between reasoning and memorization for math problems deserves further investigation.

### Connection to looped models

Given the nature of the growth operator in each stage, we hypothesize that stacking based models are close to looped models. The layer duplication that happens at every stage ensures that blocks of layers start from a common initialization. We measure the similarity between different blocks of layers by measuring cosine similarities between the parameter vectors (see Figure 2). Since looped models have been conjectured to solve algorithmic problems (Giannou et al., 2023) by finding iterative solutions (Yang et al., 2023), we conjecture that the better reasoning abilities of **Midas** are due to this connection to looped models We believe exploring this further is a very fruitful direction.

   &  Pretraining \\ Loss (\(\)) \\  } & Math WPs (5-shot) &  &  \\  & & W/o calc. & W calc. & W/o calc. & W/o calc. & W calc. \\    \\   Baseline & 1.926 & 15.4 & 27.1 & 3.0 & 3.6 & 5.3 & 8.5 \\
**Midas** & 1.929 & 22.5 & 38.3 & 3.0 & 4.1 & 10.4 & 14.5 \\    \\   Baseline & 1.841 & 27.3 & 34.9 & 4.5 & 6.6 & 12.3 & 15.8 \\
**Midas** & 1.844 & 32.9 & 43.1 & 5.5 & 7.4 & 15.2 & 18.7 \\  

Table 2: Evaluation on math tasks, including math word problems from Table 1 and a harder task GSM8k. For GSM8k we report accuracy with 8-shot prompts and with finetuning. We also report accuracy on all tasks after using an external calculator to fix arithmetic errors; this corresponds to w/ calc. Overall the use of calculator improves the accuracy for all models on all tasks. The benefit of **Midas** over baseline is even higher with calculator.

Figure 5: Accuracy improvements for model trained with **Midas** over baseline for representative _reasoning primitives_, despite having the same perplexity. We see clear improvements for **Midas** on almost all the primitives, both with 5-shot evaluation and after fine-tuning (FT) for the depth 1 and 2 primitive.

## 5 Deep dive into reasoning improvements

To further investigate the nature of this inductive bias, we construct various simple synthetic tasks to help tease apart the model's capabilities. We conjecture that these simple tasks capture core basic capabilities needed for contextual reasoning, and we therefore call these tasks "contextual reasoning primitives". They are: induction copying, variable assignment, and pre-school math (PSM), discussed further below. Overall, across various few-shot evaluations and fine-tuning, we see significant performance gaps between **Midas** and baseline training, suggesting that we have successfully isolated some of the basic capabilities at which **Midas** excels relative to baseline training. We refer the reader to Appendix B for more results and the exact input format.

**Primitive 1: Induction copying.** The "induction copying" primitive presents a sequence of words, followed by a subsequence selected randomly from within this original sequence, and asks the model to output the _next_ word in the sequence. A simplified example is: "pum nyj gdq ocu rzk jbw mlz eny kyx uni rzk jbw mlz eny kyx", and the expected output is "uni". This primitive is inspired by the "induction head" mechanism introduced in Olsson et al. (2022), which is posited to be the basic mechanism for in-context learning more generally. In Figure 5, task "Copying", we present results for 3-letter words of random letters, separated by spaces, with a sequence length of 10 and a subsequence length of 5.

**Primitive 2: Variable assignment.** The "variable assignment" primitive tests the model's ability to associate a value with a variable name and apply this ability _compositionally_, which we test by varying the "depth" of the task. We conjecture that this ability is a core function in contextual reasoning, particularly in math. An example of the depth-0 variant is "u=1; t=0; v=13; y=4; f=22; y=", and the expected output is 4. An example of the depth-2 variant is "y=7; f=0; z=3; b=9; x=8; q=y; l=f; m=z; h=x; a=b; n=h; j=m; t=a; i=1; g=q; n=", and the expected output is 8. Refer to Appendix B for more details.

**Primitive 3: Pre-school math (PSM).** This tests the model's ability to solve a very simple "pre-school math" problem by correctly associating multiple values and variables _simultaneously_ and applying this association to a particular task. An example is "z=6; b=5; i=-z+b; i=", and the expected answer (with chain-of-thought) is "-6+5=-1".

**5-shot evaluation results.** Figure 5 presents the results for representative tasks, with more results in Appendix B. Overall, we see that **Midas** outperforms baseline training across all tasks. In particular, we see that **Midas** is significantly stronger than the baseline at Depth 0, Copying, PSM-calc, and Depth 1, in decreasing order of magnitude of the performance gap. Depth-2 is much harder and is at random guessing (20%) for both models.

**Fine-tuning results.** Due to the difficulty of the variable assignment task at Depths 1 and 2, we investigate fine-tuning on these tasks as well. We fine-tune on a mixture of 32 depth-1 examples and 32 depth-2 examples (i.e., only 64 examples total), using full-batch gradient descent. Figure 5 reports the validation accuracy on Depth 1 and Depth 2 after fine-tuning on this mixture (tasks "Depth 1 (FT)" and "Depth 2 (FT)"). Overall, we see that fine-tuning with just 64 examples significantly improves performance, resulting in **Midas** outperforming the baseline by a gap of over 20% validation accuracy at both depths. See Appendix B for further fine-tuning and evaluation details.

## 6 Conclusions and future work

In this work we propose a novel stacking method that outperforms previous stacking methods and speeds up language model pretraining by 25-40%. In the process, we uncover a very intriguing inductive bias of stacking - its ability to improve downstream reasoning tasks. Through extensive empirical analysis, the paper makes a strong case for the presence and significance of this inductive bias. We believe this deserves further attention and exploration since understanding this inductive bias could unlock new approaches to improving model quality, reasoning in particular. The reasoning primitives start to provide more insights by isolating the reasoning improvements and we hope that the dataset is useful for future research on improving reasoning. Finally, understanding the dichotomy between memorization and reasoning, and how this affects the performance on various tasks, is an interesting direction to pursue.

Acknowledgments.We thank Srinadh Bhojanapalli and Vaishnavh Nagarajan for discussions on the role of layers and memory vs contextual tasks, respectively, in the early stages of the project. We also thank Satyen Kale for valuable feedback throughout the project.