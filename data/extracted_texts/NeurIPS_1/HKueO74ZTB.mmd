# Embedding Space Interpolation Beyond Mini-Batch, Beyond Pairs and Beyond Examples

Shashanka Venkataramanan\({}^{1}\)   Ewa Kijak\({}^{1}\)   Laurent Amsaleg\({}^{1}\)   Yannis Avrithis\({}^{2}\)

\({}^{1}\)Inria, Univ Rennes, CNRS, IRISA

\({}^{2}\)Institute of Advanced Research on Artificial Intelligence (IARAI)

###### Abstract

_Mixup_ refers to interpolation-based data augmentation, originally motivated as a way to go beyond _empirical risk minimization_ (ERM). Its extensions mostly focus on the definition of interpolation and the space (input or embedding) where it takes place, while the augmentation process itself is less studied. In most methods, the number of generated examples is limited to the mini-batch size and the number of examples being interpolated is limited to two (pairs), in the input space.

We make progress in this direction by introducing _MultiMix_, which generates an arbitrarily large number of interpolated examples beyond the mini-batch size, and interpolates the entire mini-batch in the embedding space. Effectively, we sample on the entire _convex hull_ of the mini-batch rather than along linear segments between pairs of examples.

On sequence data we further extend to _Dense MultiMix_. We densely interpolate features and target labels at each spatial location and also apply the loss densely. To mitigate the lack of dense labels, we inherit labels from examples and weight interpolation factors by attention as a measure of confidence.

Overall, we increase the number of loss terms per mini-batch by orders of magnitude at little additional cost. This is only possible because of interpolating in the _embedding space_. We empirically show that our solutions yield significant improvement over state-of-the-art mixup methods on four different benchmarks, despite interpolation being only linear. By analyzing the embedding space, we show that the classes are more tightly clustered and uniformly spread over the embedding space, thereby explaining the improved behavior.

## 1 Introduction

_Mixup_ is a data augmentation method that interpolates between pairs of training examples, thus regularizing a neural network to favor linear behavior in-between examples. Besides improving generalization, it has important properties such as reducing overconfident predictions and increasing the robustness to adversarial examples. Several follow-up works have studied interpolation in the _latent_ or _embedding_ space, which is equivalent to interpolating along a manifold in the input space , and a number of nonlinear and attention-based interpolation mechanisms . However, little progress has been made in the augmentation process itself, _i.e_., the number \(n\) of generated examples and the number \(m\) of examples being interpolated.

Mixup was originally motivated as a way to go beyond _empirical risk minimization_ (ERM)  through a vicinal distribution expressed as an expectation over an interpolation factor \(\), which is equivalent to the set of linear segments between all pairs of training inputs and targets. In practice however, in every training iteration, a single scalar \(\) is drawn and the number of interpolated pairs is limited to the size \(b\) of the mini-batch (\(n=b\)), as illustrated in Figure 1(a). This is because ifinterpolation takes place in the input space, it would be expensive to increase the number of pairs per iteration. To our knowledge, these limitations exist in all mixup methods.

In this work, we argue that a data augmentation process should increase the data seen by the model, or at least by its last few layers, as much as possible. In this sense, we follow _manifold mixup_ and generalize it in a number of ways to introduce _MultiMix_.

First, we increase the number \(n\) of generated examples beyond the mini-batch size \(b\), by orders of magnitude (\(n b\)). This is possible by interpolating at the deepest layer, _i.e._, just before the classifier, which happens to be the most effective choice. To our knowledge, we are the first to investigate \(n>b\).

Second, we increase the number \(m\) of examples being interpolated from \(m=2\) (pairs) to \(m=b\) (a single _tuple_ containing the entire mini-batch). Effectively, instead of linear segments between pairs of examples in the mini-batch, we sample on their entire _convex hull_ as illustrated in Figure 1(b). This idea has been investigated in the input space: the original mixup method  found it non-effective, while  found it effective only up to \(m=3\) examples and  went up to \(m=25\) but with very sparse interpolation factors. To our knowledge, we are the first to investigate \(m>2\) in the embedding space and to show that it is effective up to \(m=b\).

Third, instead of using a single scalar value of \(\) per mini-batch, we draw a different vector \(^{m}\) for each interpolated example. A single \(\) works for standard mixup because the main source of randomness is the choice of pairs (or small tuples) out of \(b\) examples. In our case, because we use a single tuple of size \(m=b\), the only source of randomness being \(\).

We also argue that, what matters more than the number of (interpolated) examples is the total number of _loss terms_ per mini-batch. A common way to increase the number of loss terms per example is by _dense_ operations when working on sequence data, _e.g._ patches in images or voxels in video. This is common in dense tasks like segmentation  and less common in classification . We are the first to investigate this idea in mixup, introducing _Dense MultiMix_.

In particular, this is an extension of MultiMix where we work with feature tensors of spatial resolution \(r\) and densely interpolate features and targets at each spatial location, generating \(r\) interpolated features per example and \(nr>n\) per mini-batch. We also apply the loss densely. This increases the number of loss terms further by a factor \(r\), typically one or two orders of magnitude, compared with MultiMix. Of course, for this to work, we also need a target label per feature, which we inherit from the corresponding example. This is a _weak_ form of supervision . To carefully select the most representative features per object, we use an _attention map_ representing our confidence in the target label per spatial location. The interpolation vectors \(\) are then weighted by attention.

Table 1 summarizes the properties of our solutions against existing interpolation methods. Overall, we make the following contributions:

   Method & Space & Terms & Mixed & Fact & Distr \\  Mixup  & input & \(b\) & \(2\) & \(1\) & Beta \\ Manifold mixup  & embedding & \(b\) & \(2\) & \(1\) & Beta \\ \(\)-Mixup  & input & \(b\) & \(25\) & \(1\) & RandPerm \\ SuperMix  & input & \(b\) & \(3\) & \(1\) & Dirchelt \\  MultiMix (ours) & embedding & \(n\) & \(b\) & \(n\) & Dirichlet \\ Dense MultiMix (ours) & embedding & \(nr\) & \(b\) & \(nr\) & Dirichlet \\   

Table 1: _Interpolation method properties_. Space: Space where interpolation takes place; Terms: number of loss terms per mini-batch; Mixed: maximum number \(m\) of examples being interpolated; Fact: number of interpolation factors \(\) per mini-batch; Distr: distribution used to sample interpolation factors; RandPerm: random permutations of a fixed discrete probability distribution. \(b\): mini-batch size; \(n\): number of generated examples per mini-batch; \(r\): spatial resolution.

Figure 1: Data augmentation in a mini-batch \(B\) of \(b=10\) points in two dimensions. (a) _mixup_: sampling \(n=b\) points on linear segments between \(b\) pairs of points using the same interpolation factor \(\). (b) _MultiMix_: sampling \(n=300\) points in the convex hull of \(B\).

1. We generate an _arbitrary large number of interpolated examples_ beyond the mini-batch size, each by interpolating the entire mini-batch in the embedding space, with one interpolation vector per example. (subsection 3.2).
2. We extend to attention-weighted _dense_ interpolation in the embedding space, further increasing the number of loss terms per example (subsection 3.3).
3. We improve over state-of-the-art (SoTA) mixup methods on _image classification_, _robustness to adversarial attacks_, _object detection_ and _out-of-distribution detection_. Our solutions have little or no additional cost while interpolation is only linear (section 4).
4. Analysis of the embedding space shows that our solutions yield classes that are _tightly clustered_ and _uniformly spread_ over the embedding space (section 4).

## 2 Related Work

Mixup: interpolation methodsIn general, mixup interpolates between pairs of input examples  or embeddings  and their corresponding target labels. Several follow-up methods mix input images according to spatial position, either at random rectangles  or based on attention [46; 26; 25], in an attempt to focus on a different object in each image. Other follow-up method  randomly cuts image at patch level and obtains its corresponding mixed label using content-based attention. We also use attention in our dense MultiMix variant, but in the embedding space. Other definitions of interpolation include the combination of content and style from two images , generating out-of-manifold samples using adaptive masks , generating binary masks by thresholding random low-frequency images  and spatial alignment of dense features . Our dense MultiMix also uses dense features but without aligning them and can interpolate a large number of samples, thereby increasing the number of loss-terms per example. Our work is orthogonal to these methods as we focus on the sampling process of augmentation rather than on the definition of interpolation. We refer the reader to  for a comprehensive study of mixup methods.

Mixup: number of examples to interpolateTo the best of our knowledge, the only methods that interpolate more than two examples for image classification are OptTransMix , SuperMix , \(\)-Mixup  and DAML . All these methods operate in the _input space_ and limit the number of generated examples to the mini-batch size; whereas MultiMix generates an arbitrary number of interpolated examples (more than \(1000\) in practice) in the _embedding space_. To determine the interpolation weights, OptTransMix uses a complex optimization process and only applies to images with clean background; \(\)-Mixup uses random permutations of a fixed vector; SuperMix uses a Dirichlet distribution over _not more than \(3\)_ examples in practice; and DAML uses a Dirichlet distribution to interpolate across different domains. We also use a Dirichlet distribution but over as many examples as the mini-batch size. Similar to MultiMix,  uses different \(\) within a single batch. Beyond classification, \(m\)-Mix  uses graph neural networks in a self-supervised setting with pair-based loss functions. The interpolation weights are deterministic and based on pairwise similarities.

Number of loss termsIncreasing the number of loss terms more than \(b\) per mini-batch is not very common in classification. In _deep metric learning_[40; 28; 53], it is common to have a loss term for each pair of examples in a mini-batch in the embedding space, giving rise to \(b(b-1)/2\) loss terms per mini-batch, even without mixup . _Contrastive_ loss functions are also common in self-supervised learning [8; 5] but have been used for supervised image classification too . Ensemble methods [55; 14; 19; 3] increase the number of loss terms, but with the proportional increase of the cost by operating in the input space. To our knowledge, MultiMix is the first method to increase the number of loss terms per mini-batch to \(n b\) for mixup. Dense MultiMix further increases this number to \(nr\). By operating in the embedding space, their computational overhead is minimal.

Dense loss functionsAlthough standard in dense tasks like semantic segmentation [41; 20], where dense targets commonly exist, dense loss functions are less common otherwise. Few examples are in _weakly-supervised segmentation_[70; 2], _few-shot learning_[33; 31], where data augmentation is of utter importance, _attribution methods_ and _unsupervised representation learning_, _e.g._ dense contrastive learning [42; 54], learning from spatial correspondences [59; 57] and masked language or image modeling [12; 58; 32; 69]. To our knowledge, we are the first to use dense interpolation and a dense loss function for mixup.

## 3 Method

### Preliminaries and background

Problem formulationLet \(x\) be an input example and \(y\) its one-hot encoded target, where \(=^{D}\) is the input space, \(=\{0,1\}^{c}\) and \(c\) is the total number of classes. Let \(f_{}:^{d}\) be an encoder that maps the input \(x\) to an embedding \(z=f_{}(x)\), where \(d\) is the dimension of the embedding. A classifier \(g_{W}:^{d}^{c-1}\) maps \(z\) to a vector \(p=g_{W}(z)\) of predicted probabilities over classes, where \(^{n}^{n+1}\) is the unit \(n\)-simplex, _i.e._, \(p 0\) and \(_{c}^{}p=1\), and \(_{c}^{c}\) is an all-ones vector. The overall network mapping is \(f:=g_{W} f_{}\). Parameters \((,W)\) are learned by optimizing over mini-batches.

Given a mini-batch of \(b\) examples, let \(X=(x_{1},,x_{b})^{D b}\) be the inputs, \(Y=(y_{1},,y_{b})^{c b}\) the targets and \(P=(p_{1},,p_{b})^{c b}\) the predicted probabilities of the mini-batch, where \(P=f(X):=(f(x_{1}),,f(x_{b}))\). The objective is to minimize the cross-entropy

\[H(Y,P):=-_{c}^{}(Y(P))_{b}/b \]

of predicted probabilities \(P\) relative to targets \(Y\) averaged over the mini-batch, where \(\) is the Hadamard (element-wise) product. In summary, the mini-batch loss is

\[L(X,Y;,W):=H(Y,g_{W}(f_{}(X))). \]

The total number of loss terms per mini-batch is \(b\).

MixupMixup methods commonly interpolate pairs of inputs or embeddings and the corresponding targets at the mini-batch level while training. Given a mini-batch of \(b\) examples with inputs \(X\) and targets \(Y\), let \(Z=(z_{1},,z_{b})^{d b}\) be the embeddings of the mini-batch, where \(Z=f_{}(X)\). _Manifold mixup_ interpolates the embeddings and targets by forming a convex combination of the pairs with interpolation factor \(\):

\[ =Z( I+(1-)) \] \[ =Y( I+(1-)), \]

where \((,)\), \(I\) is the identity matrix and \(^{b b}\) is a permutation matrix. _Input mixup_ interpolates inputs rather than embeddings:

\[=X( I+(1-)). \]

Whatever the interpolation method and the space where it is performed, the interpolated data, \(\) or \(\), replaces the original mini-batch data and gives rise to predicted probabilities \(=(p_{1},,p_{b})^{c b}\) over classes, _e.g._\(=f()\) or \(=g_{W}()\). Then, the average cross-entropy \(H(,)\) (1) between the predicted probabilities \(\) and interpolated targets \(\) is minimized. The number of generated examples per mini-batch is \(n=b\), same as the original mini-batch size, and each is obtained by interpolating \(m=2\) examples. The total number of loss terms per mini-batch is again \(b\).

### MultiMix

InterpolationThe number of generated examples per mini-batch is now \(n b\) and the number of examples being interpolated is \(m=b\). Given a mini-batch of \(b\) examples with embeddings \(Z\) and targets \(Y\), we draw interpolation vectors \(_{k}()\) for \(k=1,,n\), where \(()\) is the symmetric Dirichlet distribution and \(_{k}^{m-1}\), that is, \(_{k} 0\) and \(_{m}^{}_{k}=1\). We then interpolate embeddings and targets by taking \(n\) convex combinations over all \(m\) examples:

\[ =Z \] \[ =Y, \]

where \(=(_{1},,_{n})^{b n}\). We thus generalize manifold mixup :

1. from \(b\) to an arbitrary number \(n b\) of generated examples: interpolated embeddings \(^{d n}\) (6) _vs._\(^{d b}\) in (3), targets \(^{c n}\) (7) _vs._\(^{c b}\) in (4);2. from pairs (\(m=2\)) to a tuple of length \(m=b\), containing the entire mini-batch: \(m\)-term convex combination (6),(7) _vs._\(2\)-term in (3),(4), Dirichlet _vs._ Beta distribution;
3. from fixed \(\) across the mini-batch to a different \(_{k}\) for each generated example.

LossAgain, we replace the original mini-batch embeddings \(Z\) by the interpolated embeddings \(\) and minimize the average cross-entropy \(H(,)\) (1) between the predicted probabilities \(=g_{W}()\) and the interpolated targets \(\) (7). Compared with (2), the mini-batch loss becomes

\[L_{M}(X,Y;,W):=H(Y,g_{W}(f_{}(X))). \]

The total number of loss terms per mini-batch is now \(n b\).

### Dense MultiMix

We now extend to the case where the embeddings are structured, _e.g._ in tensors. This happens _e.g._ with token _vs._ sentence embeddings in NLP and patch _vs._ image embeddings in vision. It works by removing spatial pooling and applying the loss function densely over all tokens/patches. The idea is illustrated in Figure 2. For the sake of exposition, our formulation uses sets of matrices grouped either by example or by spatial position. In practice, all operations are on tensors.

PreliminariesThe encoder is now \(f_{}:^{d r}\), mapping the input \(x\) to an embedding \(=f_{}(x)^{d r}\), where \(d\) is the number of channels and \(r\) is its spatial resolution--if there are more than one spatial dimensions, these are flattened.

Given a mini-batch of \(b\) examples, we have again inputs \(X=(x_{1},,x_{b})^{D b}\) and targets \(Y=(y_{1},,y_{b})^{c b}\). Each embedding \(_{i}=f_{}(x_{i})=(z_{1}^{i},,z_{r}^{i})^{d  r}\) for \(i=1,,b\) consists of features \(z_{i}^{j}^{d}\) for spatial position \(j=1,,r\). We group features by position in matrices \(Z^{1},,Z^{r}\), where \(Z^{j}=(z_{1}^{j},,z_{b}^{j})^{d b}\) for \(j=1,,r\).

AttentionIn the absence of dense targets, each spatial location inherits the target of the corresponding input example. This is weak supervision, because the target object is not visible everywhere. To select the most reliable locations, we define a level of confidence according to an attention map. Given an embedding \(^{d r}\) with target \(y\) and a vector \(u^{d}\), the _attention map_

\[a=h(^{}u)^{r} \]

measures the similarity of features of \(\) to \(u\), where \(h\) is a non-linearity, _e.g._ softmax or ReLU followed by \(_{1}\) normalization. There are different ways to define vector \(u\). For example, \(u=_{r}/r\) by global average pooling (GAP) of \(\), or \(u=Wy\) assuming a linear classifier with \(W^{d c}\), similar to class activation mapping (CAM) . In case of no attention, \(a=_{r}/r\) is uniform.

Given a mini-batch, let \(a_{i}=(a_{1}^{1},,a_{i}^{r})^{r}\) be the attention map of embedding \(_{i}\) (9) for \(i=1,,b\). We group attention by position in vectors \(a^{1},,a^{r}\), where \(a^{j}=(a_{1}^{j},,a_{b}^{j})^{b}\)

Figure 2: _Dense MultiMix_ (subsection 3.3) for the special case \(m=2\) (two examples), \(n=1\) (one interpolated embedding), \(r=9\) (spatial resolution \(3 3\)). The embeddings \(_{1},_{2}^{d 9}\) of input images \(x_{1},x_{2}\) are extracted by encoder \(f_{}\). Attention maps \(a_{1},a_{2}^{9}\) are extracted (9), multiplied element-wise with interpolation vectors \(,(1-)^{9}\) (10) and \(_{1}\)-normalized per spatial position (11). The resulting weights are used to form the interpolated embedding \(}^{d 9}\) as a convex combination of \(_{1},_{2}\) per spatial position (12). Targets are interpolated similarly (13).

for \(j=1,,r\). Figure 6 in the supplementary shows the attention obtained by (9). We observe high confidence on the entire or part of the object. Where confidence is low, we assume the object is not visible and thus the corresponding interpolation factor should be low.

InterpolationThere are again \(n b\) generated examples per mini-batch, with \(m=b\) examples being densely interpolated. For each spatial position \(j=1,,r\), we draw interpolation vectors \(_{k}^{j}()\) for \(k=1,,n\) and define \(^{j}=(_{1}^{j},,_{n}^{j})^{m n}\). Since input examples are assumed to contribute according to the attention vector \(a^{j}^{m}\), we scale the rows of \(^{j}\) accordingly and normalize its columns back to \(^{m-1}\) to define convex combinations:

\[M^{j} =(a^{j})^{j} \] \[^{j} =M^{j}(_{m}^{}M^{j})^{-1} \]

We then interpolate embeddings and targets by taking \(n\) convex combinations over \(m\) examples:

\[^{j} =Z^{j}^{j} \] \[^{j} =Y^{j}. \]

This is similar to (6),(7), but there is a different interpolated embedding matrix \(^{j}^{d n}\) as well as target matrix \(^{j}^{c n}\) per position, even though the original target matrix \(Y\) is one. The total number of interpolated features and targets per mini-batch is now \(nr\).

ClassifierThe classifier is now \(g_{W}:^{d r}^{c r}\), maintaining the same spatial resolution as the embedding and generating one vector of predicted probabilities per spatial position. This is done by removing average pooling or any down-sampling operation. The interpolated embeddings \(^{1},,^{r}\) (12) are grouped by example into \(}_{1},,}_{n}^{d  r}\), mapped by \(g_{W}\) to predicted probabilities \(}_{1},,}_{n}^{c  r}\) and grouped again by position into \(^{1},,^{r}^{c n}\).

In the simple case where the original classifier is linear, _i.e_. \(W^{d c}\), it is seen as \(1 1\) convolution and applied densely to each column (feature) of \(^{j}\) for \(j=1,,r\).

LossFinally, we learn parameters \(,W\) by minimizing the _weighted cross-entropy_\(H(^{j},^{j};s)\) of \(^{j}\) relative to the interpolated targets \(^{j}\) again densely at each position \(j\), where

\[H(Y,P;s):=-_{c}^{}(Y(P))s/(_{n}^{}s) \]

generalizes (1) and the weight vector is defined as \(s=_{m}^{}M^{j}^{n}\). This is exactly the vector used to normalize the columns of \(M^{j}\) in (11). The motivation is that the columns of \(M^{j}\) are the original interpolation vectors weighted by attention: A small \(_{1}\) norm indicates that for the given position \(j\), we are sampling from examples of low attention, hence the loss is to be discounted. The total number of loss terms per mini-batch is now \(nr\).

## 4 Experiments

### Setup

We use a mini-batch of size \(b=128\) examples in all experiments. Following manifold mixup , for every mini-batch, we apply MultiMix with probability \(0.5\) or input mixup otherwise. For MultiMix, the default settings are given in subsection 4.6. We use PreActResnet-18 (R-18)  and WRN16-8  as encoder on CIFAR-10 and CIFAR-100 datasets ; R-18 on TinyImagenet  (TI); and Resnet-50 (R-50) and ViT-S/16  on ImageNet . To better understand the effect of mixup in ViT, we evaluate MultiMix and Dense MultiMix on ImageNet without using strong augmentations like Auto-Augment , Rand-Augment , random erasing  and CutMix . We reproduce TransMix  and TokenMix  using these settings.

### Results: Image classification and robustness

Image classificationIn Table 2 we observe that MultiMix and Dense MultiMix already outperform SoTA on all datasets except CIFAR-10 with R-18, where they are on par with Co-Mixup. Dense MultiMix improves over vanilla MultiMix and its effect is complementary on all datasets. On TI for example, Dense MultiMix improves over MultiMix by 1.33% and SoTA by 1.59%. We provide additional analysis of the embedding space on 10 classes of CIFAR-100 in subsection 4.4.

In Table 3 we observe that on ImageNet with R-50, vanilla MultiMix outperforms all methods except AlignMixup. Dense MultiMix outperforms all SoTA with both R-50 and ViT-S/16, bringing an overall gain of 3% over the baseline with R-50 and 2.2% with ViT-S/16. The gain over AlignMixup with R-50 is small, but it is impressive that it comes with only linear interpolation. To better isolate the effect of each method, we reproduce TransMix  and TokenMix  with ViT-S/16 using their official code with our settings, _i.e._, without strong regularizers like CutMix, Auto-Augment, Random-Augment _etc._ MultiMix is on par, while Dense MultiMix outperforms them by 1%.

Training speedTable 3 also shows the training speed as measured on NVIDIA V-100 GPU including forward and backward pass. The vanilla MultiMix has nearly the same speed with the baseline, bringing an accuracy gain of 2.49% with R-50. Dense MultiMix is slightly slower, increasing the gain to 3.10%. The inference speed is the same for all methods.

Robustness to adversarial attacksWe follow the experimental settings of AlignMixup  and use \(8/255\)\(l_{}\)\(\)-ball for FGSM  and \(4/255\)\(l_{}\)\(\)-ball with step size 2/255 for PGD  attack.

   } &  &  \\   &  &  &  &  &  \\ Network & R-18 & W16-8 & R-18 & W16-8 & R-18 & R-18 & W16-8 & R-18 \\  Baseline\({}^{}\) & 88.8\(\)0.11 & 88.3\(\)0.33 & 87.2\(\)0.10 & 72.6\(\)0.22 & 91.9\(\)0.06 & 99.9\(\)0.0 & 99.9\(\)0.01 & 99.9\(\)0.01 & 99.9\(\)0.01 \\ Manifold mixup \({}^{}\) & 76.9\(\)0.14 & 76.0\(\)0.04 & 80.2\(\)0.06 & 56.3\(\)0.10 & 89.3\(\)0.06 & 97.2\(\)0.01 & 98.4\(\)0.03 & 99.6\(\)0.01 & 98.4\(\)0.03 \\ PuzzelMix \({}^{}\) & 57.4\(\)0.22 & 60.7\(\)0.02 & 78.8\(\)0.09 & 57.8\(\)0.03 & 83.8\(\)0.05 & 97.7\(\)0.01 & 97.0\(\)0.01 & 96.4\(\)0.02 & 95.2\(\)0.03 \\ Co-Mixup \({}^{}\) & 60.1\(\)0.05 & 58.8\(\)0.10 & 77.5\(\)0.05 & 56.5\(\)0.04 & – & 97.5\(\)0.02 & 96.1\(\)0.03 & 95.3\(\)0.34 & 94.2\(\)0.01 \\ AlignMixup \({}^{}\) & 54.8\(\)0.05 & 56.0\(\)0.14 & 74.1\(\)0.04 & 55.5\(\)0.03 & 78.8\(\)0.03 & 95.3\(\)0.04 & 96.7\(\)0.03 & 90.4\(\)0.04 & 92.1\(\)0.03 \\ \(\)-Mixup \({}^{}\) & 72.8\(\)0.23 & 67.3\(\)0.24 & 75.3\(\)0.21 & 68.0\(\)0.21 & 84.7\(\)0.18 & 98.0\(\)0.06 & 98.6\(\)0.03 & 97.4\(\)0.10 & 96.1\(\)0.10 \\  MultiMix (ours) & **54.1\(\)**0.09 & 55.3\(\)0.04 & 73.8\(\)0.04 & 54.5\(\)0.01 & 77.5\(\)0.01 & 94.2\(\)0.04 & 94.8\(\)0.01 & 90.0\(\)0.01 & 91.6\(\)0.01 \\ Dense MultiMix (ours) & **54.1\(\)**0.01 & **53.3\(\)**0.03 & **73.5\(\)**0.03 & **52.9\(\)**0.04 & **75.5\(\)**0.04 & **92.9\(\)**0.04 & **92.6\(\)**0.01 & **88.6\(\)**0.03 & **90.8\(\)**0.01 \\  Gain & **+0.7** & **+2.7** & **+0.6** & **+2.1** & **+3.3** & **+2.4** & **+3.5** & **+1.4** & **+1.3** \\   

Table 4: _Robustness to FGSM & PGD attacks._ Mean and standard deviation of Top-1 error (%) for 5 runs: lower is better. \({}^{}\): reproduced, \({}^{}\): reported by AlignMixup. **Bold black**: best; blue: second best; underline: best baseline. Gain: reduction of error over best baseline. TI: TinyImagenet. R: PreActResnet, W: WRN. Comparison with additional baselines is given in subsection A.2.

   Network &  &  \\ Method &  &  &  &  \\  Baseline\({}^{}\) & 1.17 & 76.32 & 1.01 & 73.9 \\ Manifold mixup \({}^{}\) & 1.15 & 77.50 & 0.97 & 74.2 \\ PuzzelMix \({}^{}\) & 0.84 & 78.76 & 0.73 & 74.7 \\ Co-Mixup \({}^{}\) & 0.62 & – & 0.57 & 74.9 \\ TransMix \({}^{}\) & – & – & 1.01 & 75.1 \\ TokenMix \({}^{}\) & – & – & 0.87 & 75.3 \\ AlignMixup \({}^{}\) & 1.03 & 79.32 & – & – \\  MultiMix (ours) & 1.16 & 78.81 & 0.98 & 75.2 \\ Dense MultiMix (ours) & 0.95 & **79.42** & 0.88 & **76.1** \\  Gain & & +0.1 & +1.2 \\   

Table 3: _Image classification and training speed_ on ImageNet. Top-1 accuracy (%): higher is better. Speed: images/sec (\( 10^{3}\)): higher is better. \({}^{}\): reported by AlignMixup; \({}^{}\): reproduced. **Bold black**: best; Blue: second best; underline: best baseline. Gain: improvement over best baseline. Comparison with additional baselines is given in subsection A.2.

In Table 4 we observe that MultiMix is already more robust than SoTA on all datasets and settings. Dense MultiMix also increases the robustness and is complementary.

The overall gain is more impressive than in classification according to Table 2. For example, against the strong PGD attack on CIFAR-10 with W16-8, the SoTA Co-Mixup improves the baseline by 3.8% while Dense MultiMix improves it by 7.3%, which is double. MultiMix and Dense MultiMix outperform Co-Mixup and PuzzleMix by 3-6% in robustness on CIFAR-10, even though they are on-par on classification. There is also a significant gain over SoTA AlignMixup by 1-3% in robustness to FGSM on TinyImageNet and to the stronger PGD.

### Results: Transfer learning to object detection

We evaluate the effect of mixup on the generalization ability of a pre-trained network to object detection as a downstream task. Following the settings of CutMix , we pre-train R-50 on ImageNet with mixup methods and use it as the backbone for SSD  with fine-tuning on Pascal VOC07\(+\)12  and Faster-RCNN  with fine-tuning on MS-COCO .

In Table 5, we observe that, while MultiMix is slightly worse than AlignMixup on Pascal VOC07\(+\)12, Dense MultiMix brings improvements over the SoTA on both datasets and is still complementary. This is consistent with classification results. Dense MultiMix brings a gain of 0.8 mAP on Pascal VOC07\(+\)12 and 0.35 mAP on MS-COCO.

### Analysis of the embedding space

Qualitative analysisWe qualitatively analyze the embedding space on 10 CIFAR-100 classes in Figure 3. We observe that the quality of embeddings of the baseline is extremely poor with severely overlapping classes, which explains its poor performance on image classification. All mixup methods result in clearly better clustered and more uniformly spread classes. AlignMixup  yields five somewhat clustered classes and five moderately overlapping ones. Our best setting, _i.e_., Dense MultiMix, results in five tightly clustered classes and another five somewhat overlapping but less than all competitors.

Quantitative analysisWe also quantitatively assess the embedding space on the CIFAR-100 test set using alignment and uniformity . _Alignment_ measures the expected pairwise distance of examples in the same class. Lower alignment indicates that the classes are more tightly clustered. _Uniformity_ measures the (log of the) expected pairwise similarity of all examples using a Gaussian kernel as a similarity function. Lower uniformity indicates that classes are more uniformly spread in the embedding space.

Figure 3: _Embedding space visualization_ for 100 test examples per class of 10 randomly chosen classes of CIFAR-100 with PreActResnet-18, using UMAP .

   Dataset & VOC07\(+\)12 &  \\ Detector & SSD & Speed & FR-CNN & Speed \\  Baseline\({}^{}\) & 76.7 & 9.7 & 33.27 & 23.6 \\ Input mixup\({}^{}\) & 76.6 & 9.5 & 34.18 & 22.9 \\ CutMix\({}^{}\) & 77.6 & 9.4 & 35.16 & 23.2 \\ AlignMixup\({}^{}\) & 78.4 & 8.9 & 35.84 & 20.4 \\  MultiMix (ours) & 77.9 & 9.6 & 35.93 & 23.2 \\ Dense MultiMix (ours) & **79.2** & 8.8 & **36.19** & 19.8 \\  Gain &  &  \\   

Table 5: _Transfer learning_ to object detection. Mean average precision (mAP, %): higher is better. \({}^{}\): reported by AlignMixup. **Bold black**: best; Blue: second best; underline: best baseline. Gain: increase in mAP. Speed: images/sec: higher is better.

On CIFAR-100, we obtain alignment 3.02 for baseline, 2.04 for AlignMixup, 1.27 for MultiMix and 0.92 for Dense MultiMix. We also obtain uniformity -1.94 for the baseline, -2.38 for AlignMixup , -4.77 for MultiMix and -5.68 for Dense MultiMix. These results validate the qualitative analysis of Figure 3.

### Manifold intrusion analysis

Manifold intrusion  can occur when mixed examples are close to classes other than the ones being interpolated in the embedding space. To evaluate for manifold intrusion, we define the _intrusion distance_ (ID) as the minimum distance of a mixed embedding to the clean embeddings of all classes except the ones being interpolated, averaged over a mini-batch: \((,Z)=_{z}_{z Z} \|-z\|^{2}\). Here, \(\) is the set of mixed embeddings in a mini-batch and \(Z\) is the set of clean embeddings from all classes other than the ones being interpolated in the mini-batch. Intuitively, a larger \((,Z)\) denotes that mixed embeddings in \(\) are farther away from the manifold of other classes in \(Z\), thereby preventing manifold intrusion.

Averaged over the training set of CIFAR-100 using Resnet-18, the intrusion distance is 0.46 for Input Mixup, 0.47 for Manifold Mixup, 0.45 for AlignMixup, 0.46 for MultiMix and 0.47 for Dense MultiMix. This is roughly the same for most SoTA mixup methods. This may be due to the fact that true data occupy only a tiny fraction of the embedding space, thus generated mixed examples lie in empty space between class-specific manifolds with high probability. The visualization in Figure 3 indeed shows that the embedding space is sparsely populated, even in two dimensions. This sparsity is expected to grow exponentially in the number of dimensions, which is in the order of \(10^{3}\).

### Ablations

All ablations are performed using R-18 on CIFAR-100. We study the effect of the layer where we interpolate, the number \(n\) of generated examples per mini-batch, the number \(m\) of examples being interpolated and the Dirichlet parameter \(\). More ablations are given in the supplementary.

Interpolation layerFor MultiMix, we use the entire network as the encoder \(f_{}\) by default, except for the last fully-connected layer, which we use as classifier \(g_{W}\). Thus, we _interpolate embeddings_ in the deepest layer by default. Here, we study the effect of different decompositions of the network \(f=g_{W} f_{}\), such that interpolation takes place at a different layer. In Figure 4(a), we observe that mixing at the deeper layers of the network significantly improves performance. The same behavior is observed with Dense MultiMix, which validates our default choice.

It is interesting that the authors of input mixup  found that convex combinations of three or more examples in the input space with weights from the Dirichlet distribution do not bring further gain. This agrees with the finding of SuperMix  for four or more examples. Figure 4(a) suggests that further gain emerges when mixing in deeper layers.

Number \(n\) of generated examples per mini-batchThis is important since our aim is to increase the amount of data seen by the model, or at least part of the model. We observe from Figure 4(b) that accuracy increases overall with \(n\) and saturates for \(n 1000\) for both variants of MultiMix. The improvement is more pronnounced when \(m=2\), which is standard for most mixup methods.

Figure 4: _Ablation study_ on CIFAR-100 using R-18. (a) Interpolation layers (R-18 block; 0: input mixup). (b) Number \(n\) of interpolated examples per mini-batch with \(m=b\) (Default) and \(m=2\) (Standard). (c) Number \(m\) of examples being interpolated, with \(n=1000\) (Default) and \(n=100\) (Standard). (d) Fixed value of Dirichlet parameter \(\).

Our best solution, Dense MultiMix, works best at \(n=1000\) and \(n=10,000\). We choose \(n=1000\) as default, given also that the training cost increases with \(n\). The training speed as a function of \(n\) is given in the supplementary and is nearly constant for \(n 1000\).

Number \(m\) of examples being interpolatedWe vary \(m\) between \(2\) (pairs) and \(b=128\) (entire mini-batch) by using \(^{}^{m n}\) drawn from Dirichlet along with combinations (subsets) over the mini-batch to obtain \(^{b n}\) with \(m\) nonzero elements per column in (6),(7). We observe in Figure 4(c) that for both MultiMix and Dense MultiMix the performance increases with \(m\). The improvement is more pronnounced when \(n=100\), which is similar to the standard setting (\(n=b=128\)) of most mixup methods. Our choice of \(m=b=128\) brings an improvement of 1-1.8% over \(m=2\). We use this as our default setting.

Dirichlet parameter \(\)Our default setting is to draw \(\) uniformly at random from \([0.5,2]\) for every interpolation vector (column of \(\)). Here we study the effect of a fixed value of \(\). In Figure 4(d), we observe that the best accuracy comes with \(=1\) for most MultiMix variants, corresponding to the uniform distribution over the convex hull of the mini-batch embeddings. However, all measurements are lower than the default \( U[0.5,2]\). For example, from Table 2(a) (CIFAR-100, R-18), Dense MultiMix has accuracy 81.93, compared with 81.59 in Figure 4(d) for \(=1\).

## 5 Discussion

The take-home message of this work is that, instead of devising smarter and more complex interpolation functions in the input space or intermediate features, it is more beneficial to use MultiMix, even though its interpolation is only linear. In this work, we combine three elements:

1. Increase the number \(n\) of generated mixed examples beyond the mini-batch size \(b\).
2. Increase the number \(m\) of examples being interpolated from \(m=2\) (pairs) to \(m=b\).
3. Perform interpolation in the _embedding_ space rather than the input space.

Figure 4 shows that all three elements are important in achieving SoTA performance and removing any one leads to sub-optimal results. We discuss their significance and interdependence here.

Increasing the number \(n\) of generated examplesThe _expected risk_ is defined as an integral over the underlying continuous data distribution. Since that distribution is unknown, the integral is approximated by a finite sum, _i.e._, the _empirical risk_. A better approximation is the _vicinal risk_, where a number of augmented examples is sampled from a distribution in the vicinity of each training example, thus _increasing the number of loss terms per training example_. Input mixup  is inspired by the vicinal risk. However, as a practical implementation, all mixup methods still generate \(b\) mixed examples and thus incur \(b\) loss terms for a mini-batch of size \(b\). As discussed in section 2, previous works have used more loss terms than \(b\) per mini-batch, but not for mixup.

Our hypothesis for the significance of element 1 is that more mixed examples, thus more loss terms by interpolation, provide a better approximation of the expected risk integral. Dense interpolation further increases the number of loss terms, thus further improving the quality of approximation.

Increasing the number \(m\) of examples being interpolatedAs discussed in section 2, previous works, starting from input mixup  have attempted to interpolate \(m>2\) examples in the input space by sampling \(\) from Dirichlet or other distributions but have found the idea not effective for large \(m\). Our finding is that element 2 becomes effective only by interpolating in the embedding space, that is, element 3.

Interpolating in embedding spaceElement 3 is originally motivated by Manifold Mixup , where "interpolations in deeper hidden layers capture higher level information ." ACAI  explicitly studies interpolation in the latent space of an autoencoder to produce a smooth semantic warping effect in data space. This suggests that nearby points in the latent space are semantically similar, which in turn improves representation learning. Mixed examples generated by sampling in the embedding space lie on the learned manifold. We hypothesize that the learned manifold is a good surrogate of the true, unknown data manifold.

A natural extension of this work is to settings other than supervised classification. A limitation is that it is not straightforward to combine the sampling scheme of MultiMix with complex interpolation methods, unless they are fast to compute in the embedding space.

Acknowledgements

This work was in part supported by the ANR-19-CE23-0028 MEERQAT project and was performed using the HPC resources from GENCI-IDRIS Grant 2021 AD011012528.