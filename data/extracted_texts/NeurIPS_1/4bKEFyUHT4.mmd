# Convolutional Differentiable Logic Gate Networks

Felix Petersen

Stanford University

InftyLabs Research

mail@felix-petersen.de &Hilde Kuehne

Tuebingen AI Center

MIT-IBM Watson AI Lab

h.kuehne@uni-tuebingen.de &Christian Borgelt

University of Salzburg

christian@borgelt.net &Julian Welzel

InftyLabs Research

welzel@infytlabs.com &Stefano Ermon

Stanford University

ermon@cs.stanford.edu

###### Abstract

With the increasing inference cost of machine learning models, there is a growing interest in models with fast and efficient inference. Recently, an approach for learning logic gate networks directly via a differentiable relaxation was proposed. Logic gate networks are faster than conventional neural network approaches because their inference only requires logic gate operators such as NAND, OR, and XOR, which are the underlying building blocks of current hardware and can be efficiently executed. We build on this idea, extending it by deep logic gate tree convolutions, logical OR pooling, and residual initializations. This allows scaling logic gate networks up by over one order of magnitude and utilizing the paradigm of convolution. On CIFAR-10, we achieve an accuracy of 86.29% using only 61 million logic gates, which improves over the SOTA while being 29\(\) smaller.

## 1 Introduction

Deep learning has led to a variety of new applications, opportunities, and use-cases in machine vision. However, this advancement has come with considerable computational and energy costs for inference . Therefore, an array of methods has been developed for efficient deep learning inference . These include binary weight neural networks (BNNs) , a set of methods for quantizing neural network weights down to binary representations (and sometimes also binary activations); quantized low-precision neural networks , a superset of BNNs and sparse neural networks , a set of approaches for pruning neural networks and increasing sparsity. These methods have been successfully utilized for efficient vision model inference.

The state-of-the-art (SOTA) method for small architectures, deep differentiable logic gate networks (LGNs) , approaches efficient machine learning inference from a different direction: learning an LGN (i.e., a network of logic gates such as NAND and XOR) directly via a differentiable relaxation.

Figure 1: Gate count vs. accuracy plot on the CIFAR-10 data set. Our models (\(\)) are substantially above the Pareto-front of the SOTA baselines. Gate counts are proportional to chip area. Our models are more efficient than the SOTA by factors of \( 29\). Note that the \(x\)-axis (gate count) is on a log-scale.

Differentiable LGNs directly learn the combination of logic gates that have to be executed by the hardware. This differs from other approaches (like BNNs) that require translating an abstraction (like matrix multiplication-based neural networks) into executable logic for inference, an inductive bias that comes with a considerable computational burden. By optimizing the logic directly on the lowest possible level instead of optimizing an abstraction, differentiable LGNs lead to very efficient inference on logic gate-based hardware (e.g., CPU, GPU, FPGA, ASIC). Recently, differentiable LGNs achieved SOTA inference speeds on MNIST , . However, a crucial limitation was the random choice of connections, preventing LGNs from learning spatial relations, as they arise in images, which limited performance to an accuracy of only \(62\%\) on CIFAR-10 , . To address this limitation, we propose to extend differentiable LGNs to convolutions. Specifically, we propose deep logic gate tree convolutions, i.e., kernels comprised of logic gate trees applied in a convolutional fashion. Using trees of logic gates, instead of individual gates, increases the expressivity of the architecture while minimizing memory accesses, improving accuracy and accelerating training as well as inference. Further, we adapt pooling operations by representing them with logical _or_ gates (relaxed via the maximum t-conorm), improving the effectiveness of convolutions in LGNs. Additionally, we propose "residual initializations", a novel initialization scheme for differentiable LGNs that enables scaling them up to deeper networks by providing differentiable residual connections. These advances lead to an accuracy of \(86.29\%\) on CIFAR-10 using only \(61\) million logic gates, leading to cost reductions by \( 29\) compared to SOTAs as displayed in Figure 1.

## 2 Background

Our work builds on and extends differentiable logic gate networks . To recap, logic gate networks (LGNs) are networks of nodes that are binary logic gates like AND, NAND, or XOR. LGNs are also known as binary circuits or logical circuits, and are the format in which any digital hardware is implemented on the lowest pre-transistor abstraction level. The function that an LGN computes depends on the choices of logic gates that form its nodes and how these nodes are connected. Optimizing an LGN requires choosing the connections and deciding on a gate for each node. A primary challenge when optimizing LGNs is that they are, by default, non-differentiable, preventing gradient descent-based training, making this problem conventionally a combinatorial problem. However, when applied to machine learning problems, solving the combinatorial problem conventionally becomes infeasible as we require millions of parameters or gates. Thus, a differentiable relaxation of randomly connected LGNs has been proposed, which allows training LGNs with gradient descent , overcoming the exponential difficulty of optimizing LGNs. In the remainder of this section, we cover the structure, relaxation, and training of differentiable LGNs, which we also illustrate in Figure 2.

StructureLGNs follow a layered structure with each layer comprising a number of nodes, each comprising one logic gate (3 layers with 4 logic gates each in Fig. 2). As logic gates are inherently non-linear, LGNs do not require any activation functions. Further, LGNs do not have any weights nor any biases as they do not rely on matrix multiplications. Due to the binary (i.e., two-input) nature of the nodes, LGNs are necessarily sparse and cannot form fully-connected networks. The connectivity between nodes has so far been (fully) randomly selected, which works well for easier tasks but can become problematic if there is inherent structure in the data as, e.g., in images. During training, the connections remain fixed and the learning task comprises the choice of logic gate at each node.

Differentiable RelaxationTo learn the choices of logic gates for each node with gradient descent requires the network to be differentiable; however, the LGN is by default not differentiable for two reasons: (i) Because a logic gate computes a discrete function of its (Boolean) inputs, it is not differentiable. (ii) Because the choice of a logic gate is not a continuous parameter, but a discrete

Figure 2: Architecture of a randomly connected LGN. Each node corresponds to one logic gate. During training, the distribution over choices of logic gates (bottom, 16 options) is learned for each node.

decision, it is not differentiable. Petersen _et al._ propose to differentiably relax each logic gate to real-valued logic via probabilistic logic , . For example, a logical _and_ (\(a_{1} a_{2}\)) is relaxed to \(a_{1} a_{2}\) and a logical _exclusive or_ (\(a_{1} a_{2}\)) is relaxed to \(a_{1}+a_{2}-2 a_{1} a_{2}\), which corresponds to the output probability when considering two independent Bernoulli variables with coefficients \(a_{1},a_{2}\). To make the choice of logic gate learnable, Petersen _et al._ introduce a probability distribution over the 16 possible logic gates (\(\)), which is encoded as the softmax of 16 trainable parameters. For a trainable parameter vector \(^{16}\) and all 16 possible logic gate operations as \(g_{0},...,g_{15}\), the differentiable logic gate as the expectation over its outputs can be computed in closed-form as

\[f_{}(a_{1},a_{2})=_{i()\,,\,A_{1} (a_{1})\,,\,A_{2}(a_{2})}g_{i}(A_{1},A_{ 2})=_{i=0}^{15})}{_{j}(z_{j})} g_{i}(a _{1},a_{2})\,. \]

With these two ingredients, logic gate networks become end-to-end differentiable.

Initialization, Training, and DiscretizationTraining differentiable logic gate networks corresponds to learning the parameters inducing the probability distributions over possible gates. The parameter vector \(\) for each node has so far been initialized with a standard Gaussian distribution. The connections are randomly initialized and remain fixed during training. For classification tasks, each class is associated with a set of neurons in the output layer and active neurons in each set are counted composing a class score (group sum, right part of Fig. 2). After dividing them by a temperature \(\), the class scores are used as logits in a softmax cross-entropy loss. Differentiable LGNs perform best when trained with the Adam optimizer . Empirical evidence showed that the softmax distributions typically converge to concrete choices of logic gates. Thus, differentiable LGNs can be discretized to hard LGNs for deployment on hardware by selecting the logic gate with the largest probability. This discretization process incurs only a minimal loss in accuracy compared to the differentiable LGN .

LimitationsDifferentiable LGNs have shown significant limitations wrt. the available architectural components. Previously, they did not provide the option to capture local spatial patterns as they were randomly connected and only operated on flattened inputs . Further, they previously performed well only up to a depth of \(6\) layers . Thus, more complex relationships between inputs cannot be modeled. Finally, while they provide SOTA performance, differentiable LGNs are very computationally expensive to train, e.g., a vanilla 5 million gate network required 90 hours on an A6000 GPU . In the following, we address these limitations by introducing convolutional logic tree layers, logical or pooling, residual initializations, as well as computational considerations for scaling.

## 3 Convolutional Logic Gate Networks

Convolutional neural networks (CNNs) have experienced tremendous success, being a core contributor to the current machine learning ascendancy starting with their progress on the ImageNet classification challenge in 2012 . Underlying CNNs is the discrete convolution of an input tensor \(\) (e.g., an input image or hidden activations) and a linear function / kernel \(\), denoted as \(*\). CNNs are especially effective in vision tasks due to the equivariance of the convolution, which allows the network to generalize edge, texture, and shapes in different locations by sharing the parameters at all placements. However, existing differentiable LGN methods do not support convolutions.

In this work, we propose to convolve activations \(\) with differentiable binary logic gate trees. While we could convolve \(\) with an individual logic gate, we observe that actually convolving \(\) with a (deep) logic gate network or tree leads to substantially better performance as it allows for greater expressivity of the model. Similar to how the inputs to each logic gate are randomly initialized and remain fixed in conventional differentiable LGNs, we randomly construct the connections in our

Figure 3: Conventional convolutional neural networks (a) compared to convolutional logic gate networks (b). The images illustrate the first and second to last kernel placements. The nodes correspond to weighted sums (a), and binary logic gates \(f_{1},f_{2},f_{3}\) (b), respectively. The weights / choices of logic gates are shared between kernel placements. For visual simplicity, only a single input channel and kernel (output channel) is displayed.

logic gate tree kernel function. However, we need to put additional restrictions on the connections for logic gate network kernels. Specifically, we construct each logic gate network kernel as a complete binary tree of depth \(d\) with logic gates as nodes and binary input activations as leaves. The output of the logic gate operation is then the input to the next higher node, etc. To capture spatial patterns, we select the inputs / leaves of the tree from the predefined receptive field of the kernel of size \(s_{h} s_{w}\). Based on the depth of the tree, we randomly select as many inputs as necessary. For example, we could construct a binary tree of depth \(d=2\), which means that we need to randomly select \(2^{d}=4\) inputs from our receptive field, e.g., of size \(64 3 3\), which corresponds to \(64\) input channels with a kernel size of \(3 3\). This tree structure allows to capture fixed spatial patterns and correlations beyond pair-wise binary inputs. Further, it extends the concept of spatial equivariance to LGNs as such trees can be used as kernel filters, capturing general patterns in different locations. Using trees of logic gates instead of individual logic gates also has the advantage of reducing memory accesses and improving training and inference efficiency. We remark that, as we apply convolution, the parameterization of each node is shared between all placements of the kernel (which contrasts convolution from mere local connectivity.) In Figure 3, we illustrate the difference between conventional CNN models and convolutional logic gate networks.

During training, the network learns which logic gate operation to choose at each node. Thus, each logic tree kernel is parameterized via the choices of each of the \(2^{d}-1\) logic gates, which are learnable. For a logic kernel of depth \(2\), we call these logic gates \(f_{1},f_{2},f_{3}\) (or more formally \(f_{_{1}},f_{_{2}},f_{_{3}}\) for parameter vectors \(_{1},_{2},_{3}\) corresponding to Equation 1). Given input activations \(a_{1},a_{2},a_{3},a_{4}\), the kernel is expressed as a binary tree of these logic gates:

\[f_{3}(\,f_{1}(a_{1},a_{2}),f_{2}(a_{3},a_{4})\,). \]

For an input \(\) of shape \(m h w\) (\(m\) input channels; height; width) and connection index tensors \(_{M},_{H},_{W}\)1, each of shape \(n 4\) (\(n\) tree kernels / channels; \(4\) inputs per tree), the output is

\[^{}[k,i,j]=f_{3}^{k}f_{1}^{k} _{M}[k,\!1],_{H}[k,\!1]\!+\!i,_{W}[k,\!1]\!+\!j ,_{M}[k,\!2],_{H}[k,\!2]\!+\!i, _{W}[k,\!2]\!+\!j, \]

for \(k\{1,...,n\}\) where \(n\) is the number of tree kernels, \(i\{1,...,(h-s_{h}+1)\}\), and \(j\{1,...,(w-s_{w}+1)\}\) where \(s_{h} s_{w}\) is the receptive field size. Note that, in Equation 3, for each output channel \(k\) the logic gates \(f_{1}^{k},f_{2}^{k},f_{3}^{k}\) (or their relaxed form) are chosen and parameterized independently. Per convolution, all placements (indexed via \(i,j\)) of one kernel share their parameters.

After introducing convolutional LGNs, in the remainder of the section, we introduce our additional components, training strategies, and our architecture.

### Logical _Or_ Pooling

In CNNs, max-pooling is a crucial component selecting the largest possible activation over a predefined receptive field, e.g., for \(2 2\), \((a_{i,j},a_{i,j+1},a_{i+1,j},a_{i+1,j+1})\). To adopt this for logic, we propose to use the disjunction of the binary activations \(a_{i,j} a_{i,j+1} a_{i+1,j} a_{i+1,j+1}\) via the logical _or_. Instead of using a probabilistic relaxation of the logical _or_, we can use the maximum t-conorm relaxation of the logical _or_ (\(_{}(a,b)=(a,b)\)). By setting the stride of the pooling operation to the size of its receptive field, this has a range of crucial computational advantages: (i) it is faster to compute than the probabilistic relaxation; (ii) we only need to store the maximum activation and index; (iii) we only need to backpropagate through the maximum activations during training.

Intuitively, using many logical _or_s could lead to the outputs of the activations becoming predominantly \(1\). However, we find that, during training, this is not an issue as using _or_ pooling causes an

Figure 4: Plot of the density of activations for the second convolutional block of an _or_-pooling based convolutional LGN. It shows that training implicitly enforces that the outputs of the block have the activation level of a no-pooling network (i.e., with pure stride).

automatic reduction of pre-pooling activations, resolving this potential concern. This phenomenon is shown in Figure 4. Here, the average activation of a convolutional block of a logic network with \(2 2\) strided _or_ pooling is illustrated. For a random network without pooling, we expect and observe an average activation of 50% (dash-dotted). We observe that the post _or_ pooling activations (solid line) for the initialized models is 66.5%, which follows expectation. The pre _or_ pooling activations (dashed) are initialized at 50%, also following expectations. With training, the post _or_ pooling activations (solid) rapidly converge to the average activations of a network without pooling, preventing any problematic saturation of activations. We do not introduce any explicit regularization enforcing this behavior, but instead found this to be an emerging behavior of training.

### Residual Initialization

The parameters \(\) of existing differentiable LGNs were initialized as random draws from a Gaussian distribution. Unfortunately, after applying softmax, this leads to rather "washed out" probability distributions over choices of logic gates. Accordingly, the expected activations, as computed via Equation 1, are also washed out, quickly converging towards \(0.5\) in deeper networks. This also leads to vanishing gradients in existing differentiable LGNs: With Gaussian initialization, during backpropagation, the gradient norm decays at each logic gate by a factor between \(0.1\) and \(0.2\) for an initialized network, exponentially slowing training for deeper networks.

In CNNs, a technique for preventing vanishing gradients and preventing loss of information in deep networks are residual connections. Residual connections conventionally add the input to a block to the output of this block . However, when operating in logic, we cannot perform such additions.

To prevent the loss of information through washed out activations and reduce vanishing gradients with a joint strategy, we propose _residual initializations_. For this, we initialize each logic gate not randomly but instead to be primarily a feedforwarding logic gate. Here, we choose '\(A\)' as a canonical choice and choosing '\(B\)' would be equivalent. In our experiments, we found that initializing the probability for the logic gate choice '\(A\)' to around \(90\%\) and setting all other gates to \(0.67\%\) works well. This corresponds to setting the parameter \(z_{3}=5\) and all other \(z_{i}=0\) for \(i 3\) in accordance to Eq. 1. We illustrate an example of residual initializations compared to the existing Gaussian initializations in Figure 5.

Residual initializations prevent the loss of information as well as vanishing gradients in deeper networks. During training, whenever a residual connection is not required, the model learns to replace the feedforward logic gate choice by an actual operation. Thus, residual initializations are effectively a differentiable form of residual connections that does not require any hard-wiring. This also means that this form of residuals does not require additional logic gates for residuals. Residual initializations enable, for the first time, efficient and effective training of LGNs beyond 6 layers.

### Computational Training Considerations

Using trees and pooling allows for substantially improved computational training efficiency and memory requirement reductions. This is because it allows intermediate activations to be used only by the current logic gate tree and because we only need to backpropagate through the maximum activations during _or_ pooling. For example, using learnable trees with a depth of \(2\) and _or_ pooling with a kernel size and stride of \(2 2\) corresponds to a logic gate tree of depth \(2+2=4\) (2 levels are learnable + 2 from pooling) with \(16\) inputs and only a single output. For training, it is most efficient to discard all intermediate values and only store the output and information of which path through the pooling was selected, and during backward to recompute only this path, thereby reducing memory accesses. The reason for this is that training speed is limited by memory bandwidth and scalability is limited by GPU memory. On average, this strategy reduces memory accesses by 68% and reduces the memory footprint by 90% during training. For using LGNs in hardware designs, trees and pooling improve the locality of operations and routing, which also leads to more efficient chip layouts.

Figure 5: Gaussian initialization (a)  vs. our residual initialization (b).

The residual initializations provide a bias toward the feedforward logic gate in trained LGNs. As feedforward gates only require a wire and no transistors, this further reduces the necessary transistor count for hardware implementations of the LGNs, reducing the required chip area.

We developed efficient fully-fused low-level CUDA kernels, which, for the first time, enable training of convolutional LGNs. The speed of our convolutional layer is up to 200\(\) faster per logic gate than existing randomly connected LGN implementations . We will make the code publicly available by including it into the difflogic library at github.com/Felix-Petersen/difflogic.

### LogicTreeNet Architecture

In the following, we discuss the design of our convolutional logic gate tree network architectures (LogicTreeNet) for CIFAR-10, which we illustrate in Figure 6. We follow the pattern of conventional convolutional architectures and design the architecture by applying convolutional blocks with pooling at the end of each block. Each block reduces the size by a factor of \(2 2\) and we apply blocks until we reach a size of \(2 2\), increasing the number of channels in each stage. Following this, we apply three randomly connected layers and a group sum as our classification head. This architecture has an overall logical depth of \(23\) layers, including 4 convolutional blocks (Conv) with tree depths of \(d=3\), 4 _or_ pooling layers (or-Pool), and 3 randomly connected layers (Rand). \(15\) of these layers are trainable (Conv blocks and Rand), and the pooling layers remain fixed. The architecture is defined in terms of a hyperparameter k, which controls the width of the network; we consider k \(\{\)S \(\)\(32\), M \(\)\(256\), B \(\)\(512\), L \(\)\(1024\), G \(\)\(2\,048\)\(\}\). In Appendix A.1, we describe LogicTreeNet layer-by-layer and include a LogicTreeNet for MNIST.

An additional architecture choice is the connectivity for the inputs to a convolutional tree. While we rely on random choices for the inputs, we restrict the choices of channels (\(_{M}\)) such that each tree observes only 2 (rather than up to 8) input channels. This has the two advantages of enforcing spatial comparisons of values within one channel and is more efficient in hardware circuit designs. When creating hardware designs, for larger models, routing could become a problem due to congestion when connections between channels follow an arbitrary order. Thus, we restrict the connections between channels to ensure proper routing: we split the model into k\(/8\) groups, ensuring no cross-connections between the channels of each group. This restriction as well as similar hardware specific routing restrictions can be implemented without affecting the accuracy due to the sparsity of the logic gate network model.

### Input Processing

For our smaller CIFAR-10 models (S, M), we use 2 bit precision inputs, and encode them using 3 thresholds as in . For our larger CIFAR-10 models (B, L, G), we use 5 bit precision inputs, and process them with low-level feature detectors, in particular, we use edge and curvature detector kernels with thresholds, converting them into binary encodings, which are converted into LGNs and not learned. We note that the gates for the input preprocessing are included in each of the gate counts.

Figure 6: LogicTreeNet architecture. The logical architectures of the layers / blocks are illustrated on a per neuron basis. Circles indicate a logic gate that can be learned while the logical _or_s remain fixed. During training, for the trainable nodes, we use probabilistic relaxations of logic gates, which we parameterize via a softmax distribution over operators (Eq. 1/3). For the fixed logical _or_s, we use the continuous maximum t-conorm relaxation.

Related Work

Beyond differentiable LGNs ,  (covered in Section 2), the related work comprises truth table networks , , binary and quantized neural networks , , and sparse neural networks .

Lookup / Truth Table NetworksLookup table networks (aka. truth table networks) are networks comprised of lookup tables (LUTs) or equivalently (potentially complex) logic gates with \(n\) inputs.

There are different approaches for learning or constructing lookup table networks. Chatterjee  constructs truth table networks by "memorizing" training data in an explorative work to consider relations between memorization and generalization. Wang _et al._,  replace the multiplication in BNNs by lookup tables (LUTNet). Benamira _et al._ transform Heaviside step function activated CNNs into lookup tables by expressing the binary activation of each neuron via a lookup table that implicitly encodes the weight matrix (TTNet). This allows obtaining the binary activation of a neuron by "looking up" a value from the truth table at a location encoded via the binary inputs of the layer. Benamira _et al._ use this as an intermediate representation to then convert the truth tables into LGNs via CNF/DNF (conjunctive / disjunctive normal form) conversion. The resulting LGNs allow for efficient and effective formal verification. These resulting LGNs differ from the LGNs considered in this work because they are derived from a conventional CNN and not directly learned, thereby having the inductive bias of the neural network architecture (matmul) and its computational overhead, which is similar to BNNs converted into LGNs. Note that, while TTNets are LGNs, TTNets are not differentiable LGNs as there is no differentiable representation of the LGNs involved. Recently, Bacellar _et al._ extended differentiable LGNs to learning logic gates with more than two inputs.

Binary and Quantized Low-Precision NetworksBNNs and quantized neural networks reduce the precision of the weight matrices of a neural network. For example, BNNs typically use the weights \(-1\) and \(+1\), but variations are possible. For quantized neural networks, a popular choice is 8-bit and other options (such as 4-bit ) are covered in the literature. This leads to substantially reduced storage requirements of neural networks at the cost of some accuracy. Instead of naively quantizing weights, these approaches typically involve, e.g., quantization-aware fine-tuning . In addition, for some methods, BNNs and quantized neural networks also reduce the precision of the computations and activations, leading to speedups during inference , . These approaches typically start with a conventional pre-trained neural network and then convert it into a low-precision representation. BNNs are among the fastest approaches for efficient inference .

While BNNs (with binary activations, e.g., XNOR-Net ) are converted into LGNs for inference on hardware (e.g., on FPGAs ), the resulting architectures are fundamentally different from directly trained logic gate networks. BNNs have weight matrices and require multiply-accumulate (MAC) operations to express matrix multiplications. Asymptotically, each MAC requires 8 logic gates while at the same time (with only 2 possible states of the weight) this leads to a smaller expressivity compared to a single learned logic gate (with 16 possible states). We include a technical discussion in the appendix. While it is disadvantageous for inference, for training, BNNs have the advantage of operating on a higher abstraction level, simplifying training and allowing for translation between conventional neural networks and BNNs. We remark that BNNs with binary input activations and binary weight quantization frequently do not use binary output activations , which means that only the multiplications within a matrix multiplication are binary, while the remainder of the respective architectures can require floating precision. In contrast to BNNs, differentiable LGNs are not parameterized via weight matrices but instead via the choices of logic gates at each node .

Sparse Neural NetworksSparse neural networks are networks that are not densely connected but instead have only selected connections between layers , , . Conceptually, this means multiplying a weight matrix with a binary mask, setting a selection of weights to \(0\). Sparse nets can be utilized for efficient inference as the sparsity greatly reduces the number of floating-point operations that have to be executed. For an overview of sparse neural networks, we refer to Hoefler _et al._.

Due to the binary (i.e., two-input) nature of logic gates, logic gate networks are intrinsically sparse. Thus, LGNs can be seen as sparse networks; however, sparse neural networks are typically not LGNs and typically operate on real values instead of Boolean values. As differentiable LGNs use randomly initialized and fixed connections, it is perhaps important to mention that choosing randomly initialized and fixed connections has been shown to also work well for conventional sparse neural networks .

Experiments

### CIFAR-10

We train five sizes of LogicTreeNets on the CIFAR-10 data set  using the AdamW optimizer ,  with a batch size of \(128\) at a learning rate of \(0.02\). Additional training details and hyperparameters are in Appendix A.2. We report our main results in Table 1 and Figure 1. Our primary evaluation is with respect to the number of logic gates (bin. ops), which corresponds to the cost in hardware implementations and is proportional to transistor count chip area for ASICs or occupancy on FPGAs.

Comparing our model (M) with 3.08 M gates to the large TTNet model , we can observe that, while the accuracies are similar, our model requires only 1.6% of the number of logic gates. Increasing the model size, our model (B) matches the accuracy of FINN , while requiring only 16 M gates compared to 901 M gates, a \(56\) reduction. Considering an even larger variant of our model (L) with 28.9 M gates, we achieve 84.99%. The smallest baseline model that achieves comparable accuracy (84.95%) is LUTNet , which requires \(44.6\) as many logic gates. Finally, considering our largest model (G) with 61 M logic gates, we achieve \(86.29\%\) test accuracy. We match the accuracy of the Network-in-Network , XNOR-Net , while this baseline requires \(29\) as many gates. Indeed, all networks in the literature below 4 billion gates perform worse than our 61 million gate network.

After covering the performance of the trained models, we demonstrate their applicability in hardware designs on a Xilinx FPGA as a proof-of-concept. On CIFAR-10 we limit the hardware development up to the base model (B) due to labor cost. In Table 2, we report the results. We can observe a very favorable FPGA timing trade-off compared to previous works. Indeed, using our model (B) we achieve 80.17% accuracy, matching the accuracy of the FINN accelerator, but decreasing inference time from 45.6 \(\)s to 24 ns. In other words, our model achieves 41.6 million FPS, whereas the previously fastest FPGA model achieved 22 thousand FPS (even among all models with \(\)70%). Herein, the limitation preventing us from reaching around 500 million FPS is the transfer speed onto the FPGA. Here, the difference between the smaller models (S & M) and the larger model (B) is that (S & M) receive the input at 2 bit precision whereas (B) receives the input at 5 bit precision. We want to remark that substantially accelerated speeds or reduced power consumption could be achieved by manufacturing custom hardware such as ASICs; however, this lies outside the scope of this work and is an interesting future research direction.

We remark that all accuracies reported in the main paper are from discretized LGNs, and all gate counts maintain the full convolutional character (i.e., no location-based simplifications). In Appendix A.3, we provide additional gate count details. In Appendix A.4, we include a plot comparing the differentiable training mode accuracy to the discretized inference mode accuracy. Further, we refer to Figure 1 for a comparison of LogicTreeNet compared to the Pareto-front of the state-of-the-art.

  Method & Acc. & \# Gates \\  DiffLogic Net (medium)  & 57.39\% & 0.51 M \\ DiffLogic Net (largest)  & 62.14\% & 5.12 M \\  Conv. TTNet (small)  & 50.10\% & 0.57 M \\ Conv. TTNet (large)  & **70.75**\% & 189 M \\ FINN CNV  & **80.10**\% & 901 M \\ LUTNet  & **84.95**\% & 1 290 M \\ XNOR-Net  (NIN)  & **86.28**\% & 1 780 M \\ RebNet (1 residual)  & 80.59\% & 2 270 M \\ RebNet (2 residuals)  & 85.94\% & 2 830 M \\ BinaryNet  & 88.60\% & 4 090 M \\ Zhao et al.  & 88.54\% & 4 940 M \\ FBNA CNV  & 88.61\% & 5 540 M \\ Hirtzlin et al.  & 91. \% & 87 400 M \\  LogicTreeNet-S & **60.38**\% & 0.40 M \\ LogicTreeNet-M & **71.01**\% & 3.08 M \\ LogicTreeNet-B & **80.17**\% & 16.0 M \\ LogicTreeNet-L & **84.99**\% & 28.9 M \\ LogicTreeNet-G & **86.29**\% & 61.0 M \\  

Table 1: **Main results** for the CIFAR-10 experiments. Our LogicTreeNet models reduce the required numbers of logic gates by factors of \( 29\) compared to the state-of-the-art models. Our models are scaled to match accuracies.

  Method & Acc. & FPGA t. \\  FINN CNV  & 80.10\% & 45.6 \(\)s \\ RebNet (1 residual)  & 80.59\% & 167 \(\)s \\ RebNet (2 residuals)  & 85.94\% & 333 \(\)s \\ Zhao et al.  & 88.54\% & 5.94 ms \\ FBNA CNV  & 88.61\% & 1.92 ms \\ FracRNN  & 89.10\% & 356 \(\)s \\ TrueNorth  & 83.41\% & A: 801\(\)s \\  LogicTreeNet-S & 60.38\% & 9 ns \\ LogicTreeNet-M & 71.01\% & 9 ns \\ LogicTreeNet-B & 80.17\% & 24 ns \\  

Table 2: Timing results for CIFAR-10. The time is per image on an FPGA. We use a Xilinx VU13P FPGA. Our times are bottlenecked by the data transfer onto the FPGA. ‘A’ indicates the use of an ASIC.

### Mnist

We continue our evaluation on MNIST . Here, we use a slightly smaller model architecture with only 3 (instead of 4) convolutional blocks due to the input size of \(28 28\). Each convolutional block has a depth of \(3\) and, to maintain valid shapes, we use no padding in the first convolutional block. Each block increases the number of channels by a factor of 3. This network architecture is described in greater detail in Appendix A.1.2.

We display the results for MNIST in Table 3. Here, our models achieve a range of new SOTAs: compared to FINN , we can observe that our small model already improves the accuracy while simultaneously decreasing the model size by a factor of \(36\), and reducing inference time by a factor of \(160\). Our medium model, with \(99.23\%\) test accuracy improves over all BNNs in the literature. When comparing to Low-BitNN , a non-binary model, our medium model reduces the inference time by a factor of \(30\,000\) while still improving accuracy, increasing throughput from \(6\,600\) FPS to \(200\,000\,000\) FPS.

Within the, "one-classification-per-cycle" regime, comparing to LUTNet , we decrease the error from \(1.99\%\) to \(0.77\%\), and we note that the larger FPGA that LUTNet uses should enable placing LogicTreeNet-L (\(0.65\%\) error) multiple times, enabling multiple classifications per cycle.

Concluding, our MNIST models are both the most efficient models in the \( 98\%\) regime and at the same time also the highest accuracy FPGA models with an accuracy of up to \(99.35\%\).

VariancesFor small models like the small (S) model for MNIST, which has only 16 kernels in the first layer, variance due to the fixed connectivity can become a significant concern. Thus, for the small models we train multiple models simultaneously, and use a validation set of 10 000 images that we hold-out from the training set (not the test set), and based on which we select the final models. We present the variations before this selection between individual models in Table 4. We can see that with increasing model size, the variance decreases.

### Ablation Study

To demonstrate the importance of the provided architectural choices, we conduct an ablation study in Table 5. Here, we observe that using trees, residual initializations, as well as _or_ pooling are integral to the performance of convolutional LGNs. We also provide an ablation wrt. model depth.

Starting with the model depth ablation, in Table 5, we can observe that the performance improves with increasing model depth. We observe that decreasing the model depth is detrimental to performance. We note that shallower

   Model & Individual accs. \\  S & \(98.21\% 0.31\%\) \\ M & \(99.13\% 0.11\%\) \\ L & \(99.29\% 0.06\%\) \\   

Table 4: Variances between individual models on MNIST.

   Method & Acc. & \# Gates & FPGA t. \\  DiffLogic Net (small)  & 97.69\% & 48 K & — \\ DiffLogic Net (largest)  & 98.47\% & 384 K & — \\ DWN  & 98.77\% & — & 45 ns \\  TTNet (small)  & 97.23\% & 46 K & — \\ TTNet  & 98.02\% & 360 K & — \\ LUTNet  & 98.01\% & — & 5 ns \\ FINN CNV  & 98.40\% & 5.28 M & 641 ns \\ FINN FCN  & 98.86\% & 258 M & — \\ LowBitNN  & 99.2 \% & — & 152 \(\)s \\ FPGA-NHAP  & 97.81\% & — & 4.9 ms \\  LogicTreeNet-S & 98.46\% & 147 K & 4 ns \\ LogicTreeNet-M & 99.23\% & 566 K & 5 ns \\ LogicTreeNet-L & 99.35\% & 1.27 M & — \\   

Table 3: Results of the MNIST experiment. We use a Xilinx XC7Z045 FPGA, the same device as FINN CNV. All other baselines utilize equivalent or more powerful FPGAs.

models do not directly correspond to reductions in gate counts because, for deeper models, the rates of trivial gate choices like '\(A\)' that are removed during logic synthesis is significantly higher.

Next, we consider the omission of _or_ pooling. We can observe that the accuracy drops by \(3.5\%\) when removing _or_ pooling, demonstrating its importance. Setting weight decay to \(0\) causes a small reduction in accuracy by \(1\%\). Allowing each tree to use 8 channels as the input, rather than just 2, reduces the accuracy (\(1.4\%\)) because it is better to enforce the ability to perform comparisons within one channel at different \(x,y\) locations in the kernel. However, the more important effect of using only 2 input channels is the resulting improved routing in hardware design layouts.

Finally, we ablate the proposed residual initializations. We can observe in the table that the accuracy drops by almost \(9\%\) without residual initializations. This means the that the Gaussian initializations are almost unusable for such deep networks. In Figure 7, we display the test accuracy during training and observe that, without our residual initializations, training does not converge and is quite unstable.

We further ablate the effect of residual initialization on the distribution of gates in Figure 8. Here, we can observe that residual initializations not only stabilize training, but also lead to the favorable inductive bias of many gates being '\(A\)', which is automatically reduced during logic simplification.

## 6 Conclusion

In this paper, we introduced convolutional differentiable logic gate networks with logic gate tree kernels, integrating a range of concepts from machine vision into differentiable logic gate networks. In particular, we introduced residual initializations, which not only reduces loss of information in deeper networks, but also prevents vanishing gradients, enabling training of deeper LGNs than previously possible. Further, we introduced logical _or_ pooling, which, combined with logic tree kernels, substantially improved training efficiency. Our proposed CIFAR-10 architecture, LogicTreeNet, decreases model sizes by factors of \( 29\) compared to the SOTA while improving accuracy. Further, our inference stack demonstrates that convolutional LGNs can be efficiently executed on hardware. For example, on MNIST, our model improves accuracy while achieving \(160\) faster inference speed, and on CIFAR-10, our model improves inference speed by \(1900\) over the state-of-the-art. An interesting direction for future research is applying convolutional differentiable logic gate networks to computer vision tasks with continuous decisions like object localization. We hope that our results motivate the community to adopt convolutional differentiable LGNs, especially for embedded and real-time applications where inference cost and speed matter most.