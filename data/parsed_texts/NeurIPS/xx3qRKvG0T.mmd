# BasisFormer: Attention-based Time Series Forecasting with Learnable and Interpretable Basis

 Zelin Ni

Shanghai Jiao Tong University

Shanghai, China

nzl5116190@sjtu.edu.cn

&Hang Yu1

Ant Group

Hangzhou, China

hyu.hugo@antgroup.com

&Shizhan Liu

Shanghai Jiao Tong University

Shanghai, China

shanluzuode@sjtu.edu.cn

&Jianguo Li2

Ant Group

Hangzhou, China

lijg.zero@antgroup.com

&Weiyao Lin2

Shanghai Jiao Tong University

Shanghai, China

wylin@sjtu.edu.cn

Equal contribution. This work was done when Zelin Ni was a research intern at Ant Group.Corresponding authors.

Footnote 2: footnotemark:

###### Abstract

Bases have become an integral part of modern deep learning-based models for time series forecasting due to their ability to act as feature extractors or future references. To be effective, a basis must be tailored to the specific set of time series data and exhibit distinct correlation with each time series within the set. However, current state-of-the-art methods are limited in their ability to satisfy both of these requirements simultaneously. To address this challenge, we propose BasisFormer, an end-to-end time series forecasting architecture that leverages learnable and interpretable bases. This architecture comprises three components: First, we acquire bases through adaptive self-supervised learning, which treats the historical and future sections of the time series as two distinct views and employs contrastive learning. Next, we design a Coef module that calculates the similarity coefficients between the time series and bases in the historical view via bidirectional cross-attention. Finally, we present a Forecast module that selects and consolidates the bases in the future view based on the similarity coefficients, resulting in accurate future predictions. Through extensive experiments on six datasets, we demonstrate that BasisFormer outperforms previous state-of-the-art methods by 11.04% and 15.78% respectively for univariate and multivariate forecasting tasks. Code is available at: https://github.com/nzl5116190/Basisformer.

## 1 Introduction

Bases, such as trends and seasonalities, are indispensable for time series modeling and forecasting, since they capture the underlying temporal patterns and serve as the key factors driving changes in the data over time. For example, seasonalities can capture the regular fluctuations in demand for a product or a service, while trends can reflect the long-term growth or decline of a market or industry. Incorporating these bases into time series models can improve the understanding and prediction of future behaviors. Indeed, all commonly used deep learning models for time series forecasting can be reimagaged as basis-driving models. N-BEATS [1], N-HiTS [2], and FiLM [3] all resort to explicit bases, such as Fourier and Legendre basis. More generally, the linear (or convolution) layers in MLPs [4] (or CNNs [5]) can be regarded as implicit bases, as they act as filter banks to decompose the time series. In addition, the covariate embedding (a.k.a. global timestamp embedding) in RNNs [6]and Transformers [7; 8; 9; 10; 11; 12; 13] is another form of basis, since they provide reference points for predicting future sequences.

To apply bases for time series forecasting, three steps are required. First and foremost, an appropriate basis should be chosen or learned for the set of time series at hand. In practice, the full space of the basis can often be very large, whereas the patterns of the time series in a set are often similar. It is therefore desirable to learn a basis that is tailored to the specific characteristics (e.g., periods or frequencies) of the time series data. This can help reduce the complexity of the forecasting model, as well as make it more accurate and interpretable. Second, each time series in the set is decomposed according to the basis. This involves computing coefficients or weights that determine the similarity or projection energy of the time series w.r.t. (with respect to) each vector (i.e., filter) in the basis. Note that these coefficients are supposed to vary across different time series, since each time series also exhibits unique patterns and characteristics. For instance, the Fourier coefficients corresponding to different time series will be dissimilar. Finally, the prediction is determined by the weighted aggregation of the future part of the basis.

Unfortunately, the aforementioned state-of-the-art methods fall short in satisfying the requirements in the first two steps simultaneously. On one hand, methods relying on classical bases, such as N-BEATS [1], N-HiTS [2], and FiLM [3], often assume that the basis is not learnable and instead learn the coefficients of each time series in a flexible manner when projecting to the basis. However, such a basis may not effectively account for temporal patterns since there is no guarantee that the given basis includes all periods or frequencies corresponding to the set of time series. On the other hand, approaches that aim to adaptively learn the basis from data, such as MLP [4], CNN [5], RNN [6], Transformer and their variants [7; 8; 9; 10; 11; 12; 13], often overlook the need for flexible associations between the basis and each individual time series. Specifically, although Transformer and its variants learn the covariate embeddings, they add or concatenate the same embeddings to different time series embedding in a restricted manner. For MLP and CNN, they adopt the same linear and convolution layers for all time series.

To effectively tackle the aforementioned quandary, it is imperative to obtain a basis that can accurately reflect the distinct traits of the dataset, and to devise a predictive network that can selectively utilize relevant vectors in the basis for forecasting purposes. To move forward to this goal, we propose BasisFormer, a time series forecasting architecture with learnable and interpretable basis. As a first step, we acquire the basis through adaptive self-supervised learning from the data. This involves treating the historical and future sections of a time series as two distinct views and employing contrastive learning to learn the basis, assuming that the selection of basis for a time series should be consistent across both views. Subsequently, we design the Coef module that measures the similarity between the time series and the basis in the historical view via bidirectional cross-attention, facilitating the flexible association between individual time series and the basis. Finally, we develop a Forecast module that consolidates vectors from the basis in the future view according to the similarity yielded by the Coef module, leading to accurate future predictions. We emphasize that the above three parts are trained in an end-to-end fashion. In summary, the key contributions of our work comprise:

* We propose a self-supervised method for basis learning by treating the historical and future sections of the time series as two distinct views and employing contrastive learning, which ensures that the selection of basis for a time series is consistent across both views.
* We design the Coef and Forecast module that chooses and merges relevant basis in the future view based on the coefficients that measure the similarity between the time series and the basis in the historical view.
* We conduct extensive experiments on six datasets, and find that our model outperforms previous SOTA methods by 11.04% for univariate forecasting tasks and 15.78% for multivariate forecasting tasks.

## 2 Related works

**Time series forecasting models** In recent years, deep learning methods have emerged as the predominant technique for time series forecasting. As illustrated in the introduction, these deep learning methods typically resort to bases to facilitate the prediction of the future. Depending on the types of bases used in the network, forecasting models fall into two categories: those using classical orthogonal bases and those using learnable bases. The first group involves N-BEATS [1], N-HiTS [2], and FiLM [3]. N-BEATS and N-HiTs typically utilize the Fourier basis and then learn the coefficientsfor this basis in a recursive network such that the basis helps decompose the historical part of the time series into different components and these components can be further aggregated to predict the future. FiLM approximates the historical part via the Legendre polynomial basis and further removes the noise with the help of the Fourier basis. The major drawback with the group of methods is that the basis is predefined, thus giving rise to the problem of which type of basis to choose (e.g., Fourier or Legendre polynomial) and further which vectors in the basis to choose (e.g., which frequency components we choose from the Fourier basis). On the other hand, the models based on learnable bases, such as Dlinear [4], TCN [5], Deepar [6], LogTrans [11], Informer [7], AutoFormer [8], FedFormer [9], etc, use a learnable linear or convolution layer, or covariate embeddings as the basis. Although these bases are adaptable to the time series, the relationship between the basis and the time series is fixed for all time series. For example, the covariate embedding is added or concatenated to the embedding of different time series in the same way, without considering the unique frequencies and periodic patterns of each series. In our paper, we propose a method that allows for both a learnable basis and a flexible correlation between the basis and each time series for more accurate predictions.

**Basis learning for time series analysis** Apart from time series forecasting, learnable bases have also been explored for other time series-related tasks, such as time series classification. Note that basis learning is distinct from the representation learning of time series, as the former aims to capture the pattern of a set of time series using a common basis, while the latter aims to extract features from individual time series. Moreover, the basis can help extract features from time series as in Dlinear [4] and TCN [5]. Traditionally, a non-learnable basis is exploited, such as Fourier and wavelet basis. However, there exist a handful of works that overcome this limitation and enable the use learnable basis. The learnable group transform [14] generalizes the filter banks in the wavelet transformer and allows nonlinear transformation from the mother wavelet to obtain flexible filter banks that can better extract features from time series. Along this direction, Balestriero _et al._[15] propose a learnable Gaussian filter over the Wigner-Ville transform with a few interpretable parameters, and prove that the resulting filter banks can interpolate between classical ones, including Fourier, wavelet, and chirplet basis. Similar works have also been proposed for audio signal processing [16; 17], suggesting that a learnable basis is a more effective feature extractor than a fixed basis. Thus, we utilize a learnable basis in our work and demonstrate its usefulness for time series forecasting. It should be noted that DEPTS [18] tackles the challenges posed by intricate dependencies and multiple periodicities in periodic time series through the implementation of a deep expansion learning framework. However, the complex initialization and optimization strategies employed by DEPTS, as well as its limitation of only being applicable to periodic sequences, have motivated us to develop a simpler and more universally applicable basis learning framework. Concretely, we propose a novel method for basis learning based on self-supervised contrastive learning.

**Self-supervised time series representation learning** Since we employ self-supervised representation learning techniques to learn the basis, it is necessary to examine related works in this domain. One prevalent method in this field is the contrastive predictive coding (CPC) [19] which implements contrastive learning to obtain time series representations by treating subsequent future time series as positive samples and random non-subsequent future time series as negative samples. Another method, TS-TCC [20], augments the data with two types of perturbations to obtain two views and performs a cross-view prediction task contrastively, similar to CPC. As an alternative, TS2VEC [21] generates positive samples via timestamp masking or random cropping without leveraging the future information. Note that all these methods seek to establish a common representation for a time series from various views. Unlike these approaches, our goal is to preserve the consistency of the relationship between the time series and the basis. In other words, while the representation of the time series in the historical and future view may differ, their relationships with the corresponding basis should remain consistent.

## 3 BasisFormer

Suppose we have a collection of time series with a dimension of \(C\), implying that \(C\) correlated time series require simultaneous prediction. Each time series in this set is characterized by its history \(\bm{x}=(x_{1},\cdots,x_{I})\) and future \(\bm{y}=(y_{1},\cdots,y_{O})\), where \(I\) and \(O\) correspond to the input and output sequence lengths, respectively. Our primary objective is to learn a basis \(\bm{z}\) that can account for the behavior of all time series in the group, and further exploit it for predicting \(\bm{y}\) given \(\bm{x}\). Correspondingly, \(\bm{z}\) can also be split into the historical component \(\bm{z}_{x}\) and the future component \(\bm{z}_{y}\).

[MISSING_PAGE_EMPTY:4]

Correspondingly, given \(C\) time series \(\bm{x}\in\mathbb{R}^{C\times I}\) and the basis \(\bm{z}_{x}\in\mathbb{R}^{N\times I}\) of size \(N\), we can get their representations by stacking \(M\) layers of \(\mathrm{BCAB}_{H}\), namely, \(\bm{x}^{(M)}\in\mathbb{R}^{C\times D_{c}\times H}\) and \(\bm{z}_{x}^{(M)}\in\mathbb{R}^{N\times D_{c}\times H}\), where \(D_{c}\) represents the hidden dimension for each head in \(\mathrm{BCAB}_{H}\). Note that the cross attention is computed between the time series and the basis, instead of across time which is frequently found in Transformer based models [7; 13]. Additionally, the attention mechanism is used to allow for flexible associations between the time series and basis vectors. This approach ensures that each time series can selectively attend to the most relevant basis vectors, and likewise, each basis vector can selectively attend to the most relevant time series.

Finally, the Coef module calculates the "coefficient" of each time series w.r.t. each basis vector as the inner product of their representations \(x^{(M)}\) and \(z_{x}^{(M)}\) for each of the \(H\) heads, resulting in the coefficient tensor \(\bm{c}\in R^{C\times N\times H}\).

### Forecast module for aggregation and future prediction

After obtaining the coefficients, we take advantage of them for the sake of forecasting. We begin by projecting the future part of the basis vectors \(\bm{z}_{y}\) into a space where they can be linearly aggregated using the coefficients. As the Coef module computes the coefficients for \(H\) heads, the projection of \(\bm{z}_{y}\) should also have \(H\) heads to maintain consistency. To this end, we employ a four-layer Multi-Layer Perceptron (MLP) with a bottleneck to map \(\bm{z}_{y}\in\mathbb{R}^{N\times O}\) to \(\bm{\hat{z}}_{y}\in\mathbb{R}^{N\times O}\), which is then split into \(H\) heads, each with size \(N\times(O/H)\), and is denoted as \(\bm{\tilde{z}}_{y}\in\mathbb{R}^{N\times H\times(O/H)}\).

For each head, we aggregate the \(N\) basis vectors by computing the coefficients weighted sum of \(\bm{\tilde{z}}_{y}\) over the dimension of \(N\), that is,

\[\bm{\tilde{y}}[i,h]=\sum_{j=1}^{N}\bm{c}[i,j,h]\bm{\tilde{z}}_{y}[j,h,:],\] (5)

where \(h\in\{1,\cdots,H\}\) denotes the head index, and the size of \(\bm{\tilde{y}}\) is \(C\times H\times(O/H)\).

Next, we concatenate the \(H\) heads together and pass them through another four-layer MLP with a bottleneck, in order to exchange information between different heads. This is because different heads may have captured different aspects of the input sequence and the fusion MLP can help combine the information and improve the overall prediction performance.

It is noteworthy that the bottleneck layers in the above module are used to reduce the dimensionality of the input features before projecting them to a higher-dimensional space. This helps to reduce the computational complexity of the projection operation and prevent overfitting. Additionally, using a bottleneck layer can also assist in extracting more informative features by forcing the model to learn a compressed representation of the input, thus improving the prediction accuracy.

Finally, we compare the predicted values \(\bm{\hat{y}}\) with the true values \(\bm{y}\) via a Mean Squared Error (MSE) loss function, that is, \(L_{\text{pred}}=\mathrm{MSE}(\bm{\hat{y}},\bm{y})\).

### Basis module for basis learning

In this subsection, we present our approach for learning a data-driven basis in a self-supervised manner. The goal is to obtain a basis that satisfies three essential properties.

First, the relation between the basis vectors and the time series should be consistent across time, such that we can predict the future by combining the future part of the basis using the coefficients obtained from the historical part of the basis and the time series. Specifically, given a time series \((\bm{x},\bm{y})\) and the corresponding basis \((\bm{z}_{x},\bm{z}_{y})\), the coefficients (i.e., edge strength) between the time series and the basis should be consistent across the historical view \((\bm{x},\bm{z}_{x})\) and the future view \((\bm{y},\bm{z}_{y})\). In other words, the relevance of a given time series to a particular basis vector in the historical view should be retained in the future view. To achieve this, we pass both \((\bm{x},\bm{z}_{x})\) and \((\bm{y},\bm{z}_{y})\) through the Coef module to get the coefficient tensor respectively for the two views, \(\bm{c}_{x}\) and \(\bm{c}_{y}\), both with size \(C\times N\times H\). For each time series, we then perform contrastive learning by regarding the coefficient w.r.t. each basis vector in \(\bm{c}_{x}\) as the anchor point, the coefficient w.r.t. the corresponding basis vector in \(\bm{c}_{y}\) as the positive sample, and the coefficient w.r.t. the remaining basis vectors in \(\bm{c}_{y}\) as the negative sample. We optimize the InfoNCE loss to maximize the mutual information between \(\bm{c}_{x}\) and \(\bm{c}_{y}\)which is given by

\[L_{\text{align}}=-\frac{1}{CN}\sum_{i=1}^{C}\sum_{j=1}^{N}\log\frac{\exp( \bm{c}_{x}[i,j,:]\cdot\bm{c}_{y}[i,j,:]/\epsilon)}{\sum_{k=1}^{N}\exp(\bm{c}_{x} [i,j,:]\cdot\bm{c}_{y}[i,k,:]/\epsilon)}.\] (6)

where \(\epsilon\) represents the temperature used to adjust the smoothness of alignment distribution.

In addition, we require the basis to be interpretable, which means that we can gain insights into the underlying patterns captured by the basis. To achieve interpretability, we promote smoothness across time with a regularization term, that is,

\[L_{\text{smooth}}=\|\bm{z}\bm{S}\|_{2}^{2},\] (7)

where we concatenate the basis vectors for the historical and future views \((\bm{z}_{x},\bm{z}_{y})\) along the last dimension to form \(\bm{z}\), and the smoothness matrix \(\bm{S}\in\mathbb{R}^{(I+O)\times(I+O-2)}\) can be expressed as:

\[\bm{S}=\begin{bmatrix}1&-2&1&&\\ &\ddots&\ddots&\ddots&\\ &&1&-2&1\end{bmatrix}.\] (8)

It is apparent by multiplying \(\bm{z}\) with \(\bm{S}\), we compute \(\|\bm{z}[:,t-1]-2\bm{z}[:,t]+\bm{z}[:,t+1]\|_{2}^{2}\), which is the curvature over time [23]. One advantage of using \(\bm{S}\) is that the addition of a constant and a linear function of time makes the loss invariant. Therefore, the above smoothness loss can accommodate the change of the overall mean level as well as the linear trend.

Finally, the basis should be a function of the timestamp. As such, we develop a four-layer MLP with a skip connection between the input and the output of the second layer. The input to the network is the normalized timestamp associated with the first time point in the historical window. Suppose that the overall length of a time series in the dataset is \(T\), then the normalized timestamp is defined as \(\tau=t/T\), where \(t\in\{0,\cdots,T-1\}\). The output of the networks is an \(N\times(I+O)\) tensor, which is the basis for the current time window.

Overall, the loss we optimize can be expressed as:

\[L=L_{\text{pred}}+L_{\text{align}}+L_{\text{smooth}}.\] (9)

We find that the performance of BasisFormer is robust to the weights in front of the terms in (9). Therefore, we set the weights to be one in all our experiments. Sensitivity analysis of the weights in the loss function can be found in the Appendix A.4.

## 4 Experiments

To assess the effectiveness of our model, we conducted comprehensive experiments on six datasets from real-world scenarios, using the experimental setup identical to that in [5; 7; 8; 9]. Below we summarize the experimental setup, datasets, models, and compared models.

**Experimental setup**: The length of the historical input sequence is maintained at 96 (or 36 for the illness dataset), whereas the length of the sequence to be predicted is selected from a range of values, i.e., \(\{96,192,336,720\}\) (\(\{24,36,48,60\}\) for the illness dataset). Note that the input length is fixed to be 96 for all methods for a fair comparison.

**Datasets**: The six datasets used in this study comprise the following: 1) ETT [7], which consists of temperature data of electricity transformers; 2) Electricity, which includes power consumption data of several customers; 3) Exchange [24], containing financial exchange rate within a specific time range; 4) Traffic, comprising data related to road traffic; 5) Weather, which involves various weather indicators; and 6) Illness, consisting of recorded influenza-like illness data. Note that ETT is further divided into four sub-datasets: ETTh1, ETTh2, ETTm1, and ETTm2, and the results in Table 1 are based only on the ETTm2 sub-dataset. The results for the remaining three sub-datasets can be found in the Appendix.

**Models for comparison**: In this study, we compare our proposed model against the following state-of-the-art models: four transformer-based models, namely FEDformer [9], Autoformer [8], Pyraformer [13]; one MLP-based model, i.e., Dlinear [4]; and one CNN-based model, i.e., TCN [5]. We also consider two recently proposed models, e.g., N-Hits [2] and FiLM [3]. Due to space 

[MISSING_PAGE_FAIL:7]

[MISSING_PAGE_FAIL:8]

[MISSING_PAGE_FAIL:9]

follows this periodic pattern and effectively capture the salient features of the data. Secondly, the basis vectors given by our approach are smooth, indicating that they are not corrupted by the noise in the data. Note that the noise is not predictable, and so the basis that drives the change in the future is preferred to be smooth. Thirdly, it is evident that the learned bases have varying heights and intervals, thereby providing diversity to characterize different features of the time series. Finally, the obtained bases are consistent from both past and future perspectives, thus facilitating the prediction of future trends based on the coefficient similarity between a time series and the basis in the historical part. More visualized results can be found in the Appendix E.

## 5 Conclusion

This paper presents BasisFormer, a novel solution to alleviate two significant limitations that impede the efficacy of the existing SOTA methods. Through the utilization of BasisFormer, automatic learning of a self-adjusting basis can be achieved. Moreover, given the learned basis, BasisFormer also allows different time series to be correlated with distinct subsets of basis vectors. Our experimental findings provide compelling evidence of the superiority of BasisFormer over existing methods.

## 6 Acknowledgements

The paper is supported in part by the following grants: National Key Research and Development Program of China Grant (No.2018AAA0100400), National Natural Science Foundation of China (No. 62325109, U21B2013, 61971277).

\begin{table}
\begin{tabular}{c|c c c c|c c c} \hline \hline baseline & \multicolumn{4}{c|}{Fedformer} & \multicolumn{4}{c}{Autoformer} \\ \hline comparison & \multicolumn{2}{c|}{origin} & \multicolumn{2}{c|}{(+)coef module} & \multicolumn{2}{c|}{origin} & \multicolumn{2}{c}{(+)coef module} \\ \hline metric & MSE & MAE & MSE & MAE & MSE & MAE & MSE & MAE \\
96 & 0.193 & 0.308 & **0.183** & **0.301** & 0.201 & 0.317 & **0.193** & **0.305** \\
192 & 0.201 & 0.315 & **0.196** & **0.312** & 0.222 & 0.334 & **0.200** & **0.312** \\
336 & 0.214 & 0.329 & **0.209** & **0.324** & 0.231 & 0.338 & **0.211** & **0.325** \\
720 & 0.246 & 0.355 & **0.229** & **0.340** & 0.254 & 0.361 & **0.252** & **0.359** \\ avg & 0.214 & 0.327 & **0.204** & **0.319** & 0.227 & 0.338 & **0.214** & **0.325** \\ \hline \hline \end{tabular}
\end{table}
Table 7: The performance comparison of the self-supervised module used in Transformer-based models. The ’origin’ represents no modifications made to the original model and the ‘(+)coef module’ represents applying our designed self-supervised network to supervise the covariate in the models. The dataset used in this experiment was Electricity. The best results are marked in bold.

Figure 3: The visualization of time series and learned basis on the Traffic dataset: The solid line indicates the historical series and the dashed line indicates the future series. For this visualization, we set the input length \(I\) to 96 and the output length \(O\) to 96.

## References

* [1] Boris N Oreshkin, Dmitri Carpov, Nicolas Chapados, and Yoshua Bengio. N-beats: Neural basis expansion analysis for interpretable time series forecasting. _arXiv preprint arXiv:1905.10437_, 2019.
* [2] Cristian Challu, Kin G Olivares, Boris N Oreshkin, Federico Garza, Max Mergenthaler, and Artur Dubrawski. N-hits: Neural hierarchical interpolation for time series forecasting. _arXiv preprint arXiv:2201.12886_, 2022.
* [3] Tian Zhou, Ziqing Ma, Qingsong Wen, Liang Sun, Tao Yao, Wotao Yin, Rong Jin, et al. Film: Frequency improved legendre memory model for long-term time series forecasting. _Advances in Neural Information Processing Systems_, 35:12677-12690, 2022.
* [4] Ailing Zeng, Muxi Chen, Lei Zhang, and Qiang Xu. Are transformers effective for time series forecasting? _arXiv preprint arXiv:2205.13504_, 2022.
* [5] Shaojie Bai, J Zico Kolter, and Vladlen Koltun. An empirical evaluation of generic convolutional and recurrent networks for sequence modeling. _arXiv preprint arXiv:1803.01271_, 2018.
* [6] David Salinas, Valentin Flunkert, Jan Gasthaus, and Tim Januschowski. Deepar: Probabilistic forecasting with autoregressive recurrent networks. _International Journal of Forecasting_, 36(3):1181-1191, 2020.
* [7] Haoyi Zhou, Shanghang Zhang, Jieqi Peng, Shuai Zhang, Jianxin Li, Hui Xiong, and Wancai Zhang. Informer: Beyond efficient transformer for long sequence time-series forecasting. In _Proceedings of the AAAI Conference on Artificial Intelligence_, volume 35, pages 11106-11115, 2021.
* [8] Haixu Wu, Jiehui Xu, Jianmin Wang, and Mingsheng Long. Autoformer: Decomposition transformers with auto-correlation for long-term series forecasting. _Advances in Neural Information Processing Systems_, 34:22419-22430, 2021.
* [9] Tian Zhou, Ziqing Ma, Qingsong Wen, Xue Wang, Liang Sun, and Rong Jin. Fedformer: Frequency enhanced decomposed transformer for long-term series forecasting. _arXiv preprint arXiv:2201.12740_, 2022.
* [10] Yong Liu, Haixu Wu, Jianmin Wang, and Mingsheng Long. Non-stationary transformers: Rethinking the stationarity in time series forecasting. _arXiv preprint arXiv:2205.14415_, 2022.
* [11] Shiyang Li, Xiaoyong Jin, Yao Xuan, Xiyou Zhou, Wenhu Chen, Yu-Xiang Wang, and Xifeng Yan. Enhancing the locality and breaking the memory bottleneck of transformer on time series forecasting. _Advances in neural information processing systems_, 32, 2019.
* [12] Nikita Kitaev, Lukasz Kaiser, and Anselm Levskaya. Reformer: The efficient transformer. _arXiv preprint arXiv:2001.04451_, 2020.
* [13] Shizhan Liu, Hang Yu, Cong Liao, Jianguo Li, Weiyao Lin, Alex X Liu, and Schahram Dustdar. Pyraformer: Low-complexity pyramidal attention for long-range time series modeling and forecasting. In _International Conference on Learning Representations_, 2021.
* [14] Romain Cosentino and Behnaam Aazhang. Learnable group transform for time-series. In _International conference on machine learning_, pages 2164-2173. PMLR, 2020.
* [15] Randall Balestriero, Herve Glotin, and Richard Baranuik. Interpretable and learnable super-resolution time-frequency representation. In _Mathematical and Scientific Machine Learning_, pages 118-152. PMLR, 2022.
* [16] Hendrik Purwins, Bo Li, Tuomas Virtanen, Jan Schluter, Shuo-Yiin Chang, and Tara Sainath. Deep learning for audio signal processing. _IEEE Journal of Selected Topics in Signal Processing_, 13(2):206-219, 2019.
* [17] Stefan Lattner, Monika Dorfler, and Andreas Arzt. Learning complex basis functions for invariant representations of audio. _arXiv preprint arXiv:1907.05982_, 2019.

* [18] Wei Fan, Shun Zheng, Xiaohan Yi, Wei Cao, Yanjie Fu, Jiang Bian, and Tie-Yan Liu. Depts: deep expansion learning for periodic time series forecasting. _arXiv preprint arXiv:2203.07681_, 2022.
* [19] Aaron van den Oord, Yazhe Li, and Oriol Vinyals. Representation learning with contrastive predictive coding. _arXiv preprint arXiv:1807.03748_, 2018.
* [20] Emadeldeen Eldele, Mohamed Ragab, Zhenghua Chen, Min Wu, Chee Keong Kwoh, Xiaoli Li, and Cuntai Guan. Time-series representation learning via temporal and contextual contrasting. _arXiv preprint arXiv:2106.14112_, 2021.
* [21] Zhihan Yue, Yujing Wang, Juanyong Duan, Tianmeng Yang, Congrui Huang, Yunhai Tong, and Bixiong Xu. Ts2vec: Towards universal representation of time series. In _Proceedings of the AAAI Conference on Artificial Intelligence_, volume 36, pages 8980-8987, 2022.
* [22] Petar Velickovic, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Lio, and Yoshua Bengio. Graph attention networks. _arXiv preprint arXiv:1710.10903_, 2017.
* [23] Hang Yu and Justin Dauwels. Modeling spatio-temporal extreme events using graphical models. _IEEE Transactions on Signal Processing_, 64(5):1101-1116, 2015.
* [24] Guokun Lai, Wei-Cheng Chang, Yiming Yang, and Hanxiao Liu. Modeling long-and short-term temporal patterns with deep neural networks. In _The 41st international ACM SIGIR conference on research & development in information retrieval_, pages 95-104, 2018.
* [25] Gerald Woo, Chenghao Liu, Doyen Sahoo, Akshat Kumar, and Steven Hoi. Cost: Contrastive learning of disentangled seasonal-trend representations for time series forecasting. _arXiv preprint arXiv:2202.01575_, 2022.
* [26] Patrick Schafer. The boss is concerned with time series classification in the presence of noise. _Data Mining and Knowledge Discovery_, 29:1505-1530, 2015.
* [27] Juntang Zhuang, Tommy Tang, Yifan Ding, Sekhar C Tatikonda, Nicha Dvornek, Xenophon Papademetris, and James Duncan. Adabelief optimizer: Adapting stepsizes by the belief in observed gradients. _Advances in neural information processing systems_, 33:18795-18806, 2020.

## Appendix A Additional Experiments4
Footnote 4: All the six datasets can be downloaded from https://drive.google.com/drive/folders/1Z0YpTua82_jCcxIdTmyr0LXQfvatM9v1y?usp=sharing

### Experiments on the ETT datasets

In the main body, we present a comparison of the benchmark methods on the ETTm2 dataset. In this section, we extend our analysis to the remaining three ETT datasets, namely ETTh1, ETTh2, and ETTm1, as summarized in Table 8. Our experimental results reveal that Basisformer outperforms all other methods in terms of MSE and MAE. Specifically, Basisformer demonstrates a superior average MSE reduction of 1.32%, 6.74% and 9.23% when compared to FiLM, Fedformer and DLinear, respectively.

### Experimental results with longer length input setting

Throughout our research, we maintain consistency in our experimental settings by fixing the input length to be \(96\) (with a reduced input length of \(36\) for the illness dataset), instead of using a longer length. The main rationale behind this decision is that, in practical scenarios where the model is deployed as an online service and tasked with predicting a long range of the future at a granular level of minutes or hours, collecting a lengthy history (i.e., spanning 720 timestamps) for a large number of time series in real-time can be quite challenging. Therefore, the adoption of an input length of 96 proves to be more practical and feasible.

Given that certain recent methods utilize longer input lengths to yield better performance, irrespective of the length, we present supplementary comparison outcomes with extended input lengths in Table 9. Specifically, Fedformer, Autoformer, and TCN exhibit a decline in performance with an increase in input length, and hence, we retain their original outcomes at an input length of 96. In contrast, Dlinear employs an input length of 336 (104 for the illness dataset) by default, FiLM utilizes an input length that is at most four times of the output length, and N-HiTS adopts an input length that is five times of the output length. To enable a fair comparison, we standardize our input length for longer inputs to 192 (72 for the illness dataset).

The experimental results yield several notable findings. Firstly, those methods that benefit from longer inputs, namely Dlinear, FiLM, and N-HiTS, exhibit a significant performance decline when the input length is reduced from longer settings to an input length of 96. Concretely, Dlinear, FiLM, and N-HiTS show performance declines of 25.82%, 19.48%, and 330.42%, respectively. Conversely, our approach maintains most of its performance with a slight deterioration of 6.23%, as evident in Table 1 and Table 9. Secondly, concerning longer inputs, our method surpasses recent approaches such as Dlinear, FiLM, and N-HiTS, with an average MSE performance improvement of 1.35%, 0.63%, and 7.75%, respectively, and a corresponding evaluation MAE performance improvement of 3.15%, 2.33%, and 4.06%, respectively. It is noteworthy that our approach requires an input length

\begin{table}
\begin{tabular}{c|c c|c c|c c|c c|c c|c c|c c} \hline \multicolumn{2}{c|}{Models} & \multicolumn{2}{c}{Fedformer} & \multicolumn{2}{c}{Autoformer} & \multicolumn{2}{c}{N-HiTS} & \multicolumn{2}{c}{FiLM} & \multicolumn{2}{c}{Dlinear} & \multicolumn{2}{c}{Informer} & \multicolumn{2}{c}{Basisformer} \\ \hline \multicolumn{2}{c|}{Metric} & MSE & MAE & MSE & MAE & MSE & MAE & MSE & MAE & MSE & MAE & MSE & MAE & MSE & MAE \\ \hline \multirow{4}{*}{ETTh1} & 96 & **0.376** & 0.419 & 0.449 & 0.459 & 0.419 & 0.413 & 0.388 & 0.401 & 0.386 & **0.400** & 0.865 & 0.713 & 0.394 & 0.411 \\  & 192 & **0.420** & 0.448 & 0.500 & 0.482 & 0.468 & 0.443 & 0.443 & 0.439 & 0.437 & **0.432** & 1.008 & 0.792 & 0.442 & 0.437 \\  & 336 & **0.459** & 0.465 & 0.521 & 0.496 & 0.551 & 0.489 & 0.484 & 0.461 & 0.481 & 0.459 & 1.107 & 0.809 & 0.473 & **0.451** \\  & 720 & 0.506 & 0.507 & 0.514 & 0.512 & 0.669 & 0.559 & 0.525 & 0.519 & 0.516 & 1.181 & 0.865 & **0.460** & **0.465** \\ \hline \multirow{4}{*}{ETTh2} & 96 & 0.358 & 0.397 & 0.346 & 0.388 & 0.374 & 0.383 & **0.292** & **0.341** & 0.333 & 0.387 & 3.755 & 1.525 & 0.312 & 0.356 \\  & 192 & 0.429 & 0.439 & 0.456 & 0.452 & 0.476 & 0.446 & **0.378** & **0.396** & 0.477 & 0.476 & 5.602 & 1.931 & 0.382 & 0.401 \\  & 336 & 0.496 & 0.487 & 0.482 & 0.486 & 0.472 & 0.446 & 0.426 & 0.426 & 0.438 & 0.594 & 0.541 & 4.721 & 1.835 & **0.418** & **0.431** \\  & 720 & 0.463 & 0.474 & 0.515 & 0.511 & 0.932 & 0.636 & 0.443 & 0.455 & 0.831 & 0.657 & 3.647 & 1.625 & **0.418** & **0.438** \\ \hline \multirow{4}{*}{ETTh1} & 96 & 0.379 & 0.419 & 0.505 & 0.475 & **0.324** & **0.349** & 0.357 & 0.373 & 0.345 & 0.372 & 0.672 & 0.571 & 0.342 & 0.374 \\  & 192 & 0.426 & 0.441 & 0.553 & 0.496 & **0.376** & **0.379** & 0.387 & 0.385 & 0.380 & 0.389 & 0.795 & 0.669 & 0.380 & 0.392 \\  & 336 & 0.445 & 0.459 & 0.621 & 0.537 & **0.409** & **0.405** & 0.420 & 0.407 & 0.413 & 0.413 & 1.212 & 0.871 & 0.420 & 0.418 \\  & 720 & 0.543 & 0.490 & 0.671 & 0.561 & **0.472** & 0.443 & 0.478 & **0.439** & 0.474 & 0.453 & 1.166 & 0.823 & 0.492 & 0.458 \\ \hline \end{tabular}
\end{table}
Table 8: Multivariate results for the remaining three ETT datasets using an input length of \(I=96\) (or \(I=36\) for the illness dataset) and output lengths of \(O\in\{96,192,336,720\}\) (or \(O\in\{24,36,48,60\}\) for the illness dataset). In all experiments, lower MSE values indicate better model performance, and we present the best results in boldface.

[MISSING_PAGE_FAIL:14]

bottleneck architecture with a width of \(48\) can significantly reduce the number of model parameters without degrading the performance significantly, as opposed to not using a bottleneck architecture.

### Sensitivity analysis of the weights for the losses in Eq.(9)

Our model utilizes three distinct loss functions: the supervised MSE loss for prediction \(L_{pred}\), the self-supervised InfoNCE loss for basis learning \(L_{align}\), and the smoothness loss for smoothing the basis over time \(L_{align}\). During training, we directly combine these loss functions as the model's performance is not significantly impacted by the relative weights of the individual losses within a certain range. This assertion is supported by the performance evaluation presented in Figure 4, which investigates the impact of different weight combinations of the three loss functions. In our setting, we fix the weight of the predicted loss function to be 1, and then fix either the weight of the contrast loss function or the smoothness loss function to be 1, while the other one varies within the range of \(\{0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6\}\). To explore the inflection point of the effect, we take the middle point of two points and calculate a finer range again. Our results indicate that the contrast loss function is essentially stable between the weight range of 0.6-1.2, while the smoothness loss function is similarly stable between the weight range of 0.9-1.5.

\begin{table}
\begin{tabular}{c|c c|c c|c c|c c|c c} \hline \hline bottleneck & \multicolumn{2}{c|}{96} & \multicolumn{2}{c|}{48} & \multicolumn{2}{c|}{32} & \multicolumn{2}{c}{24} \\ \hline Metric & MSE & MAE & MSE & MAE & MSE & MAE & MSE & MAE & MSE & MAE \\ \hline
96 & **0.163** & **0.257** & 0.166 & 0.259 & 0.172 & 0.267 & 0.172 & 0.269 \\
192 & **0.172** & **0.265** & 0.176 & 0.268 & 0.182 & 0.273 & 0.186 & 0.279 \\
336 & **0.186** & **0.279** & 0.190 & 0.283 & 0.194 & 0.286 & 0.197 & 0.289 \\
720 & **0.217** & **0.305** & 0.218 & 0.306 & 0.230 & 0.316 & 0.233 & 0.317 \\ avg & **0.184** & **0.276** & 0.187 & 0.279 & 0.195 & 0.286 & 0.197 & 0.288 \\ \hline \hline \end{tabular}
\end{table}
Table 12: The impact of the MLP bottleneck in the forecast module. The electricity dataset is employed in this experiment. Setting the bottleneck dimension to \(96\) is equivalent to not using a bottleneck since the input length is \(96\). The best results are highlighted in bold. The second best is underlined.

Figure 4: MSE for the testing data as a function of the weight for the smoothness (the red line) and the infoNCE loss(the blue line).

\begin{table}
\begin{tabular}{c|c c|c c|c c|c c|c c} \hline \hline bottleneck & \multicolumn{2}{c|}{96} & \multicolumn{2}{c|}{48} & \multicolumn{2}{c|}{32} & \multicolumn{2}{c}{24} \\ \hline Metric & MSE & MAE & MSE & MAE & MSE & MAE & MSE & MAE & MSE & MAE \\ \hline
96 & **0.163** & **0.257** & 0.166 & 0.259 & 0.172 & 0.267 & 0.172 & 0.269 \\
192 & **0.172** & **0.265** & 0.176 & 0.268 & 0.182 & 0.273 & 0.186 & 0.279 \\
336 & **0.186** & **0.279** & 0.190 & 0.283 & 0.194 & 0.286 & 0.197 & 0.289 \\
720 & **0.217** & **0.305** & 0.218 & 0.306 & 0.230 & 0.316 & 0.233 & 0.317 \\ avg & **0.184** & **0.276** & 0.187 & 0.279 & 0.195 & 0.286 & 0.197 & 0.288 \\ \hline \hline \end{tabular}
\end{table}
Table 11: The impact of the number of stacked BCAB on the performance of the model. The electricity dataset is employed in this experiment. We present the best results in boldface.

### Comparison with self-supervised methods

Our proposed method adopts contrastive learning, here we provide comparative experiments with other self-supervised learning method namely Cost [25]. For the experiments, we fix the input length at 96 and vary the output length from 96 to 720. Table 13 and Table 14 illustrate that Basisformer outperforms Cost in terms of both MSE and MAE across all cases. It is important to note that Cost is trained using a two-step process: self-supervised training followed by supervised ridge regression. In contrast, Basisformer trains the basis, coef, and forecast modules end-to-end. This enables Basisformer to learn a basis that is specifically tailored for forecasting, potentially leading to improved performance.

### Comparison with time series discretization

To compare with time series discretization, we have chosen an method, namely Boss [26], which utilizes the Bag-Of-SFA-symbols method for feature extraction.

In order to evaluate the effectiveness of our approach, we have conducted a classification task using several UCR datasets. The description of the datasets is concluded in Table 15:

To adapt our method for classification, we followed these steps:

We partitioned the sequence into past and future parts, uniformly dividing them in a 6:4 ratio for all datasets. Different partitioning methods can be explored in future research to improve the model's performance.

We used a self-supervised approach for training, reserving 10% of the original training data for validating self-supervised performance. The remaining data was used for training, and the self-supervised loss function included prediction, alignment, and smoothness losses. Early termination based on validation set performance was done with a patience of 3.

From the well-trained self-supervised model, we extracted the aggregation coefficient matrix, specifically from the past perspective. This matrix was flattened to create sequence features, which were then fed into a random forest classifier for final classification. Notably, during self-supervised training, both past and future sequences were used for consistency, but only the past coefficient matrix was utilized in the classifier.

\begin{table}
\begin{tabular}{c|c|c c c|c c c|c c c|c c c} \hline \hline \multirow{2}{*}{Models} & \multirow{2}{*}{Metric} & \multicolumn{4}{c|}{ETT} & \multicolumn{4}{c|}{Electricity} & \multicolumn{4}{c}{exchange} \\ \cline{3-13}  & & 96 & 192 & 336 & 720 & 96 & 192 & 336 & 720 & 96 & 192 & 336 & 720 \\ \hline \multirow{3}{*}{Basisformer} & MSE & **0.184** & **0.248** & **0.321** & **0.410** & **0.165** & **0.178** & **0.189** & **0.223** & **0.085** & **0.177** & **0.336** & **0.854** \\  & MAE & **0.266** & **0.307** & **0.355** & **0.404** & **0.259** & **0.272** & **0.282** & **0.311** & **0.205** & **0.299** & **0.421** & **0.670** \\ \hline \multirow{3}{*}{Cost} & MSE & 0.280 & 0.480 & 0.805 & 1.562 & 0.199 & 0.199 & 0.212 & 0.246 & 0.263 & 0.464 & 0.833 & 1.192 \\  & MAE & 0.375 & 0.506 & 0.676 & 0.955 & 0.290 & 0.292 & 0.307 & 0.338 & 0.393 & 0.521 & 0.691 & 0.871 \\ \hline \hline \end{tabular}
\end{table}
Table 13: Multidimensional prediction comparative experiments on three datasets.

\begin{table}
\begin{tabular}{c|c|c|c|c|c|c|c} \hline \hline Dataset & Train Size & Test Size & Length & Classes & Is\_predictable & Description \\ \hline Mallat & 55 & 2345 & 1024 & 8 & Y & a simulated dataset \\ Rock & 20 & 50 & 2844 & 4 & Y & rock examples from the ASTER spectral library \\ Phoneme & 214 & 1896 & 1024 & 39 & N & Each series is extracted from the segmented audio \\ FaceUCR & 200 & 2050 & 131 & 14 & N & rotationally aligned version of facial outline \\ \hline \hline \end{tabular}
\end{table}
Table 15: The description of selected UCR datasetsWe conducted a fair comparison by extracting features using both Boss and our model, ensuring that our feature parameter count did not exceed Boss's. We employed a random forest classifier with 100 features and a maximum depth of 30 for classification, and the results are summarized in the Table 16.

The applicability of our method to self-supervision relies on predictability and consistency between past and future data. The validation set loss in the table indicates that datasets lacking predictability have high validation losses, posing challenges for loss function optimization. The Phoneme and FaceUCR datasets lack predictability. The Phoneme dataset includes speech segments from different individuals with random content before and after, while the FaceUCR dataset consists of flattened one-dimensional vectors of rotated face images, both lacking inherent predictability. These datasets require a holistic understanding of the entire sequence for meaningful interpretation, and as a result, our proposed Basisformer struggles to extract useful features, leading to lower performance compared to Boss.

On the other hand, datasets like Mallat and Rock, exhibiting predictability and low validation losses, allow our approach to achieve superior performance over Boss. Surprisingly, we achieve this performance using only the representation of the past sequence as input for the classifier.

### Uncertainty of the results

To assess the stability of our proposed method, we performed 5 repeated experiments and calculated the standard deviations for all methods, as presented in Table 17. Notably, our method exhibits a relatively small variance within the table, indicating its high degree of stability.

## Appendix B Implementation Details

The training and testing of BasisFormer are conducted on an NVIDIA GeForce RTX 3090 graphics card with 24268MB of VRAM. During the trainin process, we adopt the Adabelief optimizer [27] for optimization. We train the model for 30 epochs with the patience of 3 epochs. All experiments are averaged over 5 trials.

To implement the multi-head mechanism, we calculate the multi-head attention for each CAB separately, and then restore it to the original dimension through multiplication, concatenation, and a linear layer. In the last layer of the network, a mapping layer was utilized to map it to \(H\) heads, and the dot product outputs the final coefficients.

To promote the learning of bases and ensure consistency of time series across different dimensions, we normalized the time series during training and performed inverse normalization when outputting the results.

For the other models compared in the table, we utilized their original code and conducted experiments by only varying the input length.

## Appendix C Analysis of the Limitations of BasisFormer

BasisFormer demonstrates proficiency in learning effective representations and capturing the relationship between bases and time series. However, this proficiency is contingent upon the multi-dimensional time series being on the same feature scale, which necessitates normalization of the time series during training and inverse normalization when outputting results. Despite this, the normalization and inverse normalization operations introduce changes to the original distribution of

\begin{table}
\begin{tabular}{c|c|c|c} \hline \hline Model & Boss & \multicolumn{2}{c}{Basisformer} \\ \hline Metric & acc & acc & valid\_loss \\ \hline Mallat & 0.83 & **0.87** & 0.12 \\ Rock & 0.56 & **0.72** & 0.18 \\ Phoneme & **0.20** & 0.07 & 1.27 \\ FaceUCR & **0.68** & 0.41 & 1.68 \\ \hline \hline \end{tabular}
\end{table}
Table 16: The comparison results of BOSS and Basisformer. We present the best results in boldface.

[MISSING_PAGE_FAIL:18]

distinct attention scores for different the same set of basis vectors. It can also be seen that the attention mechanisms exhibit significant similarities between the past and future sequences. This demonstrates the consistency in the base elements between the two.

Additionally, we have provided a visualization of a specific time sequence alongside the features corresponding to the highest and lowest attention scores, as shown in Figure 6. The highest attention score is 0.2316, while the lowest attention score is 0.03371. Figure R2 highlights that the representation with a total of 8 sets of main peaks (Figure 6(c)) more comprehensively captures the patterns of the data compared to the configuration with only 2-3 main peaks (Figure 6(b)). This indicates a correlation between the attention scores and the relationship between time sequences and features.

It is important to note two key points. Firstly, since bases represent condensed patterns of time sequences, it is unlikely for a base to be identical to any single time sequence, especially when \(N\) is small. Secondly, after the bases are processed through multiple linear and nonlinear layers in the network, they correspond to predicted sequences. Therefore, the numerical values of the bases serve as reference points only. The focus should be on the patterns exhibited by the bases.

## Appendix F Analysis of the Model Complexity

Suppose that the input and output length in BasisFormer is \(I\) and \(O\) respectively when forecasting a single time series. Note that the time and space complexity of BasisFormer are of the same order. Therefore, we refer to both of them as complexity in the sequel.

With regards to the coef module, the complexity is primarily determined by the cross-attention mechanism. Within our approach, BCAB utilizes attention on the channel dimension, and we

Figure 5: corresponding set of attention maps from past and future perspectives

Figure 6: Time series and bases with higher and lower attention scores

encode the time sequence dimension to a specified hidden length \(D_{c}\ll O\) via a linear layer during computation. Consequently, the complexity of this module is \(\mathcal{O}(N)\), where \(N\) is the number of bases - a fixed hyperparameter which is usually not large. In this step, we omit the number of BCAB stacks \(M\), since \(M\) is also a fixed hyperparameter. As previously mentioned in Appendix A.3, to limit overfitting, \(M\) is typically set to \(2\).

The prediction module incorporates two Multilayer Perceptron (MLP) networks, which are employed for separating and concatenating different heads. Both MLP networks have bottlenecks with constant values, and they carry a complexity of \(\mathcal{O}(O)\). In terms of the aggregation of different base vectors, the complexity also is \(\mathcal{O}(O)\). Therefore, the cumulative complexity of this module is \(\mathcal{O}(O)\).

In summary, the total complexity of our model is \(\mathcal{O}(O)\). Table 18 provides a comparison of the computational complexity among different models, and BasisFormer achieves the lowest complexity among them.

\begin{table}
\begin{tabular}{l|c c} \hline \hline Methods & TIME & MEMORY \\ \hline Fedformer & \(\mathcal{O}(O)\) & \(\mathcal{O}(O)\) \\ Autodimer & \(\mathcal{O}(O\log O)\) & \(\mathcal{O}(O\log O)\) \\ N-HiTS & \(\mathcal{O}(O(1-r^{B})/(1-r)\) & \(\mathcal{O}(O(1-r^{B})/(1-r)\) \\ FiLM & \(\mathcal{O}(O)\) & \(\mathcal{O}(O)\) \\ Dlinear & \(\mathcal{O}(O)\) & \(\mathcal{O}(O)\) \\ TCN & \(\mathcal{O}(O)\) & \(\mathcal{O}(O)\) \\ LogTrans & \(\mathcal{O}(O\log O)\) & \(\mathcal{O}(O^{2})\) \\ Reformer & \(\mathcal{O}(O\log O)\) & \(\mathcal{O}(O\log O)\) \\ Informer & \(\mathcal{O}(O\log O)\) & \(\mathcal{O}(O\log O)\) \\ Basisformer & \(\mathcal{O}(O)\) & \(\mathcal{O}(O)\) \\ \hline \hline \end{tabular}
\end{table}
Table 18: Comparison of computational complexity for different models.