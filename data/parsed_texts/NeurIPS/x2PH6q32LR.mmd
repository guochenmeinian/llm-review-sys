# Taming Local Effects in

Graph-based Spatiotemporal Forecasting

 Andrea Cini 1, Ivan Marisca 1, Daniele Zambon 1, Cesare Alippi 12

1 The Swiss AI Lab IDSIA USI-SUPSI, Universita della Svizzera italiana, 2 Politecnico di Milano

{andrea.cini, ivan.marisca, daniele.zambon, cesare.alippi}@usi.ch

Equal contribution.

###### Abstract

Spatiotemporal graph neural networks have shown to be effective in time series forecasting applications, achieving better performance than standard univariate predictors in several settings. These architectures take advantage of a graph structure and relational inductive biases to learn a single (_global_) inductive model to predict any number of the input time series, each associated with a graph node. Despite the gain achieved in computational and data efficiency w.r.t. fitting a set of _local_ models, relying on a single global model can be a limitation whenever some of the time series are generated by a different spatiotemporal stochastic process. The main objective of this paper is to understand the interplay between _globality_ and _locality_ in graph-based spatiotemporal forecasting, while contextually proposing a methodological framework to rationalize the practice of including trainable node embeddings in such architectures. We ascribe to trainable node embeddings the role of amortizing the learning of specialized components. Moreover, embeddings allow for 1) effectively combining the advantages of shared message-passing layers with node-specific parameters and 2) efficiently transferring the learned model to new node sets. Supported by strong empirical evidence, we provide insights and guidelines for specializing graph-based models to the dynamics of each time series and show how this aspect plays a crucial role in obtaining accurate predictions.

## 1 Introduction

Neural forecasting methods [1] take advantage of large databases of related time series to learn models for each individual process. If the time series in the database are not independent, functional dependencies among them can be exploited to obtain more accurate predictions, e.g., when the considered time series are observations collected from a network of sensors. In this setting, we use the term _spatiotemporal time series_ to indicate the existence of relationships among subsets of time series (sensors) that span additional axes other than the temporal one, denoted here as _spatial_ in a broad sense. Graph representations effectively model such dependencies and graph neural networks (GNNs) [2, 3, 4] can be included as modules in the forecasting architecture to propagate information along the spatial dimension. The resulting neural architectures are known in the literature as spatiotemporal graph neural networks (STGNNs) [5, 6] and have found widespread adoption in relevant applications ranging from traffic forecasting [6, 7] to energy analytics [8, 9]. These models embed inductive biases typical of graph deep learning and graph signal processing [10] and, thus, have several advantages over standard multivariate models; in fact, a shared set of learnable weights is used to obtain predictions for each time series by conditioning on observations at the neighboring nodes. Nonetheless, it has become more and more common to see node-specific trainable parameters being introduced as means to extract node(sensor)-level features then used as spatial identifiers within the processing [11, 12]. By doing so, the designer accepts a compromise in transferability that oftenempirically leads to higher forecasting accuracy on the task at hand. We argue that the community has yet to find a proper explanatory framework for this phenomenon and, notably, has yet to design proper methodologies to deal with the root causes of observed empirical results, in practical applications.

In the broader context of time series forecasting, single models learned from a set of time series are categorized as _global_ and are opposed to _local_ models, which instead are specialized for any particular time series in the set [13, 14]. Global models are usually more robust than local ones, as they require a smaller total number of parameters and are fitted on more samples. Standard STGNNs, then, fall within the class of global models and, as a result, often have an advantage over local multivariate approaches; however, explicitly accounting for the behavior of individual time series might be problematic and require a large memory and model capacity. As an example, consider the problem of electric load forecasting: consumption patterns of single customers are influenced by shared factors, e.g., weather conditions and holidays, but are also determined by the daily routine of the individual users related by varying degrees of affinity. We refer to the dynamics proper to individual nodes as _local effects_.

Local effects can be accounted for by combining a global model with local components, e.g., by using encoding and/or decoding layers specialized for each input time series paired with a core global processing block. While such an approach to building hybrid global-local models can be effective, the added model complexity and specialization can negate the benefits of using a global component. In this paper, we propose to consider and interpret learned node embeddings as a mechanism to amortize the learning of local components; in fact, instead of learning a separate processing layer for each time series, node embeddings allow for learning a single global module conditioned on the learned (local) node features. Furthermore, we show that - within a proper methodological framework - node embeddings can be fitted to different node sets, thus enabling an effective and efficient transfer of the core processing modules.

ContributionsIn this paper, we analyze the effect of node-specific components in spatiotemporal time series models and assess how to incorporate them in the forecasting architecture, while providing an understanding of each design choice within a proper context. The major findings can be summarized in the following statements.

* Local components can be crucial to obtain accurate predictions in spatiotemporal forecasting.
* Node embeddings can amortize the learning of local components.
* Hybrid global-local STGNNs can capture local effects with contained model complexity and smaller input windows w.r.t. fully global approaches.
* Node embeddings for time series outside the training dataset can be obtained by fitting a relatively small number of observations and yield more effective transferability than fine-tuning global models.
* Giving structure to the embedding space provides an effective regularization, allowing for similarities among time series to emerge and shedding light on the role of local embeddings within a global architecture.

Throughout the paper, we reference the findings with their pointers. Against this backdrop, our main novel contributions reside in:

* A sound conceptual and methodological framework for dealing with local effects and designing node-specific components in STGNN architectures.
* An assessment of the role of learnable node embeddings in STGNNs and methods to obtain them.
* A comprehensive empirical analysis of the aforementioned phenomena in representative architectures across synthetic and real-world datasets.
* Methods to structure the embedding space, thus allowing for effective and efficient reuse of the global component in a transfer learning scenario.

We believe that our study constitutes an essential advancement toward the understanding of the interplay of different inductive biases in graph-based predictors, and argue that the methodologies and conceptual developments proposed in this work will constitute a foundational piece of know-how for the practitioner.

Preliminaries and problem statement

Consider a set of \(N\) time series with graph-side information where the \(i\)-th time series is composed by a sequence of \(d_{x}\) dimensional vectors \(\bm{x}_{t}^{i}\in\mathbb{R}^{d_{x}}\) observed at time step \(t\); each time series \(\{\bm{x}_{t}^{i}\}_{t}\) might be generated by a different stochastic process. Matrix \(\bm{X}_{t}\in\mathbb{R}^{N\times d_{x}}\) encompasses the \(N\) observations at time \(t\) and, similarly, \(\bm{X}_{t:t+T}\) indicates the sequence of observations within the time interval \([t,t+T)\). Relational information is encoded by a weighted adjacency matrix \(\bm{A}\in\mathbb{R}^{N\times N}\) that accounts for (soft) functional dependencies existing among the different time series. We use interchangeably the terms _node_ and _sensor_ to indicate the entities generating the time series and refer to the node set together with the relational information (graph) as _sensor network_. Eventual exogenous variables associated with each node are indicated by \(\bm{U}_{t}\in\mathbb{R}^{N\times d_{u}}\); the tuple \(\mathcal{G}_{t}=\langle\bm{X}_{t},\bm{U}_{t},\bm{A}\rangle\) indicates all the available information associated with time step \(t\).

We address the multistep-ahead time-series forecasting problem, i.e., we are interested in predicting, for every time step \(t\) and some \(H,W\geq 1\), the expected value of the next \(H\) observations \(\bm{X}_{t:t+H}\) given a window \(\mathcal{G}_{t-W:t}\) of \(W\) past measurements. In case data from multiple sensor networks are available, the problem can be formalized as learning from \(M\) disjoint collections of spatiotemporal time series \(\mathcal{D}=\left\{\mathcal{G}_{t_{1}:t+T_{1}}^{(1)},\mathcal{G}_{t_{2}:t_{2 }:t_{2}}^{(2)},\ldots,\mathcal{G}_{t_{m}:t_{m}+T_{m}}^{(M)}\right\}\), potentially without overlapping time frames. In the latter case, we assume sensors to be homogeneous both within a single network and among different sets. Furthermore, we assume edges to indicate the same type of relational dependencies, e.g., physical proximity.

## 3 Forecasting with Spatiotemporal Graph Neural Networks

This section provides a taxonomy of the different components that constitute an STGNN. Based on the resulting archetypes, reference operators for this study are identified. The last paragraph of the section broadens the analysis to fit STGNNs within more general time series forecasting frameworks.

Spatiotemporal message-passingWe consider STGNNs obtained by stacking spatiotemporal message-passing (STMP) layers s.t.

\[\bm{H}_{t}^{l+1}=\text{STMP}^{l}\left(\bm{H}_{\leq t}^{l},\bm{A}\right),\] (1)

where \(\bm{H}_{t}^{l}\in\mathbb{R}^{N\times d_{h}}\) indicates the stack of node representations \(\bm{h}_{t}^{i,l}\) at time step \(t\) at the \(l\)-th layer. The shorthand \(\leq t\) indicates the sequence of all representations corresponding to the time steps up to \(t\) (included). Each \(\text{STMP}^{l}\left(\ \cdot\ \right)\) layer is structured as follows

\[\bm{h}_{t}^{i,l+1}=\rho^{l}\Big{(}\bm{h}_{\leq t}^{i,l},\underset{j\in N(i)} {\text{AGR}}\left\{\gamma^{l}\big{(}\bm{h}_{\leq t}^{i,l},\bm{h}_{\leq t}^{j,l},a_{ji}\big{)}\right\}\Big{)},\] (2)

where \(\rho^{l}\) and \(\gamma^{l}\) are respectively the update and message functions, e.g., implemented by multilayer perceptrons (MLPs) or recurrent neural networks (RNNs). \(\text{AGgr}\left\{\ \cdot\ \right\}\) indicates a generic permutation invariant aggregation function, while \(\mathcal{N}(i)\) refers to the set of neighbors of node \(i\), each associated with an edge with weight \(a_{ji}\). Models of this type are fully _inductive_, in the sense that they can be used to make predictions for networks and time windows different from those they have been trained on, provided a certain level of similarity (e.g., homogenous sensors) between source and target node sets [15].

Among the different implementations of this general framework, we can distinguish between time-then-space (TTS) and time-and-space (T&S) models by following the terminology of previous works [16; 17]. Specifically, in TTS models the sequence of representations \(\bm{h}_{\leq t}^{i,0}\) is encoded by a sequence model, e.g., an RNN, before propagating information along the spatial dimension through message passing (MP) [16]. Conversely, in T&S models time and space are processed in a more integrated fashion, e.g., by a recurrent GNN [5] or by spatiotemporal convolutional operators [7]. In the remainder of the paper, we take for TTS model an STGNN composed by a Gated Recurrent Unit (GRU) [18] followed by standard MP layers [19]:

\[\bm{H}_{t}^{l}=\text{GRU}\left(\bm{H}_{\leq t}^{0}\right),\qquad\qquad\qquad \qquad\bm{H}_{t}^{l+1}=\text{MP}^{l}\left(\bm{H}_{t}^{l},\bm{A}\right),\] (3)

where \(l=1,\ldots,L-1\) and \(\text{GRU}\left(\ \cdot\ \right)\) processes sequences node-wise. Similarly, we consider as reference T&S model a GRU with an MP network at its gates [5; 20], that process input data as

\[\bm{H}_{t}^{l+1}=\text{GRU}^{l}\left(\left\{\text{MP}^{l}\left(\bm{H}_{t}^{l}, \bm{A}\right)\right\}_{\leq t}\right).\] (4)Moreover, STGNN models can be further categorized w.r.t. the implementation of message function; in particular, by loosely following Dwivedi et al. [21], we call _isotropic_ those GNNs where the message function \(\gamma^{l}\) only depends on the features of the sender node \(\bm{h}_{\leq t}^{j,l}\); conversely, we call _anisotropic_ GNNs where \(\gamma^{l}\) takes both \(\bm{h}_{\leq t}^{i,l}\) and \(\bm{h}_{\leq t}^{j,l}\) as input. In the following, the case-study isotropic operator is

\[\bm{h}_{t}^{i,l+1}=\xi\Big{(}\bm{W}_{1}^{l}\bm{h}_{t}^{i,l}+\underset{j\in \mathcal{N}(i)}{\text{\small Mean}}\Big{\{}\bm{W}_{2}^{l}\bm{h}_{t}^{j,l} \Big{\}}\Big{)},\] (5)

where \(\bm{W}_{1}^{l}\) and \(\bm{W}_{2}^{l}\) are matrices of learnable parameters and \(\xi(\ \cdot\ )\) a generic activation function. Conversely, the operator of choice for the anisotropic case corresponds to

\[\bm{m}_{t}^{j\to i,l} =\bm{W}_{2}^{l}\xi\Big{(}\bm{W}_{1}^{l}\Big{[}\bm{h}_{t}^{i,l}|| \bm{h}_{t}^{j,l}||a_{ji}\Big{]}\Big{)},\qquad\alpha_{t}^{j\to i,l}= \sigma\Big{(}\bm{W}_{0}^{l}\bm{m}_{t}^{j\to i,l}\Big{)},\] (6) \[\bm{h}_{t}^{i,l+1} =\xi\Big{(}\bm{W}_{3}^{l}\bm{h}_{t}^{i,l}+\underset{j\in \mathcal{N}(i)}{\text{\small Sum}}\Big{\{}\alpha_{t}^{j\to i,l}\bm{m}_{t}^{j \to i,l}\Big{\}}\Big{)},\] (7)

where matrices \(\bm{W}_{0}^{l}\in\mathbb{R}^{1\times d_{m}}\), \(\bm{W}_{1}^{l}\), \(\bm{W}_{2}^{l}\) and \(\bm{W}_{3}^{l}\) are learnable parameters, \(\sigma(\ \cdot\ )\) is the sigmoid activation function and \(||\) the concatenation operator applied along the feature dimension (see Appendix A.2 for a detailed description).

Global and local forecasting modelsFormally, a time series forecasting model is called _global_ if its parameters are fitted to a group of time series (either univariate or multivariate), while _local_ models are specific to a single (possibly multivariate) time series. The advantages of global models have been discussed at length in the time series forecasting literature [22; 14; 13; 1] and are mainly ascribable to the availability of large amounts of data that enable generalization and the use of models with higher capacity w.r.t. the single local models. As presented, and further detailed in the following section, STGNNs are global, yet have a peculiar position in this context, as they exploit spatial dependencies localizing predictions w.r.t. each node's neighborhood. Furthermore, the transferability of GNNs makes these models distinctively different from local multivariate approaches enabling their use in cold-start scenarios [23] and making them inductive both temporally and spatially.

## 4 Locality and globality in Spatiotemporal Graph Neural Networks

We now focus on the impact of local effects in forecasting architectures based on STGNNs. The section starts by introducing a template to combine different processing layers within a global model, then continues by discussing how these can be turned into local. Contextually, we start to empirically probe the reference architectures.

### A global processing template

STGNNs localize predictions in space, i.e., with respect to a single node, by exploiting an MP operator that contextualizes predictions by constraining the information flow within each node's neighborhood. STGNNs are global forecasting models s.t.

\[\widehat{\bm{X}}_{t:t+H}=F_{\text{\tiny G}}\left(\mathcal{G}_{t-W:t};\phi\right)\] (8)

where \(\phi\) are the learnable parameters shared among the time series and \(\widehat{\bm{X}}_{t:t+H}\) indicate the \(H\)-step ahead predictions of the input time series given the window of (structured) observations \(\bm{X}_{t-W:t}\). In particular, we consider forecasting architectures consisting of an encoding step followed by STMP layers and a final readout mapping representations to predictions; the corresponding sequence of operations composing \(F_{\text{G}}\) can be summarized as

\[\bm{h}_{t}^{i,0} =\text{\small Encoder}\left(\bm{x}_{t-1}^{i},\bm{u}_{t-1}^{i} \right),\] (9) \[\bm{H}_{t}^{l+1} =\text{\small STMP}^{l}\Big{(}\bm{H}_{\leq t}^{l},\bm{A}\Big{)}, \quad l=0,\dots,L-1\] (10) \[\hat{\bm{x}}_{t:t+H}^{i} =\text{\small Decoder}\left(\bm{h}_{t}^{i,L}\right).\] (11)

\(\text{\small Encoder}(\ \cdot\ )\) and \(\text{\small Decoder}(\ \cdot\ )\) indicate generic encoder and readout layers that could be implemented in several ways. In the following, the encoder is assumed to be a standard fully connected linear layer, while the decoder is implemented by an MLP with a single hidden layer followed by an output (linear) layer for each forecasting step.

### Local effects

Differently from the global approach, local models are fitted to a single time series (e.g., see the standard Box-Jenkins approach) and, in our problem settings, can be indicated as

\[\hat{\bm{x}}_{t:t+H}^{i}=f_{i}\left(\bm{x}_{t-W:t}^{i};\theta^{i}\right),\] (12)

where \(f_{i}\left(\ \cdot\ ;\theta^{i}\right)\) is a sensor-specific model, e.g., an RNN with its dedicated parameters \(\theta^{i}\), fitted on the \(i\)-th time series. While the advantages of global models have already been discussed, local effects, i.e., the dynamics observed at the level of the single sensor, are potentially more easily captured by a local model. In fact, if local effects are present, global models might require an impractically large model capacity to account for all node-specific dynamics [13], thus losing some of the advantages of using a global approach (**S3**). In the STGNN case, then, increasing the input window for each node would result in a large computational overhead. Conversely, purely local approaches fail to exploit relational information among the time series and cannot reuse available knowledge efficiently in an inductive setting.

Combining global graph-based components with local node-level components has the potential for achieving a two-fold objective: 1) exploiting relational dependencies together with side information to learn flexible and efficient graph deep learning models and 2) making at the same time specialized and accurate predictions for each time series. In particular, we indicate global-local STGNNs as

\[\hat{\bm{x}}_{t:t+H}^{i}=F\left(\mathcal{G}_{t-W:t};\phi,\theta^{i}\right)\] (13)

where function \(F\) and parameter vector \(\phi\) are shared across all nodes, whereas parameter vector \(\theta^{i}\) is time-series dependent. Such a function \(F(\ \cdot\ )\) could be implemented, for example, as a sum between a global model (Eq. 8) and a local one (Eq. 12):

\[\widehat{\bm{X}}_{t:t+H}^{(1)}=F_{\circ}\left(\mathcal{G}_{t-W:t};\phi\right),\qquad\hat{\bm{x}}_{t:t+H}^{i,(2)}=f_{i}\left(\bm{x}_{t-W:t}^{i};\theta^{i} \right),\] (14)

\[\hat{\bm{x}}_{t:t+H}^{i}=\hat{\bm{x}}_{t:t+H}^{i,(1)}+\hat{\bm{x}}_{t:t+H}^{i,(2)},\] (15)

or - with a more integrated approach - by using different weights for each time series at the encoding and/or decoding steps. The latter approach results in using a different encoder and/or decoder for each \(i\)-th node in the template STGNN (Eq. 9-11) to extract representations and, eventually, project them back into input space:

\[\bm{h}_{t}^{i,0}=\texttt{Encoder}_{i}\left(\bm{x}_{t-1}^{i},\bm{u}_{t-1}^{i}; \theta_{enc}^{i}\right),\] (16)

MP layers could in principle be specialized as well, e.g., by using a different local update function \(\gamma_{i}(\ \cdot\ )\) for each node. However, this would be impractical unless subsets of nodes are allowed to share parameters to some extent (e.g., by clustering them).

To support our arguments, Tab. 1 shows empirical results for the reference TTS models with isotropic message passing (TTS-IMP) on \(2\) popular traffic forecasting benchmarks (METRA and PEMS-BAY [6]). In particular, we compare the global approach with \(3\) hybrid global-local variants where local weights are used in the encoder, in the decoder, or in both of them (see Eq. 16-17 and the light brown block in Tab. 1). Notably, while fitting a separate RNN to each individual time series fails (LocalRNNs), exploiting a local encoder and/or decoder significantly improves performance w.r.t. the fully global model (**S1**). Note that the price of specialization is paid in terms of the number of learnable parameters which is an order of magnitude higher in global-local variants. The table reports as a reference also results for FC-RNN, a multivariate RNN taking as input the concatenation of all time series. Indeed, having both encoder and decoder implemented as local layers leads to a large number of parameters and has a marginal impact on forecasting accuracy. The

\begin{table}
\begin{tabular}{c|c|c|c c} \cline{3-5} \multicolumn{1}{c}{} & \multicolumn{1}{c}{**METR-LA**} & \multicolumn{1}{c}{**PEMS-BAY**} & \multicolumn{1}{c}{(\# weights)} \\ \hline \multirow{4}{*}{\(\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bmbm }}}}} \bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bmbmbm}}}}}}}}}}}}}}}}}} &&& ** ** **M** & **1.7\(\pm\)**0.00} & **4.71\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & \multirow{4}{*}{\(\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{ }}}}}}}}}}}}}}}} &\bm{}}\)**Encoder & 3.15 \(\pm\)**0.01} & 1.66 \(\pm\)**0.01} & 2.75\(\times\)**10\({}^{5}\)** \\  & & Decoder & 3.09 \(\pm\)**0.01} & 1.58 \(\pm\)**0.00} & 3.00\(\times\)**10\({}^{5}\)** \\  & & Enc. + Dec. & 3.16 \(\pm\)**0.01} & 1.70 \(\pm\)**0.01} & 5.28\(\times\)**10\({}^{5}\)** \\ \cline{2-5}  & \multirow{4}{*}{\(\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bm{\bmbm{\bmbmbmbmbmbmbmbmbm       }}}}}}}}}}}}}}}\) & **2.08 \(\pm\)**0.01} & 1.58 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & & Decoder & 3.13 \(\pm\)**0.00} & 1.60 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & & Encoder & 3.07 \(\pm\)**0.01} & 1.58 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & & Decoder & 3.15 \(\pm\)**0.01} & 1.60 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & & Decoder & 3.15 \(\pm\)**0.01} & 1.60 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{5}\)** \\ \cline{2-5}  & & Decoder & 3.15 \(\pm\)**0.00} & 1.60 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & & Decoder & 3.09 \(\pm\)**0.01} & 1.58 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & & Decoder & 3.15 \(\pm\)**0.00} & 1.58 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & & Decoder & 3.15 \(\pm\)**0.00} & 1.58 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & & Decoder & 3.15 \(\pm\)**0.00} & 1.58 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & & Decoder & 3.15 \(\pm\)**0.00} & 1.60 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & & Decoder & 3.07 \(\pm\)**0.01} & 1.58 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \hline \hline \multicolumn{2}{c}{FC-RNN} & 3.56 \(\pm\)**0.03} & 2.32 \(\pm\)**0.01} & 3.04\(\times\)**10\({}^{5}\)** \\ \cline{2-5}  & & Decoder & 3.69 \(\pm\)**0.00} & 1.91 \(\pm\)**0.00} & 1.10\(\times\)**10\({}^{7}\)** \\ \cline{2-5}  & & Decoder & 3.15 \(\pm\)**0.00} & 1.60 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & & Decoder & 3.15 \(\pm\)**0.00} & 1.60 \(\pm\)**0.00} & 5.96\(\times\)**10\({}^{4}\)** \\ \cline{2-5}  & & Decoder & 3.07 \(\pm\)**0.01} & 1.58 \(\pm\)**0.00} & 5.61\(\times\)**10\({}^{4}\)** \\ \hline \hline \multicolumn{2}{c}{FC-RNN} & 3.56 \(\pm\)**0.03} & 2.32 \(\pm\)**0.01} & 3.04\(\times\)**10\({}^{5}\)** \\ \cline{2-5}  & & Decoder & 3.69 \(\pm\)**0.00} & 1.91

[MISSING_PAGE_FAIL:6]

where \(P=\mathcal{N}(0,\mathbb{I})\) is the prior, \(D_{\mathrm{KL}}\) the Kulback-Leibler divergence, and \(\beta\) controls the regularization strength. This regularization scheme results in a smooth latent space where it is easier to interpolate between representations, thus providing a principled way for accommodating different node embeddings.

Clustering regularizationA different (and potentially complementary) approach to structuring the latent space is to incentivize node embeddings to form clusters and, consequently, to self-organize into different groups. We do so by introducing a regularization loss inspired by deep \(K\)-means algorithms [29]. In particular, besides the embedding table \(\bm{V}\in\mathbb{R}^{N\times d_{v}}\), we equip the embedding module with a matrix \(\bm{C}\in\mathbb{R}^{K\times d_{v}}\) of \(K\ll N\) learnable centroids and a cluster assignment matrix \(\bm{S}\in\mathbb{R}^{N\times K}\) encoding scores associated to each node-cluster pair. We consider scores as logits of a categorical (Boltzmann) distribution and learn them by minimizing the regularization term

\[\mathcal{L}_{reg}\doteq\mathbb{E}_{\bm{M}}\left[\left\|\bm{V}-\bm{M}\bm{C} \right\|_{2}\right],\quad p(\bm{M}_{ij}=1)=\frac{e^{\bm{S}_{ij}/\tau}}{\sum e^ {\bm{S}_{ik}/\tau}},\]

where \(\tau\) is a hyperparameter. We minimize \(\mathcal{L}_{reg}\) - which corresponds to the embedding-to-centroid distance - jointly with the forecasting loss by relying on the Gumbel softmax trick [30]. Similarly to the variational inference approach, the clustering regularization gives structure to embedding space and allows for inspecting patterns in the learned local components (see Sec. 7).

Transferability of graph-based predictorsGlobal models based on GNNs can make predictions for never-seen-before node sets, and handle graphs of different sizes and variable topology. In practice, this means that the graph-based predictors can easily handle new sensors being added to the network over time and be used for zero-shot transfer. Clearly, including in the forecasting architecture node-specific local components compromises these properties. Luckily, if local components are replaced by node embedding, adapting the specialized components is relatively cheap since the number of parameters to fit w.r.t. the new context is usually contained, and - eventually - both the graph topology and the structure of the embedding latent space can be exploited (**S4**). Experiments in Sec. 7 provide an in-depth empirical analysis of transferability within our framework and show that the discussed regularizations can be useful in this regard.

## 6 Related works

GNNs have been remarkably successful in modeling structured dynamical systems [31; 32; 33], temporal networks [34; 35; 36] and sequences of graphs [37; 38]. For what concerns time series processing, recurrent GNNs [5; 6] were among the first STGNNs being developed, followed by fully convolutional models [7; 39] and attention-based solutions [40; 41; 42]. Among the methods that focus on modeling node-specific dynamics, Bai et al. [11] use a factorization of the weight matrices in a recurrent STGNN to adapt the extracted representation to each node. Conversely, Chen et al. [43] use a model inspired by Wang et al. [44] consisting of a global GNN paired with a local model conditioned on the neighborhood of each node. Node embeddings have been mainly used in structure-learning modules to amortize the cost of learning the full adjacency matrix [39; 45; 12] and in attention-based approaches as positional encodings [46; 47; 41]. Shao et al. [48] observed how adding spatiotemporal identification mechanisms to the forecasting architecture can outperform several state-of-the-art STGNNs. Conversely, Yin et al. [49] used a cluster-based regularization to fine-tune an AGCRN-like model on different datasets. However, none of the previous works systematically addressed directly the problem of globality and locality in STGNNs, nor provided a comprehensive framework accounting for learnable node embeddings within different settings and architectures. Finally, besides STGNNs, there are several examples of hybrid global and local time series forecasting models. Wang et al. [44] propose an architecture where \(K\) global models extract dynamic global factors that are then weighted and integrated with probabilistic local models. Sen et al. [50] instead use a matrix factorization scheme paired with a temporal convolutional network [51] to learn a multivariate model then used to condition a second local predictor.

## 7 Experiments

This section reports salient results of an extensive empirical analysis of global and local models and combinations thereof in spatiotemporal forecasting benchmarks and different problem settings;complete results of this systematic analysis can be found in Appendix B. Besides the reference architectures, we consider the following baselines and popular state-of-the-art architectures.

**RNN:**: a global univariate RNN sharing the same parameters across the time series.
**FC-RNN:**: a multivariate RNN taking as input the time series as if they were a multivariate one.
**LocalRNNs:**: local univariate RNNs with different sets of parameters for each time series.
**DCRNN [6]:**: a recurrent T&S model with the Diffusion Convolutional operator.
**AGCRN [11]:**: the T&S global-local Adaptive Graph Convolutional Recurrent Network.
**GraphWaveNet:**: the deep T&S spatiotemporal convolutional network by Wu et al. [39].

We also consider a global-local RNN, in which we specialize the model by using node embeddings in the encoder. Note that among the methods selected from the literature only DCRNN can be considered fully global (see Sec. 6). Performance is measured in terms of _mean absolute error_ (MAE).

Synthetic dataWe start by assessing the performance of hybrid global-local spatiotemporal models in a controlled environment, considering a variation of GP-VAR [52], a synthetic dataset based on a polynomial graph filter [53], that we modify to include local effects. In particular, data are generated from the spatiotemporal process

\[\bm{H}_{t} =\sum_{l=1}^{L}\sum_{q=1}^{Q}\Theta_{q,l}\bm{A}^{l-1}\bm{X}_{t-q},\] \[\bm{X}_{t+1} =\bm{a}\odot\tanh\left(\bm{H}_{t}\right)+\bm{b}\odot\tanh\left( \bm{X}_{t-1}\right)+\eta_{t},\] (20)

where \(\bm{\Theta}\in\mathbb{R}^{Q\times L}\), \(\bm{a}\in\mathbb{R}^{N}\), \(\bm{b}\in\mathbb{R}^{N}\) and \(\eta_{t}\sim\mathcal{N}(\bm{0},\sigma^{2}\mathbb{I})\). We refer to this dataset as GPVAR-L: note that \(\bm{a}\) and \(\bm{b}\) are node-specific parameters that inject local effects into the spatiotemporal process. We indicate simply as GPVAR the process obtained by fixing \(\bm{a}=\bm{b}=\bm{0.5}\), i.e., by removing local effects. We use as the adjacency matrix the community graph used in prior works, increasing the number of nodes to \(120\) (see Appendix A.1).

Tab. 2 shows forecasting accuracy for reference architectures with a \(6\)-steps window on data generated from the processes. In the setting with no local effects, all STGNNs achieve performance close to the theoretical optimum, outperforming global and local univariate models but also the multivariate FC-RNN that - without any inductive bias - struggles to properly fit the data. In GPVAR-L, global and univariate models fail to match the performance of STGNNs that include local components (**S1**); interestingly, the global model with anisotropic MP outperforms the isotropic alternative, suggesting that the more advanced MP schemes can lead to more effective state identification.

BenchmarksWe then compare the performance of reference architectures and baselines with and without node embeddings at the encoding and decoding steps. Note that, while reference architectures and DCRNN are purely global models, GraphWaveNet and AGCRN use node embeddings to obtain an adjacency matrix for MP. AGCRN, furthermore, uses embeddings to make the convolutional filters

\begin{table}
\begin{tabular}{c|c c} \hline \hline Models & GPVAR & GPVAR-L \\ \hline FC-RNN & 4393\(\pm\)0024 & 5978\(\pm\)0109 \\ LocalRNNs & -4047\(\pm\)0001 &.4610\(\pm\)0003 \\ \hline \multirow{4}{*}{\begin{tabular}{c} \end{tabular} } & RNN & 3999\(\pm\)0000 & 5440\(\pm\)0003 \\  & TTS-IMP & 3232\(\pm\)0002 &.4059\(\pm\)0002 \\  & TTS-AMP & 3193\(\pm\)0000 & 3587\(\pm\)0009 \\ \hline \multirow{4}{*}{
\begin{tabular}{c} \end{tabular} } & RNN & 3991\(\pm\)0001 &.4612\(\pm\)0003 \\  & TTS-IMP & 3195\(\pm\)0000 &.3200\(\pm\)0002 \\  & TTS-AMP & 3194\(\pm\)0001 &.3199\(\pm\)0001 \\ \hline Optimal model &.3192 &.3192 \\ \hline \hline \end{tabular}
\end{table}
Table 2: One-step-ahead forecasting error (MAE) of the different models in GPVAR datasets (5 runs).

\begin{table}
\begin{tabular}{c|c c|c c c c} \hline \hline  & \multicolumn{3}{c|}{Global} & \multicolumn{3}{c}{Embeddings} \\ \hline \(W\) & \(d_{h}=16\) & \(d_{h}=32\) & \(d_{h}=64\) & \(d_{h}=16\) & \(d_{h}=32\) & \(d_{h}=64\) \\ \hline
2 & 5371\(\pm\)0014 & 4679\(\pm\)0016 & 4124\(\pm\)0021 & 3198\(\pm\)0001 &.3199\(\pm\)0001 &.3203\(\pm\)0001 \\
6 & 4059\(\pm\)0023 & 3578\(\pm\)0031 &.3365\(\pm\)0006 & 3200\(\pm\)0002 &.3201\(\pm\)0001 &.3209\(\pm\)0002 \\
12 & 3672\(\pm\)0035 & 3362\(\pm\)0012 &.3280\(\pm\)0003 &.3200\(\pm\)001 &.3200\(\pm\)0006 &.3211\(\pm\)001 \\
24 &.3485\(\pm\)0002 &.3286\(\pm\)0005 &.3250\(\pm\)001 &.3200\(\pm\)0002 &.3200\(\pm\)0006 &.3211\(\pm\)001 \\ \hline \hline \end{tabular}
\end{table}
Table 3: TTS-IMP one-step-ahead MAE on GPVAR-L with varying window length \(W\) and capacity \(d_{h}\) (5 runs).

adaptive w.r.t. the node being processed. We evaluate all models on real-world datasets from three different domains: traffic networks, energy analytics, and air quality monitoring. Besides the already introduced traffic forecasting benchmarks (**METR-LA** and **PEMS-BAY**), we run experiments on smart metering data from the **CER-E** dataset [54] and air quality measurements from **AQI**[55] by using the same pre-processing steps and data splits of previous works [20, 47]. The full experimental setup is reported in appendix A. Tab. 4 reports forecasting _mean absolute error_ (MAE) averaged over the forecasting horizon. Global-local reference models outperform the fully global variants in every considered scenario (**S1**). A similar observation can be made for the state-of-art architectures, where the impact of node embeddings (at encoding and decoding) is large for the fully global DCRNN and more contained in models already equipped with local components. Note that hyperparameters were not tuned to account for the change in architecture. Surprisingly, the simple TTS-IMP model equipped with node embeddings achieves results comparable to that of state-of-the-art STGNNs with a significantly lower number of parameters and a streamlined architecture. Interestingly, while both global and local RNNs models fail, the hybrid global-local RNN ranks among the best-performing models, outperforming graph-based models without node embeddings in most settings.

Structured embeddingsTo test the hypothesis that structure in embedding space provides insights on the local effects at play (**S5**), we consider the clustering regularization method (Sec. 5.1) and the reference TTS-IMP model trained on the CER-E dataset. We set the number of learned centroids to \(K=5\) and train the cluster assignment mechanism end-to-end with the forecasting architecture. Then, we inspect the clustering assignment by looking at intra-cluster statistics. In particular, for each load profile, we compute the weekly average load curve, and, for each hour, we look at quantiles of the energy consumption within each cluster. Fig. 0(a) shows the results of the analysis by reporting the _median_ load profile for each cluster; shaded areas correspond to quantiles with \(10\%\) increments. Results show that users in the different clusters have distinctly different consumption patterns. Fig. 0(b)

\begin{table}
\begin{tabular}{c|c c c c|c c c} \hline \hline Models & **METR-LA** & **PEMS-BAY** & **CER-E** & **AQI** & **METR-LA** & **PEMS-BAY** & **CER-E** & **AQI** \\ \hline \hline Reference arch. & \multicolumn{4}{c|}{Global models} & \multicolumn{4}{c}{Global-local models (with embeddings)} \\ \hline RNN & 3.54\({}_{\pm 0.0}\) & 1.77\({}_{\pm 0.0}\) & 456.98\({}_{\pm 0.61}\) & 14.02\({}_{\pm 0.4}\) & **3.15\({}_{\pm 0.3}\)** & **1.59\({}_{\pm 0.0}\)** & **421.50\({}_{\pm 1.78}\)** & **13.73\({}_{\pm 0.4}\)** \\ \hline T\&S-IMP & 3.35\({}_{\pm 0.01}\) & 1.70\({}_{\pm 0.01}\) & 443.85\({}_{\pm 0.99}\) & 12.87\({}_{\pm 0.2}\) & **3.10\({}_{\pm 0.01}\)** & **1.59\({}_{\pm 0.00}\)** & **417.71\({}_{\pm 1.28}\)** & **12.48\({}_{\pm 0.33}\)** \\ TTS-IMP & 3.34\({}_{\pm 0.01}\) & 1.72\({}_{\pm 0.00}\) & 439.13\({}_{\pm 0.51}\) & 12.74\({}_{\pm 0.2}\) & **3.08\({}_{\pm 0.01}\)** & **1.58\({}_{\pm 0.00}\)** & **412.44\({}_{\pm 1.20}\)** & **12.33\({}_{\pm 0.22}\)** \\ T\&S-AMP & 3.22\({}_{\pm 0.02}\) & 1.65\({}_{\pm 0.00}\) & N/A & N/A & **3.07\({}_{\pm 0.02}\)** & **1.59\({}_{\pm 0.00}\)** & N/A & N/A \\ TTS-AMP & 3.24\({}_{\pm 0.01}\) & 1.66\({}_{\pm 0.00}\) & 431.33\({}_{\pm 0.68}\) & 12.30\({}_{\pm 0.02}\) & **3.06\({}_{\pm 0.01}\)** & **1.58\({}_{\pm 0.01}\)** & **412.95\({}_{\pm 1.28}\)** & **12.15\({}_{\pm 0.22}\)** \\ \hline \hline Baseline arch. & \multicolumn{4}{c|}{Original} & \multicolumn{4}{c}{Embeddings at Encoder and Decoder} \\ \hline DCRNN & 3.22\({}_{\pm 0.01}\) & 1.64\({}_{\pm 0.00}\) & 428.36\({}_{\pm 1.23}\) & 12.96\({}_{\pm 0.03}\) & **3.07\({}_{\pm 0.02}\)** & **1.60\({}_{\pm 0.00}\)** & **412.87\({}_{\pm 1.51}\)** & **12.53\({}_{\pm 0.02}\)** \\ GraphWaveNet & 3.05\({}_{\pm 0.03}\) & **1.56\({}_{\pm 0.01}\)** & **397.17\({}_{\pm 0.67}\)** & 12.08\({}_{\pm 1.1}\) & **2.99\({}_{\pm 0.02}\)** & 1.58\({}_{\pm 0.00}\) & 401.15\({}_{\pm 1.49}\)** & **11.81\({}_{\pm 0.04}\)** \\ AGCRN & 3.16\({}_{\pm 0.01}\) & **1.61\({}_{\pm 0.00}\)** & 444.80\({}_{\pm 1.25}\) & 13.33\({}_{\pm 0.02}\) & **3.14\({}_{\pm 0.00}\)** & 1.62\({}_{\pm 0.00}\)** & **436.84\({}_{\pm 2.06}\)** & **13.28\({}_{\pm 0.03}\)** \\ \hline \hline \end{tabular}
\end{table}
Table 4: Forecasting error (MAE) on \(4\) benchmark datasets (5 runs). The best result between each model and its variant with embeddings is in **bold**. N/A indicates runs exceeding resource capacity.

Figure 1: Time series clusters in CER-E, obtained by regularizing the embedding space. **(a)** Average load for each clusters. **(b)** t-SNE plot of the corresponding node embeddings.

shows a 2D t-SNE visualization of the learned node embeddings, providing a view of the latent space and the effects of the cluster-based regularization.

TransferIn this experiment, we consider the scenario in which an STGNN for traffic forecasting is trained by using data from multiple traffic networks and then used to make predictions for a disjoint set of sensors sampled from the same region. We use the **PEMS03**, **PEMS04**, **PEMS07**, and **PEMS08** datasets [56], which contain measurements from \(4\) different districts in California. We train models on \(3\) of the datasets, fine-tune on \(1\) week of data from the target left-out dataset, validate on the following week, and test on the week thereafter. We compare variants of TTS-IMP with and without embeddings fed into encoder and decoder. Together with the unconstrained embeddings, we also consider the variational and clustering regularization approaches introduced in Sec. 5.1. At the fine-tuning stage, the global model updates all of its parameters, while in the hybrid global-local approaches only the embeddings are fitted to the new data. Tab. 5 reports results for the described scenario. The fully global approach is outperformed by the hybrid architectures in all target datasets (**S4**). Besides the significant improvement in performance, adjusting only node embeddings retains performance on the source datasets. Furthermore, results show the positive effects of regularizing the embedding space in the transfer setting (**S5**). This is further confirmed by results in Tab. 6, which report, for PEMS04, how forecasting error changes in relation to the length of the fine-tuning window. We refer to Appendix B for an in-depth analysis of several additional transfer learning scenarios.

## 8 Conclusions

We investigate the impact of locality and globality in graph-based spatiotemporal forecasting architectures. We propose a framework to explain empirical results associated with the use of trainable node embeddings and discuss different architectures and regularization techniques to account for local effects. The proposed methodologies are thoroughly empirically validated and, although not inductive, prove to be effective in a transfer learning context. We argue that our work provides necessary and key methodologies for the understanding and design of effective graph-based spatiotemporal forecasting architectures. Future works can build on the results presented here and study alternative, and even more transferable, methods to account for local effects.

## Acknowledgements

This research was partly funded by the Swiss National Science Foundation under grant 204061: _High-Order Relations and Dynamics in Graph Neural Networks_.

\begin{table}
\begin{tabular}{c|c c c c} \hline \hline Model & \multicolumn{4}{c}{Training set size} \\ \hline TTS-IMP & 2 weeks & 1 week & 3 days & 1 day \\ \hline Global & 20.86 \(\pm\) 0.03 & 21.59 \(\pm\) 0.11 & 21.84 \(\pm\) 0.06 & 22.26 \(\pm\) 0.10 \\ \hline Embeddings & 19.96 \(\pm\) 0.08 & 20.27 \(\pm\) 0.11 & 21.03 \(\pm\) 0.14 & 21.99 \(\pm\) 0.13 \\ – Variational & 19.94 \(\pm\) 0.08 & 20.19 \(\pm\) 0.05 & 20.71 \(\pm\) 0.12 & **21.20 \(\pm\) 0.15** \\ – Clustering & **19.69 \(\pm\) 0.06** & **19.91 \(\pm\) 0.11** & **20.48 \(\pm\) 0.09** & 21.91 \(\pm\) 0.21 \\ \hline \hline \end{tabular}
\end{table}
Table 6: Forecasting error (MAE) on PEMS04 in the transfer learning setting by varying fine-tuning set size (5 runs average).

\begin{table}
\begin{tabular}{c|c|c c c c} \hline \hline \multicolumn{2}{c|}{} & TTS-IMP & PEMS03 & PEMS04 & PEMS07 & PEMS08 \\ \hline \multirow{3}{*}{
\begin{tabular}{c} **Event** \\ **T-Wave** \\ \end{tabular} } & Global & 15.30 \(\pm\) 0.03 & 21.59 \(\pm\) 0.11 & 23.82 \(\pm\) 0.03 & 15.90 \(\pm\) 0.07 \\ \cline{2-6}  & Embeddings & 14.64 \(\pm\) 0.05 & 20.27 \(\pm\) 0.11 & **22.23 \(\pm\) 0.08** & **15.45 \(\pm\) 0.06** \\  & – Variational & **14.56 \(\pm\) 0.03** & 20.19 \(\pm\) 0.05 & 22.43 \(\pm\) 0.02 & **15.41 \(\pm\) 0.06** \\  & – Clustering & **14.60 \(\pm\) 0.02** & **19.91 \(\pm\) 0.11** & **22.16 \(\pm\) 0.07** & **15.41 \(\pm\) 0.06** \\ \hline \hline \multicolumn{2}{c|}{Zero-shot} & 18.20 \(\pm\) 0.09 & 23.88 \(\pm\) 0.08 & 32.76 \(\pm\) 0.69 & 20.41 \(\pm\) 0.07 \\ \hline \hline \end{tabular}
\end{table}
Table 5: Forecasting error (MAE) in the transfer learning setting (5 runs average). Results refer to a 1-week fine-tuning set size on all PEMS datasets.

## References

* Benidis et al. [2022] Konstantinos Benidis, Syama Sundar Rangapuram, Valentin Flunkert, Yuyang Wang, Danielle Maddix, Caner Turkmen, Jan Gasthaus, Michael Bohlke-Schneider, David Salinas, Lorenzo Stella, Francois-Xavier Aubet, Laurent Callot, and Tim Januschowski. Deep learning for time series forecasting: Tutorial and literature survey. _ACM Comput. Surv._, 55(6), dec 2022. ISSN 0360-0300. doi: 10.1145/3533382. URL https://doi.org/10.1145/3533382.
* Bacciu et al. [2020] Davide Bacciu, Federico Errica, Alessio Micheli, and Marco Podda. A gentle introduction to deep learning for graphs. _Neural Networks_, 129:203-221, 2020.
* Stankovic et al. [2020] Ljubisa Stankovic, Danilo Mandic, Milos Dakovic, Milos Brajovic, Bruno Scalzo, Shengxi Li, Anthony G Constantinides, et al. Data analytics on graphs part iii: machine learning on graphs, from graph topology to applications. _Foundations and Trends(r) in Machine Learning_, 13(4):332-530, 2020.
* Bronstein et al. [2021] Michael M Bronstein, Joan Bruna, Taco Cohen, and Petar Velickovic. Geometric deep learning: Grids, groups, graphs, geodesics, and gauges. _arXiv preprint arXiv:2104.13478_, 2021.
* Seo et al. [2018] Youngjoo Seo, Michael Defferrard, Pierre Vandergheynst, and Xavier Bresson. Structured sequence modeling with graph convolutional recurrent networks. In _International Conference on Neural Information Processing_, pages 362-373. Springer, 2018.
* Li et al. [2018] Yaguang Li, Rose Yu, Cyrus Shahabi, and Yan Liu. Diffusion convolutional recurrent neural network: Data-driven traffic forecasting. In _International Conference on Learning Representations_, 2018.
* Yu et al. [2018] Bing Yu, Haoteng Yin, and Zhanxing Zhu. Spatio-temporal graph convolutional networks: a deep learning framework for traffic forecasting. In _Proceedings of the 27th International Joint Conference on Artificial Intelligence_, pages 3634-3640, 2018.
* Eandi et al. [2022] Simone Eandi, Andrea Cini, Slobodan Lukovic, and Cesare Alippi. Spatio-temporal graph neural networks for aggregate load forecasting. In _2022 International Joint Conference on Neural Networks (IJCNN)_, pages 1-8. IEEE, 2022.
* Hansen et al. [2022] Jonas Berg Hansen, Stian Normann Anfinsen, and Filippo Maria Bianchi. Power flow balancing with decentralized graph neural networks. _IEEE Transactions on Power Systems_, 2022.
* Ortega et al. [2018] Antonio Ortega, Pascal Frossard, Jelena Kovacevic, Jose MF Moura, and Pierre Vandergheynst. Graph signal processing: Overview, challenges, and applications. _Proceedings of the IEEE_, 106(5):808-828, 2018.
* Bai et al. [2020] Lei Bai, Lina Yao, Can Li, Xianzhi Wang, and Can Wang. Adaptive graph convolutional recurrent network for traffic forecasting. _Advances in Neural Information Processing Systems_, 33:17804-17815, 2020.
* Deng and Hooi [2021] Ailin Deng and Bryan Hooi. Graph neural network-based anomaly detection in multivariate time series. In _Proceedings of the AAAI Conference on Artificial Intelligence_, volume 35, pages 4027-4035, 2021.
* Montero-Mango and Hyndman [2021] Pablo Montero-Mango and Rob J Hyndman. Principles and algorithms for forecasting groups of time series: Locality and globality. _International Journal of Forecasting_, 37(4):1632-1653, 2021.
* Januschowski et al. [2020] Tim Januschowski, Jan Gasthaus, Yuyang Wang, David Salinas, Valentin Flunkert, Michael Bohlke-Schneider, and Laurent Callot. Criteria for classifying forecasting methods. _International Journal of Forecasting_, 36(1):167-177, 2020.
* Ruiz et al. [2020] Luana Ruiz, Luiz Chamon, and Alejandro Ribeiro. Graphon neural networks and the transferability of graph neural networks. _Advances in Neural Information Processing Systems_, 33:1702-1712, 2020.
* Gao and Ribeiro [2022] Jianfei Gao and Bruno Ribeiro. On the equivalence between temporal and static equivariant graph representations. In _International Conference on Machine Learning_, pages 7052-7076. PMLR, 2022.

* Cini et al. [2023] Andrea Cini, Daniele Zambon, and Cesare Alippi. Sparse graph learning from spatiotemporal time series. _Journal of Machine Learning Research_, 24(242):1-36, 2023.
* Chung et al. [2014] Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of gated recurrent neural networks on sequence modeling. _arXiv preprint arXiv:1412.3555_, 2014.
* Gilmer et al. [2017] Justin Gilmer, Samuel S Schoenholz, Patrick F Riley, Oriol Vinyals, and George E Dahl. Neural message passing for quantum chemistry. In _International conference on machine learning_, pages 1263-1272. PMLR, 2017.
* Cini et al. [2022] Andrea Cini, Ivan Marisca, and Cesare Alippi. Filling the g_ap_s: Multivariate time series imputation by graph neural networks. In _International Conference on Learning Representations_, 2022.
* Dwivedi et al. [2023] Vijay Prakash Dwivedi, Chaitanya K. Joshi, Anh Tuan Luu, Thomas Laurent, Yoshua Bengio, and Xavier Bresson. Benchmarking graph neural networks. _Journal of Machine Learning Research_, 24(43):1-48, 2023. URL http://jmlr.org/papers/v24/22-0567.html.
* Salinas et al. [2020] David Salinas, Valentin Flunkert, Jan Gasthaus, and Tim Januschowski. Deepar: Probabilistic forecasting with autoregressive recurrent networks. _International Journal of Forecasting_, 36(3):1181-1191, 2020.
* Kahn and Chase [2018] Kenneth B Kahn and Charles W Chase. The state of new-product forecasting. _Foresight: The International Journal of Applied Forecasting_, (51), 2018.
* Nt and Maehara [2019] Hoang Nt and Takanori Maehara. Revisiting graph neural networks: All we have is low-pass filters. _arXiv preprint arXiv:1905.09550_, 2019.
* Oono and Suzuki [2020] Kenta Oono and Taiji Suzuki. Graph neural networks exponentially lose expressive power for node classification. In _International Conference on Learning Representations_, 2020.
* Zhou et al. [2003] Dengyong Zhou, Olivier Bousquet, Thomas Lal, Jason Weston, and Bernhard Scholkopf. Learning with local and global consistency. _Advances in neural information processing systems_, 16, 2003.
* Kipf and Welling [2017] Thomas N. Kipf and Max Welling. Semi-supervised classification with graph convolutional networks. In _International Conference on Learning Representations (ICLR)_, 2017.
* Kingma and Welling [2013] Diederik P Kingma and Max Welling. Auto-encoding variational bayes. In _Proceedings of International Conference on Learning Representations_, 2013.
* Yang et al. [2017] Bo Yang, Xiao Fu, Nicholas D Sidiropoulos, and Mingyi Hong. Towards k-means-friendly spaces: Simultaneous deep learning and clustering. In _international conference on machine learning_, pages 3861-3870. PMLR, 2017.
* Maddison et al. [2017] C Maddison, A Mnih, and Y Teh. The concrete distribution: A continuous relaxation of discrete random variables. In _International Conference on Learning Representations_, 2017.
* Sanchez-Gonzalez et al. [2020] Alvaro Sanchez-Gonzalez, Jonathan Godwin, Tobias Pfaff, Rex Ying, Jure Leskovec, and Peter Battaglia. Learning to simulate complex physics with graph networks. In _International conference on machine learning_, pages 8459-8468. PMLR, 2020.
* Huang et al. [2020] Zijie Huang, Yizhou Sun, and Wei Wang. Learning continuous system dynamics from irregularly-sampled partial observations. _Advances in Neural Information Processing Systems_, 33:16177-16187, 2020.
* Wen et al. [2022] Song Wen, Hao Wang, and Dimitris Metaxas. Social ode: Multi-agent trajectory forecasting with neural ordinary differential equations. In _European Conference on Computer Vision_, pages 217-233. Springer, 2022.
* Xu et al. [2020] Da Xu, Chuanwei Ruan, Evren Korpeoglu, Sushant Kumar, and Kannan Achan. Inductive representation learning on temporal graphs. _International Conference on Learning Representations_, 2020.

* Kazemi et al. [2020] Seyed Mehran Kazemi, Rishab Goel, Kshitij Jain, Ivan Kobyzev, Akshay Sethi, Peter Forsyth, and Pascal Poupart. Representation learning for dynamic graphs: A survey. _The Journal of Machine Learning Research_, 21(1):2648-2720, 2020.
* Longa et al. [2023] Antonio Longa, Veronica Lachi, Gabriele Santin, Monica Bianchini, Bruno Lepri, Pietro Lio, franco scarselli, and Andrea Passerini. Graph neural networks for temporal graphs: State of the art, open challenges, and opportunities. _Transactions on Machine Learning Research_, 2023. ISSN 2835-8856. URL https://openreview.net/forum?id=pHCdMat0gI.
* Grattarola et al. [2019] Daniele Grattarola, Daniele Zambon, Lorenzo Livi, and Cesare Alippi. Change detection in graph streams by learning graph embeddings on constant-curvature manifolds. _IEEE Transactions on neural networks and learning systems_, 31(6):1856-1869, 2019.
* Paassen et al. [2020] Benjamin Paassen, Daniele Grattarola, Daniele Zambon, Cesare Alippi, and Barbara Eva Hammer. Graph edit networks. In _International Conference on Learning Representations_, 2020.
* Wu et al. [2019] Zonghan Wu, Shirui Pan, Guodong Long, Jing Jiang, and Chengqi Zhang. Graph wavenet for deep spatial-temporal graph modeling. In _Proceedings of the 28th International Joint Conference on Artificial Intelligence_, pages 1907-1913, 2019.
* Zhang et al. [2018] Jiani Zhang, Xingjian Shi, Junyuan Xie, Hao Ma, Irwin King, and Dit Yan Yeung. Gaan: Gated attention networks for learning on large and spatiotemporal graphs. In _34th Conference on Uncertainty in Artificial Intelligence 2018, UAI 2018_, 2018.
* Zheng et al. [2020] Chuanpan Zheng, Xiaoliang Fan, Cheng Wang, and Jianzhong Qi. Gman: A graph multi-attention network for traffic prediction. In _Proceedings of the AAAI conference on artificial intelligence_, volume 34, pages 1234-1241, 2020.
* Wu et al. [2022] Zonghan Wu, Da Zheng, Shirui Pan, Quan Gan, Guodong Long, and George Karypis. Traversenet: Unifying space and time in message passing for traffic forecasting. _IEEE Transactions on Neural Networks and Learning Systems_, 2022.
* Chen et al. [2021] Hongjie Chen, Ryan A. Rossi, Kanak Mahadik, Sungchul Kim, and Hoda Eldardiry. Graph deep factors for forecasting with applications to cloud resource allocation. In _Proceedings of the 27th ACM SIGKDD Conference on Knowledge Discovery and Data Mining_, KDD '21, page 106-116, New York, NY, USA, 2021. Association for Computing Machinery. ISBN 9781450383325. doi: 10.1145/3447548.3467357. URL https://doi.org/10.1145/3447548.3467357.
* Wang et al. [2019] Yuyang Wang, Alex Smola, Danielle Maddix, Jan Gasthaus, Dean Foster, and Tim Januschowski. Deep factors for forecasting. In _International conference on machine learning_, pages 6607-6617. PMLR, 2019.
* Shang and Chen [2021] Chao Shang and Jie Chen. Discrete graph structure learning for forecasting multiple time series. In _Proceedings of International Conference on Learning Representations_, 2021.
* Satorras et al. [2022] Victor Garcia Satorras, Syama Sundar Rangapuram, and Tim Januschowski. Multivariate time series forecasting with latent graph inference. _arXiv preprint arXiv:2203.03423_, 2022.
* Marisca et al. [2022] Ivan Marisca, Andrea Cini, and Cesare Alippi. Learning to reconstruct missing data from spatiotemporal graphs with sparse observations. _Advances in Neural Information Processing Systems_, 35:32069-32082, 2022.
* Shao et al. [2022] Zezhi Shao, Zhao Zhang, Fei Wang, Wei Wei, and Yongjun Xu. Spatial-temporal identity: A simple yet effective baseline for multivariate time series forecasting. In _Proceedings of the 31st ACM International Conference on Information & Knowledge Management_, page 4454-4458, 2022.
* Yin et al. [2022] Xueyan Yin, Feifan Li, Yanming Shen, Heng Qi, and Baocai Yin. Nodetrans: A graph transfer learning approach for traffic prediction. _arXiv preprint arXiv:2207.01301_, 2022.
* Sen et al. [2019] Rajat Sen, Hsiang-Fu Yu, and Inderjit S Dhillon. Think globally, act locally: A deep neural network approach to high-dimensional time series forecasting. _Advances in neural information processing systems_, 32, 2019.

* Bai et al. [2018] Shaojie Bai, J Zico Kolter, and Vladlen Koltun. An empirical evaluation of generic convolutional and recurrent networks for sequence modeling. _arXiv preprint arXiv:1803.01271_, 2018.
* Zambon and Alippi [2022] Daniele Zambon and Cesare Alippi. AZ-whiteness test: a test for uncorrelated noise on spatio-temporal graphs. _Advances in Neural Information Processing Systems_, 35:11975-11986, 2022.
* Isufi et al. [2019] Elvin Isufi, Andreas Loukas, Nathanael Perraudin, and Geert Leus. Forecasting time series with VARMA recursions on graphs. _IEEE Transactions on Signal Processing_, 67(18):4870-4885, 2019.
* Electricity Customer Behaviour Trial, 2009-2010 [dataset]. _Irish Social Science Data Archive. SN: 0012-00_, 2016. URL https://www.ucd.ie/issda/data/commissionforenergyregulationcer.
* Zheng et al. [2015] Yu Zheng, Xiuwen Yi, Ming Li, Ruiyuan Li, Zhangqing Shan, Eric Chang, and Tianrui Li. Forecasting fine-grained air quality based on big data. In _Proceedings of the 21th ACM SIGKDD international conference on knowledge discovery and data mining_, pages 2267-2276, 2015.
* Guo et al. [2021] Shengnan Guo, Youfang Lin, Huaiyu Wan, Xiucheng Li, and Gao Cong. Learning dynamics and heterogeneity of spatial-temporal graph data for traffic forecasting. _IEEE Transactions on Knowledge and Data Engineering_, 34(11):5415-5428, 2021.
* Van Rossum and Drake [2009] Guido Van Rossum and Fred L. Drake. _Python 3 Reference Manual_. CreateSpace, Scotts Valley, CA, 2009. ISBN 1441412697.
* Paszke et al. [2019] Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan, Trevor Killeen, Zeming Lin, Natalia Gimelshein, Luca Antiga, Alban Desmaison, Andreas Kopf, Edward Yang, Zachary DeVito, Martin Raison, Alykhan Tejani, Sasank Chilamkurthy, Benoit Steiner, Lu Fang, Junjie Bai, and Soumith Chintala. Pytorch: An imperative style, high-performance deep learning library. In H. Wallach, H. Larochelle, A. Beygelzimer, F. d'Alche-Buc, E. Fox, and R. Garnett, editors, _Advances in Neural Information Processing Systems 32_, pages 8024-8035. Curran Associates, Inc., 2019.
* Falcon and Lightning team [2019] William Falcon and The PyTorch Lightning team. PyTorch Lightning, 3 2019. URL https://github.com/PyTorchLightning/pytorch-lightning.
* Fey and Lenssen [2019] Matthias Fey and Jan Eric Lenssen. Fast graph representation learning with pytorch geometric. _arXiv preprint arXiv:1903.02428_, 2019.
* Cini and Marisca [2022] Andrea Cini and Ivan Marisca. Torch Spatiotemporal, 3 2022. URL https://github.com/TorchSpatiotemporal/tsl.
* Harris et al. [2020] Charles R Harris, K Jarrod Millman, Stefan J Van Der Walt, Ralf Gommers, Pauli Virtanen, David Cournapeau, Eric Wieser, Julian Taylor, Sebastian Berg, Nathaniel J Smith, et al. Array programming with numpy. _Nature_, 585(7825):357-362, 2020.
* Pedregosa et al. [2011] Fabian Pedregosa, Gael Varoquaux, Alexandre Gramfort, Vincent Michel, Bertrand Thirion, Olivier Grisel, Mathieu Blondel, Peter Prettenhofer, Ron Weiss, Vincent Dubourg, et al. Scikit-learn: Machine learning in python. _Journal of Machine Learning Research_, 12:2825-2830, 2011.
* Chen et al. [2001] Chao Chen, Karl Petty, Alexander Skabardonis, Pravin Varaiya, and Zhanfeng Jia. Freeway performance measurement system: mining loop detector data. _Transportation Research Record_, 1748(1):96-102, 2001.
* Cini et al. [2022] Andrea Cini, Ivan Marisca, Filippo Maria Bianchi, and Cesare Alippi. Scalable spatiotemporal graph neural networks. In _NeurIPS 2022 Temporal Graph Learning Workshop_, 2022.
* Yi et al. [2016] Xiuwen Yi, Yu Zheng, Junbo Zhang, and Tianrui Li. St-mvl: filling missing values in geosensory time series data. In _Proceedings of the 25th International Joint Conference on Artificial Intelligence_, 2016.
* Kingma and Ba [2015] Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. _3nd International Conference on Learning Representations, ICLR 2015_, 2015.

## Appendix

The following sections provide additional details on the experimental setting and computational platform used to gather the results presented in the paper. Additionally, we also include supplementary empirical results and analysis.

## Appendix A Experimental setup

Experimental setup and baselines have been developed with Python [57] by relying on the following open-source libraries:

* PyTorch [58];
* PyTorch Lightning [59];
* PyTorch Geometric [60]
* Torch Spatiotemporal [61];
* numpy [62];
* scikit-learn [63].

Experiments were run on a workstation equipped with AMD EPYC 7513 processors and four NVIDIA RTX A5000 GPUs. The code needed to reproduce the reported results is available online2.

Footnote 2: https://github.com/Graph-Machine-Learning-Group/taming-local-effects-stgnns

### Datasets

In this section, we provide additional information regarding each one of the considered datasets. Tab. 7 reports a summary of statistics.

Gpvar(-L)For the GPVAR datasets we follow the procedure described in Sec. 7 to generate data and then partition the resulting time series in \(70\%/10\%/20\%\) splits for training, validation and testing, respectively. For GPVAR-L the parameters of the spatiotemporal process are set as

\[\Theta=\left[\begin{smallmatrix}2.5&-2.0&-0.5\\ 1.0&3.0&0.0\end{smallmatrix}\right],\qquad\bm{a},\bm{b}\sim\mathcal{U}\left(-2,2\right),\]

\[\eta\sim\mathcal{N}(\bm{0},\text{diag}(\sigma^{2})),\quad\sigma=0.4.\]

Fig. 2 shows the topology of the graph used as a support to the process. In particular, we considered a network with \(120\) nodes with \(20\) communities and added self-loops to the graph adjacency matrix.

\begin{table}
\begin{tabular}{l|c c c c c} \hline \hline Datasets & Type & Time steps & Nodes & Edges & Rate \\ \hline GPVAR & Undirected & 30,000 & 120 & 199 & N/A \\ GPVAR-L & Undirected & 30,000 & 120 & 199 & N/A \\ \hline METR-LA & Directed & 34,272 & 207 & 1515 & 5 minutes \\ PEMS-BAY & Directed & 52,128 & 325 & 2369 & 5 minutes \\ CER-E & Directed & 25,728 & 485 & 4365 & 30 minutes \\ AQI & Undirected & 8,760 & 437 & 2699 & 1 hour \\ \hline PEMS03 & Directed & 26,208 & 358 & 546 & 5 minutes \\ PEMS04 & Directed & 16,992 & 307 & 340 & 5 minutes \\ PEMS07 & Directed & 28,224 & 883 & 866 & 5 minutes \\ PEMS08 & Directed & 17,856 & 170 & 277 & 5 minutes \\ \hline \hline \end{tabular}
\end{table}
Table 7: Statistics of datasets used in the experiments.

Spatiotemporal forecasting benchmarksWe considered several datasets coming from relevant application domains and different problem settings corresponding to real-world application scenarios.

Traffic forecastingWe consider two popular traffic forecasting datasets, namely **METR-LA** and **PEMS-BAY**[6], containing measurements from loop detectors in the Los Angeles County Highway and San Francisco Bay Area, respectively. For the experiment on transfer learning, we use the **PEMS03, PEMS04, PEMS07**, and **PEMS08** datasets from Guo et al. [56] each collecting traffic flow readings, aggregated into \(5\)-minutes intervals, from different areas in California provided by Caltrans Performance Measurement System (PeMS) [64].

Electric load forecastingWe selected the **CER-E** dataset [54], a collection of energy consumption readings, aggregated into \(30\)-minutes intervals, from \(485\) smart meters monitoring small and medium-sized enterprises.

Air quality monitoringThe **AQI**[55] dataset collects hourly measurements of pollutant PM2.5 from \(437\) air quality monitoring stations in China. Note that all of these datasets have been previously used for spatiotemporal forecasting and imputation [47; 65].

For each dataset, we obtain the corresponding adjacency matrix by following previous works [20; 6; 56]. We use as exogenous variables sinusoidal functions encoding the time of the day and the one-hot encoding of the day of the week. For datasets with an excessive number of missing values, namely METR-LA and AQI, we add as an exogenous variable also a binary mask indicating if the corresponding value has been imputed.

We split datasets into windows of \(W\) time steps, and train the models to predict the next \(H\) observations. For the experiment in Tab.4, we set \(W=12,H=12\) for the traffic datasets, \(W=48,H=6\) for CER-E, and \(W=24,H=3\) for AQI. Then, for all datasets except for AQI, we divide the obtained windows sequentially into \(70\%/10\%/20\%\) splits for training, validation, and testing, respectively. For AQI instead, we use as the test set the months of March, June, September, and December, following Yi et al. [66].

### Architectures

In this section, we provide a detailed description of the reference architectures used in the study.

Reference architecturesWe consider \(4\) simple STGNN architectures that follow the template given in (Eq. 9-11). In all the models, we use as Encoder (Eq. 9) a simple linear layer s.t.

\[\bm{h}_{t}^{i,0}=\bm{W}_{\text{enc}}\big{[}\bm{x}_{t-1}^{i}||\bm{u}_{t-1}^{i} \big{]}\] (21)

and as Decoder (Eq. 11) a \(2\) layer module structured as

\[\hat{\bm{x}}_{t:t+H}^{i}=\Big{\{}\bm{W}_{h}\xi\left(\bm{W}_{\text{dec}}\bm{h }_{t}^{i,L}\right)\Big{\}}_{h=1,\dots,H}\] (22)

where \(\bm{W}_{\text{enc}}\), \(\bm{W}_{\text{dec}}\), and \(\bm{W}_{1},\dots,\bm{W}_{H}\) are learnable parameters. In hybrid models with local Encoder and/or Decoder, we use different parameter matrices for each node, i.e.,

\[\bm{h}_{t}^{i,0} =\bm{W}_{\text{enc}}^{i}\big{[}\bm{x}_{t-1}^{i}\,||\,\bm{u}_{t-1} ^{i}\big{]}\] (23) \[\hat{\bm{x}}_{t:t+H}^{i} =\Big{\{}\bm{W}_{h}^{i}\xi\left(\bm{W}_{\text{dec}}\bm{h}_{t}^{i, L}\right)\Big{\}}_{h=1,\dots,H}\,.\] (24)

When instead node embeddings \(\bm{V}\in\mathbb{R}^{N\times d_{v}}\) are used to specialize the model, they are concatenated to the modules' input as

\[\bm{h}_{t}^{i,0} =\bm{W}_{\text{enc}}\big{[}\bm{x}_{t-1}^{i}\,||\,\bm{u}_{t-1}^{i} \,||\,\bm{v}^{i}\big{]}\] (25) \[\hat{\bm{x}}_{t:t+H}^{i} =\Big{\{}\bm{W}_{h}\xi\left(\bm{W}_{\text{dec}}\left[\bm{h}_{t}^{ i,L}\,||\,\bm{v}^{i}\right]\right)\Big{\}}_{h=1,\dots,H}\,.\] (26)

Figure 2: GPVAR community graph. We used a graph with \(20\) communities resulting in a network with \(120\) nodes.

For the TTS architectures, we define the STMP module (Eq. 10) as a node-wise GRU [18]:

\[\bm{r}_{t}^{i} =\sigma\big{(}\bm{W}_{1}^{l}\big{[}\bm{h}_{t}^{i,0}\,||\,\bm{h}_{t- 1}^{i,1}\big{]}\big{)},\] (27) \[\bm{o}_{t}^{i} =\sigma\big{(}\bm{W}_{2}^{l}\big{[}\bm{h}_{t}^{i,0}\,||\,\bm{h}_{t- 1}^{i,1}\big{]}\big{)},\] (28) \[\bm{c}_{t}^{i} =\text{tanh}\big{(}\bm{W}_{3}^{l}\big{[}\bm{h}_{t}^{i,0}\,||\,\bm {r}_{t}^{i}\bm{\wedge}\bm{h}_{t-1}^{i,1}\big{]}\big{)},\] (29) \[\bm{h}_{t}^{i,1} =\bm{o}_{t}^{i}\odot\bm{h}_{t-1}^{i,1}+(1-\bm{o}_{t}^{i})\odot \bm{c}_{t}^{i}.\] (30)

The GRU is then followed by \(L\) MP layers

\[\bm{H}_{t}^{l+1}=\text{MP}^{l}\left(\bm{H}_{t}^{l},\bm{A}\right),\quad l=1, \dots,L-1.\] (31)

We consider two variants for this architecture: **TTS-IMP**, featuring the isotropic MP operator defined in Eq. 5, and **TTS-AMP**, using the anisotropic MP operator defined in Eq. 6-7. Note that all the parameters in the STMP blocks are shared among the nodes.

In T&S models, instead, we use a GRU where gates are implemented using MP layers:

\[\bm{r}_{t}^{i,l} =\sigma\left(\text{MP}_{r}^{l}\left(\left[\bm{h}_{t}^{i,l-1}||\bm {h}_{t-1}^{i,l}\right],\bm{A}\right)\right),\] (32) \[\bm{o}_{t}^{i,l} =\sigma\left(\text{MP}_{o}^{l}\left(\left[\bm{h}_{t}^{i,l-1}||\bm {h}_{t-1}^{i,l}\right],\bm{A}\right)\right),\] (33) \[\bm{c}_{t}^{i,l} =\text{tanh}\left(\text{MP}_{c}^{l}\left(\left[\bm{h}_{t}^{i,l-1 }||\bm{r}_{t}^{i,l}\odot\bm{h}_{t-1}^{i,l}\right],\bm{A}\right)\right),\] (34) \[\bm{h}_{t}^{i,l} =\bm{o}_{t}^{i,l}\odot\bm{h}_{t-1}^{i,l}+(1-\bm{o}_{t}^{i,l}) \odot\bm{c}_{t}^{i,l}.\] (35)

Similarly to the TTS case, we indicate as **T&S-IMP** the reference architecture in which MP operators are isotropic and **T&S-AMP** the one featuring anisotropic MP.

BaselinesFor the RNN baselines we follow the same template of the reference architectures (Eq. 9-11) but use a single GRU cell as core processing module instead of the STMP block. The global-local **RNN**, then, uses node embeddings at encoding as shown in Eq. 25, whereas **LocalRNNs** have different sets of parameters for each time series. The **FC-RNN** architecture, instead, takes as input the concatenation all the time series as if they were a single multivariate one.

HyperparametersFor the reference TTS architectures we use a GRU with a single cell followed by \(2\) message-passing layers. In T&S case we use a single graph recurrent convolutional cell. The number of neurons in each layer is set to \(64\) and the embedding size to \(32\) for all the reference architectures in all the benchmark datasets. Analogous hyperparameters were used for the RNN baselines. For GPVAR instead, we use \(16\) and \(8\) as hidden and embedding sizes, respectively. For the baselines from the literature, we use the hyperparameters used in the original papers whenever possible.

For GPVAR experiments we use a batch size of \(128\) and train with early stopping for a maximum of \(200\) epochs with the Adam optimizer [67] and a learning rate of \(0.01\) halved every \(50\) epochs.

For experiments in Tab. 1 and 4, we instead trained the models with batch size \(64\) for a maximum of \(300\) epochs each consisting of maximum \(300\) batches. The initial learning rate was set to \(0.003\) and reduced every \(50\) epochs.

Transfer learning experimentIn the transfer learning experiments we simulate the case where a pre-trained spatiotemporal model for traffic forecasting is tested on a new road network. We fine-tune on each of the PEMS03-08 datasets models previously trained on the left-out \(3\) datasets. Following previous works [56], we split the datasets into \(60\%/20\%/20\%\) for training, validation, and testing, respectively. We obtain the mini-batches during training by uniformly sampling \(64\) windows from the \(3\) training sets. To train the models we use a similar experimental setting of experiments in Tab. 4, decreasing the number of epochs to \(150\) and increasing the batches per epoch to \(500\). We then assume that \(2\) weeks of readings from the target dataset are available for fine-tuning, and use the first week for training and the second one as the validation set. Then, we test fine-tuned models on the immediately following week (Tab. 5). For the global model, we either tune all the parameters or none of them (zero-shot setting). For fine-tuning, we increase the maximum number of epochs to \(2000\) without limiting the batches processed per epoch and fixing the learning rate to \(0.001\). At the end of every training epoch, we compute the MAE on the validation set and stop training if it has not decreased in the last \(100\) epochs, restoring the model weights corresponding to the best-performing model. For the global-local models with variational regularization on the embedding space, during training, we set \(\beta=0.05\) and initialize the distribution parameters as

\[\bm{\mu}_{i}\sim\mathcal{U}\left(-0.01,0.01\right),\qquad\bm{\sigma}_{i}=\bm{0. 2}.\]

For fine-tuning instead, we initialize the new embedding table \(\bm{V}^{\prime}\in\mathbb{R}^{N^{\prime}\times d_{v}}\) as

\[\bm{V}^{\prime}\sim\mathcal{U}\left(-\Delta,\Delta\right),\]

where \(\Delta=\frac{1}{\sqrt{d_{v}}}\) and remove the regularization loss. For the clustering regularization, instead, we use \(K=10\) clusters and regularization trade-off weight \(\lambda=0.5\). We initialize embedding, centroid, and cluster assignment matrices as

\[\bm{V}\sim\mathcal{U}\left(-\Delta,\Delta\right)\quad\bm{C}\sim\mathcal{U} \left(-\Delta,\Delta\right)\quad\bm{S}\sim\mathcal{U}\left(0,1\right)\]

respectively. For fine-tuning, we fix the centroid table \(\bm{C}\) and initialize the new embedding table \(\bm{V}^{\prime}\in\mathbb{R}^{N^{\prime}\times d_{v}}\) and cluster assignment matrix \(\bm{S}^{\prime}\in\mathbb{R}^{N^{\prime}\times K}\) following an analogous procedure. Finally, we increase the regularization weight \(\lambda\) to \(10\).

## Appendix B Additional experimental results

Local componentsTable 8, an extended version of Table 1, shows the performance of reference architecture with and without local components. Here we consider TTS-IMP and TTS-AMP, together with FC-RNN (a multivariate RNN) and LocalRNNs (local univariate RNNs with a different set of parameters for each time series). For the STGNNs, we consider a global variant (without any local component) and global-local alternatives, where we insert node-specific components within the architecture by means of (1) different sets of weights for each time series (light brown block) or (2) node embeddings (light gray block). More precisely, we show how performance varies when the local components are added in the encoding and decoding steps together, or uniquely in one of the two steps. Results for TTS-AMP are consistent with the observations made for TTS-IMP, showing that the use of local components enables improvements up to \(7\%\) w.r.t. the fully global variant.

Transfer learningTables 9 to 12 show additional results for the transfer learning experiments in all the target datasets. In particular, each table shows results for the reference architectures w.r.t. different training set sizes (from \(1\) day to \(2\) weeks) and considers the settings where embeddings are fed to both encoder and decoder or decoder only. We report results on the test data corresponding to the week after the validation set but also on the original test split used in the literature. In the last columns of the table, we also show the performance that one would have obtained \(100\) epochs after the minimum in the validation error curve; the purpose of showing these results is to hint at the performance that one would have obtained without holding out \(1\) week of data for validation. The results indeed suggest that fine-tuning the full global model is more prone to overfitting.

\begin{table}
\begin{tabular}{c|c|c|c} \hline \multicolumn{2}{c|}{**METR-LA**} & **PEMS-BAY** (\# weights) \\ \hline \multicolumn{2}{c|}{} & \multicolumn{2}{c}{TTS-IMP} \\ \hline \multicolumn{2}{c|}{Global TTS} & 3.35 \(\pm\)0.01 & 1.72 \(\pm\)0.00 & 4.71\(\times\)10\({}^{4}\) \\ \hline \multirow{4}{*}{\begin{tabular}{c} **C-AV** \\ \end{tabular} } & Encoder & 3.15 \(\pm\)0.01 & 1.66 \(\pm\)0.01 & 2.75\(\times\)10\({}^{5}\) \\  & Decoder & 3.09 \(\pm\)0.01 & 1.58 \(\pm\)0.00 & 3.00\(\times\)10\({}^{5}\) \\  & Enc. + Dec. & 3.16 \(\pm\)0.01 & 1.70 \(\pm\)0.01 & 5.28\(\times\)10\({}^{5}\) \\ \hline \multirow{4}{*}{\begin{tabular}{c} **C-AV** \\ \end{tabular} } & Encoder & 3.08 \(\pm\)0.01 & 1.58 \(\pm\)0.00 & 5.96\(\times\)10\({}^{4}\) \\  & Decoder & 3.13 \(\pm\)0.00 & 1.60 \(\pm\)0.00 & 5.96\(\times\)10\({}^{4}\) \\  & Enc. + Dec. & 3.07 \(\pm\)0.01 & 1.58 \(\pm\)0.00 & 6.16\(\times\)10\({}^{4}\) \\ \hline \hline \multicolumn{2}{c|}{FC-RNN} & 3.56 \(\pm\)0.03 & 2.32 \(\pm\)0.01 & 3.04\(\times\)10\({}^{5}\) \\ \hline \multicolumn{2}{c|}{LocalRNNs} & 3.69 \(\pm\)0.00 & 1.91 \(\pm\)0.00 & 1.10\(\times\)10\({}^{7}\) \\ \hline \end{tabular} 
\begin{tabular}{c} **METR-LA** \\ \hline \multicolumn{2}{c|}{TTS-AMP} \\ \hline \multicolumn{2}{c|}{3.27 \(\pm\)0.01} & 1.68 \(\pm\)0.00 & 6.41\(\times\)10\({}^{4}\) \\ \hline \multicolumn{2}{c|}{3.01 \(\pm\)0.00} & 1.64 \(\pm\)0.00 & 2.92\(\times\)10\({}^{5}\) \\  & 1.58 \(\pm\)0.00 & 3.17\(\times\)10\({}^{5}\) \\ \hline \multicolumn{2}{c|}{3.14 \(\pm\)0.01} & 1.69 \(\pm\)0.01 & 5.45\(\times\)10\({}^{5}\) \\ \hline \multicolumn{2}{c|}{3.05 \(\pm\)0.02} & 1.58 \(\pm\)0.01 & 7.66\(\times\)10\({}^{4}\) \\ \hline \multicolumn{2}{c|}{3.01 \(\pm\)0.00} & 1.60 \(\pm\)0.00 & 7.66\(\times\)10\({}^{4}\) \\ \hline \multicolumn{2}{c|}{3.04 \(\pm\)0.01} & 1.59 \(\pm\)0.01 & 7.86\(\times\)10\({}^{4}\) \\ \hline \end{tabular}
\end{table}
Table 8: Performance (MAE) of TTS-IMP and TTS-AMP variants and number of associated trainable parameters in PEMS-BAY (\(5\)-run average).

[MISSING_PAGE_FAIL:19]