# Revisiting Ensembling

in One-Shot Federated Learning

 Youssef Allouah\({}^{1}\) Akash Dhasade\({}^{1}\)1 Rachid Guerraoui\({}^{1}\) Nirupam Gupta\({}^{2}\)

Anne-Marie Kermarrec\({}^{1}\) Rafael Pinot\({}^{3}\) Rafael Pires\({}^{1}\) Rishi Sharma\({}^{1}\)

\({}^{1}\)EPFL \({}^{2}\)University of Copenhagen

\({}^{3}\)Sorbonne Universite and Universite Paris Cite, CNRS, LPSM

Footnote 1: Corresponding author <akash.dhasade@epfl.ch>

###### Abstract

Federated learning (FL) is an appealing approach to training machine learning models without sharing raw data. However, standard FL algorithms are iterative and thus induce a significant communication cost. One-shot federated learning (OFL) trades the iterative exchange of models between clients and the server with a single round of communication, thereby saving substantially on communication costs. Not surprisingly, OFL exhibits a performance gap in terms of accuracy with respect to FL, especially under high data heterogeneity. We introduce Fens, a novel federated ensembling scheme that approaches the accuracy of FL with the communication efficiency of OFL. Learning in Fens proceeds in two phases: first, clients train models locally and send them to the server, similar to OFL; second, clients collaboratively train a lightweight prediction aggregator model using FL. We showcase the effectiveness of Fens through exhaustive experiments spanning several datasets and heterogeneity levels. In the particular case of heterogeneously distributed CIFAR-10 dataset, Fens achieves up to a \(26.9\%\) higher accuracy over state-of-the-art (SOTA) OFL, being only \(3.1\%\) lower than FL. At the same time, Fens incurs at most \(4.3\times\) more communication than OFL, whereas FL is at least \(10.9\times\) more communication-intensive than Fens.

## 1 Introduction

FL is a widely adopted distributed machine learning (ML) approach, enabling clients to _collaboratively train_ a common model over their collective data without sharing raw data with a central server [27]. Clients in FL engage in iterative parameter exchanges with the server over several communication rounds to train a model. While providing high accuracy, this process incurs substantial communication cost [19]. One-shot federated learning (OFL) [11] has been introduced to address the communication challenges in FL by reducing the exchange of models to a single round. Not surprisingly, this came with a loss of accuracy with respect to FL.

Typical OFL methods execute local training at the clients up to completion and form an ensemble of locally trained models at the server [7, 10, 46, 11]. The ensemble is distilled into a single model, through means of either auxiliary public dataset [10, 11] or synthetic data generated at the server [7, 14, 46]. While these OFL methods address communication challenges by reducing model exchanges to a single round, they often achieve lower accuracy compared to iterative FL. This is especially true when data distribution across clients is highly heterogeneous as OFL methods typicallyrely on simple prediction aggregation schemes such as averaging [11; 46], weighted averaging [7; 10] or voting [8].

We introduce Fens, a hybrid of OFL and standard FL. Fens aims to approach both the accuracy of iterative FL as well as the communication cost of OFL. Learning in Fens proceeds in two phases. In the first phase, similar to OFL, clients upload their locally-trained models to the server. Instead of using the traditional OFL aggregation, Fens employs a second phase of FL: the server constructs an ensemble with a prediction _aggregator model_ stacked on top of the locally trained models. This advanced aggregation function is then trained by the clients in a lightweight FL training phase. The overall learning procedure is illustrated in Figure 1, alongside iterative and one-shot FL.

### Our Contributions

We show for the first time, to the best of our knowledge, that a shallow neural network for the aggregator model suffices to satisfactorily bridge the gap between OFL and FL. Leveraging a shallow aggregator model enables two major benefits: first, it induces significantly lower communication cost in the iterative phase, and second, the iterative refinement of this aggregator model significantly improves accuracy over existing OFL methods. By utilizing elements from both OFL and FL in this novel ensembling scheme, Fens achieves the best of both worlds: accuracy of FL and communication efficiency of OFL.

Through extensive evaluations on several benchmark datasets (CIFAR-100, CIFAR-10, SVHN, and AG-News) across different heterogeneity levels, we demonstrate the efficacy of Fens in achieving FL-like accuracy at OFL-like communication cost. We extend our empirical evaluations to the FLamby benchmark [32], a realistic cross-silo FL dataset for healthcare applications. Our results show that in heterogeneous settings where even iterative FL algorithms struggle, Fens remains a strong competitor. We then conduct an extensive study of different aggregator models and highlight the accuracy vs. communication trade-off. Lastly, we show that Fens maintains high accuracy even with a comparable memory footprint.

To showcase Fens's performance, we compare its accuracy and communication costs against Co-Boosting [7], a state-of-the-art OFL method, and FedAdam[33], a popular iterative FL algorithm, as shown in Figure 2. These evaluations are performed on the CIFAR-10 dataset with \(20\) clients across three heterogeneity levels: \(\alpha=0.01\) (very high), \(\alpha=0.05\) (high), and \(\alpha=0.1\) (moderate). Co-Boosting exhibits an accuracy gap of \(13.7-26.9\%\) compared to FedAdam. Fens closes this accuracy gap, being only \(0-3.1\%\) lower than FedAdam. To achieve this, Fens incurs only \(3.8-4.3\times\) more communication than Co-Boosting whereas FedAdam is \(10.9-22.1\times\) more expensive than Fens.

### Related Work

**One-shot Federated Learning.** Guha _et al_. [11] introduced one-shot FL, which limits communication to a single round. They proposed two main methods: _(i)_ heuristic selection for final ensemble clients, and _(ii)_ knowledge distillation (KD) for ensemble aggregation into a single model at the server using an auxiliary dataset. Subsequent methods based on KD [10; 22] require large, publicly available

Figure 1: Fens in comparison to iterative and one-shot federated learning.

Figure 2: Test accuracy and communication cost of OFL, Fens and FL on CIFAR-10 dataset under high data heterogeneity.

datasets similar to local client data for good performance, which are often difficult to obtain [50]. To address this, synthetic data generation using generative adversarial networks (GAN)s has been proposed [7; 46]. The SOTA Co-Boosting algorithm [7] iteratively generates and refines synthetic data and the ensemble model. In FedCVAE-Ens[14], clients train variational autoencoders (VAEs) locally and upload decoders to the server, which generates synthetic samples for classifier training. FedOV [8] trains an open-set classifier at each client to predict "unknown" classes, with the server ensembling these models and using open-set voting for label prediction. Other OFL approaches either do not fully consider data heterogeneity [22; 37], or face difficulties under high data heterogeneity [48].

Another line of research in OFL focuses on aggregating fully trained client model parameters [42; 45]. PFNM [45] matches neurons across client models for fully-connected networks, while FedMA[42] extends this to convolutional neural networks (CNNs) and LSTMs. However, the performance of these methods drops with more complex models. Few theoretical works exist, such as [18], which analyze global model loss for overparameterized ReLU networks. Despite the advances, OFL still exhibits accuracy gap with iterative FL. We show that Fens narrows this accuracy gap while preserving communication efficiency.

**Ensembles in Federated Learning.** Ensembles have been previously studied in FL for a variety of different goals. FedDF [24] performs robust model fusion of client ensembles to support model heterogeneity. The FedBE algorithm [5] uses Bayesian Model Ensemble to aggregate parameters in each global round, improving over traditional parameter averaging. Hamer _et al_. propose FedBoost[12] that constructs the ensemble using simple weighted averaging and analyze its optimality for density estimation tasks. However, these works are designed for standard FL and rely on substantial iterative communication. In the decentralized edge setting, [38] show that collaborative inference via neighbor averaging can achieve higher accuracy over local inference alone. However, they assume a setting where clients can exchange query data during inference and consider only IID data replicated on all edge devices. The idea of learning an aggregator model closely resembles late fusion techniques in multimodal deep learning [25]. The key difference is that Fens focuses on fusing single modality models trained on heterogeneous data under the communication constraints of federated settings.

## 2 Description of Fens

We consider a classification task represented by a pair of input and output spaces \(\mathcal{X}\) and \(\mathcal{Y}\), respectively. The system comprises \(M\) clients, represented by \([M]=\{1,\ldots,M\}\) and a central server. Each client \(i\) holds a local dataset \(\mathcal{D}_{i}\subset\mathcal{X}\times\mathcal{Y}\). For a model \(h_{\theta}:\mathcal{X}\rightarrow\mathcal{Z}\) parameterized by \(\theta\in\Theta\subseteq\mathbb{R}^{d}\), each data point \((x,y)\in\mathcal{X}\times\mathcal{Y}\) incurs a loss of \(\ell(h_{\theta}(x),y)\) where \(\ell:\mathcal{Z}\times\mathcal{Y}\rightarrow\mathbb{R}\). Denoting by \(\mathcal{D}:=\bigcup_{i\in[M]}\mathcal{D}_{i}\) the union of all local datasets, the objective is to solve the empirical risk minimization (ERM) problem: \(\min_{\theta\in\Theta}\frac{1}{|\mathcal{D}|}\sum_{(x,y)\in\mathcal{D}}\ell \left(h_{\theta}(x),y\right)\).

### Federated Learning (FL) and One-shot FL (OFL)

FL algorithms, such as FedAvg [27], are iterative methods that enable the clients to solve the above ERM problem, without having to share their local data. In each iteration \(t\), the server broadcasts the current model parameter \(\theta_{t}\) to a subset of clients \(S_{t}\subseteq[M]\). Each client \(i\in S_{t}\) updates the parameter locally over its respective dataset \(\mathcal{D}_{i}\) using an optimization method, typically stochastic gradient descent (SGD). Clients send back to the server their locally updated model parameters \(\{\theta_{t}^{(i)},\,i\in S_{t}\}\). Lastly, the server updates the global model parameter to \(\theta_{t+1}\coloneqq\frac{1}{|S_{t}|}\sum_{i\in S_{t}}\theta_{t}^{(i)}\).

In One-shot Federated Learning (OFL), the iterative exchanges in FL are replaced with a _one-shot_ communication of local models. Specifically, each client \(i\) seeks a model \(\theta^{(i)}\) that approximately solves the ERM problem on their local data: \(\min_{\theta\in\Theta}\frac{1}{|\mathcal{D}_{i}|}\sum_{(x,y)\in\mathcal{D}_{i }}\ell\left(h_{\theta}(x),y\right)\), and sends \(\theta^{(i)}\) to the server. Upon receiving the local parameter \(\theta^{(i)}\), corresponding to parametric model \(\pi_{i}=h_{\theta^{(i)}}\), the server builds an ensemble model of the form \(\pi(x)=\sum_{i\in[M]}w_{i}\pi_{i}(x)\). This ensemble model is then distilled into a single global model at the server using either a public dataset or synthetic data (generated by the server). Existing OFL algorithms choose weights \(w_{1},\ldots,w_{M}\) in three different ways: _(i)_ uniformly at random [46], _(ii)_ based on local label distributions [10], and _(iii)_ dynamically adjusted based on generated synthetic data [7].

### Fens

In Fens, the server builds the ensemble model using a generic aggregator \(f_{\lambda}:\mathcal{Z}^{M}\to\mathcal{Z}\), parameterized by \(\lambda\in\Lambda\subset\mathbb{R}^{q}\) to obtain a global model \(\pi:\mathcal{X}\to\mathcal{Z}\) defined to be

\[\pi(x)\coloneqq f_{\lambda}(\pi_{1}(x),\ldots,\pi_{M}(x)).\] (1)

In case of standard aggregators such as weighted averaging, \(q=M\) and \(\lambda\in(w\in\mathbb{R}_{+}^{M}\left|\sum_{i=1}^{M}w_{i}=1)\right.\), and \(f_{\lambda}(\pi_{1}(x),\ldots,\pi_{M}(x))\coloneqq\sum_{i\in[M]}\lambda_{i} \pi_{i}(x)\). In general, \(f_{\lambda}\) can be a non-linear trainable model such as a neural network. The overall learning procedure in Fens comprises two phases:

1. **Local training and one-shot communication:** Each client \(i\) does local training to compute \(\theta^{(i)}\), identical to OFL, and sends it to the server.
2. **Iterative aggregator training:** Upon receiving the local parameters \(\theta^{(i)}\), the server reconstructs \(\pi_{i}\coloneqq h_{\theta^{(i)}}\), and obtains \(\widehat{\lambda}\) that approximately solves the following ERM problem: \[\min_{\lambda\in\Lambda}\quad\frac{1}{|\mathcal{D}|}\sum_{(x,y)\in\mathcal{D }}\ell\left(f_{\lambda}(\pi_{1}(x),\ldots,\pi_{M}(x)),y\right).\] (2) The above ERM problem is solved using an iterative FL scheme (described above). For doing so, the server transmits the set of local models \(\{\pi_{1},\ldots,\pi_{M}\}\) to all the clients. The final model is given by \(\pi(x)\coloneqq f_{\widehat{\lambda}}\left(\pi_{1}(x),\ldots,\pi_{M}(x)\right)\).

When solving for (2) using iterative FL, only the aggregator parameters are transferred between the server and the clients. As we show through experiments, in the subsequent section, training an aggregator model is much simpler than training the local models \(\pi_{i}\), and a shallow neural network suffices for \(f_{\lambda}\). Algorithms 1 and 2 (Appendix C) provide the pseudo for Fens.

**Connection with stacked generalization.** The use of a trainable aggregator corresponds to an instance of stacked generalization [44] in the centralized ensemble literature, wherein the aggregation function is regarded as _level_\(1\) generalizer, while the clients' models are regarded as _level_\(0\) generalizers. It has been shown that level 1 generalizer serves the role of correcting the biases of level \(0\) generalizers, thereby improving the overall learning performance of the ensemble [44]. While stacked generalization has been primarily studied in centralized settings, through Fens we show that this scheme can be efficiently extended to an FL setting.

## 3 Experiments

We split our evaluation into the following sections: _(i)_ Fens vs OFL in Section 3.2; _(ii)_ Fens vs FL and analysis of when Fens can match FL in Section 3.3; _(iii)_ Fens on real-world cross-silo FLamby benchmark [32] in Section 3.4; _(iv)_ Fens on language dataset in Section 3.5; _(v)_ dissecting components of Fens in Section 3.6; and _(vi)_ enhancing Fens efficiency in Section 3.7.

### Experimental setup

**Datasets.** We consider three standard vision datasets with varying level of difficulty, including SVHN [30], CIFAR-10 [30] and CIFAR-100 [30], commonly used in several OFL works [7; 10; 46] as well as one language dataset AG-News [47]. Vision experiments involve \(20\) clients, except in the scalability study, where client numbers vary; and AG-News uses \(10\) clients. The original training splits of these datasets are partitioned across clients using the Dirichlet distribution \(\texttt{Dir}_{20}(\alpha)\), in line with previous works [7; 10; 14]. The parameter \(\alpha\) determines the degree of heterogeneity, with lower values leading to more heterogeneous distributions (see Appendix A, Figure 9). For our experiments involving the realistic healthcare FLamby benchmark, we experiment with \(3\) datasets: Fed-Camelyon16, Fed-Heart-Disease, and Fed-ISIC2019. Table 5 (Appendix A) presents an overview of the selected tasks. The datasets consist of a natural non independent and identically distributed (non-IID) partitioning across clients. In Fens, each client performs local training using \(90\%\) of their local training data while reserving \(10\%\) for the iterative aggregator training. We observed that by splitting the datasets, we achieve better performance than reusing the training data for aggregator training. For fairness, OFL and FL baselines run with each client using \(100\%\) of their dataset forlocal training. The testing set of each dataset is split (50-50%) for validation and testing. We use the validation set to tune hyperparameters and always report the accuracy on the testing split.

**One-shot FL baselines.** We compare Fens against 6 one-shot baselines: _(i)_ one-round FedAvg[27]; _(ii)_ FedENS[11], the first one-shot method constituting an ensemble with uniform weights; _(iii)_ FedKD[10], based on auxiliary dataset; _(iv)_ one-shot version of Fed-ET[6]; _(v)_ the data-free FedCVAE-Ens[14]; and _(vi)_ Co-Boosting[7], based on synthetic data generation. We use the best-reported hyperparameters in each work for the respective datasets wherever applicable or tune them. Appendix B.1 provides additional details regarding the one-shot baselines.

**Iterative FL baselines.** For comparison with FL, we consider \(6\) algorithms: _(i)_ FedAvg[27]; _(ii)_ FedProx[23]; _(iii)_ FedNova[43]; _(iv)_ Scaffold[20]; _(v)_ FedYogi[33]; and _(vi)_ FedAdam[33]. We tune learning rates for each algorithm. In addition to these baselines, we implement gradient compression with FedAvg STC, following the sparsification and quantization schemes of STC[29]. In particular, we set the quantization precision to 16-bit and sparsity level to \(50\%\), to reduce the communication cost of FedAvg by \(4\times\) and keep the remaining setup to the same as above baselines. For the FLamby benchmark experiments, we use the reported hyperparameters which were obtained after extensive tuning, except with one difference. The authors purposefully restricted the number of rounds to be approximately the same as the number of epochs required to train on pooled data (see [32]). Since this might not reflect true FL performance, we rerun all FL strategies to convergence using the reported tuned parameters. Precisely, we run up to \(10\times\) more communication rounds than evaluated in the FLamby benchmark. We include more details on FL baselines in Appendix B.2.

**Fens.2** For the CIFAR-10 and CIFAR-100 datasets, each client conducts local training for \(500\) epochs utilizing SGD as the local optimizer with an initial learning rate of \(0.0025\). For the SVHN and AG-News datasets, local training extends to \(50\) and \(20\) epochs respectively with a learning rate of \(0.01\). The learning rate is decayed using Cosine Annealing across all datasets. For the FLamby benchmark experiments, each client in Fens performs local training with the same hyperparameters as the client local baselines of FLamby. We experiment with two aggregator models, a 2-layer perceptron with ReLU activations and another that learns per-client per-class weights. We train the aggregator model using the FedAdam algorithm where the learning rate is separately tuned for each dataset (Table 8, Appendix B.3). To reduce the communication costs corresponding to the ensemble download, we employ post-training model quantization at the server from FP32 to INT8. Appendix B.3 provides more details on Fens.

Footnote 2: Source code available at: https://github.com/sacs-epfl/fens.

**Configurations.** In line with related work [10; 24; 35], we use ResNet-8 [13] as the client local model for our vision tasks and fine-tune DistilBert [34] for our language task. Our FLamby experiments use the same models as defined in the benchmark for each task (see Table 5, Appendix A). We report the average results across at least 3 random seeds. For iterative FL baselines, the communication cost corresponds to the round in which the best accuracy is achieved.

### Fens vs Off

To assess Fens's efficacy, we experiment in non-IID settings, varying \(\alpha\in\{0.01,0.05,0.1\}\), and present results across datasets and baselines in Table 1. Our observations reveal challenges for one-shot methods under high heterogeneity, with the optimal baseline differing across settings. FedAvg with one round exhibits the poorest performance. While FedCVAE-Ens maintains consistent accuracy across various heterogeneity levels and datasets, it struggles particularly with CIFAR-10 and CIFAR-100, indicating challenges in learning effective local decoder models. Regarding distillation-based methods, FedKD and Co-Boosting demonstrate similar performance on SVHN and CIFAR-10. However, FedKD outperforms Co-Boosting on CIFAR-100, facilitated by the auxiliary public dataset for KD while Co-Boosting arduously generates its synthetic transfer dataset. Fed-ET improves over FedENS and is also competitive to FedKD. Notably, Fens consistently outperforms the best baseline in each scenario, except for SVHN at \(\alpha=0.01\), where FedCVAE-Ens excels. Fens achieves significant accuracy gains, surpassing the best baseline by \(11.4-26.9\%\) on CIFAR-10 and \(8.7-15.4\%\) on CIFAR-100, attributed to its advanced aggregator model.

We chart the client communication costs incurred by all algorithms in Figure 3. The clients in Fens expend \(3.6-4.3\times\) more than one-shot algorithms owing to the ensemble download and iterative 

[MISSING_PAGE_FAIL:6]

of Fens (details in Appendix B.2). We also show two versions of FedAdam, one achieving the accuracy of Fens and the other with its maximum accuracy to facilitate effective comparison of communication costs.

We observe that Fens with its iteratively trained aggregator significantly closes the accuracy gap between OFL (FedKD) and FL (FedAdam) across all datasets and heterogeneity levels. Remarkably, the boost achieved is sufficient to match FedAdam's accuracy at \(\alpha=\{0.01,0.05\}\) on the CIFAR-10 dataset. This comes at only a modest increase in communication costs which are \(\approx 4\times\) that of OFL across all cases. We observe that FedAdam incurs \(30-80\times\) more communication than OFL to reach the same accuracy as Fens. Even adding multi-round support to FedKD only marginally improves its performance. While the best accuracy achieved by FedAdam still remains higher, it also comes at significant communication costs of \(47-96\times\) that of OFL. Furthermore, we observe that communication compression (FedAvg STC) fails to preserve the accuracy of FL under high heterogeneity. Thus Fens achieves the best accuracy vs. communication trade-off, demonstrating accuracy properties of iterative FL while retaining communication efficiency of OFL.

#### 3.3.1 When can Fens match iterative FL?

In this section, we aim to understand when Fens can match iterative FL. The performance of ensembles depends upon _(i)_ the quality of local models; and _(ii)_ data heterogeneity. The quality of local models in turn depends on the amount of local data held by the clients. As local models improve at generalizing locally, the overall performance of the ensemble is enhanced. In contrast, FL struggles to generate a good global model when the local datasets of clients significantly differ. Thus more volume of data does not analogously benefit FL due to high data heterogeneity. However, as heterogeneity reduces, FL excels and benefits significantly from collaborative updates. This suggests that Fens under _sufficiently large local datasets_ and _high heterogeneity_ can match iterative FL's performance. We confirm this intuition through the following experiments on the SVHN dataset.

**Setup.** We study the performance of FL and Fens by progressively increasing the volume of data held by the clients. To this end, we consider the classification task on the SVHN dataset due to the availability of an extended training set of \(604\,388\) samples, _i.e._, \(\approx 10\times\) bigger than the default SVHN dataset. We then experiment with fractions ranging from \(10\) to \(100\)% of the total training set. Each client locally utilizes \(90\%\) for one-shot local model training and reserves \(10\%\) for iterative aggregator training, similar to previous sections. We then compare Fens with FedAvg (FL baseline) on three

Figure 4: **Fens against iterative FL. The R indicates the number of global rounds, signifying the multi-round version of the OFL baseline. Fens achieves accuracy properties of iterative FL (FedAdam) with a modest increase in communication cost compared to OFL (FedKD). Numerical accuracy results are included in Table 11 (Appendix D).**

levels of heterogeneity: \(\alpha=\{0.05,0.1,1\}\), varying from highly non-IID to IID. We tune the learning rate for FedAvg (details in Appendix B.2) and keep the remaining setup as in previous experiments.

**Results.** Figure 5 shows the results and confirms our prior insight behind the effective performance of Fens. Specifically, we observe that the growing volume of training data benefits Fens much more than FedAvg. When the data distribution is homogeneous \((\alpha=1)\), the performance of Fens improves faster than FedAvg, but still remains behind. On the other hand, under high heterogeneity (\(\alpha=0.01\)), Fens quickly catches up with the performance of FedAvg, matching the same accuracy when using the full training set. We conclude that under regimes of high heterogeneity and sufficiently large local datasets, Fens presents a practical alternative to communication expensive iterative FL.

### Performance on real-world datasets

In this section, we evaluate the performance of Fens on the real-world cross-silo FLamby benchmark [32]. Specifically, we present 5 iterative baselines and 2 one-shot baselines along with the client local baselines (Figure 6). For the one-shot FedAvg and FedProx OFL baselines, we additionally tune the number of local updates. FedKD is infeasible in these settings since it requires a public dataset for distillation, unavailable in the medical setting. FedCVAE-Ens and Co-Boosting are also infeasible due to the difficulty in learning good decoder models or synthetic dataset generators for medical input data, a conclusion supported by their poor performance on the comparatively simpler CIFAR-100 task (Table 1). Figure 6 shows the results with the first row comparing Fens against iterative FL algorithms and the second row against one-shot FL and the client local baselines.

When comparing to iterative FL, we observe that Fens is on par for the Fed-Heart-Disease dataset and performs better for Fed-Camelyon16. The iterative FL performance is affected by high heterogeneity [32] where the deterioration is more significant for Fed-Camelyon16, which learns on large breast slides (\(10000\times 2048\)) than for Fed-Heart-Disease, which learns on tabular data. In such scenarios of heterogeneity, Fens can harness diverse local classifiers through the aggregator model to attain good performance. On the Fed-ISIC2019 dataset, however, Fens does not reach the accuracy of iterative FL. Clients in Fed-ISIC2019 exhibit high variance in local data amounts and model performance, with the largest client having \(12\)k samples and the smallest only \(225\) (Table 5, Appendix A). We thus speculate that the Fed-ISIC2019 dataset falls within the low local training fraction regime depicted in Figure 5, exhibiting a larger

Figure 5: Accuracy of Fens for increasing dataset size. Performance of Fens rapidly increases as the data volume increases. At high data heterogeneity, Fens matches iterative FLâ€™s accuracy.

Figure 6: **Fens in FLamby. Fens is on par with iterative FL (row-1), except when local models are weak (Fed-ISIC2019) while remaining superior in the one-shot setting (row-2). Numerical results included in Tables 12 to 17 (Appendix D).**

accuracy gap compared to iterative FL. However, we note that Fens achieves superior performance over one-shot FedAvg and one-shot FedProx, while performing at least as well as the best client local baseline across all datasets. Overall, these observations for FL algorithms have spurred new interest in developing a better understanding of performance on heterogeneous cross-silo datasets [32]. We show that Fens remains a strong competitor in such settings.

### Performance on language dataset

We now study the performance of Fens on the AG-News dataset, comparing it against top-performing baselines FedAdam and FedKD in the iterative and one-shot categories, respectively. Figure 7 shows the results: at \(\alpha=0.1\), FedKD achieves \(71.5\%\) accuracy, leaving a gap to FedAdam at \(82.3\%\). Fens effectively closes this gap, reaching \(78.8\%\). As heterogeneity reduces at \(\alpha=0.3\), all algorithms achieve higher accuracies. Fens improves upon FedKD from \(79.3\%\) to \(84.5\%\) while FedAdam achieves \(88.3\%\). Thus we observe consistent results on the language task as our vision benchmarks.

### Dissecting Fens

We extensively evaluate various aggregation functions (details in Appendix B.4) on the CIFAR-10 dataset across diverse heterogeneity levels. In particular, we assess static aggregation rules including averaging and weighted averaging, parametric aggregator models including a linear model, and a shallow neural network. We also evaluate an advanced version of voting [2] which involves computing competency matrices to reach a collective decision. In addition, we evaluate the Mixture-of-Experts (MoE) aggregation rule [36] where only the gating function is trained via federation. Figure 8 illustrates the accuracy, communication costs, and breakdown for all aggregations. Trained aggregator models outperform static aggregations, incurring additional costs for ensemble download and iterative training. The NN aggregator emerges as the top performer, offering the best accuracy vs. communication trade-off. Notably, the iterative training cost of the NN aggregator model for several rounds is lower than the OFL phase itself. Regarding accuracy, only MoE outperforms NN at \(\alpha=0.01\), where extreme heterogeneity induces expert specialization, while the trained gating network accurately predicts the right expert. However, MoE's performance declines as heterogeneity decreases while its communication costs remain higher due to the size of the gating network.

### Enhancing Fens efficiency

The Fens global model comprises the aggregator model stacked atop the ensemble of client local models. Although Fens achieves strong accuracy, the ensemble model can be computationally and memory intensive. We used FP32 to INT8 quantization in our previous experiments which reduces the memory costs by \(4\times\) (Appendix B.3). In this section, we explore two additional approaches to reduce Fens's overheads.

Figure 8: Accuracy of different aggregation functions on the CIFAR-10 dataset. NN offers the best accuracy vs. communication trade-off, with its iterative training taking up only a fraction of the total cost. Numerical accuracy values are included in Table 9 (Appendix D).

What if we distill Fens into a single model?To enable efficient inference, we can distill the Fens global model into a single model at the server using KD once the training is completed. Specifically, we distill the Fens ensemble model comprising \(20\) ResNet-8 client models and the shallow aggregator neural network into a single ResNet-8 model. Table 3 presents the results on the CIFAR-10 dataset for \(\alpha=\{0.01,0.05,0.1\}\) distilled using CIFAR-100 as the auxiliary dataset. We observe a slight accuracy drop arising from the process of distillation, which is standard behavior [39]. While we distill using the standard distillation algorithm [15], we note that this accuracy gap can be further reduced through the use of more advanced distillation methods [16; 49].

What if we match the memory footprint of Fens to FedAdam?While the above approach enables efficient inference, we still need to mitigate training time costs. We now consider a downsized (DS) version of ResNet-8, where the width of a few layers is reduced so that the total size of the FENS downsized (Fens-DS) model approximately matches the size of the single model in FedAdam. Table 4 presents the results on the CIFAR-10 dataset for various heterogeneity levels. Note that no quantization is considered for Fens and Fens-DS, hence the contrast in values with Table 3. Under a comparable memory footprint, Fens-DS remains competitive with the original FedAdam, with only a slight drop in accuracy compared to Fens. On the other hand, using the downsized model as the global model in FedAdam-DS results in a significant accuracy drop (from \(39.32\%\) to \(29.69\%\)) under high data heterogeneity (\(\alpha=0.01\)). Thus, the memory overhead of Fens can be alleviated while retaining its communication benefits without too much impact on accuracy.

## 4 Discussion and Conclusion

**Limitations.** One limitation is the memory required on client devices to store the ensemble model for aggregator training. We explored quantization and downsizing to mitigate this issue. Future work could investigate aggregator models that do not require access to all client models in the ensemble. This memory issue is only present during training; after training, Fens can be distilled into a single global model on the server, enabling efficient inference as shown in Section 3.7. Another limitation is the increased vulnerability to attacks during iterative aggregator training, unlike OFL, which limits the attack surface to one round. However, this only affects the aggregator model, since the client local models are still uploaded in one shot. Privacy can be further enhanced in Fens through techniques such as differential privacy [9] or trusted execution environments [28]. Specifically, clients can use differentially private SGD [1] for local training, providing a differentially private local model for the ensemble, while the aggregator training could leverage a differentially private FL algorithm [31].

**Benefits.** In addition to low communication costs and good accuracy, Fens provides three important advantages. First, it supports model heterogeneity, allowing different model architectures across federated clients [21]. Second, Fens enables rapid client unlearning [4], towards the goal of the _right to be forgotten_ in GDPR [26]. In Fens, unlearning a client can be achieved by simply re-executing the lightweight aggregator training by excluding the requested clients' model from the ensemble. This is more efficient than traditional FL, where disincorporating knowledge from a single global model can be costly. Lastly, if a small server-side dataset is available, such as a proxy dataset for bootstrapping FL [3; 19], Fens can train the aggregator model on the server. This makes Fens applicable in model market scenarios of OFL [7; 41] where clients primarily offer pre-trained models.

To conclude, we introduce Fens, a hybrid approach combining OFL and FL. Fens emphasizes local training and one-shot model sharing, similar to OFL, which limits communication costs. It then performs lightweight aggregator training in an iterative FL-like fashion. Our experiments on diverse tasks demonstrated that Fens is highly effective in settings with high data heterogeneity, nearly achieving FL accuracy while maintaining the communication efficiency of OFL. Additionally, Fens supports model heterogeneity, rapid unlearning, and is applicable to model markets.

\begin{table}
\begin{tabular}{c c c c c} \hline Algorithm & \(\alpha=0.01\) & \(\alpha=0.05\) & \(\alpha=0.1\) & Memory (MiB) \\ \hline Fens & \(43.32\times 0.05\) & \(68.22\times 1.19\) & \(75.61\times 1.85\) & \(377.03\) \\ Fens-DS & \(43.08\times 0.01\) & \(44.59\times 1.72\) & \(72.43\times 1.76\) & \(17.95\) \\ FedAdam & \(39.32\times 0.05\) & \(68.74\times 2.76\) & \(78.73\times 3.55\) & \(18.85\) \\ FedAdam-DS & \(29.69\times 1.62\) & \(63.77\times 0.23\) & \(72.25\times 1.32\) & \(0.88\) \\ \hline \end{tabular}
\end{table}
Table 4: Fens vs FedAdam under similar memory footprint on CIFAR-10. DS stands for downsized.

\begin{table}
\begin{tabular}{c c c c} \hline Algorithm & \(\alpha=0.01\) & \(\alpha=0.05\) & \(\alpha=0.1\) \\ \hline Fens & \(44.20\times 2.95\) & \(68.22\times 1.19\) & \(75.61\times 1.85\) \\ Fens distilled & \(43.81\times 2.55\) & \(65.96\times 2.25\) & \(71.59\times 1.21\) \\ \hline \end{tabular}
\end{table}
Table 3: Accuracy of Fens after distillation on the CIFAR-10 dataset.

## Acknowledgments

Nirupam is partly supported by Swiss National Science Foundation (SNSF) project 200021_200477, "Controlling The Spread of Epidemics: A Computing Perspective". The authors are thankful to Milos Vujasinovic and Sayan Biswas for their helpful discussions, and to the anonymous reviewers of NeurIPS 2024 for their valuable time and constructive inputs that shaped the final version of this work.

## References

* Abadi et al. [2016] Martin Abadi, Andy Chu, Ian Goodfellow, H Brendan McMahan, Ilya Mironov, Kunal Talwar, and Li Zhang. Deep learning with differential privacy. In _Proceedings of the 2016 ACM SIGSAC conference on computer and communications security_, pages 308-318, 2016.
* Ben-Yashar and Paroush [2001] Ruth Ben-Yashar and Jacob Paroush. Optimal decision rules for fixed-size committees in polychotomous choice situations. _Social Choice and Welfare_, 18(4):737-746, 2001.
* Bonawitz et al. [2019] Keith Bonawitz, Hubert Eichner, Wolfgang Grieskamp, Dzmitry Huba, Alex Ingerman, Vladimir Ivanov, Chloe Kiddon, Jakub Konecny, Stefano Mazzocchi, Brendan McMahan, Timon Van Overveldt, David Petrou, Daniel Ramage, and Jason Roselander. Towards federated learning at scale: System design. In _MLSys_, 2019.
* Bourtoule et al. [2021] Lucas Bourtoule, Varun Chandrasekaran, Christopher A Choquette-Choo, Hengrui Jia, Adelin Travers, Baiwu Zhang, David Lie, and Nicolas Papernot. Machine unlearning. In _2021 IEEE Symposium on Security and Privacy (SP)_, pages 141-159. IEEE, 2021.
* Chen and Chao [2021] Hong-You Chen and Wei-Lun Chao. Fed{be}: Making bayesian model ensemble applicable to federated learning. In _International Conference on Learning Representations_, 2021.
* Cho et al. [2022] Yae Jee Cho, Andre Manoel, Gauri Joshi, Robert Sim, and Dimitrios Dimitriadis. Heterogeneous ensemble knowledge transfer for training large models in federated learning. In Lud De Raedt, editor, _Proceedings of the Thirty-First International Joint Conference on Artificial Intelligence, IJCAI-22_, pages 2881-2887. International Joint Conferences on Artificial Intelligence Organization, 7 2022. Main Track.
* Dai et al. [2024] Rong Dai, Yonggang Zhang, Ang Li, Tongliang Liu, Xun Yang, and Bo Han. Enhancing one-shot federated learning through data and ensemble co-boosting. In _The Twelfth International Conference on Learning Representations_, 2024.
* Diao et al. [2023] Yiqun Diao, Qinbin Li, and Bingsheng He. Towards addressing label skews in one-shot federated learning. In _International Conference on Learning Representations_, 2023.
* Geyer et al. [2017] Robin C Geyer, Tassilo Klein, and Moin Nabi. Differentially private federated learning: A client level perspective. _arXiv preprint arXiv:1712.07557_, 2017.
* Gong et al. [2022] Xuan Gong, Abhishek Sharma, Srikrishna Karanam, Ziyan Wu, Terrence Chen, David Doermann, and Arun Innanje. Preserving privacy in federated learning with ensemble cross-domain knowledge distillation. _Proceedings of the AAAI Conference on Artificial Intelligence_, 36(11):11891-11899, Jun. 2022.
* Guha et al. [2019] Neel Guha, Ameet Talwalkar, and Virginia Smith. One-shot federated learning. _arXiv preprint arXiv:1902.11175_, 2019.
* Hamer et al. [2020] Jenny Hamer, Mehryar Mohri, and Ananda Theertha Suresh. Fedboost: A communication-efficient algorithm for federated learning. In _International Conference on Machine Learning_, pages 3973-3983. PMLR, 2020.
* He et al. [2016] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In _Proceedings of the IEEE conference on computer vision and pattern recognition_, pages 770-778, 2016.

* [14] Clare Elizabeth Heinbaugh, Emilio Luz-Ricca, and Huajie Shao. Data-free one-shot federated learning under very high statistical heterogeneity. In _The Eleventh International Conference on Learning Representations_, 2023.
* [15] Geoffrey Hinton, Oriol Vinyals, and Jeffrey Dean. Distilling the knowledge in a neural network. In _NIPS Deep Learning and Representation Learning Workshop_, 2015.
* [16] Fotis Iliopoulos, Vasilis Kontonis, Cenk Baykal, Gaurav Menghani, Khoa Trinh, and Erik Vee. Weighted distillation with unlabeled examples. In S. Koyejo, S. Mohamed, A. Agarwal, D. Belgrave, K. Cho, and A. Oh, editors, _Advances in Neural Information Processing Systems_, volume 35, pages 7024-7037. Curran Associates, Inc., 2022.
* [17] Maximilian Ilse, Jakub Tomczak, and Max Welling. Attention-based deep multiple instance learning. In Jennifer Dy and Andreas Krause, editors, _Proceedings of the 35th International Conference on Machine Learning_, volume 80 of _Proceedings of Machine Learning Research_, pages 2127-2136. PMLR, 10-15 Jul 2018.
* [18] Divyansh Jhunjhunwala, Shiqiang Wang, and Gauri Joshi. Towards a theoretical and practical understanding of one-shot federated learning with fisher information. In _Federated Learning and Analytics in Practice: Algorithms, Systems, Applications, and Opportunities_, 2023.
* [19] Peter Kairouz, H Brendan McMahan, Brendan Avent, Aurelien Bellet, Mehdi Bennis, Arjun Nitin Bhagoji, Kallista Bonawitz, Zachary Charles, Graham Cormode, Rachel Cummings, et al. Advances and open problems in federated learning. _Foundations and Trends(r) in Machine Learning_, 14(1-2):1-210, 2021.
* [20] Sai Praneeth Karimireddy, Satyen Kale, Mehryar Mohri, Sashank Reddi, Sebastian Stich, and Ananda Theertha Suresh. Scaffold: Stochastic controlled averaging for federated learning. In _International Conference on Machine Learning_, pages 5132-5143. PMLR, 2020.
* [21] Daliano Li and Junpu Wang. Fedmd: Heterogenous federated learning via model distillation. _NeurIPS Workshop on Federated Learning for Data Privacy and Confidentiality_, 2019.
* [22] Qinbin Li, Bingsheng He, and Dawn Song. Practical one-shot federated learning for cross-silo setting. In Zhi-Hua Zhou, editor, _Proceedings of the Thirtieth International Joint Conference on Artificial Intelligence, IJCAI-21_, pages 1484-1490. International Joint Conferences on Artificial Intelligence Organization, 8 2021. Main Track.
* [23] Tian Li, Anit Kumar Sahu, Manzil Zaheer, Maziar Sanjabi, Ameet Talwalkar, and Virginia Smith. Federated optimization in heterogeneous networks. _Proceedings of Machine learning and systems_, 2:429-450, 2020.
* [24] Tao Lin, Lingjing Kong, Sebastian U Stich, and Martin Jaggi. Ensemble distillation for robust model fusion in federated learning. _Advances in Neural Information Processing Systems_, 33:2351-2363, 2020.
* [25] Kuan Liu, Yanen Li, Ning Xu, and Prem Natarajan. Learn to combine modalities in multimodal deep learning. _arXiv preprint arXiv:1805.11730_, 2018.
* [26] Alessandro Mantelero. The eu proposal for a general data protection regulation and the roots of the 'right to be forgotten'. _Computer Law & Security Review_, 29(3):229-235, 2013.
* [27] Brendan McMahan, Eider Moore, Daniel Ramage, Seth Hampson, and Blaise Aguera y Arcas. Communication-efficient learning of deep networks from decentralized data. In _Artificial Intelligence and Statistics_, pages 1273-1282. PMLR, 2017.
* [28] Aghiles Ait Messaoud, Sonia Ben Mokhtar, Vlad Nitu, and Valerio Schiavoni. Shielding federated learning systems against inference attacks with arm trustzone. In _Proceedings of the 23rd ACM/IFIP International Middleware Conference_, pages 335-348, 2022.
* [29] Alessio Mora, Luca Foschini, and Paolo Bellavista. Structured sparse ternary compression for convolutional layers in federated learning. In _2022 IEEE 95th Vehicular Technology Conference: (VTC2022-Spring)_, pages 1-5, 2022.

* [30] Yuval Netzer, Tao Wang, Adam Coates, Alessandro Bissacco, Bo Wu, and Andrew Y Ng. Reading digits in natural images with unsupervised feature learning. 2011.
* [31] Maxence Noble, Aurelien Bellet, and Aymeric Dieuleveut. Differentially private federated learning on heterogeneous data. In _International Conference on Artificial Intelligence and Statistics_, pages 10110-10145. PMLR, 2022.
* [32] Jean Ogier du Terrail, Samy-Safwan Ayed, Edwige Cyffers, Felix Grimberg, Chaoyang He, Regis Loeb, Paul Mangold, Tanguy Marchand, Othmane Marfoq, Erum Mushtaq, Boris Muzellec, Constantin Philippenko, Santiago Silva, Maria Teleczuk, Shadi Albarqouni, Salman Avestimehr, Aurelien Bellet, Aymeric Dieuleveut, Martin Jaggi, Sai Praneeth Karimireddy, Marco Lorenzi, Giovanni Neglia, Marc Tommasi, and Mathieu Andreux. Flamby: Datasets and benchmarks for cross-silo federated learning in realistic healthcare settings. In S. Koyejo, S. Mohamed, A. Agarwal, D. Belgrave, K. Cho, and A. Oh, editors, _Advances in Neural Information Processing Systems_, volume 35, pages 5315-5334. Curran Associates, Inc., 2022.
* [33] Sashank J. Reddi, Zachary Charles, Manzil Zaheer, Zachary Garrett, Keith Rush, Jakub Konecny, Sanjiv Kumar, and Hugh Brendan McMahan. Adaptive federated optimization. In _International Conference on Learning Representations_, 2021.
* [34] Victor Sanh, L Debut, J Chaumond, and T Wolf. Distilbert, a distilled version of bert: Smaller, faster, cheaper and lighter. arxiv 2019. _arXiv preprint arXiv:1910.01108_, 2019.
* [35] Felix Sattler, Arturo Marban, Roman Rischke, and Wojciech Samek. Cfd: Communication-efficient federated distillation via soft-label quantization and delta coding. _IEEE Transactions on Network Science and Engineering_, 9(4):2025-2038, 2022.
* [36] Noam Shazeer, *Azalia Mirhoseini, *Krzysztof Maziarz, Andy Davis, Quoc Le, Geoffrey Hinton, and Jeff Dean. Outrageously large neural networks: The sparsely-gated mixture-of-experts layer. In _International Conference on Learning Representations_, 2017.
* [37] MyungJae Shin, Chihoon Hwang, Joongheon Kim, Jihong Park, Mehdi Bennis, and Seong-Lyun Kim. Xor mixup: Privacy-preserving data augmentation for one-shot federated learning. _arXiv preprint arXiv:2006.05148_, 2020.
* 2021 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP)_, pages 8478-8482, 2021.
* [39] Samuel Don Stanton, Pavel Izmailov, Polina Kirichenko, Alexander A Alemi, and Andrew Gordon Wilson. Does knowledge distillation really work? In A. Beygelzimer, Y. Dauphin, P. Liang, and J. Wortman Vaughan, editors, _Advances in Neural Information Processing Systems_, 2021.
* [40] Mingxing Tan and Quoc Le. Efficientnet: Rethinking model scaling for convolutional neural networks. In _International conference on machine learning_, pages 6105-6114. PMLR, 2019.
* [41] Manasi Vartak, Harihar Subramanyam, Wei-En Lee, Srinidhi Viswanathan, Saadiyah Husnoo, Samuel Madden, and Matei Zaharia. Modeldb: a system for machine learning model management. In _Proceedings of the Workshop on Human-In-the-Loop Data Analytics_, HILDA '16, New York, NY, USA, 2016. Association for Computing Machinery.
* [42] Hongyi Wang, Mikhail Yurochkin, Yuekai Sun, Dimitris Papailiopoulos, and Yasaman Khazaeni. Federated learning with matched averaging. In _International Conference on Learning Representations_, 2020.
* [43] Jianyu Wang, Qinghua Liu, Hao Liang, Gauri Joshi, and H Vincent Poor. Tackling the objective inconsistency problem in heterogeneous federated optimization. _Advances in neural information processing systems_, 33:7611-7623, 2020.
* [44] David H. Wolpert. Stacked generalization. _Neural Networks_, 5(2):241-259, 1992.
* [45] Mikhail Yurochkin, Mayank Agarwal, Soumya Ghosh, Kristjan Greenewald, Nghia Hoang, and Yasaman Khazaeni. Bayesian nonparametric federated learning of neural networks. In _International conference on machine learning_, pages 7252-7261. PMLR, 2019.

* [46] Jie Zhang, Chen Chen, Bo Li, Lingjuan Lyu, Shuang Wu, Shouhong Ding, Chunhua Shen, and Chao Wu. DENSE: Data-free one-shot federated learning. In Alice H. Oh, Alekh Agarwal, Danielle Belgrave, and Kyunghyun Cho, editors, _Advances in Neural Information Processing Systems_, 2022.
* [47] Xiang Zhang, Junbo Zhao, and Yann LeCun. Character-level convolutional networks for text classification. In C. Cortes, N. Lawrence, D. Lee, M. Sugiyama, and R. Garnett, editors, _Advances in Neural Information Processing Systems_, volume 28. Curran Associates, Inc., 2015.
* [48] Yanlin Zhou, George Pu, Xiyao Ma, Xiaolin Li, and Dapeng Wu. Distilled one-shot federated learning. _arXiv preprint arXiv:2009.07999_, 2020.
* [49] Yichen Zhu, Ning Liu, Zhiyuan Xu, Xin Liu, Weibin Meng, Louis Wang, Zhicai Ou, and Jian Tang. Teach less, learn more: On the undistillable classes in knowledge distillation. In Alice H. Oh, Alekh Agarwal, Danielle Belgrave, and Kyunghyun Cho, editors, _Advances in Neural Information Processing Systems_, 2022.
* [50] Zhuangdi Zhu, Junyuan Hong, and Jiayu Zhou. Data-free knowledge distillation for heterogeneous federated learning. In _International Conference on Machine Learning_, pages 12878-12889. PMLR, 2021.

## Appendix A Datasets

As mentioned in Section 3.1, we focus on classification tasks and experiment with 3 datasets in FLamby benchmark including Fed-Camelyon16, Fed-Heart-Disease and Fed-ISIC2019. Table 5 overviews the selected tasks in this work.

## Appendix B Additional Experimental Details

### One-shot FL baselines

The client local training for all OFL baselines (except FedCVAE-Ens) as well as Fens is conducted alike, using the parameters reported in [10] for the CIFAR-10 and CIFAR-100 datasets. For the SVHN and AG-News datasets, local training is conducted using the SGD optimizer with a learning rate of \(0.01\) for \(50\) and \(20\) local epochs respectively and decayed using Cosine Annealing. All vision datasets use a batch size of \(16\) while AG-News uses a batch-size of \(8\) for local training. For FedCVAE-Ens, we use the same CVAE architecture and local training parameters as reported by the authors [14]. However, for the distillation at the server, we use ResNet-8 as the classifier model at the server to maintain fairness with other baselines. For the distillation phase of FedKD,

\begin{table}
\begin{tabular}{c c c c c c c c} \hline \hline Dataset & Input (\(\alpha\)) & Prediction (\(y\)) & Task type & \# Clients & \# Examples per client & Model & Metric \\ \hline Fed-Camelyon16 & Slides & Tumor on Slide & Binary Classification & 2 & 239, 150 & DeepMIL [17] & AUC \\ \hline Fed-Heart-Disease & Patient Info. & Heart Disease & Binary Classification & 4 & 303, 261, 46, 130 & Logistic Regression & Accuracy \\ \hline Fed-ISIC2019 & Dermoscopy & Melanoma Class & Multi-class Classification & 6 & 12413, 3954, 3363, & EfficientNet [40] + & Balanced Linear layer & Accuracy \\ \hline \hline \end{tabular}
\end{table}
Table 5: Overview of selected datasets and tasks in FLamby. We defer additional details to [32].

Figure 9: Visualizing the effect of changing \(\alpha\) on the CIFAR-10 dataset. Dot size corresponds to the number of samples of a given class in a given node.

we use the setup described by the authors [10] without inference quantization. For the one-shot version of Fed-ET, we set the diversity regularization parameter to the best value of \(\lambda=0.05\). For both FedKD and Fed-ET, we use CIFAR-10, CIFAR-100, and TinyImageNet as the auxiliary datasets for distillation for SVHN, CIFAR-10, and CIFAR-100 datasets respectively. We consider a \(60-40\%\) split for the AG-News dataset where local training is conducted on the \(60\%\) split while the remaining \(40\%\) is treated as the auxiliary dataset for distillation at the server in FedKD. Distillation in Co-Boosting using synthetically generated data also uses the best-reported hyperparameters [7]. For one-round FedAvg, we additionally tune the number of local epochs performed before aggregation by considering \(\{1,2,5,10,15,20\}\) epochs.

### Iterative FL baselines

We experiment with 6 different baselines including FedAvg, FedProx, FedNova, FedAdam, FedYogi, and Scaffold. We perform extensive hyperparameter tuning on the CIFAR-10 dataset for all levels of heterogeneity as detailed below. The server assumes full client participation, _i.e._, all clients participate in each round. For our vision benchmarks, each client performs \(2\) local epochs per round using a batch size of 16. For our language task, clients train for \(50\) local steps in each round using a batch-size of 8. We run FL training until convergence and report the best accuracy achieved. We found all algorithms to converge in less than \(100\) communication rounds on the vision tasks and in \(150\) rounds on the language task.

**Hyperparameter tuning.** Below we describe our tuning procedure derived from several previous works [23; 32; 33]. For the FedAvg algorithm, we tune the client learning rate (\(\eta_{l}\)) over the values \(\{0.1,0.01,0.001,0.0001\}\) separately for every \(\alpha\in\{0.01,0.05,0.1\}\). For the FedProx algorithm, our grid space was \(\{0.1,0.01\}\) and \(\{1,0.1,0.01\}\) for the client learning rate (\(\eta_{l}\)) and the proximal parameter (\(\mu\)) respectively. This was again separately tuned for every value of \(\alpha\in\{0.01,0.05,0.1\}\). For the FedYogi and the FedAdam algorithm, we consider the grid space of \(\{0.1,0.01,0.001,0.0001\}\) and \(\{10,1,0.1,0.01,0.001\}\) for the client learning rate (\(\eta_{l}\)) and the server learning rate (\(\eta_{s}\)) respectively. This explodes the search significantly when tuning for every value of \(\alpha\). From our tuning results for the FedAvg and the FedProx algorithm, we noticed that the optimal parameter values were the same within the following two subgroups of \(\alpha-\{0.01,0.05\}\) and \(\{0.1\}\) (Table 6). Hence, to keep the tuning tractable, we tune only for one \(\alpha\) in each subgroup and reuse the values for other alphas within the same subgroup. For the FedNova algorithm, we use the version with both client and global momentum which was reported to perform the best [43]. We consider the search space \(\{0.005,0.01,0.02,0.05,0.08\}\) for the client learning rate (\(\eta_{l}\)) as done by the authors [43] and tune separately for every value of \(\alpha\). Finally, for the Scaffold algorithm, we consider the search spaces \(\{0.1,0.01,0.001,0.0001\}\) and \(\{1.0,0.1,0.01\}\) for \(\eta_{l}\) and \(\eta_{s}\) respectively and also tune separately for every \(\alpha\). We first conduct the tuning procedure on the CIFAR-10 dataset and report the obtained hyperparameters in Table 6.

We run all iterative FL baselines using the above parameters and present the results in Table 10. Based on our results in the Table 10 for CIFAR-10, we observe that FedAdam and FedYogi consistently perform the best. Hence, to keep the experiments tractable, we tune and present just FedAdam as a representative of the iterative FL family for our evaluations on the SVHN, CIFAR-100 datasets in Section 3.3 and AG-News in Section 3.5. For FedAdam on the AG-News dataset, we note that the training is conducted using only the \(60\%\) split (see Appendix B.1) to achieve a fair comparison with FedKD. For our experiments involving the extended SVHN dataset in Section 3.3.1, we again tune the client learning rate (\(\eta_{l}\)) for the FedAvg algorithm over the search space \(\{0.1,0.01,0.001,0.0001\}\) separately for every \(\alpha\in\{0.01,0.05,0.1\}\).

\begin{table}
\begin{tabular}{c c c c c c c c c c c} \hline \hline  & \multicolumn{2}{c}{FedAvg} & \multicolumn{2}{c}{FedProx} & \multicolumn{2}{c}{FedYogi} & \multicolumn{2}{c}{FedAdam} & \multicolumn{2}{c}{FedNova} & Scaffold \\ \cline{2-10} \(\alpha\) & \(\eta_{l}\) & \(\eta_{l}\) & \(\mu\) & \(\eta_{l}\) & \(\eta_{s}\) & \(\eta_{l}\) & \(\eta_{s}\) & \(\eta_{l}\) & \(\eta_{l}\) & \(\eta_{l}\) & \(\eta_{s}\) \\ \hline \(0.01\) & \(0.01\) & \(0.01\) & \(0.01\) & \(0.01\) & \(0.01\) & - & - & \(0.001\) & \(0.0001\) & \(1.0\) \\ \(0.05\) & \(0.01\) & \(0.01\) & \(0.01\) & - & - & \(0.01\) & \(0.01\) & \(0.02\) & \(0.01\) & \(0.1\) \\ \(0.1\) & \(0.1\) & \(0.1\) & \(0.01\) & \(0.01\) & \(0.01\) & \(0.01\) & \(0.01\) & \(0.005\) & \(0.01\) & \(1.0\) \\ \hline \hline \end{tabular}
\end{table}
Table 6: Best hyperparameters obtained for the different algorithms on the CIFAR-10 dataset.

FedAvg with gradient compression.To implement FedAvg with gradient compression, we followed the sparsification and quantization schemes of STC [29]. We use the quantization level of 16-bit and sparsity of \(50\%\). This results in a communication cost reduction of \(4\times\) against standard FedAvg in every round. For each dataset and heterogeneity level, we tune the learning rate over the search space \(\{0.1,0.05,0.01,0.001\}\). We keep the remaining setup the same as FedAvg.

Multi-round FedKD.Since Fens incurs a communication cost four times that of OFL, we also evaluate FedKD with multi-round support. We explore two approaches: _i)_ pre-training for 3 rounds using FedAvg, then applying FedKD, and _ii)_ using FedKD followed by 3 fine-tuning rounds with FedAvg. In the first case, each FedKD client begins training from the global model produced by FedAvg, while in the second, FedAvg starts from the FedKD model. We observe that pre-training with FedAvg offers little improvement, likely due to the forgetting effect from multiple local training epochs, whereas fine-tuning with FedAvg boosts FedKD performance. For our experiments in Section 3.3, we thus present the multi-round version of FedKD with fine-tuning. We remark that this multi-round support is still insufficient to match the performance of Fens, which achieves significantly higher accuracy as shown in Table 7 while incurring similar communication costs.

### Fens

Clients in Fens perform local training similar to OFL baselines as described in Section 3.1 and appendix B.1. Let \(\bm{z}_{j}\in\mathbb{R}^{C}\) denote the logits obtained from each client model \(\pi_{j}\) for all \(j\in[M]\) on a given input where \(C\) is the number of classes. We use one of the two aggregator models as follows. The first one is a multilayer perceptron using ReLu activations and a final classifier head as follows: \(f=\bm{W}_{2}^{T}\sigma(\bm{W}_{1}^{T}\bm{z})\) where \(\bm{W}_{1}\in\mathbb{R}^{MC\times k},\bm{W}_{2}\in\mathbb{R}^{k\times C},\bm{ z}=\mathrm{concat}(\bm{z}_{1},\dots,\bm{z}_{M})\in\mathbb{R}^{MC}\) is the concatenated logit vector and \(\sigma(x)=\max\{x,0\}\) is the ReLU function. The parameter \(k\) determines the number of units in the hidden layer of this perceptron model. The second one is \(f=\sum_{i=1}^{M}\bm{\lambda}_{i}\odot\bm{z}_{i}\) where \(\bm{\lambda}_{1},\dots,\bm{\lambda}_{M}\in\mathbb{R}^{C}\) are weight vectors and \(\odot\) denotes coordinate-wise product. This model learns per-class per-client weights as the model parameters. For all datasets, the aggregator model is trained using the FedAdam algorithm where the learning rate is separately tuned for each dataset. Table 8 presents the tuned learning rate and tuned training parameters per dataset.

Model quantization in Fens.Clients in Fens incur a critical cost of downloading the ensemble model from the server to initiate the aggregator training. To reduce the communication burden on the clients, the server employs post-training model quantization of all received client local models from FP32 to INT8, reducing the download costs by \(4\times\). Alternatively, the quantization can also be executed on the client side. The quantization results in a drop of \(\approx 1-2\%\) test accuracy for every client model compared to the corresponding non-quantized model. However, the subsequent

\begin{table}
\begin{tabular}{c c c c c c c} \hline \hline \multirow{2}{*}{Dataset} & \multirow{2}{*}{\(\alpha\)} & \multicolumn{2}{c}{FedKD} & 3 rounds FedAvg & FedKD + & \multirow{2}{*}{Fens} \\  & & & + FedKD & 3 rounds FedAvg & \\ \hline \multirow{3}{*}{CF-10} & \(0.01\) & \(18.59\pm\).92 & \(19.31\pm\).36 & \(21.81\pm\).47 & **44.20\(\pm\)**.329 \\  & \(0.05\) & \(38.84\pm\).6.03 & \(37.92\pm\)7.04 & \(43.26\pm\)7.39 & **68.22\(\pm\)**.419 \\ \cline{1-1}  & \(0.1\) & \(64.14\pm\).5.17 & \(63.25\pm\)6.22 & \(62.61\pm\)6.17 & **75.61\(\pm\)**.185 \\ \hline \hline \end{tabular}
\end{table}
Table 7: FedKD under multi-round support on the CIFAR-10 dataset.

\begin{table}
\begin{tabular}{c c c c c c c c} \hline \hline Dataset & Aggregator Model & \(k\) & \(\eta_{l}\) & \(\eta_{s}\) & Batch Size & Local Steps & Global Rounds \\ \hline CIFAR-10 & \(f=\bm{W}_{2}^{T}\sigma(\bm{W}_{1}^{T}\bm{z})\) & \(40\) & \(1.0\) & \(0.001\) & \(128\) & \(1\) & \(500\) \\ CIFAR-100 & \(f=\sum_{i=1}^{M}\bm{\lambda}_{i}\odot\bm{z}_{i}\) & \(-\) & \(1.0\) & \(0.003\) & \(128\) & \(1\) & \(1000\) \\ SVHN & \(f=\bm{W}_{2}^{T}\sigma(\bm{W}_{1}^{T}\bm{z})\) & \(40\) & \(0.1\) & \(0.01\) & \(128\) & \(1\) & \(500\) \\ AG-News & \(f=\bm{W}_{2}^{T}\sigma(\bm{W}_{1}^{T}\bm{z})\) & \(40\) & \(1.0\) & \(0.001\) & \(128\) & \(1\) & \(500\) \\ Fed-Hear-Disease & \(f=\sum_{i=1}^{M}\bm{\lambda}_{i}\odot\bm{z}_{i}\) & \(-\) & \(0.1\) & \(0.1\) & \(2\) & \(5\) & \(50\) \\ Fed-Camelyon16 & \(f=\sum_{i=1}^{M}\bm{\lambda}_{i}\odot\bm{z}_{i}\) & \(-\) & \(1.0\) & \(0.0005\) & \(64\) & \(1\) & \(2000\) \\ Fed-ISIC2019 & \(f=\bm{W}_{2}^{T}\sigma(\bm{W}_{1}^{T}\bm{z})\) & \(24\) & \(1.0\) & \(0.001\) & \(16\) & \(1\) & \(2500\) \\ \hline \hline \end{tabular}
\end{table}
Table 8: Aggregator training in Fens. We use FedAdam as the FL algorithm with the following client (\(\eta_{l}\)) and server (\(\eta_{s}\)) learning rates. The parameter \(k\) corresponds to the weight matrices \(\bm{W}_{1}\) and \(\bm{W}_{2}\).

aggregator training phase in Fens provides resilience to this drop in the accuracy of client models in the ensemble. In fact, we observe that the final accuracy achieved after aggregator training is slightly higher when using the quantized models as compared to unquantized models due to the regularising effect of quantization on generated logits. The model quantization also provides reduced memory usage on client devices during aggregator training. We use the standard PyTorch quantization library to implement quantization in Fens.

### Aggregation rules

**Averaging.** Averaging corresponds to the following static aggregation rule: \(f=\sum_{i=1}^{M}\boldsymbol{\lambda}_{i}\odot\boldsymbol{z}_{i}\) where \(\boldsymbol{\lambda}_{i}=[\frac{1}{M},\ldots,\frac{1}{M}]\) and \(\odot\) denotes coordinate-wise product.

**Weighted Averaging.** In weighted averaging, the \(\boldsymbol{\lambda}_{1},\ldots,\boldsymbol{\lambda}_{M}\in\mathbb{R}^{C}\) are typically assigned based on local training dataset statistics. In FedKD [10], \(\boldsymbol{\lambda}_{i}=[\frac{n_{i}^{1}}{\sum_{i\in[M]}n_{i}^{1}},\frac{n_{i }^{2}}{\sum_{i\in[M]}n_{i}^{2}},\ldots,\frac{n_{i}^{C}}{\sum_{i\in[M]}n_{i}^{C }}]\) where \(n_{i}^{j}\) corresponds to the number of samples of class \(j\) with client \(i\).

**Linear.** This aggregation corresponds to having a single learnable scalar weight for each client \(f=\sum_{i=1}^{M}w_{i}\boldsymbol{z}_{i}\). The learnable parameters in this case consist of the vector \([w_{1},w_{2},\ldots,w_{M}]^{T}\).

**Neural network (NN).** Let \(\boldsymbol{z}_{j}\in\mathbb{R}^{C}\) denote the logits obtained from each client model \(\pi_{j}\) for all \(j\in[M]\) on a given input where \(C\) is the number of classes. The NN aggregation corresponds to any neural network-based model \(f:\mathcal{Z}^{M}\rightarrow\mathcal{Z}\) that operates on the logits produced by the client models. Denoting \(\boldsymbol{z}=\operatorname{concat}(\boldsymbol{z}_{1},\ldots,\boldsymbol{ z}_{M})\in\mathbb{R}^{MC}\) as the concatenated vector of logits, \(f\) corresponds to the following \(2\) layer neural network \(f=\boldsymbol{W}_{2}^{T}\sigma(\boldsymbol{W}_{1}^{T}\boldsymbol{z})\) where \(\boldsymbol{W}_{1}\in\mathbb{R}^{MC\times k},\boldsymbol{W}_{2}\in\mathbb{R}^ {k\times C}\) and \(\sigma(x)=\max\{x,0\}\) is the ReLU function. Here \(k\) determines the number of units in the hidden layer and controls the expressivity of the network. This aggregation is much more powerful than the previously mentioned aggregations, owing to its ability to discern complex patterns across all \(M\times C\) logits. The learnable parameters comprise the weight matrices \(\{\boldsymbol{W}_{1},\boldsymbol{W}_{2}\}\).

**Polychotomous Voting.** Polychotomous voting [2], was originally developed in social choice theory to reach a collective decision when offered \(C\) alternatives (classification labels in our case) in a committee of \(M\) experts (clients in our case). This method requires as input: _(i)_ classwise "competency" scores of each client: \(P_{i}^{c}(r)\) indicating the probability of \(i^{th}\)-client to vote for label \(c\) when the ground truth is \(r\); _(ii)_\(p_{prior}(r):\) prior probability distribution over correct alternatives \(r\); and _(iii)_ the "benefit" vector of the committee: \(B(c|r)\) indicating the committee's benefit in choosing label \(c\) when the correct class is \(r\). Given this information, Ben-Yashar and Paroush [2] derive a criterion for the optimal decision that maximizes expected utility. This criterion is not computed using a closed-form expression, and we generically express it as

\[f(\pi_{1},\ldots,\pi_{M};\boldsymbol{P}_{1},\ldots,\boldsymbol{P}_{M}; \boldsymbol{p}_{prior};B)\] (3)

where \(f\) corresponds to a procedure that evaluates and compares benefits for each choice \(c\in[C]\) given the competency matrices \(\{\boldsymbol{P}_{i}\}_{i=1}^{M}\), the priors \(\boldsymbol{p}_{prior}\) and the benefit function \(B\). Since the competency matrices for each client model are not directly available in our distributed setting, we learn them by federation in the network. More specifically, each client computes the competency matrix for every client model in the ensemble on its local data and transfers them to the server. The server then aggregates the received competency matrix to produce the final competency matrix per client to be used in decision-making. We further use a simple benefit function for our experiments that assigns \(B(c/r)=1\) when \(c=r\) (correct choice) and \(B(c/r)=0\) when \(c\neq r\) (incorrect choice) and set the prior to be uniform over the set of labels.

**Mixture-of-Experts (MoE).** The MoE aggregation [36] considers both the input and the logits in the following form: \(f=\sum_{i\in[M]}G(x)_{i}.\pi_{i}(x)\). Thus, MoE aggregation \(f:(\mathcal{X},\mathcal{Z}^{M})\rightarrow\mathcal{\bar{Z}}\) is more expressive compared to other aggregations which only consider logits \(f:\mathcal{Z}^{M}\rightarrow\mathcal{Z}\). Here, \(G:\mathcal{X}\rightarrow[0,1]^{M}\) is called a gating network that generates scalar weights for every expert \(\pi_{1},\ldots,\pi_{M}\) based on the input \(x\in\mathcal{X}\). In Fens with MoE aggregation, only the gating network is trained via the federation in the network while \(\{\pi_{i}\}_{i=1}^{M}\) correspond to the locally trained client models. We use a simple CNN with two convolutional blocks comprising ReLU activation and max pooling layers followed by 2 FC layers with ReLU activation, which in turn is followed by the final classification head. Despite its expressivity, learning a good gating network incurs significant communication costs and remains difficult under heterogeneous data in federated settings.

```
0:\(M\) clients, boolean _quantize_
1ProcedureFens_server():
2 Initialize model \(\pi\) with parameters \(\theta\) for local training
3 Send \(\theta\) to all \(M\) clients
4 Receive parameters of locally trained models \(\{\theta^{(i)},\ i\in[M]\}\)
5ifquantizethen
6\(\theta^{(i)}\leftarrow\texttt{quantization\_alg}(\theta^{(i)},\texttt{FP32}, \texttt{INT8})\ \forall i\in[M]\)
7 Send \(\{\theta^{(i)},\ i\in[M]\}\) to all \(M\) clients1 Initialize aggregator model \(f_{\lambda}\) with parameters \(\lambda_{0}\)
8for\(t=0,1,\ldots\)untilconvergencedo
9 Select \(S_{t}\subseteq[M]\) and send them the aggregator parameters \(\lambda_{t}\)
10 Receive updated parameters \(\{\lambda_{t}^{(i)},\ i\in S_{t}\}\)
11 Update global aggregator model \(\lambda_{t+1}:=\frac{1}{|S_{t}|}\sum_{i\in S_{t}}\lambda_{t}^{(i)}{}_{2}\) ```

**Algorithm 1**Fens from server perspective

```
0:Local dataset \(\mathcal{D}_{i}\), loss function \(\ell\), local steps \(K\) and client learning rate \(\eta_{l}\)
1ProcedureFens_client():
2 Split \(\mathcal{D}_{i}\) randomly into 90% \(\mathcal{D}_{i1}\) and 10% \(\mathcal{D}_{i2}\)
3 Receive parameters \(\theta\) from the server
4 Obtain \(\theta^{(i)}\) through local training of \(\theta\) on \(D_{i1}\)
5 Send converged model parameters \(\theta^{(i)}\) to server (one-shot)
6 Receive \(\{\theta^{(i)},\ i\in[M]\}\) from the server
7whileReceive aggregator model parameters \(\lambda_{t}\) from the serverdo
8 Initialize \(\lambda_{t}^{(i)}\leftarrow\lambda_{t}\)
9for\(k=0,1,\ldots,K\)do
10 Sample mini-batch \(b\in\mathcal{D}_{i2}\)
11\(\ell_{b}\leftarrow\frac{1}{|b|}\sum_{(x,y)\in b}\ell\left(f_{\lambda_{t}^{(i)} }(\pi_{1}(x),\ldots,\pi_{M}(x)),y\right)\)
12\(\lambda_{t}^{(i)}\leftarrow\lambda_{t}^{(i)}-\eta_{l}\nabla\ell_{b}\)
13 Send \(\lambda_{t}^{(i)}\) back to the server ```

**Algorithm 2**Fens from the clients perspective

## Appendix C Fens Algorithm

Algorithm 1 outlines the role of the server in Fens. The process begins with the server initializing the parameter \(\theta\) corresponding to the parametric model \(\pi=h_{\theta}\), which it sends to all clients for local training (lines 2-3). Once clients complete their local training, they return their updated models to the server (line 4). If quantized is enabled, the server quantizes all the local models from FP32 to INT8 using a quantization algorithm (line 6). The server then redistributes all models back to the clients (line 7), enabling each to contribute to the aggregation process that follows. In the final stage, the server iteratively trains an aggregator model in FL fashion, which is designed to combine client models into a single, improved global model (lines 9-12). During each round, the server selects a subset of clients to update the aggregator model (line 10), refining it further with each iteration until convergence.

Algorithm 2 explains the client-side process in FENS. Each client starts by splitting its local dataset into two parts: one for one-shot local training and a smaller part for the iterative aggregator training (line 2). Using the received model, clients first train on \(\mathcal{D}_{i1}\) (line 4) and send their converged local model back to the server (line 5). In subsequent rounds, clients receive from the server the aggregator model (line 7) which they refine it locally using \(\mathcal{D}_{i2}\) (lines 8-12). Finally, clients send the updated aggregator parameters back to the server (line 13), contributing to the global aggregation process.

[MISSING_PAGE_EMPTY:20]

[MISSING_PAGE_FAIL:21]

### NeurIPS Paper Checklist

1. **Claims** Question: Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope? Answer: [Yes] Justification: Our claims in the abstract and the introductions are appropriately scoped and well supported through our extensive empirical assessments spanning multiple datasets, baselines and settings. Guidelines: * The answer NA means that the abstract and introduction do not include the claims made in the paper. * The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers. * The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings. * It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper.
2. **Limitations** Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] Justification: We have discussed the limitations of our work in Section 4. Guidelines: * The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper. * The authors are encouraged to create a separate "Limitations" section in their paper. * The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be. * The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated. * The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon. * The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size. * If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness. * While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren't acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations.
3. **Theory Assumptions and Proofs** Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof?Answer: [NA]  Justification: The paper does not include theoretical results. Guidelines: * The answer NA means that the paper does not include theoretical results. * All the theorems, formulas, and proofs in the paper should be numbered and cross-referenced. * All assumptions should be clearly stated or referenced in the statement of any theorems. * The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition. * Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material. * Theorems and Lemmas that the proof relies upon should be properly referenced.
4. **Experimental Result Reproducibility** Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? Answer: [Yes] Justification: We have included elaborate descriptions regarding the setup and hyperparameters needed to reproduce the paper in Appendix B, complementing our description in Section 3.1. Guidelines: * The answer NA means that the paper does not include experiments. * If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not. * If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable. * Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed. * While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example 1. If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. 2. If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. 3. If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). 4. We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results.
5. **Open access to data and code**Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? Answer: [Yes] Justification: We open-source our code at https://github.com/sacs-epfl/fens. Guidelines:

* The answer NA means that paper does not include experiments requiring code.
* Please see the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details.
* While we encourage the release of code and data, we understand that this might not be possible, so "No" is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).
* The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details.
* The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.
* The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.
* At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).
* Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
6. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: Yes, we have included all details in Section 3.1 and Appendix B. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material.
7. **Experiment Statistical Significance** Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? Answer: [Yes] Justification: Each of our experiments is repeated with at least three random seeds. We report standard deviations in all tables and display the \(95\%\) confidence intervals in our plots. Guidelines: * The answer NA means that the paper does not include experiments. * The authors should answer "Yes" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. * The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).

* The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)
* The assumptions made should be given (e.g., Normally distributed errors).
* It should be clear whether the error bar is the standard deviation or the standard error of the mean.
* It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis of Normality of errors is not verified.
* For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).
* If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text.
8. **Experiments Compute Resources** Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? Answer: [Yes] Justification: We have included the details on compute resources in Appendix E. Guidelines: * The answer NA means that the paper does not include experiments. * The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage. * The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute. * The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn't make it into the paper).
9. **Code Of Ethics** Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? Answer: [Yes] Justification: We have reviewed the Code of Ethics and believe our work adheres to these guidelines. Guidelines: * The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics. * If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics. * The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction).
10. **Broader Impacts** Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? Answer: [Yes] Justification: We have discussed the broad impacts of our work in Appendix F. Guidelines: * The answer NA means that there is no societal impact of the work performed. * If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.

* Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.
* The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.
* The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.
* If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML).

11. **Safeguards** Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? Answer: [NA] Justification: The paper poses no such risks. Guidelines: * The answer NA means that the paper poses no such risks. * Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters. * Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images. * We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort.

12. **Licenses for existing assets** Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? Answer: [Yes] Justification: We affirm that the medical datasets employed in our experiments within the FLamby benchmark were acquired and utilized in strict accordance with their respective licensing agreements and ethical guidelines. We obtained the necessary permissions and approvals from the appropriate authorities and/or institutions responsible for data collection, and we adhered to all relevant ethical standards and regulations. The owners of the original assets used in this paper were properly cited and attributed. Guidelines:

* The answer NA means that the paper does not use existing assets.
* The authors should cite the original paper that produced the code package or dataset.
* The authors should state which version of the asset is used and, if possible, include a URL.
* The name of the license (e.g., CC-BY 4.0) should be included for each asset.

* For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.
* If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.
* For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.
* If this information is not available online, the authors are encouraged to reach out to the asset's creators.
* **New Assets*
* Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? Answer: [Yes] Justification: We open-source our code at: https://github.com/sacs-epfl/fens. Our repository is well documented with all the instructions to run the code. Guidelines:
* The answer NA means that the paper does not release new assets.
* Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.
* The paper should discuss whether and how consent was obtained from people whose asset is used.
* At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file.
* **Crowdsourcing and Research with Human Subjects*
* Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? Answer: [NA] Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines:
* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.
* According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector.
* **Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects*
* Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? Answer: [NA] Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines:
* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.
* We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.
* For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review.