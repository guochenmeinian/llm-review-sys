[MISSING_PAGE_FAIL:1]

_scan_: distance computation w.r.t all points in the retrieved cluster to find the nearest neighbor (NN). Standard IVF utilizes the same high-dimensional \(\mathrm{RR}\) for both phases, which can be sub-optimal.

**Why the sub-optimality?** Imagine one needs to partition a dataset into \(k\) clusters for IVF and the dimensionality of the data is \(d-\text{IVF}\) uses full \(d\) representation to partition into \(k\) clusters. However, suppose we have an alternate approach that somehow projects the data in \(d/2\) dimensions and learns \(2k\) clusters. Note that the storage and computation to find the nearest cluster remains the same in both cases, i.e., when we have \(k\) clusters of \(d\) dimensions or \(2k\) clusters of \(d/2\) dimensions. \(2k\) clusters can provide significantly more refined partitioning, but the distances computed between queries and clusters could be significantly more inaccurate after projection to \(d/2\) dimensions.

So, if we can find a mechanism to obtain a \(d/2\)-dimensional representation of points that can accurately approximate the topology/distances of \(d\)-dimensional representation, then we can potentially build significantly better ANNS structure that utilizes different capacity representations for the cluster mapping and linear scan phases of IVF. But how do we find such _adaptive representations?_ These desired adaptive representations should be cheap to obtain and still ensure distance preservation across dimensionality. Post-hoc dimensionality reduction techniques like SVD [14] and random projections [25] on high-dimensional \(\mathrm{RRs}\) are potential candidates, but our experiments indicate that in practice they are highly inaccurate and do not preserve distances well enough (Figure 2).

Instead, we identify that the recently proposed Matryoshka Representations (\(\mathrm{MRs}\)) [31] satisfy the specifications for adaptive representations. Matryoshka representations pack information in a hierarchical nested manner, i.e., the first \(m\)-dimensions of the \(d\)-dimensional \(\mathrm{MR}\) form an accurate low-dimensional representation while being aware of the information in the higher dimensions. This allows us to deploy \(\mathrm{MRs}\) in two major and novel ways as part of ANNS: (a) low-dimensional representations for accuracy-compute optimal clustering and quantization, and (b) high-dimensional representations for precise re-ranking when feasible.

To this effort, we introduce \(\mathrm{AdANNS}\), a novel design framework for semantic search that uses matryoshka representation-based _adaptive representations_ across different stages of ANNS to ensure significantly better accuracy-compute trade-off than the state-of-the-art baselines.

Typical ANNS systems have two key components: (a) search data structure to store datapoints, (b) distance computation to map a given query to points in the data structure. Through \(\mathrm{AdANNS}\), we address both these components and significantly improve their performance. In particular, we first propose \(\mathrm{AdANNS}\)-IVF (Section 4.1) which tackles the first component of ANNS systems. \(\mathrm{AdANNS}\)-IVF uses standard full-precision computations but uses adaptive representations for different IVF stages. On ImageNet 1-NN image retrieval (Figure 0(a)), \(\mathrm{AdANNS}\)-IVF is up to \(1.5\%\) more accurate for the compute budget and \(90\times\) cheaper in deployment for the same accuracy as IVF.

Figure 1: \(\mathrm{AdANNS}\) helps design search data structures and quantization methods with _better accuracy-compute trade-offs_ than the existing solutions. In particular, (a) \(\mathrm{AdANNS}\)-IVF improves on standard IVF by up to \(1.5\%\) in accuracy while being \(90\times\) faster in deployment and (b) \(\mathrm{AdANNS}\)-OPQ is as accurate as the baseline at _half the cost!_ Rigid-IVF and Rigid-OPQ are standard techniques that are built on rigid representations (\(\mathrm{RRs}\)) while \(\mathrm{AdANNS}\) uses matryoshka representations (\(\mathrm{MRs}\)) [31].

We then propose \(\mathrm{AdANNS}\)-OPQ (Section 4.2) which addresses the second component by using \(\mathrm{AdANNS}\)-based quantization (OPQ [13]) - here we use exhaustive search overall points. \(\mathrm{AdANNS}\)-OPQ is as accurate as the baseline OPQ on \(\mathrm{RRs}\) while being at least \(\mathbf{2}\times\) faster on Natural Questions [32] 1-NN passage retrieval (Figure 0(b)). Finally, we combine the two techniques to obtain \(\mathrm{AdANNS}\)-IVFOPQ (Section 4.3) which is more accurate while being much cheaper - up to \(\mathbf{8}\times\) - than the traditional IVFOPQ [24] index. To demonstrate generality of our technique, we adapt \(\mathrm{AdANNS}\) to DiskANN [22] which provides interesting accuracy-compute tradeoff; see Table 1.

While \(\mathrm{MR}\) already has multi-granular representations, careful integration with ANNS building blocks is critical to obtain a practical method and is _our main contribution_. In fact, Kusupati et al. [31] proposed a simple adaptive retrieval setup that uses smaller-dimensional \(\mathrm{MR}\) for shortlisting in retrieval followed by precise re-ranking with a higher-dimensional \(\mathrm{MR}\). Such techniques, unfortunately, cannot be scaled to industrial systems as they require forming a new index for every shortlisting provided by low-dimensional \(\mathrm{MR}\). Ensuring that the method aligns well with the modern-day ANNS pipelines is important as they already have mechanisms to handle real-world constraints like load-balancing [16] and random access from disk [22]. So, \(\mathrm{AdANNS}\) is a step towards making the abstraction of adaptive search and retrieval feasible at the web-scale.

Through extensive experimentation, we also show that \(\mathrm{AdANNS}\) generalizes across search data structures, distance approximations, modalities (text & image), and encoders (CNNs & Transformers) while still translating the theoretical gains to latency reductions in deployment. While we have mainly focused on IVF and OPQ-based ANNS in this work, \(\mathrm{AdANNS}\) also blends well with other ANNS pipelines. We also show that \(\mathrm{AdANNS}\) can enable compute-aware elastic search on prebuilt indices without making any modifications (Section 5.1); note that this is in contrast to \(\mathrm{AdANNS}\)-IVF that builds the index explicitly utilizing "adaptivity" in representations. Finally, we provide an extensive analysis on the alignment of matryoshka representation for better semantic search (Section 5.2).

**We make the following key contributions:**

* We introduce \(\mathrm{AdANNS}\), a novel framework for semantic search that leverages matryoshka representations for designing ANNS systems with better accuracy-compute trade-offs.
* \(\mathrm{AdANNS}\) powered search data structure (\(\mathrm{AdANNS}\)-IVF) and quantization (\(\mathrm{AdANNS}\)-OPQ) show a significant improvement in accuracy-compute tradeoff compared to existing solutions.
* \(\mathrm{AdANNS}\) generalizes to modern-day composite ANNS indices and can also enable compute-aware elastic search during inference with no modifications.

## 2 Related Work

Approximate nearest neighbour search (ANNS) is a paradigm to come as close as possible [7] to retrieving the "true" nearest neighbor (NN) without the exorbitant search costs associated with exhaustive search [21; 52]. The "approximate" nature comes from data pruning as well as the cheaper distance computation that enable real-time web-scale search. In its naive form, NN-search has a complexity of \(\mathcal{O}(dN)\); \(d\) is the data dimensionality used for distance computation and \(N\) is the size of the database. ANNS employs each of these approximations to reduce the linear dependence on the dimensionality (cheaper distance computation) and data points visited during search (data pruning).

**Cheaper distance computation.** From a bird's eye view, cheaper distance computation is always obtained through dimensionality reduction (quantization included). PCA and SVD [14; 26] can reduce dimensionality and preserve distances only to a limited extent without sacrificing accuracy. On the other hand, quantization-based techniques [6; 15] like (optimized) product quantization ((O)PQ) [13; 23] have proved extremely crucial for relatively accurate yet cheap distance computation and simultaneously reduce the memory overhead significantly. Another naive solution is to independently train the representation function with varying low-dimensional information bottlenecks [31] which is rarely used due to the costs of maintaining multiple models and databases.

**Data pruning.** Enabled by various data structures, data pruning reduces the number of data points visited as part of the search. This is often achieved through hashing [8; 46], trees [3; 12; 16; 48] and graphs [22; 38]. More recently there have been efforts towards end-to-end learning of the search data structures [17; 29; 30]. However, web-scale ANNS indices are often constructed on rigid \(d\)-dimensional real vectors using the aforementioned data structures that assist with the real-time search. For a more comprehensive review of ANNS structures please refer to [5; 34; 51].

**Composite indices.** ANNS pipelines often benefit from the complementary nature of various building blocks [24; 42]. In practice, often the data structures (coarse-quantizer) like IVF [48] and HNSW [37] are combined with cheaper distance alternatives like PQ [23] (fine-quantizer) for massive speed-ups in web-scale search. While the data structures are built on \(d\)-dimensional real vectors, past works consistently show that PQ can be safely used for distance computation during search time. As evident in modern web-scale ANNS systems like DiskANN [22], the data structures are built on \(d\)-dimensional real vectors but work with PQ vectors (\(32-64\)-byte) for fast distance computations.

**ANNS benchmark datasets.** Despite the Herculean advances in representation learning [19; 42], ANNS progress is often only benchmarked on fixed representation vectors provided for about a dozen million to billion scale datasets [1; 47] with limited access to the raw data. This resulted in the improvement of algorithmic design for rigid representations (\(\mathrm{RRs}\)) that are often not specifically designed for search. All the existing ANNS methods work with the assumption of using the provided \(d\)-dimensional representation which might not be Pareto-optimal for the accuracy-compute trade-off in the first place. Note that the lack of raw-image and text-based benchmarks led us to using ImageNet-1K [45] (1.3M images, 50K queries) and Natural Questions [32] (21M passages, 3.6K queries) for experimentation. While not billion-scale, the results observed on ImageNet often translate to real-world progress [28], and Natural Questions is one of the largest question answering datasets benchmarked for dense passage retrieval [27], making our results generalizable and widely applicable.

In this paper, we investigate the utility of adaptive representations - embeddings of different dimensionalities having similar semantic information - in improving the design of ANNS algorithms. This helps in transitioning out of restricted construction and inference on rigid representations for ANNS. To this end, we extensively use Matryoshka Representations (\(\mathrm{MRs}\)) [31] which have desired adaptive properties in-built. To the best of our knowledge, this is the first work that improves accuracy-compute trade-off in ANNS by leveraging adaptive representations on different phases of construction and inference for ANNS data structures.

## 3 Problem Setup, Notation, and Preliminaries

The problem setup of approximate nearest neighbor search (ANNS) [21] consists of a database of \(N\) data points, \([x_{1},x_{2},\ldots,x_{N}]\), and a query, \(q\), where the goal is to "approximately" retrieve the nearest data point to the query. Both the database and query are embedded to \(\mathbb{R}^{d}\) using a representation function \(\phi:\mathcal{X}\to\mathbb{R}^{d}\), often a neural network that can be learned through various representation learning paradigms [2; 19; 40; 42; 20].

Matryoshka Representations (\(\mathrm{MRs}\)).The \(d\)-dimensional representations from \(\phi\) can have a nested structure like Matryoshka Representations (\(\mathrm{MRs}\)) [31] in-built \(-\phi^{\mathrm{MR}(d)}\). Matryoshka Representation Learning (MRL) learns these nested representations with a simple strategy of optimizing the same training objective at varying dimensionalities. These granularities are ordered such that the lowest representation size forms a prefix for the higher-dimensional representations. So, high-dimensional \(\mathrm{MR}\) inherently contains low-dimensional representations of varying granularities that can be accessed for free - first \(m\)-dimensions (\(m\in[d]\)) ie., \(\phi^{\mathrm{MR}(d)}[1:m]\) from the \(d\)-dimensional \(\mathrm{MR}\) form an \(m\)-dimensional representation which is as accurate as its independently trained rigid representation (\(\mathrm{RR}\)) counterpart - \(\phi^{\mathrm{RR}(m)}\). Training an encoder with MRL does not involve any overhead or hyperparameter tuning and works seamlessly across modalities, training objectives, and architectures.

Inverted File Index (IVF).IVF [48] is an ANNS data structure used in web-scale search systems [16] owing to its simplicity, minimal compute overhead, and high accuracy. IVF construction involves clustering (coarse quantization through k-means) [36] on \(d\)-dimensional representation that results in an inverted file list [53] of all the data points in each cluster. During search, \(d\)-dimensional query representation is assigned to the most relevant cluster (\(C_{i};i\in[k]\)) by finding the closest centroid (\(\mu_{i}\)) using an appropriate distance metric (\(L_{2}\) or cosine). This is followed by an exhaustive linear search across all data points in the cluster which gives the closest NN (see Figure 5 in Appendix A for IVF overview). Lastly, IVF can scale to web-scale by utilizing a hierarchical IVF structure within each cluster [16]. Table 2 in Appendix A describes the retrieval formula for multiple variants of IVF.

Optimized Product Quantization (OPQ).Product Quantization (PQ) [23] works by splitting a \(d\)-dimensional real vector into \(m\) sub-vectors and quantizing each sub-vector with an independentlength codebook across the database. After PQ, each \(d\)-dimensional vector can be represented by a compact \(m\times b\) bit vector; we make each vector \(m\) bytes long by fixing \(b=8\). During search time, distance computation between the query vector and PQ database is extremely efficient with only \(m\) codebook lookups. The generality of PQ encompasses scalar/vector quantization [15, 36] as special cases. However, PQ can be further improved by rotating the \(d\)-dimensional space appropriately to maximize distance preservation after PQ. Optimized Product Quantization (OPQ) [13] achieves this by learning an orthonormal projection matrix \(R\) that rotates the \(d\)-dimensional space to be more amenable to PQ. OPQ shows consistent gains over PQ across a variety of ANNS tasks and has become the default choice in standard composite indices [22, 24].

Datasets.We evaluate the ANNS algorithms while changing the representations used for the search thus making it impossible to evaluate on the usual benchmarks [1]. Hence we experiment with two public datasets: (a) ImageNet-1K [45] dataset on the task of image retrieval - where the goal is to retrieve images from a database (1.3M image train set) belonging to the same class as the query image (50K image validation set) and (b) Natural Questions (NQ) [32] dataset on the task of question answering through dense passage retrieval - where the goal is to retrieve the relevant passage from a database (21M Wikipedia passages) for a query (3.6K questions).

MetricsPerformance of ANNS is often measured using recall score [22], \(k\)-recall@\(N\) - recall of the exact NN across search complexities which denotes the recall of \(k\) "true" NN when \(N\) data points are retrieved. However, the presence of labels allows us to compute 1-NN (top-1) accuracy. Top-1 accuracy is a harder and more fine-grained metric that correlates well with typical retrieval metrics like recall and mean average precision (mAP@\(k\)). Even though we report top-1 accuracy by default during experimentation, we discuss other metrics in Appendix C. Finally, we measure the compute overhead of ANNS using MFLOPS/query and also provide wall-clock times (see Appendix B.1).

Encoders.For ImageNet, we encode both the database and query set using a ResNet50 (\(\phi_{I}\)) [19] trained on ImageNet-1K. For NQ, we encode both the passages in the database and the questions in the query set using a BERT-Base (\(\phi_{N}\)) [10] model fine-tuned on NQ for dense passage retrieval [27].

We use the trained ResNet50 models with varying representation sizes (\(d=[8,16,\ldots,2048]\); default being \(2048\)) as suggested by Kusupati et al. [31] alongside the MRL-ResNet50 models trained with MRL for the same dimensionalities. The \(\mathrm{RR}\) and \(\mathrm{MR}\) models are trained to ensure the supervised one-vs-all classification accuracy across all data dimensionalities is nearly the same - 1-NN accuracy of \(2048\)-\(d\)\(\mathrm{RR}\) and \(\mathrm{MR}\) models are \(71.19\%\) and \(70.97\%\) respectively on ImageNet-1K. Independently trained models, \(\phi_{I}^{\mathrm{RR}(d)}\), output \(d=[8,16\ldots,2048]\) dimensional \(\mathrm{RR}\)s while a single MRL-ResNet50 model, \(\phi_{I}^{\mathrm{MR}(d)}\), outputs a \(d=2048\)-dimensional \(\mathrm{MR}\) that contains all the 9 granularities.

We also train BERT-Base models in a similar vein as the aforementioned ResNet50 models. The key difference is that we take a pre-trained BERT-Base model and fine-tune on NQ as suggested by Karpukhin et al. [27] with varying (5) representation sizes (bottlenecks) (\(d=[48,96,\ldots,768]\); default being \(768\)) to obtain \(\phi_{N}^{\mathrm{RR}(d)}\) that creates \(\mathrm{RR}\)s for the NQ dataset. To get the MRL-BERT-Base model, we fine-tune a pre-trained BERT-Base encoder on the NQ train dataset using the MRL objective with the same granularities as \(\mathrm{RR}\)s to obtain \(\phi_{N}^{\mathrm{MR}(d)}\) which contains all five granularities. Akin to ResNet50 models, the \(\mathrm{RR}\) and \(\mathrm{MR}\) BERT-Base models on NQ are built to have similar 1-NN accuracy for \(768\)-\(d\) of \(52.2\%\) and \(51.5\%\) respectively. More implementation details can be found in Appendix B and additional experiment-specific information is provided at the appropriate places.

## 4 \(\mathrm{AdAnns}\) - Adaptive ANNS

In this section, we present our proposed \(\mathrm{AdAnns}\) - framework that exploits the inherent flexibility of matryoshka representations to improve the accuracy-compute trade-off for semantic search components. Standard ANNS pipeline can be split into two key components: (a) search data structure that indexes and stores data points, (b) query-point computation method that outputs (approximate) distance between a given query and data point. For example, standard IVFOPQ [24] method uses an IVF structure to index points on full-precision vectors and then relies on OPQ for more efficient distance computation between the query and the data points during the linear scan.

Below, we show that \(\mathrm{AdANNS}\) can be applied to both the above-mentioned ANNS components and provides significant gains on the computation-accuracy tradeoff curve. In particular, we present \(\mathrm{AdANNS}\)-IVF which is \(\mathrm{AdANNS}\) version of the standard IVF index structure [48], and the closely related ScaNN structure [16]. We also present \(\mathrm{AdANNS}\)-OPQ which introduces representation adaptivity in the OPQ, an industry-default quantization. Then, in Section 4.3 we further demonstrate the combination of the two techniques to get \(\mathrm{AdANNS}\)-IVFOPQ - an \(\mathrm{AdANNS}\) version of IVFOPQ [24] - and \(\mathrm{AdANNS}\)-DiskANN, a similar variant of DiskANN [22]. Overall, our experiments show that \(\mathrm{AdANNS}\)-IVF is significantly more accuracy-compute optimal compared to the IVF indices built on \(\mathrm{RRs}\) and \(\mathrm{AdANNS}\)-OPQ is as accurate as the OPQ on \(\mathrm{RRs}\) while being significantly cheaper.

### \(\mathrm{AdANNS}\)-IVF

Recall from Section 1 that IVF has a clustering and a linear scan phase, where both phase use same dimensional rigid representation. Now, \(\mathrm{AdANNS}\)-IVF allows the clustering phase to use the first \(d_{c}\) dimensions of the given matyoshka representation (\(\mathrm{MR}\)). Similarly, the linear scan within each cluster uses \(d_{s}\) dimensions, where again \(d_{s}\) represents top \(d_{s}\) coordinates from \(\mathrm{MR}\). Note that setting \(d_{c}=d_{s}\) results in non-adaptive regular IVF. Intuitively, we would set \(d_{c}\ll d_{s}\), so that instead of clustering with a high-dimensional representation, we can approximate it accurately with a low-dimensional embedding of size \(d_{c}\) followed by a linear scan with a higher \(d_{s}\)-dimensional representation. Intuitively, this helps in the smooth search of design space for state-of-the-art accuracy-compute trade-off. Furthermore, this can provide a precise operating point on accuracy-compute tradeoff curve which is critical in several practical settings.

Our experiments on regular IVF with \(\mathrm{MRs}\) and \(\mathrm{RRs}\) (IVF-\(\mathrm{MR}\) & IVF-\(\mathrm{RR}\)) of varying dimensionalities and IVF configurations (# clusters, # probes) show that (Figure 2) matryoshka representations result in a significantly better accuracy-compute trade-off. We further studied and found that learned lower-dimensional representations offer better accuracy-compute trade-offs for IVF than higher-dimensional embeddings (see Appendix E for more results).

\(\mathrm{AdANNS}\) utilizes \(d\)-dimensional matryoshka representation to get accurate \(d_{c}\) and \(d_{s}\) dimensional vectors at no extra compute cost. The resulting \(\mathrm{AdANNS}\)-IVF provides a much better accuracy-compute trade-off (Figure 2) on ImageNet-1K retrieval compared to IVF-\(\mathrm{MR}\), IVF-\(\mathrm{RR}\), and MG-IVF-\(\mathrm{RR}\) - multi-granular IVF with rigid representations (akin to \(\mathrm{AdANNS}\) without \(\mathrm{MR}\)) - a strong baseline that uses \(d_{c}\) and \(d_{s}\) dimensional \(\mathrm{RRs}\). Finally, we exhaustively search the design space of IVF by varying \(d_{c},d_{s}\in[8,16,\ldots,2048]\) and the number of clusters \(k\in[8,16,\ldots,2048]\). Please see Appendix E for more details. For IVF experiments on the NQ dataset, please refer to Appendix G.

Empirical results.Figure 2 shows that \(\mathrm{AdANNS}\)-IVF outperforms the baselines across all accuracy-compute settings for ImageNet-1K retrieval. \(\mathrm{AdANNS}\)-IVF results in \(10\times\) lower compute for the best accuracy of the extremely expensive MG-IVF-\(\mathrm{RR}\) and non-adaptive IVF-\(\mathrm{MR}\). Specifically, as shown in Figure 0(a), \(\mathrm{AdANNS}\)-IVF is up to \(1.5\%\) more accurate for the same compute and has up to \(100\times\) lesser FLOPS/query (\(90\times\) real-world speed-up!) than the status quo ANNS on rigid representations (IVF-\(\mathrm{RR}\)). We filter out points for the sake of presentation and encourage the reader to check out Figure 8 in Appendix E for an expansive plot of all the configurations searched.

The advantage of \(\mathrm{AdANNS}\) for construction of search structures is evident from the improvements in IVF (\(\mathrm{AdANNS}\)-IVF) and can be easily extended to other ANNS structures like ScaNN [16] and

Figure 2: 1-NN accuracy on ImageNet retrieval shows that \(\mathrm{AdANNS}\)-IVF achieves near-optimal accuracy-compute trade-off compared across various rigid and adaptive baselines. Both adaptive variants of \(\mathrm{MR}\) and \(\mathrm{RR}\) significantly outperform their rigid counterparts (IVF-XX) while post-hoc compression on \(\mathrm{RR}\) using SVD for adaptivity falls short.

HNSW [38]. For example, HNSW consists of multiple layers with graphs of NSW graphs [37] of increasing complexity. \(\mathrm{AdANNS}\) can be adopted to HNSW, where the construction of each level can be powered by appropriate dimensionalities for an optimal accuracy-compute trade-off. In general, \(\mathrm{AdANNS}\) provides fine-grained control over compute overhead (storage, working memory, inference, and construction cost) during construction and inference while providing the best possible accuracy.

### \(\mathrm{AdANNS}\)-Opq

Standard Product Quantization (PQ) essentially performs block-wise vector quantization via clustering. For example, suppose we need \(32\)-byte PQ compressed vectors from the given \(2048\) dimensional representations. Then, we can chunk the representations in \(m=32\) equal blocks/sub-vectors of \(64\)-d each, and each sub-vector space is clustered into \(2^{8}=256\) partitions. That is, the representation of each point is essentially cluster-id for each block. Optimized PQ (OPQ) [13] further refines this idea, by first rotating the representations using a learned orthogonal matrix, and then applying PQ on top of the rotated representations. In ANNS, OPQ is used extensively to compress vectors and improves approximate distance computation primarily due to significantly lower memory overhead than storing full-precision data points IVF.

\(\mathrm{AdANNS}\)-OPQ utilizes \(\mathrm{MR}\) representations to apply OPQ on lower-dimensional representations. That is, for a given quantization budget, \(\mathrm{AdANNS}\) allows using top \(d_{s}\ll d\) dimensions from \(\mathrm{MR}\) and then computing clusters with \(d_{s}/m\)-dimensional blocks where \(m\) is the number of blocks. Depending on \(d_{s}\) and \(m\), we have further flexibility of trading-off dimensionality/capacity for increasing the number of clusters to meet the given quantization budget. \(\mathrm{AdANNS}\)-OPQ tries multiple \(d_{s}\), \(m\), and number of clusters for a fixed quantization budget to obtain the best performing configuration.

We experimented with \(8-128\) byte OPQ budgets for both ImageNet and Natural Questions retrieval with an exhaustive search on the quantized vectors. We compare \(\mathrm{AdANNS}\)-OPQ which uses \(\mathrm{MRs}\) of varying granularities to the baseline OPQ built on the highest dimensional \(\mathrm{RRs}\). We also evaluate OPQ vectors obtained projection using SVD [14] on top of the highest-dimensional \(\mathrm{RRs}\).

Empirical results.Figures 3 and 1b show that \(\mathrm{AdANNS}\)-OPQ significantly outperforms - up to \(4\%\) accuracy gain - the baselines (OPQ on \(\mathrm{RRs}\)) across compute budgets on both ImageNet and NQ. In particular, \(\mathrm{AdANNS}\)-OPQ tends to match the accuracy of a \(64\)-byte (a typical choice in ANNS) OPQ baseline with only a \(32\)-byte budget. This results in a \(2\times\) reduction in both storage and compute FLOPS which translates to significant gains in real-world web-scale deployment (see Appendix D). We only report the best \(\mathrm{AdANNS}\)-OPQ for each budget typically obtained through a much lower-dimensional \(\mathrm{MR}\) (\(128\) & \(192\); much faster to build as well) than the highest-dimensional \(\mathrm{MR}\) (\(2048\) & \(768\)) for ImageNet and NQ respectively (see Appendix G for more details). At the same time, we note that building compressed OPQ vectors on projected \(\mathrm{RRs}\) using SVD to the smaller dimensions (or using low-dimensional \(\mathrm{RRs}\), see Appendix D) as the optimal \(\mathrm{AdANNS}\)-OPQ does not help in improving the accuracy. The significant gains we observe in \(\mathrm{AdANNS}\)-OPQ are purely due to better information packing in \(\mathrm{MRs}\) - we hypothesize that packing the most important information in the initial coordinates results in a better PQ quantization than \(\mathrm{RRs}\) where the information is uniformly distributed across all the dimensions [31, 49]. See Appendix D for more details and experiments.

### \(\mathrm{AdANNS}\) for Composite Indices

We now extend \(\mathrm{AdANNS}\) to composite indices [24] which put together two main ANNS building blocks - search structures and quantization - together to obtain efficient web-scale ANNS indices used in practice. A simple instantiation of a composite index would be the combination of IVF and OPQ - IVFOPQ - where the clustering in IVF happens with full-precision real vectors but the linear scan within each cluster is approximated using OPQ-compressed variants of the representation - since often the full-precision vectors of the database cannot fit in RAM. Contemporary ANNS indices like DiskANN [22] make this a default choice where they build the search graph with a full-precision vector and approximate the distance computations during search with an OPQ-compressed vector to obtain a very small shortlist of retrieved datapoints. In DiskANN, the shortlist of data points is then re-ranked to form the final list using their full-precision vectors fetched from the disk. \(\mathrm{AdANNS}\) is naturally suited to this shortlist-rerank framework: we use a low-\(d\)\(\mathrm{MR}\) for forming index, where we could tune \(\mathrm{AdANNS}\) parameters according to the accuracy-compute trade-off of the graph and OPQ vectors. We then use a high-\(d\)\(\mathrm{MR}\) for re-ranking.

Empirical results.Figure 4 shows that \(\mathrm{AdANNS}\)-IVFOPQ is \(1-4\%\) better than the baseline at all the PQ compute budgets. Furthermore, \(\mathrm{AdANNS}\)-IVFOPQ has the same accuracy as the baselines at \(8\times\) lower overhead. With DiskANN, \(\mathrm{AdANNS}\) accelerates shortlist generation by using low-dimensional representations and recoups the accuracy by re-ranking with the highest-dimensional \(\mathrm{MR}\) at negligible cost. Table 1 shows that \(\mathrm{AdANNS}\)-DiskANN is more accurate than the baseline for both 1-NN and ranking performance at only \(half\) the cost. Using low-dimensional representations further speeds up inference in \(\mathrm{AdANNS}\)-DiskANN (see Appendix F).

These results show the generality of \(\mathrm{AdANNS}\) and its broad applicability across a variety of ANNS indices built on top of the base building blocks. Currently, \(\mathrm{AdANNS}\) piggybacks on typical ANNS pipelines for their inherent accounting of the real-world system constraints [16, 22, 25]. However, we believe that \(\mathrm{AdANNS}\)'s flexibility and significantly better accuracy-compute trade-off can be further informed by real-world deployment constraints. We leave this high-potential line of work that requires extensive study to future research.

## 5 Further Analysis and Discussion

### Compute-aware Elastic Search During Inference

\(\mathrm{AdANNS}\) search structures cater to many specific large-scale use scenarios that need to satisfy precise resource constraints during construction as well as inference. However, in many cases, construction and storage of the indices are not the bottlenecks or the user is unable to search the design space. In these settings, \(\mathrm{AdANNS}\)-D enables adaptive inference through accurate yet cheaper distance computation using the low-dimensional prefix of matryoshka representation. Akin to composite indices (Section 4.3) that use PQ vectors for cheaper distance computation, we can use the low-dimensional \(\mathrm{MR}\) for faster distance computation on ANNS structure built _non-adaptively_ with a high-dimensional \(\mathrm{MR}\) without any modifications to the existing index.

Empirical results.Figure 2 shows that for a given compute budget using IVF on ImageNet-1K retrieval, \(\mathrm{AdANNS}\)-IVF is better than \(\mathrm{AdANNS}\)-IVF-D due to the explicit control during the building of the ANNS structure which is expected. However, the interesting observation is that \(\mathrm{AdANNS}\)-D _matches or outperforms_ the IVF indices built with \(\mathrm{MRs}\) of varying capacities for ImageNet retrieval.

However, these methods are applicable in specific scenarios of deployment. Obtaining optimal \(\mathrm{AdANNS}\) search structure (highly accurate) or even the best IVF-MR index relies on a relatively expensive design search but delivers indices that fit the storage, memory, compute, and accuracy constraints all at once. On the other hand \(\mathrm{AdANNS}\)-D does not require a precisely built ANNS index but can enable compute-aware search during inference. \(\mathrm{AdANNS}\)-D is a great choice for setups that can afford only one single database/index but need to cater to varying deployment constraints, e.g., one task requires 70% accuracy while another task has a compute budget of 1 MFLOPS/query.

### Why \(\mathrm{MRs}\) over \(\mathrm{RRs}\)?

Quite a few of the gains from \(\mathrm{AdANNS}\) are owing to the quality and capabilities of matryoshka representations. So, we conducted extensive analysis to understand why matryoshka representations seem to be more aligned for semantic search than the status-quo rigid representations.

**Difficulty of NN search.** Relative contrast (\(C_{r}\)) [18] is inversely proportional to the difficulty of nearest neighbor search on a given database. On ImageNet-1K, Figure 14 shows that \(\mathrm{MRs}\) have better \(C_{r}\) than \(\mathrm{RRs}\) across dimensionalities, further supporting that matryoshka representations are more aligned (easier) for NN search than existing rigid representations for the same accuracy. More details and analysis about this experiment can be found in Appendix H.2.

**Clustering distributions.** We also investigate the potential deviation in clustering distributions for \(\mathrm{MRs}\) across dimensionalities compared to \(\mathrm{RRs}\). Unlike the \(\mathrm{RRs}\) where the information is uniformly diffused across dimensions [49], \(\mathrm{MRs}\) have hierarchical information packing. Figure 11 in Appendix E.3 shows that matryoshka representations result in clusters similar (measured by total variation distance [33]) to that of rigid representations and do not result in any unusual artifacts.

**Robustness.** Figure 9 in Appendix E shows that \(\mathrm{MRs}\) continue to be better than \(\mathrm{RRs}\) even for out-of-distribution (OOD) image queries (ImageNetV2 [44]) using ANNS. It also shows that the highest data dimensionality need not always be the most robust which is further supported by the higher recall using lower dimensions. Further details about this experiment can be found in Appendix E.1.

**Generality across encoders.** IVF-\(\mathrm{MR}\) consistently has higher accuracy than IVF-\(\mathrm{RR}\) across dimensionalities despite having similar accuracies with exact NN search (for ResNet50 on ImageNet and BERT-Base on NQ). We find that our observations on better alignment of \(\mathrm{MRs}\) for NN search hold across neural network architectures, ResNet18/34/101 [19] and ConvNeXt-Tiny [35]. Appendix H.3 delves deep into the experimentation done using various neural architectures on ImageNet-1K.

**Recall score analysis.** Analysis of recall score (see Appendix C) in Appendix H.1 shows that for a similar top-1 accuracy, lower-dimensional representations have better 1-Recall@1 across search complexities for IVF and HNSW on ImageNet-1K. Across the board, \(\mathrm{MRs}\) have higher recall scores and top-1 accuracy pointing to easier "searchability" and thus suitability of matryoshka representations for ANNS. Larger-scale experiments and further analysis can be found in Appendix H.

Through these analyses, we argue that matryoshka representations are better suited for semantic search than rigid representations, thus making them an ideal choice for \(\mathrm{AdANNS}\).

### Search for \(\mathrm{AdANNS}\) Hyperparameters

Choosing the optimal hyperparameters for \(\mathrm{AdANNS}\), such as \(d_{c}\), \(d_{s}\), \(m\), # clusters, # probes, is an interesting and open problem that requires more rigorous examination. As the ANNS index is formed _once_ and used for potentially billions of queries with massive implications for cost, latency and queries-per-second, a hyperparameter search for the best index is generally an acceptable industry practice [22; 38]. The Faiss library [24] provides guidelines2 to choose the appropriate index for a specific problem, including memory constraints, database size, and the need for exact results. There have been efforts at automating the search for optimal indexing parameters, such as Autofaiss3, which maximizes recall given compute constraints.

Footnote 2: https://github.com/facebookresearch/faiss/wiki/Guidelines-to-choose-an-indexIn case of \(\mathrm{AdANNS}\), we suggest starting at the best configurations of \(\mathrm{MRs}\) followed by a local design space search to lead to near-optimal \(\mathrm{AdANNS}\) configurations (e.g. use IVF-MR to bootstrap \(\mathrm{AdANNS}\)-IVF). We also share some observations during the course of our experiments:

1. [leftmargin=*]
2. \(\mathrm{AdANNS}\)-IVF: Top-1 accuracy generally improves (with diminishing returns after a point) with increasing dimensionality of clustering (\(d_{c}\)) and search (\(d_{s}\)), as we show on ImageNet variants and with multiple encoders in the Appendix (Figures 9 and 15). Clustering with low-\(d\)\(\mathrm{MRs}\) matches the performance of high-\(d\)\(\mathrm{MRs}\) as they likely contain similar amounts of useful information, making the increased compute cost not worth the marginal gains. Increasing # probes naturally boosts performance (Appendix, Figure 9(a)). Lastly, it is generally accepted that a good starting point for the # clusters \(k\) is \(\sqrt{N_{D}/2}\), where \(N_{D}\) is the number of indexable items [39]. \(k=\sqrt{N_{D}}\) is the optimal choice of \(k\) from a FLOPS computation perspective as can be seen in Appendix B.1.
3. [leftmargin=*]
4. \(\mathrm{AdANNS}\)-OPQ: we observe that for a fixed compute budget in bytes (\(m\)), the top-1 accuracy reaches a peak at \(d<d_{max}\) (Appendix, Table 4). We hypothesize that the better performance of \(\mathrm{AdANNS}\)-OPQ at \(d<d_{max}\) is due to the curse of dimensionality, i.e. it is easier to learn PQ codebooks on smaller embeddings with similar amounts of information. We find that using an \(\mathrm{MR}\) with \(d=4\times m\) is a good starting point on ImageNet and NQ. We also suggest using an 8-bit (256-length) codebook for OPQ as the default for each of the sub-block quantizer.
4. [leftmargin=*]
5. \(\mathrm{AdANNS}\)-DiskANN: Our observations with DiskANN are consistent with other indexing structures, i.e. the optimal graph construction dimensionality \(d<d_{max}\) (Appendix, Figure 12). A careful study of DiskANN on different datasets is required for more general guidelines to choose graph construction and OPQ dimensionality \(d\).

### Limitations

\(\mathrm{AdANNS}\)'s core focus is to improve the design of the existing ANNS pipelines. To use \(\mathrm{AdANNS}\) on a corpus, we need to back-fill [43] the \(\mathrm{MRs}\) of the data - a significant yet a one-time overhead. We also notice that high-dimensional \(\mathrm{MRs}\) start to degrade in performance when optimizing also for an extremely low-dimensional granularity (e.g., \(<24\)-d for NQ) - otherwise is it quite easy to have comparable accuracies with both \(\mathrm{RRs}\) and \(\mathrm{MRs}\). Lastly, the existing dense representations can only in theory be converted to \(\mathrm{MRs}\) with an auto-encoder-style non-linear transformation. We believe most of these limitations form excellent future work to improve \(\mathrm{AdANNS}\) further.

## 6 Conclusions

We proposed a novel framework, \(\mathrm{AdANNS}\), that leverages adaptive representations for different phases of ANNS pipelines to improve the accuracy-compute tradeoff. \(\mathrm{AdANNS}\) utilizes the inherent flexibility of matryoshka representations [31] to design better ANNS building blocks than the standard ones which use the rigid representation in each phase. \(\mathrm{AdANNS}\) achieves SOTA accuracy-compute trade-off for the two main ANNS building blocks: search data structures (\(\mathrm{AdANNS}\)-IVF) and quantization (\(\mathrm{AdANNS}\)-OPQ). The combination of \(\mathrm{AdANNS}\)-based building blocks leads to the construction of better real-world composite ANNS indices - with as much as \(8\times\) reduction in cost at the same accuracy as strong baselines - while also enabling compute-aware elastic search. Finally, we note that combining \(\mathrm{AdANNS}\) with elastic encoders [11] enables truly adaptive large-scale retrieval.

## Acknowledgments

We are grateful to Kaifeng Chen, Venkata Sailesh Sanampudi, Sanjiv Kumar, Harsha Vardhan Simhadri, Gantavya Bhatt, Matthijs Douze and Matthew Wallingford for helpful discussions and feedback. Aditya Kusupati also thanks Tom Duerig and Rahul Sukthankar for their support. Part of the paper's large-scale experimentation is supported through a research GCP credit award from Google Cloud and Google Research. Sham Kakade acknowledges funding from the ONR award N00014-22-1-2377 and NSF award CCF-2212841. Ali Farhadi acknowledges funding from the NSF awards IIS 1652052, IIS 17303166, DARPA N66001-19-2-4031, DARPA W911NF-15-1-0543, and gifts from Allen Institute for Artificial Intelligence and Google.

## References

* Aumuller et al. [2020] M. Aumuller, E. Bernhardsson, and A. Faithfull. Ann-benchmarks: A benchmarking tool for approximate nearest neighbor algorithms. _Information Systems_, 87:101374, 2020.
* Bengio [2012] Y. Bengio. Deep learning of representations for unsupervised and transfer learning. In _Proceedings of ICML workshop on unsupervised and transfer learning_, pages 17-36. JMLR Workshop and Conference Proceedings, 2012.
* Bernhardsson [2018] E. Bernhardsson. _Annoy: Approximate Nearest Neighbors in C++Python_, 2018. URL https://pypi.org/project/annoy/. Python package version 1.13.0.
* Brin and Page [1998] S. Brin and L. Page. The anatomy of a large-scale hypertextual web search engine. _Computer networks and ISDN systems_, 30(1-7):107-117, 1998.
* Cai [2021] D. Cai. A revisit of hashing algorithms for approximate nearest neighbor search. _IEEE Transactions on Knowledge and Data Engineering_, 33(6):2337-2348, 2021. doi: 10.1109/TKDE.2019.2953897.
* Chen et al. [2020] T. Chen, L. Li, and Y. Sun. Differentiable product quantization for end-to-end embedding compression. In _International Conference on Machine Learning_, pages 1617-1626. PMLR, 2020.
* Clarkson [1994] K. L. Clarkson. An algorithm for approximate closest-point queries. In _Proceedings of the tenth annual symposium on Computational geometry_, pages 160-164, 1994.
* Datar et al. [2004] M. Datar, N. Immorlica, P. Indyk, and V. S. Mirrokni. Locality-sensitive hashing scheme based on p-stable distributions. In _Proceedings of the twentieth annual symposium on Computational geometry_, pages 253-262, 2004.
* Dean [2009] J. Dean. Challenges in building large-scale information retrieval systems. In _Keynote of the 2nd ACM International Conference on Web Search and Data Mining (WSDM)_, volume 10, 2009.
* Devlin et al. [2018] J. Devlin, M.-W. Chang, K. Lee, and K. Toutanova. Bert: Pre-training of deep bidirectional transformers for language understanding. _arXiv preprint arXiv:1810.04805_, 2018.
* Devvrit et al. [2023] Devvrit, S. Kudugunta, A. Kusupati, T. Dettmers, K. Chen, I. Dhillon, Y. Tsvetkov, H. Hannaneh, S. Kakade, A. Farhadi, and P. Jain. Matformer: Nested transformer for elastic inference. _arXiv preprint arxiv:2310.07707_, 2023.
* Friedman et al. [1977] J. H. Friedman, J. L. Bentley, and R. A. Finkel. An algorithm for finding best matches in logarithmic expected time. _ACM Transactions on Mathematical Software (TOMS)_, 3(3):209-226, 1977.
* Ge et al. [2013] T. Ge, K. He, Q. Ke, and J. Sun. Optimized product quantization for approximate nearest neighbor search. In _Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition_, pages 2946-2953, 2013.
* Golub and Kahan [1965] G. Golub and W. Kahan. Calculating the singular values and pseudo-inverse of a matrix. _Journal of the Society for Industrial and Applied Mathematics, Series B: Numerical Analysis_, 2(2):205-224, 1965.
* Gray [1984] R. Gray. Vector quantization. _IEEE Assp Magazine_, 1(2):4-29, 1984.
* Guo et al. [2020] R. Guo, P. Sun, E. Lindgren, Q. Geng, D. Simcha, F. Chern, and S. Kumar. Accelerating large-scale inference with anisotropic vector quantization. In _International Conference on Machine Learning_, pages 3887-3896. PMLR, 2020.
* Gupta et al. [2022] N. Gupta, P. H. Chen, H.-F. Yu, C.-J. Hsieh, and I. S. Dhillon. End-to-end learning to index and search in large output spaces. _arXiv preprint arXiv:2210.08410_, 2022.
* He et al. [2012] J. He, S. Kumar, and S.-F. Chang. On the difficulty of nearest neighbor search. In _International Conference on Machine Learning (ICML)_, 2012.

* [19] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning for image recognition. In _Proceedings of the IEEE conference on computer vision and pattern recognition_, pages 770-778, 2016.
* [20] K. He, H. Fan, Y. Wu, S. Xie, and R. Girshick. Momentum contrast for unsupervised visual representation learning. In _Proceedings of the IEEE/CVF conference on computer vision and pattern recognition_, pages 9729-9738, 2020.
* [21] P. Indyk and R. Motwani. Approximate nearest neighbors: towards removing the curse of dimensionality. In _Proceedings of the thirtieth annual ACM symposium on Theory of computing_, pages 604-613, 1998.
* [22] S. Jayaram Subramanya, F. Devvrit, H. V. Simhadri, R. Krishnawamy, and R. Kadekodi. Diskann: Fast accurate billion-point nearest neighbor search on a single node. _Advances in Neural Information Processing Systems_, 32, 2019.
* [23] H. Jegou, M. Douze, and C. Schmid. Product quantization for nearest neighbor search. _IEEE transactions on pattern analysis and machine intelligence_, 33(1):117-128, 2010.
* [24] J. Johnson, M. Douze, and H. Jegou. Billion-scale similarity search with GPUs. _IEEE Transactions on Big Data_, 7(3):535-547, 2019.
* [25] W. B. Johnson. Extensions of lipschitz mappings into a hilbert space. _Contemp. Math._, 26:189-206, 1984.
* [26] I. T. Jolliffe and J. Cadima. Principal component analysis: a review and recent developments. _Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences_, 374(2065):20150202, 2016.
* [27] V. Karpukhin, B. Oguz, S. Min, P. Lewis, L. Wu, S. Edunov, D. Chen, and W.-t. Yih. Dense passage retrieval for open-domain question answering. _arXiv preprint arXiv:2004.04906_, 2020.
* [28] S. Kornblith, J. Shlens, and Q. V. Le. Do better imagenet models transfer better? In _Proceedings of the IEEE/CVF conference on computer vision and pattern recognition_, pages 2661-2671, 2019.
* [29] T. Kraska, A. Beutel, E. H. Chi, J. Dean, and N. Polyzotis. The case for learned index structures. In _Proceedings of the 2018 international conference on management of data_, pages 489-504, 2018.
* [30] A. Kusupati, M. Wallingford, V. Ramanujan, R. Somani, J. S. Park, K. Pillutla, P. Jain, S. Kakade, and A. Farhadi. Llc: Accurate, multi-purpose learnt low-dimensional binary codes. _Advances in Neural Information Processing Systems_, 34:23900-23913, 2021.
* [31] A. Kusupati, G. Bhatt, A. Rege, M. Wallingford, A. Sinha, V. Ramanujan, W. Howard-Snyder, K. Chen, S. Kakade, P. Jain, and A. Farhadi. Matryoshka representation learning. In _Advances in Neural Information Processing Systems_, December 2022.
* [32] T. Kwiatkowski, J. Palomaki, O. Redfield, M. Collins, A. Parikh, C. Alberti, D. Epstein, I. Polosukhin, J. Devlin, K. Lee, et al. Natural questions: a benchmark for question answering research. _Transactions of the Association for Computational Linguistics_, 7:453-466, 2019.
* [33] D. A. Levin and Y. Peres. _Markov chains and mixing times_, volume 107. American Mathematical Soc., 2017.
* [34] W. Li, Y. Zhang, Y. Sun, W. Wang, W. Zhang, and X. Lin. Approximate nearest neighbor search on high dimensional data--experiments, analyses, and improvement. _IEEE Transactions on Knowledge and Data Engineering_, 2020.
* [35] Z. Liu, H. Mao, C.-Y. Wu, C. Feichtenhofer, T. Darrell, and S. Xie. A convnet for the 2020s. In _Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition_, pages 11976-11986, 2022.
* [36] S. Lloyd. Least squares quantization in pcm. _IEEE transactions on information theory_, 28(2):129-137, 1982.

* Malkov et al. [2014] Y. Malkov, A. Ponomarenko, A. Logvinov, and V. Krylov. Approximate nearest neighbor algorithm based on navigable small world graphs. _Information Systems_, 45:61-68, 2014.
* Malkov and Yashunin [2020] Y. A. Malkov and D. Yashunin. Efficient and robust approximate nearest neighbor search using hierarchical navigable small world graphs. _IEEE Transactions on Pattern Analysis & Machine Intelligence_, 42(04):824-836, 2020.
* Mardia et al. [1979] K. Mardia, J. Kent, and J. Bibby. Multivariate analysis. _Probability and Mathematical Statistics_, 1979.
* Nayak [2019] P. Nayak. Understanding searches better than ever before. _Google AI Blog_, 2019. URL https://blog.google/products/search/search-language-understanding-bert/.
* Neelakantan et al. [2022] A. Neelakantan, T. Xu, R. Puri, A. Radford, J. M. Han, J. Tworek, Q. Yuan, N. Tezak, J. W. Kim, C. Hallacy, et al. Text and code embeddings by contrastive pre-training. _arXiv preprint arXiv:2201.10005_, 2022.
* Radford et al. [2021] A. Radford, J. W. Kim, C. Hallacy, A. Ramesh, G. Goh, S. Agarwal, G. Sastry, A. Askell, P. Mishkin, J. Clark, et al. Learning transferable visual models from natural language supervision. In _International Conference on Machine Learning_, pages 8748-8763. PMLR, 2021.
* Ramanujan et al. [2021] V. Ramanujan, P. K. A. Vasu, A. Farhadi, O. Tuzel, and H. Pouransari. Forward compatible training for representation learning. _arXiv preprint arXiv:2112.02805_, 2021.
* Recht et al. [2019] B. Recht, R. Roelofs, L. Schmidt, and V. Shankar. Do imagenet classifiers generalize to imagenet? In _International Conference on Machine Learning_, pages 5389-5400. PMLR, 2019.
* Russakovsky et al. [2015] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, et al. Imagenet large scale visual recognition challenge. _International journal of computer vision_, 115(3):211-252, 2015.
* Salakhutdinov and Hinton [2009] R. Salakhutdinov and G. Hinton. Semantic hashing. _International Journal of Approximate Reasoning_, 50(7):969-978, 2009.
* Simhadri et al. [2022] H. V. Simhadri, G. Williams, M. Aumuller, M. Douze, A. Babenko, D. Baranchuk, Q. Chen, L. Hosseini, R. Krishnaswamy, G. Srinivasa, et al. Results of the neurips'21 challenge on billion-scale approximate nearest neighbor search. _arXiv preprint arXiv:2205.03763_, 2022.
* Sivic and Zisserman [2003] J. Sivic and A. Zisserman. Video google: A text retrieval approach to object matching in videos. In _Computer Vision, IEEE International Conference on_, volume 3, pages 1470-1470. IEEE Computer Society, 2003.
* Soudry et al. [2018] D. Soudry, E. Hoffer, M. S. Nacson, S. Gunasekar, and N. Srebro. The implicit bias of gradient descent on separable data. _The Journal of Machine Learning Research_, 19(1):2822-2878, 2018.
* Waldburger [2019] C. Waldburger. As search needs evolve, microsoft makes ai tools for better search available to researchers and developers. _Microsoft AI Blog_, 2019. URL https://blogs.microsoft.com/ai/bing-vector-search/.
* Wang et al. [2021] M. Wang, X. Xu, Q. Yue, and Y. Wang. A comprehensive survey and experimental comparison of graph-based approximate nearest neighbor search. _Proceedings of the VLDB Endowment_, 14(11):1964-1978, 2021.
* Weber et al. [1998] R. Weber, H.-J. Schek, and S. Blott. A quantitative analysis and performance study for similarity-search methods in high-dimensional spaces. In _VLDB_, volume 98, pages 194-205, 1998.
* Witten et al. [1999] I. H. Witten, I. H. Witten, A. Moffat, T. C. Bell, T. C. Bell, E. Fox, and T. C. Bell. _Managing gigabytes: compressing and indexing documents and images_. Morgan Kaufmann, 1999.

Adanns Framework

```
#Indexdatabasetoconstructclustersandbuildinvertedfilesystem defadannsConstruction(database,d_cluster,num_clusters): #Slicedatabasewithclusterconstructiondim(d_cluster) xb=database[:d_cluster] cluster_centroids=constructClusters(xb,num_clusters) returncluster_centroids defadannsInference(queries,centroids,d_shortlist,d_search,num_probes,k): #Slicequeriesandcentroidswithclustershortlistdim(d_shortlist) xq=queries[:d_shortlist] xc=centroids[:d_shortlist] forqinqueries: #computetdistanceofqueryfromeachclustercentroid candidate_distances=computeDistances(q,xc) #sortclustercandidatesbydistanceandchoosessmallnumberto probo clustercandidates=sortAscending(candidate_distances)[:num_probes] database_candidates=getClusterMembers(cluster_candidates) #LinearScanallshortlistedclusterswithsearchdim(d_search) k_nearest_neighbors[q]=linearScan(q,database_candidates,d_search,k) returnk_nearest_neighbors ```

**Algorithm 1**Adanns-IVF Psuedocode

Figure 5: The schematic of inverted file index (IVF) outlaying the construction and inference phases. Adaptive representations can be utilized effectively in the decoupled components of clustering and searching for a better accuracy-compute trade-off (\(\mathrm{AdANNS}\)-IVF).

[MISSING_PAGE_FAIL:15]

Evaluation Metrics

In this work, we primarily use top-1 accuracy (i.e. 1-Nearest Neighbor), recall@k, corrected mean average precision (mAP@k) [30] and k-Recall@N (recall score), which are defined over all queries \(Q\) over indexed database of size \(N_{D}\) as:

\[\text{top-1}=\frac{\sum_{Q}\text{correct\_pred}@1}{|Q|}\]

\[\text{Recall@k}=\frac{\sum_{Q}\text{correct\_pred}@k}{|Q|}*\frac{\text{num\_ classes}}{|N_{D}|}\]

where correct_pred\(@k\) is the number of k-NN with correctly predicted labels for a given query. As noted in Section 3, k-Recall@N is the overlap between \(k\) exact search nearest neighbors (considered as ground truth) and the top N retrieved documents. As Faiss [24] supports a maximum of 2048-NN while searching the indexed database, we report 40-Recall@2048 in Figure 13. Also note that for ImageNet-1K, which constitutes a bulk of the experimentation in this work, \(|Q|=50000\), \(|N_{D}|=1281167\) and num_classes \(=1000\). For ImageNetv2 [44], \(|Q|=10000\) and num_classes \(=1000\), and for ImageNet-4K [31], \(|Q|=210100\), \(|N_{D}|=4202000\) and num_classes \(=4202\). For NQ [32], \(|Q|=3610\) and \(|N_{D}|=21015324\). As NQ consists of question-answer pairs (instance-level), num_classes = 3610 for the test set.

Figure 6: Top-1 Accuracy of \(\mathrm{AdANN}\) composite indices with OPQ distance computation compared to \(\mathrm{MR}\) and Rigid baselines models on ImageNet-1K and Natural Questions.

[MISSING_PAGE_FAIL:17]

[MISSING_PAGE_FAIL:18]

rigid representations). We also examine the setting of adaptively choosing low-dimensional \(\mathrm{MR}\) to linear scan the shortlisted clusters built with high-dimensional \(\mathrm{MR}\), i.e. \(\mathrm{AdANNS}\)-IVF-D, as seen in Table 5. As seen in Figure 8, \(\mathrm{AdANNS}\)-IVF provides pareto-optimal accuracy-compute tradeoff across inference compute. This figure is a more exhaustive indication of \(\mathrm{AdANNS}\)-IVF behavior compared to baselines than Figures 1a and 2. \(\mathrm{AdANNS}\)-IVF is evaluated for all possible tuples of \(d_{c},d_{s},k=|C|\in\{8,16,\dots,2048\}\). \(\mathrm{AdANNS}\)-IVF-D is evaluated for a pre-built IVF index with \(d_{c}=2048\) and \(d_{s}\in\{8,\dots,2048\}\). MG-IVF-\(\mathrm{RR}\) configurations are evaluated for \(d_{c}\in\{8,\dots,d_{s}\}\), \(d_{s}\in\{32,\dots,2048\}\) and \(k=1024\) clusters. A study over additional \(k\) values is omitted due to high compute cost. Finally, IVF-\(\mathrm{MR}\) and IVF-\(\mathrm{RR}\) configurations are evaluated for \(d_{c}=d_{s}\in\{8,16,\dots,2048\}\) and \(k\in\{256,\dots,8192\}\). Note that for a fair comparison, we use \(n_{p}=1\) across all configurations. We discuss the inference compute for these settings in Appendix B.1.

### Robustness

As shown in Figure 9, we examined the clustering capabilities of \(\mathrm{MR}\)s on both in-distribution (ID) queries via ImageNet-1K and out-of-distribution (OOD) queries via ImageNetV2 [44], as well as on larger-scale ImageNet-4K [31]. For ID queries on ImageNet-1K (Figure 8(a)), IVF-\(\mathrm{MR}\) is at least as accurate as \(\mathrm{Exact}\)-\(\mathrm{RR}\) for \(d\leq 256\) with a single search probe, demonstrating the quality of in-distribution low-d clustering with \(\mathrm{MR}\). On OOD queries (Figure 8(b)), we observe that IVF-\(\mathrm{MR}\) is on average \(2\%\) more robust than IVF-\(\mathrm{RR}\) across all cluster construction and linear scan dimensionalities \(d\). It is also notable that clustering with \(\mathrm{MR}\)s followed by linear scan with # probes \(=1\) is more robust than exact search with \(\mathrm{RR}\) embeddings across all \(d\leq 2048\), indicating the adaptability of \(\mathrm{MR}\)s to distribution shifts during inference. As seen in Table 5, on ImageNetV2 \(\mathrm{AdANNS}\)-IVF-D is the best configuration for \(d\leq 16\), and is similarly accurate to IVF-\(\mathrm{MR}\) at all other \(d\). \(\mathrm{AdANNS}\)-IVF-D with

Figure 8: Top-1 accuracy vs. compute cost per query of \(\mathrm{AdANNS}\)-IVF compared to IVF-\(\mathrm{MR}\), IVF-\(\mathrm{RR}\) and MG-IVF-\(\mathrm{RR}\) baselines on ImageNet-1K.

Figure 9: Top-1 Accuracy variation of IVF-\(\mathrm{MR}\) of ImageNet 1K, ImageNetV2 and ImageNet-4K. \(\mathrm{RR}\) baselines are omitted on ImageNet-4K due to high compute cost.

\(d=128\) is able to match its own accuracy with \(d=2048\), a \(16\times\) compute gain during inference. This demonstrates the potential of \(\mathrm{AdANNS}\) to adaptively search pre-indexed clustering structures.

On 4-million scale ImageNet-4K (Figure 8(c)), we observe similar accuracy trends of IVF-\(\mathrm{MR}\) compared to Exact-\(\mathrm{MR}\) as in ImageNet-1K (Figure 8(a)) and ImageNetV2 (Figure 8(b)). We omit baseline IVF-\(\mathrm{RR}\) and Exact-\(\mathrm{RR}\) experiments due to high compute cost at larger scale.

### IVF-\(\mathrm{MR}\) Ablations

As seen in Figure 9(a), IVF-\(\mathrm{MR}\) can match the accuracy of Exact Search on ImageNet-4K with \(\sim 100\times\) less compute. We also explored the capability of \(\mathrm{MR}\)s at retrieving cluster centroids with low-d compared to a ground truth of 2048-d with k-Recall@N, as seen in Figure 9(b). \(\mathrm{MR}\)s were able to saturate to near-perfect 1-Recall@N for \(d\geq 32\) and \(N\geq 4\), indicating the potential of \(\mathrm{AdANNS}\) at matching exact search performance with less than 10 search probes \(n_{p}\).

### Clustering Distribution

We examined the distribution of learnt clusters across embedding dimensionalities \(d\) for both \(\mathrm{MR}\) and \(\mathrm{RR}\) models, as seen in Figure 11. We observe IVF-\(\mathrm{MR}\) to have less variance than IVF-\(\mathrm{RR}\) at \(d\in\{8,16\}\), and slightly higher variance for \(d\geq 32\), while IVF-\(\mathrm{MR}\) outperforms IVF-\(\mathrm{RR}\) in top-1 across all \(d\) (Figure 8(a)). This indicates that although \(\mathrm{MR}\) learns clusters that are less uniformly distributed than \(\mathrm{RR}\) at high \(d\), the quality of learnt clustering is superior to \(\mathrm{RR}\) across all \(d\). Note that a uniform distribution is \(N/k\) data points per cluster, i.e. \(\sim 1250\) for ImageNet-1K with \(k=1024\). We quantitatively evaluate the proximity of the \(\mathrm{MR}\) and \(\mathrm{RR}\) clustering distributions with Total Variation

Figure 10: Ablations on IVF-\(\mathrm{MR}\) Clustering: a) Analysis of accuracy-compute tradeoff with increasing IVF-\(\mathrm{MR}\) search probes \(n_{p}\) on ImageNet-4K compared to Exact-\(\mathrm{MR}\) and b) k-Recall@N on ImageNet-1K cluster centroids across representation sizes \(d\). Cluster centroids retrieved with highest embedding dim \(d=2048\) were considered ground-truth centroids.

\begin{table}
\begin{tabular}{c|c|c c|c c} \hline \hline d & \(\mathrm{AdANNS}\)-IVF-D & IVF-\(\mathrm{MR}\) & Exact-\(\mathrm{MR}\) & IVF-\(\mathrm{RR}\) & Exact-\(\mathrm{RR}\) \\ \hline
8 & **53.51** & 50.44 & 50.41 & 49.03 & 48.79 \\
16 & **57.32** & 56.35 & 56.64 & 55.04 & 55.08 \\
32 & 57.32 & 57.64 & **57.96** & 56.06 & 56.69 \\
64 & 57.85 & 58.01 & **58.94** & 56.84 & 57.37 \\
128 & 58.02 & 58.09 & **59.13** & 56.14 & 57.17 \\
256 & 58.01 & 58.33 & **59.18** & 55.60 & 57.09 \\
512 & 58.03 & 57.84 & **59.40** & 55.46 & 57.12 \\
1024 & 57.66 & 57.58 & **59.11** & 54.80 & 57.53 \\
2048 & 58.04 & 58.04 & **59.63** & 56.17 & 57.84 \\ \hline \hline \end{tabular}
\end{table}
Table 5: Top-1 Accuracy of \(\mathrm{AdANNS}\)-IVF-D on out-of-distribution queries from ImageNetV2 compared to both IVF and Exact Search with \(\mathrm{MR}\) and \(\mathrm{RR}\) embeddings. Note that for \(\mathrm{AdANNS}\)-IVF-D, the dimensionality used to build clusters \(d_{c}=2048\).

Distance [33], which is defined over two discrete probability distributions \(p,q\) over \([n]\) as follows:

\[d_{TV}(p,q)=\frac{1}{2}\sum_{i\in[n]}|p_{i}-q_{i}|\]

We also compute \(d_{TV,2048}(\mathrm{MR\text{-}d})=d_{TV}(\mathrm{MR\text{-}d},\mathrm{RR\text{-} 2048})\), which evaluates the total variation distance of a given low-\(\mathrm{d}\)\(\mathrm{MR}\) from high-\(\mathrm{d}\)\(\mathrm{RR\text{-}2048}\). We observe a monotonically decreasing \(d_{TV,2048}\) with increasing \(d\), which demonstrates that \(\mathrm{MR}\) clustering distributions get closer to \(\mathrm{RR\text{-}2048}\) as we increase the embedding dimensionality \(d\). We observe in Figure 11 that \(d_{TV}(\mathrm{MR\text{-}d},\mathrm{RR\text{-}d})\sim 7e-4\) for \(d\in\{8,256,\ldots,2048\}\) and \(\sim 3e-4\) for \(d\in\{16,32,64\}\). These findings agree with the top-1 improvement of \(\mathrm{MR}\) over \(\mathrm{RR}\) as shown in Figure (a)a, where there are smaller improvements for \(d\in\{16,32,64\}\) (smaller \(d_{TV}\)) and larger improvements for \(d\in\{8,256,\ldots,2048\}\) (larger \(d_{TV}\)). These results demonstrate a correlation between top-1 performance of IVF-\(\mathrm{MR}\) and the quality of clusters learnt with \(\mathrm{MR}\).

## Appendix F \(\mathrm{AdAnns\text{-}DiskANN}\)

DiskANN is a state-of-the-art graph-based ANNS index capable of serving queries from both RAM and SSD. DiskANN builds a greedy best-first graph with OPQ distance computation, with compressed vectors stored in memory. The index and full-precision vectors are stored on the SSD. During search,

Figure 11: Clustering distributions for IVF-\(\mathrm{MR}\) and IVF-\(\mathrm{RR}\) across embedding dimensionality \(d\) on ImageNet-1K. An IVF-\(\mathrm{MR}\) and IVF-\(\mathrm{RR}\) clustered with \(d=16\) embeddings is denoted by \(\mathrm{MR\text{-}16}\) and \(\mathrm{RR\text{-}16}\) respectively.

when a query's neighbor shortlist is fetched from the SSD, its full-precision vector is also fetched in a single disk read. This enables efficient and fast distance computation with PQ on a large initial shortlist of candidate nearest neighbors in RAM followed by a high-precision re-ranking with full-precision vectors fetched from the SSD on a much smaller shortlist. The experiments carried out in this work primarily utilize a DiskANN graph index built in-memory5 with OPQ distance computation.

Footnote 5: https://github.com/microsoft/DiskANN

As with IVF, DiskANN is also well suited to the flexibility provided by \(\mathrm{AdANNS}\) as we demonstrate on both ImageNet and NQ that the optimal PQ codebook for a given compute budget is learnt with a smaller embedding dimensionality \(d\) (see Figures 5(c) and 6(a)). We demonstrate the capability of \(\mathrm{AdANNS}\)-DiskANN with a compute budget of \(m\in\{32,64\}\) in Table 1. We tabulate the search time latency of \(\mathrm{AdANNS}\)-DiskANN in microseconds (\(\mu s\)) in Table 6, which grows linearly with graph construction dimensionality \(d\). We also examine DiskANN-\(\mathrm{MR}\) with SSD graph indices on ImageNet-1K across OPQ budgets for distance computation \(m_{dc}\in\{32,48,64\}\), as seen in Figure 12. With SSD indices, we store PQ-compressed vectors on disk with \(m_{disk}=m_{dc}\), which essentially disables DiskANN's implicit high-precision re-ranking. We observe similar trends to other composite ANNS indices on ImageNet, where the _optimal_ dim for fixed OPQ budget is not the highest dim (\(d=1024\) with fp32 embeddings is current highest dim supported by DiskANN which stores vectors in 4KB sectors on disk). This provides further motivation for \(\mathrm{AdANNS}\)-DiskANN, which leverages \(\mathrm{MRs}\) to provide flexible access to the optimal dim for quantization and thus enables similar Top-1 accuracy to Rigid DiskANN for up to \(1/4\) the cost (Figure 5(c)).

## Appendix G \(\mathrm{AdANNS}\) on Natural Questions

In addition to image retrieval on ImageNet, we also experiment with dense passage retrieval (DPR) on Natural Questions. As shown in Figure 6, \(\mathrm{MR}\) representations are \(1-10\%\) more accurate than their

\begin{table}
\begin{tabular}{l|c c c c c} \hline \hline \(d\) & \(M\)=8 & \(M\)=16 & \(M\)=32 & \(M\)=48 & \(M\)=64 \\ \hline
8 & 495 & - & - & - & - \\
16 & 555 & 571 & - & - & - \\
32 & 669 & 655 & 653 & - & - \\
64 & 864 & 855 & 843 & 844 & 848 \\
128 & 1182 & 1311 & 1156 & 1161 & 2011 \\
256 & 1923 & 1779 & 1744 & 2849 & 1818 \\
512 & 2802 & 3272 & 3423 & 2780 & 3171 \\
1024 & 5127 & 5456 & 5724 & 4683 & 5087 \\
2048 & 9907 & 9833 & 10205 & 10183 & 9329 \\ \hline \hline \end{tabular}
\end{table}
Table 6: Wall clock search latency (\(\mu s\)) of \(\mathrm{AdANNS}\)-DiskANN across graph construction dimensionality \(d\in\{8,16,\ldots,2048\}\) and compute budget in terms of OPQ budget \(M\in\{8,16,32,48,64\}\). Search latency is fairly consistent across fixed embedding dimensionality \(D\).

Figure 12: DiskANN-\(\mathrm{MR}\) with SSD indices for ImageNet-1K retrieval, with compute budgets \(m_{disk}=m_{dc}\in\{32,48,64\}\) across graph and OPQ codebook construction dimensionalities \(d\in\{32,\ldots,1024\}\). Note that this does not use any re-ranking after obtaining OPQ based shortlist.

\(\mathrm{RR}\) counterparts across PQ compute budgets with Exact Search + OPQ on NQ. We also demonstrate that IVF-\(\mathrm{MR}\) is \(1-2.5\%\) better than IVF-\(\mathrm{RR}\) for Precision@\(k\), \(k\in\{1,5,20,100,200\}\). Note that on NQ, IVF loses \(\sim 10\%\) accuracy compared to exact search, even with the \(\mathrm{RR}\)-768 baseline. We hypothesize the weak performance of IVF owing to poor clusterability of the BERT-Base embeddings fine-tuned on the NQ dataset. A more thorough exploration of \(\mathrm{AdANNS}\)-IVF on NQ is an immediate future work and is in progress.

## Appendix H Ablations

### Recall Score Analysis

Figure 13: k-Recall@N of \(d\)-dimensional \(\mathrm{MR}\) for IVF and HNSW with increasing search probes \(n_{p}\) on ImageNet-1K and ImageNet-4K. On ImageNet-4K, we restrict our study to IVF-\(\mathrm{MR}\) with \(d\in\{8,64,256,2048\}\). Other embedding dimensionalities, HNSW-\(\mathrm{MR}\) and \(\mathrm{RR}\) baselines are omitted due to high compute cost. We observe that trends from ImageNet-1K with increasing \(d\) and \(n_{p}\) extend to ImageNet-4K, which is \(4\times\) larger.

In this section we also examine the variation of k-Recall@N with by probing a larger search space with IVF and HNSW indices. For IVF, search probes represent the number of clusters shortlisted for linear scan during inference. For HNSW, search quality is controlled by the \(efSearch\) parameter [38], which represents the closest neighbors to query \(q\) at level \(l_{c}\) of the graph and is analogous to number of search probes in IVF. As seen in Figure 13, general trends show a) an intuitive increase in recall with increasing search probes \(n_{p}\)) for fixed search probes, b) a decrease in recall with increasing search dimensionality \(d\) c) similar trends in ImageNet-1K and \(4\times\) larger ImageNet-4K.

### Relative Contrast

We utilize Relative Contrast [18] to capture the difficulty of nearest neighbors search with IVF-\(\mathrm{MR}\) compared to IVF-\(\mathrm{RR}\). For a given database \(X=\{x_{i}\in\mathbb{R}^{d},i=1,\ldots,N_{D}\}\), a query \(q\in\mathbb{R}^{d}\), and a distance metric \(D(.,.)\) we compute relative contrast \(C_{r}\) as a measure of the difficulty in finding the 1-nearest neighbor (1-NN) for a query \(q\) in database \(X\) as follows:

1. Compute \(D_{min}^{q}=\min_{i=1\ldots n}D(q,x_{i})\), i.e. the distance of query \(q\) to its nearest neighbor \(x_{nn}^{q}\in X\)
2. Compute \(D_{mean}^{q}=E_{x}[D(q,x)]\) as the average distance of query \(q\) from all database points \(x\in X\)
3. Relative Contrast of a given query \(C_{r}^{q}=\dfrac{D_{mean}^{q}}{D_{min}^{q}}\), which is a measure of how _separable_ the query's nearest neighbor \(x_{nn}^{q}\) is from an average point in the database \(x\)
4. Compute an expectation over all queries for Relative Contrast over the entire database as \[C_{r}=\dfrac{E_{q}[D_{mean}^{q}]}{E_{q}[D_{min}^{q}]}\]

It is evident that \(C_{r}\) captures the difficulty of Nearest Neighbor Search in database \(X\), as a \(C_{r}\sim 1\) indicates that for an average query, its nearest neighbor is almost equidistant from a random point in the database. As demonstrated in Figure 14, \(\mathrm{MRs}\) have higher \(R_{c}\) than \(\mathrm{RR}\) Embeddings for an Exact Search on ImageNet-1K for all \(d\geq 16\). This result implies that a portion of \(\mathrm{MR}\)'s improvement over \(\mathrm{RR}\) for 1-NN retrieval across all embedding dimensionalities \(d\)[31] is due to a higher average separability of the \(\mathrm{MR}\) 1-NN from a random database point.

### Generality across Encoders

We perform an ablation over the representation function \(\phi:X\rightarrow\mathbb{R}^{d}\) learnt via a backbone neural network (primarily ResNet50 in this work), as detailed in Section 3. We also train MRL models [31]\(\phi^{MR(d)}\) on ResNet18/34/101 [19] that are as accurate as their independently trained \(\mathrm{RR}\) baseline models \(\phi^{RR(d)}\), where \(d\) is the default max representation size of each architecture. We also train

Figure 14: Relative contrast of varying capacity \(\mathrm{MRs}\) and \(\mathrm{RRs}\) on ImageNet-1K corroborating the findings of He et al. [18].

MRL with a ConvNeXt-Tiny backbone with \([d]=\{48,96,192,384,786\}\). MR-\(768\) has a top-1 accuracy of \(79.45\%\) compared to independently trained publicly available RR-\(768\) baseline with top-1 accuracy \(82.1\%\) (Code and \(\mathrm{RR}\) model available on the official rep6). We note that this training had no hyperparameter tuning whatsoever, and this gap can be closed with additional model training effort. We then compare clustering the \(\mathrm{MRs}\) via IVF-\(\mathrm{MR}\) with \(k=2048,n_{p}=1\) on ImageNet-1K to Exact-\(\mathrm{MR}\), which is shown in Figure 15. IVF-\(\mathrm{MR}\) shows similar trends across backbones compared to Exact-\(\mathrm{MR}\), i.e. a maximum top-1 accuracy drop of \(\sim 1.6\%\) for a single search probe. This suggests the clustering capabilities of \(\mathrm{MR}\) extend beyond an inductive bias of \(\phi^{MR(d)}\in\) ResNet50, though we leave a detailed exploration for future work.

Footnote 6: https://github.com/facebookresearch/ConvNeXt

Figure 15: Top-1 Accuracy variation of IVF-\(\mathrm{MR}\) on ImageNet-1K with different embedding representation function \(\phi^{MR(d)}\) (see Section 3), where \(\phi\in\{\)ResNet18/34/101, ConvNeXt-Tiny\(\}\). We observe similar trends between IVF-\(\mathrm{MR}\) and Exact-\(\mathrm{MR}\) on ResNet18/34/101 when compared to ResNet50 (Figure 8(a)) which is the default in all experiments in this work.