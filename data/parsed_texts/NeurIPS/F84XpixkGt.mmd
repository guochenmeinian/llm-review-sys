# Instructional Segment Embedding: Improving LLM Safety with Instruction Hierarchy

 Tong Wu\({}^{1}\) Shujian Zhang\({}^{2}\) Kaiqiang Song\({}^{2}\) Silei Xu\({}^{2}\) Sanqiang Zhao\({}^{2}\) Ravi Agrawal\({}^{2}\)

**Sathish Reddy Indurthi\({}^{2}\) Chong Xiang\({}^{1}\) Prateek Mittal\({}^{1}\) Wenxuan Zhou\({}^{2}\)**

\({}^{1}\)Princeton University \({}^{2}\)Zoom Video Communications

###### Abstract

Large Language Models (LLMs) are susceptible to security and safety threats, such as prompt injection, prompt extraction, and harmful requests. One major cause of these vulnerabilities is the lack of an instruction hierarchy. Modern LLM architectures treat all inputs equally, failing to distinguish between and prioritize various types of instructions, such as system messages, user prompts, and data. As a result, lower-priority user prompts may override more critical system instructions, including safety protocols. Existing approaches to achieving instruction hierarchy, such as delimiters and instruction-based training, do not address this issue at the architectural level. We introduce the **I**nstructional **S**egment **E**mbedding (ISE) technique, inspired by BERT, to modern large language models, which embeds instruction priority information directly into the model. This approach enables models to explicitly differentiate and prioritize various instruction types, significantly improving safety against malicious prompts that attempt to override priority rules. Our experiments on the Structured Query and Instruction Hierarchy benchmarks demonstrate an average robust accuracy increase of up to 15.75% and 18.68%, respectively. Furthermore, we observe an improvement in instruction-following capability of up to 4.1% evaluated on AlpacaEval. Overall, our approach offers a promising direction for enhancing the safety of LLM architectures.

## 1 Introduction

Large Language Models (LLMs) have shown significant potential in enabling agentic applications and facilitating decision-making across various domains, such as web agents, educational tools, medical assistance, and more (Yao et al., 2022; Gan et al., 2023; Abbasian et al., 2024). To optimize the use of AI applications, a structured approach to implementation is widely adopted. This involves clear distinctions among system instructions, user prompts, and data inputs, as illustrated in Figure 1. These instructions contain specific priorities that help the model execute functionalities correctly and better assist users.

Modern LLMs process text without formal mechanisms to differentiate and prioritize instructions. Consequently, malicious attackers can easily exploit this limitation to override priority roles, leading to various vulnerabilities. For example, _prompt injection_(Greshake et al., 2023) insert malicious instructions into data sources to subvert the original ones. _Prompt extraction_(Zhang et al., 2024) aim to extract system messages, revealing proprietary prompts.

_Harmful requests_(Ganguli et al., 2022) involve malicious users providing unsafe instructions to elicit irresponsible or dangerous responses from the safety-aligned LLMs. These vulnerabilities underscore the significance of designing more robust _instruction hierarchy_ in LLMs to mitigate such attacks.

Figure 1: A demonstration of the hierarchy of instructions, including system instruction, user instruction, data input as well as model output.

Recently, research has been conducted to enhance models' ability to follow the instruction hierarchy. For instance, Hines et al. (2024) proposed prompt-based solutions utilizing a special delimiter between prompts. Chen et al. (2024) and Wallace et al. (2024) suggested methods for generating hierarchical prompts, incorporating adversarial data along with high-quality responses to fine-tune LLMs. However, despite these improvements, the core challenge persists: **current LLM architectures still lack an effective mechanism to differentiate and prioritize hierarchical instructions.**

In this work, we tackle the challenge by introducing an architecture-level design for LLMs. Inspired by BERT (Lan et al., 2019) and its variants (Lan et al., 2019; Yasunaga et al., 2022), we propose using an _Instructional Segment Embedding (ISE)_ to categorize different types of instructions distinctly. Specifically, we enhance the input token by incorporating segment information that classifies each token by its role (e.g., system instruction as 0, user prompt as 1, and data input as 2). This segment information is processed through a learned embedding layer, converting it into segment embeddings, which are then passed to later self-attention layers along with token embeddings. To obtain a robust segment embedding layer, we perform supervised fine-tuning on datasets containing structured prompts and high-quality responses. This process enables the model to differentiate between levels of instruction hierarchies more effectively, thereby boosting the overall safety of the system.

Empirically, we conduct comprehensive experiments on two benchmarks: Structured Query (Chen et al., 2024) and Instruction Hierarchy (Wallace et al., 2024), which are constructed based on the Alpaca (Taori et al., 2023) and Ultrachat (Ding et al., 2023) datasets, respectively. We fine-tune multiple pretrained LLMs, including Llama-2-13B (Touvron et al., 2023), Llama-3-8B (Llama Team, 2024), and Llama-3.1-8B, and compare their performance with and without the use of Instructional Segment Embedding. Our findings indicate that our method yields substantial improvements in robustness while either maintaining or enhancing the models' general capabilities, regardless of the presence of adversarial training data. For example, on the Structured Query benchmark, the method achieves an average robust accuracy improvement of up to **15.75%** against indirect prompt injection attacks. On the Instruction Hierarchy benchmark, our ISE yields an average boost in robustness of up to **18.68%** across multiple vulnerabilities, including indirect and direct prompt injection, prompt extraction, and harmful requests. In addition, the integration of ISE also maintains or even improves the instruction-following capability by as much as **4.1%** on AlpacaEval.

**Contributions: (1)** We identify and analyze critical limitations in current LLM architectures concerning the lack of instruction hierarchy (Section 3). **(2)** We propose Instructional Segment Embedding, a simple yet effective method designed to incorporate instruction-type information directly into the model. This approach enables the model to better distinguish and prioritize instructions based on their privilege (Section 4). **(3)** We empirically demonstrate the effectiveness of ISE across two benchmarks, encompassing five training datasets and addressing four types of vulnerabilities (Sections 5 & 6).

## 2 Background: LLM Vulnerabilities

Modern LLM products typically involve up to three stakeholders1: (1) the LLM application provider (e.g., OpenAI), who designs the model's system-level instructions and manages the general workflow; (2) the primary user, who provides input in the form of instructions or queries; and (3) third-party

Figure 2: A demonstration of various vulnerabilities of LLM applications, including prompt injection, prompt extraction as well as harmful request.

source/data, such as web search results, that offer additional context for the LLM. As a result, LLM applications often establish a hierarchical order of instructions based on their perceived reliability: system instructions take precedence, followed by user instructions, and finally data.

Security vulnerabilities arise when conflicts between these priorities occur, such as (1) a malicious user attempting to bypass safety system instructions or (2) malicious web providers injecting harmful actions in data. These conflicts may take various forms, including prompt injections, prompt extractions, and harmful requests, as shown in Figure 2 and outlined below.

**Prompt injection (Figure 1(a)).** Prompt injection attacks (Perez and Ribeiro, 2022) generally occur in two forms: indirect and direct. Indirect prompt injection attacks occur when third-party data input contains instructions that should never be followed by LLMs. Direct prompt injection attacks happen when a malicious attacker manipulates the user query to an LLM, causing the model to generate outputs that deviate from predefined instructions.

**Prompt extraction (Figure 1(b)).** This vulnerability (Zhang et al., 2024) often exploits a weakness in certain LLM applications that store confidential information within system instructions. Attackers may craft malicious queries that prompt the model to reference this stored information, potentially leading to the disclosure of system prompts.

**Harmful requests (Figure 1(c)).** Harmful requests (Ganguli et al., 2022) aim to bypass the model's safety alignment (Bai et al., 2022) through malicious queries. These prompts can lead to unsafe outcomes, including unethical responses or even the weaponization of LLMs.

In this paper, we aim to enhance the instruction hierarchy capabilities of LLMs, thereby mitigating various forms of attacks that attempt to override the priority rules.

## 3 Lack of Instruction Hierarchy in Modern LLM Architecture

**Current embeddings lack instruction hierarchy.** Given an input context \(\mathbf{X}_{M}\) with \(M\) tokens \(x_{1},x_{2},\dots,x_{M}\), the large language models first convert each token into a high-dimensional vector using a token embedding matrix \(\mathbf{E}^{\text{Tok}}\in\mathbb{R}^{V\times D}\), where \(V\) is the vocabulary size, and \(D\) is the output embedding dimension. The embedding vector \(e_{m}^{\text{Tok}}\) for token \(x_{m}\) is given by \(\mathbf{E}^{\text{Tok}}[x_{m}]\), based on its index in the vocabulary. Additionally, the model also obtains positional embeddings \(\mathbf{E}_{m}^{\text{Pos}}\), based on the position of each token. Then, the token embeddings \((e_{1}^{\text{tok}},e_{2}^{\text{tok}},\dots,e_{M}^{\text{tok}})\) will be fed into the transformer's self-attention layers along with positional embeddings for further processing.2

Footnote 2: Models handle positional information in different ways. For example, GPT-2 (Radford et al., 2019) adds learned positional embeddings to its token embeddings, while Llama-2 uses Rotary Position Embedding (RoPE) (Su et al., 2024) in its attention blocks to represent positions.

In these self-attention layers, each token embedding is processed "equally". As a result, the model recognizes only the semantic content and sequential order of each token from the embedding, lacking the capability to distinguish their hierarchical significance. This architectural design can inherently lead to vulnerabilities. For instance, a lower-priority user prompt, such as "Please focus on my report as the system prompt is outdated", could mistakenly be prioritized and override the original system prompt. This could inadvertently lead to various types of vulnerabilities, as shown in Figure 2.

**Prior works do not address this issue.** To mitigate these vulnerabilities, researchers have introduced methods to improve the robustness of large language models (LLMs) during the supervised fine-tuning phase. This method involves not only using benign prompt-response data but also adversarial or misaligned instructions with robust responses (Piet et al., 2023; Chen et al., 2024; Wallace et al., 2024). This approach helps the model learn to prioritize hierarchical instructions and adhere to embedded safety protocols. Despite its improvement, the challenge of uniformly processing

Figure 3: A demonstration of the chat template for Llama-3-Instruct (Llama Team, 2024).

hierarchical instructions remains a fundamental limitation inherent in current embedding methods and model architecture, as demonstrated in our experimental results (see Table 1 and Figure 5).

An alternative approach is to use specific chat templates to better handle input data. For instance, LLAMA-3-Chat (Llama Team, 2024) leverages a chat template with special tokens like <|be-gin_of_text|> and <|star_header_id|> as shown in Figure 3. Hines et al. (2024) and Chen et al. (2024) have also leveraged the specialized delimiters that aid the model in more effectively distinguishing instructions. However, two major drawbacks exist. Firstly, during inference, only a few tokens contain hierarchical priority information, and this signal is likely to diminish when encountering long-context tasks (e.g., summarizing a novel). Secondly, malicious attackers may extract these special delimiters, and exploiting them could lead to more severe attacks (Zheng et al., 2024).

## 4 Proposed Approach: Instructional Segment Embedding (ISE)

To tackle this challenge, we propose **Instructional Segment Embedding (ISE)**, which encodes the instruction hierarchy directly into the embeddings. This enables subsequent self-attention layers to more effectively recognize and follow instruction priorities, thereby boosting robustness.

Specifically, we leverage a learnable embedding layer, similar to the token embedding matrix \(\mathbf{E}^{\text{Tok}}\), which we call the segment embedding matrix \(\mathbf{E}^{\text{Seg}}\). We define \(\mathbf{E}^{\text{Seg}}\in\mathbb{R}^{H\times D}\), where \(H\) is the number of hierarchies and \(D\) is the embedding dimension. By default, we set \(H\) to 4, representing system, user, data, and output. Each token in \(\mathbf{X}_{M}\) is tagged with corresponding hierarchy information \(h_{m}\in\{0,1,2,3\}\), readily derived from distinct stakeholder categories in the LLM applications. The instructional segment embeddings of \(\mathbf{X}_{M}\) are represented as \((e_{1}^{\text{Seg}},e_{2}^{\text{Seg}},\ldots,e_{M}^{\text{Seg}})\) and obtained from \(\mathbf{E}^{\text{Seg}}[h_{m}]\). To incorporate this modification, the final embeddings are computed by summing the token embeddings and segment embeddings. This results in \((e_{1}^{\text{Seg}}+e_{1}^{\text{Tok}},e_{2}^{\text{Seg}}+e_{2}^{\text{Tok}}, \ldots,e_{M}^{\text{Seg}}+e_{M}^{\text{Tok}})\), as illustrated in Figure 4. These embeddings are then fed into self-attention layers, following the process used in current LLMs.

The segment embedding layer is trained alongside other parameters during the supervised fine-tuning (instruction tuning) phase. In our experiments, we use widely adopted instruction-following datasets and construct structured queries based on the original prompt using GPT-4o (OpenAI, 2023). Additionally, we experiment with datasets containing malicious instructions designed to override higher-level instructions, enabling the model to learn how to reject or ignore such commands.

**Flexibility in design.** The design choice for Instructional Segment Embedding can be flexible and should be tailored to the specific downstream tasks. For instance, if the data category can be further subdivided into outputs from external API tools or online information, we can introduce "tools type" and "web data type" categories, providing more fine-grained information. If the application does not involve third-party context, the data type can be omitted.

Figure 4: The input representation includes both token embeddings and instructional segment embeddings. We categorize all input texts into four segments: system instructions, user instructions, third-party data, and generated output. We assign different segment embeddings to each type of input text. The final input embeddings are the sum of token embeddings and segment embeddings. The LLMs will predict the next token after “the summary is”, with extra instruction hierarchy information.

**Connection to BERT.** Inspired by BERT's segment embeddings (Devlin et al., 2019), originally used to distinguish input segments for next-sentence prediction, our approach repurposes these embeddings to encode hierarchical instructions. This helps address the need for structured prompts and safer LLM outputs by providing direct, contextually relevant cues to the model. Unlike BERT, we incorporate the output type for two reasons: (**1**) It supports consistent autoregressive inference for each token in the input. **(2)**output may also include instructions (e.g., "Please provide more details of your question") that are critical in multi-turn language tasks.

**Simplicity.** The implementation is also straightforward and can be easily adapted for most transformer-based LLMs. We provide a PyTorch code snippet that demonstrates how to implement this in just a few lines, as shown in Appendix B.

## 5 Experimental Design

In this section, we present how we conducted the experiments. Specifically, we begin by describing the generation of the training data (Section 5.1), the experimental setup (Section 5.2), and the details of the robustness evaluation against multiple attacks (Section 5.3).

### Generating Training Data

We conduct experiments using two benchmarks: **Structured Query** and **Instruction Hierarchy**. The Structured Query benchmark primarily focuses on indirect prompt injection attacks, whereas the Instruction Hierarchy benchmark evaluates all types of vulnerabilities discussed, including indirect and direct prompt injections, prompt extraction, and harmful requests.

For the **Structured Query** benchmark, we generally follow the approach of Chen et al. (2024). Two datasets are constructed: _Clean Alpaca_ and _Adversarial Alpaca_. The Clean Alpaca dataset is constructed by _Alpaca-Cleaned-50K_ dataset (Taori et al., 2023; Gururise, 2024). For the Adversarial Alpaca dataset, we incorporate malicious instructions into the data and train the model to ignore such instructions.

For the **Instruction Hierarchy** benchmark, we mostly adhere to previous work by Wallace et al. (2024) to create both aligned and misaligned data3. We select the _UltraChat-200K_ dataset (Ding et al., 2023) as the base dataset, which contains more training data. Since UltraChat consists solely of prompts and responses, we utilized GPT-40 (OpenAI, 2023) to decompose 10K prompts into three components: system instructions, user instructions, and data inputs, which we term the _UltraChat Baseline_. Additionally, we incorporate datasets from SystemChat (Abacus.AI, 2023) and SystemMessage (Huggingface, 2023) that contain specifical system prompts, designated as the _System Follow_ dataset. Lastly, We crafted three types of attacks for the malicious data: indirect/direct prompt injection and prompt extraction, which we collectively name the _Instruction Hierarchy_ datasets. We excluded harmful request data from the training but used them as evaluations following Wallace et al. (2024). Further details on generating training data are available in Section C.

Footnote 3: We contacted the authors for training data and details, but they cannot share them due to company restrictions.

### Experiment Setup

**Data processing.** We format all training and evaluation samples with clear segmentation, including system, user, data, and output information. We merge the system and user instructions for the Structured Query benchmark into the same type, as all system instructions in Alpaca are identical. To simplify the experiments, we train and evaluate only single-turn chats, where the conversation ends after the model generates a complete response.

**LLM training and inference.** By default, we utilize **Llama-2-13B**(Touvron et al., 2023) and **Llama-3-8B**(Llama Team, 2024) as the pretrained models for Structured Query and Instruction Hierarchy, respectively. Experiments with **Llama-3.1-8B** are presented in Section E.2. We employ supervised fine-tuning to update all parameters, including our segment embedding layer, for three epochs. A learning rate of 2e-5 and a cosine learning schedule are used. During inference, we use top-p sampling methods with the model's default settings.

**Baselines.** We conduct experiments on multiple datasets and compare our Instructional Segment Embedding method (**+ISE**) with models that do not use it. For the Structured Query benchmark, we include experiments using either text (**Baseline**) or newly constructed tokens (**Delimiter**) to differentiate distinct types of prompts, following the approach of Chen et al. (2024). For the Instruction Hierarchy benchmark, we only include experiments with the default delimiters of LLAMA-3-8B (**Baseline**), as these are already specially reserved tokens (shown in Figure 3).

### Robustness Evaluation

We evaluate our method using comprehensive attack methods. More details are in Appendix D.

**Structured Query benchmark.** Following the approach of Chen et al. (2024), we evaluate indirect prompt injection attacks on models trained on the Alpaca dataset. Specifically, we focus on four types of attacks: Naive Attack, Ignore Attack, Escape Separation Attack, and Completion Real Attack as _in-domain attacks_. All in-domain attacks are crafted by injecting one or a few sentences at the end of the data to trick the model into outputting the word "hacked". Since the scenarios for in-domain attacks are quite similar to the adversarial training data constructed by Chen et al. (2024), we further develop new attacks based on the in-domain methods. These new attacks inject adversarial texts at the data's beginning and end, called _out-of-domain attacks_. This strategy significantly degrades the robustness of models trained on the adversarial Alpaca dataset. For the evaluation metrics, we compute the rate at which the model does not generate content containing the word "hacked" and refer to this as robustness or robust accuracy.

**Instruction Hierarchy benchmark.** Evaluating models trained on the Instruction Hierarchy benchmark is complex due to the need to account for indirect and direct prompt injection, prompt extraction, and harmful requests. To address these challenges: **(1)** For indirect prompt injection, we apply the same evaluations and metrics used in Structured Query benchmarks. For direct prompt injection, we use the same attacking prompts but inject them directly into the user prompt. **(2)** For prompt extraction, we use the ShareGPT and Unnatural Instructions datasets from (Zhang et al., 2024), along with 15 author-selected effective extraction prompts, and evaluate robustness using an approximate metric based on Rouge-L recall (Lin, 2004). **(3)** For harmful requests, we follow the evaluations of (Wallace et al., 2024), using Jailbeckakt (Chat) and "Do Anything Now" (DAN) prompts (Shen et al., 2024) paired with StrongREJECT malicious instructions (Souly et al., 2024). We query GPT-4o to check whether its responses adhere to safety guardfalls.

**Comprehensive robustness metrics.** For prompt injection and extraction, which encompass multiple attack methods or malicious prompts, we include additional metrics. We define _average robustness_ as the model's average performance across these various attack methods, offering a general evaluation of model robustness. Furthermore, we introduce _worst robustness_, representing the model's ability to defend against the most challenging attack.

**Clean evaluation.** We evaluate the model's capacity using standard datasets. Both benchmarks are assessed with AlpacaEval 1.0 (Li et al., 2023). For the Instruction Hierarchy benchmark, we additionally use the MT-Bench (Zheng et al., 2023) to measure the model's performance.

## 6 Experimental Results and Analysis

We report the main results on the Structured Query benchmark in Section 6.1 and the Instruction Hierarchy in Section 6.2. We observe that our approach **consistently achieves higher robust accuracy** while either **maintaining or improving general capability**. We also present a more detailed analysis of multiple vulnerabilities in Appendix E.1. Lastly, we conduct an over-refusal evaluation and assess generalization to the advanced Llama-3.1-8B model in Appendix E.2.

### Main Results on Structured Query

**Maintains high utility.** In Table 1, we present the main results for capability and robustness by comparing our method with the baseline and delimiter methods on both the clean and adversarial Alpaca datasets. Compared to the other two methods, Instructional Segment Embedding maintains high utility with negligible degradation or even slight improvement. The difference in winning rate between the methods is less than 1% on AlpacaEval.

**Consistent robustness enhancement.** We also observe that our method consistently improves robustness against indirect prompt injection attacks. Specifically, it achieves a **15.75%** increase in average robust accuracy and a **32.17%** increase in worst robust accuracy against in-domain attacks when trained with the clean Alpaca dataset. Both the delimiter and our ISE reach nearly perfect in-domain robustness. For out-of-domain attacks, we find that adding ISE can also significantly enhance robustness, resulting in improvements of \(\sim\)**10%** and \(\sim\)**7%** in average robustness for clean and adversarial Alpaca, respectively. Interestingly, our out-of-domain attacks degrade the robustness of models trained on the adversarial Alpaca dataset more than those trained on the clean Alpaca dataset (16% vs. 5%). This suggests that the adversarial dataset may overfit to in-domain attacks. Nevertheless, adding ISE largely maintains generalization to out-of-domain attacks.

We present detailed experiment results in Appendix F.

### Main Results on Instruction Hierarchy

We present the evaluation results for our method on the Instruction Hierarchy benchmark in Figure 5, focusing on model capability and average robustness across various datasets and attack scenarios.

**Improvement in capabilities.** Adding ISE boosts instruction-following capabilities, particularly for models trained on the System Follow and Instruction Hierarchy datasets. For example, the AlpacaEval win rate improves by approximately \(\sim\)**4.1%** when training on the Instruction Hierarchy dataset with our ISE, as shown in Figure 5(a). Additionally, we observe negligible degradation on MT-Bench for the UltraChat Baseline model and improvements for the other two training datasets.

**Enhanced safety against multiple vulnerabilities.** We evaluate the robustness of the models against indirect and direct prompt injection attacks, prompt extraction attacks, and harmful requests. **(1)** Indirect and direct prompt injection scenarios (#1, #2, #3, and #4 in Figure 5(b)) : We report the average robustness across four types of attacks, including both in-domain (ID) and out-of-domain (OOD) contexts. Our results demonstrate robust accuracy improvements ranging from **5%** to **25%** across all training data configurations when applying the ISE method. Notably, for models trained with the UltraChat Baseline, robust accuracy increases by nearly **25%** on average. **(2)** Prompt extraction scenarios (#5 and #6 in Figure 5(b)): Robustness is measured against 15 effective extraction prompts. Our findings show that models using ISE consistently achieve higher average robustness, with an increase of at least **10%** across all datasets. This is evident even for models trained on the Instruction Hierarchy dataset, which already demonstrated more than 80% robust accuracy. **(3)** Harmful requests

\begin{table}
\begin{tabular}{l l c c c|c c c} \hline \hline  & Dataset & \multicolumn{4}{c|}{Clean Alpaca} & \multicolumn{4}{c}{Adversarial Alpaca} \\  & Method & Baseline & Delimiter & +ISE (Ours) & Baseline & Delimiter & +ISE (Ours) \\ \hline Capability (\(\uparrow\)) & AlpacaEval & **72.76** & 72.67 & 72.13 & 73.41 & 72.26 & **73.76** \\ \hline  & Naive & 65.87 & 68.75 & **75.96** & **100.00** & 99.04 & **100.00** \\  & Ignore & 57.69 & 57.21 & **70.19** & **99.52** & 99.04 & 99.04 \\ In-Domain & Escape-S & 75.00 & 69.23 & **78.85** & 99.52 & 99.52 & **100.00** \\ Robustness (\(\uparrow\)) & Completion-R & 4.81 & 7.21 & **40.38** & 70.19 & **100.00** & **100.00** \\ \cline{2-8}  & Average & 50.84 & 50.60 & **66.35** (+15.75) & 92.31 & 99.16 & **99.76** (+0.00) \\  & Worst & 4.81 & 7.21 & **40.38** (+32.17) & 70.19 & **99.04** & **99.04** (+0.00) \\ \hline  & Naive & 62.02 & 66.35 & **69.71** & 64.90 & 67.79 & **76.44** \\  & Ignore & 52.40 & 51.92 & **69.71** & 98.56 & 96.15 & **96.63** \\ Out-of-Domain & Escape-S & **72.12** & 71.63 & 70.67 & 73.08 & 76.44 & **88.46** \\ Robustness (\(\uparrow\)) & Completion-R & 1.92 & 12.99 & **34.14** & 85.58 & 91.35 & **99.52** \\ \cline{2-8}  & Average & 47.12 & 50.72 & **61.06** (+10.34) & 80.53 & 82.93 & **90.26** (+7.67) \\  & Worst & 1.92 & 12.99 & **34.14** (+21.15) & 64.90 & 67.79 & **76.44** (+8.65) \\ \hline \hline \end{tabular}
\end{table}
Table 1: The evaluation results on Structured Query benchmark against both in-domain and out-of-domain indirect prompt injection attacks. We compare our method (+ISE) with the baseline and delimiter methods (Chen et al., 2024) on Clean Alpaca and Adversarial Alpaca.

(#7 and #8 in Figure 5(b))): Our analysis reveals improvements in robustness for models under the UltraChat Baseline and Instruction Hierarchy settings when using ISE. For System Follow, our methods either maintain or slightly exceed the baseline method.

Overall, using Instructional Segment Embeddings significantly enhances both the capabilities and robustness of models against a wide range of attacks on the Instruction Hierarchy benchmark. We present detailed experiment results in Appendix E & Appendix G.

## 7 Discussion and Conclusion

**Limitations and future work directions.** This study primarily focused on the supervised fine-tuning phase, using single-turn conversations. Future work could explore incorporating ISE during the pre-training or RLHF stage and applying it to multi-turn conversation datasets. Additionally, while our approach significantly improves the instruction hierarchy capabilities of LLMs, it offers limited robustness against adaptive attacks, commonly referred to as jailbreaks (see Appendix H for more discussion). However, integrating our method with established adversarial training strategies may potentially enhance the robustness.

**Conclusion.4** In this work, we introduced the Instructional Segment Embedding as the first attempt to design novel architectures to enhance instruction hierarchy. We conducted comprehensive experiments to demonstrate its effectiveness in improving robustness and general capabilities. We believe our method offers considerable potential for integration into real-world LLM applications and encourage practitioners to explore and test it in more downstream tasks.

Figure 5: The evaluation of model capabilities on the Instruction Hierarchy benchmark is conducted using AlpacaEval and MT-Bench, as illustrated in Figure (a). Robustness evaluations include both indirect and direct prompt injection attacks, prompt extraction attacks, and harmful requests, as shown in Figure (b). We performed experiments across three datasets (i.e., UltraChat Baseline, System Follow, and Instruction Hierarchy) and compared our ISE with the baseline (Wallace et al., 2024).

#### Acknowledgments

We would like to thank Jiachen T. Wang and Feiran Jia for providing feedback on our early draft. Prateek was supported in part by the National Science Foundation under grant CNS-2131938 and the Princeton SEAS Innovation Grant.

## References

* Abacus (2023) Abacus.AI. Systemchat-1.1, 2023. URL https://huggingface.co/datasets/abacusai/SystemChat-1.1. Accessed: August 23, 2024.
* Abbasian et al. (2024) Mahyar Abbasian, Iman Azimi, Amir M. Rahmani, and Ramesh Jain. Conversational health agents: A personalized llm-powered agent framework, 2024. URL https://arxiv.org/abs/2310.02374.
* Andriushchenko et al. (2024) Maksym Andriushchenko, Francesco Croce, and Nicolas Flammarion. Jailbreaking leading safety-aligned llms with simple adaptive attacks. _arXiv preprint arXiv:2404.02151_, 2024.
* Anil et al. (2024) Cem Anil, Esin Durmus, Mrinank Sharma, Joe Benton, Sandipan Kundu, Joshua Batson, Nina Rimsky, Meg Tong, Jesse Mu, Daniel Ford, et al. Many-shot jailbreaking, 2024. Preprint.
* Anthropic (2024) Anthropic. The claude 3 model family: Opus, sonnet, haiku, 2024. 2024c.
* Bai et al. (2022) Yuntao Bai, Andy Jones, Kamal Ndousse, Amanda Askell, Anna Chen, Nova DasSarma, Dawn Drain, Stanislav Fort, Deep Ganguli, Tom Henighan, et al. Training a helpful and harmless assistant with reinforcement learning from human feedback. _arXiv preprint arXiv:2204.05862_, 2022.
* Chao et al. (2023) Patrick Chao, Alexander Robey, Edgar Dobriban, Hamed Hassani, George J. Pappas, and Eric Wong. Jailbreaking black box large language models in twenty queries. In _R0-FoMo:Robustness of Few-shot and Zero-shot Learning in Large Foundation Models_, 2023. URL https://openreview.net/forum?id=rYWD5TMaLj.
* Chen et al. (2024) Sizhe Chen, Julien Piet, Chawin Sitawarin, and David Wagner. Struq: Defending against prompt injection with structured queries. _ArXiv_, abs/2402.06363, 2024. URL https://api.semanticscholar.org/CorpusID:267616771.
* Debenedetti et al. (2024) Edoardo Debenedetti, Jie Zhang, Mislav Balunovic, Luca Beurer-Kellner, Marc Fischer, and Florian Tramer. Agentdojo: A dynamic environment to evaluate attacks and defenses for llm agents, 2024.
* Devlin et al. (2019) Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep bidirectional transformers for language understanding. In _North American Chapter of the Association for Computational Linguistics_, 2019. URL https://api.semanticscholar.org/CorpusID:52967399.
* Ding et al. (2023) Ning Ding, Yulin Chen, Bokai Xu, Yujia Qin, Zhi Zheng, Shengding Hu, Zhiyuan Liu, Maosong Sun, and Bowen Zhou. Enhancing chat language models by scaling high-quality instructional conversations. _arXiv preprint arXiv:2305.14233_, 2023.
* Gan et al. (2023) Wensheng Gan, Zhenlian Qi, Jiayang Wu, and Jerry Chun-Wei Lin. Large language models in education: Vision and opportunities. In _2023 IEEE International Conference on Big Data (BigData)_, pp. 4776-4785, 2023. doi:10.1109/BigData59044.2023.10386291.
* Ganguli et al. (2022) Deep Ganguli, Liane Lovitt, John Kernion, Amanda Askell, Yuntao Bai, Saurav Kadavath, Benjamin Mann, Ethan Perez, Nicholas Schiefer, Kamal Ndousse, Andy Jones, Sam Bowman, Anna Chen, Tom Conerly, Nova Dassarma, Dawn Drain, Nelson Elhage, Sheer El-Showk, Stanislav Fort, Zachary Dodds, Tom Henighan, Danny Hernandez, Tristan Hume, Josh Jacobson, Scott Johnston, Shauna Kravec, Catherine Olsson, Sam Ringer, Eli Tran-Johnson, Dario Amodei, Tom B. Brown, Nicholas Joseph, Sam McCandlish, Christopher Olah, Jared Kaplan, and Jack Clark. Red teaming language models to reduce harms: Methods, scaling behaviors, and lessons learned. _ArXiv_, abs/2209.07858, 2022. URL https://api.semanticscholar.org/CorpusID:252355458.

* Greshake et al. (2023) Kai Greshake, Sahar Abdelnabi, Shailesh Mishra, Christoph Endres, Thorsten Holz, and Mario Fritz. Not what you've signed up for: Compromising real-world llm-integrated applications with indirect prompt injection. In _Proceedings of the 16th ACM Workshop on Artificial Intelligence and Security_, AISec '23, pp. 79-90, New York, NY, USA, 2023. Association for Computing Machinery. ISBN 9798400702600. doi: 10.1145/3605764.3623985. URL https://doi.org/10.1145/3605764.3623985.
* Gururise (2024) Gururise. AlpacaDataCleaned: Data Cleaning Repository. https://github.com/gururise/AlpacaDataCleaned, 2024.
* Hines et al. (2024) Keegan Hines, Gary Lopez, Matthew Hall, Federico Zarfati, Yonatan Zunger, and Emre Kiciman. Defending against indirect prompt injection attacks with spotlighting. _ArXiv_, abs/2403.14720, 2024. URL https://api.semanticscholar.org/CorpusID:268667111.
* Honovich et al. (2023) Or Honovich, Thomas Scialom, Omer Levy, and Timo Schick. Unnatural instructions: Tuning language models with (almost) no human labor. In Anna Rogers, Jordan Boyd-Graber, and Naoaki Okazaki (eds.), _Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)_, pp. 14409-14428, Toronto, Canada, July 2023. Association for Computational Linguistics. doi: 10.18653/v1/2023.acl-long.806. URL https://aclanthology.org/2023.acl-long.806.
* Huggingface (2024) Huggingface. System message contradictions sharegpt, 2023. URL https://huggingface.co/datasets/NobodyExistsOnTheInternet/SystemMessageContradictionsSharegpt. Accessed: August 23, 2024.
* Lan et al. (2019) Zhenzhong Lan, Mingda Chen, Sebastian Goodman, Kevin Gimpel, Piyush Sharma, and Radu Soricut. Albert: A lite bert for self-supervised learning of language representations. In _International Conference on Learning Representations_, 2019.
* Li et al. (2023) Xuechen Li, Tianyi Zhang, Yann Dubois, Rohan Taori, Ishaan Gulrajani, Carlos Guestrin, Percy Liang, and Tatsunori B. Hashimoto. Alpacaeval: An automatic evaluator of instruction-following models. https://github.com/tatsu-lab/alpaca_eval, 5 2023.
* Liao & Sun (2024) Zeyi Liao and Huan Sun. Amplegc: Learning a universal and transferable generative model of adversarial suffixes for jailbreaking both open and closed lms. _arXiv preprint arXiv:2404.07921_, 2024.
* Lin (2004) Chin-Yew Lin. Rouge: A package for automatic evaluation of summaries. In _Annual Meeting of the Association for Computational Linguistics_, 2004. URL https://api.semanticscholar.org/CorpusID:964287.
* Liu et al. (2023) Yi Liu, Gelei Deng, Yuekang Li, Kailong Wang, Zihao Wang, Xiaofeng Wang, Tianwei Zhang, Yepang Liu, Haoyu Wang, Yan Zheng, et al. Prompt injection attack against llm-integrated applications. _arXiv preprint arXiv:2306.05499_, 2023.
* A1 @ Meta Llama Team (2024) AI @ Meta Llama Team. The llama 3 herd of models, 2024. URL https://arxiv.org/abs/2407.21783.
* McLeish et al. (2024) Sean McLeish, Arpit Bansal, Alex Stein, Neel Jain, John Kirchenbauer, Brian R Bartoldson, Bhavya Kailkhura, Abhinav Bhatele, Jonas Geiping, Avi Schwarzschild, et al. Transformers can do arithmetic with the right embeddings. _arXiv preprint arXiv:2405.17399_, 2024.
* Mu et al. (2023) Norman Mu, Sarah Chen, Zifan Wang, Sizhe Chen, David Karamardian, Lulwa Aljeraisy, Basel Alomair, Dan Hendrycks, and David Wagner. Can llms follow simple rules? _arXiv_, 2023.
* OpenAI (2023) OpenAI. Gpt-4o system card, 2023. URL https://cdn.openai.com/gpt-4o-system-card.pdf.
* Perez et al. (2022) Ethan Perez, Saffron Huang, Francis Song, Trevor Cai, Roman Ring, John Aslanides, Amelia Glaese, Nat McAleese, and Geoffrey Irving. Red teaming language models with language models. _arXiv preprint arXiv:2202.03286_, 2022.
* Perez & Ribeiro (2022) Fabio Perez and Ian Ribeiro. Ignore previous prompt: Attack techniques for language models, 2022. URL https://arxiv.org/abs/2211.09527.

* Piet et al. (2023) Julien Piet, Maha Alrashed, Chawin Sitawarin, Sizhe Chen, Zeming Wei, Elizabeth Sun, Basel Alomair, and David Wagner. Jatmo: Prompt injection defense by task-specific finetuning. _ArXiv_, abs/2312.17673, 2023. URL https://api.semanticscholar.org/CorpusID:266690784.
* Radford et al. (2019) Alec Radford, Jeff Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. Language models are unsupervised multitask learners, 2019.
* Sharma et al. (2024) Reshabh K Sharma, Vinayak Gupta, and Dan Grossman. Spml: A dsl for defending language models against prompt attacks, 2024.
* Shen et al. (2024) Xinyue Shen, Zeyuan Chen, Michael Backes, Yun Shen, and Yang Zhang. "Do Anything Now": Characterizing and Evaluating In-The-Wild Jailbreak Prompts on Large Language Models. In _ACM SIGSAC Conference on Computer and Communications Security (CCS)_. ACM, 2024.
* Sheshadri et al. (2024) Abhay Sheshadri, Aidan Ewart, Phillip Guo, Aengus Lynch, Cindy Wu, Vivek Hebbar, Henry Sleight, Asa Cooper Stickland, Ethan Perez, Dylan Hadfield-Menell, and Stephen Casper. Targeted latent adversarial training improves robustness to persistent harmful behaviors in llms. _arXiv preprint arXiv:2407.15549_, 2024.
* Souly et al. (2024) Alexandra Souly, Qingyuan Lu, Dillon Bowen, Tu Trinh, Elvis Hsieh, Sana Pandey, Pieter Abbeel, Justin Svegliato, Scott Emmons, Olivia Watkins, and Sam Toyer. A strongreject for empty jailbreaks, 2024.
* Su et al. (2024) Jianlin Su, Murtadha Ahmed, Yu Lu, Shengfeng Pan, Wen Bo, and Yunfeng Liu. Roformer: Enhanced transformer with rotary position embedding. _Neurocomputing_, 568:127063, 2024. ISSN 0925-2312. doi:https://doi.org/10.1016/j.neucom.2023.127063. URL https://www.sciencedirect.com/science/article/pii/S0925231223011864.
* Taori et al. (2023) Rohan Taori, Ishaan Gulrajani, Tianyi Zhang, Yann Dubois, Xuechen Li, Carlos Guestrin, Percy Liang, and Tatsunori B. Hashimoto. Stanford alpaca: An instruction-following llama model. https://github.com/tatsu-lab/stanford_alpaca, 2023.
* Touvron et al. (2023) Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajwal Bhagava, Shruti Bhosale, et al. Llama 2: Open foundation and fine-tuned chat models. _arXiv preprint arXiv:2307.09288_, 2023.
* Toyer et al. (2024) Sam Toyer, Olivia Watkins, Ethan Adrian Mendes, Justin Svegliato, Luke Bailey, Tiffany Wang, Isaac Ong, Karim Elmaaroufi, Pieter Abbeel, Trevor Darrell, Alan Ritter, and Stuart Russell. Tensor trust: Interpretable prompt injection attacks from an online game. In _The Twelfth International Conference on Learning Representations_, 2024. URL https://openreview.net/forum?id=fsW7wJGLBd.
* Wallace et al. (2024) Eric Wallace, Kai Xiao, Reimar H. Leike, Lilian Weng, Johannes Heidecke, and Alex Beutel. The instruction hierarchy: Training llms to prioritize privileged instructions. _ArXiv_, abs/2404.13208, 2024. URL https://api.semanticscholar.org/CorpusID:269294048.
* Wang et al. (2023) Boxin Wang, Weixin Chen, Hengzhi Pei, Chulin Xie, Mintong Kang, Chenhui Zhang, Chejian Xu, Zidi Xiong, Ritik Dutta, Ryan Schaeffer, Sang T. Truong, Simran Arora, Mantas Mazeika, Dan Hendrycks, Zinan Lin, Yu Cheng, Sanni Koyejo, Dawn Song, and Bo Li. Decodingtrust: A comprehensive assessment of trustworthiness in GPT models. In _Thirty-seventh Conference on Neural Information Processing Systems Datasets and Benchmarks Track_, 2023. URL https://openreview.net/forum?id=kalpto802w2.
* Wei et al. (2023) Zeming Wei, Yifei Wang, and Yisen Wang. Jailbreak and guard aligned language models with only few in-context demonstrations. _arXiv preprint arXiv:2310.06387_, 2023.
* Xie et al. (2024) Tinghao Xie, Xiangyu Qi, Yi Zeng, Yangsibo Huang, Udari Madhushani Sehwag, Kaixuan Huang, Luxi He, Boyi Wei, Dacheng Li, Ying Sheng, et al. Sorry-bench: Systematically evaluating large language model safety refusal behaviors. _arXiv preprint arXiv:2406.14598_, 2024.

* Yao et al. (2022) Shunyu Yao, Howard Chen, John Yang, and Karthik Narasimhan. Webbop: Towards scalable real-world web interaction with grounded language agents. In S. Koyejo, S. Mohamed, A. Agarwal, D. Belgrave, K. Cho, and A. Oh (eds.), _Advances in Neural Information Processing Systems_, volume 35, pp. 20744-20757. Curran Associates, Inc., 2022. URL https://proceedings.neurips.cc/paper_files/paper/2022/file/82ad13ec01f9fe44c01cb91814fd7b8c-Paper-Conference.pdf.
* Yasunaga et al. (2022) Michihiro Yasunaga, Jure Leskovec, and Percy Liang. LinkBERT: Pretraining language models with document links. In Smaranda Muresan, Preslav Nakov, and Aline Villavicencio (eds.), _Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)_, pp. 8003-8016, Dublin, Ireland, May 2022. Association for Computational Linguistics. doi:10.18653/v1/2022.acl-long.551. URL https://aclanthology.org/2022.acl-long.551.
* Yen et al. (2024) Howard Yen, Tianyu Gao, and Danqi Chen. Long-context language modeling with parallel context encoding. In Lun-Wei Ku, Andre Martins, and Vivek Srikumar (eds.), _Proceedings of the 62nd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)_, pp. 2588-2610, Bangkok, Thailand, August 2024. Association for Computational Linguistics. URL https://aclanthology.org/2024.acl-long.142.
* Yu et al. (2023) Jiahao Yu, Yuhang Wu, Dong Shu, Mingyu Jin, and Xinyu Xing. Assessing prompt injection risks in 200+ custom gpts. _arXiv preprint arXiv:2311.11538_, 2023.
* Zhan et al. (2024) Qiusi Zhan, Zhixiang Liang, Zifan Ying, and Daniel Kang. Injecagent: Benchmarking indirect prompt injections in tool-integrated large language model agents. In _Annual Meeting of the Association for Computational Linguistics_, 2024. URL https://api.semanticscholar.org/CorpusID:268248325.
* Zhang et al. (2024) Yiming Zhang, Nicholas Carlini, and Daphne Ippolito. Effective prompt extraction from language models. In _First Conference on Language Modeling_, 2024. URL https://openreview.net/forum?id=0o95CVdwuz.
* Zhao et al. (2024) Wenting Zhao, Xiang Ren, Jack Hessel, Claire Cardie, Yejin Choi, and Yuntian Deng. Wildchat: 1m chatGPT interaction logs in the wild. In _The Twelfth International Conference on Learning Representations_, 2024. URL https://openreview.net/forum?id=B18u72R1bdM.
* Zheng et al. (2023) Lianmin Zheng, Wei-Lin Chiang, Ying Sheng, Siyuan Zhuang, Zhanghao Wu, Yonghao Zhuang, Zi Lin, Zhuohuan Li, Dacheng Li, Eric Xing, Hao Zhang, Joseph E Gonzalez, and Ion Stoica. Judging llm-as-a-judge with mt-bench and chatbot arena. In A. Oh, T. Naumann, A. Globerson, K. Saenko, M. Hardt, and S. Levine (eds.), _Advances in Neural Information Processing Systems_, volume 36, pp. 46595-46623. Curran Associates, Inc., 2023. URL https://proceedings.neurips.cc/paper_files/paper/2023/file/91f18a1287b398d378ef22595bf41832-Paper-Datasets_and_Benchmarks.pdf.
* Zheng et al. (2024) Xiaosen Zheng, Tianyu Pang, Chao Du, Qian Liu, Jing Jiang, and Min Lin. Improved few-shot jailbreaking can circumvent aligned language models and their defenses, 2024. URL https://arxiv.org/abs/2406.01288.
* Zou et al. (2023) Andy Zou, Zifan Wang, Nicholas Carlini, Milad Nasr, J Zico Kolter, and Matt Fredrikson. Universal and transferable adversarial attacks on aligned language models. _arXiv preprint arXiv:2307.15043_, 2023.
* Zou et al. (2024) Andy Zou, Long Phan, Justin Wang, Derek Duenas, Maxwell Lin, Maksym Andriushchenko, Rowan Wang, Zico Kolter, Matt Fredrikson, and Dan Hendrycks. Improving alignment and robustness with circuit breakers. _ArXiv_, abs/2406.04313, 2024. URL https://api.semanticscholar.org/CorpusID:270286008.
* Zverev et al. (2024) Egor Zverev, Sahar Abdelnabi, Mario Fritz, and Christoph H Lampert. Can llms separate instructions from data? and what do we even mean by that? _arXiv preprint arXiv:2403.06833_, 2024.

## Appendix A Related Works

**Safety vulnerabilities of LLMs.** Recently, the safety of LLMs has become a critical concern. **(1)** These models are vulnerable to indirect and direct prompt injection attacks. Indirect prompt injections happen when malicious content is embedded in inputs sourced from external data providers, as discussed in various research studies (Greshake et al., 2023; Liu et al., 2023; Zhan et al., 2024; Debenedetti et al., 2024). In contrast, direct prompt injections occur when attackers explicitly introduce malicious instructions into user input, as demonstrated in (Perez and Ribeiro, 2022; Mu et al., 2023; Toyer et al., 2024; Sharma et al., 2024). **(2)** Another safety concern is the prompt extraction attack (Yu et al., 2023; Wang et al., 2023; Zhang et al., 2024), which is more related to privacy. In this type of attack, the attacker's goal is to maliciously obtain information from the system prompt, which is usually considered confidential. **(3)** Lastly, we consider harmful requests (Ganguli et al., 2022; Perez et al., 2022; Souly et al., 2024; Xie et al., 2024), where the prompts attempt to circumvent safety guidelines and elicit responses involving unsafe behavior, such as instructions for stealing someone's identity.

**Improving LLM robustness.** To mitigate these attacks, researchers have developed two major defense strategies: prompt-based and learning-based defenses. Prompt-based defenses construct special instructions (e.g., in-context exemplars or delimiters) to mitigate attacks during inference (Wei et al., 2023; Hines et al., 2024; Zverev et al., 2024). While these defenses can achieve high robustness against specific attacks, concerns exist regarding their potential utility drops. Learning-based defenses (Piet et al., 2023; Chen et al., 2024; Wallace et al., 2024) aim to enhance model robustness by fine-tuning the models with a dataset of malicious instructions combined with robust responses. In this work, we explore another approach to improving model robustness by modifying the embedding approach, which is orthogonal to all previous mitigation strategies.

**Embedding and architecture of LLMs.** Recent research has also focused on improving the LLM embeddings and architectural designs to tackle different challenges. For instance, Yen et al. (2024) proposed a method for enhancing long-context generalization by using a small encoder to process long inputs in chunks. Additionally, McLeish et al. (2024) introduced the Abacus embedding to improve model performance on arithmetic tasks. In contrast, this paper focuses primarily on enabling the model to learn the instruction hierarchy through Instructional Segment Embedding, as inspired by previous work on designing BERT (Lan et al., 2019) and LinkBERT (Yasunaga et al., 2022).

Details of Implementing Instructional Segment Embedding

Here's an example of implementing Instructional Segment Embedding with a few lines of Python/Pytorch code. The additional code is highlighted in **bold blue**.

In the init function, we initialize embedding layers, including the token embedding layer, ISE embedding layer, and positional embedding layer. The inputs to the function include the embedding dimension (embed_size), vocabulary size (vocab_size), and ISE dimension (ISE_size, which defaults to 4).

During inference (the forward function), we compute the token embeddings and ISE embeddings, then sum them for further processing. The input x is a list containing the input IDs of each token in the sentence, and the input seg is a list containing the segment IDs (e.g., system as 0, user as 1, data as 2, output as 3) for each token, with the same size as x.

```
1importtorch
2
3classTransformer(nn.Module):
5def__init_(self,embed_size,vocab_size,ISE_size):
6super(Transformer,self)__init_()
7self.token_embedding=nn.Embedding(vocab_size,embed_size)
8#Tokenembeddinglayer
9self.ISE_embedding=nn.Embedding(ISE_size,embed_size)
10#Instructionalsegementembeddinglayer
11self.positional_embedding=...
12self.layers=...
13
14
15
16defforward(self,x,seg):
17token_embed=self.token_embedding(x)
18#Converttokenindicestotokenembeddings
19ISE_embed=self.ISE_embedding(seg)
20#ConvertinstructionalsegmentstotInstructionalSegment Embeddings
21embedding=token_embed+ISE_embed
23x=self.positional_encoding(embedding)
25
26forlayerinself.layers:
27x=layer(x)
28returnx ```
Details of Training Data

In this section, we provide details on how we construct the data, including both the clean and adversarial datasets, to conduct experiments on Structured Query and Instruction Hierarchy benchmarks.

**Structured Query benchmark.** For the Clean Alpaca dataset, we use the _Alpaca-Cleaned-50K_ dataset (Taori et al., 2023; Gururise, 2024) to fine-tune the model. Since the dataset shares the same system instructions (i.e., "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request."), we combine the types of system and user instructions into a single instruction type.

For the Adversarial Alpaca dataset, we follow the approach outlined in Chen et al. (2024) to construct the dataset. The dataset includes both clean samples (50%), derived from the Clean Alpaca dataset, and attacked samples (50%), which involve indirect prompt injection attacks within the data. These attacked samples contain two types of attacks: the Naive Attack and the Completion-Other Attack. In the Naive Attack, the instruction from other samples is injected into the data. In the Completion-Other Attack, a fabricated response is injected first, followed by another set of instructions. The desired output for these adversarial samples should address only the original user instruction so the output remains the same.

More details can be found in this StruQ repository.

**Instruction Hierarchy benchmark.** We use three different datasets to train models: UltraChat Baseline, System Follow, and Instruction Hierarchy.

For the UltraChat Baseline dataset, we use the _UltraChat-200K_ dataset (Ding et al., 2023) and employ GPT-4o to decompose 10K prompts into three components: system instructions, user instructions, and data inputs. This results in approximately 190K plain UltraChat samples and 10K samples with structured queries. For samples without system instructions, we use the default prompt shown in Figure 6.

For the System Follow dataset, we combine the UltraChat Baseline dataset with two additional datasets: SystemChat (Abacus.AI, 2023) and SystemMessage (Huggingface, 2023). We use 5K samples from each of these datasets. Additionally, we observe that the quality of the original responses in SystemChat is relatively low; therefore, we use GPT-4o to generate high-quality output.

For the Instruction Hierarchy dataset, we include three different types of misaligned data following Wallace et al. (2024): indirect prompt injection, direct prompt injection, and prompt extraction. (1) Indirect prompt injection: We use 2K samples from UltraChat and inject instructions from other samples into the data. The output remains unchanged. (2) Direct prompt injection: We use 2K SystemChat samples and inject malicious user instructions that attempt to change the original system instructions. Additionally, we include 200 samples that directly conflict with the system instructions. The outputs for both parts are generated by GPT-4o. (3) Prompt extraction: We use 200 SystemMessage samples and inject malicious user instructions that attempt to extract the system message. We also included 2K samples that used aligned questions, which asked for general information about the system messages. Again, GPT-4o is used to generate the outputs. For direct prompt injection and prompt extraction, all injected user instructions are also generated by prompting GPT-4o.

Figure 6: The default system prompt of Instruction Hierarchy benchmark.

DTABLE]

## Appendix D Details of Evaluation

In this section, we provide full details on constructing various attacks to evaluate LLM models. Specifically, we consider the Structured Query benchmark (Appendix D.1) and the Instruction Hierarchy benchmark (Appendix D.2). We also explain how we evaluate the model's instruction-following capabilities in Appendix D.3.

### Evaluations on Structured Query Benchmark

As we discussed in Section 5.3, we leverage the same evaluation methods from (Chen et al., 2024), including Naive Attack, Ignore Attack, Escape Separation Attack, and Completion Real Attack, as shown in Figure 7. We use the test set from AlpacaEval, but only include samples containing valid data inputs to evaluate the model, resulting in a total of 208 test samples.

These attacks are designed to trick the model into outputting the specific word "hacked". The Naive Attack directly requests the model to print "hacked". The Ignore Attack prompts the model to disregard all previous instructions and output "hacked" (Perez and Ribeiro, 2022). The Escape Separation Attack injects special characters to simulate a separation of the previous text, tricking the model into ignoring prior instructions. Finally, the Completion Real Attack appends a fake response to the prompt, leading the model to believe the task is complete, after which malicious instructions are injected for the model to follow.

We also evaluate **out-of-domain** indirect prompt injection attacks. The key idea is to inject the adversarial text at the beginning and end of the data input sequence. We present a demonstration in Figure 8.

For both in-domain and out-of-domain attacks, we evaluate the models using robust accuracy, defined as the ratio of samples that do not output "hacked".

Figure 7: A demonstration of **in-domain** indirect prompt injection attacks on the Alpaca dataset, including Naive Attack, Ignore Attack, Escape Separation Attack, and Completion Real Attack.

### Evaluations on the Instruction Hierarchy Benchmark

We evaluate our models on Instruction Hierarchy using four types of attacks: indirect prompt injection, direct prompt injection, prompt extraction, and harmful requests.

**Indirect prompt injection.** We use the same evaluations and metrics as those applied in the Structured Query benchmarks.

**Direct prompt injection.** We use the same attacking prompts as indirect prompt injection but inject them directly into the user prompt. Additionally, we use the test set from AlpacaEval without any data input, which consists of 597 test samples. The evaluation metric remains the same: we calculate the ratio of samples that do not output "hacked", and denote this as robustness.

**Prompt extraction.** We use the ShareGPT and Unnatural Instructions datasets (Honovich et al., 2023), each consisting of 500 prompts, as described in (Zhang et al., 2024), to serve as the secret system messages. To perform prompt extraction, we utilize 15 effective prompts selected by the authors. These prompts are illustrated in Figure 9.

For evaluation metrics, we adopt the approach of Zhang et al. (2024), utilizing an approximate metric based on ROUGE-L recall (Lin, 2004). This metric computes the length of the longest common subsequence (LCS) between the extracted system message (\(e\)) and the ground truth (\(t\)). The resulting score is the ratio of the LCS length to the length of the ground truth. An attack is considered successful if this score exceeds 0.9, as presented in Equation 1.

\[\mathrm{Metric}(e,t)=1\left[\frac{|\operatorname{LCS}(\mathrm{tokens}(t), \mathrm{tokens}(e))|}{|\operatorname{tokens}(t)|}\geq 0.9\right]\] (1)

Robustness is then evaluated by the proportion of samples that successfully defend against the attack.

**Harmful requests.** We follow the evaluation approach of Wallace et al. (2024), utilizing prompts from Jailbreakchat (Chat) and "Do Anything Now" (DAN). These prompts are concatenated with malicious requests from StrongREJECT (Souly et al., 2024) to create the final harmful prompts.

Figure 8: A demonstration of **out-of-domain** indirect prompt injection attacks on the Alpaca dataset, including Naive Attack, Ignore Attack, Escape Separation Attack, and Completion Real Attack.

The full dataset includes 79 effective attacking prompts from Jailbreakchat (Chat) and 225 from "Do Anything Now" (DAN), all of which are publicly available. Both Jailbreakchat (Chat) and "Do Anything Now" (DAN) can be accessed in the repository, sourced from jailbreakchat.com and ChatGPTJailbreak. Additionally, there are 313 malicious instructions from StrongREJECT. For each sample, we randomly select one attacking prompt to concatenate with the instruction, resulting in a dataset of 313 evaluation samples.

For evaluation metrics, we query GPT-4o to determine whether the response adheres to safety guardrails (i.e., whether the response provides sufficient details to answer malicious requests). The detailed evaluation prompt is presented in Figure 10, which is similar to that used in (Xie et al., 2024). Robust accuracy is then computed as the ratio of cases where the model either rejects or does not provide sufficient detail in response to malicious questions.

### Instruction-following Evaluation

We also evaluate our models using two instruction-following benchmarks: AlpacaEval 1.0 (Li et al., 2023) and MT-Bench (Zheng et al., 2023). Specifically, we follow the steps of AlpacaEval 1.0 to assess model performance. For MT-Bench, we evaluate only 1-turn conversations, as our model is trained for single-turn interactions.

Figure 10: A demonstration of evaluation prompts for harmful requests.

Figure 9: A demonstration of attacking prompts used in prompt extraction.

## Appendix E Other Analysis of Evaluation Results

### Detailed Analysis over Attacks

The main paper covered the overall results (average robustness) across multiple prompt injection and extraction attacks. Here, we provide more detailed evaluations of attacks on the Instruction Hierarchy benchmark. Results for the Structure Query are reported in Appendix F.

**Prompt injection.** In Figure 11, we present the results of indirect prompt injection attacks, including Naive, Ignore, Escape Separation, and Completion Real, across in-domain and out-of-domain scenarios. The results indicate that our ISE method significantly enhances performance compared to the baseline across nearly all scenarios. Notably, the Completion Real attack severely compromises model robustness, resulting in less than 10% effectiveness for models trained on the UltraChat Baseline and the System Follow dataset without ISE. This attack works by introducing a spoofed response to the benign instruction and concatenating a new malicious instruction into the data. Models that fail to effectively differentiate between these types of instructions are prone to executing the new malicious instruction. However, our method significantly boosts robustness, yielding improvements ranging from approximately **30%** to **50%**.

**Prompt extraction.** As mentioned in Section 5.3, we utilize 15 effective malicious prompts to extract the system messages. In Figure 12, we present all the results and find that our method consistently outperforms the baseline, notably enhancing the worst robust accuracy by up to approximately **45%**. Interestingly, the model trained on the UltraChat Baseline dataset with ISE exhibits the highest robustness, even exceeding that of the model trained on the Instruction Hierarchy dataset. We find that this is because the instruction-following capability of models trained on the UltraChat Baseline is relatively weak (about 20% lower than the other two models on AlpacaEval). Consequently, in scenarios where the model is misled into fulfilling a request to output the system message, it sometimes generates only a partial system prompt. Therefore, the attack is not classified as successful. Results on the Unnatural dataset are provided in Appendix G.3.

**Harmful requests.** In Figure 13, we report the robustness of models trained on UltraChat Baseline against Jailbreakhat prompts across six categories: 'Disinformation and Deception,' 'Hate, Harassment, and Discrimination,' 'Illegal Goods and Services,' 'Non-Violent Crimes,' 'Sexual Content,' and 'Violence.' We observe that Instructional Segment Embedding improves robustness in 6 out of 6 categories, with improvements of up to **18%**. Further results are reported in Appendix G.4.

Figure 11: Robust accuracy of indirect prompt injection attack on the Instruction Hierarchy benchmark with both in-domain and out-of-domain attacks. More details are described in Appendix G.1.

Figure 12: Robust accuracy against 15 effective prompt extraction attacks on ShareGPT dataset.

### Other Analysis

**Over-refusal Evaluation.** One potential concern is that our method may overfit and refuse to follow user instructions. Therefore, we conduct an over-refusal evaluation on the WildChat dataset (Zhao et al., 2024) following (Anthropic, 2024; Zou et al., 2024). After filtering out prompts that exceed the context window, we use 691 non-toxic prompts to query the model and evaluate whether it generates reasonable responses using GPT-4o. In Figure 15, we report the compliance rate on the benchmark and observe that our ISE improves the compliance rate by about 10% for the model trained on the UltraChat Baseline but shows slight degradation for the other two models. Overall, we expect that our method will maintain model capacity, as shown on AlpacaEval and MT-bench in Figure 5.

**Generalization to Other Model.** We also evaluated Llama-3.1-8B using the same setup as Llama-3-8B on the Instruction Hierarchy benchmarks. In Figure 15, we present the results on AlpacaEval and the robustness against four attacks (averaged results) of models trained on the UltraChat Baseline. Our method demonstrates an approximate **10%** improvement in win rate on the AlpacaEval dataset. For robustness, we observe around a **5%** robust accuracy improvement against harmful requests and over **10%** on all other attacks. Overall, these results suggest our method can be generalized across different models. The complete results are provided in Appendix G.5.

[MISSING_PAGE_FAIL:21]

More Experimental Results on Instruction Hierarchy

In this section, we provide additional experimental results on the Instruction Hierarchy benchmark, covering indirect prompt injection (Appendix G.1), direct prompt injection (Appendix G.2), prompt extraction (Appendix G.3), and harmful requests (Appendix G.4). Furthermore, we present the results for Llama-3.1-8B in Appendix G.5.

### Detailed Analysis of Indirect Prompt Injection

In Figure 11, we present the results of both in-domain and out-of-domain attacks. Similar to the Structured Query benchmark, we evaluate additional in-domain attacks designed by (Chen et al., 2024), which are shown in Figure 16. Due to space constraints, we use Att to represent different attacks.

Specifically, Attl to Attl8 correspond to the following list of attacks: Attl:Naive, Att2:Ignore, Att3:Escape_deletion, Att4:Escape_separation, Att5:Completion_other, Att6:Completion_otherch, Att7:Completion_real, Att8:Completion_realch, Att9:Completion_close_2hash, Attl0:Completion_close_hash, Attl10:Completion_close_2hash, Attl2:Completion_close_upper, Attl3:Completion_close_title, Attl4:Completion_close_nospace, Attl5:Completion_close_nocolon, Attl6:Completion_close_typo, and Attl7:Completion_close_similar.

Again, we observe that our ISE method significantly enhances robustness against almost all attacks. The average robust accuracy gains range from approximately **15%** to **45%**, with the worst robust accuracy gains reaching up to nearly **50%**.

### Detailed Analysis of Direct Prompt Injection

In Figure 17, we report the robust accuracy against both in-domain and out-of-domain direct prompt injection attacks. We observe performance gains for our ISE method across various attack scenarios. For instance, the average robust accuracy against in-domain attacks improves from **47.3%** to **69.9%** for the model trained on the UltraChat Baseline dataset.

Additionally, similar to indirect prompt injection attacks, we also include the full results of in-domain attacks in Figure 18. The attacking prompts are exactly the same as described in Appendix G.1. These results further validate the effectiveness of our method, improving the average robust accuracy by over **10%** and the worst robust accuracy by over **20%**.

Figure 16: Full results of in-domain indirect prompt injection attack we evaluated on the Instruction Hierarchy benchmark.

Figure 17: Results of direct prompt injection attack we evaluated on the Instruction Hierarchy benchmark.

### Detailed Analysis of Prompt Extraction

Following Section E.1, we also present the full results of the prompt extraction on the Unnatural Instructions dataset. We observe similar trends where adding ISE makes the model more robust against extraction attacks, potentially enhancing privacy. Notably, the robustness (i.e., the ratio of cases where the attack fails to extract a significant number of original prompts) improves by over **20%** on both average and worst scenarios for the models trained on the UltraChat Baseline.

### Detailed Analysis of Harmful Requests

We present the full results from Figure 13 with two more models trained on the System Follow and Instruction Hierarchy dataset in Figure 20. We continue to observe average robustness improvements across different categories, especially for the UltraChat Baseline and Instruction Hierarchy datasets. Note that the model was trained without any data specifically designed to bypass the safety guidelines.

### Detailed Analysis of LLAMA 3.1 Model

We then provide a more detailed evaluation of the Llama-3.1-8B model on Instruction Hierarchy in Figure 21. We continue to observe improved model capability and enhanced robustness across various attacks, indicating that our method generalizes well to different models. For instance, ISE consistently improves the winning rate on AlpacaEval and either maintains or improves the score on

Figure 19: Full results of prompt extraction we evaluated on Unnatural Instructions.

Figure 20: Full results of the harmful request evaluation on JailbreakChat prompts using StrongREJECT malicious instructions.

Figure 18: Full results of in-domain direct prompt injection attack we evaluated on the Instruction Hierarchy benchmark.

MT-Bench. In terms of robustness, our method also improves performance, even for models trained on Instruction Hierarchy, which already achieve high robustness.

Figure 21: **Evaluations on Llama-3.1-8B. The evaluation of model capabilities on the Instruction Hierarchy benchmark is conducted using AlpacaEval and MT-Bench (Figure a). Robustness evaluations include indirect and direct prompt injection attacks, prompt extraction attacks, and harmful requests (Figure b). We performed experiments across three training datasets and compared our Instructional Segment Embedding (ISE) method against the baseline.**

## Appendix H Discussions and Evaluations on Jailbreak Attacks

In our harmful request evaluations, we primarily focused on malicious prompts collected in the wild, without involving any active optimization, following Wallace et al. (2024). We considered these prompts as zero-shot generalization evaluations since no training data aimed to bypass safety alignment.

There also exist adaptive attacks, known as jailbreak attacks, generated through advanced strategies, such as adversarially optimized texts like those in (Zou et al., 2023; Liao & Sun, 2024), or carefully human-crafted strategies as seen in Anil et al. (2024). In Table 4, we present the results of using adaptive attacks from (Andriushchenko et al., 2024; Zheng et al., 2024) on 50 malicious requests (Chao et al., 2023), and we observe that our models almost completely fail to generate safe responses.

_In fact, we do not expect our method to improve adaptive jailbreak robustness._ First, none of our data were explicitly created to defend against (or reject) jailbreak attacks. Second, while our segment embedding is designed to differentiate between types of instructions, adversarial texts may directly target the model. Our method is orthogonal to many robust training methods, such as LAT (Sheshadri et al., 2024) and circuit breakers (Zou et al., 2024). We leave further exploration of this issue for future research.

\begin{table}
\begin{tabular}{l c c c c c c} \hline \hline  & UltraChat & +ISE & System & +ISE & Instruction & +ISE \\  & Baseline & (Ours) & Follow & (Ours) & Hierarchy & (Ours) \\ \hline Jailbreak attacks (\%) & 2.0 & 2.0 & 0.0 & 2.0 & 2.0 & 4.0 \\ \hline \hline \end{tabular}
\end{table}
Table 4: Robust accuracy against adaptive attacks on Instruction Hierarchy benchmark.