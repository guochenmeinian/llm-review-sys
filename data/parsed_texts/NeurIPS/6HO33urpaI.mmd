# Open-Book Neural Algorithmic Reasoning

 Hefei Li, Chao Peng, Chenyang Xu, Zhengfeng Yang

Shanghai Key Laboratory of Trustworthy Computing

Software Engineering Institute

East China Normal University, Shanghai, China

51255902127@stu.ecnu.edu.cn,

{cpeng, cyxu, zfyang}@sei.ecnu.edu.cn

Correspondence to Chao Peng and Chenyang Xu. The authors are ordered alphabetically.

###### Abstract

Neural algorithmic reasoning is an emerging area of machine learning that focuses on building neural networks capable of solving complex algorithmic tasks. Recent advancements predominantly follow the standard supervised learning paradigm - feeding an individual problem instance into the network each time and training it to approximate the execution steps of a classical algorithm. We challenge this mode and propose a novel open-book learning framework. In this framework, whether during training or testing, the network can access and utilize all instances in the training dataset when reasoning for a given instance.

Empirical evaluation is conducted on the challenging CLRS Algorithmic Reasoning Benchmark, which consists of 30 diverse algorithmic tasks. Our open-book learning framework exhibits a significant enhancement in neural reasoning capabilities. Further, we notice that there is recent literature suggesting that multi-task training on CLRS can improve the reasoning accuracy of certain tasks, implying intrinsic connections between different algorithmic tasks. We delve into this direction via the open-book framework. When the network reasons for a specific task, we enable it to aggregate information from training instances of other tasks in an attention-based manner. We show that this open-book attention mechanism offers insights into the inherent relationships among various tasks in the benchmark and provides a robust tool for interpretable multi-task training.

## 1 Introduction

Deep neural networks have achieved remarkable advancements in various areas, such as image processing [18; 6] and natural language processing [16; 21]. In recent years, as deep learning continues to evolve, there has been an increasing desire to see deep neural networks take on more complex tasks. Algorithmic reasoning tasks [27; 5; 28] have emerged as a particularly crucial category. In classical domains, deep neural networks have demonstrated their ability to learn predictive patterns from training data. The aspiration now is to extend this capability to the field of algorithmic reasoning, which motivates a burgeoning domain -- _Neural Algorithmic Reasoning_ (NAR).

Neural algorithmic reasoning was initially coined by [30]. The central objective of this domain is to develop and train neural networks with the capability to imitate classical rule-based algorithms, such as sorting algorithms and graph algorithms. Networks built in this manner demonstrate the ability to perform algorithmic computations similar to traditional algorithms in reasoning tasks, while showcasing improved computational efficiency compared to them [17]. Moreover, recent literature [31; 22] shows that owing to the characteristics of deep learning, these networks exhibit flexibility in handling diverse input formats, making them robust even in scenarios where certain input features are missing.

**Challenging Benchmark for NAR.** CLRS Algorithmic Reasoning Benchmark proposed by [26] is currently the most popular and definitive benchmark for evaluating the algorithmic capabilities of neural networks. This benchmark comprises 30 diverse algorithmic reasoning tasks extracted from the foundational algorithms textbook "Introduction to Algorithms" [4], including sorting, searching, dynamic programming, graph algorithms, string algorithms, and more. Beyond the task diversity, another notable challenge of this benchmark is the _significant differences_ in scale between problem instances in the training and test sets. The test instances are substantially larger in scale compared to those in the training set.

There have been many recent advances in exploring CLRS [7; 19; 2; 8; 24; 3]. As classical algorithms can often be represented by graph structures, several successful approaches leverage the Graph Neural Network (GNN) framework, including models such as PGN [29] and MPNN [9]. In addition to directly applying these classical GNNs, the literature has observed that the execution of some classical algorithms often relies on specific data structures. Consequently, there have been proposals to integrate classical GNNs with data structures like priority queues [12] or stacks [14] to enhance neural reasoning capabilities.

However, we notice that all prior approaches predict algorithmic executions based solely on their parameters and the features of a single input. Although this mode is commonly used in traditional supervised learning tasks [20; 1], it may not be well-suited for NAR due to the inherent difference between complicated reasoning tasks and traditional tasks like image processing. In practical scenarios, when recognizing images, extensive background knowledge is typically not required; but when faced with complex reasoning tasks, a substantial amount of background knowledge is often necessary to complete various aspects of the reasoning process. In such situations, having real-time illustrative examples or formulas available for reference can significantly reduce our memory burden, thereby enhancing task completion. This naturally raises a question:

_If allowing a neural network to access additional examples for reference during reasoning, will its reasoning capability improve as a result?_

### Our Contributions

We explore the aforementioned question and introduce open-book neural algorithmic reasoning. In this model, the neural architecture is enhanced with an additional memory component that stores representations of instances in the training dataset. Whether during training or testing, whenever the network engages in reasoning for a specific instance, it has the capability to leverage this supplementary memory to aggregate information from other instances within the training set, akin to an open-book exam. The main results of the paper are summarized as follows:

* We present a general framework for open-book NAR. This framework builds upon the foundation of previous NAR architectures by introducing two additional modules for embedding and information aggregation from the training set, and can seamlessly integrate with existing methods. We further provide a detailed implementation of the framework, which is grounded in the cross-attention mechanism. This design not only caters to single-task training but also proves to be highly effective in scenarios involving multi-task training.
* Empirical evaluations are conducted on the challenging CLRS Benchmark [26]. We incorporate the proposed framework with three popular network architectures in the literature. The results demonstrate that each architecture's reasoning capability can be improved significantly when utilizing the training instances through the framework. Across the majority of the reasoning tasks within the benchmark, the framework yields state-of-the-art results.
* Multi-task training is also investigated in the paper. As highlighted in [11], on certain reasoning tasks, a generalist network trained on all datasets in CLRS outperforms the networks trained in a single-task manner. We provide an interpretation of this observation using the proposed open-book framework. Specifically, when training a neural network to solve a task, we input information from other task datasets into the framework for its use. The results show that our open-book framework can nearly replicate the effects of multi-task training for each algorithmic task, while in some tasks, it even achieves higher accuracies. Additionally, our attention-based implementation enables us to analyze the attention weights of various tasks, facilitating a deeper understanding of the intrinsic relationships amongtasks. A "paired training" experiment is further conducted to verify the effectiveness of the learned attention weights.

### Other Related Work

Our work is closely aligned with the exploration of non-parametric models [23; 25; 13], where models abstain from training specific parameters and, instead, utilize dependencies among training data points for predictions. Our framework can be viewed as a fusion of deep neural networks and non-parametric models. We have noted analogous efforts in recent work within the field of image processing [15]. This work focuses on the CIFAR-10 dataset, employing self-attention mechanisms among different points in the dataset to finish image classification tasks.

## 2 Preliminaries

This section introduces the setting of an NAR dataset formally and outlines the standard paradigm employed in NAR.

**NAR Dataset.** The objective of an NAR task is to train a neural network such that it can imitate each execution step of a classical algorithm on given problem instances. Hence, a NAR dataset is labeled by a specific problem and the algorithm employed to solve it. Each data point includes a problem instance, represented by a graph structure, and the corresponding algorithm execution on that instance, conveyed through a sequence of graph-structured states. Denote by \(\mathbf{x}\) the problem instance and by \(\mathbf{y}=\{\mathbf{y}^{(1)},...,\mathbf{y}^{(t)},...\}\) the algorithm execution, where \(\mathbf{y}^{(t)}\) signifies the graph-structured states (e.g., the current nodes in the queue of breadth-first search) at the \(t\)-th step of the algorithm.

**Training Objective.** The training objective of the neural network is to perform sequential reasoning tasks over a given problem instance. At each step \(t\), the network takes as input the pair \(\left(\mathbf{x},\mathbf{y}^{(t-1)}\right)\) and produces the output \(\mathbf{y}^{(t)}\). This process enables the neural network to learn and predict the evolution of the algorithmic execution on the problem instance in a step-wise fashion.

**Encode-Processor-Decode Paradigm.** To achieve the aforementioned step-wise objective, the literature follows the standard _encode-process-decode_ paradigm [10], which consists of three modules: Encoder, Processor, and Decoder. At each step \(t\), the input \(\left(\mathbf{x},\mathbf{y}^{(t-1)}\right)\) traverses through these modules sequentially2:

Footnote 2: For simplicity, we abuse the notion slightly, allowing \(\mathbf{y}^{(t-1)}\) to represent the outcome of the last step.

* The encoder module encompasses multiple neural networks that operate on \(\left(\mathbf{x},\mathbf{y}^{(t-1)}\right)\), thereby transforming it into a collection of graph-structured hidden states. Use \(G=(V,E)\) to denote the graph structure. Following this module, we obtain \(h_{v}\) corresponding to each node \(v\in V\), \(h_{vu}\) associated with each edge \((v,u)\in E\), and \(h_{g}\) representing the hidden state of the entire graph \(G\).
* The processor module usually consists of a graph neural network. This module maintains the historical hidden states of nodes, edges, and the graph: \(\{h_{v}^{(t-1)}\}_{v\in V}\), \(\{h_{vu}^{(t-1)}\}_{(v,u)\in E}\), \(h_{g}^{(t-1)}\), and integrate them with the newly generated states \(\{h_{v}\}\), \(\{h_{v,u}\}\), \(h_{g}\) to yield updated states. We borrow the language of the message-passing architecture [9] to formalize this process. For brevity, the following focuses only on updating the state of each node \(v\). At each step \(t\), the node computes and aggregates messages \(m_{uv}\) from its incoming edges, updating its own hidden state: \[z_{v}^{(t)} \gets f_{1}\left(h_{v},h_{v}^{(t-1)}\right)\;;\quad m_{uv} \gets f_{2}\left(z_{v}^{(t)},z_{u}^{(t)},h_{uv},h_{g}\right)\quad\forall( u,v)\in E\;;\] \[M_{v} \leftarrow\bigoplus_{w:(u,v)\in E}m_{uv}\;;\qquad h_{v}^{(t)} \gets f_{3}\left(z_{v}^{(t)},M_{v}\right).\] Different processors employ different layers \(f_{1}\), \(f_{2}\), \(f_{3}\), and aggregation function \(\bigoplus\).
* The decoder module utilizes the states \(\mathbf{h}^{(t)}\) as input to forecast the algorithmic execution \(\mathbf{y}^{(t)}\) at step \(t\). It is noteworthy that recent literature [11] also incorporates \(\mathbf{x}\) and \(\mathbf{y}^{(t-1)}\) within this module.

Open-Book Reasoning

The paradigm above can be denoted by a function \(\mathcal{F}\) mapping \(\mathbf{x}\) to \(\mathbf{y}\) for each data point. Given a NAR dataset, this function implies a standard supervised learning mode: during a training step, a (or a mini-batch of) random datapoint \((\mathbf{x},\mathbf{y})\) is selected. The loss between \(\mathcal{F}(\mathbf{x})\) and \(\mathbf{y}\) is then computed, and the parameters in \(\mathcal{F}\) are updated accordingly. In this section, we go beyond the individual \(\mathbf{x}\rightarrow\mathbf{y}\) mode in conventional supervised learning, exploring a more general and practical learning paradigm.

### Framework

We introduce an open-book reasoning framework. Within the framework, when the network is tasked with solving problem instance \(\mathbf{x}\) and deducing \(\mathbf{y}\), it not only utilizes \(\mathbf{x}\) as input but is also allowed to leverage information from other data points within the training set during the reasoning process.

The intuition behind the open-book framework is analogous to our real-world scenario of solving algorithmic problems or engaging in other reasoning tasks. In practical situations, we often consult textbooks and refer to example problems to aid in completing tasks. Typically, the structure and solutions of these examples provide substantial assistance in our reasoning process. Denoting the training set as \(\mathbf{T}\), the framework essentially aims to learn a comprehensive function \(\mathcal{F}:\mathbf{x}\cup\mathbf{T}\rightarrow\mathbf{y}\).

An illustration of the framework is present in Figure 1. In addition to the original three modules, we introduce two new modules: _Dataset Encoder_ and _Open-Book Processor_:

* The dataset encoder module employs an encoding function \(f_{E}\) to compute the latent feature of each data point \(\mathbf{d}_{i}=(\mathbf{x}_{i},\mathbf{y}_{i})\) in the training set: \(\mathbf{r}_{i}\gets f_{E}\left(\mathbf{x}_{i},\mathbf{y}_{i}\right).\) It is worth noting that this encoder module is essentially different from the original one. It maps an entire data point \(\mathbf{d}_{i}=(\mathbf{x}_{i},\mathbf{y}_{i})\), encompassing the ground truth of each node (and edge) at each step, into a single representation \(\mathbf{r}_{i}\).
* The open-book processor module is incorporated between the original processor and decoder modules. The output \(\mathbf{h}^{(t)}\) from the processor no longer directly feeds into the decoder; instead, it passes through the open-book processor, where it undergoes information aggregation with the training data representation \(\mathbf{R}=\{\mathbf{r}_{1},...,\mathbf{r}_{i},...\}\) (generated by the dataset encoder). Subsequently, the open-book processor produces the latent features \(\widehat{\mathbf{h}}^{(t)}\) required by the decoder. Formally, for each node \(v\in V\), \(\widehat{h}_{v}^{(t)}\gets f_{P}\left(h_{v}^{(t)},\mathbf{R}\right).\)

The central component of the framework is the open-book processor module. Within this module, the current problem instance to be solved is integrated with examples from the training set. It is crucial to acknowledge that this integration has both advantages and disadvantages. While it often enhances the architecture's reasoning capabilities, there are instances when it may lead to counterproductive effects, particularly during multi-task training. We will elaborate on this in the experiments.

Figure 1: An illustration of the open-book framework. At each reasoning step \(t\), we simultaneously input \((\mathbf{x},\mathbf{y}^{(t-1)})\) and instances from the training set \(\mathbf{T}\), yielding \(\mathbf{y}^{(t)}\).

### Attention-Based Implementation

Diverse implementations within the framework can be achieved by employing different functions for \(f_{E}\) and \(f_{P}\). For the ease of investigating multitask training, we adopt an attention mechanism-based implementation. A description of the network implementation and training is given in Algorithm 1.

```
0: Training set \(\mathbf{T}\).
1:while current epochs \(\leq\) maximum training epochs do
2: Initialize the hidden state \(\mathbf{h}^{(0)}\) and \(\widehat{\mathbf{h}}^{(0)}\).
3: Randomly pick a _target_ data point \(\mathbf{d}=(\mathbf{x},\mathbf{y})\in\mathbf{T}\) and several _auxiliary_ data points \(\mathbf{d}_{1},\mathbf{d}_{2},...\mathbf{d}_{\ell}\in\mathbf{T}\). \(\triangleright\)Dataset Encoder
4:for each auxiliary data point \(\mathbf{d}_{i}=(\mathbf{x}_{i},\mathbf{y}_{i})\)do
5: Let \(G=(V,E)\) represent the underlying graph of \(\mathbf{d}_{i}\). This data point encompasses a state sequence \(<\mathbf{x}_{i}=\mathbf{y}_{i}^{(0)},\mathbf{y}_{i}^{(1)},...,\mathbf{y}_{i}^ {(t)},...>\) on the graph.
6: Randomly select two adjacent states \(\mathbf{y}_{i}^{(p)},\mathbf{y}_{i}^{(p+1)}\) from the sequence.
7:for each node \(v\in V\)do
8: Let \(y_{v}\) and \(y_{v}^{\prime}\) be node \(v\)'s states in \(\mathbf{y}_{i}^{(p)}\) and \(\mathbf{y}_{i}^{(p+1)}\) respectively.
9: Employ a linear layer \(z_{v}\leftarrow\text{linear}\left(\frac{1}{2}\cdot(y_{v}+y_{v}^{\prime})\right)\).
10:endfor
11:\(\mathbf{r}_{i}\leftarrow\frac{1}{|V|}\cdot\sum_{v\in V}z_{v}\).
12:endfor
13: Define \(\mathbf{R}:=[\mathbf{r}_{1},...,\mathbf{r}_{\ell}]\).
14:for each algorithm execution step \(t\) of the target data point do
15: Feed \(\mathbf{x}\) and the outcome from the previous step into the encoder and processor sequentially to obtain the hidden states \(\mathbf{h}^{(t)}\).
16: Employ a linear layer: \(\mathbf{R}^{(t)}\leftarrow\mathbf{R}\parallel\text{linear}(\mathbf{h}^{(t)})\). \(\triangleright\)Open-Book Processor
17: Set a QKV attention function with linear layers \(\mathsf{query}(\cdot),\mathsf{key}(\cdot),\mathsf{value}(\cdot)\).
18: Compute a cross-attention between \(\mathbf{h}^{(t)}\) and \(\mathbf{R}^{(t)}\): \[\widehat{\mathbf{h}}^{(t)}\leftarrow\mathsf{softmax}\left(\frac{\mathsf{query} \left(\mathbf{h}^{(t)}\right)\cdot\mathsf{key}\left(\mathbf{R}^{(t)}\right)} {\sqrt{d_{k}}}\right)\ \cdot\ \mathsf{value}\left(\mathbf{R}^{(t)}\right),\] where \(d_{k}\) is the dimension of the key vectors.
19: Add a gate function: \(\widehat{\mathbf{h}}^{(t)}\leftarrow\mathsf{gate}\left(\mathbf{h}^{(t)}, \widehat{\mathbf{h}}^{(t)}\right).\)
20: Feed \(\widehat{\mathbf{h}}^{(t)}\) into the decoder module, yielding the predictions of this step.
21:endfor
22: Compute the prediction loss and update the network parameters.
23:endwhile ```

**Algorithm 1** Attention-Based Implementation of Open-Book Reasoning

From the description, a _target_ data point and several _auxiliary_ data points are randomly selected in each training iteration. The target data point serves as the focal point for neural optimization in this iteration: the network predicts its ground truths, computes the loss, and consequently updates the network parameters. The auxiliary data points assist the network in reasoning for the target data point. Their latent features are obtained through the dataset encoder, and they subsequently influence predictions through the open-book processor.

At each algorithmic step \(t\), the hidden states \(\mathbf{h}^{(t)}\) are computed conventionally. However, these states are not directly input into the decoder. Instead, they need to undergo cross-attention with the representations of auxiliary data points within the open-book processor module. This design allows the network to incorporate hints provided by the auxiliary data points during the reasoning process.

The construction of the dataset encoder is a bit subtle. We observe a crucial aspect that all these pieces of information ultimately serve the decoder module. In a single algorithmic step, the decoder's role is to facilitate the transition between two adjacent states throughout the entire reasoning process. Therefore, to better provide effective hints to the final decoder, for each auxiliary data point, werandomly sample a pair of adjacent states from its corresponding state sequence. Subsequently, we employ a linear layer to yield the latent representations of these data points.

**Remark.** The testing process is essentially similar to the training. It is worth noting that during the testing phase, the target data points are sourced from the testing set, while the auxiliary data points must still originate from the training set.

## 4 Experiments

This section evaluates the open-book implementation empirically on the CLRS benchmark. We aim to investigate the following three questions during the experiments:

* For various processor architectures present in the literature, can the open-book framework consistently enhance their empirical performances across the majority of the algorithmic tasks within the CLRS benchmark?
* There is a recent literature [11] proposing a multi-task training approach for CLRS. They train a common network for various tasks in the benchmark and find that some tasks benefit from the multi-task approach, achieving higher accuracy than when trained individually. In the context of the open-book setting, does this phenomenon imply that incorporating training sets from various tasks into the open-book framework may enhance the network's performance on certain tasks?
* Can the attention-based implementation serve as a robust tool for interpretable multi-task training? When integrating training sets from various tasks into the open-book framework for a specific task, the network eventually learns attention weights in the open-book processor, signifying the task's relevance to other tasks. Does this imply that if a task performs better in multi-task training than in single-task training, retaining only those tasks with prominent attention for multi-task training can still outperform single-task training?

To tackle these questions, we conduct three types of experiments3: single-task augmenting, multi-task augmenting, and multi-task interpretation. Note that our "multi-task augmenting" experiment differs essentially from traditional multi-task training; here, we still train the network for a specific task, but with the inclusion of datasets from other tasks in the dataset encoder. Additional ablation experiments are also conducted. Due to space limitations, we defer them to the full version of this paper. We initially outline the experimental setup and subsequently delve into each experiment.

Footnote 3: The codes are provided in https://github.com/Hoferlee1/Open-Book

### Setup

**Baselines.** We incorporate the open-book framework into three existing processor architectures: PGN [29], MPNN [9] and Triplet-GMPNN [11]. Given that the feature dimension of hidden states is set to 128 in the literature, we adjust the parameters of the dataset encoder and open-book processor to ensure seamless integration. The results (F1 scores) achieved by open-book reasoning are compared with them. Moreover, we also compare the performance with other recent architectures like Memnet [26] and NPQ [12].

**Computational Details.** The experiments are conducted on a machine equipped with an i7-13700K CPU, an RTX 4090 GPU, and an RTX A6000 GPU. The results are averaged over 4 runs. To ensure fair comparisons, we follow the widely-used experimental hyperparameter settings in [11], where the batch size is 32 and the network is trained for 10,000 steps by Adam optimizer with a learning rate of 0.001. During each training and testing iteration, we allow Algorithm1 to sample \(240\) auxiliary data points and use only one attention head. The average training time for each reasoning task is approximately 0.5 GPU hours.

### Single-Task Augmenting

This subsection considers a single-task environment: for each reasoning task in CLRS, both target and auxiliary data points in Algorithm1 are sourced from its own dataset. We create comparison charts for results on three existing architectures. Due to space, only one chart Figure2 is presentedin the main body, while the other two are deferred to the full version of this paper.The figure uses bar charts to illustrate average scores for each task, with standard deviations denoted by black lines. Additionally, we arrange the tasks in descending order of improvement magnitude to better illustrate trends.

We also provide tables to comprehensively compare the accuracies that the open-book framework yields with existing results. In CLRS, the 30 tasks are partitioned into 8 categories: Divide and Conquer, Dynamic Programming, Geometry, Graphs, Greedy, Search, Sorting, and Strings. So we present two tables: one showcasing the performance on the 30 individual tasks and another displaying the average performance for each of the 8 task categories. Due to space constraints, the latter is included in the main body (Table 1), while the former is deferred to the full version of this paper.

From the figures and tables, we observe that our approach outperforms the original architectures in the majority of tasks. The improvements provided by the open-book framework are particularly significant for certain tasks, such as the Naive String Matcher task (see Figure 2). However, we also notice a relatively large standard deviation in performance for some tasks. We attribute this variability to the fact that during testing, we sample data from the training set and input it into the dataset encoder each time. The quality of the sampled data influences the final inference results, leading to performance fluctuations.

\begin{table}
\begin{tabular}{c c c c} \hline Task Category & Prior Best & Triplet-GMPNN & Ours \\ \hline Graphs & 64.98\%\(\pm\)2.59 & 81.41\%\(\pm\)1.53 & **85.37\%\(\pm\)1.73** \\ Geometry & 92.48\%\(\pm\)1.35 & 94.09\%\(\pm\)0.77 & **96.55\%\(\pm\)0.50** \\ Strings & 4.08\%\(\pm\)0.57 & 49.09\%\(\pm\)4.78 & **72.41\%\(\pm\)2.66** \\ Dynamic Programming & 76\%\(\pm\)2.47 & 81.99\%\(\pm\)1.30 & **82.14\%\(\pm\)1.45** \\ Divide and Conquer & 65.23\%\(\pm\)2.56 & **76.36\%\(\pm\)0.43** & 74.52\%\(\pm\)1.88 \\ Greedy & 84.13\%\(\pm\)2.59 & 91.22\%\(\pm\)0.40 & **93.40\%\(\pm\)2.12** \\ Search & 56.11\%\(\pm\)0.36 & 58.61\%\(\pm\)1.05 & **63.15\%\(\pm\)0.90** \\ Sorting & 71.53\%\(\pm\)0.97 & 60.38\%\(\pm\)5.25 & **83.65\%\(\pm\)3.06** \\ \hline \end{tabular}
\end{table}
Table 1: The summary of our results on each task category in CLRS. The best-performing results in each row are highlighted in bold. To save space, we use the column “Prior Best” to denote the best results among four existing approaches: Memnet [26], PGN [26], MPNN [26], and NPQ [12], and the column “Ours” to denote the best results achieved by applying the open-book framework to the three existing architectures.

Figure 2: Comparison of the MPNN architecture’s performance before and after augmentation with the open-book framework. The 30 tasks are arranged in descending order of improvement magnitude.

### Multi-Task Augmenting

This subsection considers a "multi-task" environment: for each task in CLRS, Algorithm 1 selects target points from its own dataset, while the sampled auxiliary points are drawn from all datasets in CLRS. Since CLRS comprises 30 datasets, in each iteration, we randomly sample 8 instances from each dataset, ensuring that the total number of auxiliary points remains the same as in the single-task experiment, i.e., 240. Given that Triplet-GMPNN is the only architecture used for multi-task training in the literature, both this subsection and the following one "multi-task interpretation" focus exclusively on the results obtained by integrating the open-book framework with Triplet-GMPNN.

The results are present in Figure 3. We find that incorporating data from different tasks into the open-book processor indeed replicates multi-task training. Our multi-task augmented method closely matches the previous multi-task training results, and even outperforms them on the vast majority of tasks. It is worth noting that multi-task training requires simultaneous training on all 30 algorithmic tasks, which is extremely time-consuming. If the goal is simply to enhance performance on a specific task using multi-task training, the cost is substantial. However, with the open-book framework, we can nearly achieve the effects of multi-task training on a target task in approximately the same amount of time it takes to train a single algorithm.

### Multi-Task Interpretation

This subsection delves into interpreting multi-task training. In our multi-task augmenting experiments, the acquired attention weights in the open-book processor reveal the significance of each task in relation to others. Specifically, for each task, we aggregate the attention weights of each node at every algorithmic step on each test instance. The resulting 30-dimensional vector is then normalized, serving as the total attention vector for that task relative to other tasks in the benchmark. Table 2 shows the task with the highest attention weight for each task. Moreover, we present a heatmap regarding the attention weights among CLRS tasks in the full version of this paper.

Surprisingly, the table indicates that the majority of tasks exhibit a preference for attention toward tasks outside their own categories, contrary to our initial expectations. Only four bolded pairs show high attention to tasks within the same category, with most of these being graph algorithms. An intuitive explanation for this phenomenon is that tasks within the same category might not contribute additional information compared to the dataset used for training the task itself. Instead, tasks from other categories seem to play a crucial role in improving training accuracy.

Figure 3: Comparisons between our multi-task augmented approach and Triplet-GMPNN. The 30 tasks are arranged in descending order of improvement magnitude.

We proceed to a more in-depth examination of the relationships among tasks learned by the framework. We select a partner for each task according to Table 2 - namely, the task it pays the most attention to. We conduct training and testing in a multi-task manner for each task paired with its chosen partner, and refer to this type of training as paired-task training. In this experiment, we only focus on tasks that either demonstrate accuracy improvements or slight declines in multi-task training compared to single-task training, and train them in the paired manner. The results are given in Table 3. The table validates our hypothesis. On these tasks, paired-task training achieves improvements compared to single-task training, with most tasks even surpassing the performance of multi-task training.

### Experimental Summary

The experiments address the three questions posed at the beginning of the section.

* The open-book framework can significantly enhance the reasoning capabilities of various existing architectures, yielding state-of-the-art results across the majority of tasks in CLRS.
* By feeding data from various tasks into the dataset encoder, the framework can successfully replicate the effects of multi-task training, and in most datasets, even outperform it.

\begin{table}
\begin{tabular}{c c c} \hline Target & Auxiliary & Target & Auxiliary \\ \hline Activity Selector & Topological Sort & Jarvis’ March & MST-Kruskal \\ Articulation Points & Knuth-Morris-Pratt & Knuth-Morris-Pratt & Quicksort \\ Bellman-Ford & Bridges & LCS Length & Dijkstra \\ BFS & Task Scheduling & Matrix Chain Order & Jarvis’ March \\
**Binary Search** & **Quicksselect** & Minimum & Quicksort \\ Bridges & Optimal BST & MST-Kruskal & Heaepsort \\ Bubble Sort & Task Scheduling & **MST-Prim** & **Bridges** \\ DAG Shortest Paths & Naive String Matcher & LCS Length \\ DFS & Binary Search & Optimal BST & Find Max. Subarray \\
**Dijkstra** & **Bellman-Ford** & Quickselect & Dijkstra \\ Find Max. Subarray & Jarvis’ March & Quicksort & BFS \\ Floyd-Warshall & Heapsort & Segments Intersect & Topological Sort \\ Graham Scan & Quicksort & SCC & Task Scheduling \\ Heapsort & Activity Selector & Task Scheduling & Heapsort \\ Insertion Sort & Minimum & **Topological Sort** & **DAG Shortest Paths** \\ \hline \end{tabular}
\end{table}
Table 2: For each target (task), we show the task with the highest attention weight among other tasks in column “Auxiliary”. We use bold text to indicate when the paired tasks belong to the same algorithmic category.

\begin{table}
\begin{tabular}{c c c c} \hline Task & Single-Task & Multi-Task & Paired-Task \\ \hline Heapsort & 31.04\%\(\pm\)5.82 & **55.62\%\(\pm\)**15.91 & 46.63\%\(\pm\)10.43 \\ Knuth-Morris-Pratt & 19.51\%\(\pm\)4.57 & 51.61\%\(\pm\)8.63 & **65.67\%\(\pm\)12.36** \\ Insertion Sort & 78.14\%\(\pm\)4.64 & 87.00\%\(\pm\)4.16 & **95.78\%\(\pm\)0.80** \\ LCS Length & 80.51\%\(\pm\)1.84 & 83.43\%\(\pm\)1.19 & **85.86\%\(\pm\)1.47** \\ Quicksort & 64.64\%\(\pm\)5.12 & 75.10\%\(\pm\)9.52 & **88.43\%\(\pm\)6.25** \\ SCC & 43.43\%\(\pm\)3.15 & 48.48\%\(\pm\)9.96 & **73.39\%\(\pm\)3.00** \\ Jarvis’March & 91.01\%\(\pm\)1.30 & 74.51\%\(\pm\)10.71 & **94.44\%\(\pm\)0.63** \\ MST-Kruskal & 89.80\%\(\pm\)0.77 & 89.08\%\(\pm\)1.64 & **90.55\%\(\pm\)1.12** \\ MST-Prim & 86.39\%\(\pm\)1.33 & 86.26\%\(\pm\)2.08 & **92.56\%\(\pm\)0.99** \\ Topological Sort & 87.27\%\(\pm\)2.67 & 81.65\%\(\pm\)2.53 & **87.30\%\(\pm\)4.62** \\ Dijkstra & 96.05\%\(\pm\)0.60 & 94.29\%\(\pm\)1.04 & **97.44\%\(\pm\)0.50** \\ Binary Search & 77.58\%\(\pm\)2.35 & 69.30\%\(\pm\)5.65 & **79.17\%\(\pm\)2.79** \\ Bubble Sort & 67.68\%\(\pm\)5.50 & 52.94\%\(\pm\)9.96 & **70.30\%\(\pm\)6.77** \\ Graham Scan & 93.62\%\(\pm\)0.91 & 87.74\%\(\pm\)3.87 & **94.58\%\(\pm\)0.87** \\ Minimum & 97.78\%\(\pm\)0.55 & 92.50\%\(\pm\)2.53 & **98.32\%\(\pm\)0.14** \\ \hline \end{tabular}
\end{table}
Table 3: Comparisons among three training manners under Triplet-GMPNN.

* The attention-based implementation provides a valuable tool for the interpretability of multi-task training. By examining the learned attention weights, we can gain insights into the influences and intrinsic relationships among tasks during multi-task training.

## 5 Conclusion

This paper considers open-book neural algorithmic reasoning, introducing a novel open-book framework accompanied by an attention-based implementation. Through empirical evaluations, we demonstrate that this implementation not only enhances the reasoning capabilities of the existing architecture but also functions as an effective tool for interpretable learning.

Several interesting direction for future research exist, such as exploring more effective implementations within the open-book framework. Note that although our current implementation demonstrates performance improvements for the majority of tasks in CLRS, there are instances where the open-book approach may yield counterproductive results. Refining the current architecture to ensure performance enhancements across all tasks remains a significant challenge.

## Acknowledgements

This work is supported by the National Key Research Project of China under Grant No. 2023YFA1009402, the Scientific and Technological Innovation 2030 Major Projects under Grant 2018AAA0100902, NSFC Programs (62161146001, 62302166, 62372176), Shanghai Key Lab of Trustworthy Computing, Henan Key Laboratory of Oracle Bone Inscription Information Processing (AnYang Normal University), and the Key Laboratory of Interdisciplinary Research of Computation and Economics (SUFE), Ministry of Education.

## References

* [1]A. Aljuaid and M. Anwar (2022) Survey of supervised learning for medical image processing. SN Comput. Sci.3 (4), pp. 292. Cited by: SS1.
* [2]B. Bevilacqua, K. Nikiforou, B. Ibarz, I. Bica, M. Paganini, C. Blundell, J. Mitrovic, and P. Velickovic (2023) Neural algorithmic reasoning with causal regularisation. In ICML, Vol. 202 of Proceedings of Machine Learning Research, pp. 2272-2288. Cited by: SS1.
* [3]W. Bounsi, B. Ibarz, A. Dudzik, J. B. Hamrick, L. Markeeva, A. Vitvitskyi, R. Pascanu, and P. Velickovic (2024) Transformers meet neural algorithmic reasoners. CoRRabs/2406.09308. Cited by: SS1.
* [4]T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein (2009) Introduction to algorithms. 3rd edition, MIT Press. Cited by: SS1.
* [5]A. Deac, P. Velickovic, O. Milinkovic, P. Bacon, J. Tang, and M. Nikolic (2021) Neural algorithmic reasoners are implicit planners. In NeurIPS, pp. 15529-15542. Cited by: SS1.
* [6]S. Deng, D. Liao, X. Gao, J. Zhao, and K. Ye (2023) A survey on cross-domain few-shot image classification. In BigData, Lecture Notes in Computer Science, pp. 3-17. Cited by: SS1.
* [7]C. Diao and R. Loynd (2023) Relational attention: generalizing transformers for graph-structured tasks. In ICLR, Cited by: SS1.
* [8]A. J. Dudzik and P. Velickovic (2022) Graph neural networks are dynamic programmers. In NeurIPS, Cited by: SS1.
* [9]J. Gilmer, S. S. Schoenholz, P. F. Riley, O. Vinyals, and G. E. Dahl (2017) Neural message passing for quantum chemistry. In ICML, Vol. 70 of Proceedings of Machine Learning Research, pp. 1263-1272. Cited by: SS1.
* [10]J. B. Hamrick, K. R. Allen, V. Bapst, T. Zhu, K. R. McKee, J. Tenenbaum, and P. W. Battaglia (2018) Relational inductive bias for physical construction in humans and machines. In CogSci, pp. eprintseicencesociety.org. Cited by: SS1.
* [11]B. Ibarz, V. Kurin, G. Papamakarios, K. Nikiforou, M. Bennani, R. Csordas, A. J. Dudzik, M. Bosnjak, A. Vitvitskyi, Y. Rubanova, A. Deac, B. Bevilacqua, Y. Ganin, C. Blundell, and P. Velickovic (2022) A generalist neural algorithmic learner. In LoG, Vol. 198 of Proceedings of Machine Learning Research, pp. 2. PMLR. Cited by: SS1.
* [12]R. Jain, P. Velickovic, and P. Lio (2023) Neural priority queues for graph neural networks. In The 2023 ICML, Workshop on Knowledge and Logical Reasoning in the Era of Data-driven Learning, Vol. 202. PMLR. Cited by: SS1.
* [13]Z. Jiang, Y. Dai, J. Xin, M. Li, and J. Lin (2022) Few-shot non-parametric learning with deep latent variable model. In NeurIPS, Cited by: SS1.
* [14]J. Jurss, D. Hansaja Jayalath, and P. Velickovic (2023) Recursive algorithmic reasoning. In The Second Learning on Graphs Conference, Cited by: SS1.

* [15] Jannik Kossen, Neil Band, Clare Lyle, Aidan N. Gomez, Thomas Rainforth, and Yarin Gal. Self-attention between datapoints: Going beyond individual input-output pairs in deep learning. In _NeurIPS_, pages 28742-28756, 2021.
* [16] Ivano Lauriola, Alberto Lavelli, and Fabio Aiolli. An introduction to deep learning in natural language processing: Models, techniques, and tools. _Neurocomputing_, 470:443-456, 2022.
* [17] Yujia Li, Felix Gimeno, Pushmeet Kohli, and Oriol Vinyals. Strong generalization and efficiency in neural programs. _CoRR_, abs/2007.03629, 2020.
* [18] Weibo Liu, Zidong Wang, Xiaohui Liu, Nianyin Zeng, Yurong Liu, and Fuad E. Alsaadi. A survey of deep neural network architectures and their applications. _Neurocomputing_, 234:11-26, 2017.
* [19] Sadegh Mahdavi, Kevin Swersky, Thomas Kipf, Milad Hashemi, Christos Thrampoulidis, and Renjie Liao. Towards better out-of-distribution generalization of neural algorithmic reasoning tasks. _Trans. Mach. Learn. Res._, 2023, 2023.
* [20] Mohammed Amine El Mrabet, Khalid El Makkaoui, and Ahmed Faize. Supervised machine learning: A survey. In _CommNet_, pages 1-10. IEEE, 2021.
* [21] Wongyung Nam and Beakcheol Jang. A survey on multimodal bidirectional machine learning translation of image and natural language processing. _Expert Syst. Appl._, 235:121168, 2024.
* [22] Danilo Numeroso, Davide Bacciu, and Petar Velickovic. Dual algorithmic reasoning. In _ICLR_. OpenReview.net, 2023.
* [23] Carl Edward Rasmussen. Gaussian processes in machine learning. In _Advanced Lectures on Machine Learning_, volume 3176 of _Lecture Notes in Computer Science_, pages 63-71. Springer, 2003.
* [24] Gleb Rodionov and Liudmila Prokhorenkova. Neural algorithmic reasoning without intermediate supervision. In _NeurIPS_, 2023.
* [25] Bing Shuai, Gang Wang, Zhen Zuo, Bing Wang, and Lifan Zhao. Integrating parametric and non-parametric models for scene labeling. In _CVPR_, pages 4249-4258. IEEE Computer Society, 2015.
* [26] Petar Velickovic, Adria Puigdomenech Badia, David Budden, Razvan Pascanu, Andrea Banino, Misha Dashevskiy, Raia Hadsell, and Charles Blundell. The CLRS algorithmic reasoning benchmark. In _ICML_, volume 162 of _Proceedings of Machine Learning Research_, pages 22084-22102. PMLR, 2022.
* [27] Petar Velickovic and Charles Blundell. Neural algorithmic reasoning. _Patterns_, 2(7):100273, 2021.
* [28] Petar Velickovic, Matko Bosnjak, Thomas Kipf, Alexander Lerchner, Raia Hadsell, Razvan Pascanu, and Charles Blundell. Reasoning-modulated representations. In _LoG_, volume 198 of _Proceedings of Machine Learning Research_, page 50. PMLR, 2022.
* [29] Petar Velickovic, Lars Buesing, Matthew C. Overlan, Razvan Pascanu, Oriol Vinyals, and Charles Blundell. Pointer graph networks. In _NeurIPS_, 2020.
* [30] Petar Velickovic, Rex Ying, Matilde Padovano, Raia Hadsell, and Charles Blundell. Neural execution of graph algorithms. In _ICLR_. OpenReview.net, 2020.
* [31] Louis-Pascal A. C. Xhonneux, Andreea Deac, Petar Velickovic, and Jian Tang. How to transfer algorithmic reasoning knowledge to learn new algorithms? In _NeurIPS_, pages 19500-19512, 2021.

### NeurIPS Paper Checklist

1. **Claims** Question: Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope? Answer: [Yes] Justification: Our topic and contributions are present clearly in the abstract and introduction. Guidelines: * The answer NA means that the abstract and introduction do not include the claims made in the paper. * The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers. * The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings. * It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper.
2. **Limitations** Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] Justification: We have a discussion on the limitations in the experimental section. Guidelines: * The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper. * The authors are encouraged to create a separate "Limitations" section in their paper. * The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be. * The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated. * The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon. * The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size. * If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness. * While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren't acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations.
3. **Theory Assumptions and Proofs** Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? Answer: [NA]Justification: The contributions of the paper are experimental. Guidelines: * The answer NA means that the paper does not include theoretical results. * All the theorems, formulas, and proofs in the paper should be numbered and cross-referenced. * All assumptions should be clearly stated or referenced in the statement of any theorems. * The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition. * Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material. * Theorems and Lemmas that the proof relies upon should be properly referenced.
4. **Experimental Result Reproducibility** Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? Answer: [Yes] Justification: The experimental section gives all the details needed to reproduce our results. Guidelines: * The answer NA means that the paper does not include experiments. * If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not. * If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable. * Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed. * While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example 1. If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. 2. If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. 3. If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). 4. We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results.
5. **Open access to data and code** Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material?Answer: [Yes] Justification: We will make our open-source code and datasets publicly available to facilitate others in reproducing the results. Guidelines: * The answer NA means that paper does not include experiments requiring code. * Please see the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details. * While we encourage the release of code and data, we understand that this might not be possible, so "No" is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark). * The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details. * The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc. * The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why. * At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable). * Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
6. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: The experimental setup and relevant hyperparameters for reproducibility can be found in the experimental section. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material.
7. **Experiment Statistical Significance** Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? Answer: [Yes] Justification: Our table and figures provide the standard deviation. Guidelines: * The answer NA means that the paper does not include experiments. * The authors should answer "Yes" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. * The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions). * The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.) * The assumptions made should be given (e.g., Normally distributed errors).

* It should be clear whether the error bar is the standard deviation or the standard error of the mean.
* It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis of Normality of errors is not verified.
* For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).
* If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text.
8. **Experiments Compute Resources** Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? Answer: [Yes] Justification: In the experimental section of this paper, we have specified the model of the graphics card used in our experiments, and further discussed the duration of the model training. Guidelines: * The answer NA means that the paper does not include experiments. * The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage. * The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute. * The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn't make it into the paper).
9. **Code Of Ethics** Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? Answer: [Yes] Justification: The research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics. Guidelines: * The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics. * If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics. * The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction).
10. **Broader Impacts** Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? Answer: [NA] Justification: The paper is just a standard experimental study for a public benchmark. Guidelines: * The answer NA means that there is no societal impact of the work performed. * If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact. * Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.

* The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.
* The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.
* If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML).
11. **Safeguards** Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? Answer: [NA] Justification: The paper poses no such risks. Guidelines: * The answer NA means that the paper poses no such risks. * Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters. * Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images. * We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort.
12. **Licensees for existing assets** Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? Answer: [Yes] Justification: The data and model used in the paper are properly respected. Guidelines: * The answer NA means that the paper does not use existing assets. * The authors should cite the original paper that produced the code package or dataset. * The authors should state which version of the asset is used and, if possible, include a URL. * The name of the license (e.g., CC-BY 4.0) should be included for each asset. * For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided. * If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset. * For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.

* If this information is not available online, the authors are encouraged to reach out to the asset's creators.
* **New Assets*
* Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? Answer: [NA] Justification: The paper does not release new assets. Guidelines:
* The answer NA means that the paper does not release new assets.
* Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.
* The paper should discuss whether and how consent was obtained from people whose asset is used.
* At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file.
* **Crowdsourcing and Research with Human Subjects*
* Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? Answer: [NA] Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines:
* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.
* According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector.
* **Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects*
* Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? Answer: [NA] Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines:
* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.
* We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.
* For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review.