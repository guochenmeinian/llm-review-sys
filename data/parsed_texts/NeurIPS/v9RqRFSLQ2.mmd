# Learning from Uncertain Data: From Possible Worlds to Possible Models

Jiongli Zhu\({}^{1}\) Su Feng\({}^{2}\) Boris Glavic\({}^{3}\) Babak Salimi\({}^{1}\)

\({}^{1}\)University of California, San Diego \({}^{2}\)Nanjing Tech University \({}^{3}\)University of Illinois, Chicago

###### Abstract

We introduce an efficient method for learning linear models from uncertain data, where uncertainty is represented as a set of possible variations in the data, leading to predictive multiplicity. Our approach leverages abstract interpretation and zonotopes, a type of convex polytope, to compactly represent these dataset variations, enabling the symbolic execution of gradient descent on all possible worlds simultaneously. We develop techniques to ensure that this process converges to a fixed point and derive closed-form solutions for this fixed point. Our method provides sound over-approximations of all possible optimal models and viable prediction ranges. We demonstrate the effectiveness of our approach through theoretical and empirical analysis, highlighting its potential to reason about model and prediction uncertainty due to data quality issues in training data.

## 1 Introduction

This paper addresses the challenges of learning from uncertain datasets by employing the framework of _possible world semantics_, a well-established concept in AI and database theory [59, 23, 41, 28]. In this approach, uncertainty in a dataset \(\bm{D}\) is conceptualized through a collection of possible datasets \(\{\bm{D}_{1},\bm{D}_{2},\ldots\}\), each representing a potential state of the real world, reflecting variations due to missing entries, errors, inconsistencies, and biases. Given this framework and a learning algorithm, our objective is to construct a set of models \(\{f_{1},f_{2},\ldots\}\), where each model \(f_{i}\) is trained on a corresponding potential dataset \(\bm{D}_{i}\). This method, that we implement in a system called Zorro (_ZO_notope-based _R_obustness Analysis for _R_egression with _O_ver-approximations), allows for a thorough evaluation of how data uncertainties affect the robustness, reliability, and fairness of models in predictive modeling and statistical inference, particularly in scenarios where the ground truth is unidentifiable, necessitating consideration of all possible dataset variations.

While the framework of possible world semantics is essential for modeling dataset uncertainties, it poses significant challenges due to the potentially infinite number of scenarios each dataset might represent. Exploring every possibility and training a model for each is impractical. The concept of _model multiplicity_, which highlights situations where models with similar accuracy differ in individual predictions, has gained traction [7, 42], yet it primarily focuses on competing models without addressing the full range of dataset variations. Similarly, _dataset multiplicity_ introduced in [47] recognizes data variations due to uncertainty but [47] only proposed a solution for linear models with label errors. Our approach expands these ideas by using possible world semantics to systematically manage uncertainty across all features and labels, thus creating a comprehensive framework for evaluating model robustness amid data uncertainties.

To address the challenges of learning from uncertain datasets, we employ the method of _abstract interpretation_[13]. Utilizing zonotopes--a type of convex polytope well-suited for compactly representing high-dimensional data spaces [74, 4]--we over-approximate the set of all possible dataset variations. This framework allows for the simultaneous symbolic execution of gradient descentacross all possible datasets, compactly over-approximating all possible optimal model parameters as a zonotope. We demonstrate that for linear regression with \(\ell_{2}\) regularization (Ridge), our method admits a non-trivial closed-form solution. The zonotope representation of model parameters enables efficient inference, facilitating reasoning about the range of possible predictions or of specific parameters.

**Contributions.** The key contributions of this research are:

1. We introduce an abstract gradient descent algorithm for learning linear regression models from uncertain data. This method over-approximates data variations using zonotopes and symbolically executes gradient descent on all possible datasets concurrently. We define and prove the existence of a fixed point that soundly over-approximates all potential models.
2. Symbolic execution generates intractable polynomial zonotopes for gradients due to non-linear terms and monomial growth that is exponential in the number of iterations. We use linearization and order reduction to compactly over-approximate these polynomial zonotopes using linear zonotopes at each step, introducing an efficient version of abstract gradient descent.
3. The efficient version, however, does not guarantee a fixed point for arbitrary order reduction techniques. To address this, we develop advanced order reduction techniques that ensure fixed points and provide a non-trivial closed-form solution for these fixed points in ridge regression.
4. We implement our approach in a system called Zorro and use it to evaluate the impact of data uncertainty on linear regression models. Our empirical results and analytical solutions validate the effectiveness of our approach, demonstrating its efficacy in computing prediction ranges and verifying robustness.

Related Work.Predictive multiplicity has shown that a single dataset can produce multiple optimally fitted models due to variations in training processes [8, 11, 44, 66, 69, 9, 15, 71, 42] or modifications to training parameters such as random seeds, data ordering, and hyperparameters. For predictive multiplicity due to missing data, Khosravi et al.[34] address the issue using a probabilistic method that computes expected predictions for all possible imputations. Our approach can be seen as an extreme case of multiple imputation [62, 61], where we consider all possible data variations rather than just a few plausible scenarios. Meyer et al. [47] recently introduced the concept of dataset multiplicity, using possible world semantics to model how uncertain, biased, or noisy training data can lead to predictive multiplicity. However, their focus is on uncertainty in training labels, and they use interval arithmetic for over-approximation of prediction intervals for linear regression. In contrast, our approach handles arbitrary uncertainty in features and labels during both training and testing using zonotope-based learning for over-approximation of prediction ranges and model parameters. We show that interval arithmetic fails to provide tight prediction ranges even for uncertainty in labels.

Our work is broadly related to robust model learning, which ensures robustness against data quality issues such as attacks [31, 76, 70, 60, 55, 52, 29]. Distributional robustness [6, 53, 65] studies model reliability against varying data distributions, while robust statistics [19, 18] examines model performance under outliers or data errors. Our approach provides exact provable robustness guarantees by exploring the entire range of models under extreme dataset variations, which is crucial for individual-level predictions and reasoning about the robustness of specific parameters.

Our work is also related to robustness certification, which certifies ML models' robustness against data perturbations and uncertainties [27, 68, 50]. These efforts mainly focus on test-time robustness, validating predictions for inputs in the vicinity of a test sample. In contrast, we address training-time robustness, considering the effects of possible datasets on training models. Closest to our approach is the work by Meyer et al. [46] for decision trees and Karlas et al. [33] for nearest neighbor classifiers. We use zonotopes to over-approximate prediction ranges for linear regression, generating robustness certificates. While zonotopes have been used for test-time robustness [49, 20, 22, 51], our work is the first to apply zonotopes for training-time robustness for an iterative learning algorithm.

Approaches for uncertainty quantification (UQ) aim to understand the range of outcomes a model may produce using Bayesian methods, ensembling, conformal prediction, and bootstrapping [54, 43, 35, 17, 16]. UQ focuses on epistemic and aleatoric uncertainty, stemming from insufficient data, noisy data, or uncertainty about the model parameters, and does not account for uncertainty due to systematic data quality issues, such as non-random data errors or missing values [25], which induce a multiplicity of possible datasets. In this case, UQ methods might underestimate the uncertainty as they rely on critical assumptions. Bayesian methods, for instance, require correctly specified priors to accurately model uncertainty, often failing under conditions with unknown or erroneous priors [73; 67; 72], while conformal prediction (CP) assumes data exchangeability--a condition that breaks down when data errors are systematic [21; 75]. In contrast, our approach addresses this distinct challenge by computing sound over-approximations that guarantee complete coverage of potential predictions across all variations of the dataset. This sound coverage is essential in high-stakes settings such as evaluating the robustness of predictive models for medical use.

## 2 Notation, Problem Formulation and Background

Denote a training dataset \(\bm{D}=(\bm{X},\bm{y})\) with \(\bm{X}=\left[\bm{x}_{1}\quad\cdots\quad\bm{x}_{n}\right]^{T}\in\mathbb{R}^{n \times d}\) as the matrix of features, and \(\bm{y}=\left[y_{1}\quad\cdots\quad y_{n}\right]^{T}\in\mathbb{R}^{n}\) as the corresponding ground truth labels. Let \(f(\bm{x};\bm{w})\) be a model parameterized by \(\bm{w}\in\mathbb{R}^{p}\) that maps an input data point to a label. A learning algorithm \(\mathcal{A}\) maps a training dataset \(\bm{D}\) to the parameters of the trained model, \(\bm{w}^{*}=\mathcal{A}(\bm{D})\). Given a test dataset \(\mathbf{X}_{\text{test}}\in\mathbb{R}^{n\times d}\), for any test sample \(\bm{x}\) from \(\mathbf{X}_{\text{test}}\), the function \(f\) computes a prediction \(\hat{y}=f(\bm{x};\bm{w}^{*})\).

### Learning Possible Models from Possible Worlds

We use possible world semantics to represent the uncertainty in a dataset \(\bm{D}\).

**Definition 2.1** (Possible Datasets).: _Given an uncertain dataset \(\bm{D}\), the uncertainty in \(\bm{D}\) can be represented by a set of possible datasets \(\bm{D}^{\odot}\): \(\bm{D}^{\odot}=\{\bm{D}_{1},\bm{D}_{2},\ldots\}\)._

Each dataset \(\bm{D}_{i}\in\bm{D}^{\odot}\) is a "possible world", i.e., a hypothetical variation of the dataset \(\bm{D}\) that could potentially exist in the real world based on our knowledge about the uncertainty in \(\bm{D}\).

**Example 2.2**.: _Consider an e-commerce dataset \(\bm{D}\) where some product price is missing, meaning the exact price is unknown. Using possible world semantics, we represent this uncertainty with a set of possible datasets \(\bm{D}^{\odot}\), each containing a possible clean price, which could be obtained from prices of the same items on the market._

In App. D, we discuss construction methods for common data quality issues. Our goal is to efficiently construct the set of all possible models from uncertain data and understand their behavior in making predictions.

**Definition 2.3** (Possible Models and Prediction Range).: _Given a set of possible datasets \(\bm{D}^{\odot}\) associated with an uncertain dataset \(\bm{D}\), the possible models, denoted \(f^{\odot}\), are obtained by applying the learning algorithm \(\mathcal{A}\) to each training dataset \(\bm{D}_{i}\) within \(\bm{D}^{\odot}\) to obtain the set of all possible optimal model parameters \(\bm{w}^{\odot*}\), i.e.,_

\[\bm{w}^{\odot*}=\{\bm{w}^{*}_{i}\mid\bm{w}^{*}_{i}=\mathcal{A}(\bm{D}_{i}), \bm{D}_{i}\in\bm{D}^{\odot}\}\]

_For a test data point \(\bm{x}\), the viable prediction range \(V(\bm{x})\) is defined as the interval between the least upper bound and the greatest lower bound of the outputs produced by all models in \(f^{\odot}\), i.e.,_

\[V(\bm{x})=\left[\inf_{\bm{w}^{*}\in\bm{w}^{\odot*}}f(\bm{x},\bm{w}^{*}),\sup_ {\bm{w}^{*}\in\bm{w}^{\odot*}}f(\bm{x},\bm{w}^{*})\right]\]

This prediction range quantifies the minimum and maximum predictions that can be expected for \(\bm{x}\), highlighting the variability in model outputs due to differences in the training data. Our framework supports uncertainty in training and test data. We discuss test data uncertainty in App. F.3.

### Sound Approximation of Possible Models with Abstract Interpretation

The set of all possible datasets associated with uncertain data can be intractable. We use _abstract_ interpretation [12] to over-approximate sets of elements of a concrete domain \(\mathbb{D}\) (the training data and model weights) with elements from an abstract domain \(\mathbb{D}^{\sharp}\). Specifically, we use the abstract domain of zonotopes, a type of convex polytope, to over-approximate the possible datasets \(\bm{D}^{\odot}\) using a zonotope \(\bm{D}^{\sharp}\) that has a compact symbolic representation. Instead of applying the learning algorithm \(\mathcal{A}\) to each possible dataset to compute all possible optimal model parameters \(\bm{w}^{\odot*}\), we develop an abstract learning algorithm \(\mathcal{A}^{\sharp}\) that operates directly on the abstract domain of zonotopes. Given \(\bm{D}^{\sharp}\), \(\mathcal{A}^{\sharp}\) generates a zonotope \(\bm{w}^{\sharp}=\mathcal{A}^{\sharp}(\bm{D}^{\sharp})\) that over-approximates \(\bm{w}^{\odot*}\) (demonstrated in the graph on the right). Intuitively, this represents the symbolic execution of the learning algorithm across all possible datasets simultaneously.

**Definition 2.4** (Abstract Domain).: _Let \(\mathbb{D}\) be a concrete domain. An abstract domain for \(\mathbb{D}\) is a set \(\mathbb{D}^{\sharp}\) paired with two functions:_

\[\mathbf{Abstract}\ \alpha:\mathcal{P}(\mathbb{D})\to\mathbb{D}^{\sharp}\qquad \qquad\qquad\mathbf{Concretization}\ \gamma:\mathbb{D}^{\sharp}\to\mathcal{P}(\mathbb{D})\]

_which satisfy the following condition for any subset \(S\subseteq\mathbb{D}\): \(\gamma\left(\alpha(S)\right)\supseteq S\). Two abstract elements \(d_{1}\) and \(d_{2}\) are equivalent, written as \(d_{1}\simeq_{\sharp}d_{2}\), if \(\gamma\left(d_{1}\right)=\gamma\left(d_{2}\right)\)._

Def. 2.4 ensures that the abstract element \(\alpha(S)\) associated with a set \(S\) through application of the abstraction function \(\alpha\) encodes an over-approximation of \(S\). We will use an abstract element \(\mathbf{D}^{\sharp}=\alpha(\mathbf{D}^{\odot})\) to over-approximate the possible worlds of an uncertain training dataset \(\mathbf{D}^{\odot}\). We discuss abstraction functions \(\alpha\) for specific types of training data uncertainty in App. D.

**Definition 2.5** (Abstract Transformer).: _Consider a function \(F:\mathbb{D}_{1}\to\mathbb{D}_{2}\) on concrete domains \(\mathbb{D}_{1}\) and \(\mathbb{D}_{2}\). An abstract transformer \(F^{\sharp}:\mathbb{D}_{1}{}^{\sharp}\to\mathbb{D}_{2}{}^{\sharp}\) over-approximates \(F\) in the abstract domain:_

\[\forall S\in\mathcal{P}(\mathbb{D}):\gamma\left(F^{\sharp}(\alpha(S))\right) \supseteq F(S)\]

_An abstract transformer is exact (does not loose precision) if \(\forall d\in\mathbb{D}^{\sharp}:\gamma\left(F^{\sharp}(d)\right)=F(\gamma \left(d\right))\)._

Importantly, (exact) abstract transformers compose (see App. B.2, Prop. B.1) and, thus, we can construct an abstract transformer for complex functions from simpler parts.

To over-approximate the set of possible model parameters \(\bm{w}^{\odot*}\), we will develop an abstract transformer \(\mathcal{A}^{\sharp}\) for the learning algorithm \(\mathcal{A}\) to get \(\gamma\left(\mathcal{A}^{\sharp}(\mathbf{D}^{\sharp})\right)\supseteq\bm{w}^{ \odot*}\).

Symbolic Abstract Domains and Zonotopes.We consider a symbolic abstract domain \(\Psi\) of vectors and matrices (marked with \(\cdot^{\sharp}\)) with elements that are polynomials \(\psi\) over variables \(\mathcal{E}=\{\epsilon_{i}\}\). The concretization of a polynomial \(\psi\) is the result of evaluating \(\psi\) on all assignments \(e:\mathcal{E}\to[-1,1]\), encoded as vectors \([-1,1]^{|\,\mathcal{E}\,|}\): \(\gamma\left(\psi\right)=\{\psi(e)\mid e\in[-1,1]^{|\,\mathcal{E}\,|}\}\). We lift concretization to vectors and matrices through point-wise application. Such an object \(\bm{z}^{\sharp}\) is typically referred to as a _polynomial zonotope_ or _zonotope_ if all symbolic expressions are linear (see App. C.2). The concretization of \(\bm{z}^{\sharp}\) is: \(\gamma\left(\bm{z}^{\sharp}\right)=\left\{\bm{z}^{\sharp}(e)\mid e\in[-1,1]^{| \,\mathcal{E}\,|}\right\}\).

## 3 Exact Abstract Transformers for Learning Linear Models

Given an uncertain training dataset \(\mathbf{D}^{\odot}\), we aim to over-approximate the set of possible optimal linear models \(\bm{w}^{\odot*}=\{\bm{w}_{1}^{*},\bm{w}_{2}^{*},\ldots\}\), where \(\bm{w}_{i}^{*}\in\mathbb{R}^{p}\) represents the optimal parameters of a linear model trained on \(\mathbf{D}_{i}\in\mathbf{D}^{\odot}\). These optimal parameters are the fixed point of the sequence \(\{\bm{w}_{i}^{k}\}_{k=0}^{\infty}\) generated by: \(\bm{w}_{i}^{k+1}=\Phi(\bm{w}_{i}^{k})\) where the operator \(\Phi:\mathbb{R}^{p}\to\mathbb{R}^{p}\) captures one step of gradient descent, i.e., \(\Phi(\bm{w})=\bm{w}-\eta\nabla L(\bm{w})\), for a learning rate \(\eta\) and a loss function \(L(\bm{w})\)[57].

In the abstract domain, we use the zonotope representations \(\mathbf{D}^{\sharp}\) and \(\bm{w}^{\sharp}\) to abstract the possible datasets \(\mathbf{D}^{\odot}\) and the set of possible model weights \(\bm{w}^{\odot*}\). While it is theoretically possible to compute symbolic expressions for the standard closed form solution for linear regression, this can result in large expressions that contain fractions with polynomial numerators and denominators and, thus, computing prediction intervals based on such expressions is computationally infeasible (see App. L). Instead, we over-approximate the optimal parameters using an abstract operator \(\Phi_{exact}^{\sharp}:\bm{w}^{\sharp}\to\bm{w}^{\sharp}\) that generates a sequence of abstract elements \(\{\bm{w}^{\sharp}\,k\}_{k=0}^{\infty}\):

\[\bm{w}^{\sharp\,k+1}=\Phi_{exact}^{\sharp}(\bm{w}^{\sharp\,k}),\]

where the abstract operator \(\Phi_{exact}^{\sharp}\) given by \(\Phi_{exact}^{\sharp}(\bm{w}^{\sharp})=\bm{w}^{\sharp}-\eta\nabla L(\bm{w}^{ \sharp})\) captures one gradient descent step in the abstract domain. Specifically, for any loss function \(L\) whose gradient \(\nabla L\) consists of linear or polynomial expressions, such as the mean squared error (MSE) loss, \(\Phi_{exact}^{\sharp}\) is an exact abstract transformer. This follows from the existence of exact abstract transformers for addition and multiplication over polynomial zonotopes [37] and the fact that abstract transformers compose (see App. E, Prop. B.1 and Prop. E.1).

**Proposition 3.1**.: _The abstract gradient descent operator \(\Phi_{exact}^{\sharp}\) is an exact abstract transformer for the concrete gradient descent operator \(\Phi\). Formally, for any abstract \(\bm{w}^{\sharp}\),_

\[\gamma\left(\Phi_{exact}^{\sharp}(\bm{w}^{\sharp})\right)=\Phi(\gamma\left(\bm{ w}^{\sharp}\right)),\]

[MISSING_PAGE_FAIL:5]

[MISSING_PAGE_FAIL:6]

[MISSING_PAGE_FAIL:7]

the _robustness ratio_ which is the fraction of the test data receiving robust predictions as a metric in all robustness verification experiments. The robustness threshold is set to 5% of the label range for the _MPG_ data, and 0.8% of the label range for the _Insurance_ data. Additionally, we assess the _worst-case test loss_ using certain test data and uncertain model weights trained from uncertain training data.

### Robustness Verification

Prediction Robustness (Uncertain Labels).Fig. 1(a)(b) compares Zorro with the baseline Meyer[47] on a setting where only training labels suffer from uncertainty. We vary the uncertainty radius and uncertain data percentage. As both systems provide sound over-approximations of prediction ranges, they may underestimate a model's robustness. As shown, Zorro consistently certifies significantly higher robustness ratios than Meyer. This is due to the fact that Meyer uses interval-arithmetic which ignores the correlation between model weights in different dimensions and between the training labels and the weights, leading to overly conservative prediction ranges. Specifically, for higher uncertainty radius values, Meyer fails to certify robustness for most of the data while Zorro still can certify robustness for 100% of the instances.

Prediction Robustness (Uncertain Features).We also evaluate the impact of training feature uncertainty (not supported by Meyer). Specifically, we introduce uncertainty into the vehicle weight column for the MPG dataset. As shown in Fig. 1(c), uncertainty in the features results in relatively less robust predictions compared to uncertain labels for a similar uncertainty radius (Fig. 1(a)). This is primarily because uncertain features result in more high-order terms in the closed form solution than uncertain labels which in turn leads to larger over-approximation errors during linearization.

In all experiments the standard deviation of the robustness ratio, calculated by repeating experiments with different random seeds, is large when the average robustness ratio is close to 0.5. This is because when the uncertain data percentage is low, the model will be robust no matter which training instances are selected to be uncertain. Likewise, when the uncertain data percentage is high, then most predictions will be uncertain no matter which training data points are uncertain.

Parameter Robustness.Next, we apply Zorro for robustness certification of parameters in linear regression models, crucial for statistical estimation and causal analysis. We compare the ground truth coefficients for a treatment variable with the results obtained by Zorro and through KNN imputation on a dataset with injected missing data. Fig. 2 shows the treatment variable coefficient and

Figure 1: Robustness verification on using intervals (Meyer[47]) and zonotopes (Zorro).

the regression model's intercept. The intercept captures the baseline level of the outcome variable when all predictors are zero, highlighting how baseline values can shift under uncertainty. While the model trained after KNN imputation sometimes correctly identifies the directionality of the treatment effect, this is not always the case as shown in Fig. 2(b). This highlights the needs for techniques like Zorro which guarantee that the true treatment effect is within certain bounds.

### Solution Quality with Varying Uncertainty and Hyperparameters

We evaluate Zorro's effectiveness by testing the tightness of the over-approximation and the accuracy of possible models. Specifically, we examine how the over-approximation quality and worst-case loss are influenced by the level of data uncertainty and the regularization coefficient.

Varying Data Uncertainty.To evaluate how specific characteristics of the data affect the effectiveness of Zorro, we injected errors into real datasets, varying uncertain data percentage and uncertainty range. We compare Zorro with the ground truth range of the loss computed by enumerating all possible worlds (GT). The results shown in Fig. 3(a) demonstrate that Zorro tightly over-approximates the ground truth loss range, especially for smaller uncertainty radius values. As uncertainty increases, the over-approximation gap widens due to the increased coefficient of higher-order terms in the gradient, which are linearized, leading to higher linearization errors. As shown in Fig. 3(b), the tightness of Zorro's over-approximation is not affected by the dimension of the data.

Effect of Regularization.We investigate the impact of the regularization coefficient on the robustness of predictions and the worst-case loss of possible models. Following a similar approach to Sec. 5.1, we introduce uncertainty in both features and labels in the MPG dataset and use zonotopes with varying levels of uncertainty to over-approximate the training data uncertainty. The results, shown in Fig. 4, indicate that a higher regularization coefficient leads to more robust predictions, as regularization tends to "compress" all possible model weights towards the origin. Interestingly, the worst-case loss shows that \(\lambda=0\) is not optimal across all scenarios, especially when the fraction uncertain instances is high. Instead, a small, positive \(\lambda\) (e.g., 0.02 or 0.025) generally yields the best worst-case losses. Combining these results, the optimal regularization coefficient should enhance robustness (i.e., a higher robustness ratio) while maintaining an acceptable worst-case loss. Therefore, the regularization coefficient should be tuned based on a validation dataset to achieve a small range of accurate possible models.

## 6 Conclusions, limitations and broader impacts

We introduce an approach for propagating uncertainty through model training and inference for linear models. Given an abstract uncertain training dataset that over-approximates the possible worlds of a training dataset, we develop abstract interpretation techniques to over-approximate the set of possible models and inference results for this set of models using zonotopes. This is challenging, as we need to compute fixed points of gradient descent in the abstract domain. Our main technical

Figure 3: Range of the loss, through enumeration of all possible worlds (GT) and Zorro.

Figure 2: Applying Zorro to causal inference. The intercept (y-axis) is the model’s bias term, the treatment effect (x-axis) is the coefficient for the treatment variable.

contribution is the development of closed-form solutions for such fixed points that can be solved efficiently. Our techniques efficiently over-approximate models and inference for several use cases, including robustness verification, uncertainty management in causal reasoning, and improving the interpretability and reliability of predictions and inferences. This framework can be particularly valuable in critical applications where data quality and robustness are paramount. While we propose an effective method for abstract learning of linear models, extending our approach to more complex models is challenging. Non-linear models, such as neural networks, would require more advanced linearization and order reduction techniques, as well as parallelization, to manage the increased complexity of the involved symbolic operations. In addition, adapting our method to a broader classes of models through efficiently approximating the fixed points remains a challenging and promising future direction.

## 7 Acknowledgment

This research was supported by NSF awards IIS-2340124, IIS-2420691, and IIS-2420577, as well as by NIH grant U54HG012510. The views, opinions, and findings presented are those of the authors and do not necessarily represent those of the NSF or NIH.

## References

* [1] Amr Alanwar, Anne Koch, Frank Allgower, and Karl Henrik Johansson. Data-driven reachability analysis using matrix zonotopes. In _Learning for Dynamics and Control_, pages 163-175. PMLR, 2021.
* [2] Matthias Althoff. _Reachability analysis and its application to the safety assessment of autonomous cars_. PhD thesis, Technische Universitat Munchen, 2010.
* [3] Matthias Althoff. Reachability analysis of nonlinear systems using conservative polynomialization and non-convex sets. In _Proceedings of the 16th international conference on Hybrid systems: computation and control_, pages 173-182, 2013.
* [4] Matthias Althoff and Bruce H Krogh. Zonotope bundles for the efficient computation of reachable sets. In _2011 50th IEEE conference on decision and control and European control conference_, pages 6814-6821. IEEE, 2011.
* [5] Stanley Bak, Sergiy Bogomolov, Brandon Heneey, Niklas Kochdumper, Ethan Lew, and Kostiantyn Potomkin. Reachability of koopman linearized systems using random fourier feature observables and polynomial zonotope refinement. In _International Conference on Computer Aided Verification_, pages 490-510. Springer, 2022.
* [6] Aharon Ben-Tal, Dick den Hertog, Anja De Waegenaere, Bertrand Melenberg, and Gijs Rennen. Robust solutions of optimization problems affected by uncertain probabilities. _Advanced Risk & Portfolio Management(r) Research Paper Series_, 2011.
* [7] Emily Black, Manish Raghavan, and Solon Barocas. Model multiplicity: Opportunities, concerns, and solutions. In _Proceedings of the 2022 ACM Conference on Fairness, Accountability, and Transparency_, pages 850-863, 2022.
* [8] Xavier Bouthillier, Pierre Delaunay, Mirko Bronzi, Assya Trofimov, Brennan Nichyporuk, Justin Szeto, Nazanin Mohammadi Sepahvand, Edward Raff, Kanika Madan, Vikram Voleti, et al. Accounting for variance in machine learning benchmarks. _Proceedings of Machine Learning and Systems_, 3:747-769, 2021.
* [9] Leo Breiman. Heuristics of instability and stabilization in model selection. _The annals of statistics_, 24(6):2350-2383, 1996.

Figure 4: Varying regularization coefficient \(\lambda\): Robustness ratio (green) and worst-case test loss (red).

* [10] Christophe Combastel. Functional sets with typed symbols: Mixed zonotopes and polytopes for hybrid nonlinear reachability and filtering. _Automatica_, 143:110457, 2022.
* [11] A Feder Cooper, Yucheng Lu, Jessica Forde, and Christopher M De Sa. Hyperparameter optimization is deceiving us, and how to stop it. _Advances in Neural Information Processing Systems_, 34:3081-3095, 2021.
* [12] P. Cousot. Abstract interpretation. _CSUR_, 28(2):324-328, 1996.
* [13] Patrick Cousot and Radhia Cousot. Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. In _Proceedings of ACM SIGACT-SIGPLAN symposium on Principles of programming languages_, pages 238-252, 1977.
* [14] Patrick Cousot and Nicolas Halbwachs. Automatic discovery of linear restraints among variables of a program. In _Proceedings of the 5th ACM SIGACT-SIGPLAN symposium on Principles of programming languages_, pages 84-96, 1978.
* [15] Alexander D'Amour, Katherine Heller, Dan Moldovan, Ben Adlam, Babak Alipanahi, Alex Beutel, Christina Chen, Jonathan Deaton, Jacob Eisenstein, Matthew D Hoffman, et al. Underspecification presents challenges for credibility in modern machine learning. _Journal of Machine Learning Research_, 23(226):1-61, 2022.
* [16] Fabricio Olivetti de Franca and Gabriel Kronberger. Prediction intervals and confidence regions for symbolic regression models based on likelihood profiles, 2022.
* [17] Nicolas Dewolf, Bernard De Baets, and Willem Waegeman. Valid prediction intervals for regression problems. _Artificial Intelligence Review_, 56(1):577-613, April 2022.
* [18] Ilias Diakonikolas, Gautam Kamath, Daniel M. Kane, Jerry Li, Ankur Moitra, and Alistair Stewart. Robustness meets algorithms. _Commun. ACM_, 64(5):107-115, apr 2021.
* [19] Ilias Diakonikolas and Daniel M. Kane. Recent advances in algorithmic high-dimensional robust statistics. _CoRR_, abs/1911.05911, 2019.
* [20] Tianyu Du, Shouling Ji, Lujia Shen, Yao Zhang, Jinfeng Li, Jie Shi, Chengfang Fang, Jianwei Yin, Raheem Beyah, and Ting Wang. Cert-rnn: Towards certifying the robustness of recurrent neural networks. _CCS_, 21(2021):15-19, 2021.
* [21] Rina Foygel Barber, Emmanuel J Candes, Aaditya Ramdas, and Ryan J Tibshirani. The limits of distribution-free conditional predictive inference. _Information and Inference: A Journal of the IMA_, 10(2):455-482, 2021.
* [22] Timon Gehr, Matthew Mirman, Dana Drachsler-Cohen, Petar Tsankov, Swarat Chaudhuri, and Martin Vechev. Ai2: Safety and robustness certification of neural networks with abstract interpretation. In _2018 IEEE symposium on security and privacy (SP)_, pages 3-18. IEEE, 2018.
* [23] Matthew L Ginsberg. Counterfactuals. _Artificial intelligence_, 30(1):35-79, 1986.
* [24] Eric Goubault, Tristan Le Gall, and Sylvie Putot. An accurate join for zonotopes, preserving affine input/output relations. In Jan Midtgaard and Matthew Might, editors, _Proceedings of International Workshop on Numerical and Symbolic Abstract Domains_, volume 287, pages 65-76, 2012.
* A Statisticians' View. _arXiv_, 2023.
* [26] Arthur E. Hoerl and Robert W. Kennard. Ridge regression: Biased estimation for nonorthogonal problems. _Technometrics_, 42(1):80-86, 2000.
* [27] Chengqiang Huang, Zheng Hu, Xiaowei Huang, and Ke Pei. Statistical certification of acceptable robustness for neural networks. In _Artificial Neural Networks and Machine Learning_, pages 79-90. Springer, 2021.
* [28] Tomasz Imielinski and Witold Lipski Jr. Incomplete information in relational databases. _Journal of the ACM (JACM)_, 31(4):761-791, 1984.
* [29] Matthew Jagielski, Alina Oprea, Battista Biggio, Chang Liu, Cristina Nita-Rotaru, and Bo Li. Manipulating machine learning: Poisoning attacks and countermeasures for regression learning. In _2018 IEEE symposium on security and privacy (SP)_, pages 19-35. IEEE, 2018.
* [30] Arun Jangir and William Oliveira. Healthcare insurance, 2023. This dataset is licensed under CC0: Public Domain.

* [31] Jinyuan Jia, Xiaoyu Cao, and Neil Zhenqiang Gong. Intrinsic certified robustness of bagging against data poisoning attacks. In _Proceedings of the AAAI conference on artificial intelligence_, volume 35, pages 7961-7969, 2021.
* [32] Matt Jordan, Jonathan Hayase, Alex Dimakis, and Sewoong Oh. zonotope domains for lagrangian neural network verification. In _NIPS_, 2022.
* [33] Bojan Karlas, Peng Li, Renzhi Wu, Nezihe Merve Gurel, Xu Chu, Wentao Wu, and Ce Zhang. Nearest neighbor classifiers over incomplete information: From certain answers to certain predictions. _Proc. VLDB Endow._, 14(3):255-267, 2020.
* [34] Pasha Khosravi, Yitao Liang, YooJung Choi, and Guy Van den Broeck. What to Expect of Classifiers? Reasoning about Logistic Regression with Missing Features. _arXiv_, 2019.
* [35] Byol Kim, Chen Xu, and Rina Foygel Barber. Predictive inference is free with the jackknife+-after-bootstrap. In _International Conference on Neural Information Processing Systems_. Curran Associates Inc., 2020.
* [36] Niklas Kochdumper and Matthias Althoff. Sparse polynomial zonotopes: A novel set representation for reachability analysis. _IEEE Transactions on Automatic Control_, 66(9):4043-4058, 2020.
* [37] Niklas Kochdumper and Matthias Althoff. Constrained polynomial zonotopes. _Acta Informatica_, 60(3):279-316, 2023.
* [38] Anna-Kathrin Kopetzki, Bastian Schurmann, and Matthias Althoff. Methods for order reduction of zonotopes. In _2017 IEEE 56th Annual Conference on Decision and Control (CDC)_, pages 5626-5633. IEEE, 2017.
* [39] Adrian Kulmburg and Matthias Althoff. On the co-np-completeness of the zonotope containment problem. _Eur. J. Control_, 62:84-91, 2021.
* [40] Sungyoon Lee, Hoki Kim, and Jaewook Lee. Graddiv: Adversarial robustness of randomized neural networks via gradient diversity regularization. _IEEE Transactions on Pattern Analysis and Machine Intelligence_, 2022.
* [41] David Lewis. Counterfactuals and comparative possibility. In _IFS: Conditionally, Belief, Decision, Chance and Time_, pages 57-85. Springer, 1973.
* [42] Charles Marx, Flavio Calmon, and Berk Ustun. Predictive multiplicity in classification. In _International Conference on Machine Learning_, pages 6765-6774. PMLR, 2020.
* [43] Peter McCullagh, Vladimir Vovk, Ilia Nouretdinov, Dmitry Devetyarov, and Alex Gammerman. Conditional prediction intervals for linear regression. In _International Conference on Machine Learning and Applications_, pages 131-138, 2009.
* [44] Johannes Mehrer, Courtney J Spoerer, Nikolaus Kriegeskorte, and Tim C Kietzmann. Individual differences among deep neural network models. _Nature communications_, 11(1):5725, 2020.
* [45] Aaron Meurer, Christopher P Smith, Mateusz Paprocki, Ondrej Certik, Sergey B Kirpichev, Matthew Rocklin, AMiT Kumar, Sergiu Ivanov, Jason K Moore, Sartaj Singh, et al. Sympy: symbolic computing in python. _PeerJ Computer Science_, 3:e103, 2017.
* [46] Anna P. Meyer, Aws Albarghouthi, and Loris D'Antoni. Certifying data-bias robustness in linear regression. _CoRR_, abs/2206.03575, 2022.
* [47] Anna P Meyer, Aws Albarghouthi, and Loris D'Antoni. The dataset multiplicity problem: How unreliable data impacts predictions. In _Proceedings of the 2023 ACM Conference on Fairness, Accountability, and Transparency_, pages 193-204, 2023.
* [48] Antoine Mine. The octagon abstract domain. _Higher-order and symbolic computation_, 19:31-100, 2006.
* [49] Matthew Mirman, Timon Gehr, and Martin Vechev. Differentiable abstract interpretation for provably robust neural networks. In _International Conference on Machine Learning_, pages 3578-3586. PMLR, 2018.
* [50] Matthew Mirman, Alexander Hagele, Pavol Bielik, Timon Gehr, and Martin Vechev. Robustness certification with generative models. In _ACM SIGPLAN International Conference on Programming Language Design and Implementation_, pages 1141-1154, 2021.

* [51] Mark Niklas Muller, Marc Fischer, Robin Staab, and Martin Vechev. Abstract interpretation of fixpoint iterators with applications to neural networks. _Proceedings of the ACM on Programming Languages_, 7(PLDI):786-810, 2023.
* [52] Nicolas Muller, Daniel Kowatsch, and Konstantin Bottinger. Data poisoning attacks on regression learning and corresponding defenses. In _Pacific Rim International Symposium on Dependable Computing (PRDC)_, pages 80-89. IEEE, 2020.
* [53] Hongseok Namkoong and John C Duchi. Stochastic gradient methods for distributionally robust optimization with f-divergences. In D. Lee, M. Sugiyama, U. Luxburg, I. Guyon, and R. Garnett, editors, _Advances in Neural Information Processing Systems_, volume 29. Curran Associates, Inc., 2016.
* [54] David J. Olive. Prediction intervals for regression models. _Computational Statistics & Data Analysis_, 51(6):3115-3122, 2007.
* [55] Andrea Paudice, Luis Munoz-Gonzalez, and Emil C Lupu. Label sanitization against label flipping poisoning attacks. In _ECML PKDD Workshops_, pages 5-15. Springer, 2019.
* [56] Robert J Plemmons. M-matrix characterizations. i-nonsingular m-matrices. _Linear Algebra and its applications_, 18(2):175-188, 1977.
* [57] Boris T Polyak. Some methods of speeding up the convergence of iteration methods. _Ussr computational mathematics and mathematical physics_, 4(5):1-17, 1964.
* [58] R. Quinlan. Auto MPG. UCI Machine Learning Repository, 1993. DOI: https://doi.org/10.24432/C5859H. This dataset is licensed under a Creative Commons Attribution 4.0 International (CC BY 4.0) license.
* [59] Raymond Reiter. A theory of diagnosis from first principles. _Artificial intelligence_, 32(1):57-95, 1987.
* [60] Elan Rosenfeld, Ezra Winston, Pradeep Ravikumar, and Zico Kolter. Certified robustness to label-flipping attacks via randomized smoothing. In _International Conference on Machine Learning_, pages 8230-8241. PMLR, 2020.
* [61] Donald B Rubin. Multiple imputations in sample surveys-a phenomenological bayesian approach to nonresponse. In _Proceedings of the survey research methods section of the American Statistical Association_, volume 1, pages 20-34. American Statistical Association Alexandria, VA, USA, 1978.
* [62] Donald B Rubin. Multiple imputation after 18+ years. _Journal of the American statistical Association_, 91(434):473-489, 1996.
* [63] Anian Ruoss, Mislav Balunovic, Marc Fischer, and Martin Vechev. Learning certified individually fair representations. In _Advances in Neural Information Processing Systems_, pages 7584-7596, 2020.
* [64] Christian Schilling, Marcelo Forets, and Sebastian Guadalupe. Verification of neural-network control systems by integrating taylor models and zonotopes. In _Proceedings of the AAAI Conference on Artificial Intelligence_, volume 36, pages 8169-8177, 2022.
* [65] Soroosh Shafieezadeh-Abadeh, Peyman Mohajerin Esfahani, and Daniel Kuhn. Distributionally robust logistic regression. In _Neural Information Processing Systems_, 2015.
* [66] Ilia Shumailov, Zakhar Shumaylov, Dmitry Kazhdan, Yiren Zhao, Nicolas Papernot, Murat A Erdogdu, and Ross J Anderson. Manipulating sgd with data ordering attacks. _Advances in Neural Information Processing Systems_, 34:18021-18032, 2021.
* [67] Daniele Silvestro and Tobias Andermann. Prior choice affects ability of bayesian neural networks to identify unknowns. _arXiv preprint arXiv:2005.04987_, 2020.
* [68] Gagandeep Singh, Timon Gehr, Matthew Mirman, Markus Puschel, and Martin Vechev. Fast and effective robustness certification. _Advances in neural information processing systems_, 31, 2018.
* [69] Jasper Snoek, Hugo Larochelle, and Ryan P Adams. Practical bayesian optimization of machine learning algorithms. _Advances in neural information processing systems_, 25, 2012.
* [70] Jacob Steinhardt, Pang Wei Koh, and Percy Liang. Certified defenses for data poisoning attacks. In _NeurIPS_, 2017.
* [71] Damien Teney, Maxime Peyrard, and Ehsan Abbasnejad. Predicting is not understanding: Recognizing and addressing underspecification in machine learning. In _European Conference on Computer Vision_, pages 458-476. Springer, 2022.

* [72] Ba-Hien Tran, Simone Rossi, Dimitrios Milios, and Maurizio Filippone. All you need is a good functional prior for bayesian deep learning. _Journal of Machine Learning Research_, 23(74):1-56, 2022.
* [73] Rens van de Schoot, Sarah Depaoli, Ruth King, Bianca Kramer, Kaspar Martens, Mahlet G Tadesse, Marina Vannucci, Andrew Gelman, Duco Veen, Joukje Willemsen, et al. Bayesian statistics and modelling. _Nature Reviews Methods Primers_, 1(1):1, 2021.
* [74] Marianne Southall Winslett. _Reasoning about action using a possible models approach_. Number 1427-1432. Department of Computer Science, University of Illinois at Urbana-Champaign, 1988.
* [75] Margaux Zaffran, Aymeric Dieuleveut, Julie Josse, and Yaniv Romano. Conformal prediction with missing values. In _International Conference on Machine Learning_, pages 40578-40604. PMLR, 2023.
* [76] Xuezhou Zhang, Xiaojin Zhu, and Stephen Wright. Training set debugging using trusted items. In _AAAI_, 2018.

Linear Regression and Ridge Regression

In this section, we review standard loss functions for linear regression, specifically mean squared error (MSE) and the loss function used in ridge regression. can be trained via either the closed-form solution or gradient descent. Specifically, the closed-form solution requires computing the inversion of the covariance matrix, while the gradient descent only involves matrix addition and multiplication. Since the linear regression model is convex, gradient descent is guaranteed to converge to the global optimum.

Suppose we have a training data \(\bm{D}=(\bm{X},\bm{y})\) with \(n\) i.i.d. samples, where the feature matrix \(\bm{X}=\left[\bm{x}_{1}\quad\cdots\quad\bm{x}_{n}\right]^{T}\in\mathbb{R}^{n \times d}\), and the labels \(\bm{y}=\left[y_{1},\cdots,y_{n}\right]^{T}\in\mathbb{R}^{n}\). Given an input \(\bm{x}\) and the model weight \(\bm{w}\), the prediction of the linear regression model \(\hat{\bm{y}}=\bm{w}^{T}\bm{x}\) (the bias term can be integrated into \(\bm{w}\), corresponding to an added column in \(\bm{X}\) with constant 1's).

Loss FunctionsThe mean squared error (MSE) loss on \(\bm{D}\) is defined as shown below.

\[L(\bm{X},\bm{y},\bm{w})=\frac{1}{n}\sum_{i=1}^{n}{(y^{\prime}_{i}-y_{i})^{2}} =\frac{1}{n}\sum_{i=1}^{n}{(\bm{w}^{T}\bm{x_{i}}-y_{i})^{2}}=\frac{1}{n}(\bm {X}\bm{w}-\bm{y})^{T}(\bm{X}\bm{w}-\bm{y}).\] (4)

In practice, regularization terms, e.g., based on the \(l_{p}\)-norm of the model parameters, are often added to the original MSE loss to prevent overfitting by penalizing large weights. Using \(l_{2}\)-regularization with a regularization coefficient \(\lambda\) which determines the strength of regularization is often called _ridge regression_. The loss function for ridge regression is:

\[L(\bm{X},\bm{y},\bm{w})=\frac{1}{n}(\bm{X}\bm{w}-\bm{y})^{T}(\bm{X}\bm{w}-\bm {y})+\lambda\cdot\bm{w}^{T}\bm{w}.\] (5)

Gradient Descent for Linear RegressionDue to the convexity of linear models, the locally optimal point, which can be obtained by gradient descent with an appropriate learning rate \(\eta\), is globally optimal. In gradient descent, the model weights \(\bm{w}\) are iteratively updated (with some learning rate \(\eta\)) towards the reverse direction of the gradient \(\frac{\partial L(\bm{X},\bm{y},\bm{w})}{\partial\bm{w}}\). Thus, for ridge regression:

\[\frac{\partial L(\bm{X},\bm{y},\bm{w})}{\partial\bm{w}}=\frac{2}{n}(\bm{X}^{T} \bm{X}\bm{w}-\bm{X}^{T}\bm{y})+2\lambda\bm{w}.\] (6)

Thus, one step of gradient descent \(\Phi\) is:

\[\bm{w}^{i+1}=\bm{w}^{i}-\eta\frac{2}{n}(\bm{X}^{T}\bm{X}\bm{w}-\bm{X}^{T}\bm{ y})+2\lambda\bm{w}\] (7)

Closed-form Solution for Linear RegressionThe convex nature of linear models ensures that the optimal weight \(\bm{w}=\bm{w}^{*}\), which minimizes the loss \(L(\bm{X},\bm{y},\bm{w})\), can be computed by establishing \(\frac{\partial L(\bm{X},\bm{y},\bm{w})}{\partial\bm{w}}=0\):

\[\begin{split}\frac{\partial L(\bm{X},\bm{y},\bm{w}^{*})}{\partial \bm{w}^{*}}&=\frac{2}{n}(\bm{X}^{T}\bm{X}\bm{w}^{*}-\bm{X}^{T}\bm{ y})+2\lambda\bm{w}^{*}=0\\ \Rightarrow\quad\quad\quad\quad\quad\bm{X}^{T}\bm{y}& =(\bm{X}^{T}\bm{X}+\lambda nI)\bm{w}^{*}\\ \Rightarrow\quad\quad\quad\quad\quad\bm{w}^{*}&=( \bm{X}^{T}\bm{X}+\lambda nI)^{-1}\bm{X}^{T}\bm{y}\end{split}\] (8)

## Appendix B Background on Abstract Interpretation

Abstract interpretation [13] is a technique for over-approximating the results of computations over a set of inputs. This is achieved by associating sets of elements of a concrete domain \(\mathbb{D}\) with elements from an abstract domain \(\mathbb{D}^{\sharp}\). In this context, various abstract domains are employed: interval domains represent variables as ranges of possible values [13], octagon domains allow for constraints between pairs of variables within a specific bound [48], and polynomial zonotopes which represent convex polytopes using polynomial constraints [14]. Abstract interpretation, while originally designed for static program analysis such as strictness analysis, has also found applications in wide range of other domains including reachability analysis [1, 5, 2, 10, 36, 4], robustness verification for neural networks [32, 64], learning robust models by providing bounds on the loss for a set of inputs [51, 63, 49, 22], and many others.

We now state some important, but well-known, facts about abstract transformers that we utilize in our derivations.

### Abstract Transformers

In Def. 2.5, we presented the standard definition of abstract transformers as functions over abstract domains that over-approximate the application of functions in the concrete domains to sets of elements. To clarify the connection between abstract transformers and possible world semantics observe that both take a concrete function \(F:\mathbb{D}\rightarrow\mathbb{D}^{\prime}\) and lift it to sets of inputs \(S\in\mathcal{P}(\mathbb{D})\) through point-wise applications:

\[F(S)=\{F(e)\mid e\in S\}\]

Thus, abstract interpretation is a natural fit for over-approximating PWS by over-approximating sets of possible worlds using abstract elements and then over-approximates computations with PWS for a function \(F\) using abstract transformers for such a function.

### Abstract Transformers Compose

Importantly, abstract transformers compose. This enables us to decompose a complex computation into simpler operations and build an abstract transformer for the computation by composing abstract transformations for these simpler operations.

**Proposition B.1** (Abstract Transformers Compose).: _Consider (exact) abstract transformers \(f^{\sharp}\) and \(g^{\sharp}\) for functions \(f\) and \(g\), then \(g^{\sharp}\circ f^{\sharp}\) is an (exact) abstract transformer for \(g\circ f\)._

## Appendix C Symbolic and Standard Representation of Zonotopes

We now provide a more detailed account of the correspondence between the symbolic and standard geometric representation of zonotopes and polynomial zonotopes and discuss why matrices and sets of symbolic matrices as used in our abstract domain can equivalently be thought of as (polynomial) zonotopes.

### Symbolic vs. Geometric Representation

We defined zonotopes \(\bm{z}^{\sharp}\) as vectors \(\Psi^{d}\) where \(\Psi\) denotes polynomials over variables (called error symbols) \(\mathcal{E}\). The concretization of such a symbolic representation of a zonotope is the set of vectors in \(\mathbb{R}^{d}\) that can be derived from \(\bm{z}^{\sharp}\) by assigning values from \([-1,1]\) to each variable \(\epsilon\in\mathcal{E}\). We encode such variable assignments as vectors \([-1,1]^{\,|\,\mathcal{E}\,|}\).

**Definition C.1** (Polynomial zonotopes - Symbolic Representation).: _A \(d\)-dimensional polynomial zonotope is a vector \(\bm{z}^{\sharp}\in\Psi^{d}\)[10]. Let \(m=|\,\mathcal{E}\,|\). The concretization of \(\bm{z}^{\sharp}\) is defined as:_

\[\gamma\left(\bm{z}^{\sharp}\right)=\left\{\bm{z}^{\sharp}(e)\mid e\in[-1,1]^{ \,|\,\mathcal{E}\,|}\right\}\]

A common measure of the representation size of a zonotope is its order. The order of a \(d\)-dimensional (polynomial) \(\bm{z}^{\sharp}\) in symbolic representation is the total number of distinct monomials in \(\bm{z}^{\sharp}\) divided by \(d\):

\[\textsc{ord}(\bm{z}^{\sharp})=\frac{\#\mathcal{M}(\bm{z}^{\sharp})}{d}\]

where \(\#\mathcal{M}(\psi)\) denotes the cardinality of the set of distinct monomials in polynomial \(\psi\).

A more common way to represent \(d\)-dimensional zonotopes is by fixing a set \(\mathcal{S}\) of monomials over \(\mathcal{E}\) and writing the zonotope as a central point \(\bm{c}\in\mathbb{R}^{d}\) and a sum of generator vectors \(\bm{g_{i}}\in\mathbb{R}^{d}\) multiplied with the monomials from \(\mathcal{S}\). The generator vector \(\bm{g_{i}}\) assigns a coefficient to monomial \(\mathcal{S}[i]\) for each of the \(d\) dimensions.

**Definition C.2** (Polynomial zonotopes - Geometric Representation).: _The geometric representation of a \(d\)-dimensional polynomial zonotope is a sum of a center point \(\bm{c}\in\mathbb{R}^{d}\) and the monomials over error symbols in \(\mathcal{E}\) from a set \(\mathcal{S}\) multiplied by coefficients encoded in set of generator vectors \(\bm{g}_{i}\in\mathbb{R}^{d}\):_

\[\bm{z}^{\sharp}=\bm{c}+\sum_{i=1}^{|\mathcal{S}|}\bm{g}_{i}\mathcal{S}[i]\]

For the geometric representation, the order of a \(d\)-dimensional (polynomial) \(\bm{z}^{\sharp}\) over monomials \(\mathcal{S}\) is defined as:

\[\text{ord}(\bm{z}^{\sharp})=\frac{|\mathcal{S}|}{d}\]

Note that the order of the symbolic and geometric representation of a zonotope are the same. As an example consider the 4-dimensional polynomial zonotope \(\bm{z}^{\sharp}\) shown in symbolic representation (left) and standard representation (right).

### Symbolic Matrices and Sets of Symbolic Matrices

We use matrices over symbolic expressions and sets of heterogeneous abstract matrices to represent the state of a computation and allow matrices from such a set to share variables to encode relationships between the elements of such matrices. The semantics we associate with such a set is that of a _joint concretization_. For \(S^{\sharp}=\{\bm{M}_{i}{}^{\sharp}\}\), we define:

\[\gamma\left(S^{\sharp}\right)=\{\bm{M}_{i}{}^{\sharp}(e)\mid\bm{M}_{i}{}^{ \sharp}\in S^{\sharp}\wedge e\in[-1,1]^{n}\}\]

zonotopes encode convex sets of points in \(\mathbb{R}^{d}\). We can think of a symbolic matrix \(M^{\sharp}\in\Psi^{n\times m}\) as a \(n\cdot m\)-dimensional polynomial zonotope. Similarly, a set of symbolic matrices \(S^{\sharp}=\{\bm{M}_{i}{}^{\sharp}\in\mathbb{R}^{n_{i}\times m_{i}}\}\) can be thought of as a \(l\)-dimensional polynomial zonotope \(\mathbb{R}^{l}\) where \(l=\sum_{i}n_{i}\cdot m_{i}\). If every symbolic expression in a matrix or set of matrices is a linear combination of error symbols (an affine form), then such objects can equivalently be represented as zonotopes.

For instance, below on the left we show a zonotope matrix \(\bm{W}^{\sharp}\) (all expressions are linear) and two possible worlds in its concretization (for assignments \([-1,-1]\) and \([0,0.5]\)).

### Abstract Training Data and Model Weights

Using possible world semantics to compute all possible model weights \(\bm{w}^{\odot*}\) given a set of possible training datasets \(\bm{D}^{\odot}\), there will be a natural correspondence between a model weight \(\bm{w}\in\bm{w}^{\odot*}\) and the dataset \(\bm{D}\in\bm{D}^{\odot}\) from which is was derived. When training in the abstract domain such correlations can be preserved by sharing error symbols between the abstract training data \(\bm{\mathrm{D}}^{\sharp}\) and corresponding model weights \(\bm{w}^{\sharp}\). When such sharing occurs, then it is critical to reason about the joint concretization when determining whether an abstract fixed point as been achieved. Testing equivalence (equal concretization) of \(\bm{w}^{\sharp}\) alone can lead to false positives, as \(\bm{w}^{\sharp}{}_{1}\simeq_{\sharp}\bm{w}^{\sharp}{}_{2}\) does not in general imply \((\mathbf{D}^{\sharp},\bm{w}^{\sharp}{}_{1})\simeq_{\sharp}(\mathbf{D}^{\sharp},\bm{w}^{\sharp}{}_{2})\). This is due to the fact that a particular concrete model weight \(\bm{w}\in\gamma\left(\bm{w}^{\sharp}{}_{1}\right)=\gamma\left(\bm{w}^{\sharp} {}_{2}\right)\) may be associated with different datasets in \((\mathbf{D}^{\sharp},\bm{w}^{\sharp}{}_{1})\) and \(\mathbf{D}^{\sharp},\bm{w}^{\sharp}{}_{2})\) because of shared error symbols between \(\mathbf{D}^{\sharp}\) and the abstract model weights. Thus,concretization equivalence between model weights only does not imply equivalent results after application of a gradient decent step.

To further illustrate this consider, two pairs of abstract model weights \(\bm{w}^{\sharp}_{1}\) and \(\bm{w}^{\sharp}_{2}\).

\[\left(\bm{w}^{\sharp}_{1}=\begin{bmatrix}2+2\epsilon_{1}\\ 3+\epsilon_{2}\end{bmatrix},\bm{D}^{\sharp}=\begin{bmatrix}\epsilon_{1}\\ 5\end{bmatrix}\right)\] \[\left(\bm{w}^{\sharp}_{2}=\begin{bmatrix}2+2\epsilon_{3}\\ 3+\epsilon_{2}\end{bmatrix},\bm{D}^{\sharp}=\begin{bmatrix}\epsilon_{1}\\ 5\end{bmatrix}\right)\]

The only difference between \(\bm{w}^{\sharp}_{1}\) and \(\bm{w}^{\sharp}_{2}\) is that \(\bm{w}^{\sharp}_{1}\) shares a variable (\(\epsilon_{1}\)) with \(\bm{D}^{\sharp}\) while \(\bm{w}^{\sharp}_{2}\) does not. Observe that \(\gamma\left(\bm{w}^{\sharp}_{1}\right)=\gamma\left(\bm{w}^{\sharp}_{2}\right)\). However, applying a step of gradient decent to \(\bm{w}^{\sharp}_{1}\) and \(\bm{w}^{\sharp}_{2}\) may lead to abstract models that are not equivalent. For sake of this example, consider a hypothetical gradient operator \(\Phi^{\sharp}_{dummy}\) that subtracts the data from the current model weight.

\[\left(\Phi^{\sharp}_{dummy}(\bm{w}^{\sharp}_{1})=\begin{bmatrix}2+\epsilon_{ 1}\\ -2+\epsilon_{2}\end{bmatrix},\bm{D}^{\sharp}=\begin{bmatrix}\epsilon_{1}\\ 5\end{bmatrix}\right)\]

Note that \(\Phi^{\sharp}_{dummy}(\bm{w}^{\sharp}_{1})\not\simeq_{\sharp}\Phi^{\sharp}_{ dummy}(\bm{w}^{\sharp}_{2})\). Thus, even if two abstract model weights have equal concretization this does not guarantee that a fixed point has been reached when also taking the data into account. This is important as otherwise it is not possible that the abstract model weights contain all possible optimal model weights \(\bm{w}^{\odot*}\). Instead, we need to consider the _joint concretization_ of model weight and data, s.t. if \(\gamma\left(S^{\sharp}_{1}\right)=\gamma\left(S^{\sharp}_{2}\right)\) then concretization equivalence is guaranteed to hold for all subsequent iterations.

## Appendix D Examples Of Training Data Uncertainty and Abstraction

In this section, we discuss several causes of training (and test) data uncertainty, how to encode them as possible worlds, and abstraction functions for approximating such uncertainty in our symbolic model.

### Measurement Uncertainty

Sensors typically have some measurement uncertainty. If the measurement error \(\epsilon\) is know, e.g., provided by the instrument manufacturer or estimated through repeated measurements and calibration, then for a set of sensor readings used in training \(\bm{D}=\{(\bm{x}_{i},y_{i})\}\), then each possible world in \(\bm{D}^{\odot}\) is derived from \(\bm{D}\) by replacing values \(\bm{x}_{i}[j]\) with values in \(\bm{x}_{i}[j]\pm\epsilon\).

### Missing Values and Imputation

Consider a training dataset \(\bm{D}\) where some of the features are missing for some of the datapoints in \(\bm{D}\). If each feature \(\mathcal{X}_{i}\)'s domain is an interval \([l_{i},u_{i}]\) and assuming that missing values can be represented as independent random variables, then the set of possible worlds of the training data \(\bm{D}^{\odot}\) are all training datasets that can be derived from \(\bm{D}\) by replacing each missing value in a feature \(\mathcal{X}_{i}\) with a value from \([l_{i},u_{i}]\).

We can use an abstraction function \(\alpha_{missing}\) that represents each missing value as an interval \([l_{i},u_{i}]\). In the symbolic representation, this is encoded as the central point of the interval of an error symbol \(\epsilon\) with a coefficient half of the interval's length. We associate a separate error symbol with each missing value. For \(\bm{D}\in\mathbb{R}^{n\times m}\), we define \(\alpha_{missing}\) for \(i\in[1,n]\) and \(j\in[1,m]\) as:

\[\alpha_{missing}(\bm{D}_{ij})=\begin{cases}\frac{u_{j}+l_{j}}{2}+\frac{u_{i}-l _{i}}{2}\epsilon_{i,j}&\text{if }\bm{D}_{ij}=\bot\\ \bm{D}_{ij}&\text{otherwise}\end{cases}\]For instance, consider the training dataset \(\bm{D}\in\mathbb{R}^{3\times 2}\) shown below where \(\bot\) denotes a missing value.

\[\bm{D}=\begin{pmatrix}3&\bot\\ 1&6\\ \bot&9\end{pmatrix}\]

Assuming that both features have a domain \([0,10]\), we get:

\[\alpha_{missing}(\bm{D})=\begin{pmatrix}3&5+5\epsilon_{1,2}\\ 1&6\\ 5+5\epsilon_{3,1}&9\end{pmatrix}\]

If the independence assumption on missing values holds, then \(\gamma\left(\alpha_{missing}(\bm{D})\right)=\bm{D}^{\odot}\). If the independence assumption does not hold, then \(\bm{D}^{\odot}\) would be a subset of the worlds described above and \(\alpha_{missing}(\bm{D})\) is a still a valid abstraction function, albeit an over-approximating one:

\[\gamma\left(\alpha_{missing}(\bm{D})\right)\supseteq\bm{D}^{\odot}\]

ImputationIf we make the stronger assumption the unknown ground truth value corresponding to a missing value is in a set of estimations \(\{a_{1},\ldots,a_{m}\}\) returned by a set of imputation methods, then we can use \([min(\{a_{i}\}),max(\{a_{i}\})]\) instead of \([l_{i},u_{i}]\).

Training Label UncertaintyThe abstract transformer \(\alpha_{missing}\) can also be used if training data labels are missing.

## Appendix E Abstract Transformers for Zonotopes

In this section we introduce (exact) abstract transformers for (polynomial) zonotopes that have been introduced in related work and discuss their computation complexity and the space requirements for the output zonotope \(\bm{z}^{\sharp}\) in terms of its order \(\textsc{ord}(\bm{z}^{\sharp})\) (see Sec. 2.2). Kochdumper et al. [37, Table 1] shows an overview of which operations are exact for linear and polynomial zonotopes (and other set representations). Relevant to for our purpose is that exact transformers exist for polynomial zonotopes for all operations used in the learning algorithms for linear models we consider.

**Proposition E.1** (Exact Transformers for Polynomial Zonotopes).: _There exist exact abstract transformers for scalar addition and multiplication as well as for matrix addition and multiplication for polynomial zonotopes [3]. There exist exact transformers for scalar addition and matrix addition for zonotopes. Abstract transformers for multiplication and matrix multiplication for zonotopes exist, but are not exact._

We present the details of these operations in the following.

### Arithmetic Operations

Addition.Scalar and matrix addition are exact in both zonotopes and polynomial zonotopes. Given two matrix (polynomial) zonotopes \(\bm{V}^{\sharp}\) and \(\bm{W}^{\sharp}\) in \(\Psi^{n\times m}\), their addition \(\bm{Z}^{\sharp}=\bm{V}^{\sharp}+\bm{W}^{\sharp}\) is defined by adding entries. For each \(i\in[1,n]\) and \(j\in[1,m]\):

\[\bm{Z}^{\sharp}{}_{ij}=\bm{V}^{\sharp}{}_{ij}+\bm{W}^{\sharp}{}_{ij}\]

The order of \(\bm{Z}^{\sharp}\) is the sum of the orders of \(\bm{V}^{\sharp}\) and \(\bm{W}^{\sharp}\):

\[\textsc{ord}(\bm{Z}^{\sharp})=\textsc{ord}(\bm{V}^{\sharp})+\textsc{ord}(\bm{ W}^{\sharp})\]

Scalar multiplication.Multiplying a (polynomial) zonotope matrix \(\bm{W}^{\sharp}\) with a scalar \(c\) is exact using the abstract transformer \(\cdot_{poly}\) defined below. We simply multiply each entry in the matrix by \(c\).For each \(i\in[1,n]\) and \(j\in[1,m]\):

\[(c\cdot_{poly}\bm{W}^{\sharp})_{ij}=c\cdot\bm{W}^{\sharp}{}_{ij}\]Multiplication with a scalar abstract value \(d\in\Psi\) is exact for polynomial zonotope matrices, but increases the order of the input zonotope:

\[\textsc{ord}(d\cdot\bm{W})=\textsc{ord}(d)\cdot\textsc{ord}(\bm{W})\]

Here we define the order of a scalar abstract value \(d\in\Psi\) to be the number of monomials in the representation of \(d\). For a linear zonotope \(\bm{W}\), \(d\cdot\bm{W}^{\sharp}_{ij}\) is in general not linear as it contains higher-order terms. Thus, matrix multiplication for linear zonotopes requires application of linearization (see App. G):

\[d\cdot_{Lin}\bm{W}=\mathbf{L}(d\cdot_{poly}\bm{W})\]

Matrix multiplication.Matrix multiplication is defined using scalar multiplication and addition. As discussed above, addition is exact for both linear and polynomial zonotopes. However, scalar multiplication of symbolic expressions is only exact for polynomial zonotopes, but requires linearization and, thus, over-approximation, for linear zonotopes. That is, matrix multiplication is exact for polynomial zonotopes only. Consider two matrices \(\bm{V}^{\sharp}\in\Psi^{n\times m}\) and \(\bm{V}^{\sharp}\in\Psi^{m\times k}\), then matrix multiplication is defined as usual, but using abstract transformers for scalar addition and multiplication. Each symbolic entry in the matrix \(\bm{V}^{\sharp}\cdot\bm{W}^{\sharp}\) is a sum of \(m\) elements, each the multiplication of one entry of \(\bm{V}^{\sharp}\) with one entry of \(\bm{W}^{\sharp}\). Thus,

\[\textsc{ord}(\bm{V}^{\sharp}\cdot\bm{W}^{\sharp})=m\cdot\textsc{ord}(\bm{V}^{ \sharp})\cdot\textsc{ord}(\bm{W}^{\sharp})\]

For linear zonotopes, we have to again apply linearization to make sure that the output is a linear zonotope.

## Appendix F Abstract Transformers for Gradient Descent

### Abstract Fixed Points Over-Approximate Possible Fixed Points

Proof of Prop. 3.3.: Initially, we will assume that \(\bm{w}^{\sharp\,j}\) is computed through repeated application of \(F^{\sharp}\). Let \(n\) be the smallest number such that \(\bm{w}^{\sharp\,*}=\bm{w}^{\sharp\,*}=F^{\sharp}(\bm{w}^{\sharp\,*}n^{-1}, \mathbf{D}^{\sharp})\) for iteration with abstract transformer \(F^{\sharp}\). As \(F^{\sharp}\) is an abstract transformer for \(\Phi\) and abstract transformers compose (Prop. B.1), we know that for every \(\bm{D}_{i}\in\bm{D}^{\odot}\) and \(n\in\mathbb{N}\), we have \((\bm{w}^{n}_{i},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*}n,\mathbf{D}^{ \sharp}\right)\). To prove the claim it is sufficient to show that for every such \(\bm{D}_{i}\) we have \((\bm{w}^{*}_{i},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*}n,\mathbf{D}^{ \sharp}\right)\). WLOG consider some \(\bm{D}_{i}\in\bm{D}^{\odot}\) and \((\bm{w}^{n}_{i},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*}n,\mathbf{D}^{ \sharp}\right)\). Let \(m\in\mathbb{N}\) be the smallest number such that \(\bm{w}^{*}_{i}=\bm{w}^{m}_{j}\). If \(m\leq n\), then based on the fact that \(F^{\sharp}\) is an abstract transformer (over-approximates \(\Phi\)), the result holds as \((\bm{w}^{n}_{i},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*}n,\mathbf{D}^{ \sharp}\right)\). Now consider the case where \(m>n\). We will show through induction that for all \(j\in[n+1,m]\), \((\bm{w}^{j}_{i},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*}n,\mathbf{D}^{ \sharp}\right)\) and, thus \((\bm{w}^{*}_{i},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*}n,\mathbf{D}^{ \sharp}\right)\).

_Induction start._ For \(j=n\) the result trivially holds based on the definition of abstract fixed points.

_Induction step._ Assume that \((\bm{w}^{j}_{i},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*}n,\mathbf{D}^{ \sharp}\right)\) for \(j\in[n,m-1]\), we have to show that this implies that \((\bm{w}^{j+1}_{i},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*}n,\mathbf{D}^{ \sharp}\right)\). By definition, we have

\[\bm{w}^{j+1}_{i}=\Phi(\bm{w}^{j}_{i})\]

As \(F^{\sharp}\) is an abstract transformer for \(\Phi\), we have, \((\bm{w}^{j+1}_{i},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*}n+1,\mathbf{D}^{ \sharp}\right)\). Now based on the fact that \(\bm{w}^{\sharp\,*}\) is an abstract fixed point according to Def. 3.2 and, thus, \(\gamma\left(\bm{w}^{\sharp\,*}n,\mathbf{D}^{\sharp}\right)\supseteq\gamma\left( \bm{w}^{\sharp\,*}n+1,\mathbf{D}^{\sharp}\right)\), it follows that \((\bm{w}^{j+1}_{i},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*}n,\mathbf{D}^{ \sharp}\right)\).

So far we have demonstrated that a fixed point \(\bm{w}^{\sharp\,*}\) that appears in the iteration sequence \(\{\bm{w}^{\sharp\,j}\}_{j=0}^{\infty}\) contains all optimal model weights \(\bm{w}^{\odot*}\). We now prove the stronger result that as long as \(\bm{w}^{\sharp\,*}\) fulfills the condition of Def. 3.2, no matter it is the result of an iteration sequence using \(F^{\sharp}\) or not, its concretization encloses \(\bm{w}^{\odot*}\). Consider one \(\bm{D}_{i}\in\gamma\left(\mathbf{D}^{\sharp}\right)\) and as above let \(\bm{w}^{*}_{i}\) denote its optimal model weight. We will demonstrate that \((\bm{w}^{*}_{i},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*},\mathbf{D}^{ \sharp}\right)\). First note that given that gradient descent for linear models is convex, for any initial model weight \(\bm{w}^{0}_{i}\), the sequence \(\{\bm{w}^{j}_{i}\}_{j=0}^{\infty}\) converges to \(\bm{w}^{*}_{i}\). Specifically, let \(\bm{w}\) denote the model weight such that \((\bm{w},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*},\mathbf{D}^{\sharp}\right)\)and let \(n_{i}\) denote the smallest integer such that \(\bm{w}_{i}^{n_{i}}=\bm{w}_{i}^{*}\) for the sequence generated starting from \(\bm{w}_{i}^{0}=\bm{w}\). However, now we can apply the same proof by induction shown above to demonstrate that \((\bm{w}_{i}^{n_{i}},\bm{D}_{i})\in\gamma\left(\bm{w}^{\sharp\,*},\bm{D}^{\sharp}\right)\). This concludes the proof. 

### Exact Abstract Transformer for Gradient Descent

In this section we show that the abstract transformer for gradient descent introduced in sec. 3 has a fixed point.

**Proposition F.1**.: _The abstract gradient descent operator \(\Phi^{\sharp}\) has a fixed point \(\bm{w}^{\sharp\,*}\)._

Proof of Prop. F.1.: The existence of a fixed point is implied by the fact that \(\Phi^{\sharp}\) is an exact abstract transformer of the concrete gradient descent operator \(\Phi\). Consider \(\gamma\left(\bm{w}^{\sharp\,0},\bm{D}^{\sharp}\right)=\{(\bm{w}_{i}^{0},\bm{D}_ {i})\}\). Let \(n_{i}\) be the smallest integer such that \(\bm{w}_{i}^{n_{i}}=\bm{w}_{i}^{*}\) and let \(n=\max_{i}n_{i}\), i.e., at iteration \(n\), the concrete model weights have converged in every possible world in the concretization of \((\bm{w}^{\sharp\,0},\bm{D}^{\sharp})\). As \(\Phi^{\sharp}\) is an exact abstract transformer, we can show by induction that \(\gamma\left(\bm{w}^{\sharp\,j},\bm{D}^{\sharp}\right)=\{(\bm{w}_{j}^{j},\bm{D}_ {i})\}\) for any \(j\). As all computations in the concretization have converged at \(n\), we know that \(\bm{w}_{i}^{n+1}=\Phi(\bm{w}_{i}^{n})=\bm{w}_{i}^{n}\) and, thus, \(\{(\bm{w}_{i}^{n},\bm{D}_{i})\}=\{(\bm{w}_{i}^{n+1},\bm{D}_{i})\}\). As \(\Phi^{\sharp}\) is exact, we get the desired result: \(\gamma\left(\bm{w}^{\sharp\,n},\bm{D}^{\sharp}\right)=\{(\bm{w}_{i}^{n},\bm{D}_ {i})\}=\{(\bm{w}_{i}^{n+1},\bm{D}_{i})\}=\gamma\left(\bm{w}^{\sharp\,n+1},\bm{ D}^{\sharp}\right)\). 

### Prediction with Abstract Model Weight Fixed Points

We now discuss how to use the abstract model weights \(\bm{w}^{\sharp\,*}\) returned by our abstract transformer for learning linear models during inference to over-approximate the possible set of predictions for a test data point. We start by discussing test data that is not uncertain and then extend the discussion to the case where the test data is also uncertain.

Deterministic Test DataFor now let us assume that the test data is not uncertain. The following corollary then enables us to use abstract gradient descent for inference and for over-approximating the prediction ranges.

**Corollary F.2**.: _Let \(f_{\bm{w}}(\bm{x})\) denote the linear model for parameters \(\bm{w}\). Given an incomplete training dataset \(\bm{D}\) associated with a set of possible worlds \(\bm{D}^{\odot}\), the prediction range \(V(\bm{x})\) for a test data point \(\bm{x}\) can be over-approximated by:_

\[V^{\sharp}(\bm{x})=\left[\min_{\bm{w}\in\gamma(\bm{w}^{\sharp\,*})}f_{\bm{w}}( \bm{x}),\max_{\bm{w}\in\gamma(\bm{w}^{\sharp\,*})}f_{\bm{w}}(\bm{x})\right],\]

_where \(\bm{w}^{\sharp\,*}\) is the fixed point of the abstract gradient descent operator \(\Phi^{\sharp}\) applied to \(\bm{D}^{\sharp}=\alpha(\bm{D}^{\odot})\), the abstract representation of \(\bm{D}^{\odot}\) in the zonotope domain._

The prediction returned by a linear model with parameters \(\bm{w}\) for a data point \(\bm{x}\) is \(\bm{w}^{T}\bm{x}\). As \(\bm{x}\) does not contain any symbolic term this is the sum of linear terms multiplied by constants, i.e., the result is a 1-dimensional linear zonotope which is a linear expression of the form:

\[c_{0}+\sum_{i=1}^{m}c_{i}\epsilon_{i}\]

where \(c_{i}\in R\) and \(\epsilon_{i}\in\mathcal{E}\). The minimum and maximum value of a 1-d linear zonotope can be determined efficiently as shown below:

\[\left[c_{0}-\sum_{i=1}^{m}\lvert c_{i}\rvert,c_{0}+\sum_{i=1}^{m}\lvert c_{i} \rvert\right]\]

Uncertain Test DataIn Sec. 2 we modeled uncertainty in the training data as sets of possible worlds \(\bm{D}^{\odot}\). As mentioned in that section, our techniques also supports uncertain test data, i.e., both the training and test data may be uncertain.

In the most general case, the training and test data may be correlated.1 We model this as a set of possible worlds \((\bm{D}^{\odot},\mathbf{X}_{\text{test}}{}^{\odot})\) where each world is a pair of a training dataset \(\bm{D}_{i}\) and a test dataset \(\mathbf{X}_{\text{test}i}\):

Footnote 1: Note that this does not necessarily imply a violation of the i.i.d. assumption. For instance, consider a dataset with a textual feature race that is first translated into a categorical feature that is then one-hot encoded into multiple binary attributes. If we are uncertain about the meaning of a particular value of the original attribute, then this leads to a correlation between the uncertainty of both datasets as the interpretation of this value affects all data points with that particular value in the race feature before preprocessing.

\[(\bm{D},\mathbf{X}_{\text{test}})^{\odot}=\{(\bm{D}_{1},\mathbf{X}_{\text{test }1}),\dots,(\bm{D}_{m},\mathbf{X}_{\text{test}m})\}\]

If training and test data are independent, then we can specify their worlds separately ( \(\bm{D}^{\odot}\) and \(\mathbf{X}_{\text{test}}{}^{\odot}\)) and assume the worlds of \((\bm{D},\mathbf{X}_{\text{test}})^{\odot}\) to be their cross product. Uncertainty propagation for inference then requires us to compute the set of possible predictions:

\[\bm{y}^{\odot}=\{f(\mathbf{X}_{\text{test}i})\mid\exists(\bm{D}_{i},\mathbf{X }_{\text{test}i})\in(\bm{D},\mathbf{X}_{\text{test}})^{\odot}:f_{i}=\mathcal{ A}(\bm{D}_{i})\}\]

For inference in the abstract domain we first have to select an appropriate abstraction function for the test data, e.g., using the same abstraction function \(\alpha\) we use for the training data. The only difference to the case discussed above is that a test data point is now also an abstract element \(\bm{x}^{\sharp}\) and the prediction \(\bm{w}^{\sharp}\bm{x}^{\sharp}\) is a polynomial zonotope as it contains higher order terms that are the result of multiplying linear terms. To efficiently determine the minimum and maximum we can, e.g., employ linearization to map the polynomial zonotope into a linear one and apply the solution described above for finding the minimum and maximum of a linear zonotope.

## Appendix G Linearization and Order Reduction Techniques

### Linearization

The purpose of linearization is to over-approximate an input polynomial zonotope with a linear zonotope.

**Definition G.1** (Linearization Operator \(\mathbf{L}\)).: _A linearization operator \(\mathbf{L}\) maps a polynomial zonotope \(\bm{z}^{\sharp}\) to a linear zonotope \(\bm{\ell}^{\sharp}\). It replaces high-order polynomial terms with new error symbols, ensuring that all expressions are linear while maintaining an over-approximation:_

\[\gamma\left(\mathbf{L}(\bm{z}^{\sharp})\right)\supseteq\gamma\left(\bm{z}^{ \sharp}\right).\]

During inference, computing the prediction intervals using the linear zonotope representation can be done efficiently with linear programming. However, more importantly, in our construction of abstract fixed points we use a specific order reduction technique that requires prior linearization in each gradient descent step to enforce the existence of a fixed point. For a \(d\)-dimensional polynomial zonotope \(\bm{z}^{\sharp}\) with a set of monomials \(\mathcal{S}\):

\[\bm{z}^{\sharp}=\bm{c}+\sum_{i=1}^{|\mathcal{S}|}\bm{g}_{i}\mathcal{S}[i],\]

we have its linearization:

\[\mathbf{L}(\bm{z}^{\sharp})=\bm{c}+\underbrace{\sum_{i\in\sigma_{l}}\bm{g}_{i }\mathcal{S}[i]}_{\text{Linear monomials}}+\underbrace{\sum_{i\in\sigma_{l}}\bm{g}_{i }\epsilon^{\prime}_{i}}_{\text{Replaced with linear monomials}}\]

where \(\sigma_{l}\) denotes the set of indices of all linear terms in \(\bm{z}^{\sharp}\). Here, the third part over-approximates each high-order term in \(\bm{z}^{\sharp}\) by replacing it with a new error symbol.

### Order Reduction Operators

_Order reduction operators_ are used to reduce the representation size of a zonotope. That is, an order reduction operator takes as input a linear zonotope \(\bm{\ell}^{\sharp}\) and return a linear zonotope of smaller order (smaller representation size) that over-approximates \(\bm{\ell}^{\sharp}\). For linear zonotopes this means that order reduction operators reduce the number of distinct error symbols that occur in a zonotope by merging error symbols.

**Definition G.2** (Order Reduction Operator \(\mathbf{R}\)).: _An order reduction operator \(\mathbf{R}\) takes a linear zonotope \(\bm{\ell}^{\sharp}\) as input and returns another linear zonotope of reduced order:_

\[\gamma\left(\mathbf{R}(\bm{\ell}^{\sharp})\right)\supseteq\gamma \left(\bm{\ell}^{\sharp}\right) \mathrm{ord}(\mathbf{R}(\bm{\ell}^{\sharp}))<\mathrm{ord}(\bm{\ell}^{ \sharp})\]

We now present details about two commonly adopted order reduction techniques: _Interval Hull (IH)_ and _transformation-based Interval Hull (TIH)_ in App. G. In this section, we use the geometric representation of zonotopes (see Def. C.2). Note that for a linear zonotope, each \(\mathcal{S}[i]\) consists of a single error term \(\epsilon_{i}\). Thus, we can write such a zonotope \(\bm{\ell}^{\sharp}\) as:

\[\bm{\ell}^{\sharp}=\bm{c}+\sum_{i=1}^{|\mathcal{S}|}\bm{g}_{i}\epsilon_{i}\]

IH merges a selected subset \(\delta_{s}\) of the error symbols of a zonotope and their corresponding generator vectors. For a \(d\)-dimensional zonotope \(\bm{\ell}^{\sharp}\):

\[\mathbf{R}_{IH}(\delta_{s},\bm{\ell}^{\sharp})=\mathbf{R}_{IH}\left(\delta_{ s},\bm{c}+\sum_{i=1}^{|\mathcal{S}|}\bm{g}_{i}\epsilon_{i}\right)=\bm{c}+ \underbrace{\sum_{i\notin\delta_{s}}\bm{g}_{i}\epsilon_{i}}_{\textbf{Retained error symbols}}+\underbrace{\begin{bmatrix}\left(\sum_{i\in\delta_{s}}|\bm{g}_{i}[1]| \right)\epsilon_{1}^{\prime}\\ \vdots\\ \left(\sum_{i\in\delta_{s}}|\bm{g}_{i}[d]|\right)\epsilon_{d}^{\prime}\end{bmatrix}}_ {\textbf{Over-approximated with $d$-dimensional box}}\]

The selected terms \(\delta_{s}\) are merged into a \(d\)-dimensional box described by \(d\) new error symbols \(\{\epsilon_{1}^{\prime},\cdots,\epsilon_{d}^{\prime}\}\). We will drop \(\delta_{s}\) if all error symbols of the input zonotope are selected.

The error symbols getting merged (\(\delta_{s}\)) are often determined based on some heuristic, e.g., symbols with lowest coefficients. TIH \(\mathbf{R}_{TIH}\) first projects the zonotope to another space using an invertible linear transformation matrix \(\bm{A}\in\mathbb{R}^{d\times d}\), then applies IH, and finally projects the resulting zonotope back with \(\bm{A}^{-1}\). IH is a special case of TIH where \(\bm{A}=I\).

\[\mathbf{R}_{TIH}(\delta_{s},\bm{A},\bm{z}^{\sharp})=\bm{A}^{-1}\mathbf{R}_{IH} (\bm{A}\bm{z}^{\sharp}).\]

Intuitively, the purpose of the linear transformation \(\bm{A}\) is to project the zonotope to a space where its shape is closer to a box, to reduce the loss of precision brought by order reduction [2, 38]. One of the most widely used TIH is PCA-based order reduction, whose transformation is obtained from the PCA of the set of all generator vectors of the input zonotope [51, 38].

Order Reduction for PTIME Zonotope TrainingWith linearization, the number of error symbols in the model weights zonotope \(\bm{w}^{\sharp}\) still grows exponentially with rate \(\mathcal{O}(p^{2})\), leading to exponential time complexity for gradient descent. We can overcome this challenge through _order reduction_, which enforces the maximum number of terms in the symbolic expressions of model weights zonotopes [38]. Note that for a linear zonotope, each \(\mathcal{S}[i]\) consists of a single error term \(\epsilon_{i}\). Thus, we can write such a zonotope \(\bm{\ell}^{\sharp}\) as:

\[\bm{\ell}^{\sharp}=\bm{c}+\sum_{i=1}^{|\mathcal{S}|}\bm{g}_{i}\epsilon_{i}\]

Order reduction \(\mathbf{R}\) reduces the order (representation size) of a linear zonotope \(\bm{\ell}^{\sharp}\). This is achieved by _merging_ error symbols in \(\mathcal{S}\), while ensuring that the result over-approximation the input zonotope, i.e.,

\[\gamma\left(\mathbf{R}(\bm{\ell}^{\sharp})\right)\supseteq\gamma\left(\bm{\ell} ^{\sharp}\right)\]Two commonly adopted order reduction approaches [38] are _Interval Hull (IH)_, denoted as \(\mathbf{R}_{IH}\), and _Transformation-based Interval Hull (TIH)_, denoted as \(\mathbf{R}_{TIH}\)[2, 38, 64]. Specifically, IH merges a set of error symbols \(\delta_{s}\subseteq\{\epsilon_{i}\}\) and their corresponding generator vectors (here \(\delta_{k}=\{\epsilon_{i}\}-\delta_{s}\)):

\[\mathbf{R}_{IH}(\bm{z}^{\sharp})=\mathbf{R}_{IH}\left(\bm{c}+\sum_{i=1}^{| \mathcal{S}|}\bm{g}_{i}\mathcal{S}[i]\right)=\bm{c}+\sum_{i\in\delta_{k}}\bm{ g}_{i}\mathcal{S}[i]+diag(\sum_{i\in\delta_{s}}|\bm{g}_{i}[1]|,\cdots,\sum_{i\in \delta_{s}}|\bm{g}_{i}[d]|)\begin{bmatrix}\epsilon_{1}^{\prime}\\ \vdots\\ \epsilon_{d}^{\prime}\end{bmatrix}\]

The selected terms \(\delta_{s}\) are merged into a \(d\)-dimensional box described by \(d\) new error symbols \(\{\epsilon_{1}^{\prime},\cdots,\epsilon_{d}^{\prime}\}\). The error symbols getting merged (\(\delta_{s}\)) are often determined based on some heuristic [38], e.g., the symbols with lowest coefficients. Similar to IH, TIH also merges error terms using IH, but in some projected space. TIH first projects the zonotope to another space using an invertible linear transformation matrix \(A\in\mathbb{R}^{d\times d}\), then conducts IH, and finally projects the resulting zonotope back into the original space with \(A^{-1}\):

\[\mathbf{R}_{TIH}(\bm{z}^{\sharp})=A^{-1}\mathbf{R}_{IH}(A\bm{z}^{\sharp}).\]

Intuitively, the linear transformation \(A\) aims to project the zonotope to a space where its shape is closer to a box, to reduce the loss of precision brought by order reduction [2, 38]. One of the most widely used TIH is PCA-based order reduction, whose transformation is obtained from the PCA of all generator vectors [38, 51].

## Appendix H Efficient Abstract Gradient Descent with Order Reduction

As mentioned in sec. 4.1, to address the tractability issues with abstract gradient descent, we employ two key techniques: linearization and order reduction. We employ linearization at each step of gradient descent to ensure that the resulting abstract representation of model parameters remains a linear zonotope.

Given a linearization operator \(\mathbf{L}\) and order reduction operator \(\mathbf{R}\), we construct an abstract gradient descent operator, \(\Phi^{\sharp}\):

\[\Phi^{\sharp}(\bm{w}^{\sharp})=\mathbf{R}\Big{(}\bm{w}^{\sharp}-\mathbf{L} \big{(}\eta\nabla L(\bm{w}^{\sharp})\big{)}\Big{)},\] (9)

which ensures that the abstract representation size remains bounded while providing efficient over-approximation. This operator is an abstract transformer for the concrete gradient descent operator.

**Proposition H.1**.: _For any linearization \(\mathbf{L}\) and order reduction \(\mathbf{R}\), the abstract gradient descent \(\Phi^{\sharp}\) is an abstract transformer for the concrete gradient descent operator \(\Phi\). Formally, for any abstract \(\bm{w}^{\sharp}\),_

\[\gamma\left(\Phi^{\sharp}(\bm{w}^{\sharp})\right)\supseteq\Phi(\gamma\left( \bm{w}^{\sharp}\right)),\]

_._

Proof.: Given that abstract transformers compose (Prop. B.1), we can decompose \(\Phi\) into separate steps and construct an abstract transformer for \(\Phi\) by composing abstract transformers for the individual steps. We can inject identity functions anywhere into the computation without changing its result. Let \(ident\) represent an identify function of an appropriate type and \(F^{\sharp}\) be the abstract operator resulting from injecting identity functions as shown below, then:

\[F^{\sharp}(\bm{w}^{\sharp})=ident\Big{(}\bm{w}^{\sharp}-ident\big{(}\eta\nabla L (\bm{w}^{\sharp})\big{)}\Big{)}=\bm{w}^{\sharp}-\big{(}\eta\nabla L(\bm{w}^{ \sharp})\big{)}=\Phi^{\sharp}_{exact}(\bm{w}^{\sharp})\]

Since \(\Phi^{\sharp}_{exact}\) is an abstract transformer for \(\Phi\), so is \(F^{\sharp}\). Now observe that both \(\mathbf{L}\) and \(\mathbf{R}\) are abstract transformers for \(ident\) as

\[\gamma\left(\mathbf{L}(\bm{w}^{\sharp})\right)\supseteq\gamma\left(\bm{w}^{ \sharp}\right)=ident(\gamma\left(\bm{w}^{\sharp}\right))\]

Thus, \(\Phi^{\sharp}\) is an abstract transformer for \(\Phi\). 

Note that Prop. 3.3 then implies that a fixed point \(\bm{w}^{\sharp\,*}\) for \(\Phi^{\sharp}\)is an over-approximation of all possible model weights \(\bm{w}^{\odot\,*}\):

\[\gamma\left(\bm{w}^{\sharp\,*}\right)\supseteq\bm{w}^{\odot\ast}\]

### Abstract Gradient Descent With Order Reduction And Fixed Points

While \(\Phi^{\sharp}\) ensures that every step of gradient descent can be computed efficiently as we bound the order of the resulting zonotope in each step, this operator typically does not have a fixed point and even if it does, we still would have to solve an NP-hard problem [39] to detected that we have converged. The reason for the lack of a fixed point is that both linearization and order reduction results in over-approximation and the over-approximation error may grow in each iteration. Recall that we did show a real example of where this operator diverges in Sec. 4.1.

## Appendix I An Efficient Approximate Abstract Transformer for Ridge Regression

In this section and the next section we present the proof of our main technical result: Thm. 4.2. Recall that Thm. 4.2 states that Alg. 1 computes abstract model parameters \(\bm{w}^{\sharp}\)\({}^{*}\) that are a fixed point for the abstract transformer \(\Phi^{\sharp}\)using a closed form solution. Because \(\Phi^{\sharp}\)was shown to be an abstract transformer for gradient decent this then implies that \(\bm{w}^{\sharp}\)\({}^{*}\) over-approximates all possible model weights \(\bm{w}^{\odot*}\). We start by presenting additional details of the decomposition we employ to force a fixed points, formally prove that the condition on \(\bm{w}^{\sharp}\)\({}^{*}\) from Prop. 4.1 is a sufficient for \(\bm{w}^{\sharp}\)\({}^{*}\) being a fixed point for \(\Phi^{\sharp}\), and then develop a closed form solution that requires solving a system of linear equations. For \(\bm{w}^{\sharp}_{N}\), the parts of the abstract model weights that exclusively contains symbols that do not appear in the abstract training dataset \(\mathbf{D}^{\sharp}\), the equation system only has a solution if the regularization coefficient \(\lambda\) is larger then or equal to a constant \(\beta\) that depends on \(\mathbf{D}^{\sharp}\). Based on our experience and extensive experimental evaluation, we typically have \(\beta=0\), i.e., the closed form solution exists for any regularization coefficient \(\lambda\). Nonetheless, we present a technique for achieving any desired \(\beta\geq 0\) by splitting zonotopes into smaller parts with lower \(\beta\), computing fixed points for each split individually, and merging the final result. These techniques will be presented in app. J.

### Decomposing Fixed Point Equations For Abstract Gradient Descent

We now present additional details about our decomposition of the gradient from Sec. 4.1 for linear regression with \(\ell_{2}\) regularization (ridge regression). The loss function \(L\) for ridge regression an \(\ell_{2}\) penalty, is given by:

\[L(\bm{X},\bm{y},\bm{w})=\frac{1}{n}(\bm{X}\bm{w}-\bm{y})^{T}(\bm{X}\bm{w}-\bm{ y})+\lambda\cdot\bm{w}^{T}\bm{w},\]

where \(\lambda\) is the regularization coefficient (see App. A for details).

Recall that we observed that an abstract model weight zonotope \(\bm{w}^{\sharp}\) can be decomposed into parts that can be dealt with separately in the sense that we will show that a sufficient condition for achieving a fixed point \(\bm{w}^{\sharp}\)\({}^{*}\) is that each component has a fixed point. Given an abstract training dataset \(\mathbf{D}^{\sharp}\), we use \(\bm{X}^{\sharp}\) and \(\bm{y}^{\sharp}\) to denote its feature matrix and labels. We decompose them into real (concrete) and symbolic components:

\[\bm{X}^{\sharp} =\bm{X}_{R}+\bm{X}^{\sharp}_{S}\] \[\bm{y}^{\sharp} =\bm{y}_{R}+\bm{y}^{\sharp}_{S}\]

where \(\bm{X}_{R}\in\mathbb{R}^{n\times d}\) and \(\bm{y}_{R}\in\mathbb{R}^{n}\) represent the real centers of zonotopes \(\bm{X}^{\sharp}\) and \(\bm{y}^{\sharp}\), while \(\bm{X}^{\sharp}_{S}\in\Lambda^{n\times d}\) and \(\bm{y}^{\sharp}_{S}\in\Lambda^{n}\) contain the symbolic terms.

Similarly, we decompose the abstract model weights at iteration \(i\) into real and symbolic components:

\[\bm{w}^{\sharp}\,{}^{i}=\bm{w}^{i}_{R}+\bm{w}^{\sharp}_{S}\,,\]

where \(\bm{w}^{i}_{R}\in\mathbb{R}^{d}\) represents the real center, and \(\bm{w}^{\sharp}_{S}\in\Lambda^{d}\) contains the symbolic terms. The symbolic terms are further decomposed into those containing data symbols (\(\bm{w}^{\sharp}_{D}\)), i.e., symbols that are shared with \(\mathbf{D}^{\sharp}\), and those introduced via linearization and order reduction in linear abstract gradient descent (\(\bm{w}^{\sharp}_{N}\)), i.e., that do not appear in \(\mathbf{D}^{\sharp}\).

\[\bm{w}^{\sharp}_{S}=\bm{w}^{\sharp}_{D}+\bm{w}^{\sharp}_{N}\,.\]

[MISSING_PAGE_FAIL:26]

\(\bm{A}\big{(}\mathbf{R}_{IH}(\bm{A}^{-1}(\bm{w}_{X}^{\sharp}-\eta(\mathcal{G}_{L}^ {N}+\mathbf{L}(\mathcal{G}_{H})))\big{)}\big{)}\) does not share symbols with \(\mathbf{D}^{\sharp}\), as it consists of new symbols generated from order reduction.

### Constructing Fixed Points For Abstract Gradient Descent

Having defined \(\Phi_{(\mathbf{L},\mathbf{R}_{\bm{A}})}^{\sharp}\) which was denoted by \(\Phi_{(\mathbf{L},\mathbf{R}_{\bm{A}})}^{\sharp}\) in app. H, we are now ready to state the first part of our main technical result: under some mild assumptions on \(\lambda\) being larger than some data-dependent constant \(\beta\), \(\Phi_{(\mathbf{L},\mathbf{R}_{\bm{A}})}^{\sharp}\) has a fixed point and, importantly, this fixed point can be computed efficiently. In practice, we often have \(\beta=0\). However, if this is not the case, we demonstrate later that at the cost of reduced computational efficiency we can reduce \(\beta\) by splitting \(\mathbf{D}^{\sharp}\) into several zonotopes and solving the problem independently for each zonotope as we will details in App. J.

**Theorem I.1** (Existence of Abstract Fixed Points).: _Consider an abstract training dataset \(\mathbf{D}^{\sharp}\). There exists a constant \(\beta\) specific to \(\mathbf{D}^{\sharp}\) such that \(\Phi_{(\mathbf{L},\mathbf{R}_{\bm{A}})}^{\sharp}\) has a fixed point for any \(\lambda\geq\beta\)._

In the remainder of this section, we prove Thm. I.1 by demonstrating how to construct such a fixed point efficiently. We start by identifying a sufficient condition for \(\bm{w}^{\sharp\,*}\) to be a fixed point, then demonstrate that the problem of finding a \(\bm{w}^{\sharp\,*}\) that fulfills this sufficient condition can be decomposed based on our decomposition \(\bm{w}^{\sharp\,*}=\bm{w}_{R}^{\star}+\bm{w}_{D}^{\sharp\,*}+\bm{w}_{N}^{ \sharp\,*}\) presented earlier. Specifically, certain components are independent of other components suggesting an evaluation order where we find a fixed point for one component treating the previously computed fixed points for other components as constants. Then we proceed to prove closed form solutions for \(\bm{w}_{R}^{\star}\) and for \(\bm{w}_{D}^{\sharp\,*}\) given \(\bm{w}_{R}^{\star}\). Finally, given \(\bm{w}_{R}^{\star}\) and \(\bm{w}_{D}^{\sharp\,*}\) we construct a system of equations whose solution gives a fixed point for \(\bm{w}_{N}^{\sharp\,*}\) and demonstrate that this system of equations has a closed form solution for any \(\lambda\geq\beta\).

A Sufficient Condition for Abstract Fixed Points.Recall from Def. 3.2 that the fixed point \(\bm{w}^{\sharp\,*}\) must satisfy \(\gamma\left(\bm{w}^{\sharp\,*},\mathbf{D}^{\sharp}\right)\supseteq\gamma\left( \Phi_{(\mathbf{L},\mathbf{R}_{\bm{A}})}^{\sharp}(\bm{w}^{\sharp\,*}),\mathbf{ D}^{\sharp}\right)\). We now present a sufficient condition for this to hold. Intuitively this condition requires the **invariance** of different components of \(\Phi_{(\mathbf{L},\mathbf{R}_{\bm{A}})}^{\sharp}(\bm{w}^{\sharp})\) when doing joint concretization with \(\mathbf{D}^{\sharp}\).

**Proposition I.2**.: _If an abstract model weight \(\bm{w}^{\sharp\,*}=\bm{w}_{R}^{\star}+\bm{w}_{D}^{\sharp\,*}+\bm{w}_{N}^{ \sharp\,*}\) satisfies the following three conditions, then it is an abstract fixed point of the abstract gradient descent operator \(\Phi_{(\mathbf{L},\mathbf{R}_{\bm{A}})}^{\sharp}\):_

\[\bm{w}_{R}^{\star} =\bm{w}_{R}^{\star}-\eta\mathcal{G}_{R}\] (19) \[\bm{w}_{D}^{\sharp\,*} =\bm{w}_{D}^{\sharp\,*}-\eta\mathcal{G}_{L}^{D}\] (20) \[\bm{w}_{N}^{\sharp\,*} \simeq_{\sharp}\mathbf{R}_{\bm{A}}\left(\bm{w}_{N}^{\sharp}-\eta( \mathcal{G}_{L}^{N}+\mathbf{L}(\mathcal{G}_{H}))\right).\] (21)

Proof.: Consider the definition of an abstract fixed point \(\bm{w}^{\sharp\,*}\) (Def. 3.2 applied to \(\Phi_{(\mathbf{L},\mathbf{R}_{\bm{A}})}^{\sharp}\) ):

\[\gamma\left(\bm{w}^{\sharp\,*},\mathbf{D}^{\sharp}\right)\supseteq\gamma\left( \Phi_{(\mathbf{L},\mathbf{R}_{\bm{A}})}^{\sharp}(\bm{w}^{\sharp\,*}),\mathbf{D} ^{\sharp}\right)\]

This can certainly be achieved if

\[\bm{w}^{\sharp\,*},\mathbf{D}^{\sharp}\simeq_{\sharp}\Phi_{(\mathbf{L},\mathbf{ R}_{\bm{A}})}^{\sharp}(\bm{w}^{\sharp\,*}),\mathbf{D}^{\sharp}\]

This requires equal joint concretization of the fixed point the pairs \((\bm{w}^{\sharp\,*},\mathbf{D}^{\sharp})\) and \((\Phi_{(\mathbf{L},\mathbf{R}_{\bm{A}})}^{\sharp}(\bm{w}^{\sharp\,*}),\mathbf{ D}^{\sharp})\). To understand the need for joint concretization here note that certain model weights \(\bm{w}\)paired with certain datasets \(\bm{D}\) in the joint concretization. If we would only consider equivalence of the abstract model weight, two zonotopes \(\bm{w}^{\sharp}\) and \(\bm{w}^{\sharp\,\prime}\) may be equivalent \(\bm{w}^{\sharp}\simeq_{\sharp}\bm{w}^{\sharp\,\prime}\), but pair a particular model weight \(\bm{w}\in\gamma\left(\bm{w}^{\sharp}\right)=\gamma\left(\bm{w}^{\sharp\,\prime}\right)\) with different datasets \(\bm{D}_{1}\in\gamma\left(\mathbf{D}^{\sharp}\right)\) and \(\bm{D}_{2}\in\gamma\left(\mathbf{D}^{\sharp}\right)\). Thus, it is possible that \(\bm{w}^{\sharp}\simeq_{\sharp}\Phi_{(\mathbf{L},\mathbf{R}_{\bm{A}})}^{\sharp}( \bm{w}^{\sharp})\) holds but \(\gamma\left(\bm{w}^{\sharp}\right)=\gamma\left(\bm{w}^{\sharp\,\prime}\right)\) does not contain all model weights from \(\bm{w}^{\odot*}\).

[MISSING_PAGE_FAIL:28]

The last step relies on the fact that \(\bm{X}_{R}{}^{T}\bm{X}_{R}+\lambda nI\) is invertible which is guaranteed for \(\lambda>0\)[26]. Note that, as expected since the fixed point equation for \(\bm{w}_{R}^{*}\) does not contain any symbolic expressions, the closed form for \(\bm{w}_{R}^{*}\) is equal to the well-known closed form for ridge regression. _Fixed Point for \(\bm{w}_{D}^{\sharp\,*}\)_. Note that given the independence of \(\bm{w}_{R}^{*}\) from \(\bm{w}_{D}^{\sharp\,*}\), we can assume that \(\bm{w}_{R}^{*}\) has been determined using the closed form solution shown above. Thus, we can treat \(\bm{w}_{R}^{*}\) as a constant in the following derivation. We start by substituting the definition or Eq. (13) into Eq. (20).

\[\bm{w}_{D}^{\sharp\,*}=\bm{w}_{D}^{\sharp\,*}-\eta\Big{(}(2\lambda I +\frac{2}{n}\bm{X}_{R}{}^{T}\bm{X}_{R})\bm{w}_{D}^{\sharp\,*}+\frac{2}{n}(\bm{ X}_{R}{}^{T}\bm{X}_{S}^{\sharp}+\bm{X}_{S}^{\sharp\,T}\bm{X}_{R})\bm{w}_{R}^{*}\] \[\qquad\qquad\qquad-\frac{2}{n}(\bm{X}_{S}^{\sharp}\bm{y}_{R}+\bm {X}_{R}{}^{T}\bm{y}_{S}^{\sharp})\Big{)}\] \[\Leftrightarrow 0=\frac{2\eta}{n}\Big{(}(\bm{X}_{R}{}^{T}\bm{X}_{R}+\lambda nI )\bm{w}_{D}^{\sharp\,*}+(\bm{X}_{R}{}^{T}\bm{X}_{S}^{\sharp}+\bm{X}_{S}^{\sharp \,T}\bm{X}_{R})\bm{w}_{R}^{*}-\bm{X}_{S}^{\sharp}\bm{y}_{R}-\bm{X}_{R}{}^{T}\bm {y}_{S}^{\sharp}\Big{)}\] \[\Leftrightarrow 0=(\lambda nI+\bm{X}_{R}{}^{T}\bm{X}_{R})\bm{w}_{D}^{\sharp\,*} +(\bm{X}_{R}{}^{T}\bm{X}_{S}^{\sharp}+\bm{X}_{S}^{\sharp\,T}\bm{X}_{R})\bm{w} _{R}^{*}-\bm{X}_{S}^{\sharp}\bm{y}_{R}-\bm{X}_{R}{}^{T}\bm{y}_{S}^{\sharp} \qquad(\eta>0)\] \[\Leftrightarrow (\lambda nI+\bm{X}_{R}{}^{T}\bm{X}_{R})\bm{w}_{D}^{\sharp\,*}=- \Big{(}(\bm{X}_{R}{}^{T}\bm{X}_{S}^{\sharp}+\bm{X}_{S}^{\sharp\,T}\bm{X}_{R}) \bm{w}_{R}^{*}-\bm{X}_{S}^{\sharp}\bm{y}_{R}-\bm{X}_{R}{}^{T}\bm{y}_{S}^{\sharp }\Big{)}\] \[\Leftrightarrow \bm{w}_{D}^{\sharp\,*}=(\bm{X}_{R}{}^{T}\bm{X}_{R}+\lambda nI)^ {-1}\Big{(}\bm{X}_{S}^{\sharp}\bm{y}_{R}+\bm{X}_{R}{}^{T}\bm{y}_{S}^{\sharp}-( \bm{X}_{R}{}^{T}\bm{X}_{S}^{\sharp}+\bm{X}_{S}^{\sharp\,T}\bm{X}_{R})\bm{w}_{R} ^{*}\Big{)}\] (25)

Note that matrix inversion is applied to \((\bm{X}_{R}{}^{T}\bm{X}_{R}+\lambda nI)\) which does not contain any symbolic terms and as discussed above this matrix is guaranteed to be invertible. 

Analysis of the Fixed Point Equations for \(\bm{w}_{N}^{\sharp\,*}\).Using the closed form solutions established in Lem. 1.4, we can compute \(\bm{w}_{R}^{*}\) and \(\bm{w}_{D}^{\sharp\,*}\) fulfilling Eq. (19) and Eq. (20). In the remainder of this subsection we show how to compute a solution \(\bm{w}_{N}^{\sharp\,*}\) to Eq. (21) for a given \(\lambda\geq\beta\) (regularization coefficient), i.e., we prove Thm. 1.1 that postulated the existence of such fixed points \(\bm{w}^{\sharp\,*}\) constructively.

To find a fixed point \(\bm{w}_{N}^{\sharp\,*}\), we are searching for an abstract model weight that fulfills Eq. (21):

\[\bm{w}_{N}^{\sharp\,*}\simeq_{\sharp}\mathbf{R}_{\bm{A}}\left(\bm{w}_{N}^{ \sharp}-\eta(\mathcal{G}_{L}^{N}+\mathbf{L}(\mathcal{G}_{H}))\right)\] (26)

This implies that \(\bm{w}_{N}^{\sharp\,*}\) needs to be equivalent to the result of \(\mathbf{R}_{\bm{A}}\) on some input zonotope \(\bm{w}_{N}^{\sharp}-\eta(\mathcal{G}_{L}^{N}+\mathbf{L}(\mathcal{G}_{H})\). Recall the definition of \(\mathbf{R}_{\bm{A}}\) for a linear input zonotope \(\bm{\ell}^{\sharp}\):

\[\mathbf{R}_{\bm{A}}(\bm{\ell}^{\sharp})=\bm{A}^{-1}\mathbf{R}_{IH}(\bm{A}\bm{ \ell}^{\sharp})\] (27)

Note that \(\mathbf{R}_{\bm{A}}\) applies \(\mathbf{R}_{IH}\) to all error symbols in its input. Thus, \(\mathbf{R}_{IH}(\cdot)\) is a \(d\)-dimensional box in the projected space into which the input \(\bm{\ell}^{\sharp}\) is mapped into by \(\bm{A}\). Furthermore, as \(\bm{w}_{N}^{\sharp}-\eta(\mathcal{G}_{L}^{N}+\mathbf{L}(\mathcal{G}_{H})\) does only contain symbolic terms, the interval hull (the box computed by \(\mathbf{R}_{IH}\)) is centered at \(\mathbf{0}\).

**Lemma I.5**.: _Any solution \(\bm{w}_{N}^{\sharp}\) of Eq. (26) is equivalent to the image of a box \(\bm{b}^{\sharp}\) centered at \(\mathbf{0}\) produced by \(\bm{A}^{-1}\), i.e.,_

\[\bm{w}_{N}^{\sharp}\simeq_{\sharp}\bm{A}^{-1}\bm{b}^{\sharp}\]

Proof.: IH does not change the center of a zonotope and \(\bm{A}\) is a linear map. Now observe that all terms in Eq. (14) and (15) are symbolic (contain error symbols). Thus, the RHS of Eq. (26) that is the input to order reduction is a zonotope with center \(\mathbf{0}\). 

A linear zonotope that is a box in \(d\)-dimensional space with center \(\mathbf{0}\) is, up to equivalence, uniquely determined by the diameter of the box in each dimension. That is, if we use \(k_{i}\geq 0\) to denote the diameter of the box in the \(i^{th}\) dimension and \(\bm{k}\in\mathbb{R}^{d}\) to denote the vector of these elements, then we can write any such zonotope \(\bm{b}^{\sharp}\) as:

\[\bm{b}^{\sharp}=\begin{bmatrix}k_{1}\epsilon_{1}\\ \vdots\\ k_{d}\epsilon_{d}\end{bmatrix}=\begin{bmatrix}k_{1}&\cdots&0\\ \vdots&\ddots&\vdots\\ 0&\cdots&k_{d}\end{bmatrix}\begin{bmatrix}\epsilon_{1}\\ \vdots\\ \epsilon_{d}\end{bmatrix}=diag\{\bm{k}\}\begin{bmatrix}\epsilon_{1}\\ \vdots\\ \epsilon_{d}\end{bmatrix}\]Combining Eq. (26) with Eq. (27), we know that \(\bm{w}_{N}^{\sharp}\) is a zonotope that is equivalent to the image of \(A^{-1}\) on a box \(\bm{b}^{\sharp}\) parameterized by \(\bm{k}\). We will only consider solutions of this form:2

Footnote 2: This does not restrict the possible concretization of any such zonotope we can achieve. As \(\bm{A}\) is invertible, \(\bm{A}^{-1}\) has full rank and thus, its column vectors \(\bm{a}_{1},\cdots,\bm{a}_{d}\) form a basis of a vector space. Given \(\bm{A}^{-1}\), the concretization of a zonotope of this form is uniquely determined by \(\bm{k}\) (recall that we assume that all \(k_{i}\) are positive).

\[\bm{w}_{N}^{\sharp\,*}=\bm{A}^{-1}diag\{\bm{k}\}\begin{bmatrix}\epsilon_{1}\\ \vdots\\ \epsilon_{d}\end{bmatrix}=\sum_{i=1}^{d}k_{i}\bm{a}_{i}\epsilon_{i}\] (28)

where \(\bm{a}_{1},\cdots,\bm{a}_{d}\) are the column vectors of \(\bm{A}^{-1}\). As the naming of error symbols is irrelevant, finding a solution to Eq. (26) now amounts to finding a vector \(\bm{k}\) as the error symbols are now treated as fixed.

Now we can substitute the formula for \(\bm{w}_{N}^{\sharp\,*}\) from Eq. (28) into the RHS of Eq. (26) as shown below. Recall from app. G.2 that IH merges different error symbols by adding up the absolute values of their coefficients. For the \(i^{th}\) dimension, each \(k_{j}\) will appear with a certain coefficient. For some terms, the symbolic expression for the \(i^{th}\) dimension may contain error symbols that do not have any \(k_{l}\) in their coefficients. Thus, without considering for now the precise values for each coefficient we know that the box produced by IH in the RHS is of the form shown below where \(\bm{C}\in\mathbb{R}^{d\times d}\) is a matrix with non-negative entries \(c_{i,j}\geq 0\) (at position \((i,j)\)), and \(\bm{c}_{0}\in\mathbb{R}^{d}\) is a vector with non-negative elements \(c_{i,0}\geq 0\) (at dimension \(i\)). Intuitively, \(c_{i,j}\) is the coefficient of \(k_{j}\) in the \(i^{th}\) dimension and \(c_{i,0}\) is the sum of the coefficients of error symbols that do not have any \(k_{j}\) in their coefficients (e.g., the fresh symbols introduced by linearization). Note since IH does calculate coefficients of the error symbols in the output as a sum of absolute values, we know that all entries of \(\bm{C}\) and \(\bm{c}_{0}\) are positive. Furthermore, recall that we assumed that \(k_{j}\geq 0\).

\[\begin{split}\mathbf{R}_{\bm{A}}(\bm{w}_{N}^{\sharp}-\eta( \mathcal{G}_{L}^{N}+\mathbf{L}(\mathcal{G}_{H})))=\bm{A}^{-1}\mathbf{R}_{JH}( \bm{A}(\bm{w}_{N}^{\sharp}-\eta(\mathcal{G}_{L}^{N}+\mathbf{L}(\mathcal{G}_{ H}))))\\ =\bm{A}^{-1}\begin{bmatrix}(c_{1,0}+\sum_{j=1}^{d}c_{1,j}k_{j}) \epsilon_{1}^{\prime}\\ \vdots\\ (c_{d,0}+\sum_{j=1}^{d}c_{d,j}k_{j})\epsilon_{d}^{\prime}\end{bmatrix}=\bm{A} ^{-1}diag\{\bm{c}_{0}+\bm{C}\bm{k}\}\begin{bmatrix}\epsilon_{1}^{\prime}\\ \vdots\\ \epsilon_{d}^{\prime}\end{bmatrix}.\end{split}\] (29)

Substituting the LHS and RHS of Eq. (21) with Eq. (28) and (29), we get:

\[\bm{A}^{-1}diag\{\bm{k}\}\begin{bmatrix}\epsilon_{1}\\ \vdots\\ \epsilon_{d}\end{bmatrix}\simeq_{\sharp}\bm{A}^{-1}diag\{\bm{c}_{0}+\bm{C} \bm{k}\}\begin{bmatrix}\epsilon_{1}^{\prime}\\ \vdots\\ \epsilon_{d}^{\prime}\end{bmatrix}\] \[\Leftrightarrow diag\{\bm{k}\}\begin{bmatrix}\epsilon_{1}\\ \vdots\\ \epsilon_{d}\end{bmatrix}\simeq_{\sharp}diag\{\bm{c}_{0}+\bm{C}\bm{k}\} \begin{bmatrix}\epsilon_{1}^{\prime}\\ \vdots\\ \epsilon_{d}^{\prime}\end{bmatrix}\] (30) \[\Leftrightarrow \bm{k}=\bm{c}_{0}+\bm{C}\bm{k}\] (31) \[\Leftrightarrow (I-\bm{C})\bm{k}=\bm{c}_{0}\quad s.t.\ \bm{k}\succcurlyeq\bm{0}\] (32) \[\Leftrightarrow (1-c_{i,i})k_{i}-\sum_{\begin{subarray}{c}j=1\\ j\neq i\end{subarray}}^{d}(c_{i,j}k_{j})=c_{i,0}\quad s.t.\ k_{i}\geq 0\ \forall i\in[1,d]\] (33)

Intuitively, the equivalence of boxes from Eq. (30) is equivalent to the equality of their diameters which yields Eq. (31). Therefore, any \(\bm{k}\in\mathbb{R}^{d}\) satisfying Eq. (31) gives us a fixed point \(\bm{w}_{N}^{\sharp\,*}\). In Eq. (32) we make explicit our assumption that \(k_{i}\geq 0\) and finally in Eq. (33) we write Eq. (32) as a system of linear equations.

Existence of a Closed Form Solution for the Fixed Point Equations for \(\bm{w}_{N}^{\sharp*}\)What remains to be shown to prove Thm. 1.1 is that Eq. (33) is guaranteed to have a solution. For that we will investigate the structure of \(\bm{C}\) and \(\bm{c}_{0}\). Recall that the matrix \(\bm{C}\) and \(\bm{c}_{0}\) are obtained from IH order reduction on input (see Eq. (29))

\[\bm{A}(\bm{w}_{N}^{\sharp}-\eta(\mathcal{G}_{L}^{N}+\mathbf{L}(\mathcal{G}_{H}) )).\]

\(\bm{w}_{N}^{\sharp*}\) and \(\mathcal{G}_{L}^{N}\) share the same set of symbols, while they do not share any error symbols with \(\mathbf{L}(\mathcal{G}_{H})\), as linearization always generates new error symbols. This implies that the terms of \(\bm{A}(\bm{w}_{N}^{\sharp}-\eta\mathcal{G}_{L}^{N})\) and \(-\eta\bm{A}\mathbf{L}(\mathcal{G}_{H})\) will not cancel out. In other words, they contribute separately to the diameter \(\bm{k}\) of the merged box produced by IH. Therefore, we will look into their contributions separately.

For \(\bm{A}(\bm{w}_{N}^{\sharp}-\eta\mathcal{G}_{L}^{N})\), we substitute the definitions of \(\mathcal{G}_{L}^{N}\) and \(\bm{w}_{N}^{\sharp*}\) to get:

\[\bm{A}(\bm{w}_{N}^{\sharp}-\eta\mathcal{G}_{L}^{N}) =\bm{A}\Big{(}(1-2\eta\lambda)I-\frac{2\eta}{n}\bm{X}_{R}{}^{T} \bm{X}_{R}\Big{)}\bm{w}_{N}^{\sharp}\] (34) \[=\bm{A}\left((1-2\eta\lambda)I-\frac{2\eta}{n}\bm{X}_{R}{}^{T} \bm{X}_{R}\right)\bm{A}^{-1}\begin{bmatrix}k_{1}\epsilon_{1}\\ \vdots\\ k_{d}\epsilon_{d}\end{bmatrix}\] (expand \[\bm{w}_{N}^{\sharp}\] ) \[=\bm{A}\left(\bm{A}(1-2\eta\lambda)\bm{A}^{-1}-\frac{2\eta}{n} \bm{A}\bm{X}_{R}{}^{T}\bm{X}_{R}\bm{A}^{-1}\right)\bm{A}^{-1}\begin{bmatrix}k _{1}\epsilon_{1}\\ \vdots\\ k_{d}\epsilon_{d}\end{bmatrix}\] (122) \[=\left(\bm{A}(1-2\eta\lambda)\bm{A}^{-1}-\frac{2\eta}{n}\bm{A} \bm{X}_{R}{}^{T}\bm{X}_{R}\bm{A}^{-1}\right)\begin{bmatrix}k_{1}\epsilon_{1} \\ \vdots\\ k_{d}\epsilon_{d}\end{bmatrix}\] (123) \[=\left(\bm{A}(1-2\eta\lambda)\bm{A}^{-1}-\frac{2\eta}{n}\bm{A} \bm{X}_{R}{}^{T}\bm{X}_{R}\bm{A}^{-1}\right)\begin{bmatrix}k_{1}\epsilon_{1} \\ \vdots\\ k_{d}\epsilon_{d}\end{bmatrix}\] (124)

This contributes \(\Big{(}|1-2\eta\lambda-\frac{2\eta}{n}q_{i,i}|k_{i}+\frac{2\eta}{n}\sum_{j=i} ^{d}|q_{i,j}|k_{j}\Big{)}\) to the diameter of the merged box along dimension \(i\), where \(q_{i,j}\) is the element in \(\bm{A}\bm{X}_{R}{}^{T}\bm{X}_{R}\bm{A}^{-1}\) at position \((i,j)\). By choosing a small learning rate \(\eta\) to let \(1-2\eta\lambda-\frac{2\eta}{n}q_{i,i}\geq 0\) the contribution is equal to \(\Big{(}(1-2\eta\lambda-\frac{2\eta}{n}q_{i,i})k_{i}+\frac{2\eta}{n}\sum_{j=i} ^{d}|q_{i,j}|k_{j}\Big{)}\). From Eq. (34) it is obvious that this component has a shared term \(\bm{w}_{N}^{\sharp*}\) containing \(\bm{k}\) and as \(\bm{w}_{N}^{\sharp*}\) is centered at \(\bm{0}\), we know that this component has only symbolic terms. This in turn implies that this component only contributes to the coefficient matrix \(\bm{C}\) and does not contribute to the constant part \(\bm{c}_{0}\) of the system of linear equations.

Now consider the other component

\[-\eta\bm{A}\mathbf{L}(\mathcal{G}_{H})\] (125) \[= -\eta\bm{A}\mathbf{L}\left(\frac{2}{n}\Big{(}(\bm{X}_{R}{}^{T} \bm{X}_{S}^{\sharp}+\bm{X}_{S}^{\sharp}{}^{T}\bm{X}_{R})(\bm{w}_{D}^{\sharp} +\bm{w}_{N}^{\sharp})+\bm{X}_{S}^{\sharp}{}^{T}\bm{X}_{S}^{\sharp}(\bm{w}_{R} +\bm{w}_{D}^{\sharp}+\bm{w}_{N}^{\sharp})-\bm{X}_{S}^{\sharp}{}^{T}\bm{y}_{S} ^{\sharp}\Big{)}\right)\] (126) \[= -\eta\bm{A}\mathbf{L}\left(\frac{2}{n}\Big{(}(\underbrace{(\bm{X }_{R}{}^{T}\bm{X}_{S}^{\sharp}+\bm{X}_{S}^{\sharp}{}^{T}\bm{X}_{R}+\bm{X}_{S}^{ \sharp}{}^{T}\bm{X}_{S}^{\sharp})\bm{w}_{N}^{\sharp}}_{\text{contributes to $\bm{C}$}}\] (127) \[\qquad\qquad+\underbrace{(\bm{X}_{R}{}^{T}\bm{X}_{S}^{\sharp}+\bm {X}_{S}^{\sharp}{}^{T}\bm{X}_{R})\bm{w}_{D}^{\sharp}+\bm{X}_{S}^{\sharp}{}^{T} \bm{X}_{S}^{\sharp}(\bm{w}_{R}+\bm{w}_{D}^{\sharp})-\bm{X}_{S}^{\sharp}{}^{T} \bm{y}_{S}^{\sharp}}_{\text{contributes to $\bm{c}_{0}$}}\right)\]

Note that the first part of the equation is the only part that contains \(\bm{w}_{N}^{\sharp}\) which in turn contains the variables \(\bm{k}\) for which we want to solve. As every element of this part of the equation contains some \(k_{i}\) it only contributes to \(\bm{C}\). In contrast the second part of the equation does not contain any variable \(k_{i}\) and, thus, is the only part of both components that contribute to \(\bm{c}_{0}\). Let us use \(\frac{2\eta}{n}\bm{C}^{\prime}\bm{k}\) to denote the matrix of coefficients that is the sum of absolute values of coefficients of \(\frac{2}{n}(\boldsymbol{X}_{R}^{\,T}\boldsymbol{X}_{S}^{\sharp}+\boldsymbol{X}_{S} ^{\,\ddagger\,T}\boldsymbol{X}_{R}+\boldsymbol{X}_{S}^{\,\ddagger\,T}\boldsymbol {X}_{S}^{\ddagger\,T})\boldsymbol{w}_{N}^{\sharp}\) that will be projected by \(\boldsymbol{A}\) stemming from the first part of the equation in the expanded version of \(\mathbf{L}(\mathcal{G}_{H})\). We use \(c_{i,j}^{\prime}\geq 0\) to denote the element of \(\boldsymbol{C}^{\prime}\) at \((i,j)\). As mentioned before this is the only part of this component that contains terms containing unknowns \(k_{i}\). We use \(\boldsymbol{c}_{0}^{\prime}\) to denote the contribution from the second part of Eq. (37) towards the output of linearization \(\mathbf{L}\). Then based on the fact that the second part of this component is the only part of both components that contributes to \(\boldsymbol{c}_{0}\), we know that the whole contribution of the component from Eq. (36) towards \(\boldsymbol{C}+\boldsymbol{c}_{0}\) is:

\[\eta\boldsymbol{c}_{0}^{\prime}+\frac{2\eta}{n}\boldsymbol{C}^{\prime} \boldsymbol{k}\] (38)

In summary, the system of linear equations from Eq. (33) can be written as:

\[\Big{(}2\eta\lambda+\frac{2\eta}{n}q_{i,i}-\frac{2\eta}{n}c_{i,i} ^{\prime}\Big{)}k_{i}-\frac{2\eta}{n}\sum_{\begin{subarray}{c}j=1\\ j\neq i\end{subarray}}^{d}(|q_{i,j}|+c_{i,j}^{\prime})k_{j}=\eta c_{i,0}\quad s.t.\;k_{i}\geq 0\quad\forall i\in[1,d]\] \[\Leftrightarrow (\lambda n+q_{i,i}-c_{i,i}^{\prime})k_{i}-\sum_{\begin{subarray}{ c}j=1\\ j\neq i\end{subarray}}^{d}(|q_{i,j}|+c_{i,j}^{\prime})k_{j}=\frac{n}{2}c_{i,0} \quad s.t.\;k_{i}\geq 0\quad\forall i\in[1,d].\] (39)

In the expanded system of linear equations, the diagonal elements of the coefficient matrix are \((\lambda n+q_{i,i}-c_{i,i}^{\prime})\), while the off-diagonal elements are \(-(|q_{i,j}|+c_{i,j}^{\prime})\).

**Lemma I.6**.: _If for all \(i\in[1,d]\),_

\[(\lambda n+q_{i,i}-c_{i,i}^{\prime})\geq\sum_{\begin{subarray}{c}j=1\\ j\neq i\end{subarray}}^{d}(|q_{i,j}|+c_{i,j}^{\prime}),\]

_then the system of linear equations from Eq. (39) has a solution._

Proof.: When this condition holds, the coefficient matrix of this system of linear equations is diagonally dominant. Also considering all diagonal elements are non-negative (\((\lambda n+q_{i,i}-c_{i,i}^{\prime})\geq\sum_{\begin{subarray}{c}j=1\\ j\neq i\end{subarray}}^{d}(|q_{i,j}|+c_{i,j}^{\prime})\geq 0\)) and all off-diagonal elements are non-positive, the coefficient matrix is an M-matrix3. For any M-matrix \(\boldsymbol{M}\), the inverse \(\boldsymbol{M}^{-1}\) exists and is has all non-negative entries. Furthermore, for any system of linear equations represented as matrix equation \(\boldsymbol{M}\boldsymbol{x}=\boldsymbol{b}\) where \(\boldsymbol{x}\) are the variables of the equation system, \(\boldsymbol{M}^{-1}\boldsymbol{b}\) is a solution. As our matrix \(I-\boldsymbol{C}\) is an M-matrix, we know that its inverse exists and has only positive entries and we can compute a solution \(\boldsymbol{k}\) as:

Footnote 3: There are over 40 sufficient conditions for a matrix to be an M-matrix [56]. The one we use here requires that the matrix fulfills two conditions: (1) all off-diagonal elements are non-positive, and (2) each diagonal element is no less than the sum of absolute values of the off-diagonal elements at the same row (also known as diagonally dominant).

\[\boldsymbol{k}=(I-\boldsymbol{C})^{-1}\boldsymbol{c}_{0}\]

Given that all elements \(c_{i,0}\) are positive and that \((I-\boldsymbol{C})^{-1}\) is positive, the solution \(\boldsymbol{k}\) for Eq. (39) is also positive. 

The correctness of Thm. I.1 follows immediately based on the sufficient condition for the existence of solution stated in Lem. I.6,.

**Corollary I.7** (Proof of Thm. I.1).: _Given an input abstract training dataset \(\mathbf{D}^{\sharp}\), let \(\beta=\frac{1}{n}\max_{i}\big{(}\sum_{\begin{subarray}{c}j=1\\ j\neq i\end{subarray}}^{d}(|q_{i,j}|+c_{i,j}^{\prime})+c_{i,i}^{\prime}-q_{i,i} \big{)}\) For any regularization coefficient \(\lambda\geq\beta\), we can compute an abstract fixed point \(\boldsymbol{w}^{\sharp\,*}\) for the model weights according to Def. 3.2._

Proof.: To find an abstract fixed point of the model weights

\[\boldsymbol{w}^{\sharp\,*}=\boldsymbol{w}_{R}^{*}+\boldsymbol{w}_{D}^{\sharp \,*}+\boldsymbol{w}_{N}^{\sharp\,*}\]that fulfills the sufficient condition for an abstract fixed point from Prop. I.2, we first use the closed form solutions from Lem. I.4 to compute \(\bm{w}_{R}^{*}\) and then using \(\bm{w}_{R}^{*}\) compute \(\bm{w}_{D}^{\bm{i}\,*}\). These are guaranteed to fulfill the first two conditions of Prop. I.2. As the regularization coefficient \(\lambda\geq\beta=\frac{1}{n}\max_{i}\big{(}\sum_{\begin{subarray}{c}j=1\\ j\neq i\end{subarray}}^{d}(|q_{i,j}|+c^{\prime}_{i,j})+c^{\prime}_{i,i}-q_{i, i}\big{)}\), the condition from Lem. I.6 holds. Thus, the linear system of equations for a \(\bm{w}_{N}^{\bm{i}\,*}\) that fulfills the last condition of Prop. I.2 has a solution that we can compute using any techniques for solving a system of linear equation. It follows that \(\bm{w}^{\bm{i}\,*}=\bm{w}_{R}^{*}+\bm{w}_{D}^{\bm{i}\,*}+\bm{w}_{N}^{\bm{i}\,*}\) fulfills all conditions of Prop. I.2 and is an abstract fixed point according to Def. 3.2. 

## Appendix J Weakening the Requirements on Regularization

The existence of a fixed point \(\bm{w}^{\bm{j}\,*}\) as postulated in Thm. I.1 only holds for sufficiently large regularization \(\lambda\geq\beta\) where \(\beta\) depends on \(\mathbf{D}^{\sharp}\). The majority of real world examples without multiclinearity in the real part of the training data that we have investigated have \(\beta=0\). However, we still provide a technique to reduce \(\beta\) if the need should arise at the cost of increasing the runtime of our approach. Specifically, we will make use of _splitting_[2] which divides an input zonotope into multiple zonotopes of smaller expand. We apply splitting to \(\mathbf{D}^{\sharp}\), then compute the fixed point for each zonotope in the result of splitting, and finally combine these fixed point using a _join_ operation for zonotopes that over-approximates the union of the concretizations of two zonotopes (allows us to merge multiple zonotope such that the merged zonotope has a concretization that over-approximates the concretizations of all of the inputs). We will demonstrate that this approach enables us to reduce \(\beta\) to any value \(\geq 0\). Intuitively, this works because we can reduce the extend of the input zonotope for the fixed point computation to the extend necessary to ensure \(\beta=0\). Albeit in worst-case this can require a splitting operator that generates a number of zonotopes that is exponential in the dimension.

### Splitting and Join for zonotopes

Intuitively, a splitting operator divides an input zonotope into two or more zonotopes such that the union of their concretization is the same as the concretization of the input zonotope.

**Definition J.1** (Split Operator).: _An operator \(\mathbf{S}\) that maps a zonotope \(\bm{\ell}^{\sharp}\) to a set of zonotopes \(\{\bm{\ell}_{1}^{\sharp},\cdots,\bm{\ell}_{m}^{\sharp}\}\) is for any input zonotope \(\bm{\ell}^{\sharp}\) we have:_

\[\mathbf{S}(\bm{\ell}^{\sharp})=\{\bm{\ell}_{1}^{\sharp},\cdots,\bm{\ell}_{m}^ {\sharp}\}\quad s.t.\bigcup_{i}\gamma\left(\bm{\ell}_{i}^{\sharp}\right)= \gamma\left(\bm{\ell}^{\sharp}\right)\,.\]

As an example of a split operator consider the binary split (2-split) at dimension \(i\) denoted by \(\mathbf{S}_{2,i}\) that splits the input zonotope into two parts by scaling the \(i^{th}\) generator \(\bm{g}_{i}\) by \(\frac{1}{2}\) and shifting the center of the zonotope by \(\frac{1}{2}\bm{g}_{i}\) (\(-\frac{1}{2}\bm{g}_{i}\)):

\[\mathbf{S}_{2,i}(\bm{\ell}^{\sharp})=\Big{\{}\bm{\ell}_{1}^{\sharp },\bm{\ell}_{2}^{\sharp}\Big{\}} =\Big{\{}\bm{c}+\underbrace{\sum_{j}\bm{g}_{j}\epsilon_{j}}_{ \begin{subarray}{c}\epsilon_{i}\in[-1,0]\\ \text{other }\epsilon_{j}\in[-1,1]\end{subarray}},\bm{c}+\underbrace{\sum_{j} \bm{g}_{j}\epsilon_{j}}_{\begin{subarray}{c}\epsilon_{i}\in[0,1]\\ \text{other }\epsilon_{j}\in[-1,1]\end{subarray}}\Big{\}}\] \[=\Big{\{}\bm{c}-\frac{1}{2}\bm{g}_{i}+\frac{1}{2}\bm{g}_{i} \epsilon_{i}+\sum_{j\neq i}\bm{g}_{j}\epsilon_{j},\quad\bm{c}+\frac{1}{2}\bm{g} _{i}+\frac{1}{2}\bm{g}_{i}\epsilon_{i}+\sum_{j\neq i}\bm{g}_{j}\epsilon_{j} \Big{\}}\] (40)

As \(\gamma\left(\bm{\ell}_{1}^{\sharp}\right)\cup\gamma\left(\bm{\ell}_{2}^{\sharp }\right)=\gamma\left(\bm{\ell}^{\sharp}\right)\), \(\mathbf{S}_{2,i}(\cdot)\) is a split operator according to Def. J.1. We can generalize 2-split to an \((m,i)\)-split \(\mathbf{S}_{m,i}\) that divides the zonotope evenly into \(m\) parts along the \(i^{th}\) dimension. We will call the composition of \((m,i)\)-splits across all dimensions as a \(\mu\)-split. Given \(\mu=\frac{1}{m}\) for \(m\in\mathbb{N}\) as input, the effect of the \(\mu\)-split \(\mathbf{S}_{\mu}\) is the generators of each zonotope in the result of splitting are the generators of the input zonotope scaled by \(\mu\). Thus, \(\mu\)-splitting allows us to downscale the generators of a zonotope. For a \(d\)-dimensional zonotope and \(\mu=\frac{1}{m}\), \(\mathbf{S}_{\mu}\) returns \(d^{m}\) zonotopes.

**Definition J.2** (\(\mu\)-split).: _For \(d\)-dimensional zonotopes and \(\mu=\frac{1}{m}\) for \(m\in\mathbb{N}\), the \(\mu\)-split \(\mathbf{S}_{\mu}\) is defined as:_

\[\mathbf{S}_{m,d}\circ\ldots\circ\mathbf{S}_{m,1}\]_where the \((m,i)\)-split \(\mathbf{S}_{m,i}\) is defined as shown below and the application of a split operator to a set of zonotopes is defined as applying the split operator to every element in the set._

\[\mathbf{S}_{m,i}(\boldsymbol{\ell}^{\sharp})=\{\boldsymbol{\ell}^{\sharp}_{i} \}_{j=1}^{m}\]

_for_

\[\boldsymbol{\ell}^{\sharp}_{j}=\boldsymbol{c}+\frac{-m+2j-1}{m}\boldsymbol{g} _{i}\epsilon_{i}+\sum_{j\neq i}\boldsymbol{g}_{j}\epsilon_{j}\]

For example, \(\mathbf{S}_{2}(1+\epsilon_{1})=\{0.5+0.5\epsilon_{1},1.5+0.5\epsilon_{1}\}\). It is easy to see that \(\mathbf{S}_{\mu}\) is indeed a split according to Def. J.1.

**Proposition J.3** (\(\mathbf{S}_{\mu}\) is a Split Operator).: \(\mathbf{S}_{\mu}\) _is a split operator for any \(\mu=\frac{1}{m}\) were \(m\in\mathbb{N}\)._

Next we introduce join operators for zonotopes and then demonstrate that for any abstract transformer \(F^{\sharp}\) for a function \(F\), we can construct another abstract transformer for \(F\) by (i) splitting the input zonotope using some split operator \(\mathbf{S}\), (ii) applying \(F^{\sharp}\) separately on each zonotope returned by the split, and (iii) merge the results using a join that we introduce next.4

Footnote 4: Technically, join is normally defined as an over-approximation of the least upper bound of two abstract elements wrt. a partial order of the abstract domain. We order abstract elements based on set inclusion of their concretizations here and only define join regarding to this partial order.

**Definition J.4** (Join).: _An operator \(\sqcup\) is a join for zonotopes if it over-approximates union of concretization. That is, for any set \(S^{\sharp}\) of zonotopes:_

\[\gamma\left(\bigsqcup S^{\sharp}\right)\supseteq\bigcup_{\boldsymbol{z}^{ \sharp}\in S^{\sharp}}\gamma\left(\boldsymbol{z}^{\sharp}\right).\]

Several join operators have been proposed for zonotopes, e.g., [24]. Next we establish that new abstract transformers can be constructed by wrapping existing transformers with split and join. This ensures that our approach of combining our abstract fixed point calculation with splitting yields valid fixed points.

**Lemma J.5** (Abstract Transformers Are Sound on Splits).: _Consider a zonotope \(\boldsymbol{z}^{\sharp}\) and let \(F^{\sharp}\) be an abstract transformer for a function \(F\). Furthermore, let \(\sqcup\) be a join operator, \(\mathbf{S}\) be a split operator, and let \(\mathbf{S}(\boldsymbol{\ell}^{\sharp})=\{\boldsymbol{\ell}^{\sharp}_{1}, \ldots,\boldsymbol{\ell}^{\sharp}_{m}\}\). Then, \(F_{\mathbf{S},\sqcup}{}^{\sharp}=\sqcup\circ F^{\sharp}\circ\mathbf{S}\) is an abstract transformer for \(F\)._

Proof.: We have to show that

\[\gamma\left(F_{\mathbf{S},\sqcup}{}^{\sharp}(\boldsymbol{\ell}^{\sharp}) \right)\supseteq F(\gamma\left(\boldsymbol{\ell}^{\sharp}\right)).\]

We have

\[F(\gamma\left(\boldsymbol{\ell}^{\sharp}\right))\] \[= F(\bigcup_{\boldsymbol{\ell}^{\sharp}\in\mathbf{S}(\boldsymbol {\ell}^{\sharp})}\gamma\left(\boldsymbol{\ell}^{\sharp^{\prime}}\right))\] (Def. J.1 for \[\mathbf{S}\] ) \[= F(\bigcup_{i=1}^{m}\gamma\left(\boldsymbol{\ell}^{\sharp}_{i}\right))\] \[= \bigcup_{i=1}^{m}F(\gamma\left(\boldsymbol{\ell}^{\sharp}_{i}\right))\] (function application on sets of concrete elements is point-wise application) \[\subseteq \bigcup_{i=1}^{m}\gamma\left(F^{\sharp}(\boldsymbol{\ell}^{\sharp} _{i})\right)\] ( \[F^{\sharp}\] is an abstract transformer) \[\subseteq \gamma\left(\left\sqcup_{i=1}^{m}F^{\sharp}(\boldsymbol{\ell}^{ \sharp}_{i})\right)\] ( \[\gamma\left(\boldsymbol{z}^{\sharp}_{1}\sqcup\boldsymbol{z}^{ \sharp}_{2}\right)\supseteq\gamma\left(\boldsymbol{z}^{\sharp}_{1}\right)\cup \gamma\left(\boldsymbol{z}^{\sharp}_{2}\right)\] ) \[= \gamma\left(F_{\mathbf{S},\sqcup}{}^{\sharp}(\boldsymbol{\ell}^{ \sharp})\right)\]

### Weakening Regularization Requirements

Equipped with the \(\mu\)-split and a join operator, we are ready to analyze how the introduction of a \(\mu\)-split can be used to achieve an arbitrarily small \(\beta\). Given the input data \(\mathbf{D}^{\sharp}\), the learning rate \(\eta\geq\beta\), the regularization coefficient \(\lambda\), the transformation matrix \(\bm{A}\), we use \(\Gamma(\mathbf{D}^{\sharp},\eta,\lambda,\bm{A})\) to denote the function that computes the fixed point \(\bm{w}_{\mathcal{S}}^{\bm{\sharp}\,*}\) for these inputs using the process outlined in Corollary 1.7. From Lem. 1.5 follows that \(\Gamma_{\mathbf{S}_{\mu},\sqcup}\) is an abstract transformer for gradient descent and, thus, according to Prop. 3.3 over-approximates \(\bm{w}^{\odot\ast}\)

Next, we show that given an abstract training dataset \(\mathbf{D}^{\sharp}\) and a desired regularization coefficient \(\lambda_{target}\), we can find a value of \(\mu\) such that the abstract fixed point construction with \(\mu\)-splitting computes a fixed point. Recall that \(\Gamma\) can construct a fixed point if \(\lambda\geq\beta\) where \(\beta\) is a constant that depends on \(\mathbf{D}^{\sharp}\). We will show that by choosing \(\mu\) carefully, we can achieve \(\beta\leq\lambda_{target}\) for each zonotope in the result of the split and, thus, \(\Gamma\) will return a valid fixed point for each zonotope in the split result.

**Lemma J.6**.: _For any abstract training dataset \(\mathbf{D}^{\sharp}\) and desired regularization coefficient \(\lambda\), there exists \(m\in\mathbb{N}\) such that for \(\mu=\frac{1}{m}\), \(\Gamma_{\mathbf{S}_{\mu},\sqcup}\) returns a fixed point \(\bm{w}^{\sharp\,*}\)._

Proof.: Consider an abstract training dataset \(\mathbf{D}^{\sharp}=(\bm{X}^{\sharp},\bm{y}^{\sharp})\) with \(\bm{X}^{\sharp}=\bm{X}_{R}+\bm{X}_{S}^{\sharp}\). WLOG consider a single abstract training dataset \(\mathbf{D}^{\sharp}_{i}\) in the result of \(\mu\)-split on \(\mathbf{D}^{\sharp}\):

\[\mathbf{D}^{\sharp}{}_{i}\in\mathbf{S}_{\mu}(\mathbf{D}^{\sharp})\]

We will show that using the regularization coefficient \(\lambda\), we can find \(\mu\) such that the precondition \(\lambda\geq\beta\) for \(\Gamma\) to compute a fixed point holds. Then applying Lem. 1.5 we get the desired result.

First observe that since \(\mathbf{D}^{\sharp}{}_{i}\) is in the result of \(\mu\)-splitting, we know that it has the following shape where the symbolic component \(\bm{X}_{S}^{\sharp}\) is scaled by \(\mu\) and the real component \(\bm{X}_{R\,i}\) of \(\mathbf{D}^{\sharp}{}_{i}\) typically differs from \(\bm{X}^{\sharp}\) as \(\mu\)-splitting changes the center of the zonotope.

\[\bm{X}^{\sharp}{}_{i}=\bm{X}_{R\,i}+\mu\bm{X}_{S}^{\sharp}\]

Recall that \(\frac{2\eta}{n}\bm{C}^{\prime}\bm{k}\) denotes the matrix of coefficients that is the sum of absolute values of coefficients of \(\frac{2}{n}\bm{A}(\bm{X}_{R}{}^{T}\bm{X}_{S}^{\sharp}+\bm{X}_{S}^{\sharp}{}^ {T}\bm{X}_{R}+\bm{X}_{S}^{\sharp}{}^{T}\bm{X}_{S}^{\sharp})\bm{w}_{N}^{\sharp}\). Plugging in the definition of \(\bm{X}^{\sharp}{}_{i}\) from above, we get a matrix \(\frac{2\eta}{n}\bm{C}^{\prime}\bm{k}\) that is the sum of absolute values of coefficients of

\[\frac{2}{n}\bm{A}(\bm{X}_{R\,i}{}^{T}\mu\bm{X}_{S}^{\sharp}+\mu \bm{X}_{S}^{\sharp}{}^{T}\bm{X}_{R\,i}+\mu\bm{X}_{S}^{\sharp}{}^{T}\mu\bm{X}_{ S}^{\sharp})\bm{w}_{N}^{\sharp}\] (41) \[= \frac{2}{n}\bm{A}(\mu\bm{X}_{R\,i}{}^{T}\bm{X}_{S}^{\sharp}+\mu \bm{X}_{S}^{\sharp}{}^{T}\bm{X}_{R\,i}+\mu^{2}\bm{X}_{S}^{\sharp}{}^{T}\bm{X}_{ S}^{\sharp})\bm{A}^{-1}\begin{bmatrix}k_{1}\epsilon_{1}\\ \vdots\\ k_{d}\epsilon_{d}\end{bmatrix}\] (42) \[= \bigg{(}\underbrace{\frac{2\mu}{n}\bm{A}(\bm{X}_{R\,i}{}^{T}\bm{X }_{S}^{\sharp}+\bm{X}_{S}^{\sharp}{}^{T}\bm{X}_{R\,i})\bm{A}^{-1}}_{\text{ contributes to }c_{i,j}^{1}}+\underbrace{\frac{2\mu^{2}}{n}\bm{A}(\bm{X}_{S}^{\sharp}{}^{T}\bm{X}_{S}^{ \sharp})\bm{A}^{-1}}_{\text{ contributes to }c_{i,j}^{2}}\bigg{)}\begin{bmatrix}k_{1}\epsilon_{1}\\ \vdots\\ k_{d}\epsilon_{d}\end{bmatrix}.\] (43)

Recall that \(c_{i,j}^{\prime}\) denotes entry of \(\bm{C}^{\prime}\) at row \(i\) and column \(j\). Here, \(\bm{X}_{S}^{\sharp}{}^{T}\bm{X}_{S}^{\sharp}\) has higher order than \((\bm{X}_{R}{}^{T}\bm{X}_{S}^{\sharp}+\bm{X}_{S}^{\sharp}{}^{T}\bm{X}_{R})\), thus their terms will not cancel out. Therefore, we can decompose the contribution to \(c_{i,j}^{\prime}\) into the above two parts, denoted as

\[c_{i,j}^{\prime}=c_{i,j}^{1}+c_{i,j}^{2}.\]

Given scalar \(\mu\), let

\[c_{\mu}^{\prime}=\max_{u,v}c_{u,v}^{\prime}\]

i.e., \(c_{\mu}^{\prime}\) denotes the largest entry \(c_{i,j}^{\prime}\) in \(\mathbf{D}^{\sharp}{}_{i}\).

Let \(i\) and \(j\) such that \(c^{\prime}_{\mu}=c^{\prime}_{i,j}\), we have:

\[c^{\prime}_{\mu}=\mu c^{1}_{i,j}+\mu^{2}c^{2}_{i,j}\leq\mu c^{1}_{i,j}+\mu c^{2} _{i,j}=\mu c^{\prime}_{max},\]

where \(c^{\prime}_{max}\) is a constant that is equal to the maximum \(c^{\prime}_{i,j}\) before scaling \(\bm{X}^{\sharp}_{S}\) through \(\mu\)-splitting.

Next, we prove the lemma for a specific transformation \(\bm{A}=V^{T}\) during order reduction derived through singular value decomposition (SVD). Using SVD, we can decompose the covariance matrix \(\bm{X}_{R_{i}}^{T}\bm{X}_{R_{i}}\) of the real number part of features \(\bm{X}_{R_{i}}\) as shown below

\[\bm{X}_{R_{i}}^{T}\bm{X}_{R_{i}}=V\Sigma V^{T}.\]

For \(\bm{A}=V^{T}\), and using the fact that \(V\) is a rotation in SVD which implies \(V^{-1}=V^{T}\), we get:

\[\bm{A}\bm{X}_{R_{i}}^{T}\bm{X}_{R_{i}}\bm{A}^{-1}\] \[= \bm{A}(V\Sigma V^{T})\bm{A}^{-1}\] \[= V^{T}(V\Sigma V^{T})V^{T-1}\] \[= (V^{-1}V)\Sigma(V^{-1}{V^{-1}}^{-1})\] \[= \Sigma\]

Thus, the matrix \(\bm{A}\bm{X}_{R_{i}}^{T}\bm{X}_{R_{i}}\bm{A}^{-1}=\Sigma\) is a diagonal matrix, meaning that all off-diagonal elements of it (\(|q_{i,j}|\) for all (\(i\neq j\)) in Corollary I.7) are zero. In addition, the diagonal element \(\Sigma[i,i]\) (\(q_{i,i}\) in Corollary I.7) is the \(i^{th}\) eigenvalue of the covariance matrix \(\bm{X}_{R_{i}}^{T}\bm{X}_{R_{i}}\), which must be positive when assuming no multicolinearity.

To sum up, \(\beta\) from Corollary I.7 can be re-written as:

\[\beta =\frac{1}{n}\max_{i}\big{(}c^{\prime}_{i,i}+\sum_{\begin{subarray} {c}j=1\\ j\neq i\end{subarray}}^{d}\left(|q_{i,j}|+c^{\prime}_{i,j}\right)-q_{i,i}\big{)}\] (44) \[\leq\frac{1}{n}\max_{i}\big{(}c^{\prime}_{\mu}+\sum_{ \begin{subarray}{c}j=1\\ j\neq i\end{subarray}}^{d}c^{\prime}_{\mu}-q_{i,i}\big{)}\] (45) \[\leq\frac{1}{n}\max_{i}\big{(}\mu c^{\prime}_{max}+\sum_{ \begin{subarray}{c}j=1\\ j\neq i\end{subarray}}^{d}\mu c^{\prime}_{max}-q_{i,i}\big{)}\] (46) \[=\frac{1}{n}\max_{i}\big{(}d\mu c^{\prime}_{max}-q_{i,i}\big{)}= \frac{1}{n}d\mu c^{\prime}_{max}-\frac{1}{n}\min_{i}(q_{i,i})\] (47)

where \(\frac{1}{n}\min_{i}(q_{i,i})\) is a positive constant. Therefore, when setting \(\mu=\frac{\min_{i}(q_{i,i})}{dc_{max}}>0\), we have \(\beta\leq\frac{1}{n}d\mu c^{\prime}_{max}-\frac{1}{n}\min_{i}(q_{i,i})=0\). 

## Appendix K An Approximate Abstract Transformer for Ridge Regression

Alg. 2 is the detailed version of Alg. 1 we presented in the main paper. Like Alg. 1, Alg. 2 takes as input an abstract dataset \(\bm{D^{\sharp}}\) that over-approximates \(\bm{D}^{\odot}\), a learning rate \(\eta\), a regularization coefficient \(\lambda\), and a transformation matrix \(\bm{A}\) used for order reduction (e.g., the SVD-based transformation discussed in App. J.2). In Line 1, we first use function constructFPEquations to compute fixed points for \(\bm{w}^{\sharp}_{R}\) and \(\bm{w}^{\sharp}_{D}\) using the closed form solution from Lem. I.4 and construct the equation system \(\Xi\) for \(\bm{w}^{\sharp\ast}_{N}\) (Eq. (39)). Furthermore, this function also computes the threshold \(\beta\) on the regularization coefficient for this system of equations to have a solution. If \(\beta\) is smaller or equal to the desired regularization coefficient \(\lambda\) (Line 10), then we solve the linear equations \(\Xi\) (Line 11) and then returns the fixpoint \(\bm{w}^{\sharp\ast}\). Otherwise, we determine a sufficiently small splitting factor \(\mu\) that ensures that \(\beta\leq\lambda\) for each \(\bm{w}^{\sharp}_{i}\) in the result of the split (Line 3), compute the fixed point for each such \(\bm{w}^{\sharp}_{i}\) (Lines 6 and 8), and merge these fixed points using join to compute the final result (Line 9).

## Appendix L Infeasibility of Symbolically Evaluating the Closed-form Solution for Ridge Regression

In this section, we demonstrate why evaluating the closed-form solution for linear regression with MSE is not feasible. It produces symbolic expressions with many variables and large symbolic terms (their representation size) that include the fractions with denominators and enumerators that are polynomial expressions. Apart from the size of these expressions, computing viable prediction intervals from such a symbolic representation of model weights is computationally hard. We use MSE loss for simplicity, but the same arguments also apply to ridge regression.

We illustrate the issues using a randomly-generated toy dataset with 10 samples and 3 uncertain data cells in the third column (corresponding to 3 error symbols \(\epsilon_{0},\epsilon_{1},\epsilon_{2}\))5:

Footnote 5: The first column of \(\bm{X}^{\ddagger}\) consisting of 1’s corresponds to the bias term or the intercept term in the weights.

\[\bm{X}^{\ddagger}=\begin{bmatrix}1.0&1.6&1.3\epsilon_{0}+1.4\\ 1.0&0.8&1.5\\ 1.0&-1.7&-1.9\\ 1.0&-0.57&1.1\\ 1.0&-0.39&0.36\\ 1.0&0.035&1.2\\ 1.0&-0.34&-0.73\\ 1.0&0.038&0.3\epsilon_{1}+0.44\\ 1.0&1.5&1.2\epsilon_{2}+1.3\\ 1.0&-0.98&-0.66\\ \end{bmatrix}\quad\bm{y}^{\ddagger}=\begin{bmatrix}4.6\\ -1.5\\ 0.39\\ -5.7\\ -3.0\\ -0.44\\ -3.0\\ 2.2\\ -3.0\\ \end{bmatrix}\]

``` Input: abstract dataset \(\mathbf{D}^{\ddagger}=(\bm{X}^{\ddagger},\bm{y}^{\ddagger})\), learning rate \(\eta\), Regularization coefficient \(\lambda\), transformation matrix \(\bm{A}\) Output: abstract fixed point \(\bm{w}^{\ddagger}\)1 \(\bm{w}^{\ddagger}_{R}\), \(\bm{w}^{\ddagger}_{D}\), \(\Xi,\beta\leftarrow\texttt{constructFPequations}(\mathbf{D}^{\ddagger}, \lambda,\eta)\) if\(\beta>\lambda\)then // Is splitting necessary? \(\mu\leftarrow\texttt{determineNumSplits}(\Xi,\lambda)\) \(\{\mathbf{D}^{\ddagger}_{i}\}_{i=1}^{m}\leftarrow\mathbf{S}_{\mu}(\mathbf{D}^{ \ddagger})\) // Apply \(\mu\)-splitting for\(\mathbf{D}^{\ddagger}_{i}\in\{\mathbf{D}^{\ddagger}\}_{i=1}^{m}\)do// Construct FP for each \(\mathbf{D}^{\ddagger}_{i}\) in the split \(\bm{w}^{\ddagger}_{i}\), \(\bm{w}^{\ddagger}_{N}\), \(\Xi,\beta\leftarrow\texttt{constructFPequations}(\mathbf{D}^{\ddagger}_{i}, \lambda,\eta)\) \(\bm{w}^{\ddagger}_{N}\leftarrow\texttt{solveFixedPointEquations}(\Xi, \lambda,\eta)\) \(\bm{w}^{\ddagger}_{i}\leftarrow\bm{w}^{\ddagger}_{R}+\bm{w}^{\ddagger}_{D}+ \bm{w}^{\ddagger}_{N}\) return\(\bigsqcup_{i=1}^{m}\bm{w}^{\ddagger}_{i}\) // Merge FPs using Join // No splitting required
1else // No splitting required
2 \(\bm{w}^{\ddagger}_{N}\leftarrow\texttt{solveFixedPointEquations}(\Xi, \lambda,\eta)\) \(\bm{w}^{\ddagger}\leftarrow\bm{w}^{\ddagger}_{N}+\bm{w}^{\ddagger}_{D}+\bm{w} ^{\ddagger}_{N}\) return\(\bm{w}^{\ddagger}\) ```

**Algorithm 2**Constructing a Fixed Point for Abstract Gradient Descent

## Appendix L Infeasibility of Symbolically Evaluating the Closed-form Solution for Ridge Regression

In this section, we demonstrate why evaluating the closed-form solution for linear regression with MSE is not feasible. It produces symbolic expressions with many variables and large symbolic terms (their representation size) that include the fractions with denominators and enumerators that are polynomial expressions. Apart from the size of these expressions, computing viable prediction intervals from such a symbolic representation of model weights is computationally hard. We use MSE loss for simplicity, but the same arguments also apply to ridge regression.

We illustrate the issues using a randomly-generated toy dataset with 10 samples and 3 uncertain data cells in the third column (corresponding to 3 error symbols \(\epsilon_{0},\epsilon_{1},\epsilon_{2}\))5:

Footnote 5: The first column of \(\bm{X}^{\ddagger}\) consisting of 1’s corresponds to the bias term or the intercept term in the weights.

\[\bm{X}^{\ddagger}=\begin{bmatrix}1.0&1.6&1.3\epsilon_{0}+1.4\\ 1.0&0.8&1.5\\ 1.0&-1.7&-1.9\\ 1.0&-0.57&1.1\\ 1.0&-0.39&0.36\\ 1.0&0.035&1.2\\ 1.0&-0.34&-0.73\\ 1.0&0.038&0.3\epsilon_{1}+0.44\\ 1.0&1.5&1.2\epsilon_{2}+1.3\\ 1.0&-0.98&-0.66\\ \end{bmatrix}\quad\bm{y}^{\ddagger}=\begin{bmatrix}4.6\\ -1.5\\ 0.39\\ -5.7\\ -3.0\\ -0.44\\ -3.0\\ -3.0\\ \end{bmatrix}\]
Then, symbolically evaluating the closed-form solution for linear regression with MSE loss, we obtain the symbolic expression representing all possible model weights:

\[\bm{w}^{\sharp\,*} =(\bm{X}^{\sharp T}\bm{X}^{\sharp})^{-1}\bm{X}^{\sharp T}\bm{y}^{ \sharp}\] \[=\begin{bmatrix}\frac{1.5\cdot 10^{6}\epsilon_{2}^{2}+8.7\cdot 10^{4 }\epsilon_{0}\epsilon_{1}-4.5\cdot 10^{5}\epsilon_{0}\epsilon_{2}-1.2\cdot 10^{6} \epsilon_{0}+9.2\cdot 10^{4}\epsilon_{2}^{2}+4.0\cdot 10^{5}\epsilon_{1} \epsilon_{2}-2.4\cdot 10^{5}\epsilon_{1}+1.0\cdot 10^{6}\epsilon_{2}^{2}-2.1 \cdot 10^{6}\epsilon_{2}-1.8\cdot 10^{6}}{-1.1\cdot 10^{6}\epsilon_{2}^{2}+8.4 \cdot 10^{4}\epsilon_{0}\epsilon_{1}+1.1\cdot 10^{6}\epsilon_{0} \epsilon_{2}+1.1\cdot 10^{6}\epsilon_{2}-8.3\cdot 10^{4}\epsilon_{2}^{2}+7.7 \cdot 10^{4}\epsilon_{1}\epsilon_{2}+6.1\cdot 10^{3}\epsilon_{1}-9.9 \cdot 10^{5}\epsilon_{2}^{2}+9.5\cdot 10^{6}\epsilon_{2}-4.0\cdot 10^{6}}\\ -9.5\cdot 10^{4}\epsilon_{2}^{3}+2.3\cdot 10^{4}\epsilon_{0}\epsilon_{1}+2.6 \cdot 10^{5}\epsilon_{0}\epsilon_{2}+2.3\cdot 10^{5}\epsilon_{0}-1.4\cdot 10^{4} \epsilon_{1}^{2}+2.0\cdot 10^{4}\epsilon_{2}+3.6\cdot 10^{4}\epsilon_{1}-1.4 \cdot 10^{5}\epsilon_{2}^{2}-6.0\cdot 10^{2}\epsilon_{2}-1.8\cdot 10^{6}}{-1.1 \cdot 10^{5}\epsilon_{0}^{6}+8.4\cdot 10^{6}\epsilon_{1}+1.1\cdot 10^{5}\epsilon_{ 2}+1.1\cdot 10^{6}\epsilon_{0}-8.3\cdot 10^{6}\epsilon_{1}^{2}+7.7 \cdot 10^{5}\epsilon_{2}+6.1\cdot 10^{2}\epsilon_{1}-9.9\cdot 10^{4}\epsilon_{2}^{2}+9.5 \cdot 10^{2}\epsilon_{2}-4.0\cdot 10^{5}}\end{bmatrix}.\]

Next, we consider one test sample \(\bm{x_{t}}=[1,-1,1]\) and apply this closed-form model weight expression to infer its prediction range \(V^{\sharp}(\bm{x_{t}})\) (cf. Corollary F.2). With _merely_ 3 uncertain data points in the training data, the prediction of this test data point

\[\begin{split}\dot{\bm{y_{t}}}=&\bm{w^{\sharp\,*}} \bm{x_{t}}\\ =&-\frac{3.7\cdot 10^{3}\epsilon_{0}+4.1\cdot 10^{2} \epsilon_{1}+9.2\cdot 10^{2}\epsilon_{2}-1.3\cdot 10^{4}}{-1.1\cdot 10^{2} \epsilon_{0}^{2}+8.4\cdot 10^{4}\epsilon_{2}+1.1\cdot 10^{4}\epsilon_{0}-8.3 \cdot 10^{4}\epsilon_{1}^{2}+7.7\cdot 10^{4}\epsilon_{2}+6.1\cdot 10^{4} \epsilon_{1}-9.9\cdot 10^{2}\epsilon_{2}^{2}-4.0\cdot 10^{3}}{+9.5\cdot 10^{4} \epsilon_{2}^{2}-2.3\cdot 10^{4}\epsilon_{1}-2.6\cdot 10^{2}\epsilon_{2}+1.8 \cdot 10^{6}}\\ &+\frac{9.5\cdot 10^{4}\epsilon_{2}^{2}-3.10^{4}\epsilon_{0}-2.6 \cdot 10^{5}\epsilon_{0}+2.2\cdot 10^{5}\epsilon_{0}+1.4\cdot 10^{4} \epsilon_{2}^{2}-2.0\cdot 10^{4}\epsilon_{1}-2.3\cdot 10^{4}\epsilon_{1}+1.4 \cdot 10^{5}\epsilon_{2}^{2}+6.0\cdot 10^{2}\epsilon_{2}+1.8\cdot 10^{6}}{-1.1 \cdot 10^{5}\epsilon_{0}^{6}+8.4\cdot 10^{5}\epsilon_{1}+1.1\cdot 10^{5}\epsilon_{0}^{6} +8.1\cdot 10^{5}\epsilon_{2}+1.1\cdot 10^{5}\epsilon_{0}-8.3\cdot 10^{4} \epsilon_{1}^{2}+7.7\cdot 10^{5}\epsilon_{2}^{2}+6.1\cdot 10^{2}\epsilon_{1}-9.9 \cdot 10^{4}\epsilon_{2}^{2}+9.5\cdot 10^{4}\epsilon_{2}-4.0\cdot 10^{5}}\\ &+\frac{1.5\cdot 10^{6}\epsilon_{2}^{2}+8.7\cdot 10^{4}\epsilon_{0} \epsilon_{1}-4.5\cdot 10^{5}\epsilon_{0}-12.1\cdot 10^{6}\epsilon_{0}+9.2\cdot 10^{4} \epsilon_{1}^{2}+4.0\cdot 10^{3}\epsilon_{1}^{2}-2.4\cdot 10^{5}\epsilon_{1}+1.0 \cdot 10^{6}\epsilon_{2}^{2}-2.1\cdot 10^{6}\epsilon_{2}-1.8\cdot 10^{6}}{-1.1 \cdot 10^{6}\epsilon_{2}^{2}+8.4\cdot 10^{4}\epsilon_{0}^{4}+1.1\cdot 10^{6}\epsilon_{0} +2.1\cdot 10^{6}\epsilon_{0}-8.3\cdot 10^{4}\epsilon_{1}^{2}+7.7\cdot 10^{4}\epsilon_{ 1}+2.6\cdot 1.10^{4}\epsilon_{1}-9.9\cdot 10^{5}\epsilon_{2}^{2}+9.5\cdot 10^{5}\epsilon_{2}-4.0 \cdot 10^{6}}\end{split}\] (48)

already consists of fractions of complex polynomial expressions. Finding the viable prediction range for this data point, i.e. the minimum and maximum possible prediction for the point across all models in the concretization of the symbolic expression, using this expression is infeasible, as it is harder than finding an extrema for multivariate polynomials under linear constraints6, which is known to be NP-hard. In practice, expressions will be significantly larger as they will involve more error symbols. Assume each column has \(p\) uncertain cells, and \(q\) is the number of uncertain labels, the number of distinct monomials is \(O(p^{d}d^{2a}q)\), where \(d\) is the number of dimensions, and the \(d\) in exponents mainly comes from the matrix inversion when computing the determinant.

Footnote 6: The expression is a sum of fractions in which both numerator and denominators are multivariate polynomial expressions. The range \([-1,1]\) for each error symbol can be formulated as linear constraints over the input space.

In summary, the symbolic expressions obtained from symbolically evaluating the closed-form solution for linear regression are not suitable for representing the space of possible model weights.

## Appendix M Additional Experiments

### Robustness Verification Additional Results

For a better comparison with Meyer[47], we use heatmaps to visualize the robustness ratios averaged over 5 repeated experiments with different random seeds. In App. M.1, Zorro exhibits much less yellow regions (representing higher uncertainty) compared to Meyer. Especially when the uncertainty is high (bottom-right part), there are many cases that Zorro returns high robustness ratio but Meyer does not. Recall that both approach gives sound over-approximation of prediction robustness, thus the robustness ratios returned by both are lower bounds of the ground truth prediction robustness ratio. Therefore, the aforementioned cases correspond to highly robust ground truth (no less than the result of Zorro), where Zorro gives tight over-approximations but Meyer does not.

### Micro Benchmark

We use range of loss as the metric to measure the quality (tightness) of uncertain training result. range of loss for samples are calculated by max loss - min loss across all sampled results. Loss range for symbolic representations are calculated my measuring the range of the interval concretization of the loss function result. Notice that samplings return a subset of all possible result which has no soundness guarantees, as a result, produces an under-approximation of the loss range. The symbolic fixed point approach produces an over-approximated loss range. We take 1,000 (1k) and 10,000 (10k) samples from all possible worlds as under approximations to the concrete range when number of possible worlds are to large to compute the ground truth range.

#### Varying ratio of tuples contains uncertain data

Figure 5(a) shows the loss range results while updating the ratio of uncertain rows from 0.01 to 0.12. Zorro has a tight range considering all samples are under approximations of ground truth range especially in. As uncertainty increases, the over-approximation gap widens due to the increased coefficient of higher order terms in the gradient, which are linearized, leading to higher linearization errors.

#### Increasing uncertainty radius

Figure 5(b) shows the result by increasing the radius of uncertain data (imputation results) by multiplier of 0.06 to 0.44 where 0.06 means the range for each uncertain data is increased by 6%. Similar to amount of uncertainty,

#### Varying dimensions

Figure 5(c) shows the result by change number of dimensions to the training data. Result indicates tightness of Zorro's over-approximation is not affected by the dimension of the data.

Figure 7 added sampling result to Figure 3 shows additionally that sampling result is an under approximation of the ground truth result.

### Additional Experiments on Varying Regularization Coefficients

Fig. 8 shows the effect of varying regularization coefficients on the worst-case loss and prediction robustness ratio. To avoid much overlapping in the plots, we used one standard deviation as the error bar. Similar to the conclusions in Sec. 5.2, \(\lambda=0\) is often not the optimal regularization coefficient in terms of accuracy or robustness. In fact, a small, positive \(\lambda\) could result in higher accuracy and better robustness, and this optimal \(\lambda\) varies across different settings. In general, higher data uncertainty requires higher \(\lambda\), which coincides with the intuition of using regularization in traditional settings of linear regressions, which aims to mitigate the effect of data noises or errors.

Figure 5: Robustness verification under label errors using intervals (Meyer) or zonotopes (Zorro).

Figure 6: Fixed point versus samplings

### Comparing with Bayesian Regression

We ran empirical evaluations to demonstrate how data quality issues pose challenges for Bayesian linear regression (implemented with torchbnn [40]), making them inapplicable to our setting. Using the setting from the third plot in Fig 0(c), where the uncertain data percentage is set to 10%, we tested Bayesian linear regression on different possible worlds using two methods: impute-and-predict and sampling from possible worlds. The results show that the prediction intervals generated by Bayesian methods do not cover the ground truth prediction, i.e., the prediction by the model trained on the ground truth training data. In contrast, our approach guarantees 100% coverage across all cases.

### Varying Robustness Threshold

Different practical applications may differ in how much uncertainty they are willing to tolerate, thus leading to varying choices of robustness thresholds. To account for this in the experiments, we selected both a low threshold (0.5% for the insurance data) and a high threshold (5% for the MPG data). As presented in Fig 10, we also explored other thresholds, which did not impact the trends significantly: Zorro can consistently certify a larger fraction of the test data points than the baseline due to its use of the more expressive zonotope domain.

\begin{table}
\begin{tabular}{c|c|c|c|c|c|c|c} Uncertain & \multicolumn{2}{c|}{NNN Imputation (8=5)} & \multicolumn{2}{c|}{NNN Imputation (8=10)} & \multicolumn{2}{c|}{Multiple Imputation} & \multicolumn{1}{c}{Zero} \\ \cline{2-9} Radies (\%) & Coverage (\%) & Avg. Inv. & Coverage (\%) & Avg. Inv. & Coverage (\%) & Avg. Inv. & Coverage (\%) & Avg. Inv. \\ \hline
2.5 & 38.75 & 0.151 & 40 & 0.154 & 55 & 0.176 & 100 & 0.183 \\
5 & 30 & 0.158 & 40 & 0.154 & 37.5 & 0.176 & 100 & 0.506 \\
7.5 & 42.5 & 0.161 & 38.8 & 0.155 & 31.3 & 0.155 & 100 & 1.107 \\
10 & 57.5 & 0.351 & 31.3 & 0.169 & 27.5 & 0.163 & 100 & 2.387 \\ \end{tabular}
\end{table}
Table 2: Bayesian approach on sampled possible worlds.

\begin{table}
\begin{tabular}{c|c|c|c|c|c|c|c|c} Uncertain & \multicolumn{2}{c|}{Possible World 1} & \multicolumn{2}{c|}{Possible World 2} & \multicolumn{2}{c|}{Possible World 3} & \multicolumn{1}{c}{Zero} \\ \cline{2-9} Radies (\%) & Coverage (\%) & Avg. Inv. & Coverage (\%) & Avg. Inv. & Coverage (\%) & Avg. Inv. & Coverage (\%) & Avg. Inv. \\ \hline
2.5 & 38.75 & 0.151 & 40 & 0.154 & 55 & 0.176 & 100 & 0.183 \\
5 & 30 & 0.158 & 40 & 0.154 & 37.5 & 0.176 & 100 & 0.506 \\
7.5 & 42.5 & 0.161 & 38.8 & 0.155 & 31.3 & 0.155 & 100 & 1.107 \\
10 & 57.5 & 0.351 & 31.3 & 0.169 & 27.5 & 0.163 & 100 & 2.387 \\ \end{tabular}
\end{table}
Table 1: Bayesian approach on imputed data.

Figure 8: Results with uncertain training labels.

Figure 7: The range of losses obtained by enumerating all possible worlds (GT), sampling 1000 possible worlds (1k), and Zorro.

Figure 9: Robustness ratio (red y-axis) and worst-case test loss (green y-axis) vs. regularization coefficient \(\lambda\) (x-axis), with varying percentages of uncertain labels.

### Varying Uncertain Feature

The variability of trained models will depend on the correlation that features with uncertainty have with the label, which then also affects our over-approximation of this set. As a rule of thumb, model variability will increase with the correlation between the uncertain feature and the labels, leading to less robust predictions. We conducted an additional experiment using the MPG dataset, focusing on the feature "acceleration," which has relatively low correlation with the label. Unlike the feature "weight" (Fig. 0(c)), where the robustness drops when the uncertainty radius is 10%, the robustness for "acceleration" starts to drop only when the uncertainty radius is increased to 16%. The result shown in Fig 11 indicates that features with lower predictive power have less impact on the robustness of a model compared to features that are highly correlated with the label.

### Runtime of Zorro

We evaluated the runtimes for computing the closed-form solution on the MPG dataset, varying the numbers of uncertain data points, in Fig 12. With the same number of uncertainty data points, uncertain features lead to more complex computations of covariance matrices, and result in higher runtimes compared to label uncertainty, where the covariance matrix remains real-valued.

Figure 11: Robustness verification with errors in feature ”acceleration”.

Figure 12: Zorro runtimes on MPG data.

Figure 10: Varying robustness threshold from 0.4% to 2.4% with fixed uncertainty radius 6%

### NeurIPS Paper Checklist

1. **Claims** Question: Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope? Answer: [Yes] Justification: We state our contributions and scope in Sec. 1. Guidelines: * The answer NA means that the abstract and introduction do not include the claims made in the paper. * The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers. * The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings. * It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper.
2. **Limitations** Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] Justification: We discuss the limitations of our approach in Sec. 5 and app. I and J. Guidelines: * The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper. * The authors are encouraged to create a separate "Limitations" section in their paper. * The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be. * The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated. * The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon. * The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size. * If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness. * While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren't acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. 3. **Theory Assumptions and Proofs** Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? Answer: [Yes]Justification: We provide intuitions in the main body of the paper (Sec. 3 and 4). We include the complete proofs in the appendix, and refer to them in the main body of the paper (App. F and H to J)

Guidelines:

* The answer NA means that the paper does not include theoretical results.
* All the theorems, formulas, and proofs in the paper should be numbered and cross-referenced.
* All assumptions should be clearly stated or referenced in the statement of any theorems.
* The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.
* Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.
* Theorems and Lemmas that the proof relies upon should be properly referenced.
4. **Experimental Result Reproducibility** Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? Answer: [Yes] Justification: Descriptions in the main body of the paper (Sec. 3 to 5), and the formulas and technical details in App. I and J are sufficient for reproducing our approach and experimental results. Guidelines: * The answer NA means that the paper does not include experiments. * If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not. * If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable. * Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed. * While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example 1. If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. 2. If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. 3. If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). 4. We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results.

5. **Open access to data and code** Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? Answer: [Yes] Justification: We share the anonymize Github repository containing the data and code in the paper. Guidelines: * The answer NA means that paper does not include experiments requiring code. * Please see the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details. * While we encourage the release of code and data, we understand that this might not be possible, so "No" is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark). * The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details. * The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc. * The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why. * At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable). * Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
6. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: We describe the experiment settings in detail in Sec. 5. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material.
7. **Experiment Statistical Significance** Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? Answer: [Yes] Justification: We repeat experiments with different random seeds and show the mean and standard deviation in the results. Guidelines: * The answer NA means that the paper does not include experiments. * The authors should answer "Yes" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.

* The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).
* The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)
* The assumptions made should be given (e.g., Normally distributed errors).
* It should be clear whether the error bar is the standard deviation or the standard error of the mean.
* It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis of Normality of errors is not verified.
* For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).
* If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text.
8. **Experiments Compute Resources** Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? Answer: [Yes] Justification: We describe the sufficient information on the computer resources in Sec. 5. Guidelines: * The answer NA means that the paper does not include experiments. * The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage. * The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute. * The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn't make it into the paper).
9. **Code Of Ethics** Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? Answer: [Yes] Justification: We reviewed the NeurIPS Code of Ethics and make sure the paper conforms with it. Guidelines: * The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics. * If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics. * The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction).
10. **Broader Impacts** Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? Answer: [Yes] Justification: We discuss the broader impacts of our technique in Sec. 6. Guidelines: * The answer NA means that there is no societal impact of the work performed.

* If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.
* Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.
* The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.
* The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.
* If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML).
11. **Safeguards** Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? Answer: [NA] Justification: This paper has no such risk. Guidelines: * The answer NA means that the paper poses no such risks. * Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters. * Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images. * We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort.
12. **Licenses for existing assets** Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? Answer: [Yes] Justification: We credit all existing assets used in the paper, and include the license information in the reference. Guidelines: * The answer NA means that the paper does not use existing assets. * The authors should cite the original paper that produced the code package or dataset. * The authors should state which version of the asset is used and, if possible, include a URL. * The name of the license (e.g., CC-BY 4.0) should be included for each asset. * For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.

* If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.
* For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.
* If this information is not available online, the authors are encouraged to reach out to the asset's creators.
* **New Assets*
* Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? Answer: [Yes] Justification: We provide documentations for the released anonymized code (Sec. 5). Guidelines:
* The answer NA means that the paper does not release new assets.
* Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.
* The paper should discuss whether and how consent was obtained from people whose asset is used.
* At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file.
* **Crowdsourcing and Research with Human Subjects*
* Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? Answer: [NA] Justification: This paper does not involve crowdsourcing nor research with human subjects. Guidelines:
* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.
* According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector.
* **Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects*
* Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? Answer: [NA] Justification: This paper does not involve crowdsourcing nor research with human subjects. Guidelines:
* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.
* We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.
* For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review.