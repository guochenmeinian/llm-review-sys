# Contrast Everything: A Hierarchical Contrastive Framework for Medical Time-Series

Yihe Wang

University of North Carolina - Charlotte

ywang145@uncc.edu

&Yu Han

University of Chinese Academy of Sciences

hanyu21@mails.ucas.ac.cn

&Haishuai Wang

Zhejiang University

haishuai.wang@zju.edu.cn &Xiang Zhang

University of North Carolina - Charlotte

xiang.zhang@uncc.edu

These authors contributed equally to this work.

###### Abstract

Contrastive representation learning is crucial in medical time series analysis as it alleviates dependency on labor-intensive, domain-specific, and scarce expert annotations. However, existing contrastive learning methods primarily focus on one single data level, which fails to fully exploit the intricate nature of medical time series. To address this issue, we present COMET, an innovative hierarchical framework that leverages data consistencies at all inherent levels in medical time series. Our meticulously designed model systematically captures data consistency from four potential levels: observation, sample, trial, and patient levels. By developing contrastive loss at multiple levels, we can learn effective representations that preserve comprehensive data consistency, maximizing information utilization in a self-supervised manner. We conduct experiments in the challenging patient-independent setting. We compare COMET against six baselines using three diverse datasets, which include ECG signals for myocardial infarction and EEG signals for Alzheimer's and Parkinson's diseases. The results demonstrate that COMET consistently outperforms all baselines, particularly in setup with 10% and 1% labeled data fractions across all datasets. These results underscore the significant impact of our framework in advancing contrastive representation learning techniques for medical time series. The source code is available at https://github.com/DL4mHealth/COMET.

## 1 Introduction

Time series data is crucial in various real-world applications, ranging from finance [1; 2; 3], engineering [4; 5], to healthcare [6; 7]. Unlike domains such as computer vision [8; 9] and natural language processing [10; 11], where human recognizable features exist, time series data often lacks readily discernible patterns, making data labeling challenging. Consequently, the scarcity of labeled data poses a significant hurdle in effectively utilizing time series for analysis and classification tasks.

To address the paucity of labeled data in time series analysis, self-supervised contrastive learning has emerged as a promising approach. For example, TimeCLR [12] proposes a DTW data augmentation for time series data; TS2vec [13] designs a cropping and masking mechanism to form positive pairs; ExpCLR [14] introduces a novel loss function to utilize continuous expert features. By leveraging the inherent consistency within unlabeled data, contrastive learning algorithms enable the extraction of effective representations without relying on explicit labels. This paradigm shift opens up possibilities for overcoming the data scarcity issue and enhancing the capabilities of time series analysis.

Despite recent advancements in contrastive learning methods for time series, existing approaches fail to exploit the full potential of medical time series data, such as electroencephalogram (EEG) signals. Unlike conventional time series data, medical time series often exhibit more data levels (Figure 1), including patient, trial, sample, and observation levels. Current contrastive learning techniques exclusively employ subsets of these levels (as illustrated in Table 1). Additionally, many of these methods are tailored to specific data types, which restricts their capacity to capture the rich complexity of medical time series. For example, CLOCS [15] presents a contrastive learning method for ECG using sample and patient levels. Mixing-up [16] captures sample-level consistency through a mixing data augmentation scheme. TNC [17] exploits trial-level consistency by contrasting neighbor samples in the same trial as positive pairs. Neither of them leverages all the levels exhibited in the medical time series.

After reviewing existing contrastive learning methods within the time series domain, we consistently posed a pivotal question to ourselves: Can we design a straightforward yet appliable contrastive learning framework that can be adapted to all forms of medical time series data, akin to the classical model SimCLR [18] in the domain of contrastive learning? Our objective is to craft an innovative framework that utilizes all information within medical time series in the context of self-supervised contrastive learning. It enables us to harness patient and trial information to learn consistency across instances while leveraging the sample and observation levels' information to facilitate conventional instance discrimination.

In this paper, we propose a hierarchical framework, COMET, that systematically leverages all four levels of medical time series, namely patient, trial, sample, and observation, to reduce the reliance on labeled data. By incorporating self-supervised contrastive learning, our method aims to bridge the gap between the limited availability of labeled data and the need for robust and generalizable models in medical time series analysis. We conduct extensive experiments with six baselines on three diverse datasets in a challenging patient-independent setting. COMET outperforms SOTAs by 14% and 13% F1 score with label fractions of 10% and 1%, respectively, on EEG-based Alzheimer's detection. Further, COMET outperforms SOTAs by 0.17% and 2.66% F1 score with label fractions of 10% and 1%, respectively, on detecting Myocardial infarction with ECG. Finally, COMET outperforms SOTAs by 2% and 8% F1 score with label fractions of 10% and 1%, respectively, in the EEG-based diagnosis of Parkinson's disease. The results of downstream tasks demonstrate the effectiveness and stability of our method.

## 2 Related Work

**Medical time series.** Medical time series [19; 20; 21; 22] is a distinct type of time series data used for healthcare (_e.g._, disease diagnosis, monitoring, and rehabilitation). It can be collected in a low-cost, non-invasive manner [23] or a high-cost, invasive manner [24].

Unlike general time series, which typically consist of sample and observation levels, medical time series introduces two additional data levels: patient and trial. These extra levels of data information in medical time series enable the development of specialized methods tailored to address the unique characteristics and requirements of medical time series analysis. Various types of medical time series, including EEG [28; 29; 30], ECG [31; 32], EMG [33], and EOG [34], offer valuable insights into specific medical conditions and play a crucial role in advancing healthcare practices.

\begin{table}
\begin{tabular}{l c c c c} \hline \hline
**Models** & **Patient** & **Trial** & **Sample** & **Observation** \\ \hline
**SimCLR**[25] & & & ✓ & \\
**TF-C**[26] & & & ✓ & \\
**Mixing-up**[16] & & & ✓ & \\
**TNC**[17] & & ✓ & & \\
**TS2vec**[13] & & ✓ & ✓ & \\
**TS-TCC**[27] & & & ✓ & ✓ \\
**CLOS**[15] & ✓ & & ✓ & \\
**COMET(Ours)** & ✓ & ✓ & ✓ & ✓ \\ \hline \hline \end{tabular}
\end{table}
Table 1: Existing methods only utilize partial levels.

Figure 1: Structure of medical time series. Medical time series commonly have four levels (coarse to fine): patient, trial, sample, and observation. An observation is a single value in univariate time series and a vector in multivariate time series.

Contrastive learning for time series.Contrastive learning has demonstrated its ability to learn effective representations in various domains, including image processing [35; 18; 36], graph analysis [37; 38; 37], and time series [39]. The key idea behind contrastive representation learning is to mine data consistency by bringing similar data closer together and pushing dissimilar data further apart.

Many existing works on contrastive learning focus on general time series, while some are designed specifically for medical data [40]. One classic framework, SimCLR, transforms a single sample into two augmented views and performs contrastive learning [25]. Other settings, such as using sub-series and overlapping-series, leverage sample-level consistency [41]. TF-C [26] contrasts representations learned from the time and frequency domains to exploit sample-level consistency. Mixing-up [16] learn sample-level consistency by utilizing a mixing component as a data augmentation scheme. TS-TCC and TS2vec [27; 13] apply data augmentation at the sample-level and perform contrastive learning at the observation-level. TNC [17] learns trial-level consistency by contrasting neighboring and non-neighboring samples. NCL [42] can also be used to learn trial-level consistency if we define samples from a trial as a neighborhood. CLOCS [15] learns patient-level consistency in cardiac signal features by contrasting different leads over time.

Certain prior methods have implicitly utilized hierarchical structure [13; 15]. However, as shown in Table 1, none of these methods leverage all the levels present in the medical time series, potentially resulting in the loss of useful information during training. We explicitly present a hierarchical framework in the context of contrastive learning, which can be applied across diverse types of medical time series data. In our paper, we aim to leverage data consistency at all levels in medical time series. Our work plays a role in summarizing, inspiring, and guiding future works in self-supervised contrastive learning on medical time series.

## 3 Preliminaries and Problem Formulation

### Medical Time Series

In this section, we clarify the key conceptions of **observation** (or measurement), **sample** (or segment), **trial** (or recording), and **patient** (or subject) in the context of medical time series (Figure 1). For better understanding, we illustrate the concepts with an example of Electroencephalography (EEG) signals for Alzheimer's Disease diagnosis (details in Appendix A).

**Definition 1: Observation.**_An observation \(\bm{x}_{i,t}\in\mathbb{R}^{F}\) in medical time series data represents a single data point or a vector captured at a specific timestamp \(t\)._ Here we use \(i\) to denote the sample index (see **Definition 2**) and \(t\) to denote the timestamp. It may record physiological status, laboratory test results, vital signs, or other measurable health indicators. The observation is a single real value for univariate time series while vector for multivariate time series. The \(F\) is the feature dimension if it is a multivariate time series.

**Definition 2: Sample.**_A sample \(\bm{x}_{i}=\{\bm{x}_{i,t}|t=1,\cdots,T\}\) is a sequence of consecutive observations_, typically measured at regular intervals over a specified period (\(T\) timestamps). It can also be called a _segment_ or _window_. Here we use \(i\) to denote the sample index. In the medical time series, a sample might consist of a sequence of heart rate measurements or blood pressure readings.

**Definition 3: Trial.**_A trial \(\bm{r}_{i}\) is a collection of consecutive samples._ It can also be called a _record_. Here we use \(i\) to denote the trial ID. In medical time series, a trial is a continuous set of observations collected over a not-short period (_e.g._, 30 minutes). Therefore, a trial is generally too long (_e.g._, hundreds of thousands of observations) to feed into deep learning models for representation learning directly and is usually split into shorter subsequences (_i.e._, samples/segments). To represent the aggregate of samples stemming from a particular trial \(\bm{r}_{i}\) with trial ID \(i\), we employ the notation \(\mathcal{R}_{i}\).

**Definition 4: Patient.**_A patient \(\bm{p}_{i}\) represents a collection of multiple trials stemming from a single patient._ It can also be called a _subject_. Here we use \(i\) to denote the patient ID. It is important to note that trials for a given patient may exhibit variations due to differing data collection timeframes, sensor placements, patient conditions, and other contributing factors. As shown in **Definition 3**, a trial is typically divided into many samples for better representation learning. In practical scenarios, a patient, which constitutes a cluster of trials, is also divided into samples that may share identical or distinct trial IDs but maintain the same patient ID. To represent the aggregate of samples stemming from a particular patient \(\bm{p}_{i}\) with the corresponding patient ID \(i\), we employ the notation \(\mathcal{P}_{i}\).

In this work, we propose a novel hierarchical contrastive framework to learn representative and generalizable embeddings by comprehensively exploring instance discrimination at observation and sample levels and harnessing consistency across instances at trial and patient levels. Although we elaborate the proposed COMET in the context of medical time series, we note our model can possibly be extended to other time series beyond healthcare as long as extra information is available. For example, a climate dataset contains multiple meteorological satellites, each satellite contains multiple measuring units, and each unit contains multiple sensors, and every sensor can measure a specific observation at a certain timestamp. The key is to utilize all available information, excluding label data, for contrastive pre-training, such as patient ID. To adapt our approach to other domains, researchers must consider a crucial question: Does the dataset have additional information beyond sample labels? If affirmative, can this information be harnessed for contrastive learning? The example of satellite sensor application underscores the potential existence of supplementary information even in non-medical domains.

### Problem Formulation

**Problem (Self-Supervised Representation Learning For Medical Time Series).**_Let an unlabeled dataset \(\mathcal{D}\) consist of a set of patients, where each patient \(\bm{p}_{i}\) has multiple trials, each trial \(\bm{r}_{i}\) can be segmented into many samples, and each sample \(\bm{x}_{i}\) comprises a series of observations. We aim to pre-train an encoder \(G\) that exploits data consistency at all available levels in a self-supervised contrastive manner. For a given time series sample \(\bm{x}_{i}\in\mathbb{R}^{T\times F}\) with \(T\) timestamps and \(F\) feature dimensions, the encoder \(G\) learns a sample-level representation \(\bm{h}_{i}\in\mathbb{R}^{T\times K}\), where \(\bm{h}_{i,t}\in\mathbb{R}^{K}\) is the observation-level representation at timestamp \(t\) with K dimensions._

By exploiting hierarchical consistency at multiple data levels, we aim to learn a representation \(\bm{h}_{i}\) that is both representative (yielding good performance in downstream tasks) and generalizable (maintaining stability across different patients). Depending on the fine-tuning settings [18], a specific fraction of labels \(y_{i}\) corresponding to samples \(\bm{x}_{i}\) are necessary.

## 4 Method

In this section, we first present our assumption of data consistency behind designing a hierarchical contrastive framework. Then, we describe the architecture of the proposed model COMET (Figure 2).

Figure 2: **Overview of COMET approach. Our COMET model consists of four contrastive blocks, each illustrating the formulation of positive pairs and negative pairs at different data levels. In the observation-level contrastive, an observation \(\bm{x}_{i,t}\) and its augmented view \(\widetilde{\bm{x}}_{i,t}\) serve as a positive pair. Similarly, in the sample-level contrastive, a sample \(\bm{x}_{i}\) and its augmented view \(\widetilde{\bm{x}}_{i}\) form a positive pair. Moving to the trial-level contrastive, two samples \(\bm{x}\) and \(\bm{x}^{+}\) from the same trial \(\bm{r}_{i}\) are considered to be a positive pair. The patient-level contrastive follows a similar pattern, where two samples \(\bm{x}\) and \(\bm{x}^{+}\) from the same patient \(\bm{p}_{i}\) are regarded as a positive pair. Positive and corresponding negative pairs will be utilized to build contrastive loss in embedding space after being processed by encoder \(G\).**

### Hierarchical Data Consistency

Capturing data consistency is crucial in the development of a contrastive learning framework [13]. Data consistency refers to the shared commonalities preserved within the data, which provide a supervisory signal to guide model optimization. Contrastive learning captures data consistency by contrasting positive and negative data pairs, where positive pairs share commonalities and negative pairs do not. We propose consistency across four data levels: observation, sample, trial, and patient, from fine-grained to coarse-grained in the medical time series. Although we present four levels here, our model can easily be adapted to accommodate specific datasets by adding or removing data levels.

**Observation-level data consistency.** We assume a slightly augmented observation (_e.g._, channel masked) will carry similar information as the original observation [13]. We use \(\bm{x}_{i,t}\) as the anchor observation at timestamp \(t\), and \(\bm{x}_{i,t^{-}}\) as the observation at another timestamp \(t^{-}\) in the sample \(\bm{x}_{i}\). We consider the anchor observation \(\bm{x}_{i,t}\) and an augmented observation \(\widetilde{\bm{x}}_{i,t}\) as positive pairs \((\bm{x}_{i,t},\widetilde{\bm{x}}_{i,t})\) (with closer embeddings). Conversely, we consider the original observation \(\bm{x}_{i,t}\) and the observations \(\widetilde{\bm{x}}_{i,t^{-}}\) and \(\bm{x}_{i,t^{-}}\) at another timestamp \(t^{-}\) as negative pairs \((\bm{x}_{i,t},\widetilde{\bm{x}}_{i,t^{-}}),(\bm{x}_{i,t},\bm{x}_{i,t^{-}})\), with distant embeddings.

**Sample-level data consistency.** The sample-level consistency is based on our assumption that a slightly perturbed sample (e.g., temporally masked) should carry similar information as the original sample [18; 16; 26]. We consider the anchor sample \(\bm{x}_{i}\) and its augmented view \(\widetilde{\bm{x}}_{i}\) as positive pair \((\bm{x}_{i},\widetilde{\bm{x}}_{i})\). We regard the anchor sample \(\bm{x}_{i}\) and a different sample \(\bm{x}_{j}\) and its augmented view \(\widetilde{\bm{x}}_{j}\) as negative pairs: \((\bm{x}_{i},\widetilde{\bm{x}}_{j})\) and \((\bm{x}_{i},\bm{x}_{j})\).

**Trial-level data consistency.** We assume that samples sliced from the same trial should carry similar information compared to those obtained from different trials. For simplicity, we use \(\bm{x}\) to denote the anchor sample and \(\bm{x}^{+}\) to denote a sample from the same trial \(\bm{r}_{i}\) as the anchor sample, while \(\bm{x}^{-}\) to denote a sample from another trial \(\bm{r}_{j}\). In other words, we have \(\{\bm{x},\bm{x}^{+}\}\in\mathcal{R}_{i}\) and \(\bm{x}^{-}\in\mathcal{R}_{j}\). We treat sample \(\bm{x}\) and the sample \(\bm{x}^{+}\) from the same trial as positive pair \((\bm{x},\bm{x}^{+})\). We regard sample \(\bm{x}\) and the sample \(\bm{x}^{-}\) from different trials as negative pair \((\bm{x},\bm{x}^{-})\).

**Patient-level data consistency.** We assume samples originating from the same patient are likely to contain similar information when compared to those from different patients [15]. Here, we use \(\bm{x}\) to denote the anchor sample and \(\bm{x}^{+}\) to denote a sample from the same patient \(\bm{p}_{i}\), while \(\bm{x}^{-}\) from another patient \(\bm{p}_{j}\). In other words, there are \(\{\bm{x},\bm{x}^{+}\}\in\mathcal{P}_{i}\) and \(\bm{x}^{-}\in\mathcal{P}_{j}\). We have positive pair \((\bm{x},\bm{x}^{+})\) including samples from the same patient and negative pair \((\bm{x},\bm{x}^{-})\) that from different patients.

**Disease-level data consistency.** For completeness, we introduce disease-level data consistency, which suggests that samples associated with the same type of disease should exhibit shared patterns, even when collected from different patients in different ways. However, capturing disease-level consistency requires ground truth labels, which are not available in a self-supervised approach. As a result, we do NOT employ disease-level consistency in this paper. Nevertheless, it can be adapted for semi-supervised or supervised contrastive learning and may prove beneficial in learning domain-adaptable representations for certain diseases across patients and even datasets.

A common principle underlying all definitions is that _the X-level data consistency refers to the positive pair belonging to the same X, where X could be observation, sample, trial, patient, or disease._ We assume that _each patient is associated with only one label_, such as suffering from a specific disease, which implies that all samples from the same patient essentially originate from the same distribution. However, in cases where data from a patient is derived from multiple distributions (e.g., a patient could perform various daily activities; associated with multiple labels), the assumptions of trial-level and patient-level consistency are not satisfied. Therefore, the user can switch on the observation-level and sample-level consistency.

Building upon the concepts of data consistency, we introduce four contrastive blocks corresponding to the four data levels. Our model is highly flexible, allowing users to enable or disable any of the blocks based on the requirements of a specific task or dataset.

### Observation-Level Contrastive Block

For a given time series sample \(\bm{x}_{i}\), we apply data augmentation (such as masking) to generate an augmented sample \(\widetilde{\bm{x}}_{i}\)[25; 43]. We input the original sample \(\bm{x}_{i}\) and its augmented view \(\widetilde{\bm{x}}_{i}\) intocontrastive encoder \(G\) to obtain their respective representations \(\bm{h}_{i}=G(\bm{x}_{i})\) and \(\widetilde{\bm{h}}_{i}=G(\widetilde{\bm{x}}_{i})\). It is important to note that we apply data augmentation to the samples, which indirectly extends to augmenting the observations, simplifying the encoding process. To capture observation-level consistency, we assume that, after being processed by encoder \(G\), the representation of observation \(\bm{x}_{i,t}\) is close to the representation of the augmented observation \(\widetilde{\bm{x}}_{i,t}\). In contrast, it should be distant from the representations of observations \(\bm{x}_{i,t^{-}}\) and \(\widetilde{\bm{x}}_{i,t^{-}}\) originating from any other timestamp \(t^{-}\). Specifically, our positive pair is \((\bm{x}_{i,t},\widetilde{\bm{x}}_{i,t})\) and negative pairs are \((\bm{x}_{i,t},\bm{x}_{i,t^{-}})\) and \((\bm{x}_{i,t},\widetilde{\bm{x}}_{i,t^{-}})\).

**Observation-level contrastive loss.** The observation-level contrastive loss \(\mathcal{L}_{\text{O}}\)[13] for the input sample \(\bm{x}_{i}\) is defined as:

\[\mathcal{L}_{\text{O}}=\mathbb{E}_{\bm{x}_{i}\in\mathcal{D}}\left[\text{E}_{t \in\mathcal{T}}\left[-\text{log}\frac{\text{exp}(\bm{h}_{i,t}\cdot\widetilde{ \bm{h}}_{i,t})}{\sum_{t^{-}\in\mathcal{T}}(\text{exp}(\bm{h}_{i,t}\cdot \widetilde{\bm{h}}_{i,t^{-}})+\mathbbm{1}_{[t\neq t^{-}]}\text{exp}(\bm{h}_{i, t}\cdot\bm{h}_{i,t^{-}}))}\right]\right]\] (1)

where \(\mathcal{T}=\{1,\cdots,T\}\) is the set of all timestamps in sample \(\bm{x}_{i}\) and \(\cdot\) denotes dot product. The \(\mathbbm{1}_{[t\neq t^{-}]}\) is an indicator function that equals to \(0\) when \(t=t^{-}\) and \(1\) otherwise.

### Sample-Level Contrastive Block

For an input time series sample \(\bm{x}_{i}\) and its augmented view \(\widetilde{\bm{x}}_{i}\), we calculate their representations through \(\bm{h}_{i}=G(\bm{x}_{i})\) and \(\widetilde{\bm{h}}_{i}=G(\widetilde{\bm{x}}_{i})\). The augmentation applied here could be the same as or different from the augmentation used in Section 4.2. We assume that after passing through the encoder \(G\), the representation of the sample \(\bm{x}_{i}\) is close to the representation of its augmented view \(\widetilde{\bm{x}}_{i}\), while far away from the representations of any other samples \(\bm{x}_{j}\) and \(\widetilde{\bm{x}}_{j}\). In specific, our positive pair is \((\bm{x}_{i},\widetilde{\bm{x}}_{i})\), and negative pairs are \((\bm{x}_{i},\widetilde{\bm{x}}_{j})\) and \((\bm{x}_{i},\bm{x}_{j})\).

**Sample-level contrastive loss.** The sample-level contrastive loss \(\mathcal{L}_{\text{S}}\)[18; 43] for the input sample \(\bm{x}_{i}\) is defined as:

\[\mathcal{L}_{\text{S}}=\mathbb{E}_{\bm{x}_{i}\in\mathcal{D}}\left[-\text{log }\frac{\text{exp}(\bm{h}_{i}\cdot\widetilde{\bm{h}}_{i})}{\sum_{j=1}^{| \mathcal{D}|}(\text{exp}(\bm{h}_{i}\cdot\widetilde{\bm{h}}_{j})+\mathbbm{1}_ {[i\neq j]}\text{exp}(\bm{h}_{i}\cdot\bm{h}_{j}))}\right]\] (2)

where \(|\mathcal{D}|\) represents the total number of samples in the dataset \(\mathcal{D}\) and \(\cdot\) denotes dot product. The \(\mathbbm{1}_{[i\neq j]}\) is an indicator function that equals \(0\) when \(i=j\) and \(1\) otherwise.

### Trial-Level Contrastive Block

For an input sample \(\bm{x}\in\mathcal{R}_{i}\), where \(\mathcal{R}_{i}\) is a collection of all samples segmented from trial \(\bm{r}_{i}\), we feed it into the contrastive encoder \(G\) to generate a sample-level representation \(\bm{h}=G(\bm{x})\). To seize trial-level data consistency, we assume that the representation of the anchor sample \(\bm{x}\in\mathcal{R}_{i}\) is close to the representation of sample \(\bm{x}^{+}\) that also come from the trial \(\bm{r}_{i}\). In contrast, the representation of the anchor sample \(\bm{x}\) is far away from the representation of sample \(\bm{x}^{-}\) that come from a different trial \(\bm{r}_{j}\), where \(\bm{x}^{-}\in\mathcal{R}_{j}\). In other words, we have positive pair \((\bm{x},\bm{x}^{+})\) and negative pair \((\bm{x},\bm{x}^{-})\).

**Trial-level contrastive loss.** The trial-level contrastive loss \(\mathcal{L}_{\text{R}}\)[15; 18] for the input sample \(\bm{x}\) is defined as:

\[\mathcal{L}_{\text{R}}=\mathbb{E}_{\bm{x}\in\mathcal{D}}\left[\mathbb{E}_{\bm{x }^{+}\in\mathcal{R}_{i}}\left[-\text{log}\frac{\text{exp}(\text{sim}(\bm{h},G( \bm{x}^{+}))/\tau)}{\sum_{j=1}^{J}\sum_{\bm{x}^{-}\in\mathcal{R}_{j}}(\text{ exp}(\text{sim}(\bm{h},G(\bm{x}^{-}))/\tau))}\right]\right]\] (3)

where \(J\) is the total number of trials in the dataset \(\mathcal{D}\). The \(\text{sim}(\bm{u},\bm{v})=\bm{u}^{T}\bm{v}/\left\|\bm{u}\right\|\|\bm{v}\|\) denotes the cosine similarity, and \(\tau\) is a temperature parameter to adjust the scale. The \(G(\bm{x}^{+})\) and \(G(\bm{x}^{-})\) are learned representations of samples \(\bm{x}^{+}\in\mathcal{R}_{i}\) and \(\bm{x}^{-}\in\mathcal{R}_{j}\), respectively. To measure the trial-level loss for sample \(\bm{x}\), we iterate all the \(\bm{x}^{+}\) in \(\mathcal{R}_{i}\), and averaging across \(|\mathcal{R}_{i}|-1\) positive pairs.

In this block, we do NOT learn a trial-level embedding representing the entire trial. Instead, we learn a representation for each sample within the trial while considering trial-level data consistency. Similarly, we follow this protocol for the patient-level contrastive block.

### Patient-Level Contrastive Block

For an input sample \(\bm{x}\in\mathcal{P}_{i}\), where \(\mathcal{P}_{i}\) denotes all samples from patient \(\bm{p}_{i}\), we feed it into the contrastive encoder \(G\) to generate a sample-level representation \(\bm{h}=G(\bm{x})\). Similar to the above trial-level contrastive block, we have positive pair \((\bm{x},\bm{x}^{+})\) and negative pair \((\bm{x},\bm{x}^{-})\), in which \(\bm{x}^{+}\) come from the same patient while \(\bm{x}^{-}\) come from a different patient.

**Patient-level contrastive loss.** The patient-level contrastive loss \(\mathcal{L}_{\text{P}}\)[15] for the input sample \(\bm{x}\) is defined as:

\[\mathcal{L}_{\text{P}}=\mathbb{E}_{\bm{x}\in\mathcal{D}}\left[\mathbb{E}_{\bm {x}^{+}\in\mathcal{P}_{i}}\left[-\text{log}\frac{\text{exp}(\text{sim}(\bm{h },G(\bm{x}^{+}))/\tau)}{\sum_{j=1}^{M}\sum_{\bm{x}^{-}\in\mathcal{P}_{j}}(\text {exp}(\text{sim}(\bm{h},G(\bm{x}^{-}))/\tau))}\right]\right]\] (4)

where \(M\) is the total number of patients in the dataset \(\mathcal{D}\). In this block, the \(G(\bm{x}^{+})\) and \(G(\bm{x}^{-})\) are learned representations of samples \(\bm{x}^{+}\in\mathcal{P}_{i}\) and \(\bm{x}^{-}\in\mathcal{P}_{j}\), respectively.

### Overall Loss Function

The overall loss function \(\mathcal{L}\) consists of four loss terms The observation-level loss \(\mathcal{L}_{\text{O}}\) and sample-level loss \(\mathcal{L}_{\text{S}}\) encourage the encoder to learn robust representations that are invariant to perturbations. The trial-level loss \(\mathcal{L}_{\text{R}}\) and patient-level loss \(\mathcal{L}_{\text{P}}\) compel the encoder to learn cross-sample features within a trial or a patient. In summary, the overall loss function of the proposed COMET model is:

\[\mathcal{L}=\lambda_{1}\mathcal{L}_{\text{O}}+\lambda_{2}\mathcal{L}_{\text{ S}}+\lambda_{3}\mathcal{L}_{\text{R}}+\lambda_{4}\mathcal{L}_{\text{P}}\] (5)

where \(\lambda_{1},\lambda_{2},\lambda_{3}\), \(\lambda_{4}\in[0,1]\) are hyper-coefficients that control the relative importance and adjust the scales of each level's loss. Users can simply turn off specific data levels by setting \(\lambda\) of those levels to 0. We set \(\lambda_{1}+\lambda_{2}+\lambda_{3}+\lambda_{4}=1\). We calculate the total loss by taking the expectation of \(\mathcal{L}\) across all samples \(\bm{x}\in\mathcal{D}\). In practice, the contrastive losses are calculated within a mini-batch.

## 5 Experiments

We compare the COMET model with six baselines on three datasets. Following the setup in SimCLR [18], we use unlabeled data to pre-train encoder \(G\) and evaluate it in two downstream settings (Appendix E): partial fine-tuning (P-FT; _i.e._, linear evaluation [18]) and full fine-tuning (F-FT). All datasets are split into training, validation, and test sets in **patient-independent** setting (Figure 3), which is very challenging due to patient variations (More explanations in Appendix F.1).

**Datasets.** (1) **AD**[44] has 23 patients, 663 trials, and 5967 multivariate EEG samples. There are 4329, 891, and 747 samples in training, validation, and test sets. The sampling rate (frequency) is 256Hz. Each sample is a one-second interval with 256 observations. A binary label based on whether the patient has Alzheimer's disease is assigned to each sample. (2) **PTB**[45] has 198 patients, 6237 trials, and 62370 multivariate ECG samples. There are 53950, 3400, and 5020 samples in training, validation, and test sets. The sampling rate (frequency) is 250Hz. Each sample is a heartbeat with 300 observations. A binary label based on whether the patient has Myocardial infarction is assigned to each sample. (3) **TDBrain**[46] has 72 patients, 624 trials, and 11856 multivariate EEG samples. There are 8208, 1824, and 1824 samples in training, validation, and test sets. The sampling rate (frequency) is 256Hz. Each sample is a one-second interval with 256 observations. A binary label based on whether the patient has Parkinson's disease is assigned to each sample. See appendix D for more details about data statistics, train-test split, and data preprocessing.

**Baselines.** We compare with 6 state-of-the-art methods: TS2vec [13], Mixing-up [16], TS-TCC [27], SimCLR [43], CLOCS [15] and TF-C [26]. Since TF-C is designed for transfer learning, we implement its downstream tasks the same as ours for a fair comparison. The evaluation metrics are accuracy, precision (macro-averaged), recall(macro-averaged), F1 score(macro-averaged, AUROC(macro-averaged), and AUPRC(macro-averaged).

Figure 3: **Patient-dependent/independent Setting. In the patient-dependent setting, samples from the same patient can appear in both the training and test sets. In contrast, in the patient-independent setting, samples from the same patient are exclusively included in the training or test set.**

**Implementation.** We use a ten residual blocks dilated CNN module [47] as backbones for encoders \(G\). To preserve the magnitude feature of time series, which is often an important feature in time series, we utilize timestamp masking as proposed in [13] as an augmentation method. While many existing works apply data augmentation directly on raw time series, we use a fully connected projection layer to map the raw input into an embedding with a higher feature dimension. This strategy helps prevent situations where some parts of the raw data are zero, which could result in ineffective augmentation if timestamp masking were directly applied. Additionally, to ensure stability during training, we incorporate a hierarchical loss [13], which encapsulates the observation and sample-level losses. To guarantee there are samples with the same trial and patient IDs in a batch for trial and patient levels contrasting, we design two specific shuffle functions. See Appendix C for further details. For datasets whose trial level is absent or limited to one trial per patient, we provide a solution in Appendix F.2.

We conduct experiments with five seeds(41-45) based on the same data split to account for variance and report the mean and standard deviation. All experiments expect baseline SimCLR run on NVIDIA RTX 4090. Baseline SimCLR runs on Google Colab NVIDIA A100. See further implementation details in Appendix E.

### Results on Partial Fine-tuning

**Setup.** Linear evaluation is a widely used P-FT setup to evaluate the quality of representation, where a linear classifier is trained on top of a frozen network for sample classification [18; 15; 48; 49]. This evaluation method allows for a quick assessment of representation quality. In linear evaluation, we add a logistic regression classifier \(L\) on top of the pre-trained encoder \(G\). The training process utilizes 100% labeled training data for sample classification. Notably, the parameters of the encoder \(G\) are frozen during training, ensuring that only the classifier \(L\) is fine-tuned. See further details in E.1.

**Results.** We report the experimental results of the P-FT setup on AD in Table 2. On average, our COMET model claims a large margin of more than 7% over all baselines on the F1 score on AD.

### Results on Full Fine-tuning

**Setup.** In an F-FT setup, we add a two-layer fully connected network classifier \(P\) to the pre-trained encoder \(G\). The training process utilizes 100%, 10%, and 1% of the labeled training data for sample classification, respectively. Unlike the P-FT approach, both the encoder \(G\) and classifier \(P\) are trainable now, allowing for fine-tuning of the entire network structure. See further details in E.2.

**Results.** The results for F-FT on the three datasets are presented in Table 3 and Table 4. In general, COMET demonstrates success in 46 out of 54 tests conducted across the three datasets, considering six different evaluation metrics. With 100% labeled data, the F1 score of COMET outperforms the best baseline, TS2Vec, by 2% on the AD dataset and surpasses the best baseline, Mixing-up, by 4% on the TDBrain dataset. Furthermore, it achieves a result comparable to the best baseline, TF-C, on the PTB dataset.

Notably, the F1 score of COMET surpasses the best baseline, TF-C, by 14% and 13% with label fractions of 10% and 1%, respectively, on the AD dataset. Additionally, on the TDBrain dataset, the F1 score of COMET outperforms the best baseline, Mixing-up, by 2% and 8% with label fractions of 10% and 1%, respectively. Similarly, the F1 score of COMET outperforms the best baseline, CLOCS, by 0.17% and 2.66% with label fractions of 10% and 1%, respectively, on the PTB dataset. It is interesting to observe that the F1 score of COMET with label fractions of 10% and 1% outperforms a label fraction of 100% on the AD and PTB datasets. This suggests a potential overfitting of COMET to the training data. A similar phenomenon is observed with SimCLR, TF-C, CLOCS, and TS2vec, where a higher fraction of labeled data did not necessarily lead to improved performance.

\begin{table}
\begin{tabular}{l c c c c c c} \hline \hline
**Models** & **Accuracy** & **Precision** & **Recall** & **F1 score** & **AUROC** & **AUPRC** \\ \hline
**TS2vec** & 66.48\(\pm\)3.53 & 67.72\(\pm\)5.09 & 67.40\(\pm\)5.20 & 66.32\(\pm\)5.46 & 74.12\(\pm\)6.88 & 72.96\(\pm\)721 \\
**TF-C** & 77.03\(\pm\)2.88 & 75.79\(\pm\)5.07 & 64.27\(\pm\)5.03 & 64.85\(\pm\)5.56 & 80.71\(\pm\)4.03 & 79.27\(\pm\)4.15 \\
**Mixing-up** & 46.16\(\pm\)1.38 & 52.62\(\pm\)4.90 & 50.81\(\pm\)1.32 & 37.37\(\pm\)1.98 & 64.42\(\pm\)6.49 & 62.85\(\pm\)6.07 \\
**TS-TCC** & 59.71\(\pm\)8.63 & 61.69\(\pm\)8.63 & 60.33\(\pm\)8.26 & 58.66\(\pm\)8.39 & 67.53\(\pm\)10.04 & 68.33\(\pm\)9.37 \\
**SimCLR** & 57.16\(\pm\)2.05 & 56.67\(\pm\)3.91 & 53.57\(\pm\)2.12 & 49.11\(\pm\)4.26 & 56.67\(\pm\)3.91 & 52.10\(\pm\)4.11 \\
**CLOCS** & 66.69\(\pm\)9.24 & 67.17\(\pm\)2.96 & 67.33\(\pm\)2.99 & 66.91\(\pm\)2.83 & 73.17\(\pm\)3.62 & 72.58\(\pm\)3.54 \\
**COMET (Ours)** & **76.09\(\pm\)4.21** & **77.36\(\pm\)3.37** & **74.68\(\pm\)4.42** & **74.80\(\pm\)4.33** & **81.30\(\pm\)4.97** & **80.50\(\pm\)5.31** \\ \hline \hline \end{tabular}
\end{table}
Table 2: **Partial fine-tuning results.** A logistic regression(LG) classifier \(L\) is added on top of a frozen encoder \(G\) on dataset AD. Only fine-tuning the classifier \(L\).

As a result, COMET demonstrates its superiority and stability across all the datasets. Furthermore, COMET outperforms SOTAs methods significantly with 10% and 1% label fractions, highlighting the effectiveness of our contrastive pre-training approach in reducing the reliance on labeled data.

### Ablation Study, Visualization, Additional Downstream Tasks, and Heavy Duty Baseline

**Ablation study.** We verify the effectiveness of each contrastive block and other COMET variants. Besides, we study the impact of hyperparameter \(\lambda\). (Appendix G.1)

**Visualization.** We visualize the embedding space and show our model can learn more distinctive and robust representations. (Appendix G.2)

**Additional downstream tasks.** Apart from the classification tasks in Section 5.1-5.2, we show the proposed COMET outperforms baselines in a wide range of downstream tasks, including clustering and anomaly detection. (Appendix G.3)

**Heavy duty baseline.** We show the superiority of our model does NOT result from the newly added contrastive blocks (_i.e._, increased model parameters). COMET outperforms the heavy-duty SimCLR and TS2Vec with four contrastive blocks and four times pre-training epochs. (Appendix G.4)

\begin{table}
\begin{tabular}{c c c c c c c c c} \hline \hline
**Datasets** & **Fraction** & **Models** & **Accuracy** & **Precision** & **Recall** & **F1 score** & **AUROC** & **AUPRC** \\ \hline \multirow{10}{*}{AD} & \multirow{5}{*}{**100\%**} & **TS2vec** & 81.26\({}_{+2.06}\) & 81.21\({}_{+2.14}\) & 81.34\({}_{+2.04}\) & 81.12\({}_{+2.06}\) & 89.20\({}_{+1.76}\) & 88.94\({}_{+1.85}\) \\  & & **TF-C** & 75.31\({}_{+8.27}\) & 75.87\({}_{+8.73}\) & 74.83\({}_{+8.98}\) & 74.54\({}_{+8.85}\) & 79.45\({}_{+0.12}\) & 79.33\({}_{+10.57}\) \\  & & **Mixing-up** & 65.68\({}_{+7.89}\) & 72.61\({}_{+4.21}\) & 68.25\({}_{+6.97}\) & 63.98\({}_{+9.92}\) & 84.63\({}_{+5.04}\) & 83.46\({}_{+5.18}\) \\  & & **TS-TCC** & 73.55\({}_{+1.00}\) & 77.22\({}_{+2.13}\) & 73.83\({}_{+9.63}\) & 76.16\({}_{+1.99}\) & 86.17\({}_{+1.51}\) & 85.73\({}_{+5.11}\) \\  & & **SimCLR** & 54.77\({}_{+1.97}\) & 50.51\({}_{+8.72}\) & 50.58\({}_{+1.92}\) & 43.18\({}_{+4.27}\) & 50.15\({}_{+7.02}\) & 50.42\({}_{+1.66}\) \\  & & **CLOCS** & 78.37\({}_{+6.00}\) & 83.99\({}_{+2.11}\) & 76.14\({}_{+7.03}\) & 75.78\({}_{+7.93}\) & 91.17\({}_{+2.51}\) & 90.72\({}_{+0.56}\) \\  & & **COMET (Ours)** & **84.50\({}_{+4.46}\)** & **88.31\({}_{+2.42}\)** & **82.95\({}_{+8.39}\)** & **83.33\({}_{+5.18}\)** & **94.44\({}_{+2.37}\)** & **94.43\({}_{+2.48}\)** \\ \cline{2-10}  & & **TS2vec** & 73.28\({}_{+4.34}\) & 74.14\({}_{+4.33}\) & 73.52\({}_{+3.77}\) & 73.00\({}_{+3.18}\) & 81.66\({}_{+5.20}\) & 81.58\({}_{+5.11}\) \\  & & **TF-C** & 75.66\({}_{+1.12}\) & 75.54\({}_{+8.14}\) & 75.58\({}_{+1.19}\) & 75.38\({}_{+1.41}\) & 81.38\({}_{+4.19}\) & 71.56\({}_{+1.08}\) \\  & & **Mixing-up** & 59.38\({}_{+5.33}\) & 64.85\({}_{+4.38}\) & 61.94\({}_{+3.42}\) & 58.17\({}_{+3.41}\) & 75.02\({}_{+6.14}\) & 73.44\({}_{+5.82}\) \\  & & **TS-TCC** & 77.83\({}_{+6.90}\) & 79.73\({}_{+7.49}\) & 76.18\({}_{+7.21}\) & 76.43\({}_{+7.56}\) & 84.12\({}_{+7.32}\) & 84.12\({}_{+7.61}\) \\  & & **SimCLR** & 56.09\({}_{+2.92}\) & 53.31\({}_{+8.74}\) & 57.13\({}_{+2.99}\) & 44.10\({}_{+4.44}\) & 53.81\({}_{+8.74}\) & 51.08\({}_{+1.53}\) \\  & & **CLOCS** & 76.97\({}_{+3.01}\) & 81.70\({}_{+3.21}\) & 74.69\({}_{+3.26}\) & 74.75\({}_{+3.61}\) & 86.91\({}_{+3.61}\) & 86.70\({}_{+3.64}\) \\  & & **COMET (Ours)** & **91.43\({}_{+3.32}\)** & **92.52\({}_{+2.36}\)** & **90.71\({}_{+3.85}\)** & **91.14\({}_{+3.31}\)** & **96.44\({}_{+2.84}\)** & **96.48\({}_{+2.82}\)** \\ \cline{2-10}  & & **TS2vec** & 64.93\({}_{+5.33}\) & 65.28\({}_{+3.52}\) & 65.14\({}_{+3.97}\) & 64.64\({}_{+3.58}\) & 70.56\({}_{+5.38}\) & 68.97\({}_{+5.75}\) \\  & & **TF-C** & 75.66\({}_{+1.61}\) & 75.26\({}_{+1.91}\) & 74.77\({}_{+3.64}\) & 74.33\({}_{+4.48}\) & 79.56\({}_{+1.67}\) & 81.89\({}_{+1.20}\) \\  & & **Mixing-up** & 63.67\({}_{+1.20}\) & 65.02\({}_{+2.09}\) & 64.64\({}_{+6.13}\) & 65.53\({}_{+1.21}\) & 71.95\({}_{+3.39}\) & 70.15\({}_{+3.70}\) \\  & & **TS-TCC** & 53.04\({}_{+8.80}\) & 52.39\({}_{+1.73}\) & 52.00\({}_{+8.01}\) & 44.69\({}_{+1.24}\) & 58.89\({}_{+1.95}\) & 51.41\({}_{+7.81}\) \\  & & **SimCLR** & 55.42\({}_{+2.42}\) & 52.18\({}_{+5.55}\) & 51.37\({}_{+2.76}\) & 45.20\({}_{+4.79}\) & 52.18\({}_{+5.55}\) & 50.87\({}_{+4.5}\) \\  & & **CLOCS** & 64.50\({}_{+4.04}\) & 65.67\({}_{+4.74}\) & 74.72\({}_{+3.74}\) & 63.73\({}_{+4.86}\) & 61.05\({}_{+1.51}\) & 69.16\({}_{+6.75}\) & 68.15\({}_{+2.70}\) \\  & & **COMET (Ours)** & **88.22\({}_{+3.36}\)** & **88.55\({}_{+2.73}\)** & **88.56\({}_{+3.44}\)** & **88.14\({}_{+3.37}\)** & **86.05\({}_{+1.36}\)** & **96.12\({}_{+1.31}\)** \\ \hline \multirow{10}{*}{**TDBrain**} & \multirow{5}{*}{**100\%**} & **TS2vec** & 80.21\({

## 6 Conclusion

This paper introduces COMET, a hierarchical contrastive representation learning framework tailored for medical time series. COMET leverages all data levels of medical time series, including patient, trial, sample, and observation levels, to capture the intricate complexities of the data. Through extensive experiments on three diverse datasets, we demonstrate that our method surpasses existing state-of-the-art methods in medical time series analysis. Our framework also shows its effectiveness in patient-independent downstream tasks, highlighting its potential to advance medical time series analysis and improve patient care and diagnosis.

One limitation of our work is the presence of label conflicts between different levels. In patient-level consistency, we assume all samples belonging to the same patient are positive while others are negative. In trial-level consistency, we consider samples from the same trial as positive samples and others as negative. This means a positive pair at the patient level may be considered negative at the trial level, as they do not belong to the same trial.

In future research, we aim to investigate the efficacy of our method across a wider range of datasets, with a particular focus on ECG datasets. Additionally, we intend to explore approaches to integrate disease-level consistency within our self-supervised contrastive framework.

We discuss the **broader impacts** with potential negative social impacts in Appendix H.

## Acknowledgments and Disclosure of Funding

This work is partially supported by the National Science Foundation under Grant No. 2245894. Any opinions, findings, conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the funders.

\begin{table}
\begin{tabular}{l l l l l l l l l} \hline \hline
**Datasets** & **Fraction** & **Models** & **Accuracy** & **Precision** & **Recall** & **F1 score** & **AUROC** & **AUPRC** \\ \hline \multirow{10}{*}{**PTB**} & \multirow{4}{*}{**100\%**} & **TS2vec** & 85.14\(\pm\)1.66 & 87.82\(\pm\)2.21 & 76.84\(\pm\)3.99 & 79.66\(\pm\)3.63 & 90.50\(\pm\)1.59 & **90.07\(\pm\)1.73** \\  & & **TF-C** & 87.50\(\pm\)2.43 & 85.50\(\pm\)3.04 & **82.68\(\pm\)4.04** & **83.77\(\pm\)3.50** & 77.59\(\pm\)1.92 & 80.62\(\pm\)15.10 \\  & & **Mixing-up** & 87.61\(\pm\)1.48 & **89.56\(\pm\)2.08** & 79.30\(\pm\)1.67 & 82.56\(\pm\)2.00 & 89.29\(\pm\)1.26 & 88.94\(\pm\)1.04 \\  & & **TS-TCC** & 82.24\(\pm\)3.55 & 85.28\(\pm\)5.08 & 69.46\(\pm\)3.58 & 72.06\(\pm\)8.68 & 87.60\(\pm\)2.51 & 86.26\(\pm\)3.00 \\  & & **SimCLR** & 84.19\(\pm\)1.32 & 85.85\(\pm\)1.39 & 73.89\(\pm\)2.95 & 76.84\(\pm\)2.00 & 85.85\(\pm\)1.89 & 70.70\(\pm\)2.36 \\  & & **CLOCS** & 86.39\(\pm\)2.76 & 87.06\(\pm\)2.81 & 77.95\(\pm\)4.79 & 80.71\(\pm\)4.78 & 90.41\(\pm\)2.07 & 87.35\(\pm\)3.36 \\  & & **COMET (Ours)** & **87.84\(\pm\)1.98** & 87.67\(\pm\)1.72 & 81.14\(\pm\)3.68 & 83.45\(\pm\)3.22 & **92.95\(\pm\)1.56** & 87.47\(\pm\)2.82 \\ \cline{2-8}  & & **TS2vec** & 82.49\(\pm\)4.71 & 80.39\(\pm\)5.04 & **83.35\(\pm\)0.91** & 80.18\(\pm\)4.04 & 93.03\(\pm\)1.03 & **92.81\(\pm\)0.97** \\  & & **TF-C** & 85.37\(\pm\)1.23 & 82.80\(\pm\)2.35 & 79.94\(\pm\)7.81 & 81.09\(\pm\)1.14 & 81.57\(\pm\)1.56 & 84.57\(\pm\)1.82 \\  & & **Mixing-up** & 87.05\(\pm\)1.41 & 86.56\(\pm\)3.24 & 80.61\(\pm\)2.68 & 82.62\(\pm\)1.99 & 82.28\(\pm\)1.43 & 87.22\(\pm\)2.76 \\  & & **TS-TCC** & 83.38\(\pm\)1.53 & 85.11\(\pm\)2.11 & 72.24\(\pm\)2.45 & 75.27\(\pm\)2.64 & 86.06\(\pm\)1.76 & 84.34\(\pm\)2.08 \\  & & **SimCLR** & 83.84\(\pm\)2.15 & 87.19\(\pm\)1.34 & 72.51\(\pm\)4.63 & 75.44\(\pm\)4.77 & 87.19\(\pm\)1.34 & 69.99\(\pm\)3.84 \\  & & **CLOCS** & 88.25\(\pm\)2.48 & 88.64\(\pm\)2.12 & 81.40\(\pm\)4.64 & 83.84\(\pm\)4.03 & 91.91\(\pm\)2.06 & 89.76\(\pm\)3.94 \\  & & **COMET (Ours)** & **88.49\(\pm\)1.28** & **88.98\(\pm\)2.06** & 81.65\(\pm\)6.00 & **84.01\(\pm\)5.64** & **94.83\(\pm\)1.09** & 92.48\(\pm\)2.22 \\ \cline{2-8}  & & **TS2vec** & 81.95\(\pm\)1.85 & 78.78\(\pm\)0.98 & 83.83\(\pm\)0.36 & 79.77\(\pm\)1.44 & 90.99\(\pm\)1.34 & 88.69\(\pm\)1.44 \\  & & **TF-C** & 85.82\(\pm\)2.34 & 82.79\(\pm\)3.20 & 81.86\(\pm\)2.36 & 82.21\(\pm\)2.62 & 89.14\(\pm\)2.59 & 89.47\(\pm\)2.92 \\  & & **Mixing-up** & 84.71\(\pm\)4.11 & 82.33\(\pm\)6.87 & 78.17\(\pm\)4.79 & 79.81\(\pm\)3.53 & 89.40\(\pm\)3.57 & 84.67\(\pm\)5.16 \\  & & **TS-TCC** & 78.61\(\pm\)1.98 & 78.72\(\pm\)1.99 & 64.56\(\pm\)3.52 & 66.63\(\pm\)3.36 & 79.97\(\pm\)2.17 & 76.98\(\pm\)2.00 \\  & & **SimCLR** & 84.19\(\pm\)1.49 & 87.15\(\pm\)1.27 & 73.21\(\pm\)3.43 & 76.31\(\pm\)3.26 & 87.15\(\pm\)1.27 & 70.58\(\pm\)2.71 \\  & & **CLOCS** & 88.80\(\pm\)2.82 & 88.11\(\pm\)3.77 & 84.47\(\pm\)3.41 & 85.57\(\pm\)3.41 & 94.73\(\pm\)1.59 & **94.04\(\pm\)2.14** \\  & & **COMET (Ours)** & **90.52\(\pm\)1.90** & **88.58\(\pm\)2.93** & **88.23\(\pm\)1.98** & **88.23\(\pm\)1.20** & **95.08\(\pm\)1.50** & 93.78\(\pm\)1.98 \\ \hline \hline \end{tabular}
\end{table}
Table 4: Full fine-tuning results of ECG datasets. A two-layer fully connected networks classifier \(P\) is trained on top of pre-trained encoder \(G\) on ECG dataset PTB. Fine-tuning the whole network includes \(G\) and \(P\). We use 100%, 10%, and 1% of labeled training data in PTB.

## References

* [1] Dawei Cheng, Fangzhou Yang, Sheng Xiang, and Jin Liu. Financial time series forecasting with multi-modality graph neural network. _Pattern Recognition_, 121:108218, 2022.
* [2] Yajiao Tang, Zhenyu Song, Yulin Zhu, Huaiyu Yuan, Maozhang Hou, Junkai Ji, Cheng Tang, and Jianqiang Li. A survey on machine learning models for financial time series forecasting. _Neurocomputing_, 512:363-380, 2022.
* [3] Xiaoyu He, Suixiang Shi, Xiulin Geng, and Lingyu Xu. Information-aware attention dynamic synergetic network for multivariate time series long-term forecasting. _Neurocomputing_, 500:143-154, 2022.
* [4] Zhiwen Chen, Jiamin Xu, Tao Peng, and Chunhua Yang. Graph convolutional network-based method for fault diagnosis using a hybrid of measurement and prior knowledge. _IEEE transactions on cybernetics_, 52(9):9157-9169, 2021.
* [5] Quan Qian, Yi Qin, Jun Luo, and Dengyu Xiao. Cross-machine transfer fault diagnosis by ensemble weighting subdomain adaptation network. _IEEE Transactions on Industrial Electronics_, 2023.
* [6] Catherine Arsenault, Anna Gage, Min Kyung Kim, Neena R Kapoor, Patricia Akweongo, Freddie Amponsah, Amit Aryal, Daisuke Asai, John Koku Awoonor-Williams, Wondimu Ayele, et al. Covid-19 and resilience of healthcare systems in ten countries. _Nature Medicine_, 28(6):1314-1324, 2022.
* [7] Andrea Brizzi, Charles Whittaker, Luciana MS Servo, Iwona Hawryluk, Carlos A Prete Jr, William M de Souza, Renato S Aguiar, Leonardo JT Araujo, Leonardo S Bastos, Alexandra Blenkinsop, et al. Spatial and temporal fluctuations in covid-19 fatality rates in brazilian hospitals. _Nature medicine_, 28(7):1476-1485, 2022.
* [8] Danyang Tu, Xiongkuo Min, Huiyu Duan, Guodong Guo, Guangtao Zhai, and Wei Shen. End-to-end human-gaze-target detection with transformers. In _2022 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR)_, pages 2192-2200. IEEE, 2022.
* [9] Jaime Spencer, Richard Bowden, and Simon Hadfield. Medusa: Universal feature learning via attentional multitasking. In _Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition_, pages 3800-3809, 2022.
* [10] Haris Bin Zia, Ignacio Castro, Arkaitz Zubiaga, and Gareth Tyson. Improving zero-shot cross-lingual hate speech detection with pseudo-label fine-tuning of transformer language models. In _Proceedings of the International AAAI Conference on Web and Social Media_, volume 16, pages 1435-1439, 2022.
* [11] Tuan Dinh, Yuchen Zeng, Ruisu Zhang, Ziqian Lin, Michael Gira, Shashank Rajput, Jy-yong Sohn, Dimitris Papailiopoulos, and Kangwook Lee. Lift: Language-interfaced fine-tuning for non-language machine learning tasks. _Advances in Neural Information Processing Systems_, 35:11763-11784, 2022.
* [12] Xinyu Yang, Zhenguo Zhang, and Rongyi Cui. Timeclr: A self-supervised contrastive learning framework for univariate time series representation. _Knowledge-Based Systems_, 245:108606, 2022.
* [13] Zhihan Yue, Yujing Wang, Juanyong Duan, Tianmeng Yang, Congrui Huang, Yunhai Tong, and Bixiong Xu. Ts2vec: Towards universal representation of time series. In _Proceedings of the AAAI Conference on Artificial Intelligence_, volume 36, pages 8980-8987, 2022.
* [14] Manuel T Nonnenmacher, Lukas Oldenburg, Ingo Steinwart, and David Reeb. Utilizing expert features for contrastive learning of time-series representations. In _International Conference on Machine Learning_, pages 16969-16989. PMLR, 2022.
* [15] Dani Kiyasseh, Tingting Zhu, and David A Clifton. Clocs: Contrastive learning of cardiac signals across space, time, and patients. In _International Conference on Machine Learning_, pages 5606-5615. PMLR, 2021.
* [16] Kristoffer Wickstrom, Michael Kampffmeyer, Karl Oyvind Mikalsen, and Robert Jenssen. Mixing up contrastive learning: Self-supervised representation learning for time series. _Pattern Recognition Letters_, 155:54-61, 2022.

* [17] Sana Tonekaboni, Danny Eytan, and Anna Goldenberg. Unsupervised representation learning for time series with temporal neighborhood coding. In ICLR, 2021.
* [18] Ting Chen, Simon Kornblith, Mohammad Norouzi, and Geoffrey Hinton. A simple framework for contrastive learning of visual representations. In _International conference on machine learning_, pages 1597-1607. PMLR, 2020.
* [19] Minji Lee, Leandro RD Sanz, Alice Barra, Audrey Wolff, Jaakko O Nieminen, Melanie Boly, Mario Rosanova, Silvia Casarotto, Olivier Bodart, Jitka Annen, et al. Quantifying arousal and awareness in altered states of consciousness using interpretable deep learning. _Nature communications_, 13(1):1064, 2022.
* [20] Chenxi Sun, Hongyan Li, Moxian Song, and Shenda Hong. A ranking-based cross-entropy loss for early classification of time series. _IEEE Transactions on Neural Networks and Learning Systems_, 2023.
* [21] Huizi Cui, Lingge Zhou, Yan Li, and Bingyi Kang. Belief entropy-of-entropy and its application in the cardiac interbeat interval time series analysis. _Chaos, Solitons & Fractals_, 155:111736, 2022.
* [22] Zongxing Xie, Bing Zhou, Xi Cheng, Elinor Schoenfeld, and Fan Ye. Passive and context-aware in-home vital signs monitoring using co-located uwb-depth sensor fusion. _ACM Transactions on Computing for Healthcare_, 3(4):1-31, 2022.
* [23] Martin Krause, Shannon K McWilliams, Kenneth J Bullard, Lena M Mayes, Leslie C Jameson, Susan K Mikulich-Gilbertson, Ana Fernandez-Bustamante, and Karsten Bartels. Neostigmine versus sugammadex for reversal of neuromuscular blockade and effects on re-intubation for respiratory failure or newly initiated non-invasive ventilation-an interrupted time series design. _Anesthesia and analgesia_, 131(1):141, 2020.
* [24] Mohammad-Parsa Hosseini, Tuyen X Tran, Dario Pompili, Kost Elisevich, and Hamid Soltanian-Zadeh. Multimodal data analysis of epileptic eeg and rs-fmri via deep learning and edge computing. _Artificial Intelligence in Medicine_, 104:101813, 2020.
* [25] Johannes Poppelbaum, Gavneet Singh Chadha, and Andreas Schwung. Contrastive learning based self-supervised time-series analysis. _Applied Soft Computing_, 117:108397, 2022.
* [26] Xiang Zhang, Ziyuan Zhao, Theodoros Tsiligkaridis, and Marinka Zitnik. Self-supervised contrastive pre-training for time series via time-frequency consistency. In _NeurIPS_, 2022.
* [27] Emadeldeen Eldele, Mohamed Ragab, Zhenghua Chen, Min Wu, Chee Keong Kwoh, Xiaoli Li, and Cuntai Guan. Time-series representation learning via temporal and contextual contrasting. In _IJCAI_, pages 2352-2359, 2021.
* [28] Siyi Tang, Jared Dunnmon, Khaled Kamal Saab, Xuan Zhang, Qianying Huang, Florian Dubost, Daniel Rubin, and Christopher Lee-Messer. Self-supervised graph neural networks for improved electroencephalographic seizure analysis. In _International Conference on Learning Representations_, 2021.
* [29] Chaoqi Yang, M Brandon Westover, and Jimeng Sun. Manydg: Many-domain generalization for healthcare applications. In _The Eleventh International Conference on Learning Representations_, 2023.
* [30] Xiaodong Qu, Zepeng Hu, Zhaonan Li, and Timothy J Hickey. Ensemble methods and lstm outperformed other eight machine learning classifiers in an eeg-based bci experiment. In _International Conference on Learning Representations_, 2020.
* [31] Uri Shaham, Jonathan Svirsky, Ori Katz, and Ronen Talmon. Discovery of single independent latent variable. _Advances in Neural Information Processing Systems_, 35:25251-25263, 2022.
* [32] Xu Chen and Brett Wujek. A unified framework for automatic distributed active learning. _IEEE Transactions on Pattern Analysis & Machine Intelligence_, 44(12):9774-9786, 2022.
* [33] Yuanchao Dai, Jing Wu, Yuanzhao Fan, Jin Wang, Jianwei Niu, Fei Gu, and Shigen Shen. Mseva: A musculoskeletal rehabilitation evaluation system based on emg signals. _ACM Transactions on Sensor Networks_, 19(1):1-23, 2022.
* [34] Yingying Jiao, Yini Deng, Yun Luo, and Bao-Liang Lu. Driver sleepiness detection from eeg and eog signals using gan and lstm networks. _Neurocomputing_, 408:100-111, 2020.

* [35] Jean-Bastien Grill, Florian Strub, Florent Altche, Corentin Tallec, Pierre Richemond, Elena Buchatskaya, Carl Doersch, Bernardo Avila Pires, Zhaohan Guo, Mohammad Gheshlaghi Azar, et al. Bootstrap your own latent-a new approach to self-supervised learning. _Advances in neural information processing systems_, 33:21271-21284, 2020.
* [36] Aaron van den Oord, Yazhe Li, and Oriol Vinyals. Representation learning with contrastive predictive coding. _arXiv preprint arXiv:1807.03748_, 2018.
* [37] Chunhui Zhang, Hongfu Liu, Jundong Li, Yanfang Ye, and Chuxu Zhang. Contrastive graph few-shot learning. In _NeurIPS 2022 Workshop: New Frontiers in Graph Learning_, 2022.
* [38] Zekun Tong, Yuxuan Liang, Henghui Ding, Yongxing Dai, Xinke Li, and Changhu Wang. Directed graph contrastive learning. _Advances in Neural Information Processing Systems_, 34:19580-19593, 2021.
* [39] Aniruddh Raghu, Payal Chandak, Ridwan Alam, John Guttag, and Collin Stultz. Contrastive pre-training for multimodal medical time series. In _NeurIPS 2022 Workshop on Learning from Time Series for Health_, 2022.
* [40] Ziyu Liu, Azadeh Alavi, Minyi Li, and Xiang Zhang. Self-supervised contrastive learning for medical time series: A systematic review. _Sensors_, 23(9):4221, 2023.
* [41] Jean-Yves Franceschi, Aymeric Dieuleveut, and Martin Jaggi. Unsupervised scalable representation learning for multivariate time series. _Advances in neural information processing systems_, 32, 2019.
* [42] Hugo Yeche, Gideon Dresdner, Francesco Locatello, Matthias Huser, and Gunnar Ratsch. Neighborhood contrastive learning applied to online patient monitoring. In _International Conference on Machine Learning_, pages 11964-11974. PMLR, 2021.
* [43] Chi Ian Tang, Ignacio Perez-Pozuelo, Dimitris Spathis, and Cecilia Mascolo. Exploring contrastive learning in human activity recognition for healthcare. _Machine Learning for Mobile Health Workshop at NeurIPS_, 2020.
* [44] J Escudero, Daniel Abasolo, Roberto Hornero, Pedro Espino, and Miguel Lopez. Analysis of electroencephalograms in alzheimer's disease patients with multiscale entropy. _Physiological measurement_, 27(11):1091, 2006.
* [45] PhysioToolkit PhysioBank. Physionet: components of a new research resource for complex physiologic signals. _Circulation_, 101(23):e215-e220, 2000.
* [46] Hanneke van Dijk, Guido van Wingen, Damiaan Denys, Sebastian Olbrich, Rosalinde van Ruth, and Martijn Arns. The two decades brainclinics research archive for insights in neurophysiology (tdbrain) database. _Scientific data_, 9(1):333, 2022.
* [47] Shaojie Bai, J Zico Kolter, and Vladlen Koltun. An empirical evaluation of generic convolutional and recurrent networks for sequence modeling. _arXiv preprint arXiv:1803.01271_, 2018.
* [48] Richard Zhang, Phillip Isola, and Alexei A Efros. Colorful image colorization. In _European conference on computer vision_, pages 649-666. Springer, 2016.
* [49] Philip Bachman, R Devon Hjelm, and William Buchwalter. Learning representations by maximizing mutual information across views. _Advances in neural information processing systems_, 32, 2019.
* [50] Xiang Lan, Dianwen Ng, Shenda Hong, and Mengling Feng. Intra-inter subject self-supervised learning for multivariate cardiac signals. In _Proceedings of the AAAI Conference on Artificial Intelligence_, volume 36, pages 4532-4540, 2022.

## Appendix A A Medical Time Series Example

Here we use EEG data of Alzheimer's as an example. An EEG dataset has many patients with or without Alzheimer's (healthy control). Data collectors take multiple trials on a specific patient. These trials could be collected continuously within a short time or across a long period but follow the same experiment manner. Usually, the timestamps are too long for the deep learning pipeline to learn. For example, a 5 minutes trial with a sampling rate 25GHz has 76800 timestamps. Researchers generally use data preprocessing to split a trial into many samples, such as 1-second and 3-second short samples, for further representation learning. Each observation denotes a scalar or a vector of real value at a specific timestamp. An experiment with a sampling rate 25GHz has 256 observations in one second.

## Appendix B Data Augmentation Banks

**Binomial masking**: Generate a mask following a binomial distribution that masks some timestamps of a sample, setting all channels at the masked timestamps to zero.

**Channel binomial masking**: Generate a mask following a binomial distribution that masks some channels of some timestamps of a sample, setting only a subset of channels at the masked timestamps to zero.

**Continuous masking**: Mask some continuous sequences of timestamps of a sample, setting all channels at the masked timestamps to zero.

**Channel continuous masking**: Mask some continuous sequences of timestamps of a sample, setting only a random half of the channels at the masked timestamps to zero.

**All true**: Do not apply any masking to the sample. Output the raw sample.

## Appendix C Shuffle Function Banks

In real-world scenarios, ensuring the presence of samples from the same trial or patient within a training batch becomes increasingly low probability as the number of patients grows. This situation can hinder learning meaningful representations at the trial and patient levels. To address this situation, we have designed two distinct shuffle functions that serve to rearrange samples while also upholding the requirement to include samples originating from the same trial and patient. These functions are called the "trial shuffle" and the "batch shuffle".

**Trial shuffle**: This function shuffles samples originating from the same trial and subsequently shuffles the trial order. Initially, we arrange the samples by sorting them based on their trial IDs. Next, samples from the same trial are grouped into sets, and the order of samples within each trial set is shuffled. Finally, we sort the trial sets themselves while preserving the order of samples within each respective trial set.

**Batch shuffle**: This function shuffles samples in a batch and subsequently shuffles the order of batches. The logic of trial and batch shuffle are similar. Initially, we arrange the samples by sorting them based on their trial IDs. Next, we group samples into batch sets, and the order of samples within each batch set is shuffled. Finally, we sort the batch sets themselves while preserving the order of samples within each respective batch set.

**Random shuffle**: Besides the two specifically designed shuffle functions, this random shuffle function shuffles all the samples in the dataset.

All the shuffle functions mentioned here are designed to shuffle samples within the dataset before training. During training, it is also essential to shuffle samples each epoch to prevent the model from memorizing the dataset and encourage it to learn more useful representations. To address this, we implemented a specially crafted BatchSampler class in PyTorch, following the "batch shuffle" approach. This BatchSampler shuffles the samples locally within each epoch, ensuring that the pre-shuffled sample order is not disrupted significantly. This approach guarantees that each batch contains samples from the same trial. It's worth noting that when a batch consists of samples from the same trial, it must have samples from the same patient.

## Appendix D Data Preprocessing

### AD Data Preprocessing

The AD dataset [44] comprises EEG recordings from 12 patients with Alzheimer's disease and 11 healthy controls. Each patient has an average of 30.0 \(\pm\) 12.5 trials. Each trial corresponds to a 5-second interval with 1280 timestamps (sampled at 256Hz) and includes 16 channels. Prior to further processing, each trial is scaled using a standard scaler. To facilitate analysis, we segment each trial into nine half-overlapping samples, where each sample has a duration of 256 timestamps (equivalent to 1 second). Additionally, we assign a unique trial ID and patient ID to each sample based on its origin in terms of the patient and trial. We split training, validation, and test sets in a patient-independent way. We use samples from patient IDs 17 and 18 as the validation set and samples from IDs 19 and 20 as the test set. The rest of the samples are all put into the training set.

### PTB Data Preprocessing

The PTB dataset [45] consists of ECG recordings from 290 patients, with 15 channels sampled at 1000 Hz. There are a total of 8 types of heart diseases present in the dataset. For this paper, we focus on binary classification using a subset of the dataset that includes 198 patients with major disease labels, specifically Myocardial infarction and healthy controls. To preprocess the ECG signals, they are first normalized using a standard scaler after being resampled to a frequency of 250 Hz. Due to special peak information in ECG signals, a regular sliding window segmentation approach may result in the loss of crucial information. To address this issue, a different segmentation strategy is employed. Instead of sliding windows, the raw trials are segmented into individual heartbeats, with each heartbeat treated as a sample. To perform this segmentation, (1) the first step involves determining the maximum duration. The median value of R-Peak intervals across all channels is calculated for each raw trial, and outliers are removed to obtain a reasonable maximum interval as the standard heartbeat duration. (2) The next step is to determine the position of the first R-Peak. The median value of the first R-Peak position is calculated and used for all channels. (3) Next, the raw trials are split into individual heartbeat segments based on the median value of their respective R-Peak intervals. Each heartbeat is sampled starting from the R-Peak position, with the segments extending to both ends with half the length of the median interval. (4) To ensure the same length of the heartbeat samples, zero padding is applied to align their lengths with the maximum duration. (5) Finally, the samples are merged into trials, where 10 nearby samples are grouped together to form a pseudo-trial, similar to the neighborhood idea presented in [17]. We split training, validation, and test sets in a patient-independent way. We use samples from 28 patients(7 healthy and 21 positive) as the validation set and samples from another 28 patients(7 healthy and 21 positive) as the test set. The rest of the samples are all put into the training set.

### TDBrain Data Preprocessing

The TDBrain [46] is a large dataset that monitors the brain signals of 1274 patients with 33 channels (500 Hz) during EC (Eye closed) and EO (Eye open) tasks. The dataset consists of 60 types of diseases, and it is possible for a patient to have multiple diseases simultaneously. This paper focuses on a subset of the dataset, specifically 25 patients with Parkinson's disease and 25 healthy controls. Only the EC task trials are used for representation learning. To process the raw EC trials, we employ a sliding window approach that continuously moves from the middle of the trial to both ends without any overlap. Each raw EC trial is divided into processed pseudo-trials with a length of 2560 timestamps (10 seconds) after resampling to 256 Hz. These processed pseudo-trials are then scaled using a standard scaler. Furthermore, each pseudo-trial is split into 19 half-overlapping samples, with each sample having a length of 256 timestamps (1 second). In addition to the binary label indicating Parkinson's disease or healthy, each sample is assigned a patient and trial ID based on the patient and processed trial it originates from. It is important to note that the trial ID refers to the ID of the processed pseudo-trial and not the raw EC trial. We split training, validation, and test sets in a patient-independent way. We use samples from 8 patients(4 healthy and 4 positive) as the validation set and samples from another 8 patients(4 healthy and 4 positive) as the test set. The rest of the samples are all put into the training set.

## Appendix E COMET and Baseline Implementation Details

We implement the baselines following their corresponding papers, including TS2vec [13], Mixing-up [16], TS-TCC [27], SimCLR [43], CLOCS [15], and TF-C [26]. In our COMET framework and all baselines, we use the last epoch of the contrastive pre-training encoder \(G\) for downstream tasks. For the P-FT and F-FT tasks, we save the best model in terms of F1 score on the validation set during training and load the saved model to evaluate the performance on the test set.

**COMET (our model)** We use a two-layer, fully connected network as the projection head to map the input dimension to the output dimension. The input dimension corresponds to the feature dimension of the data, while the hidden dimension is set to 128, and the output dimension is set to 64. To augment the data, we apply time series masking on the output dimension using the [all_true, all_true, continuous, continuous] (see Appendix B) for the observation, sample, trial, and patient-level contrastive blocks, respectively. The augmented output dimension from the projection head is then passed to the encoder \(G\) for representation learning. For the encoder \(G\), we adopt a dilated CNN module. It consists of 10 hidden blocks, each following the order "GELU -> DilatedConv -> GELU -> DilatedConv." A residual connection is applied between the beginning and end of each block. The dilation factor of the convolution in the i-th block is set to \(2^{i}\). Each hidden dimension of the dilated convolution is set to 64, and the kernel size is set to 3. The output dimension of encoder \(G\) is fixed at 320. We utilize positive pair selection strategies specific to each contrastive block to build the contrastive loss in the embedding space (after encoder \(G\)). A max-pooling layer is employed before applying the representation to downstream tasks. During contrastive pre-training, we set the learning rate to 0.0001. The pre-training batch size is 256, and the total number of pre-training epochs is 100. We report the hyperparameters that achieved good results and stability among random seeds. The hyperparameters \(\lambda_{1}\), \(\lambda_{2}\), \(\lambda_{3}\), \(\lambda_{4}\) are assigned values of (0.25, 0.25, 0.25, 0.25), (0.1, 0.7, 0.1, 0.1), and (0.25, 0.25, 0.25, 0.25) for the AD, PTB, and TDBrain datasets, respectively.

**TS2vec**[13] introduces contextual consistency using overlapping subseries and a hierarchical loss function to capture data consistency at the observation and sample levels. To incorporate their methodology, we utilize the open-source code available at https://github.com/yuezhihan/ts2vec. However, their code does not include downstream tasks for F-FT (Full Fine-Tuning), so we implement these tasks using the same setup as our COMET. Specifically, we set the number of epochs for contrastive pre-training to 100, the learning rate to 0.0001, and the batch size to 256. To align with our model, we adjust the convolution blocks to 10, matching our configuration. We adopt the default settings provided by the TS2vec implementation for other settings during pre-training.

**TS-TCC**[27] leverages temporal and contextual consistency by contrasting a strong and weak augmentation. They employ a transformer-based autoregressive as the encoder. They perform a cross-view prediction by using temporal context to predict one view's future. Then, they maximize the similarity of contexts generated by the encoder to leverage contextual consistency. We utilize the open-source code available https://github.com/emadellecen24/TS-TCC. We set the number of pre-training epochs to 100. We adopt the default settings provided by the TS-TCC implementation for other settings during pre-training.

**Mixing-up**[16] proposes a mixing-up augmentation by mixing the proportion of two time-series samples. This augmentation involves creating an augmented sample as the convex combination of two randomly selected time-series samples from the dataset. The mixing parameter follows a beta distribution, determining the proportion of the two samples in the augmentation process. We utilize the open-source code available at https://github.com/wickstrom/mixupcontrastivelearning to implement Mixing-up. Although they only provide downstream tasks for F-FT, we align their method with our setups for all downstream tasks, including P-FT and F-FT. We set the number of pre-training epochs to 100, the learning rate to 0.0001, and the batch size to 256 during pre-training.

**SimCLR**[18] is the most classic contrastive learning framework first proposed in the CV domain. It applies data augmentation techniques to create augmented views of input samples and constructs a contrastive loss based on these views. While initially designed for images, SimCLR has also been successfully adapted to time series data, as demonstrated in previous work such as [43]. To implement SimCLR, we utilize their open-source code available at https://github.com/iantangc/ContrastiveLearningHAR. We set the number of pre-training epochs to 100, the learning rate to 0.0001, and the batch size to 512, aligning with their recommended settings. We use the default values provided in the SimCLR implementation for other configuration parameters during pre-training.

CLOCS[15] employs samples from the same patient as positive pairs to leverage the data invariance in ECG recordings. They make use of both temporal and spatial information for contrastive learning. To implement CLOCS, we utilized their open-source code, available at https://github.com/danikiyasseh/CLOCS. We incorporated their contrastive loss function to implement the Contrastive Multi-segment Coding (CMSC) mechanism described in their paper. Additionally, we modified their backbone to use TCN, which shares the same network structure as our COMET, including the configuration parameters. Specifically, we set the number of pre-training epochs to 100, the learning rate to 0.0001, and the batch size to 256.

**TF-C**[26] leverages the consistency between time domain and frequency domain. They assume that the time-based and frequency-based representations of the same example exhibit proximity in the time-frequency space. We utilize their open-source code available at https://github.com/mims-harvard/TFC-pretraining to implement TF-C. While the original method is primarily designed for transfer learning, we extend it to incorporate downstream tasks such as P-FT and F-FT in our experiments. We set the number of pre-training epochs to 100, the learning rate to 0.0001, and the batch size to 256. We use the default values provided in the TF-C implementation for other configuration parameters during pre-training.

### Partial Fine-tuning

In the P-FT (Partial Fine-Tuning) setup, we introduce a classifier \(L\) on top of the pre-trained encoder \(G\), while keeping the parameters of \(G\) fixed. Only the classifier \(L\) is fine-tuned in this setup.

In the COMET, TS2vec, and Mixing-up approaches, we utilize logistic regression from the Sklearn library to implement the classifier \(L\). We use the default settings of Sklearn, except for setting the maximum iteration to 100,000. We employ a one-layer fully connected network as the classifier \(L\) for the TF-C method. The learning rates are specifically set to 8e-5, 3e-5, and 1e-4 for the AD, PTB, and TDBrain datasets, respectively. As for TS-TCC and SimCLR, we follow their respective default settings for the partial fine-tuning phase.

### Full Fine-tuning

In the F-FT (Full Fine-Tuning) setup, we introduce a classifier \(P\) on top of the pre-trained encoder \(G\), where both the parameters of the encoder \(G\) and the classifier \(P\) are trainable. In this setup, we fine-tune both the classifier \(P\) and the encoder \(G\). We utilize a fraction of 100%, 10%, and 1% labeled training data for fine-tuning.

In the COMET, TS2vec, and Mixing-up approaches, we set the finetune learning rate to 1e-4. We use a batch size of 128 and perform fine-tuning for 50, 100, and 100 epochs for 100%, 10%, and 1% label fractions, respectively. The classifier \(P\) is implemented as a two-layer fully connected network with hidden dimensions 128. For TF-C, we change the hidden dimension of this two-layer fully connected network to 64. The learning rates are specifically set to 8e-5, 3e-5, and 1e-4 for the AD, PTB, and TDBrain datasets, respectively. Regarding TS-TCC and SimCLR, we follow their respective default settings for the full fine-tuning phase.

## Appendix F Experimental Setting

### Patient-Independent Experimental Setting

This paper adopts a patient-independent setting for the train-validation-test split. In medical time series classification tasks, two common approaches to splitting the data are patient-independent and patient-dependent settings [15, 1]. Figure 3 illustrates these two settings' differences. In the patient-dependent setting, samples from the same patient can appear in both the training and testing sets, whereas in the patient-independent setting, samples from the same patient are exclusively included in either the training or testing set.

Performing patient-independent representation learning poses challenges due to the unique characteristics and different data distributions exhibited by each patient [50]. Even if two patients share the same label, the patterns within their data may differ significantly due to individual noise characteristics, potentially overshadowing the common patterns observed across patients. However, in real-world scenarios, it is essential for a model to be robust and general to perform patient-independentrepresentation learning. The goal is to train a model on a subset of patients with known labels and utilize it to predict other patients with unknown labels. In contrast, patient-dependent classification is usually impractical since it requires knowledge of the labels for all patients.

### Pseudo-Trial Experimental Setting

For many medical time series datasets, patient information is readily available, but trial information may be absent or limited to a single trial per patient. In such cases, the question arises of effectively employing trial-level contrastive learning. The solution is straightforward. We can generate pseudo-trials rather than merely deactivating the trial-level block by setting \(\lambda\) to 0.

We can define groups of adjacent samples as pseudo-trials and assign them the same trial ID. In our paper, we employed ten neighboring samples as a pseudo-trial for the PTB and TDBrain datasets, and this approach yielded favorable results. This concept is akin to the approach taken by TNC [17], where close samples are defined as positive pairs.

## Appendix G Ablation Study, Visualization, Additional Downstream Tasks, and Heavy Duty Baseline

### Ablation Study

Ablation study of contrastive blocksWe examined the effectiveness of each contrastive block and progressively incorporated each block from the observation-level to all four levels. Table 5 compares the full-level COMET model with its six variants on the AD, PTB, and TDBrain datasets. The variants are as follows: (1) **O**, **S**, **R**, **P**, which utilize only one level of the contrastive block. We activate that specific level by setting its \(\lambda\) to 1 and deactivate the other three levels by setting their \(\lambda\) to 0; (2) **S+O**, which combines the sample and observation-level contrastive blocks. The \(\lambda\) values for sample and observation levels are set equally to 0.5; (3) **R+S+O**, incorporating the trial, sample, and observation-level contrastive blocks. The \(\lambda\) values for these three levels are set equally to 0.33; and (4) **P+R+S+O**, representing our complete COMET method with all four levels of contrastive blocks. The \(\lambda\) values for the four levels are set equally to 0.25. The "Fraction" column indicates the fraction of labeled training samples used during fine-tuning.

We observed that variants **R** and **P** exhibit strong performance, achieving comparable or even outperforming the full-level COMET model **P+R+S+O** on the PTB and TDBrain datasets across different fractions of labeled data (100%, 10%, and 1%). Notably, they also perform well with a 1% fraction in the AD dataset, although they exhibit significant instability in this case. This finding suggests that adding more contrastive blocks may not necessarily improve final results. Achieving a balance in weights among different levels through \(\lambda\) is crucial. Nevertheless, training models at individual levels can provide insights into the importance of each level in contrastive representation learning. Furthermore, it's noteworthy that the full-level COMET model **P+R+S+O** consistently demonstrates comparable or superior results across all datasets and fractions. Importantly, we did not perform any parameter tuning here, opting to set all the \(\lambda\) values equally, highlighting the stability of the full-level COMET **P+R+S+O** compared to other variants.

Ablation study of hyperparameter \(\lambda\)We conducted an analysis to assess the impact of hyperparameter \(\lambda\) on the AD, PTB, and TDBrain datasets in table 6. The values of \(\lambda_{1},\lambda_{2},\lambda_{3}\), and \(\lambda_{4}\), from left to right, correspond to the patient, trial, sample, and observation levels, respectively. In this analysis, all four data levels are incorporated, representing the full-level COMET model **P+R+S+O**. We applied a significant weight to one data level by setting its corresponding \(\lambda\) to 0.7 while assigning lower weights of 0.1 to the other levels. Furthermore, we explored scenarios with increased weights on patient and trial levels or sample and observation levels. The "Fraction" column indicates the fraction of labeled training samples used during fine-tuning.

We observed that the results exhibited greater stability than the ablation study of contrastive blocks. In the contrastive block ablation study, there were significant discrepancies between different COMET variants at times. For instance, the **S** and **R** variants of the TDBrain dataset exhibited substantial differences across various fraction setups. However, in the full-level COMET model, the differences between these inter-running setups were notably reduced, even when a heavy weight was applied to one data level. For instance, the differences between lambda setups (0.1, 0.1, 0.7, 0.1) and (0.1,0.7, 0.1, 0.1) were not as significant in the TDBrain dataset. This observation underscores again the stability and robustness of the full-level COMET model.

### Visualization

To visualize the effectiveness of COMET, we depict the learned representation \(h_{i}\) using the F-FT setup on the AD dataset as a case study. It is important to note that the learned representation \(h_{i}\) consists of 320 dimensions after pooling. To visualize the representations more interpretably, we employ UMAP, a dimensionality reduction technique with 20 neighbors and a minimum distance of 0.2. To establish a benchmark for comparison, we utilize TS2vec, which has shown the best performance among all baselines in the F-FT setup on the AD dataset. Additionally, we compute the average pairwise Euclidean distance between the negative (healthy) and positive (Alzheimer) classes, offering a quantitative measure of separability between the two classes.

### Performance on Downstream Tasks

ClusteringWe assess the clustering performance of COMET using the AD dataset as a case study. Instead of employing a classifier model on top of the encoder, we apply K-means clustering (K=2) to the encoder \(G\). We utilize three widely-used evaluation metrics: Silhouette score, Adjusted Rand Index (ARI), and Normalized Mutual Information (NMI). To establish a benchmark for comparison, we consider TS2vec, which has shown the best performance among all baselines in the F-FT setup on the AD dataset. Table 7 illustrates that COMET surpasses TS2vec with an improvement of 0.0586 in Silhouette score, 0.945 in ARI, and 0.881 in NMI.

Anomaly detectionWe evaluate the anomaly detection performance of COMET using the AD dataset as a case study. While some previous works focus on identifying outlier observations within a sample [S2, S3], we concentrate on sample-level anomaly detection. We construct a very unbalanced AD test set comprising 90% negative (healthy) samples and 10% positive (Alzheimer's) samples. The negative samples are considered normal, while the positive samples are treated as outliers. The test set is prepared accordingly, while the remaining aspects of the experiment follow the F-FT setup. Specifically, We utilize the saved trained models from the F-FT setup to evaluate the new test set, and for comparison, we still employ TS2vec as a benchmark. The "Fraction" column indicates the fraction of labeled training samples used during fine-tuning. The experiment result is shown in table 8. The COMET outperforms TS2vec by 5.25%, 15.3% and 11.4% with label fraction 100%, 10% and 1%, respectively.

Figure 4: **Visualizing the learned representation** (a) Visualization for TS2vec. (b) Visualization for COMET(Ours). The visualized representation is trained in the F-FT setup on the AD dataset. Dark blue and light blue denotes the negative class(Health) and positive class(Alzheimer), respectively. We calculate the mean Euclidean distance between pairwise samples from two classes for each pair of samples to evaluate the class separability. As the figure shows, our method exhibits superior separation between the two classes, resulting in larger pairwise distances.

[MISSING_PAGE_FAIL:20]

\begin{table}
\begin{tabular}{c c c c c c c c c} \hline \hline
**Datasets** & **Fraction** & \(\lambda_{1},\lambda_{2},\lambda_{3},\lambda_{4}\) & **Accuracy** & **Precision** & **Recall** & **F1 score** & **AUROC** & **AUPRC** \\ \hline \multirow{9}{*}{**AD**} & & (0.1,0.1,0.1) & **87.82\({}_{+1.44}\)** & **91.08\({}_{+4.19}\)** & **86.62\({}_{+8.88}\)** & **86.77\({}_{+8.64}\)** & **97.95\({}_{+1.25}\)** & **97.94\({}_{+1.28}\)** \\  & & (0.1,0.1,0.7,0.1) & 85.03\({}_{+5.64}\) & 89.09\({}_{+3.22}\) & 83.32\({}_{+6.37}\) & 83.78\({}_{+6.59}\) & 95.33\({}_{+1.81}\) & 95.30\({}_{+1.90}\) \\  & & (0.1,0.7,0.1,0.1) & 82.76\({}_{+8.67}\) & 88.00\({}_{+4.65}\) & 80.98\({}_{+0.102}\) & 80.72\({}_{+10.30}\) & 95.32\({}_{+2.77}\) & 95.26\({}_{+2.71}\) \\  & **100\%** & (0.7,0.1,0.1) & 82.22\({}_{+8.83}\) & 87.27\({}_{+4.14}\) & 80.42\({}_{+9.62}\) & 80.71\({}_{+1.100}\) & 94.84\({}_{+2.64}\) & 94.80\({}_{+2.65}\) \\  & & (0.2,0.2,0.3,0.3) & 86.88\({}_{+3.78}\) & 89.96\({}_{+4.00}\) & 85.46\({}_{+6.52}\) & 85.97\({}_{+6.36}\) & 94.03\({}_{+3.56}\) & 94.07\({}_{+0.35}\) \\  & & (0.3,0.3,0.2) & 86.75\({}_{+9.57}\) & 89.76\({}_{+3.12}\) & 85.41\({}_{+6.92}\) & 85.73\({}_{+6.95}\) & 95.91\({}_{+1.45}\) & 95.09\({}_{+2.04}\) \\  & & (0.3,0.3,0.15,0.25) & 82.84\({}_{+6.96}\) & 88.09\({}_{+3.99}\) & 80.87\({}_{+9.38}\) & 81.04\({}_{+8.06}\) & 94.73\({}_{+2.98}\) & 94.64\({}_{+3.12}\) \\ \cline{2-9}  & & (0.1,0.1,0.1,0.7) & 89.56\({}_{+8.67}\) & 91.37\({}_{+6.73}\) & 88.64\({}_{+9.65}\) & 88.82\({}_{+9.51}\) & 96.55\({}_{+4.41}\) & 96.47\({}_{+2.63}\) \\  & & (0.1,0.1,0.7,0.1) & 87.84\({}_{+6.09}\) & 88.72\({}_{+5.16}\) & 87.50\({}_{+6.76}\) & 87.42\({}_{+6.66}\) & 94.58\({}_{+5.32}\) & 93.85\({}_{+5.57}\) \\  & & (0.1,0.7,0.1,0.1) & 79.89\({}_{+4.06}\) & 85.79\({}_{+7.95}\) & 77.97\({}_{+6.05}\) & 75.54\({}_{+9.81}\) & 28.99\({}_{+6.45}\) & 92.67\({}_{+6.64}\) \\  & **10\%** & (0.7,0.1,0.1) & 78.26\({}_{+1.95}\) & 88.49\({}_{+6.68}\) & 76.38\({}_{+1.58}\) & 73.44\({}_{+19.24}\) & 92.47\({}_{+7.64}\) & 92.57\({}_{+7.93}\) \\  & & (0.2,0.2,0.3,0.3) & **93.57\({}_{+1.17}\)** & **93.66\({}_{+1.24}\)** & **92.77\({}_{+2.09}\)** & **93.09\({}_{+1.89}\)** & **97.68\({}_{+6.87}\)** & **97.75\({}_{+8.88}\)** \\  & & (0.3,0.3,0.2,0.2) & 91.43\({}_{+3.30}\) & 92.71\({}_{+2.19}\) & 90.68\({}_{+2.48}\) & 91.90\({}_{+2.00}\) & 96.81\({}_{+2.16}\) & 96.88\({}_{+1.64}\) \\  & & (0.3,0.3,0.15,0.25) & 91.54\({}_{+3.63}\) & 92.93\({}_{+2.32}\) & 90.77\({}_{+4.25}\) & 91.91\({}_{+3.91}\) & 97.26\({}_{+1.67}\) & 92.79\({}_{+1.67}\) \\ \cline{2-9}  & & (0.1,0.1,0.1,0.7) & 95.88\({}_{+2.29}\) & 96.21\({}_{+1.92}\) & 95.64\({}_{+2.55}\) & 95.79\({}_{+2.16}\) & 92.72\({}_{+9.34}\) & 93.24\({}_{+8.74}\) \\  & & (0.1,0.1,0.7,0.1) & 85.03\({}_{+9.89}\) & 87.16\({}_{+5.75}\) & 85.65\({}_{+8.54}\) & 84.62\({}_{+10.42}\) & 94.71\({}_{+2.73}\) & 94.73\({}_{+2.89}\) \\  & & (0.1,0.7,0.1,0.1) & **97.19\({}_{+1.18}\)** & **97.32\({}_{+1.11}\)** & **97.80\({}_{+1.24}\)** & **97.15\({}_{+1.31}\)** & **99.02\({}_{+1.26}\)** & **98.98\({}_{+1.11}\)** \\  & **1\%** & (0.7,0.1,0.1,0.1) & 97.00\({}_{+1.01}\) & 97.01\({}_{+1.06}\) & 96.92\({}_{+1.14}\) & 96.96\({}_{+1.12}\) & 98.93\({}_{+1.30}\) & 98.99\({}_{+1.25}\) \\  & & (0.2,0.2,0.3,0.3) & 84.55\({}_{+7.39}\) & 84.47\({}_{+7.51}\) & 84.75\({}_{+7.65}\) & 84.44\({}_{+7.49}\) & 89.95\({}_{+0.83}\) & 89.78\({}_{+1.12}\) \\  & & (0.3,0.3,0.2,0.2) & 86.96\({}_{+5.92}\) & 87.16\({}_{+5.66}\) & 86.87\({}_{+6.31}\) & 86.72\({}_{+6.19}\) & 92.68\({}_{+7.76}\) & 92.93\({}_{+7.43}\) \\  & & (0.3,0.3,0.15,0.25) & 92.40\({}_{+2.52}\) & 92.75\({}_{+2.41}\) & 92.16\({}_{+2.44}\) & 92.27\({}_{+2.55}\) & 97.76\({}_{+1.11}\) & 97.66\({}_{+1.17}\) \\ \hline \multirow{9}{*}{**TPB**} & & (0.1,0.1,0.1,0.7) & 85.51\({}_{+2.66}\) & 85.54\({}_{+2.23}\) & 76.96\({}_{+

### Heavy Duty Baselines

In COMET, we incorporate four contrastive blocks to leverage four levels of data consistency, allowing the data to pass through the model four times within one epoch during contrastive pre-training. To ensure that our superior performance is not due to increased data passing, we conduct experiments on the AD dataset with two baselines: SimCLR and TS2vec.

SimCLR utilizes only one contrastive block during training. We employ two strategies to match the data passing number with COMET: (1) Run SimCLR with one contrastive block for four times the original number of epochs in pre-training (400 epochs instead of 100). (2) Duplicate the contrastive blocks, resulting in four SimCLR contrastive blocks. The notation **4E** signifies running the model for four times the original number of epochs, while **4B** indicates the use of four times the number of contrastive blocks compared to the original SimCLR.

TS2vec incorporates two contrastive blocks during training, leading to data passing twice within one epoch. Similarly, we adopt two strategies to align the data passing number with COMET: (1) Run TS2vec for two times the original number of epochs in pre-training (200 epochs instead of 100). (2) Duplicate the contrastive blocks, resulting in four TS2vec contrastive blocks. The notation **2E** denotes running the model for four times the original number of epochs, while **2B** indicates the use of four times the number of contrastive blocks compared to the original TS2vec.

The results are presented in Table 9. We observe that simply increasing the number of epochs or contrastive blocks does not improve performance but rather leads to a decrease in most cases. We speculate that this decrease is caused by overfitting.

## Appendix H Broader Impacts

Our approach for self-supervised contrastive learning improves classification performance on target datasets in patient-independent medical diagnosis scenarios. Leveraging different data consistency levels in medical time series is crucial to enable effective and accurate contrastive learning without sufficient labels. Our work will encourage the research community to discover universal frameworks for other practical applications based on time series representation learning. We also hope our work can attract more researchers to the more general problem of hierarchical consistency from other related fields.

From the societal perspective, our work and the line of contrastive learning can promote more efficient use of medical time series with the lack of labels. Specifically, our model has the potential to identify patterns and anomalies that may not be immediately apparent to human experts. This could lead to earlier and more accurate diagnoses, improving patient outcomes and reducing healthcare costs. However, practitioners need to be aware of the limitations of the model.

\begin{table}
\begin{tabular}{l l l l l} \hline \hline
**Method** & **Silhouette** & **ARI** & **NMI** \\ \hline
**Random Init.** & 0.1184\(\pm\) 0.0082 & 0.1189\(\pm\)0.0664 & 0.1258\(\pm\)0.0660 \\ \hline
**TS2vec** & 0.0795\(\pm\) 0.0032 & 0.0013\(\pm\) 0.0026 & 0.0018\(\pm\)0.0016 \\
**COMET (Ours)** & 0.1381\(\pm\) 0.0139 & 0.9358\(\pm\)0.0264 & 0.8827\(\pm\)0.0414 \\ \hline \hline \end{tabular}
\end{table}
Table 7: Performance on downstream clustering. The clustering performance is evaluated on the AD dataset. We compare the baseline TS2vec, which performs best in the F-FT setup.

\begin{table}
\begin{tabular}{c l l l l l l l} \hline \hline
**Fraction** & **Models** & **Accuracy** & **Precision** & **Recall** & **F1 score** & **AUROC** & **AUPRC** \\ \hline
**100\%** & **TS2vec** & 82.11\(\pm\)3.30 & 66.05\(\pm\)2.45 & 82.123\(\pm\)3.21 & 68.70\(\pm\)3.37 & 91.27\(\pm\)1.47 & 76.80\(\pm\)3.08 \\
**COMET (Ours)** & 83.03\(\pm\)11.65 & 71.76\(\pm\)7.60 & 90.33\(\pm\)6.31 & 73.95\(\pm\)1.97 & 97.99\(\pm\)1.37 & 91.52\(\pm\)5.52 \\ \hline
**10\%** & **TS2vec** & 76.05\(\pm\)6.35 & 62.48\(\pm\)2.90 & 77.33\(\pm\)4.74 & 62.67\(\pm\)5.00 & 86.76\(\pm\)3.95 & 72.21\(\pm\)5.09 \\
**COMET (Ours)** & 88.22\(\pm\)2.88 & 73.22\(\pm\)3.31 & 92.49\(\pm\)1.73 & 77.97\(\pm\)3.87 & 97.91\(\pm\)1.14 & 92.21\(\pm\)4.43 \\ \hline
**1\%** & **TS2vec** & 67.24\(\pm\)8.05 & 57.34\(\pm\)3.12 & 67.87\(\pm\)6.45 & 54.35\(\pm\)6.21 & 72.75\(\pm\)6.82 & 61.32\(\pm\)5.25 \\
**COMET (Ours)** & 77.57\(\pm\)4.21 & 64.72\(\pm\)1.95 & 84.41\(\pm\)3.38 & 65.74\(\pm\)3.67 & 93.13\(\pm\)2.82 & 79.65\(\pm\)7.65 \\ \hline \hline \end{tabular}
\end{table}
Table 8: Performance on anomaly detection. Sample-level anomaly detection on a very unbalanced AD test set comprising 90% negative (healthy) samples and 10% positive (Alzheimer) samples.

All datasets in this paper are publicly available and are not associated with privacy or security concerns. Furthermore, we have followed guidelines on responsible use specified by the primary authors of the datasets used in the current work.

\begin{table}
\begin{tabular}{c l l l l l l l} \hline \hline
**Fraction** & **Models** & **Accuracy** & **Precision** & **Recall** & **F1 score** & **AUROC** & **AUPRC** \\ \hline \multirow{6}{*}{**100\%**} & **4E-SimCLR** & 56.87\(\pm\)2.51 & 57.67\(\pm\)4.02 & 53.31\(\pm\)2.30 & 48.28\(\pm\)4.63 & 57.67\(\pm\)4.02 & 51.97\(\pm\)1.44 \\  & **4B-SimCLR** & 53.92\(\pm\)3.31 & 51.88\(\pm\)3.25 & 51.26\(\pm\)3.05 & 46.92\(\pm\)5.07 & 51.88\(\pm\)3.25 & 50.75\(\pm\)1.69 \\  & SimCLR & 54.77\(\pm\)1.97 & 50.15\(\pm\)7.02 & 50.58\(\pm\)1.92 & 43.18\(\pm\)4.27 & 50.15\(\pm\)7.02 & 50.42\(\pm\)1.06 \\  & **2E-TS2vec** & 76.49\(\pm\)4.610 & 78.97\(\pm\)3.54 & 77.69\(\pm\)3.56 & 76.21\(\pm\)4.65 & 88.44\(\pm\)4.20 & 88.12\(\pm\)2.53 \\  & **2B-TS2vec** & 81.61\(\pm\)1.65 & 81.47\(\pm\)1.75 & 81.53\(\pm\)1.68 & 81.43\(\pm\)1.65 & 89.50\(\pm\)1.60 & 89.22\(\pm\)1.75 \\  & **TS2vec** & 81.26\(\pm\)2.08 & 81.21\(\pm\)2.14 & 81.34\(\pm\)2.04 & 81.12\(\pm\)2.06 & 89.20\(\pm\)1.76 & 88.94\(\pm\)1.85 \\  & **COMET (Ours)** & **84.50\(\pm\)4.46** & **88.31\(\pm\)2.42** & **82.95\(\pm\)3.39** & **83.33\(\pm\)5.15** & **94.44\(\pm\)2.37** & **94.43\(\pm\)2.48** \\ \hline \multirow{6}{*}{**10\%**} & **4E-SimCLR** & 57.97\(\pm\)1.74 & 58.41\(\pm\)3.31 & 53.69\(\pm\)2.25 & 46.47\(\pm\)5.71 & 58.41\(\pm\)8.31 & 52.33\(\pm\)1.38 \\  & **4B-SimCLR** & 53.57\(\pm\)6.29 & 53.89\(\pm\)5.05 & 52.97\(\pm\)4.22 & 50.60\(\pm\)5.46 & 53.89\(\pm\)5.05 & 51.80\(\pm\)2.34 \\  & SimCLR & 56.90\(\pm\)2.25 & 53.81\(\pm\)5.43 & 51.73\(\pm\)2.59 & 44.10\(\pm\)4.84 & 53.81\(\pm\)5.74 & 51.08\(\pm\)1.53 \\  & **2E-TS2vec** & 66.29\(\pm\)7.86 & 69.92\(\pm\)5.13 & 67.79\(\pm\)4.64 & 56.36\(\pm\)8.55 & 78.54\(\pm\)4.98 & 77.95\(\pm\)5.29 \\  & **2B-TS2vec** & 72.61\(\pm\)4.46 & 73.86\(\pm\)3.46 & 72.98\(\pm\)3.66 & 72.30\(\pm\)2.41 & 81.91\(\pm\)4.83 & 81.74\(\pm\)4.85 \\  & **TS2vec** & 73.28\(\pm\)4.34 & 74.14\(\pm\)4.33 & 73.52\(\pm\)3.77 & 73.00\(\pm\)4.18 & 81.66\(\pm\)5.20 & 81.58\(\pm\)5.11 \\  & **COMET (Ours)** & **91.43\(\pm\)3.12** & **92.52\(\pm\)3.36** & **90.71\(\pm\)3.56** & **91.14\(\pm\)3.31** & **96.44\(\pm\)2.84** & **96.48\(\pm\)2.82** \\ \hline \multirow{6}{*}{**1\%**} & **4E-SimCLR** & 58.07\(\pm\)1.93 & 57.72\(\pm\)3.50 & 54.92\(\pm\)1.99 & 51.93\(\pm\)3.11 & 57.72\(\pm\)3.50 & 52.91\(\pm\)1.28 \\  & **4B-SimCLR** & 54.67\(\pm\)5.43 & 54.86\(\pm\)4.94 & 54.48\(\pm\)4.64 & 53.68\(\pm\)4.89 & 54.86\(\pm\)4.94 & 52.67\(\pm\)2.68 \\  & **SimCLR** & 55.42\(\pm\)2.43 & 52.18\(\pm\)5.55 & 51.37\(\pm\)2.76 & 45.02\(\pm\)4.79 & 52.18\(\pm\)5.55 & 50.87\(\pm\)1.45 \\  & **2E-TS2vec** & 63.56\(\pm\)4.62 & 64.97\(\pm\)3.53 & 64.49\(\pm\)3.90 & 63.28\(\pm\)4.69 & 70.26\(\pm\)3.55 & 68.77\(\pm\)3.59 \\  & **2B-TS2vec** & 64.18\(\pm\)4.53 & 64.26\(\pm\)4.80 & 64.26\(\pm\)4.80 & 63.93\(\pm\)4.61 & 70.07\(\pm\)5.97 & 68.62\(\pm\)6.25 \\  & **TS2vec** & 64.93\(\pm\)3.53 & 65.28\(\pm\)3.52 & 65.14\(\pm\)3.59 & 64.64\(\pm\)3.58 & 70.56\(\pm\)5.38 & 68.97\(\pm\)5.75 \\  & **COMET (Ours)** & **88.22\(\pm\)3.36** & **88.55\(\pm\)2.73** & **88.56\(\pm\)3.14** & **88.14\(\pm\)3.37** & **96.05\(\pm\)1.36** & **96.12\(\pm\)1.31** \\ \hline \hline \end{tabular}
\end{table}
Table 9: Heavy Duty Baselines. Run more epochs or add more contrastive blocks to SimCLR and TS2vec on the AD dataset.

## Appendix References

* [1]C. Ieracitano, N. Mammone, A. Bramanti, A. Hussain, and F. C. Morabito (2019) A convolutional neural network approach for classification of dementia stages based on 2d-spectral representation of eeg recordings. Neurocomputing323, pp. 96-107. Cited by: SS1.
* [2]L. Yang and S. Hong (2022) Unsupervised time-series representation learning with iterative bilinear temporal-spectral fusion. In International Conference on Machine Learning, pp. 25038-25054. Cited by: SS1.
* [3]D. Bassler, T. Kortus, and G. Guhring (2022) Unsupervised anomaly detection in multivariate time series with online evolving spiking neural networks. Machine Learning111 (4), pp. 1377-1408. Cited by: SS1.