# Interpretable Prototype-based Graph Information Bottleneck

 Sangwoo Seo\({}^{1}\) Sungwon Kim\({}^{1}\) Chanyoung Park\({}^{1}\)

\({}^{1}\)KAIST

{sangwooseo@kaist.ac.kr, swkim@kaist.ac.kr, cy.park@kaist.ac.kr}

Corresponding author.

###### Abstract

The success of Graph Neural Networks (GNNs) has led to a need for understanding their decision-making process and providing explanations for their predictions, which has given rise to explainable AI (XAI) that offers transparent explanations for black-box models. Recently, the use of prototypes has successfully improved the explainability of models by learning prototypes to imply training graphs that affect the prediction. However, these approaches tend to provide prototypes with excessive information from the entire graph, leading to the exclusion of key substructures or the inclusion of irrelevant substructures, which can limit both the interpretability and the performance of the model in downstream tasks. In this work, we propose a novel framework of explainable GNNs, called interpretable Prototype-based **G**raph **I**nformation **B**ottleneck (PGIB), that incorporates prototype learning within the information bottleneck framework to provide prototypes with the key subgraph from the input graph that is important for the model prediction. This is the first work that incorporates prototype learning into the process of identifying the key subgraphs that have a critical impact on the prediction performance. Extensive experiments, including qualitative analysis, demonstrate that PGIB outperforms state-of-the-art methods in terms of both prediction performance and explainability. The source code of PGIB is available at https://github.com/sang-woo-seo/PGIB.

## 1 Introduction

With the success of Graph Neural Networks (GNNs) in a wide range of deep learning tasks, there has been an increasing demand for exploring the decision-making process of these models and providing explanations for their predictions. To address this demand, explainable AI (XAI) has emerged as a way to understand black-box models by providing transparent explanations for their predictions. This approach can improve the credibility of models and ensure transparency in their decision-making processes. As a result, XAI is actively being used in various applications, such as medical, finance, security, and chemistry [3; 26].

In general, explainability can be viewed from two perspectives: 1) _improving the interpretability_ by providing explanations for the model's _predictions_, and 2) _providing the reasoning process_ behind the model prediction by giving explanations for the model's _training process_. _Improving the interpretability_ in GNNs involves detecting important substructures during the inference phase, which is useful for tasks such as identifying functional groups (i.e., important substructures) in molecular chemistry [29; 33; 23; 12]. On the other hand, it is also important to _provide the reasoning process_ for why the model predicts in a certain way, which requires an in-depth analysis of the training phase, so as to understand the model in a more fundamental level. Through this reasoning process, we can visualize and analyze how the model makes correct or incorrect decisions, thus obtaining crucial information for improving its performance.

In recent years, there has been a growing interest in exploring the reasoning process to provide greater transparency and explainability in deep learning models. These approaches can be generally classified into two main categories: 1) _post-hoc_ approaches, and 2) _built-in_ approaches. _Post-hoc_ approaches focus on exploring the model outputs by visualizing the degree of activation of neurons through measuring their contribution based on gradients of the model predictions. For instance, recent works [14, 9, 34] use techniques such as saliency maps and class activation maps to visualize the activated areas during the model's prediction process. However, these approaches require a separate explanatory model for each trained model, resulting in the need for a new explanatory model for additional training data and different models [2, 15]. In order to address the aforementioned challenges, _built-in_ approaches aim to integrate the generation of explanations into the model training process. One such approach is prototype learning, which involves learning prototypes that represent each class of the input data, which are then compared with new instances to make predictions. ProtGNN [35], for instance, measures the similarity between the embedding of an input graph and each prototype, providing explanations through the similarity calculation and making predictions for the input graph based on its similarity with the learned prototypes. More precisely, ProtGNN projects each learned prototype onto the closest training graph, enabling it to provide explanations of primary structures for its prediction.

However, since ProtGNN compares the graph-level embedding of an input graph with the learned prototypes, the model overlooks the key substructures in the input graph while also potentially including uninformative substructures. This not only results in a degradation of the interpretability of the reasoning process, but also limits the performance on the downstream tasks. Figure 1(a) shows the prototype graphs in the training set (i.e., \(\mathcal{G}_{p}\), denoted as bold edges) detected by ProtGNN for an input molecule (i.e., \(\mathcal{G}\)) that belongs to the "mutagenic" class. Despite the \(\mathrm{NO}_{2}\) structure being the key functional group for classifying a given molecule as "mutagenic," \(\mathcal{G}_{p}\) detected by ProtGNN tends to include numerous ring structures (i.e., uninformative substructures) that are commonly found throughout the input graph, and exclude \(\mathrm{NO}_{2}\) structures (i.e., key substructures) in learned prototype graphs, which is mainly due to the fact that the input graph \(\mathcal{G}\) is considered in the whole graph-level. As a result, it is crucial to identify a key subgraph within the input graph that holds essential information for the learning of prototypes, which in turn enhances both the explanation of the reasoning process and the performance on the downstream tasks. Among the various solutions for detecting important subgraphs, the Information Bottleneck (IB) has emerged as one of the most effective methods [27, 31], and it has been demonstrated that key subgraphs detected based on IB can contribute to performance improvement in various tasks such as relational learning [11] and structure learning [19]. We aim to approach the IB principle from the perspective of prototypes to convey important substructure information to the prototypes.

To this end, we propose a novel framework of explainable GNNs, called Interpretable Prototype-based Graph Information Bottleneck (PGIB). The main idea is to incorporate prototype learning within the Information Bottleneck (IB) framework, which enables the prototypes to capture the essential key subgraph of the input graph detected by the IB framework. Specifically, PGIB involves prototypes (i.e., \(\mathcal{G}_{p}\)) in a process that maximizes the mutual information between the learnable key subgraph (i.e., \(\mathcal{G}_{sub}\)) of the input graph (i.e., \(\mathcal{G}\)) and target information (i.e., \(Y\)), which allows the prototypes to interact with the subgraph. This enables the learning of prototypes \(\mathcal{G}_{p}\) based on the key subgraph \(\mathcal{G}_{sub}\) within the input graph \(\mathcal{G}\), leading to a more precise explanation of the reasoning process and improvement in the performance on the downstream tasks. To the best of our knowledge, this is the first work that combines the process of optimizing the reasoning process and interpretability by identifying the key subgraphs that have a critical impact on the prediction performance. In Figure 1(b), PGIB is shown to successfully detect the key subgraph \(\mathcal{G}_{sub}\) that includes \(\mathrm{NO}_{2}\) from the input graph \(\mathcal{G}\), even when the ring structures are dominant in \(\mathcal{G}\). It is important to note that PGIB is highly efficient in detecting \(\mathcal{G}_{sub}\) from \(\mathcal{G}\) since PGIB adopts a learnable masking technique, effectively resolving the time complexity issue. Last but not least, since the number of prototypes for each

Figure 1: Comparison of the learned prototypes between ProtGNN and PGIB.

class is determined before training, some of the learned prototypes may share similar semantics, which negatively affects the model interpretability for which the small size and low complexity are desirable [6; 25; 17]. Hence, we propose a method for effectively merging the prototypes, which in turn contributes to enhancing both the explanation of the reasoning process and the performance on the downstream tasks.

We conducted extensive experiments to evaluate the effectiveness and interpretability of the reasoning process of PGIB in graph classification tasks. Our results show that PGIB outperforms recent state-of-the-art methods, including existing prototype learning-based and IB-based methods. Moreover, we evaluated the ability of PGIB in capturing the label information by evaluating the classification performance using only the detected subgraph \(\mathcal{G}_{sub}\). We also conducted a qualitative analysis that visualizes the subgraph \(\mathcal{G}_{sub}\) and prototype graph \(\mathcal{G}_{p}\), suggesting the ability of PGIB in detecting the key subgraph. Overall, our results show that PGIB significantly improves the interpretability of both \(\mathcal{G}_{sub}\) and \(\mathcal{G}_{p}\) in the reasoning process, while simultaneously improving the performance in downstream tasks.

In summary, our main contributions can be summarized as follows: **1)** We propose an effective approach, PGIB, that not only improves the interpretability of the reasoning process, but also the overall performance in downstream tasks by incorporating the prototype learning in a process of detecting key subgraphs based on the IB framework. **2)** We provide theoretical background with our method that utilizes interpretable prototypes in the process of optimizing \(\mathcal{G}_{sub}\). **3)** Extensive experiments, including qualitative analysis, demonstrate that PGIB outperforms state-of-the-art methods in terms of both prediction performance and explainability.

## 2 Preliminaries

In this section, we introduce notations used throughout the paper followed by the definitions of IB and IB-Graph.

Notations.We use \(\mathcal{G}=(\mathcal{V},\mathcal{E},\mathbf{A},\mathbf{X})\) to denote a graph, where \(\mathcal{V}\), \(\mathcal{E}\), \(\mathbf{A}\) and \(\mathbf{X}\) denote the set of nodes and edges, the adjacency matrix and node features, respectively. We assume that each node \(v_{i}\in\mathcal{V}\) is associated with a feature vector \(\mathbf{x}_{i}\), which is the \(i\)-th row of \(\mathbf{X}\). We use \(\{(\mathcal{G}_{1},y_{1}),(\mathcal{G}_{2},y_{2}),\cdots,(\mathcal{G}_{N},y_{ N})\}\) to denote the set of \(N\) graphs with its corresponding labels. The graph labels are given by a set of \(K\) classes \(\mathcal{C}=\{1,2,\ldots,K\}\), and the ground truth label of a graph \(\mathcal{G}_{i}\) is denoted by \(y_{i}\in\mathcal{C}\). We use \(\mathcal{G}_{sub}\) to denote a subgraph of \(\mathcal{G}\), and use \(\tilde{\mathcal{G}}_{sub}\) to denote the complementary structure of \(\mathcal{G}_{sub}\) in \(\mathcal{G}\). We also introduce the prototype layer, which consists of a set of prototypes \(\mathcal{Z}_{p}=\left\{\mathbf{z}_{\mathcal{G}_{p}}^{1},\mathbf{z}_{\mathcal{ G}_{p}}^{2},\cdots,\mathbf{z}_{\mathcal{G}_{p}}^{M}\right\}\), where \(M\) is the total number of prototypes, and each prototype \(\mathbf{z}_{\mathcal{G}_{p}}^{m}\) is a learnable parameter vector that serves as the latent representation of the prototypical part (i.e., \(\mathcal{G}_{p}\)) of graph \(\mathcal{G}\). We allocate \(J\) prototypes for each class, i.e., \(M=K\times J\).

Graph Information Bottleneck.The mutual information between two random variables \(X\) and \(Y\), i.e., \(I(X;Y)\), is defined as follows:

\[I(X;Y)=\int_{X}\int_{Y}p(x,y)\log\frac{p(x,y)}{p(x)p(y)}\text{d}x\text{d}y\] (1)

Given the input \(X\) and its associated label \(Y\), the Information Bottleneck (IB) [21] aims to obtain a bottleneck variable \(Z\) by optimizing the following objective:

\[\min_{Z}-I(Y;Z)+\beta I(X;Z),\] (2)

where \(\beta\) is the Lagrange multiplier used to control the trade-off between the two terms. IB principle has recently been applied to learning a bottleneck graph, named IB-Graph, for a given graph \(\mathcal{G}\), which retains the minimal sufficient information in terms of \(\mathcal{G}\)'s properties [31]. This approach is motivated by the Graph Information Bottleneck (GIB) principle, which seeks to identify an informative yet compressed subgraph \(\mathcal{G}_{sub}\) from the original graph \(\mathcal{G}\) by optimizing the following objective:

\[\min_{\mathcal{G}_{sub}}-I(Y;\mathcal{G}_{sub})+\beta I(\mathcal{G};\mathcal{ G}_{sub}),\] (3)

where \(Y\) is the label of \(\mathcal{G}\). The first term maximizes the mutual information between the graph label and the compressed subgraph, which ensures that the compressed subgraph contains as much information as possible about the graph label. The second term minimizes the mutual information between the input graph and the compressed subgraph, which ensures that the compressed subgraph contains minimal information about the input graph.

## 3 Methodology

In this section, we present our proposed method, called PGIB. We introduce Prototype-based Graph Information Bottleneck (Section 3.1), each layer in the architecture (Section 3.2 - 3.4), and the interpretability stabilization process (Section 3.5), which enhances the interpretability and the tracking capabilities of the reasoning process during the model training.

**Model Architecture.** Figure 2 presents an overview of PGIB. We first generate the representations of nodes in the input graph \(\mathcal{G}\) using a GNN encoder. Then, the node representations are passed to the subgraph extraction layer that assigns each node in \(\mathcal{G}\) to either \(\mathcal{G}_{sub}\) or \(\bar{\mathcal{G}}_{sub}\). Next, we compute the similarities between the embedding \(\mathbf{z}_{\mathcal{G}_{sub}}\) and the set of prototypes \(\mathcal{Z}_{p}=\left\{\mathbf{z}_{\mathcal{G}_{p}}^{1},\mathbf{z}_{\mathcal{ G}_{p}}^{2},\cdots,\mathbf{z}_{\mathcal{G}_{p}}^{M}\right\}\) in the prototype layer. Finally, we merge the prototypes that are semantically similar, which are then used to generate the final prediction.

### Prototype-based Graph Information Bottleneck

PGIB is a novel explainable GNN framework that incorporates the prototype learning within the IB framework, thereby enabling the prototypes to capture the essential key subgraph of the input graph detected by the IB framework. More precisely, we reformulate the GIB objective shown in Equation 3 by decomposing the first term, i.e., \(I(Y;\mathcal{G}_{sub})\), with respect to the prototype \(\mathcal{G}_{p}\) using the chain rule of mutual information in order to examine the impact of the joint information between \(\mathcal{G}_{sub}\) and \(\mathcal{G}_{p}\) on \(Y\) as follows:

\[\min_{\mathcal{G}_{sub}}\underbrace{-I(Y;\mathcal{G}_{sub},\mathcal{G}_{p})+I (Y;\mathcal{G}_{p}|\mathcal{G}_{sub})}_{\text{Section 3.3}}+\beta\underbrace{I( \mathcal{G};\mathcal{G}_{sub})}_{\text{Section 3.2}}.\] (4)

Please refer to Appendix A.1 for a detailed proof of Equation 4. In the following sections, we describe how each term is optimized during training.

### Subgraph Extraction Layer (Minimizing \(I(\mathcal{G};\mathcal{G}_{sub})\))

The goal of the subgraph extraction layer is to extract an informative subgraph \(\mathcal{G}_{sub}\) from \(\mathcal{G}\) that contains minimal information about \(\mathcal{G}\). We minimize \(I(\mathcal{G};\mathcal{G}_{sub})\) by training the model to inject noise into insignificant subgraphs \(\bar{\mathcal{G}}_{sub}\), while injecting less noise into more informative ones \(\mathcal{G}_{sub}\)[32]. Specifically, given the representation of node \(v_{i}\), i.e., \(\mathbf{h}_{i}\), we compute the probability \(p_{i}\) with an MLP followed by a sigmoid function, which is then used to replace the representation \(h_{i}\) to obtain the final representation \(\mathbf{z}_{i}\) as follows:

\[\begin{split} p_{i}=\operatorname{Sigmoid}(\operatorname{MLP}(h_{i }))\\ z_{i}=\lambda_{i}h_{i}+(1-\lambda_{i})\epsilon,\ \text{ where }\lambda_{i} \sim\operatorname{Bernoulli}(p_{i})\text{ and }\epsilon\sim\mathcal{N}(\mu_{\mathbf{h}_{i}},\sigma_{ \mathbf{h}_{i}}^{2}).\end{split}\] (5)

That is, the learned probability \(p_{i}\) enables selective preservation of information in \(\mathcal{G}_{sub}\), and based on this probability, the quantity of information transmitted from \(\mathbf{h}_{i}\) to \(\mathbf{z}_{i}\) can be flexibly adjusted to compress the information from \(\mathcal{G}\) to \(\mathcal{G}_{sub}\). This approach not only retains interpretability within the

Figure 2: The architecture of our proposed PGIB. PGIB generates a subgraph \(\mathcal{G}_{sub}\) by injecting noise to identify core subgraphs, and it is used to compute similarity scores between prototypes in the prototype layer. The trained prototypes play a crucial role in visualizing the reasoning processes during training in an interpretable manner. PGIB also involves merging pairs of similar prototypes to decrease the number of prototypes. Finally, the integrated prototypes are utilized to predict the graph labels in the fully connected layer.

subgraph itself, but also potentially facilitates the learning of prototypes that are introduced in the next step. Following [32], we minimize the upper bound of \(I(\mathcal{G};\mathcal{G}_{sub})\) as follows:

\[I(\mathcal{G};\mathcal{G}_{sub})\leq\mathbb{E}_{\mathcal{G}}(-\frac{1}{2}\log A +\frac{1}{2|\mathcal{V}_{\mathcal{G}}|}A+\frac{1}{2|\mathcal{V}_{\mathcal{G}}| }B^{2})=:\mathcal{L}_{\mathrm{MI}}^{1}(\mathcal{G},\mathcal{G}_{sub}),\] (6)

where \(A=\sum_{i=1}^{|\mathcal{V}_{\mathcal{G}}|}(1-\lambda_{i})^{2}\) and \(B=\frac{\sum_{i=1}^{|\mathcal{V}_{\mathcal{G}}|}\lambda_{i}(\mathbf{h}_{i}- \mathbf{\mu}_{\mathbf{h}_{i}})}{\sigma_{\mathbf{h}_{i}}}\). Thus, minimizing \(\mathcal{L}_{\mathrm{MI}}^{1}\) allows us to minimize the upper bound of \(I(\mathcal{G};\mathcal{G}_{sub})\). After noise injection, we compute the embedding \(\mathbf{z}_{\mathcal{G}_{sub}}\) through a graph readout function such as max pooling and sum pooling. For further details and analysis of the different graph readout functions, please refer to Appendix A.4.2.

Prototype Layer (Minimizing \(-I(Y;\mathcal{G}_{sub},\mathcal{G}_{p})+I(Y;\mathcal{G}_{p}|\mathcal{G}_{sub})\) )

The prototype layer involves allocation of a fixed number of prototypes for each class. The prototypes are required to capture the most significant graph patterns that can aid in the identification of the graphs within each class. To begin with, we define the similarity score between the prototype \(\mathbf{z}_{\mathcal{G}_{p}}\) and the embedding \(\mathbf{z}_{\mathcal{G}_{sub}}\) obtained from noise injection as follows:

\[g(\mathbf{z}_{\mathcal{G}_{sub}},\mathbf{z}_{\mathcal{G}_{p}})=\log\left( \frac{\|\mathbf{z}_{\mathcal{G}_{sub}}-\mathbf{z}_{\mathcal{G}_{p}}\|_{2}^{2 }+1}{\|\mathbf{z}_{\mathcal{G}_{sub}}-\mathbf{z}_{\mathcal{G}_{p}}\|_{2}^{2 }+\epsilon}\right),\] (7)

where \(\mathbf{z}_{\mathcal{G}_{p}}\) is the prototype and shares the same dimension as \(\mathbf{z}_{\mathcal{G}_{sub}}\).

#### 3.3.1 Minimizing \(-I(Y;\mathcal{G}_{sub},\mathcal{G}_{p})\)

We derive the lower bound of \(I(Y;\mathcal{G}_{sub},\mathcal{G}_{p})\) as follows:

_Proposition 1_.: **(Lower bound of \(I(Y;\mathcal{G}_{sub},\mathcal{G}_{p})\))** Given significant subgraph \(\mathcal{G}_{sub}\) for a graph \(\mathcal{G}\), its label information \(Y\), prototype graph \(\mathcal{G}_{p}\) and similarity function \(\gamma\), we have

\[\begin{split} I(Y;\mathcal{G}_{sub},\mathcal{G}_{p})& =\mathbb{E}_{Y,\mathcal{G}_{sub},\mathcal{G}_{p}}\left[\log p\left(Y| \mathcal{G}_{sub},\mathcal{G}_{p}\right)\right]-\mathbb{E}_{Y}\left[\log p(Y)\right] \\ &\geq\mathbb{E}_{Y,\mathcal{G}_{sub},\mathcal{G}_{p}}\left[\log p \left(Y|\gamma\left(\mathcal{G}_{sub},\mathcal{G}_{p}\right)\right)\right]- \mathbb{E}_{Y}\left[\log p(Y)\right]\\ &\geq\mathbb{E}_{Y,\mathcal{G}_{sub},\mathcal{G}_{p}}\left[\log q _{p}\left(Y|\gamma\left(\mathcal{G}_{sub},\mathcal{G}_{p}\right)\right)\right] \\ &=:-\mathcal{L}_{\mathrm{cls}}(q_{p}\left(Y|\gamma\left(\mathcal{G }_{sub},\mathcal{G}_{p}\right)\right))\end{split}\] (8)

where \(q_{\theta}\left(Y|\gamma\left(\mathcal{G}_{sub},\mathcal{G}_{p}\right)\right)\) is the variational approximation to the true posterior \(p\left(Y|\gamma\left(\mathcal{G}_{sub},\mathcal{G}_{p}\right)\right)\).

Equation 8 demonstrates that the maximization of the mutual information \(I(Y;\mathcal{G}_{sub},\mathcal{G}_{p})\) can be attained by minimizing the classification loss, denoted as \(\mathcal{L}_{cls}\). This maximization of mutual information between the label \(Y\) and the similarity information \(\gamma\left(\mathcal{G}_{sub},\mathcal{G}_{p}\right)\) promotes the subgraph \(\mathcal{G}_{sub}\) and prototype \(\mathcal{G}_{p}\) to possess predictive capabilities concerning the graph label \(Y\). In practical applications, the cross-entropy loss is chosen for a categorical \(Y\). For a comprehensive understanding of the derivation process of Equation 8, refer to the Appendix A.2. Note that the similarity between \(\mathcal{G}_{sub}\) and \(\mathcal{G}_{p}\), i.e., \(\gamma\left(\mathcal{G}_{sub},\mathcal{G}_{p}\right)\), is computed by the similarity score defined in Equation 7, i.e., \(g(\mathbf{z}_{\mathcal{G}_{sub}},\mathbf{z}_{\mathcal{G}_{p}})\).

#### 3.3.2 Minimizing \(I(Y;\mathcal{G}_{p}|\mathcal{G}_{sub})\)

We investigate the mutual information, denoted as \(I(Y;\mathcal{G}_{p}|\mathcal{G}_{sub})\), from the perspective of the interaction between \(\mathcal{G}_{sub}\) and \(\mathcal{G}_{p}\). We decompose \(I(Y;\mathcal{G}_{p}|\mathcal{G}_{sub})\) into the sum of two terms based on the chain rule of mutual information as follows:

\[I(Y;\mathcal{G}_{p}|\mathcal{G}_{sub})=I(\mathcal{G}_{p};Y,\mathcal{G}_{sub})-I (\mathcal{G}_{sub};\mathcal{G}_{p}).\] (9)

It is important to note that the first term, i.e., \(I(\mathcal{G}_{p};Y,\mathcal{G}_{sub})\), minimizes the mutual information between \(\mathcal{G}_{p}\) and the joint variables \((Y,\,\mathcal{G}_{sub})\), which eliminates the information about \(Y\) related to \(\mathcal{G}_{sub}\) from \(\mathcal{G}_{p}\). However, since our goal is not to solely minimize \(I(\mathcal{G}_{p};Y,\mathcal{G}_{sub})\) but to ensure the interpretability of the prototype \(\mathcal{G}_{p}\), including this term leads to diminished interpretability of \(\mathcal{G}_{p}\). Consequently, we excluded the first term during training, and only consider the second term, i.e., \(-I(\mathcal{G}_{sub};\mathcal{G}_{p})\), to simultaneously guarantee the interpretability of both \(\mathcal{G}_{sub}\) and \(\mathcal{G}_{p}\). A detailed derivation for Equation 9 is given in Appendix A.3. From now on, we describe approaches for minimizing the second term. Inspired by [11], we introduce two different approaches for minimizing \(-I(\mathcal{G}_{sub};\mathcal{G}_{p})\).

[MISSING_PAGE_FAIL:6]

\[\small\mathbf{z}_{\mathcal{G}_{p}}\leftarrow\operatorname*{arg\,min}_{\tilde{ \mathbf{z}}\in\mathbb{Z}}\|\tilde{\mathbf{z}}-\mathbf{z}_{\mathcal{G}_{p}}\|_{ 2},\text{ where }\mathbb{Z}=\left\{\tilde{\mathbf{z}}:\text{Readout}\{f_{g}(\vec{ \mathcal{G}})\},\vec{\mathcal{G}}\in\text{Subgraph}(\mathcal{G}_{i})\ \forall i\text{ }s \text{.t. }y_{i}=k\right\}.\] (14)

In the Equation 14, we use Monte Carlo Tree Search (MCTS) [18] to explore training subgraphs \(\vec{\mathcal{G}}\) during prototype projection.

Connectivity Loss.For an input graph \(\mathcal{G}\), we construct a node assignment \(S_{\mathcal{G}}\in\mathbb{R}^{|\mathcal{V}_{\mathcal{G}}|\times 2}\) based on the probability values that are computed by Equation 5. Specifically, \(S_{\mathcal{G}}[j,0]\) and \(S_{\mathcal{G}}[j,1]\) denote the probability of node \(v_{j}\in\mathcal{V}_{\mathcal{G}}\) belonging to \(\mathcal{G}_{sub}\) and \(\vec{\mathcal{G}}_{sub}\), respectively. Following [31], poor initialization of the matrix \(S\) may result in the proximity of its elements \(S[j,0]\) and \(S[j,1]\) for \(\forall v_{j}\in\mathcal{V}_{\mathcal{G}_{i}}\), leading to an unstable connectivity of \(\mathcal{G}_{sub}\). This instability can have adverse effects on the subgraph generation process. To enhance the interpretability of \(\mathcal{G}_{sub}\) by inducing a compact topology, we utilize a batch-wise loss function as follows:

\[\mathcal{L}_{\mathrm{con}}=\|\mathrm{Norm}(S_{\mathrm{B}}^{T}\mathbf{A}_{ \mathrm{B}}S_{\mathrm{B}})-I_{2}\|_{F}\] (15)

where \(S_{\mathrm{B}}\in\mathbb{R}^{\sum\limits_{i=1}^{n}|\mathcal{V}_{\mathcal{G}_{ i}}|\times 2}\) and \(\mathbf{A}_{\mathrm{B}}\in\mathbb{R}^{\sum\limits_{i=1}^{n}|\mathcal{V}_{ \mathcal{G}_{i}}|\times\sum\limits_{i=1}^{n}|\mathcal{V}_{\mathcal{G}_{i}}|}\) are the node assignment and the adjacency matrix at the batch level, respectively. \(I_{2}\) is 2-by-2 identity matrix, \(\|\cdot\|_{F}\) is the Frobenius norm and \(\mathrm{Norm}(\cdot)\) is the row normalization. Minimizing \(\mathcal{L}_{\mathrm{con}}\) indicates that if \(v_{j}\) is in \(\mathcal{G}_{sub}\) its neighbors also have a high probability to be in \(\mathcal{G}_{sub}\), while if \(v_{i}\) is in \(\mathcal{G}_{sub}\), its neighbors have a low probability to be in \(\vec{\mathcal{G}}_{sub}\).

Final Objectives.Finally, we define the objective of our model as the sum of the losses as follows:

\[\mathcal{L}_{\mathrm{total}}=\mathcal{L}_{\mathrm{cls}}+\alpha_{1}\mathcal{L}_ {\mathrm{MI}}^{1}+\alpha_{2}\mathcal{L}_{\mathrm{MI}}^{2}+\alpha_{3}\mathcal{L }_{\mathrm{con}}\] (16)

where \(\alpha_{1},\alpha_{2}\) and \(\alpha_{3}\) are hyper-parameters that adjust the weights of the losses. A detailed ablation study for each loss term is provided in Appendix A.4.1 for further analysis.

## 4 Experiments

### Experimental Settings

Each dataset is split into training, validation, and test sets with a ratio of \(80\%\), \(10\%\), and \(10\%\), respectively. All models are trained for \(300\) epochs using the Adam optimizer with a learning rate of 0.005. GIN [28] is used as the encoder for all models used in the experiment. We evaluate the performance based on accuracy, which is averaged over 10 independent runs with different random seeds. For simplicity, the hyperparameters \(\alpha_{1}\), \(\alpha_{2}\), and \(\alpha_{3}\) in Equation 16 are set to \(0.0001,0.01\) to \(0.1\) and \(5\), respectively. The prototype merge operation starts at epoch \(100\) and is performed every \(50\) epochs thereafter. We set the number of prototypes per class to \(7\) and combine \(30\%\) of the most similar prototype pairs.

### Graph Classification

Datasets and Baselines. We use the MUTAG [16], PROTEINS [1], NCI1 [24], and DD[5] datasets. These are datasets related to molecules or bioinformatics, and are widely used for evaluations on graph classification. We consider three GNN baselines, including GCN [10], GIN [28], GAT [22]. In addition, we compare PGIB with several state-of-the-art built-in models that integrate explanation functionality internally, including a prototype-based method ProtGNN [35], and IB-based models such as GIB [31], VGIB [32], and GSAT [13]. Further details about the baselines and datasets are provided in Appendix A.5 and A.6, respectively.

Experiment Results. Experimental results for graph classification are presented in the Table 1. In the table, PGIB and PGIB\({}_{\text{\sf{cont}}}\) represent our proposed methods. PGIB utilizes a Variational IB-based approach, while PGIB\({}_{\text{\sf{cont}}}\) employs a Contrastive learning-based approach to maximize \(I(\mathcal{G}_{\text{sub}};\mathcal{G}_{p})\) (Section 3.3.2). We have the following observations: **1)** All variants of PGIB outperform the baselines including both the prototype-based and IB-based methods on all datasets. Notably, PGIBs incorporate the crucial information of the key subgraph, which significantly contributes to enhancing the classification performance. PGIB\({}_{\text{\sf{cont}}}\) achieves a significant improvement of up to 5.6% compared to the runner-up baseline. **2)** We observe that PGIB\({}_{\text{\sf{cont}}}\) performs relatively better than PGIB. We attribute this to the nature of the contrastive loss, which is generally shown to be effective in classifying instances between different classes, allowing the prototypes learned based on the contrastive loss to be more distinguishable from one another.

### Graph Interpretation

In this section, we evaluate the process of extracting subgraphs that possess the most similar properties of the original graph. We present qualitative results including subgraph visualizations, and conduct quantitative experiments to measure how accurately explanations capture the important components that contribute to the model's predictions.

**Datasets and Baselines**. We use four molecular properties from the ZINC [8] dataset, which consists of 250,000 molecules, for graph interpretation. QED measures the likelihood of a molecule being a drug and DRD2 indicates the probability of a molecule being active on dopamine type 2 receptors. HLM-CLint and RLM represent estimates of in vitro human and rat liver microsomal metabolic stability (mL/min/g as base 10 logarithm). We compare PGIB\({}_{\text{cont}}\) with several representative interpretation models, including GNNexpliner [29], PGexpliner [12], GIB [31], and VGIB [32]. Note that as PGIB shows similar results with PGIB\({}_{\text{cont}}\), we only report the results of PGIB\({}_{\text{cont}}\) for simplicity. Further details on baselines and datasets are described in Appendix A.5 and A.6, respectively.

**Qualitative Analysis**. Figure 3(a)-(d) present the visualization of subgraphs in Mutag dataset. According to [29; 4], the \(\mathrm{NO}_{2}\) functional group is known to be a cause of mutagenicity, while the carbon ring is a substructure that is not related to mutagenicity. In the figure, the bold edges connect the nodes that the models consider important. The \(\mathrm{NO}_{2}\) group in Mutag is correctly identified by PGIB, while VGIB, ProtGNN, and GNNexplainer fail to recognize all \(\mathrm{NO}_{2}\) groups or include other unnecessary substructures. Figure 3(e)-(h) present the visualization of subgraphs in BA-2Motifs dataset. We observe that PGIB accurately recognizes motif graphs containing the label information such as a house or a five-node cycle, but other models have difficulty in detecting the complete motifs.

**Quantitative Analysis**. Although visualizing the explanations generated by models plays a crucial role in assessing various explanation models, relying solely on qualitative evaluations may not always be reliable due to their subjective nature. Therefore, we also perform quantitative experiments using the Fidelity metric [14; 34].

The Fidelity metric quantifies the extent to which explanations accurately capture the important components that contribute to the model's predictions. Specifically, let \(y_{i}\) and \(\hat{y}_{i}\) denote the ground-truth and predicted values for the \(i\)-th input graph, respectively. Moreover, \(k\) denotes the sparsity score of the selected subgraph in which nodes whose importance scores obtained by Equation 5 are among the top-\((k\times 100)\)% within the original graph, and its prediction is denoted by \(\hat{y}_{i}^{k}\). Additionally, \(\hat{y}_{i}^{1-k}\) denotes the prediction based on the remaining subgraph. The Fidelity scores are computed as follows:

\[\mathcal{F}_{-}=\frac{1}{N}\sum_{i=1}^{N}\mathbb{I}(y_{i}=\hat{y}_{i})- \mathbb{I}(y_{i}=\hat{y}_{i}^{k}),\quad\mathcal{F}_{+}=\frac{1}{N}\sum_{i=1}^ {N}\mathbb{I}(y_{i}=\hat{y}_{i})-\mathbb{I}(y_{i}=\hat{y}_{i}^{1-k}),\] (17)

where \(\mathbb{I}(y_{i}=\hat{y}_{i})\) is the binary indicator which returns 1 if \(y_{i}=\hat{y}_{i}\), and 0 otherwise. In other words, they measure how well the predictions made solely based on the extracted subgraph (i.e., \(\mathcal{F}_{-}\)) and the remaining subgraph (i.e., \(\mathcal{F}_{+}\)) mimic the predictions made based on the entire graph, respectively. Hence, a low value of \(\mathcal{F}_{-}\) and a high value of \(\mathcal{F}_{-}\) indicate better explainability of the model.

Table 2 shows the fidelity scores on four datasets at the sparsity score of \(k=0.5\). Our proposed model outperforms both post-hoc and built-in state-of-the-art explanation models in all datasets. Furthermore, merging prototypes achieves significant improvements in terms of interpretability. This implies

\begin{table}
\begin{tabular}{c|c c c c c c|c c c|c} \hline \multirow{2}{*}{Dataset} & \multicolumn{8}{c}{Methods} \\ \cline{2-11}  & GCN & GIN & GAT & ProtGNN & GIB & VGIB & GSAT & **PGIB** & **PGIB\({}_{\text{cont}}\)** \\ \hline MUTAG & 74.50\(\pm\)7.89 & 80.50\(\pm\)7.89 & 73.50\(\pm\)7.43 & 80.50\(\pm\)9.07 & 79.00\(\pm\)6.24 & 81.00\(\pm\)6.63 & 80.88\(\pm\)8.94 & 85.00\(\pm\)7.07 & **85.50\(\pm\)5.22** \\ PROTEINS & 72.83\(\pm\)4.23 & 70.30\(\pm\)4.84 & 71.35\(\pm\)4.85 & 73.83\(\pm\)4.22 & 75.25\(\pm\)5.92 & 73.66\(\pm\)3.32 & 69.64\(\pm\)4.71 & 77.14\(\pm\)2.19 & **77.50\(\pm\)2.42** \\ NCI1 & 73.16\(\pm\)3.49 & 75.04\(\pm\)2.08 & 66.05\(\pm\)1.03 & 74.13\(\pm\)2.10 & 64.65\(\pm\)6.78 & 63.75\(\pm\)3.37 & 68.13\(\pm\)2.64 & 77.65\(\pm\)2.20 & **78.25\(\pm\)2.13** \\ DD & 72.53\(\pm\)4.51 & 72.04\(\pm\)3.62 & 70.81\(\pm\)4.33 & 69.15\(\pm\)4.33 & 72.61\(\pm\)8.26 & 72.77\(\pm\)45.63 & 71.93\(\pm\)2.74 & 73.36\(\pm\)1.80 & **73.70\(\pm\)2.14** \\ \hline \end{tabular}
\end{table}
Table 1: Evaluation on graph classification (accuracy).

\begin{table}
\begin{tabular}{c|c c c c c c c} \hline \multirow{2}{*}{**Method**} & \multicolumn{5}{c}{\(\mathcal{F}_{+}\uparrow\)} \\ \cline{2-10}  & RLM & HLM-CLint & QED & DRD2 & RLM & HLM-CLint & QED & DRD2 \\ \hline GNNexpliner & 0.478 & 0.616 & 0.498 & 0.433 & 0.694 & 0.778 & 0.602 & 0.740 \\ PGexplainer & 0.502 & 0.620 & 0.560 & 0.540 & 0.632 & 0.692 & 0.598 & 0.686 \\ GIB & 0.483 & 0.643 & 0.525 & 0.428 & 0.654 & 0.781 & 0.601 & 0.724 \\ VGIB & 0.463 & 0.579 & 0.487 & 0.424 & 0.765 & 0.792 & 0.627 & 0.756 \\ \hline PGIB\({}_{\text{cont}}\) & 0.441 & 0.593 & 0.459 & 0.406 & 0.747 & 0.772 & 0.613 & 0.771 \\ PGIB\({}_{\text{cont}}\) + merge & **0.415** & **0.543** & **0.447** & **0.379** & **0.765** & **0.796** & **0.635** & **0.781** \\ \hline \end{tabular}
\end{table}
Table 2: Evaluation on graph interpretation (Fidelity scores).

that decreasing the number of prototypes can eliminate uninformative substructures and emphasize key substructures, which increases the interpretability of the extracted subgraphs. Figure 4 visualizes the comparison of fidelity scores over various sparsity scores of subgraphs. To ensure a fair comparison, the fidelity scores are compared under the same subgraph sparsity, as the difference between the predictions of the original graph and subgraph strongly depends on the level of sparsity. We observe that PGIB\({}_{\text{cont}}\) achieves the best performance in most sparsity environments on the four datasets.

### Hyperparameter Analysis

In Figure 6, we conduct a sensitivity analysis on the hyperparameters \(\alpha_{1}\) and \(\alpha_{2}\) of the final loss (Equation 16) relevant to mutual information. Note that \(\alpha_{1}\) and \(\alpha_{2}\) are related to minimizing \(I(\mathcal{G};\mathcal{G}_{sub})\) and maximizing \(I(\mathcal{G}_{sub};\mathcal{G}_{p})\), respectively. **1)** Figure 6(a) shows a significant decrease in performance when \(\alpha_{1}\) becomes large, i.e., when the model focuses on compressing the subgraphs. This is because too much compression of subgraphs results in the loss of important information, ultimately having a negative impact on the downstream performance. However, when \(\alpha_{1}=0\) (i.e., \(\mathcal{G}=\mathcal{G}_{sub}\); no compression at all), uninformative information would be included in \(\mathcal{G}_{sub}\), which incurs a performance degradation. **2)** Figure 6(b) visualizes the change in performance depending on \(\alpha_{2}\). A small value of \(\alpha_{2}\) prevents sufficient transmission of information from \(\mathcal{G}_{sub}\) to \(\mathcal{G}_{p}\), whereas excessive value of \(\alpha_{2}\) allows the influence of \(\mathcal{G}_{sub}\) to dominate the prototypes \(\mathcal{G}_{p}\), both of which lead to a performance deterioration. For example, in Mutag dataset, a low value of \(\alpha_{2}\) ultimately results in \(\mathcal{G}_{p}\) not obtaining label-relevant information (i.e., NO\({}_{2}\)) that is captured by \(\mathcal{G}_{sub}\) (See Figure 5(a)). On the other hand, a high value of \(\alpha_{2}\) hinders the formation of diverse prototypes (See Figure 5(b)).

## 5 Conclusion and Future work

We propose a novel framework of explainable GNNs, called interpretable Prototype-based Graph Information Bottleneck (PGIB), that integrates prototype learning into the information bottleneck framework. The main idea of PGIB is to learn prototypes that capture subgraphs containing key structures relevant to the label information, and to merge the semantically similar prototypes for better model interpretability and model complexity. Experimental results show that PGIB achieves improvements not only in the performance on downstream tasks, but also provides more precise explanation of the reasoning process. For future work, we plan to further extend the applicability of PGIB by integrating domain knowledge into prototype learning by imposing constraints on subgraphs. We expect that this approach would enable the learning of prototypes that align with the domain knowledge as they obtain domain-specific information from the subgraphs.

## Acknowledgments and Disclosure of Funding

This work was supported by Institute of Information & Communications Technology Planning & Evaluation(IITP) grant funded by the Korea government(MSIT) (RS-2023-00216011, No.2022-0-00077), and the National Research Foundation of Korea(NRF) funded by Ministry of Science and ICT (NRF-2022M3J6A1063021).

## References

* [1] K. M. Borgwardt, C. S. Ong, S. Schonauer, S. Vishwanathan, A. J. Smola, and H. Kriegel. Protein function prediction via graph kernels. _Bioinformatics_, 21(suppl_1):i47-i56, 2005.
* [2] C. Chen, O. Li, D. Tao, A. Barnett, C. Rudin, and J. K. Su. This looks like that: deep learning for interpretable image recognition. _Advances in neural information processing systems_, 32, 2019.
* [3] M. Cranmer, A. Sanchez Gonzalez, P. Battaglia, R. Xu, K. Cranmer, D. Spergel, and S. Ho. Discovering symbolic models from deep learning with inductive biases. In _Advances in Neural Information Processing Systems_, pages 17429-17442, 2020.
* [4] A. K. Debnath, R. L. Lopez de Compadre, G. Debnath, A. J. Shusterman, and C. Hansch. Structure-activity relationship of mutagenic aromatic and heteroaromatic nitro compounds. correlation with molecular orbital energies and hydrophobicity. _Journal of medicinal chemistry_, 34(2):786-797, 1991.
* [5] P. D. Dobson and A. J. Doig. Distinguishing enzyme structures from non-enzymes without alignments. _Journal of molecular biology_, 330(4):771-783, 2003.
* [6] F. Doshi-Velez and B. Kim. A roadmap for a rigorous science of interpretability. _arXiv preprint arXiv:1702.08608_, 2(1), 2017.
* [7] R. D. Hjelm, A. Fedorov, S. Lavoie-Marchildon, K. Grewal, P. Bachman, A. Trischler, and Y. Bengio. Learning deep representations by mutual information estimation and maximization. _arXiv preprint arXiv:1808.06670_, 2018.
* [8] J. J. Irwin and B. K. Shoichet. Zinc- a free database of commercially available compounds for virtual screening. _Journal of chemical information and modeling_, 45(1):177-182, 2005.
* [9] G. Jaume, P. Pati, B. Bozorgtabar, A. Foncubierta, A. M. Anniciello, F. Feroce, T. Rau, J.-P. Thiran, M. Gabrani, and O. Goksel. Quantifying explainers of graph neural networks in computational pathology. In _Proceedings of the IEEE/CVF conference on computer vision and pattern recognition_, pages 8106-8116, 2021.
* [10] T. N. Kipf and M. Welling. Semi-supervised classification with graph convolutional networks. _arXiv preprint arXiv:1609.02907_, 2016.
* [11] N. Lee, D. Hyun, G. S. Na, S. Kim, J. Lee, and C. Park. Conditional graph information bottleneck for molecular relational learning. _arXiv preprint arXiv:2305.01520_, 2023.
* [12] D. Luo, W. Cheng, D. Xu, W. Yu, B. Zong, H. Chen, and X. Zhang. Parameterized explainer for graph neural network. In _Advances in Neural Information Processing Systems_, pages 19620-19631, 2020.
* [13] S. Miao, M. Liu, and P. Li. Interpretable and generalizable graph learning via stochastic attention mechanism. In _International Conference on Machine Learning_, pages 15524-15543. PMLR, 2022.

* [14] P. E. Pope, S. Kolouri, M. Rostami, C. E. Martin, and H. Hoffmann. Explainability methods for graph convolutional neural networks. In _Proceedings of the IEEE/CVF conference on computer vision and pattern recognition_, pages 10772-10781, 2019.
* [15] C. Rudin. Stop explaining black box machine learning models for high stakes decisions and use interpretable models instead. _Nature machine intelligence_, 1(5):206-215, 2019.
* [16] M. Rupp, A. Tkatchenko, K.-R. Muller, and O. A. Von Lilienfeld. Fast and accurate modeling of molecular atomization energies with machine learning. _Physical review letters_, 108(5):058301, 2012.
* [17] D. Rymarczyk, L. Struski, J. Tabor, and B. Zielinski. Protopshare: Prototypical parts sharing for similarity discovery in interpretable image classification. In _Proceedings of the 27th ACM SIGKDD Conference on Knowledge Discovery & Data Mining_, pages 1420-1430, 2021.
* [18] D. Silver, J. Schrittwieser, K. Simonyan, I. Antonoglou, A. Huang, A. Guez, T. Hubert, L. Baker, M. Lai, A. Bolton, et al. Mastering the game of go without human knowledge. _nature_, 550 (7676):354-359, 2017.
* [19] Q. Sun, J. Li, H. Peng, J. Wu, X. Fu, C. Ji, and S. Y. Philip. Graph structure learning with variational information bottleneck. In _Proceedings of the AAAI Conference on Artificial Intelligence_, volume 36, pages 4165-4174, 2022.
* [20] Y. Tian, D. Krishnan, and P. Isola. Contrastive multiview coding. In _Computer Vision-ECCV 2020: 16th European Conference, Glasgow, UK, August 23-28, 2020, Proceedings, Part XI 16_, pages 776-794. Springer, 2020.
* [21] N. Tishby, F. C. Pereira, and W. Bialek. The information bottleneck method. _arXiv preprint physics/0004057_, 2000.
* [22] P. Velickovic, G. Cucurull, A. Casanova, A. Romero, P. Lio, and Y. Bengio. Graph attention networks. _arXiv preprint arXiv:1710.10903_, 2017.
* [23] M. Vu and M. T. Thai. Pgm-explainer: Probabilistic graphical model explanations for graph neural networks. In _Advances in Neural Information Processing Systems_, pages 12225-12235, 2020.
* [24] N. Wale, I. A. Watson, and G. Karypis. Comparison of descriptor spaces for chemical compound retrieval and classification. _Knowledge and Information Systems_, 14:347-375, 2008.
* [25] T. Wang. Gaining free or low-cost interpretability with interpretable partial substitute. In _International Conference on Machine Learning_, pages 6505-6514. PMLR, 2019.
* [26] J. Wencel-Delord and F. Glorius. C-h bond activation enables the rapid construction and late-stage diversification of functional molecules. _Nature chemistry_, 5(5):369-375, 2013.
* [27] T. Wu, H. Ren, P. Li, and J. Leskovec. Graph information bottleneck. _Advances in Neural Information Processing Systems_, 33:20437-20448, 2020.
* [28] K. Xu, W. Hu, J. Leskovec, and S. Jegelka. How powerful are graph neural networks? _arXiv preprint arXiv:1810.00826_, 2018.
* [29] Z. Ying, D. Bourgeois, J. You, M. Zitnik, and J. Leskovec. Gnnexplainer: Generating explanations for graph neural networks. In _Advances in Neural Information Processing Systems_, pages 9240-9251, 2019.
* [30] Y. You, T. Chen, Y. Sui, T. Chen, Z. Wang, and Y. Shen. Graph contrastive learning with augmentations. _Advances in neural information processing systems_, 33:5812-5823, 2020.
* [31] J. Yu, T. Xu, Y. Rong, Y. Bian, J. Huang, and R. He. Graph information bottleneck for subgraph recognition. In _International Conference on Learning Representations_, 2021.
* [32] J. Yu, J. Cao, and R. He. Improving subgraph recognition with variational graph information bottleneck. In _Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition_, pages 19396-19405, 2022.

* [33] H. Yuan, J. Tang, X. Hu, and S. Ji. Xgnn: Towards model-level explanations of graph neural networks. In _Proceedings of the 26th ACM SIGKDD International Conference on Knowledge Discovery & Data Mining_, pages 430-438, 2020.
* [34] H. Yuan, H. Yu, S. Gui, and S. Ji. Explainability in graph neural networks: A taxonomic survey. _IEEE Transactions on Pattern Analysis and Machine Intelligence_, 2022.
* [35] Z. Zhang, Q. Liu, H. Wang, C. Lu, and C. Lee. Protgnn: Towards self-explaining graph neural networks. In _Proceedings of the AAAI Conference on Artificial Intelligence_, volume 36, pages 9127-9135, 2022.