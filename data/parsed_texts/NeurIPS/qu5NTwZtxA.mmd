# Towards Editing Time Series

 Baoyu Jing\({}^{*}\) 2, Shuqi Gu\({}^{*}\) 1, Tianyu Chen\({}^{1}\), Zhiyu Yang\({}^{1}\),

**Dongsheng Li\({}^{3}\), Jingrui He\({}^{2}\), Kan Ren\({}^{\dagger}\) 1**

\({}^{1}\)ShanghaiTech University, \({}^{2}\)University of Illinois at Urbana-Champaign, \({}^{3}\)Microsoft Research

Baoyu Jing and Shuqi Gu share the co-first authorship.Correspondence to Kan Ren: renkan@shanghaitech.edu.cn

 Shuqi Gu\({}^{*}\) 1, Tianyu Chen\({}^{1}\), Zhiyu Yang\({}^{1}\),

**Dongsheng Li\({}^{3}\), Jingrui He\({}^{2}\), Kan Ren\({}^{\dagger}\) 1**

\({}^{1}\)ShanghaiTech University, \({}^{2}\)University of Illinois at Urbana-Champaign, \({}^{3}\)Microsoft Research

Footnote 1: footnotemark:

Footnote 2: footnotemark:

###### Abstract

Synthesizing time series data is pivotal in modern society, aiding effective decision-making and ensuring privacy preservation in various scenarios. Time series are associated with various attributes, including trends, seasonality, and external information such as location. Recent research has predominantly focused on random unconditional synthesis or conditional synthesis. Nonetheless, these paradigms generate time series from scratch and are incapable of manipulating existing time series samples. This paper introduces a novel task, called Time Series Editing (TSE), to synthesize time series by manipulating existing time series. The objective is to modify the given time series according to the specified attributes while preserving other properties unchanged. This task is not trivial due to the inadequacy of data coverage and the intricate relationships between time series and their attributes. To address these issues, we introduce a novel diffusion model, called TEdit. The proposed TEdit is trained using a novel bootstrap learning algorithm that effectively enhances the coverage of the original data. It is also equipped with an innovative multi-resolution modeling and generation paradigm to capture the complex relationships between time series and their attributes. Experimental results demonstrate the efficacy of TEdit for editing specified attributes upon the existing time series data. The project page is at https://seqml.github.io/tse.

## 1 Introduction

Time series data analysis plays a crucial role in various modern business sectors, including climate monitoring [22; 13; 14], healthcare [12; 3; 46], urban management [43; 16; 15], and online service [35]. Time series are derived from diverse sources with inherent characteristics, such as system configurations, alongside external influential factors like environmental status. These factors are considered _attributes_ of the time series. In many real-world scenarios, such as healthcare and urban monitoring, time series data tend to be sparse and privacy-sensitive, particularly concerning specific attributes that are rarely observed in real-world scenarios.

Synthesizing time series data has emerged as a prominent research area aimed at addressing these challenges. Existing methods for time series synthesis range from unconditional generation [47; 31] to conditional generation [39; 27; 4]. Unconditional generation produces outputs based solely on the underlying distribution of the data. Without relying on any input conditions, the generated results are highly uncontrollable. Conditional generation controls the outcomes of the generated data based on the input conditions. However, conditional generation tends to produce samples around the data mean [40], as demonstrated in our experiments, which could easily overlook detailed characteristics of the data, such as high-frequency patterns and local structures. Both unconditional and conditional generation paradigms synthesize time series from scratch, and they are incapable of manipulating existing samples. As a result, these paradigms are unable to answer _"what if"_ questions in time series synthesis: _given a time series, what would it become if some of its attributes are modified?_In this paper, we introduce a novel task, called **Time Series Editing (TSE)**, for sample-level time series manipulation. More specifically, our objective is to directly manipulate specific attributes of an input time series to target values while maintaining consistency in other characteristics. For instance, consider observing air quality under season conditions in different cities as shown in Fig. 1. On the left side, two example air quality time series for the spring and summer of London are illustrated. The spring one exhibits a lower amplitude with more noise, whereas the summer one features a higher amplitude with less noise. What would the resulting time series look like if we modify the season attribute of the spring one to summer while maintaining all other properties? As illustrated in Fig. 1, it could have a larger amplitude with much noise.

The task of TSE is complex due to several challenges. Firstly, the time series data distribution over the full composited attribute space is biased and may not be adequately covered, leaving gaps in our understanding, especially concerning unobservable or poorly defined attributes. For example, in climate data analysis, attributes like temperature and humidity are observable and well-defined. However, attributes like atmospheric pressure variations or localized microclimates may be challenging to observe or define accurately. Secondly, different attributes influence time series at varying resolutions. For example, trends have a global impact, while seasonality exerts a more localized influence. Modeling these multi-scale attributes and time series associations, while effectively controlling them, presents significant difficulties.

To address these challenges, we introduce a novel method called **Time Series Editor (TEdit)**, which is based on predominant generative models, specifically diffusion models [10, 38, 39, 27]. To address the data coverage issue, we propose a novel bootstrap learning algorithm, which leverages the generated data as pseudo-supervision for subsequent model learning. This algorithm helps improve the coverage of the whole attribute space and enhance the generation performance. To capture the intricate multi-scale associations between time series and attributes, we introduce a multi-resolution modeling and generation paradigm. The proposed multi-resolution paradigm can manipulate the given time series and attributes both effectively and efficiently. Our experiments, conducted on both synthetic and real-world datasets, demonstrate the effectiveness of our proposed solution. Specifically, our approach excels in generating precise time series under specified attributes, while keeping consistency in other attributes, showcasing the practical utility of our method.

In summary, our main contributions are threefold. (1) We introduce and formulate the novel task of Time Series Editing (TSE). To the best of our knowledge, this is the first work exploring editing time series according to the given attribute configuration upon the input data. (2) We propose a novel multi-resolution diffusion model, called TEdit, with a bootstrap learning algorithm, which can flexibly capture the patterns at diverse granularity and gradually improve the generation performance. (3) We conduct and release a benchmark for TSE, including synthetic data and several carefully curated real-world datasets with a comprehensive evaluation protocol, aiming to facilitate further research in the community.

Figure 1: Illustration of the time series generation paradigms. Conditional generation generates time series from scratch, which usually generates samples around the dataset mean. Time series editing allows for the manipulation of the attributes of an input time series sample, which aligns with the desired target attribute values while preserving other properties.

Background

### Time Series Generation

A time series sample \(\mathbf{x}\in\mathbb{R}^{L}\) is a series of \(L\) chronologically ordered sample points. Each time series sample adheres to some attributes \(\mathbf{a}\in\mathbb{N}_{+}^{K}\), such as trend and the cycle number, and the \(k\)-th item \(a_{k}\) corresponds to \(N_{k}\) categorical options where \(k\in\{1,...,K\}\). In real-world scenarios, each time series may have several attributes, e.g., the air quality time series is associated with \(K=2\) attributes: location and season. Note that, not all the attributes can be observed due to practical limitations.

Before describing the main task of the paper, we first briefly review the background of Time Series Generation. _Unconditional Time Series Generation (UTSG)_ samples the time series data \(\mathbf{x}\) upon the modeled data distribution \(p(\mathbf{x})\) such that \(\mathbf{x}\sim p(\mathbf{x})\), of which the generation process is uncontrollable. _Conditional Time Series Generation (CTSG)_ generates the time series sample \(\mathbf{x}\) based on the conditional distribution such that \(\mathbf{x}\sim p(\mathbf{x}|\mathbf{a})\), where \(\mathbf{a}\) is the input condition. CTSG tends to produce data samples near the dataset mean [40]. Both UTSG and CTSG paradigms generate time series from scratch and lack the ability to directly manipulate the existing samples.

### Conditional Diffusion Models

Diffusion models [10; 37; 38] learn to estimate and remove the random noise, which was added in the forward process onto the real-world data, through a sequence of sampling processes. Specifically, during training, random noise is gradually added to the original data sample \(\mathbf{x}_{0}=\mathbf{x}\)1 via a Gaussian Markov transition \(q(\mathbf{x}_{t}|\mathbf{x}_{t-1}):=\mathcal{N}(\sqrt{1-\beta_{t}}\mathbf{x}_ {t-1},\beta_{t}\mathbf{I})\), where \(t\in[1,T]\) indicates the diffusion step, and \(\{\beta_{t}\}_{t=0}^{T}\) are the predetermined variance schedule. The expression of latent variable \(\mathbf{x}_{t}\) can be simplified as \(\mathbf{x}_{t}=\sqrt{\alpha_{t}}\mathbf{x}_{0}+\sqrt{1-\alpha_{t}}\boldsymbol {\epsilon},\ \boldsymbol{\epsilon}\sim\mathcal{N}(0,\mathbf{I}),\ \alpha_{t}:=\Pi_{s=1}^{t}(1-\beta_{s})\). The learnable component of the diffusion models is a noise estimation network \(\boldsymbol{\epsilon}_{\theta}(\mathbf{x}_{t},t,\mathbf{a})\), where \(\mathbf{a}\) denotes the additional condition such as attributes. \(\boldsymbol{\epsilon}_{\theta}(\mathbf{x}_{t},t,\mathbf{a})\) is trained by estimating the noise added to \(\mathbf{x}_{t}\):

Footnote 1: \(\mathbf{x}_{0}\) and \(\mathbf{x}\) are interchangeable in this paper.

\[\min_{\theta}\mathcal{L}(\mathbf{x}_{0}):=\min_{\theta}\mathbb{E}_{\boldsymbol {\epsilon}\sim\mathcal{N}(0,\mathbf{I}),t\sim\mathcal{U}(1,T)}\left\| \boldsymbol{\epsilon}-\boldsymbol{\epsilon}_{\theta}\left(\mathbf{x}_{t},t, \mathbf{a}\right)\right\|_{2}^{2}\] (1)

where \(\mathbf{x}_{0}\sim q(\mathbf{x}_{0})\) is sampled from the real data distribution, \(\mathbf{x}_{t}\) is a noisy version of \(\mathbf{x}_{0}\).

After training, given an attribute \(\mathbf{a}\), we can generate a sample \(\hat{\mathbf{x}}_{0}\) from random noise \(\hat{\mathbf{x}}_{T}\sim\mathcal{N}(0,\mathbf{I})\) using \(\boldsymbol{\epsilon}_{\theta}(\mathbf{x}_{t},t,\mathbf{a})\) with a sampler, e.g., deterministic Denoising Diffusion Implicit Model (DDIM) [38]:

\[\hat{\mathbf{x}}_{t-1} =\sqrt{\alpha_{t-1}}\mathbf{f}_{\theta}(\hat{\mathbf{x}}_{t},t, \mathbf{a})+\sqrt{1-\alpha_{t-1}}\boldsymbol{\epsilon}_{\theta}(\hat{\mathbf{x }}_{t},t,\mathbf{a})\] (2) \[\mathbf{f}_{\theta}(\hat{\mathbf{x}}_{t},t,\mathbf{a}) =(\hat{\mathbf{x}}_{t}-\sqrt{1-\alpha_{t}}\boldsymbol{\epsilon}_{ \theta}\left(\hat{\mathbf{x}}_{t},t,\mathbf{a}\right))/\sqrt{\alpha_{t}}\] (3)

where \(\mathbf{f}_{\theta}(\hat{\mathbf{x}}_{t},t,\mathbf{a})\) can be regarded as a prediction of \(\ \mathbf{x}_{0}\) at the diffusion step \(t\).

Adapting diffusion methods from the computer vision domain to the time series domain is not trivial. Time series is different from images, and it poses unique challenges for modeling and generating time series data, such as the complex multi-scale entanglement between time series and attributes.

## 3 Time Series Editing

Given a time series and its associated attributes \((\mathbf{x},\mathbf{a})\), a natural question arises: _"what would it become if some of its attributes are modified?"_ In our work, we take a novel perspective of directly editing the given time series with the specified attribute modifications.

In this section, we first formally formulate the problem of _Time Series Editing (TSE)_ in Sec. 3.1. Next, we present our method _Time Series Editor (TEdit)_ with the overall procedure of the diffusion model-based TSE in Sec. 3.2, the model architecture in Sec. 3.3 and the learning algorithm in Sec. 3.4.

### Problem Formulation

Recall that, each time series sample \(\mathbf{x}\in\mathbb{R}^{L}\) is associated with a set of attributes \(\mathbf{a}\in\mathbb{N}_{+}^{K}\). Each attribute \(a_{k}\) has \(N_{k}\) options, \(k\in\{1,...,K\}\). For example, the trend type may contain \(N_{k}=4\) valueslike linear, quadratic, exponential, and logistic. Let \((\mathbf{x}^{\text{src}},\mathbf{a}^{\text{src}})\) be a pair of _source time series_ and _source attributes_ to be edited, and \(\mathbf{a}^{\text{gt}}\) be the desired _target attributes_. Comparing \(\mathbf{a}^{\text{tgt}}\) and \(\mathbf{a}^{\text{src}}\), there are \(K_{\text{edit}}\) edited attributes, e.g., trend types, and \(K_{\text{prsv}}\) preserved attributes, e.g., cycle numbers, where \(K_{\text{edit}}+K_{\text{prsv}}=K\). Now, we can formally define the task as below.

**Definition 1** (Time Series Editing (TSE)): _The time series editing task is to build a function \(\Phi_{\theta}\) to generate a target time series \(\hat{\mathbf{x}}^{\text{tgt}}=\Phi_{\theta}(\mathbf{x}^{\text{src}},\mathbf{a }^{\text{src}},\mathbf{a}^{\text{gt}})\) by modifying the set of \(K_{\text{edit}}\) edited attributes \(\mathcal{A}_{\text{edit}}\) and maintaining the set of \(K_{\text{prsv}}\) preserved attributes \(\mathcal{A}_{\text{prsv}}\) as well as other information of \(\mathbf{x}^{\text{src}}\)._

### Editing with Source Modeling and Target Generation

Given a pair of source time series and attributes \((\mathbf{x}^{\text{src}},\mathbf{a}^{\text{src}})\), generating the target time series \(\hat{\mathbf{x}}^{\text{tgt}}\) corresponding to the target attributes \(\mathbf{a}^{\text{tgt}}\) entails two requirements. On one hand, the edited attributes \(\mathcal{A}_{edit}\) should be satisfied after the generation. On the other hand, the preserved attributes \(\mathcal{A}_{prsv}\) as well as other characteristics, e.g., noise, need to be maintained. Conditional generation [27], such as directly adopting the conditional diffusion model described in Sec. 2.2, would fail the editing task because it does not take into consideration the detail characteristics of the source time series.

In this paper, we propose a diffusion based two-stage procedure for TSE: \(\Phi_{\theta}(\mathbf{x}^{\text{src}},\mathbf{a}^{\text{src}},\mathbf{a}^{ \text{tgt}})\), which is illustrated in the upper part of Fig. 2. In the first stage, we encode both the attribute semantics [6] and the detail characteristics [10] of the source time series \(\mathbf{x}^{\text{src}}_{0}\) into the latent variable \(\mathbf{x}^{\text{src}}_{T}\) via the deterministic forward DDIM process [18]:

\[\mathbf{x}^{\text{src}}_{t+1}=\sqrt{\alpha_{t+1}}\mathbf{f}_{\theta}(\mathbf{ x}^{\text{src}}_{t},t,\mathbf{a}^{\text{src}})+\sqrt{1-\alpha_{t+1}}\bm{\epsilon}_{ \theta}(\mathbf{x}^{\text{src}}_{t},t,\mathbf{a}^{\text{src}}).\] (4)

In the second stage, originating from the latent variable \(\hat{\mathbf{x}}^{\text{tgt}}_{T}=\mathbf{x}^{\text{src}}_{T}\), we gradually generate the final target time series \(\hat{\mathbf{x}}^{\text{tgt}}_{0}\) with the consideration of the target attribute \(\mathbf{a}^{\text{tgt}}\) via the deterministic reverse DDIM process [38]:

\[\hat{\mathbf{x}}^{\text{tgt}}_{t-1}=\sqrt{\alpha_{t-1}}\mathbf{f}_{\theta}( \hat{\mathbf{x}}^{\text{tgt}}_{t},t,\mathbf{a}^{\text{tgt}})+\sqrt{1-\alpha_ {t-1}}\bm{\epsilon}_{\theta}(\hat{\mathbf{x}}^{\text{tgt}}_{t},t,\mathbf{a}^{ \text{tgt}}),\] (5)

where \(\mathbf{f}_{\theta}\) is given in Eq. (3). Till now, we have detailed the procedure of the proposed TEdit. In the following subsections, we introduce the model architecture and the training algorithm.

### Multi-Resolution Noise Estimator

The key component of our TEdit is the noise estimator \(\bm{\epsilon}_{\theta}(\mathbf{x},t,\mathbf{a})\) in Eqs. (4)(5). Though many diffusion model realizations have been proposed in other fields [18; 10; 37; 38; 24] and the time series domain [39; 27], we found them inefficacious in modeling and generating time series data, especially when considering attributes. Few of them consider that different attributes can influence the time series on varying scales. We argue that it is important to take into account these differences. For instance, the trend types have a global impact on time series, while the seasonality affects the time series in local areas.

In this paper, we propose a multi-resolution noise estimator. It first slices the input time series \(\mathbf{x}_{t}\) into several patch sequences of different resolutions \(r\in\{1,...,R\}\), where \(R\) is the total number of resolutions. Then it processes the patch sequences along with other information, e.g., attributes \(\mathbf{a}\) and diffusion step \(t\), to estimate the noise \(\hat{\bm{\epsilon}}_{t}^{r}\) for resolution \(r\). Finally, the estimated noise for different resolutions are mixed together to obtain the final estimated noise \(\hat{\bm{\epsilon}}_{t}\). An illustration is presented in Fig. 3. We elaborate on the details in the following content2.

Footnote 2: We discuss the noise estimator in the diffusion step \(t\) here, thus, we omit the notation of the diffusion step \(t\) without causing confusion.

**Patchifying.** Following [29], we patchify the input time series \(\mathbf{x}\in\mathbb{R}^{L}\), into a sequence of patch tokens \(\mathbf{P}=\{\mathbf{p}_{1},...,\mathbf{p}_{N_{p}}\}\), where \(\mathbf{p}_{i}\in\mathbb{R}^{L_{p}}\), \(L_{p}\) is the window size and \(N_{p}=\lfloor\frac{L-L_{p}}{L_{p}}\rfloor\) is the patch number. After that, we encode them into embeddings \(\bar{\mathbf{P}}=\{\bar{\mathbf{p}}_{1},...,\bar{\mathbf{p}}_{N_{p}}\}\), where \(\bar{\mathbf{p}}_{i}\in\mathbb{R}^{D}\).

**Multi-Resolution Modeling and Generation.** To model multi-resolution patterns and better control the conditional generation at multiple scales, we propose a multi-patch design with various patch lengths. Specifically, as shown in the left part of Fig. 3, following the above patchifying operation, we encode the input time series \(\mathbf{x}\) into patch embedding sequences \(\{\bar{\mathbf{P}}^{r}\}_{r=1}^{R}\) of \(R\) resolutions, where \(\bar{\mathbf{P}}^{r}=\{\bar{\mathbf{p}}_{1}^{r},...,\bar{\mathbf{p}}_{N_{p}^{ r}}^{r}\}\), \(\bar{\mathbf{p}}_{i}^{r}\in\mathbb{R}^{D}\), \(N_{p}^{r}=\lfloor\frac{L-L_{p}^{r}}{L_{p}^{r}}\rfloor\) is the patch number, \(L_{p}^{r}\) is the window size. We set the patch length as \(L_{p}^{r}=b^{r-1}\) to produce exponential receptions, where \(b\in\mathbb{N}_{+}\) is the base. Thereafter, the processing module operates self-attention as the Transformer [42] to capture the input patterns for each resolution \(r\), and it incorporates the attribute \(\mathbf{a}\) and diffusion step \(t\) information to produce the embeddings \(\{\bar{\mathbf{P}}^{r}\}_{r=1}^{R}\). The details of the processing module are presented in Appendix D.

The processed output \(\{\tilde{\mathbf{P}}^{r}\}_{r=1}^{R}\) is still in the form of multi-resolution sequences. The model subsequently decodes the diffusion noise at different resolutions back into the original space and integrates the outcomes at different resolutions to produce the final noise estimation, as shown on the right side of Fig. 3. Specifically, for each \(\tilde{\mathbf{P}}^{r}\), the decoder transforms it to \(\hat{\bm{\epsilon}}^{r}\in\mathbb{R}^{L}\) in the original time series space. The final estimated noise is obtained via a mixing upon the concatenation of estimated noise of different resolutions as \(\hat{\bm{\epsilon}}=\text{MLP}([\bm{\epsilon}^{1},...,\bm{\epsilon}^{R}])\), where \(\text{MLP}(\cdot)\) denotes Multi-Layer Perceptron.

**Parallel Processing.** Though more effective, the proposed multi-resolution modeling and generation brings efficiency issues since it derives multiple token sequences with various sequence lengths. Iteratively processing each sequence is of low efficiency. Herein we design a novel parallelization

Figure 3: Architecture of the proposed multi-resolution noise estimator \(\bm{\epsilon}_{\theta}\). We illustrate with \(R=3\) patching schema, patch length \(L_{p}^{r}=2^{r-1},r\in\{1,...,R\}\) and the input length \(L=8\). \(N_{p}^{r}=\lfloor\frac{L-L_{p}^{r}}{L_{p}^{r}}\rfloor\) is the patch number. \(D\) is the embedding size. Please refer to Sec. 3.3 for details.

with an attention masking mechanism in the processing module in Fig. 3 to harness the parallelism of the Graphics Processing Unit (GPU). Specifically, we first concatenate the input patch embedding sequences of different resolutions into a single vector \(\bar{\mathbf{P}}=[\bar{\mathbf{P}}^{1},...,\bar{\mathbf{P}}^{R}]\in\mathbb{R}^{D \times(N_{p}^{1}+...+N_{p}^{R})}\). When calculating pair-wise self-attention scores as in the Transformer [42], we use a mask matrix to mask out the inter-sequence attention operations across different sequences while preserving intra-sequence attention. Please refer to Appendix D for more details.

### Bootstrap Learning Algorithm

Although any pretrained conditional diffusion model \(\bm{\epsilon}_{\theta}\) can be directly used to perform editing as shown in Sec. 3.2, the pretrained model is an essentially conditional generator, which has a great ability in generating time series directly from attributes but it might be less effective in modifying the attributes of an existing time series. The simplest way to improve the model's ability is to finetune \(\bm{\epsilon}_{\theta}\) via the ground-truth source \((\mathbf{x}_{0}^{\text{src}},\mathbf{a}^{\text{src}})\) and target \((\mathbf{x}_{0}^{\text{tgt}},\mathbf{a}^{\text{tgt}})\) pairs. However, the imaginary target \(\mathbf{x}_{0}^{\text{tgt}}\), which satisfies both \(\mathbf{a}^{\text{tgt}}\) and the details of \(\mathbf{x}_{0}^{\text{src}}\) might be very rare or even does not exist in the real world. Thus, a key challenge for finetuning is how to effectively learn the information of \(\mathbf{x}_{0}^{\text{tgt}}\).

Fortunately, the pretrained model is capable of generating some edited samples of a certain quality via \(\hat{\mathbf{x}}_{0}^{\text{tgt}}=\Phi_{\theta}(\mathbf{x}_{0}^{\text{src}}, \mathbf{a}^{\text{src}},\mathbf{a}^{\text{tgt}})\). An example is shown in Fig. 2. In this paper, we propose a bootstrap learning algorithm, which first _pretrains_\(\bm{\epsilon}_{\theta}\) based on the noise estimation loss \(\mathcal{L}\) in Eq. (1) and then _finetunes_\(\bm{\epsilon}_{\theta}\) based on \(\hat{\mathbf{x}}_{0}^{\text{tgt}}\) with top confidence scores. Here, we briefly present the key steps of the bootstrap learning, and the full algorithm is given in Appendix E. Given a batch \((\mathbf{X}_{0}^{\text{src}},\mathbf{A}^{\text{src}})\), where \(\mathbf{X}_{0}^{\text{src}}\in\mathbb{R}^{B\times L}\), \(\mathbf{A}^{\text{src}}\in\mathbb{N}_{+}^{B\times K}\), \(B\) is the batch size, the finetuning works as follows:

* **Compose target attributes \(\mathbf{A}^{\text{tgt}}\).** For each \((\mathbf{x}_{0}^{\text{src}},\mathbf{a}^{\text{src}})\in(\mathbf{X}_{0}^{ \text{src}},\mathbf{A}^{\text{src}})\), we compose the imaginary target attributes \(\mathbf{a}^{\text{tgt}}\) based on \(\mathbf{a}^{\text{src}}\) by randomly sampling values for edited attributes \(\mathcal{A}_{\text{edit}}\) and keeping the values of the preserved attributes \(\mathcal{A}_{\text{prsv}}\). Then we have the tuple \((\mathbf{X}_{0}^{\text{src}},\mathbf{A}^{\text{src}},\mathbf{A}^{\text{tgt}})\).
* **Generate the edited time series \(\hat{\mathbf{X}}_{0}^{\text{tgt}}\) via \(\Phi_{\theta}\).** An illustration is shown in the upper part of Fig. 2.
* **Self-score \(\hat{\mathbf{X}}_{0}^{\text{tgt}}\) via \(\Phi_{\theta}\) and keep top \(\psi\) samples.** An illustration of the self-scoring process is shown in the lower part of Fig. 2. We first edit \(\hat{\mathbf{X}}_{0}^{\text{tgt}}\) back to source \(\hat{\mathbf{X}}_{0}^{\text{src}}=\Phi_{\theta}(\hat{\mathbf{X}}_{0}^{\text{ tgt}},\mathbf{A}^{\text{tgt}},\mathbf{A}^{\text{src}})\). Then we use the Mean Squared Error (MSE) between \(\mathbf{X}_{0}^{\text{src}}\) and \(\hat{\mathbf{X}}_{0}^{\text{src}}\) to score \(\hat{\mathbf{X}}_{0}^{\text{tgt}}\). The top \(\psi\) samples of \(\hat{\mathbf{X}}_{0}^{\text{tgt}}\) with the lowest MSE are selected as the bootstrap samples, denoted by \(\hat{\mathbf{X}}_{0,\text{bs}}^{\text{tgt}}\).
* **Update \(\bm{\epsilon}_{\theta}\) by minimizing \(\mathcal{L}_{\text{BS}}\).** We finetune \(\bm{\epsilon}_{\theta}\) by minimizing the noise estimation loss \(\mathcal{L}\) in Eq. (1) for \(\hat{\mathbf{X}}_{0,\text{bs}}^{\text{tgt}}\). Formally, we minimize \(\mathcal{L}_{\text{BS}}=\mathcal{L}(\hat{\mathbf{X}}_{0,\text{bs}}^{\text{tgt}})\).

## 4 Experiments

In this section, we present experiments aimed at addressing the following research questions: **RQ1**: How does the proposed TEdit perform in terms of editing and preserving attributes? **RQ2**: What's the impact of bootstrap training? **RQ3**: What's the impact of multi-resolution modeling?

### Experimental Setup

**Datasets.** We collect three datasets for TSE, including one synthetic dataset and two real-world datasets. For the **Synthetic** data, each time series sample has a length of 128, and is associated with 3 attributes, where there are 4 trend types, 2 trend directions, and 4 season cycles. In addition to attributes, noise and bias are added to simulate real-world conditions. The **Air Quality**[8] dataset contains PM2.5 time series of Beijing and London from 01/01/2017 to 31/03/2018. Each time series has a length of 168 and is affected by two attributes: 2 cities and 4 seasons. The **Motor Imagery**[1] dataset contains the ElectroEncephaloGram (EEG) data of subjects, who were required to imagine the movements of either the tongue or the left small finger. Each sample takes a length of 150 with 2 attributes: 2 movements and 64 channel ids.

Each of the three datasets is associated with a pertaining dataset and several finetuning datasets. The pretraining datasets only contain the source time series \(\mathbf{x}^{\text{src}}\) and its attributes \(\mathbf{a}^{\text{src}}\). During pertaining, the noise estimator \(\bm{\epsilon}_{\theta}\) is trained to denoise \(\mathbf{x}_{t}^{\text{src}}\) with \(\mathbf{a}^{\text{src}}\) via Eq. (1). Each finetuningdataset corresponds to a specific split of \(\mathcal{A}_{\text{edit}}\) and \(\mathcal{A}_{\text{pcsv}}\). For example, the Synthetic dataset has 3 attributes, and thus it has \(6=\sum_{i=1}^{2}\binom{3}{i}\) different splits, namely, finetuning datasets. Similarly, both Air Quality and Motor Imagery datasets have 2 finetuning datasets. Finetuning datasets contain the source time series \(\mathbf{x}^{\text{src}}\), source attributes \(\mathbf{a}^{\text{src}}\), and target attributes \(\mathbf{a}^{\text{tgt}}\). The process of generating the target attributes mirrors the target attribute composition step in bootstrap learning. Note that for Synthetic, the target time series \(\mathbf{x}^{\text{tgt}}\) is also available. During finetuning, we use the proposed bootstrap learning algorithm to further improve the model. More details can be found in Appendix F.

**Evaluation Metrics.** A good editor should be able to generate \(\hat{\mathbf{x}}^{\text{tgt}}\) that aligns with each \(a_{k}^{\text{tgt}}\in\mathbf{a}^{\text{tgt}}\). The cornerstone of our evaluation is the **Contrastive Time series Attribute Pretraining (CTAP)** model, which extracts time series and attribute embeddings by learning their alignment. Our CTAP is similar to CLIP [33]. For details of CTAP, please refer to Appendix G. Based on the CTAP model, we introduce two metrics: **CTAP score** and **Log Ratio of Target-to-Source (RaTS)**. (1) The CTAP score is similar to the CLIP-I score [23; 33], which measures the alignment between the generated time series and the real-world time series which are associated with the given attribute value \(a_{k}^{\text{tgt}}\). Specifically, we first use the CTAP model to extract embeddings \(\hat{\mathbf{h}}_{\mathbf{x}}\), which is the embedding of \(\hat{\mathbf{x}}^{\text{tgt}}\), and \(\bar{\mathbf{h}}_{\mathbf{x}}|a_{k}^{\text{tgt}}\), which is the average embedding of the time series associated with \(a_{k}^{\text{tgt}}\) in the training data. Then we calculate the cosine similarity of \(\hat{\mathbf{h}}_{\mathbf{x}}\) and \(\bar{\mathbf{h}}_{\mathbf{x}}|a_{k}^{\text{tgt}}\), where the higher similarity indicates better alignment. (2) The RaTS score measures whether \(\hat{\mathbf{x}}^{\text{tgt}}\) is closer to \(a_{k}^{\text{tgt}}\) than \(\mathbf{x}^{\text{src}}\). Formally, the RaTS score for a tuple (\(\hat{\mathbf{x}}^{\text{tgt}}\), \(\mathbf{x}^{\text{src}}\), \(a_{k}^{\text{tgt}}\)) is defined as:

\[\text{RaTS}(\hat{\mathbf{x}}^{\text{tgt}},\mathbf{x}^{\text{src}},a_{k}^{ \text{tgt}})=\log(\frac{p(a_{k}^{\text{tgt}}|\hat{\mathbf{x}}^{\text{tgt}})} {p(a_{k}^{\text{tgt}}|\mathbf{x}^{\text{src}})}),\] (6)

where \(p(a_{k}|\mathbf{x})\) is calculated by applying a softmax over the similarity scores of all \((\mathbf{h}_{\mathbf{x}},\mathbf{h}_{a_{k}=i})\) pairs, where \(\mathbf{h}_{\mathbf{x}}\) is the CTAP embedding of \(\mathbf{x}\), and \(\mathbf{h}_{a_{k}=i}\), \(i\in\{1,...,N_{k}\}\), is the CTAP embedding of the \(i\)-th possible value for the \(k\)-th attribute \(a_{k}\).

We mainly evaluate \(\hat{\mathbf{x}}^{\text{tgt}}\) from two perspectives: _editability_ and _preservability_ for edited attributes \(\mathcal{A}_{\text{edit}}\) and preserved attributes \(\mathcal{A}_{\text{pcsv}}\), respectively. For the edited attributes \(\mathcal{A}_{\text{edit}}\), the higher RaTS and CTAP the better. For the preserved attributes \(\mathcal{A}_{\text{pcsv}}\), the higher CTAP the better. Since RaTS can take negative values, we use |RaTS| for \(\mathcal{A}_{\text{pcsv}}\), which measures the semantic divergence of \(\hat{\mathbf{x}}^{\text{tgt}}\) from \(\mathbf{x}^{\text{src}}\) w.r.t \(a_{k}\). The lower |RaTS| means the better preservability. For more details, please refer to Appendix H. In addition to the semantic level evaluations, for the synthetic data, since we have ground truth target time series, we also use Mean Square Error (MSE), Mean Absolute Error (MAE) to perform the point level evaluation.

**Compared Methods.** Since there is no existing method for TSE, we modify the popular time series diffusion model CSDI [39] and the recent conditional diffusion model Time Weaver [27] for TSE. As CSDI is unable to process attributes, we add an extra attribute encoder to incorporate attribute information. For Time Weaver, we slightly modify its attribute encoder for our settings. After pretraining the modified CSDI and Time Weaver, we use them to edit time series via the editing procedure described in Sec. 3.2. Our proposed TEdit-CSDI and TEdit-TW are implemented by incorporating core processing modules of CSDI and Time Weaver into our proposed multi-resolution noise estimator Sec. 3.3, and trained via Sec. 3.4. Architecture details are presented in Appendix D.

**Implementation Details.** For all experiments, we set the number of diffusion steps as \(T=50\), embedding size for attributes and time series as 64, and use Adam optimizer [20] to train the model. For pretraining, we set (batch size, learning rate) as (256, 1e-3); for finetuning, we set them as (64,1e-7) for Synethtic and (32,1e-7) for Air Quality and Motor Imagery. We conduct a grid search for the hyperparameters of the multi-resolution. Considering the balance between performance and efficiency, we chose a compromise ratio for bootstrap. Specifically, \((R,L_{p},\psi)=(3,2,0.5)\) for Synthetic, \((3,2,0.5)\) for Air Quality, \((3,3,0.5)\) for Motor Imagery. All our experiments were conducted on a single Nvidia-A100 GPU.

### Main Results

In this section, we quantitatively evaluate the performance of comparison methods for editing and preserving attributes (**RQ1**) for all the datasets. For the edited attributes \(\mathcal{A}_{\text{edit}}\), we report the RaTS and CTAP scores to depict the models' ability to edit attributes. For the preserved attributes \(\mathcal{A}_{\text{pcsv}}\)we report the \(|\)RaTSl and CTAP scores to depict the models' ability to preserve attributes. For the Synthetic dataset, since we have the ground truth, we also include MSE and MAE to evaluate the overall disparity between the ground truth \(\mathbf{x}^{\text{tgt}}\) and the generated \(\hat{\mathbf{x}}^{\text{tgt}}\).

In Tab. 1, we present the averaged results over all the finetuning sets for each dataset. The detailed results for each finetuning sets are presented in Appendix I.1. Firstly, for the overall performance (MSE and MAE), the proposed TEdit could significantly outperform baselines. Secondly, for the edited attributes \(\mathcal{A}_{\text{edit}}\), TEdit-CSDI and TEdit-TW could respectively outperform CSDI and Time Weaver on RaTS and TAP, showing that \(\hat{\mathbf{x}}^{\text{tgt}}\) generated by TEdit could better fulfill the desired target \(\mathcal{A}_{\text{edit}}\). Thirdly, for the preserved attributes \(\mathcal{A}_{\text{pvsv}}\), TEdit could basically maintain \(|\)RaTSl and TAP scores, which indicates TEdit is capable of preserving \(\mathcal{A}_{\text{pvsv}}\). In summary, these observations show that TEdit, including the multi-resolution and bootstrap learning, could improve the ability of conditional diffusion models to edit \(\mathcal{A}_{\text{edit}}\) and preserve \(\mathcal{A}_{\text{pvsv}}\).

### Ablation Study

In this subsection, we conduct ablation studies on the Synthetic and Motor datasets based on the TEdit-TW to investigate the impact of the proposed multi-resolution modeling (**RQ2**) and the bootstrap training algorithm (**RQ3**). The averaged results over all the finetuning sets are presented in Tab. 2.

Firstly, we compare TEdit-TW trained with BS (BootStrap) with TEdit-TW trained with GT (Ground Truth) on the Synthetic dataset3. For GT, we finetune TEdit-TW by minimizing MSE between the generated \(\hat{\mathbf{x}}^{\text{tgt}}\) and the ground truth \(\mathbf{x}^{\text{tgt}}\). It can be observed that GT performs much better than BS on the overall metrics (MSE and MAE), and it is only slightly better than BS on the attribute level metrics for both edited and preserved attributes, demonstrating that BS has a strong ability to capture the attribute semantic information. Secondly, we remove BS from TEdit-TW and compare its performance with the full TEdit-TW model. For the Synthetic dataset, BS could improve the overall scores, and maintain the performance on other attribute level metrics. For the Air dataset, BS primarily improves the scores of the edited attributes, with a trade-off in the scores of the preserved attributes. We hypothesize that there might exist some intrinsic connections between the two attributes: city and season. For the Motor dataset, BS can enhance the performance on the edited attribute while maintaining the performance on the preserved attributes. Thirdly, we investigate the contribution of MR (Multi-Resolution). For the Synthetic and Air datasets, MR could improve the scores on all metrics. For the Motor dataset, MR helps improve the scores for the edited attributes and mostly sustains the performance on the preserved attributes. These improvements highlight the effectiveness of the proposed MR.

\begin{table}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c|c} \hline \hline  & \multicolumn{4}{c|}{Synthetic} & \multicolumn{4}{c||}{Air} & \multicolumn{4}{c}{Motor} \\ \hline  & \multicolumn{2}{c|}{Overall} & \multicolumn{2}{c|}{Edited} & \multicolumn{2}{c|}{Preserved} & \multicolumn{2}{c|}{Edited} & \multicolumn{2}{c|}{Preserved} & \multicolumn{2}{c|}{Edited} & \multicolumn{2}{c|}{Preserved} & \multicolumn{2}{c|}{Edited} & \multicolumn{2}{c|}{Preserved} \\  & \(\downarrow\)MSE & \(\downarrow\)MAE & \(\uparrow\)RaTS & \(\uparrow\)CTAP & \(\downarrow\)RaTS & \(\uparrow\)CTAP & \(\uparrow\)RaTS & \(\uparrow\)CTAP & \(\downarrow\)RaTS & \(\uparrow\)CTAP & \(\downarrow\)RaTS & \(\uparrow\)CTAP \\ \hline CSDI & 0.1789 & 0.3221 & 0.7540 & 0.5405 & 0.1439 & 0.7898 & 0.7452 & 0.1581 & 0.1705 & 0.6311 & 0.0939 & 0.4203 & 0.1597 & 0.6617 \\ Time Weaver & 0.1454 & 0.2898 & 0.9030 & 0.6943 & 0.1169 & 0.8292 & 0.8956 & 0.3266 & 0.1866 & 0.6299 & 0.0979 & 0.4168 & **0.1520** & **0.6691** \\ \hline TEdit-CSDI & **0.1235** & **0.2606** & 0.9257 & 0.7109 & 0.1021 & 0.8553 & 0.8022 & 0.2179 & **0.1614** & **0.6529** & 0.1016 & 0.4186 & 0.1580 & 0.6654 \\ TEdit-TW & 0.1315 & 0.2722 & **1.0121** & **0.7957** & **0.0995** & **0.8622** & **0.9661** & **0.9390** & 0.1916 & 0.6274 & **0.1212** & **0.4348** & 0.1571 & 0.6621 \\ \hline \hline \end{tabular}
\end{table}
Table 1: Averaged performance over all finetuning sets for Synthetic (left), Air (middle), and Motor (right). “Edited” and “Preserved” are the average results of all edited and preserved attributes.

\begin{table}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c} \hline \hline  & \multicolumn{4}{c|}{Synthetic} & \multicolumn{4}{c||}{Air} & \multicolumn{4}{c}{Motor} \\ \hline  & \multicolumn{2}{c|}{Overall} & \multicolumn{2}{c|}{Edited} & \multicolumn{2}{c|}{Preserved} & \multicolumn{2}{c|}{Edited} & \multicolumn{2}{c|}{Preserved} & \multicolumn{2}{c|}{Edited} & \multicolumn{2}{c|}{Preserved} & \multicolumn{2}{c|}{Edited} & \multicolumn{2}{c|}{Preserved} \\  & \(\downarrow\)MSE & \(\downarrow\)MAE & \(\uparrow\)RaTS & \(\uparrow\)CTAP & \(\downarrow\)RaTS & \(\uparrow\)CTAP & \(\uparrow\)RaTS & \(\uparrow\)CTAP & \(\downarrow\)RaTS & \(\uparrow\)CTAP & \(\downarrow\)RaTS & \(\uparrow\)CTAP \\ \hline TEdit-TW w GT & **0.1233** & **0.2622** & **1.0165** & **0.7991** & 0.0984 & **0.8650** & - & - & - & - & - & - & - \\ TEdit-TW & 0.1315 & 0.2722 & 1.0121 & 0.7957 & 0.0995 & 0.8622 & **0.9661** & **0.9390** & 0.1916 & 0.6274 & **0.1212** & **0.4348** & 0.1571 & 0.6621 \\ \hline w/o BS & 0.1376 & 0.2793 & 1.0127 & 0.7952 & **0.0962** & 0.8632 & 0.9524 & 0.3792 & **0.1839** & **0.6418** & 0.1113 & 0.4289 & 0.1571 & 0.6658 \\ w/o BS \& 0.1454 & 0.2898 & 0.9030 & 0.6943 & 0.1169 & 0.8292 & 0.8956 & 0.3266 & 0.1866 & 0.6299 & 0.0987 & 0.4168 & **0.1520** & **0.6691** \\ \hline \hline \end{tabular}
\end{table}
Table 2: Ablation studies on the Synthetic, Air and Motor datasets. GT, BS and MR refer to Ground Truth source and target pairs, BootStrap and Multi-Resolution. Results are averaged over all finetuning sets. “Edited” and “Preserved” are the average results of all edited and preserved attributes.

### Extended Investigation

We further conduct an in-depth analysis of the effectiveness and efficiency of our TEdit, aiming to reveal how it works through quantitative comparison and visualization.

**Editing vs. Conditional Generation.** Although conditional generation \(\hat{\mathbf{x}}^{\text{tgt}}=\Phi_{\theta}(\emptyset,\emptyset,\mathbf{a}^{ \text{tgt}})\) can produce time series that satisfy the specified target attribute values, it often struggles to retain sufficient details, particularly for difficult or unobservable attributes, since it generates samples from scratch. In contrast, editing \(\hat{\mathbf{x}}^{\text{tgt}}=\Phi_{\theta}(\mathbf{x}^{\text{src}},\mathbf{a} ^{\text{src}},\mathbf{a}^{\text{tgt}})\) is designed to modify the attributes of existing time series, and thus is able to preserve much detail information. We first quantitatively compare the two modes on the Synthetic data. The averaged MSE and MAE over all the finetuning datasets are presented in Tab. 3, which shows that editing could significantly outperform conditional generation with much better (lower) MSE and MAE scores.

We further showcase how editing and conditional generation work at the sample level. Fig. 4, plots the generated results of these two modes under. We can observe that the edited time series could better align with the target attributes, Fig. 4(a)(b), and preserve the characteristics of the source time series, e.g., bias in Fig. 4 (a). In comparison, conditional generation tends to produce smooth samples around the dataset mean. Additionally, we can also see in Fig. 4 that the MSE scores of editing are much lower than conditional generation. More visualization results can be found in Appendix I.4

**Efficiency of Multi-Resolution Generation.** Considering that multi-resolution modeling and generation brings additional efforts for processing different resolutions, as discussed in Sec. 3.3. We compare the running time of serial processing and parallel processing implementations of the multi-resolution paradigm with total resolution number \(R=3\) and patch length \(L_{p}^{r}=3^{r},r\in\{0,...,R-1\}\). The experiment is conducted on the Synthetic dataset with a batch size of 32. The serial processing iterative processes a single resolution at a time, whereas the parallel processing concatenates multiple resolution sequences along the length dimension and processes them simultaneously. We record the time it takes for the full noise estimator and the processing module to complete the forward diffusion process. As shown in Tab. 4, our designed parallel mechanism can significantly improve the inference efficiency.

**Bootstrap Improves the distributional coverage of the attribution space.** Fig. 5 visualizes the dimension reduced distribution of (a) the raw data, (b) the generated data and (c) the mixed data, on the Synthetic dataset using t-SNE [41]. We can observe that the newly generated data fulfill the uncovered region of the original raw data therefore enhance the data coverage over the whole space, which explains how the bootstrap learning helps generative model training. More visualization analysis can be found in Appendix I.5.

### Sensitivity Analysis

In this subsection, we conduct sensitivity analysis to study the impacts of hyper-parameters of the multi-resolution mechanism and bootstrap learning.

\begin{table}
\begin{tabular}{l|c|c} \hline \hline Running time (ms) & Serial processing & Parallel processing \\ \hline Noise estimator & 11.1 & 6.0 \\ Processing module & 8.8 & 3.7 \\ \hline \hline \end{tabular}
\end{table}
Table 4: Running time (ms) of the multi-resolution modeling and generation module, averaged over 1000 samples.

Figure 4: Case study for editing and conditional generation, under two settings: (a) editing the trend type from logistic to linear; (b) editing the trend type from linear to quadratic and the season cycles from 1 to 4.

\begin{table}
\begin{tabular}{l|c|c c} \hline \hline  & & \multicolumn{2}{c}{Synthetic} \\ \hline Method & Mode & MSE\(\downarrow\) & MAE\(\downarrow\) \\ \hline \multirow{2}{*}{TEdit-CSDI} & Cond. Gen. & 0.2581 & 0.4096 \\  & Edit & **0.1235** & **0.2606** \\ \hline \multirow{2}{*}{TEdit-TW} & Cond. Gen. & 0.2875 & 0.4308 \\  & Edit & **0.1315** & **0.2722** \\ \hline \hline \end{tabular}
\end{table}
Table 3: Quantitative comparison of editing and conditional generation on the Synthetic dataset. The results are averaged over all the finetuning sets.

**Multi-resolution hyper-parameters.** We perform a sensitivity study for the hyper-parameters of the proposed multi-resolution, i.e., the patch length \(L_{p}\) and the number of resolutions \(R\), on one Synthetic finetuning set, which aims to edit trend directions while preserving other attributes. The results are presented in Fig. 6. More results on other Synthetic finetuning sets can be found in Appendix I.2.

To analyze the impact of \(R\), we fix \(L_{p}=2\) and vary \(R\). As shown in Fig. 6 (a), trend types prefer \(R=3\), whereas seasonal cycles perform better with \(R=4\). To examine the impact of \(L_{p}\), we fix \(R=3\) and vary \(L_{p}\). According to Fig. 6 (b), trend types show a preference for \(L_{p}=2\) while seasonal cycles prefer \(L_{p}=3\). Besides, we find that our proposed multi-resolution paradigm always performs better than the vanilla single resolution time-series modeling paradigms, i.e., \(L_{p}=1\) or \(R=1\), which corroborates the discussion in Sec. 3.3 that attributes may influence the time-series generation at different scales and granularities.

**Bootstrap learning hyper-parameters.** We conduct a sensitivity study on the hyper-parameters of bootstrapping, specifically the bootstrap ratio \(\psi\) within the range \(\{0.1,0.3,0.5,0.7,0.9\}\) on a Synthetic finetuning set, which aims to edit the trend direction while preserving others. As shown in Fig. 7, the model exhibits a poor performance then the bootstrap ratio is low, e.g., 0.1. The model has a good performance with medium to high bootstrap ratios. We hypothesize that this is because tuning with only a few top samples might lead to certain mode collapse.

## 5 Conclusion

In this paper, we introduced the task of Time Series Editing (TSE), which enables controllable time series synthesis by manipulating specific attributes of the input time series while maintaining consistency in other properties. There are two major challenges of TSE. Firstly, in the real world, the distribution of time series and attributes is usually biased, and the full space might not be adequately covered. Secondly, time series and attributes exhibit complex multi-scale entanglement. To address these two challenges, we propose a novel diffusion based approach, called TEdit, which incorporates a bootstrap learning algorithm and a multi-resolution modeling and generation paradigm. Comprehensive experiments on both synthetic and real-world datasets demonstrate the effectiveness of our proposed TEdit in generating precise time series with specified attributes. In practice, our method still has certain limitations. For example, different attributes have varying difficulty degrees to edit; attributes may have complex inter-dependencies, and some attributes may be difficult to edit without affecting others. Despite this limitation, we believe our work lays the groundwork for controllable time series synthesis, potentially benefiting applications in fields such as climate monitoring, healthcare, and urban management.

## 6 Acknowledgment

This work is supported by HPC Platform of ShanghaiTech University, Shanghai Frontiers Science Center of Human-centered Artificial Intelligence, and MoE Key Lab of Intelligent Perception and Human-Machine Collaboration. We would like to express our sincere gratitude for their valuable support and resources that contributed significantly to the success of this research.

## References

* [1] Anthony Bagnall, Hoang Anh Dau, Jason Lines, Michael Flynn, James Large, Aaron Bostrom, Paul Southam, and Eamonn Keogh. The uea multivariate time series classification archive, 2018, 2018.
* [2] Nanxin Chen, Yu Zhang, Heiga Zen, Ron J Weiss, Mohammad Norouzi, and William Chan. Wavegrad: Estimating gradients for waveform generation. _arXiv preprint arXiv:2009.00713_, 2020.
* [3] Yuqi Chen, Kan Ren, Yansen Wang, Yuchen Fang, Weiwei Sun, and Dongsheng Li. Contiformer: Continuous-time transformer for irregular time series modeling. _Advances in Neural Information Processing Systems_, 36, 2024.
* [4] Andrea Coletta, Sriram Gopalakrishnan, Daniel Borrajo, and Svitlana Vyetrenko. On the constrained time-series generation problem. _Advances in Neural Information Processing Systems_, 36, 2024.
* [5] Sumanth Dathathri, Andrea Madotto, Janice Lan, Jane Hung, Eric Frank, Piero Molino, Jason Yosinski, and Rosanne Liu. Plug and play language models: A simple approach to controlled text generation. _arXiv preprint arXiv:1912.02164_, 2019.
* [6] Prafulla Dhariwal and Alexander Nichol. Diffusion models beat gans on image synthesis. _Advances in neural information processing systems_, 34:8780-8794, 2021.
* [7] Dave Epstein, Allan Jabri, Ben Poole, Alexei Efros, and Aleksander Holynski. Diffusion self-guidance for controllable image generation. _Advances in Neural Information Processing Systems_, 36:16222-16239, 2023.
* [8] Rakshitha Godahewa, Christoph Bergmeir, Geoff Webb, Rob Hyndman, and Pablo Montero-Manso. Kdd cup dataset (without missing values). https://zenodo.org/records/4656756, 2020.
* [9] Amir Hertz, Ron Mokady, Jay Tenenbaum, Kfir Aberman, Yael Pritch, and Daniel Cohen-Or. Prompt-to-prompt image editing with cross attention control. _arXiv preprint arXiv:2208.01626_, 2022.
* [10] Jonathan Ho, Ajay Jain, and Pieter Abbeel. Denoising diffusion probabilistic models. _Advances in neural information processing systems_, 33:6840-6851, 2020.
* [11] Jonathan Ho and Tim Salimans. Classifier-free diffusion guidance. _arXiv preprint arXiv:2207.12598_, 2022.
* [12] Daniel Jarrett, Jinsung Yoon, Ioana Bica, Zhaozhi Qian, Ari Ercole, and Mihaela van der Schaar. Clairvoyance: A pipeline toolkit for medical time series. _arXiv preprint arXiv:2310.18688_, 2023.
* [13] Baoyu Jing, Hanghang Tong, and Yada Zhu. Network of tensor time series. In _Proceedings of the Web Conference 2021_, pages 2425-2437, 2021.
* [14] Baoyu Jing, Yansen Wang, Guoxin Sui, Jing Hong, Jingrui He, Yuqing Yang, Dongsheng Li, and Kan Ren. Automated contrastive learning strategy search for time series. In _Proceedings of the 33rd ACM International Conference on Information and Knowledge Management_, pages 4612-4620, 2024.
* [15] Baoyu Jing, Si Zhang, Yada Zhu, Bin Peng, Kaiyu Guan, Andrew Margenot, and Hanghang Tong. Retrieval based time series forecasting. _arXiv preprint arXiv:2209.13525_, 2022.
* [16] Baoyu Jing, Dawei Zhou, Kan Ren, and Carl Yang. Causality-aware spatiotemporal graph neural networks for spatiotemporal time series imputation. In _Proceedings of the 33rd ACM International Conference on Information and Knowledge Management_, pages 1027-1037, 2024.
* [17] Tero Karras, Samuli Laine, and Timo Aila. A style-based generator architecture for generative adversarial networks. In _Proceedings of the IEEE/CVF conference on computer vision and pattern recognition_, pages 4401-4410, 2019.

* [18] Gwanghyun Kim, Taesung Kwon, and Jong Chul Ye. Diffusionclip: Text-guided diffusion models for robust image manipulation. In _Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition_, pages 2426-2435, 2022.
* [19] Heeseung Kim, Sungwon Kim, and Sungroh Yoon. Guided-tts: A diffusion model for text-to-speech via classifier guidance. In _International Conference on Machine Learning_, pages 11119-11133. PMLR, 2022.
* [20] Diederik P Kingma. Adam: A method for stochastic optimization. _arXiv preprint arXiv:1412.6980_, 2014.
* [21] Zhifeng Kong, Wei Ping, Jiaji Huang, Kexin Zhao, and Bryan Catanzaro. Diffwave: A versatile diffusion model for audio synthesis. _arXiv preprint arXiv:2009.09761_, 2020.
* [22] Thorsten Kurth, Shashank Subramanian, Peter Harrington, Jaideep Pathak, Morteza Mardani, David Hall, Andrea Miele, Karthik Kashinath, and Anima Anandkumar. Fourcastnet: Accelerating global high-resolution weather forecasting using adaptive fourier neural operators. In _Proceedings of the platform for advanced scientific computing conference_, pages 1-11, 2023.
* [23] Dongxu Li, Junnan Li, and Steven Hoi. Blip-diffusion: Pre-trained subject representation for controllable text-to-image generation and editing. _Advances in Neural Information Processing Systems_, 36, 2024.
* [24] Xiang Li, John Thickstun, Ishaan Gulrajani, Percy S Liang, and Tatsunori B Hashimoto. Diffusion-lm improves controllable text generation. _Advances in Neural Information Processing Systems_, 35:4328-4343, 2022.
* [25] Huan Ling, Karsten Kreis, Daiqing Li, Seung Wook Kim, Antonio Torralba, and Sanja Fidler. Editgan: High-precision semantic image editing. _Advances in Neural Information Processing Systems_, 34:16331-16345, 2021.
* [26] Ron Mokady, Amir Hertz, Kfir Aberman, Yael Pritch, and Daniel Cohen-Or. Null-text inversion for editing real images using guided diffusion models. In _Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition_, pages 6038-6047, 2023.
* [27] Sai Shankar Narasimhan, Shubhankar Agarwal, Oguzhan Akcin, Sujay Sanghavi, and Sandeep Chinchali. Time weaver: A conditional time series generation model. _arXiv preprint arXiv:2403.02682_, 2024.
* [28] Alex Nichol, Prafulla Dhariwal, Aditya Ramesh, Pranav Shyam, Pamela Mishkin, Bob McGrew, Ilya Sutskever, and Mark Chen. Glide: Towards photorealistic image generation and editing with text-guided diffusion models. _arXiv preprint arXiv:2112.10741_, 2021.
* [29] Yuqi Nie, Nam H Nguyen, Phanwadee Sinthong, and Jayant Kalagnanam. A time series is worth 64 words: Long-term forecasting with transformers. _arXiv preprint arXiv:2211.14730_, 2022.
* [30] William Peebles and Saining Xie. Scalable diffusion models with transformers. In _Proceedings of the IEEE/CVF International Conference on Computer Vision_, pages 4195-4205, 2023.
* [31] Hengzhi Pei, Kan Ren, Yuqing Yang, Chang Liu, Tao Qin, and Dongsheng Li. Towards generating real-world time series data. In _2021 IEEE International Conference on Data Mining (ICDM)_, pages 469-478. IEEE, 2021.
* [32] Ratish Puduppully, Li Dong, and Mirella Lapata. Data-to-text generation with content selection and planning. In _Proceedings of the AAAI conference on artificial intelligence_, volume 33, pages 6908-6915, 2019.
* [33] Alec Radford, Jong Wook Kim, Chris Hallacy, Aditya Ramesh, Gabriel Goh, Sandhini Agarwal, Girish Sastry, Amanda Askell, Pamela Mishkin, Jack Clark, et al. Learning transferable visual models from natural language supervision. In _International conference on machine learning_, pages 8748-8763. PMLR, 2021.

* Rasul et al. [2021] Kashif Rasul, Calvin Seward, Ingmar Schuster, and Roland Vollgraf. Autoregressive denoising diffusion models for multivariate probabilistic time series forecasting. In _International Conference on Machine Learning_, pages 8857-8868. PMLR, 2021.
* Ren et al. [2019] Hansheng Ren, Bixiong Xu, Yujing Wang, Chao Yi, Congrui Huang, Xiaoyu Kou, Tony Xing, Mao Yang, Jie Tong, and Qi Zhang. Time-series anomaly detection service at microsoft. In _Proceedings of the 25th ACM SIGKDD international conference on knowledge discovery & data mining_, pages 3009-3017, 2019.
* Shen and Kwok [2023] Lifeng Shen and James Kwok. Non-autoregressive conditional diffusion models for time series prediction. In _International Conference on Machine Learning_, pages 31016-31029. PMLR, 2023.
* Sohl-Dickstein et al. [2015] Jascha Sohl-Dickstein, Eric Weiss, Niru Maheswaranathan, and Surya Ganguli. Deep unsupervised learning using nonequilibrium thermodynamics. In _International conference on machine learning_, pages 2256-2265. PMLR, 2015.
* Song et al. [2020] Jiaming Song, Chenlin Meng, and Stefano Ermon. Denoising diffusion implicit models. _arXiv preprint arXiv:2010.02502_, 2020.
* Tashiro et al. [2021] Yusuke Tashiro, Jiaming Song, Yang Song, and Stefano Ermon. Csdi: Conditional score-based diffusion models for probabilistic time series imputation. _Advances in Neural Information Processing Systems_, 34:24804-24816, 2021.
* Um and Ye [2023] Soobin Um and Jong Chul Ye. Don't play favorites: Minority guidance for diffusion models. _arXiv preprint arXiv:2301.12334_, 2023.
* Maaten and Hinton [2008] Laurens van der Maaten and Geoffrey Hinton. Visualizing data using t-sne. _Journal of Machine Learning Research_, 9(Nov):2579-2605, 2008.
* Vaswani et al. [2017] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. _Advances in neural information processing systems_, 30, 2017.
* Wang et al. [2022] Senzhang Wang, Meiyue Zhang, Hao Miao, Zhaohui Peng, and Philip S Yu. Multivariate correlation-aware spatio-temporal graph convolutional networks for multi-scale traffic prediction. _ACM Transactions on Intelligent Systems and Technology (TIST)_, 13(3):1-22, 2022.
* Xiao et al. [2023] Chunjing Xiao, Zehua Gou, Wenxin Tai, Kunpeng Zhang, and Fan Zhou. Imputation-based time-series anomaly detection with conditional weight-incremental diffusion models. In _Proceedings of the 29th ACM SIGKDD Conference on Knowledge Discovery and Data Mining_, pages 2742-2751, 2023.
* Yang et al. [2024] Yiyuan Yang, Ming Jin, Haomin Wen, Chaoli Zhang, Yuxuan Liang, Lintao Ma, Yi Wang, Chenghao Liu, Bin Yang, Zenglin Xu, et al. A survey on diffusion models for time series and spatio-temporal data. _arXiv preprint arXiv:2404.18886_, 2024.
* Yi et al. [2024] Ke Yi, Yansen Wang, Kan Ren, and Dongsheng Li. Learning topology-agnostic eeg representations with geometry-aware modeling. _Advances in Neural Information Processing Systems_, 36, 2024.
* Yoon et al. [2019] Jinsung Yoon, Daniel Jarrett, and Mihaela Van der Schaar. Time-series generative adversarial networks. _Advances in neural information processing systems_, 32, 2019.
* Yuan and Qiao [2024] Xinyu Yuan and Yan Qiao. Diffusion-ts: Interpretable diffusion for general time series generation. _arXiv preprint arXiv:2403.01742_, 2024.
* Zhang et al. [2023] Lvmin Zhang, Anyi Rao, and Maneesh Agrawala. Adding conditional control to text-to-image diffusion models. In _Proceedings of the IEEE/CVF International Conference on Computer Vision_, pages 3836-3847, 2023.
* Zhou et al. [2019] Hang Zhou, Yu Liu, Ziwei Liu, Ping Luo, and Xiaogang Wang. Talking face generation by adversarially disentangled audio-visual representation. In _Proceedings of the AAAI conference on artificial intelligence_, volume 33, pages 9299-9306, 2019.

* [51] Hang Zhou, Yasheng Sun, Wayne Wu, Chen Change Loy, Xiaogang Wang, and Ziwei Liu. Pose-controllable talking face generation by implicitly modularized audio-visual representation. In _Proceedings of the IEEE/CVF conference on computer vision and pattern recognition_, pages 4176-4186, 2021.

Related Work

Time Series Generation.Time series generation has become a research hotspot in recent years [47]. From the view of modeling, early attempts for time series generation utilize Generative Adversarial Networks (GANs) [47; 31], which trains the generator adversarial to the discriminator of correct classification on real or synthetic data. The latest research moves the focus to Diffusion models (DMs) [27; 36; 39] which have illustrated much higher fidelity and generation performance than GANs [45]. From the perspective of the generation paradigm, there are two branches. The first one is unconditional generation [47; 31; 34; 48], which employs a generative model to generate data samples without relying on any conditions for regulation. The second paradigm is conditional generation [39; 27; 36; 44] making use of additional conditional information like category labels, textual descriptions, features, and other kinds of metadata to guide the generation process and enabling high-quality generation that is tightly correlated with the conditions. Among them, CSDI [39] enhances time-series imputation by treating observed time series as conditions in the diffusion model. Time Weaver[27] directly encode the metadata into the diffusion model to achieve controlled generation. Though they achieved better quantitative results, these methods suffer from unexpected outcomes that inadvertently emphasize trivial attributes while overlooking critical ones, especially with a low availability of time-series data over various attributes.

Diffusion Model.Diffusion model [10; 37] has become increasingly prominent for data generation across various fields [26; 28; 2; 21], which learns to gradually regress and remove the noise that was added to the clean data in the forward process, allowing data generation aligned with real distribution. Our work is highly related to conditional generation, which can be divided into two main streams of techniques. Classifier-guided generation [6; 19; 24] adds the control signal from the gradient of the classifier to bias the generation towards the specific class in the denoising process of the diffusion model, which requires training an additional classification model. Another stream of works [11; 30] stem from classifier-free guidance in data generation, without training any additional classifier.

Data Editing.Data editing aims to manipulate the content of the given input to meet the requirements of the target data attributes, such as image style [17], semantics [25], and structure [7], with the utilization of multimodal methods such as text-to-image synthesis [9; 28; 49] and audio based image editing [50; 51]. In text-based scenarios, some works also generate texts under the instruction of specific attributes like sentiment [5] and structural information [32]. However, directly adopting the existing solution from other fields to time series editing is not feasible because of the significantly different data formats and poor data coverage of real-world time-series data w.r.t. different attributes.

## Appendix B Broader Impacts

Our method offers several potential positive societal impacts in many real-world scenarios. For example, in climate monitoring, it enhances climate models and forecasts, aiding in climate change mitigation. For urban management, it supports better decision-making in areas such as traffic management, pollution control, and resource allocation. Additionally, in research, it facilitates robust experiments and innovative solutions by providing high-quality, customizable datasets.

However, there are potential negative societal impacts to consider. There are data privacy risks associated with the manipulation of sensitive information, necessitating strong data protection measures. In financial markets, our method could be exploited for fraudulent activities, undermining market integrity. An overreliance on synthetic data may lead to biased or inaccurate models, resulting in flawed decision-making. Furthermore, there are ethical concerns regarding the potential misuse of our method in creating deceptive artificial intelligence models, which raises issues of transparency and accountability. While our method offers significant benefits, it is crucial to carefully manage these risks to maximize positive impacts and minimize negative consequences.

## Appendix C Diffusion Process

In this section, we give a review of the diffusion process. Diffusion models are a class of two-stage generation models, consisting of a forward process and a reverse(denoising) process. The forward process is a Markov chain which gradually adds random noise on the origin data sample \(\mathbf{x}_{0}\) and intermediate latent variables \(\mathbf{x}_{t}\) through a Gaussian transition \(q(\mathbf{x}_{t}|\mathbf{x}_{t-1}):=\mathcal{N}(\sqrt{1-\beta_{t}}\mathbf{x}_{t- 1},\beta_{t}\mathbf{I})\), where \(t=1,\cdots,T\) indicates the diffusion step, and \(\{\beta_{t}\}_{t=0}^{T}\) are predetermined variance schedule. The latent variable \(\mathbf{x}_{t}\) can be described as:

\[\mathbf{x}_{t}=\sqrt{\alpha_{t}}\mathbf{x}_{0}+\sqrt{1-\alpha_{t}}\bm{\epsilon },\ \bm{\epsilon}\sim\mathcal{N}(0,\mathbf{I}),\ \alpha_{t}:=\Pi_{s=1}^{t}(1-\beta_{s}).\] (7)

In the reverse process, a denoiser \(\bm{\epsilon}_{\theta}(\mathbf{x}_{t},t,\mathbf{a})\), where \(\mathbf{a}\in\mathbb{N}^{K}\) is the given attributes, is needed to approximate the noise in each diffusion step to help to sample backward from \(\mathbf{x}_{T}\) through another Gaussian transition \(p_{\theta}(\mathbf{x}_{t-1}|\mathbf{x}_{t}):=\mathcal{N}(\mathbf{x}_{t-1}; \mu_{\theta}(\mathbf{x}_{t},t),\ \sigma_{\theta}(\mathbf{x}_{t},t)\mathbf{I})\). To obtain \(\mu_{\theta}(\mathbf{x}_{t},t)\), the denoiser should be trained by optimizing the loss:

\[\min_{\theta}\mathcal{L}:=\min_{\theta}\mathbb{E}_{\mathbf{x}_{0}\sim q( \mathbf{x}_{0}),\ \bm{\epsilon}\sim\mathcal{N}(0,\mathbf{I}),\ t\sim\mathcal{U}(1,T)}\ \|\bm{\epsilon}-\bm{\epsilon}_{\theta}\left(\mathbf{x}_{t},t,\mathbf{a} \right)\|_{2}^{2}\] (8)

Here \(q(\mathbf{x}_{0})\) denotes the data distribution of \(\mathbf{x}_{0}\) (or \(\mathbf{x}\)), \(t\sim\mathcal{U}(1,T)\) indicates that the diffusion step \(t\) follows the uniform distribution between \(1\) and \(T\).

After training, given a condition \(\mathbf{a}\), we can generate the sample \(\hat{\mathbf{x}}_{0}\) from a random noise \(\hat{\mathbf{x}}_{T}\sim\mathcal{N}(0,\mathbf{I})\) using the trained \(\bm{\epsilon}_{\theta}(\mathbf{x}_{t},t,\mathbf{a})\) with a diffusion sampler, such as the deterministic denoising diffusion implicit model (DDIM) [38]:

\[\hat{\mathbf{x}}_{t-1} =\sqrt{\alpha_{t-1}}\mathbf{f}_{\theta}(\hat{\mathbf{x}}_{t},t, \mathbf{a})+\sqrt{1-\alpha_{t-1}}\bm{\epsilon}_{\theta}(\hat{\mathbf{x}}_{t}, t,\mathbf{a})\] (9) \[\mathbf{f}_{\theta}(\hat{\mathbf{x}}_{t},t,\mathbf{a}) =(\hat{\mathbf{x}}_{t}-\sqrt{1-\alpha_{t}}\bm{\epsilon}_{\theta }\left(\hat{\mathbf{x}}_{t},t,\mathbf{a}\right))/\sqrt{\alpha_{t}}\] (10)

where \(\mathbf{f}_{\theta}(\hat{\mathbf{x}}_{t},t,\mathbf{a})\) can be regarded as a prediction of \(\mathbf{x}_{0}\) at the diffusion step \(t\).

## Appendix D Model Architecture

In this section, we will show the architecture utilized in our modified backbone models CSDI 8 and Time-Weaver 9, especially how the attributes are incorporated into the models. It should be mentioned that all the attributes in our experiment setting are categorical.

Consider a batch of time series samples of size \((N_{\text{batch}},F,L)\), where \(N_{\text{batch}}\) represents the number of samples per batch, \(F\) represents the number of channels in the time series, and \(L\) represents the horizon. The corresponding attributes \(\mathbf{a}\) is of shape \((N_{\text{batch}},L,K)\), where \(K\) represents the number

Figure 8: Model architecture of our modified CSDI.

of the attributes. While performing the time-series inputs, each attribute option will be encoded to a corresponding embedding vector.

As for CSDI, our modified part is highlighted in red. First, the attribute embedding will be linearly projected to shape \((N_{\text{batch}},d,F,K)\), then concatenated with the time series embedding to form the prompt with shape \((N_{\text{batch}},d,F,K+L)\). Next, the prompt is added with the expanded diffusion step embedding and the sum will be inputted into the transformer layer. After that, the attribute embedding will be discarded, and the shape gets back to \((N_{\text{batch}},d,F,L)\).

For Time-Weaver, We only make some slight changes to its original structure: 1. Our experiment setting doesn't include continuous type attributes, as mentioned. 2. We replace the self-attention modules with multi-layer perceptrons (MLPs).

As mentioned in Sec 3.3, we introduce a novel parallelization with an attention masking mechanism to accelerate the training and inference. The attention mask is of the following form, denoted as \(\mathbf{M}\in\mathbb{R}^{(N_{p}^{0}+\dots+N_{p}^{R-1})\times(N_{p}^{0}+\dots+N _{p}^{R-1})}\) where \(\mathbf{M}^{r}\in\mathbf{0}^{N_{p}^{r}}\), the residual value is negative infinity. Through adding this attention mask into the original attention calculation [42] and softmax operation \(\text{softmax}(\mathbf{z})_{i}=\frac{e^{z_{i}}}{\sum_{j=1}^{p}e^{z_{j}}}\) receiving \(\mathbf{z}\in\mathbb{R}^{N}\), such attention mask would mask out inter-sequence attention while preserving intra-sequence attention.

\[\mathbf{M}=\begin{pmatrix}\mathbf{M^{1}}&\dots&-\infty\\ \vdots&\ddots&\vdots\\ -\infty&\dots&\mathbf{M^{R-1}}\end{pmatrix}\]

## Appendix E Bootstrap Learning Algorithm

As mentioned in Sec. 3.4, we propose a bootstrap learning algorithm that enables the model \(\bm{\epsilon}_{\theta}\) to learn the information of the imaginary target. Given the pretained model \(\bm{\epsilon}_{\theta}\), the detailed algorithm for a batch \((\mathbf{X}_{0}^{\text{src}}\in\mathbb{R}^{B\times L},\mathbf{A}^{\text{src }}\in\mathbb{N}_{+}^{B\times K})\), where \(B\) is the batch size, \(L\) is the length, and \(K\) is the number of attributes, is presented below.

Figure 9: Model architecture of Time Weaver.

## Appendix F Datasets

### Synthetic Dataset

We generate the synthetic time series according to the following formula:

\[\mathbf{x}=\mathbf{x}_{\text{trend}}+\mathbf{x}_{\text{season}}+\mathbf{x}_{ \text{noise}}+\mathbf{x}_{\text{bias}}.\] (11)

Table 5 shows the summary of the attributes for the synthetic dataset.

For example, the attribute \(\{\text{Trend Type}\) = linear, \(\text{Trend Direction}\) = up, \(\text{Season Cycles}\) = 2\(\}\) is one of the total 32 (\(4\) Trend Types \(\times\)\(2\) Trend Directions \(\times\)\(4\) Season Cycles) attribute combinations. We split the 32 combinations into train, validation, and test sets by 24:4:4.

In the pretraining dataset, for each attribute combination, we sample 300 time series according to the random variances described in the following subsections. For the finetuning dataset, we treat each attribute combination in the 24:4:4 split as the target attribute. For each target attribute, we compose its source attribute based on the desired attributes to be edited \(\mathcal{A}_{\text{edit}}\) and preserved \(\mathcal{A}_{\text{prsv}}\). For example, let \(\mathcal{A}_{\text{edit}}=\{\text{trend type}\}\), \(\mathcal{A}_{\text{prsv}}=\{\text{trend direction},\text{season cycles}\}\). Suppose the target attribute \(\mathbf{a}^{\text{tgt}}=\{\text{linear},\text{up},2\}\), then its source could be \(\mathbf{a}^{\text{src}}_{1}=\{\text{linear},\text{up},2\}\), \(\mathbf{a}^{\text{src}}_{2}=\{\text{quadratic},\text{up},2\}\), \(\mathbf{a}^{\text{src}}_{3}=\{\text{exponential},\text{up},2\}\) and, \(\mathbf{a}^{\text{src}}_{4}=\{\text{logistic},\text{up},2\}\). Then for a source and target attribute pair \((\mathbf{a}^{\text{src}},\mathbf{a}^{\text{tgt}})\), we generate the source and target time series \((\mathbf{x}^{\text{src}},\mathbf{x}^{\text{tgt}})\) based on the process described in the following subsections. Note that for each \((\mathbf{a}^{\text{src}},\mathbf{a}^{\text{tgt}})\) attribute pair, we first generate the deterministic part, e.g., trend type, for \(\mathbf{a}^{\text{src}}\) and \(\mathbf{a}^{\text{tgt}}\), denoted by \(\mathbf{x}^{\text{src}}_{defer}\) and \(\mathbf{x}^{\text{tgt}}_{defer}\). Then generate 10 randomnesses \(\mathbf{x}_{rand}\), including noise, bias etc, and then we add these randomnesses to the

\begin{table}
\begin{tabular}{l l} \hline \hline
**Input:** & \((\mathbf{X}^{\text{src}}_{0}\in\mathbb{R}^{B\times L},\mathbf{A}^{\text{src} }\in\mathbb{N}_{+}^{B\times K})\), where \(B\), \(L\), \(K\) are batch size, length, and attribute number. \\ Attributes to be edited \(\mathcal{A}_{\text{edit}}\) and preserved \(\mathcal{A}_{\text{prsv}}\). \\ The ratio \(\psi\) of the top bootstrapped samples to include for tuning. \\
1: **\# 1. Compose tuple**\((\mathbf{X}^{\text{src}}_{0},\mathbf{A}^{\text{src}},\mathbf{A}^{\text{tgt}})\). \\
2: **for**\(k=1,\cdots,K\)**do** \\
3: **if**\(k\in\mathcal{A}_{\text{edit}}\)**then** \\
4: \(\mathbf{A}^{\text{tgt}}[:,k]\sim\mathcal{U}\{1,\cdots,N_{k}\}\) \\
5: **else** \\
6: **\(\mathbf{A}^{\text{tgt}}[:,k]=\mathbf{A}^{\text{src}}[:,k]\)** \\
7: **\# 2. Generate the target \(\hat{\mathbf{X}}^{\text{tgt}}\).** \\
8: \(\hat{\mathbf{X}}^{\text{tgt}}_{0}\leftarrow\Phi_{\theta}(\mathbf{X}^{\text{ src}}_{0},\mathbf{A}^{\text{src}},\mathbf{A}^{\text{tgt}})\) \\
9: **\# 3. Self-Score the target \(\hat{\mathbf{X}}^{\text{tgt}}_{0}\), and keep the top \(\psi\) samples.** \\
10: \(\hat{\mathbf{X}}^{\text{src}}_{0}\leftarrow\Phi_{\theta}(\hat{\mathbf{X}}^{ \text{tgt}}_{0},\mathbf{A}^{\text{tgt}},\mathbf{A}^{\text{src}})\) \\
11: \(\mathbf{s}\leftarrow\text{MSE}(\mathbf{X}^{\text{src}}_{0},\hat{\mathbf{X}}^{ \text{src}}_{0})\) \\
12: \(\hat{\mathbf{X}}^{\text{tgt}}_{0}\leftarrow\text{Sort}(\hat{\mathbf{X}}^{ \text{tgt}}_{0}|\mathbf{s})\) \\
13: \(\hat{\mathbf{X}}^{\text{tgt}}_{0,\text{bs}}\leftarrow\hat{\mathbf{X}}^{\text{tgt }}_{0}[:B\cdot\psi]\) \\
14: **\# 4. Calculate the loss.** \\
15: \(\mathcal{L}_{BS}\leftarrow\mathcal{L}(\hat{\mathbf{X}}^{\text{tgt}}_{0,\text{bs}})\) \\ \(\triangleright\)\(\mathcal{L}\) _is the noise estimation loss of diffusion models defined in Eq.(_1_)._ \\ \hline \hline \end{tabular}
\end{table}
Table 5: Summary of attribute optionsdeterministic part to ensure the source and target time series have the same randomness \(\mathbf{x}_{rand}\): \(\mathbf{x}^{\text{tgt}}=\mathbf{x}^{\text{tgt}}_{deter}+\mathbf{x}_{rand}\), \(\mathbf{x}^{\text{src}}=\mathbf{x}^{\text{src}}_{deter}+\mathbf{x}_{rand}\).

The finetuning dataset contains 6 subsets for editing different attribute combinations. For modifying trend type, there are 760 train samples, 140 validation samples, and 160 test samples. For modifying trend direction, there are 420 train samples, 70 validation samples, and 80 test samples. For modifying season cycles, there are 760 train samples, 140 validation samples, and 160 test samples. For modifying trend type and trend direction, there are 1440 train samples, 280 validation samples, and 320 test samples. For modifying trend type and season cycles, there are 2880 train samples, 560 validation samples, and 640 test samples. For modifying trend direction and season cycles, there are 1440 train samples, 280 validation samples, and 320 test samples. In addition, the same random variance and bias pair is used both on the source time series and target time series in a source-target pair respectively.

In the following formulas, \(t_{i}\) indicates the \(i\)-th sampling point in the original synthetic time series(\(\mathbf{t}\)) and \(x_{i}\) indicates the \(i\)-th sampling point in a contain form of \(\mathbf{x}\). For instance, the total length of a time series \(L=128,\text{ then }i=[1,\ldots,128]\).

#### f.1.1 Trend

**Trend Types.** As described in table 5, there are 4 trend types: linear, quadratic, exponential, and logistic. As described above, \(\mathbf{t}\) is used to obtain \(\mathbf{x}\). For the **linear** trend: \(\mathbf{x}_{\text{trend}}=\mathbf{t},\text{ in this case }t_{i}\in[0,1],\ x_{i}\in[0,1]\). For the **quadratic** trend: \(\mathbf{x}_{\text{trend}}=\mathbf{t}^{2},\text{ in this case }t_{i}\in[0,1],\ x_{i}\in[0,1]\). For the **exponential** trend: \(\mathbf{x}_{\text{trend}}=\frac{2^{\epsilon}}{102^{24}},\text{ in this case }t_{i}\in[-10,10],\ x_{i}\in[0,1]\). \(\mathbf{x}_{\text{trend}}\) is needed to range from 0 to 1, so \(t_{i}\) is in [-10,10]. For **logistic** trend: \(\mathbf{x}_{\text{trend}}=\frac{1}{1+\exp(-\mathbf{t})},\text{ where }t_{i}\in[-10,10],\ x_{i}\in[0,1]\). Similar to the exponential trend, we repeat a scaling process in logistic trend. To train the model more easily, \(\mathbf{x}_{\text{trend}}=(\mathbf{x}-0.5)\times 2\) is used to normalize \(\mathbf{x}_{\text{trend}}\) to \([-1,1]\).

**Trend Directions.** There are totally 2 directions: up and down. For instance, in the Cartesian coordinate system, a linear line from coordinates \((0,0)\) to \((1,1)\) represents an "up" trend, while another line from coordinates \((0,0)\) to \((1,-1)\) represents a "down" trend. All 4 trend types introduce above are originally "up" trends. Therefore, for an "up" trend, we set \(\mathbf{x}_{\text{trend}}=\mathbf{x}_{\text{trend}}\) and for a "down" trend, we set \(\mathbf{x}_{\text{trend}}=-\mathbf{x}_{\text{trend}}\).

**Random Variance.** We randomly perturb the scale of the trend by: \(\mathbf{x}_{\text{trend}}=s\cdot\mathbf{x}_{\text{trend}}\) where \(s\) is the random scale obtained by the following process \(s=m\cdot c+(1-m)\cdot\frac{1}{c},\ m\sim Bern(0.5),\ c\sim\mathcal{U}(0.8,1.0)\) If \(m=1\), then \(s=c\in[0.8,1.0]\); else \(s=\frac{1}{c}\in[1.0,1.25]\).

#### f.1.2 Season

The season attribute is represented by the number of cycles in a time series. [0,1,2,4] sinusoidal wave cycles are randomly added.

\[\mathbf{x}_{\text{season}}=a\sin(2\pi t+\phi)\] (12)

where \(t\in[0,n_{\text{cycle}}],n_{\text{cycle}}\in[0,2^{0},2^{1},2^{2}]\). The Random Variances of these two variables follow uniform distributions: \(a\sim\mathcal{U}(0.4,0.6),\ \phi\sim\mathcal{U}(0,2\pi)\).

#### f.1.3 Noise

We simulate the real-world noise by a combination of Gaussian noise and high-frequency noise.

\[\mathbf{x}_{\text{noise}}=\mathbf{x}_{\text{g}}+\mathbf{x}_{\text{bf}}\] (13)

The Gaussian noise is sampled through \(\mathbf{x}_{\text{g}}=\mathcal{N}(0,\sigma),\sigma\sim\mathcal{U}(0.04,0.06)\). The high-frequency noise is portrayed by a sinusoidal wave: \(\mathbf{x}_{\text{bf}}=a\sin(2\pi t+\phi),\ t\in[0,n_{\text{cycle}}],\ n_{ \text{cycle}}\in[2^{4},2^{5},2^{6}],\ a\sim\mathcal{U}(0.08,0.10),\ \phi\sim\mathcal{U}(0,2\pi)\).

#### f.1.4 Bias

The last step is to add bias to the previous synthesized sample, which is randomly sampled from a uniform distribution \(\mathbf{x}_{\text{bias}}\sim\mathcal{U}(-0.5,0.5)\).

### Real World Datasets

#### f.2.1 Air Quality Dataset

This dataset was used in the KDD Cup 2018 forecasting competition [8]. It contains lots of hourly sampled time series representing the air quality levels measured from different stations in 2 cities: Beijing (35 stations) and London (24 stations) from 01/01/2017 to 31/03/2018. This air quality level is represented in multiple measurements such as PM2.5, PM10, NO\({}_{2}\), CO, O\({}_{3}\), and SO\({}_{2}\).

We processed the raw data and split it into train, validation, and test sets. We only selected the data of PM2.5, which is common in all stations. Season attributes are generated according to month. We slice the series by week to a length of \(168~{}(24\text{hour}\times 7\text{day})\). For pretraining dataset, there are totally 3650 time series samples, in which we randomly pick 2825 time series samples as train, 353 time series samples as validation, and 472 time series samples as the test. For finetuning dataset, it's composed of multi-subsets where each subset corresponds to an editing setting, e.g. modifying the "season". In any subset, a sample is composed of a source time series, source attributes, and target attributes where the source time series are sampled from the corresponding splits of pretraining data. For each source time series, we randomly change the source attributes 2 or 3 times to get the target attributes and pair the source time series and target attributes together. Finally, we get (train: 2000, valid: 600, test: 600) samples for modifying "city" subset and (train: 3000, validation: 900, test: 900) samples for modifying "season" subset.

#### f.2.2 Motor Imagery Dataset

The Motor Imagery dataset [1] contains some Electroencephalogram (EEG) records. During the Brain-Computer Interface experiments, the subjects have to perform imagined movements of either the tongue or the left small finger. All recordings are collected at a sampling rate of 1000 Hz with 64 channels. Every record contains 3000 time stamps (3 seconds measurement). For pertaining data, there are 19353 samples in the train set, 2419 in the validation set, 2419 in the test set. For fine-tuning data, the processing operation is similar to the Air Quality. In the subset of modifying movement, there are (train:2000, valid:1000, test:1000) samples. In the subset of modifying channel id, there are (train:3000, valid:1500, test:1500) samples.

## Appendix G CTAP Model Details

Our Contrastive Time-Series Attribute Pretraining (CTAP) model is similar to the popular CLIP model [33]. The purpose of this model is to train the time series encoder and the attribute encoder by learning the alignment between the time series \(\mathbf{x}\in\mathbb{R}^{L}\) and its associated attributes \(\mathbf{a}\in\mathbb{N}_{+}^{K}\). Note that we use separate attribute encoders for different attributes \(a_{k}=\mathbf{a}[k]\), \(k\in\{1,...,K\}\). An illustration of CTAP for a batch of \(\mathbf{X}\in\mathbb{R}^{B\times L}\) and their associated \(k\)-th attribute \(\mathbf{A}\in\mathbb{N}_{+}^{B}\) is presented in Fig. 10. Note that the attribute index \(k\) is dropped for clarity. The time series encoder and attribute encoder extract the embeddings \(\mathbf{H}_{\mathbf{x}}=\{\mathbf{h}_{\mathbf{x}_{i}}\}_{i=1}^{B}\) and \(\mathbf{H}_{a}=\{\mathbf{h}_{a_{i}}\}_{i=1}^{B}\). Following [33], we calculate the pair-wise similarities between the \(\mathbf{h}_{\mathbf{x}_{i}}\) and \(\mathbf{h}_{a_{j}}\), and the encoders are trained by distinguishing whether \(\mathbf{h}_{\mathbf{x}_{i}}\) and \(\mathbf{h}_{a_{j}}\) are from the same data pair. The pseudocode of the CTAP model is shown in Algorithm 2.

\begin{table}
\begin{tabular}{l c c} \hline \hline Dataset & L & Categorical and Editable Attributes \\ \hline Air Quality [8] & 168 & 
\begin{tabular}{c} 4 Seasons [Spring, Summer, Autumn, Winter] \\ 2 Cities [Beijing, London] \\ \end{tabular} \\ \hline \multirow{2}{*}{Motor Imagery [1]} & \multirow{2}{*}{150} & 2 Movements [Figure, Tongue] \\  & & 64 Channels[1, 2,..., 64] \\ \hline \end{tabular}
\end{table}
Table 6: Dataset description in our experiments. Some key information is listed above. The real-world datasets include Air Quality, Motor Imagery. All datasets have been carefully processed. \(L\) indicates the time series length. The second column indicates all editable attributes.

[MISSING_PAGE_FAIL:21]

Evaluation Metrics

### MSE and MAE

For the synthetic dataset, MSE and MAE are two of the metrics used in our experiments. For the reason that we have targets in our synthetic datasets, MSE and MAE can be applied to evaluate the generated time series. The two formulas are listed below:

MSE \[=\frac{1}{|\mathcal{D}|}\sum_{i=1}^{|\mathcal{D}|}(\mathbf{x}_{i}- \hat{\mathbf{x}}_{i})^{2}\] (14) MAE \[=\frac{1}{|\mathcal{D}|}\sum_{i=1}^{|\mathcal{D}|}|\mathbf{x}_{i}- \hat{\mathbf{x}}_{i}|\] (15)

Here \(|\mathcal{D}|\) is the size of the test set, \(\mathbf{x}_{i}\) is the \(i\)-th target time series, and \(\hat{\mathbf{x}}_{i}\) is the corresponding generated time series.

### Ctap

The CTAP score is obtained through the Contrastive Time series - Attribute Pretraining (CTAP) model, which is similar to the popular CLIP model [33]. The details of the CTAP model are given in Appendix G. Suppose \(a_{k}^{\text{tgt}}\) is one of the target attributes, the CTAP score is similar to the CLIP-I score [23], which uses the pretrained CTAP model to measure the alignment, e.g., cosine similarity, between the generated \(\hat{\mathbf{x}}^{\text{tgt}}\) and the real-world time series that also associated with the attribute \(a_{k}^{\text{tgt}}\). Specifically, we first use the CTAP model to extract embeddings \(\hat{\mathbf{h}}_{\mathbf{x}}\), which is the embedding of \(\hat{\mathbf{x}}^{\text{tgt}}\), and \(\hat{\mathbf{h}}_{\mathbf{x}}|a_{k}^{\text{tgt}}\), which is the average embedding for the time series associated with \(a_{k}^{\text{tgt}}\) in the training data. Then we calculate the cosine similarity of \(\hat{\mathbf{h}}_{\mathbf{x}}\) and \(\hat{\mathbf{h}}_{\mathbf{x}}|a_{k}^{\text{tgt}}\), where the higher similarity indicates better alignment between the generated and real-world time series.

### RaTS

We introduce Log _R_atio of _T_arget-to-Source probability (RaTS) score to measure whether the generated time series \(\hat{\mathbf{x}}^{\text{tgt}}\) is closer to the target attribute \(a_{k}^{\text{tgt}}\) than the source time series \(\mathbf{x}^{\text{src}}\). Formally, the RaTS score for a tuple (\(\hat{\mathbf{x}}^{\text{tgt}}\), \(\mathbf{x}^{\text{src}}\), \(a_{k}^{\text{tgt}}\)) is defined as:

\[\text{RaTS}(\hat{\mathbf{x}}^{\text{tgt}},\mathbf{x}^{\text{src}},a_{k}^{ \text{tgt}})=\log(\frac{p(a_{k}^{\text{tgt}}|\hat{\mathbf{x}}^{\text{tgt}}) }{p(a_{k}^{\text{tgt}}|\mathbf{x}^{\text{src}})}).\] (16)

where \(p(a_{k}|\mathbf{x})\) is calculated by applying a softmax over the similarity scores of all \((\mathbf{h}_{\mathbf{x}},\mathbf{h}_{a_{k}=i})\) pairs, where \(\mathbf{h}_{\mathbf{x}}\) is the CTAP embedding of \(\mathbf{x}\), and \(\mathbf{h}_{a_{k}=i}\), \(i\in\{1,...,N_{k}\}\), is the CTAP embedding of the \(i\)-th possible value for the \(k\)-th attribute \(a_{k}\).

RaTS > 0 represents the model doesn't retain characteristics of the source time series \(\mathbf{x}^{\text{src}}\) to a certain degree. RaTS < 0 means that the attribute \(a_{k}^{\text{tgt}}\) is reinforced compared to the source \(\mathbf{x}^{\text{src}}\). For the edited attributes \(\mathcal{A}_{\text{edit}}\), the higher the RaTS score, the closer the edited \(\hat{\mathbf{x}}^{\text{tgt}}\) is to the target attributes. For the preserved attributes \(\mathcal{A}_{\text{pav}}\), the lower the IRaTSl score, the better the preservation of the attributes.

[MISSING_PAGE_EMPTY:23]

### Sensitivity Study for multi-resolution

In this section, we show the impact of different Multi-resolution parameters on different attributes in Fig. 11. All experiments are performed on 6 subsets of Synthetic, including editing [trend type, trend direction, season cycles, trend type & trend direction, trend type & season cycles, trend direction & season cycles]. To analyze the influence of \(R\), we fix \(L_{p}=2\) and vary \(R\). To examine the impact of \(L_{p}\), we fix \(R=3\) and vary \(L_{p}\). We found that different attributes exhibit varying preferences for multi-resolution parameters across different subsets. This observation supports the motivation for proposing a multi-resolution approach: distinct attributes exert different scales of influence on time series data.

Figure 11: The impact of multi-resolution on 6 Synthetic subsets.

### Case Study

In this section, we demonstrate the superiority of our approach by visualizing the results of our method with a baseline on editing tasks. As shown in Fig. 12, we compare our method and baselines on Synthetic dataset. The left column compares the TEdit-CSDI and CSDI while the right column compares the TEdit-TW and Time Weaver. Each row represents different attribute settings, containing: modifying trend type, modifying trend direction, modifying season cycles, modifying trend type and trend direction, modifying trend type and season cycles, modifying trend direction and season cycles. It's obvious that the editing results of our method are much closer to the target time series with lower MSE and MAE, proving the superiority of our method.

Figure 12: More cases of different attribute subsets of Synthetic dataset

### Comparing Editing and Conditional Generation

Here we provide more comparison results of conditional generation and editing in Fig. 13. The editing results are closer to the target time series with lower MSE and MAE. Although the time series generated by condition generation also meets the requirement of the attributes, it still lost the detailed information of input while the editing process better retains the characteristics of the time series to preserve and manipulate only the target attribute to change. Therefore, the editing can achieve a more precise control compared with conditional generation.

### Bootstrap influence on different attributes

To further explore the impact of bootstrapping on data coverage, we visualize the effect of bootstrapping data on different attributes to complement the original data. Fig. 14,15,16 present the results on trend types, and season cycles, trend directions, respectively. According to the classification accuracy of the TAP model and case study, we can infer that trend directions are a relatively simple pattern for modeling while the trend types and season cycles are more complex. The data coverage improvement brought by bootstrapping is more obvious when the attribute is complex.

Figure 13: Comparison between editing and conditional generationFigure 16: The influence of bootstrapping on different trend directions

Figure 14: The influence of bootstrapping on different trend types

Figure 15: The influence of bootstrapping on different season cycles

### NeurIPS Paper Checklist

1. **Claims** Question: Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope? Answer: [Yes] Justification: The paper has clearly claimed the contributions and method scope in Abstract and Introduction parts. Guidelines: * The answer NA means that the abstract and introduction do not include the claims made in the paper. * The abstract and/or intr2oduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers. * The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings. * It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper.
2. **Limitations** Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] Justification: This paper has discussed the limitations in Conclusion part. Guidelines: * The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper. * The authors are encouraged to create a separate "Limitations" section in their paper. * The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be. * The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated. * The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon. * The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size. * If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness. * While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren't acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations.
3. **Theory Assumptions and Proofs** Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? Answer: [NA]Justification: This paper does not include theoretical results. Guidelines: * The answer NA means that the paper does not include theoretical results. * All the theorems, formulas, and proofs in the paper should be numbered and cross-referenced. * All assumptions should be clearly stated or referenced in the statement of any theorems. * The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition. * Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material. * Theorems and Lemmas that the proof relies upon should be properly referenced.
4. **Experimental Result Reproducibility** Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? Answer: [Yes] Justification: This paper has claimed the details of both experimental settings and model implementations. Guidelines: * The answer NA means that the paper does not include experiments. * If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not. * If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable. * Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed. * While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example 1. If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. 2. If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. 3. If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). 4. We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results.
5. **Open access to data and code** Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material?Answer: [Yes] Justification: The code and data are released with paper. Guidelines:

* The answer NA means that paper does not include experiments requiring code.
* Please see the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details.
* While we encourage the release of code and data, we understand that this might not be possible, so "No" is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).
* The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details.
* The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.
* The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.
* At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).
* Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
6. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: The training and test details have been provided in the appendix. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material.
7. **Experiment Statistical Significance** Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? Answer: [Yes] Justification: Standard deviations are provided in Appendix. Guidelines: * The answer NA means that the paper does not include experiments. * The authors should answer "Yes" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. * The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions). * The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.) * The assumptions made should be given (e.g., Normally distributed errors). * It should be clear whether the error bar is the standard deviation or the standard error of the mean.

* It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis of Normality of errors is not verified.
* For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).
* If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text.
8. **Experiments Compute Resources** Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? Answer: [Yes] Justification: The information about the computer resources have been claimed in the appendix. Guidelines: * The answer NA means that the paper does not include experiments. * The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage. * The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute. * The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn't make it into the paper).
9. **Code Of Ethics** Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? Answer: [Yes] Justification: The research conform with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines. Guidelines: * The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics. * If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics. * The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction).
10. **Broader Impacts** Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? Answer: [Yes] Justification: This paper has discussed broader impacts in appendix. Guidelines: * The answer NA means that there is no societal impact of the work performed. * If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact. * Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.

* The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.
* The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.
* If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML).
11. **Safeguards** Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? Answer: [NA] Justification: This paper does not release models or real-world datasets, all the experiments are based on synthetic data and public datasets. Guidelines: * The answer NA means that the paper poses no such risks. * Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters. * Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images. * We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort.
12. **Licenses for existing assets** Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? Answer: [Yes] Justification: All the assets used in this paper are open-source materials and are properly credited. Guidelines: * The answer NA means that the paper does not use existing assets. * The authors should cite the original paper that produced the code package or dataset. * The authors should state which version of the asset is used and, if possible, include a URL. * The name of the license (e.g., CC-BY 4.0) should be included for each asset. * For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided. * If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.

* For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.
* If this information is not available online, the authors are encouraged to reach out to the asset's creators.
* **New Assets*
* Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? Answer: [NA] Justification: The paper does not release new assets. Guidelines:
* The answer NA means that the paper does not release new assets.
* Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.
* The paper should discuss whether and how consent was obtained from people whose asset is used.
* At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file.
* **Crowdsourcing and Research with Human Subjects*
* Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? Answer: [NA] Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines:
* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.
* According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector.
* **Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects*
* Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? Answer: [NA] Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines:
* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.
* We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.
* For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review.