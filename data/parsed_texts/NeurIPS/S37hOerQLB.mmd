# Self-Refine:

Iterative Refinement with Self-Feedback

 Aman Madaan\({}^{1}\), Niket Tandon\({}^{2}\), Prakhar Gupta\({}^{1}\), Skyler Hallinan\({}^{3}\), Luyu Gao\({}^{1}\),

**Sarah Wiegreffe\({}^{2}\), Uri Alon\({}^{1}\), Nouha Dziri\({}^{2}\), Shrimai Prabhumoye\({}^{4}\), Yiming Yang\({}^{1}\), Shashank Gupta\({}^{2}\), Bodhisattwa Prasad Majumder\({}^{5}\), Katherine Hermann\({}^{6}\), Sean Welleck\({}^{2,3}\), Amir Yazdanbakhsh\({}^{6}\), Peter Clark\({}^{2}\)**

\({}^{1}\)Language Technologies Institute, Carnegie Mellon University

\({}^{2}\)Allen Institute for Artificial Intelligence

\({}^{3}\)University of Washington \({}^{4}\)NVIDIA \({}^{5}\)UC San Diego \({}^{6}\)Google Deepmind

selfrefine@googlegroups.com

Now at Google DeepMind

###### Abstract

Like humans, large language models (llms) do not always generate the best output on their first try. Motivated by how humans refine their written text, we introduce Self-Refine, an approach for improving initial outputs from llms through iterative feedback and refinement. The main idea is to generate an initial output using an llm; then, the same llm provides _feedback_ for its output and uses it to _refine_ itself, iteratively. Self-Refine does not require any supervised training data, additional training, or reinforcement learning, and instead uses a single llm as the generator, refiner, and feedback provider. We evaluate Self-Refine across 7 diverse tasks, ranging from dialog response generation to mathematical reasoning, using state-of-the-art (gpt-3.5 and GPT-4) llms. Across all evaluated tasks, outputs generated with Self-Refine are preferred by humans and automatic metrics over those generated with the same llm using conventional one-step generation, improving by \(\sim\)20% absolute on average in task performance. Our work demonstrates that even state-of-the-art llms like GPT-4 can be further improved at test-time using our simple, standalone approach.2.

Footnote 2: Code and data at https://selfrefine.info/

## 1 Introduction

Although large language models (llms) can generate coherent outputs, they often fall short in addressing intricate requirements. This mostly includes tasks with multifaceted objectives, such as dialogue response generation, or tasks with hard-to-define goals, such as enhancing program readability. In these scenarios, modern llms may produce an intelligible initial output, yet may benefit from further iterative refinement--i.e., iteratively mapping a candidate output to an improved one--to ensure that the desired quality is achieved. Iterative refinement typically involves training a refinement model that relies on domain-specific data (e.g., Reid and Neubig (2022); Schick et al. (2022); Welleck et al. (2022)). Other approaches that rely on external supervision or reward models require large training sets or expensive human annotations (Madaan et al., 2021; Ouyang et al., 2022), which may not always be feasible to obtain. These limitations underscore the need for an effective refinement approach that can be applied to various tasks without requiring extensive supervision.

Iterative _self_-refinement is a fundamental characteristic of human problem-solving (Simon, 1962; Flower and Hayes, 1981; Amabile, 1983). Iterative self-refinement is a process that involves creating an initial draft and subsequently refining it based on self-provided feedback. For example, when

[MISSING_PAGE_FAIL:2]

For example, in Figure 2(d), the model generates functionally correct code for the given input. Here, \(p_{\text{gen}}\) is a task-specific few-shot prompt (or instruction) for an initial generation, and \(\|\) denotes concatenation. The few-shot prompt contains input-output pairs \(\langle x^{(k)},y^{(k)}\rangle\) for the task.3

Footnote 3: Few-shot prompting (also referred to as “in-context learning”) provides a model with a prompt consisting of \(k\) in-context examples of the target task, each in the form of input-output pairs \(\langle x_{i},y_{i}\rangle\)(Brown et al., 2020).

feedbackNext, Self-Refine uses the same model \(\mathcal{M}\) to provide feedback \(fb_{t}\) on its own output, given a task-specific prompt \(p_{\text{fb}}\) for generating feedback:

\[fb_{t}=\mathcal{M}\left(p_{\text{fb}}\|x\|y_{t}\right).\] (2)

Intuitively, the feedback may address multiple aspects of the output. For example, in code optimization, the feedback might address the efficiency, readability, and overall quality of the code.

Figure 3: The Self-Refine algorithm. See (§2) for a discussion of each component.

Figure 2: Examples of Self-Refine: an initial output generated by the base llm and then passed back to the _same_ llm to receive feedback to the _same_ llm to refine the output. The top row illustrates this for dialog generation where an initial dialogue response can be transformed into a more engaging one that also understands the user by applying feedback. The bottom row illustrates this for code optimization where the code is made more efficient by applying feedback.

Here, the prompt \(p_{\text{fb}}\) provides examples of feedback in the form of input-output-feedback triples \(\langle x^{(k)},y^{(k)},fb^{(k)}\rangle\). We prompt the model to write feedback that is actionable and specific via \(fb^{(k)}\). By 'actionable', we mean the feedback should contain a concrete action that would likely improve the output. By'specific', we mean the feedback should identify concrete phrases in the output to change. For example, the feedback in Figure 2(e) is _"This code is slow as it uses a for loop which is brute force. A better approach is to use the formula... (n(n+1))/2"_. This feedback is actionable, since it suggests the action 'use the formula...'. The feedback is specific since it mentions the 'for loop'.

refineNext, Self-Refine uses \(\mathcal{M}\) to refine its most recent output, given its own feedback:

\[y_{t+1}=\mathcal{M}\left(p_{\text{refine}}\|x\|y_{t}\|fb_{t}\right).\] (3)

For example, in Figure 2(f), given the initial output and the generated feedback, the model generates a re-implementation that is shorter and runs much faster than the initial implementation. The prompt \(p_{\text{refine}}\) provides examples of improving the output based on the feedback, in the form of input-output-feedback-refined quadruples \(\langle x^{(k)},y_{t}^{(k)},fb_{t}^{(k)},y_{t+1}^{(k)}\rangle\).

Iterating Self-Refine Self-Refine alternates between feedback and refine steps until a stopping condition is met. The stopping condition \(\operatorname{stop}(fb_{t},t)\) either stops at a specified timestep \(t\), or extracts a stopping indicator (e.g. a scalar stop score) from the feedback. In practice, the model can be prompted to generate a stopping indicator in \(p_{\text{fb}}\), and the condition is determined per-task.

To inform the model about the previous iterations, we retain the history of previous feedback and outputs by appending them to the prompt. Intuitively, this allows the model to learn from past mistakes and avoid repeating them. More precisely, Equation (3) is in fact instantiated as:

\[y_{t+1}=\mathcal{M}\left(p_{\text{refine}}\|x\|y_{0}\|fb_{0}\|...\|y_{t}\|fb_{ t}\right).\] (4)

Finally, we use the last refinement \(y_{t}\) as the output of Self-Refine.

Algorithm 1 summarizes Self-Refine, and Figure 2 shows an example of Self-Refine in the Dialogue Response Generation (Mehri and Eskenazi, 2020) and Code Optimization (Madaan et al., 2023) tasks. Appendix V provides examples of the \(p_{\text{gen}}\), \(p_{\text{fb}}\), \(p_{\text{refine}}\) prompts for various tasks. The key idea is that Self-Refine uses the same underlying llm to generate, get feedback, and refine its outputs given its own feedback. It relies only on supervision present in the few-shot examples.

## 3 Evaluation

We evaluate Self-Refine on 7 diverse tasks: Dialogue Response Generation (Appendix P; Mehri and Eskenazi, 2020), Code Optimization (Appendix Q; Madaan et al., 2023), Code Readability Improvement (Appendix O; Puri et al., 2021), Math Reasoning (Appendix R; Cobbe et al., 2021), Sentiment Reversal (Appendix S; Zhang et al., 2015), and we introduce two new tasks: Aeronym Generation (Appendix T) and Constrained Generation (a harder version of Lin et al. (2020) with 20-30 keyword constraints instead of 3-5; Appendix U)

Examples for all tasks and dataset statistics are provided in Table 4 (Appendix A).

### Instantiating Self-Refine

We instantiate Self-Refine following the high-level description in Section 2. The feedback-refine iterations continue until the desired output quality or task-specific criterion is reached, up to a maximum of 4 iterations. To make our evaluation consistent across different models, we implemented both feedback and refine as few-shot prompts even with models that respond well to instructions, such as chatgpt and gpt-4.

Base LLMsOur main goal is to evaluate whether we can improve the performance of any strong base LLMs using Self-Refine. Therefore, we compare Self-Refine to the same base LLMs but without feedback-refine iterations. We used three main strong base LLM across all tasks: gpt-3.5 (text-davinci-003), chatgpt (gpt-3.5-turbo), and gpt-4 (OpenAI, 2023). For code-based tasks, we also experimented with CodEx (code-davinci-002). In all tasks, either gpt-3.5 or gpt-4 is the previous state-of-the-art.4 We used the same prompts from previous work when available (such as for Code Optimization and Math Reasoning); otherwise, we created prompts as detailed in Appendix V. We generate samples using a temperature of 0.7.

### Metrics

We report three types of metrics:

* Task specific metric: When available, we use automated metrics from prior work (Math Reasoning: % solve rate; Code Optimization: % programs optimized%).
* gpt-4-pref: In addition to human-pref, we use gpt-4 as a proxy for human preference following prior work (Fu et al., 2023; Chiang et al., 2023; Geng et al., 2023; Sun et al., 2023), and found high correlation (82% for Sentiment Reversal, 68% for Acronym Generation, and 71% for Dialogue Response Generation) with human-pref. For Code Readability Improvement, we prompt gpt-4 to calculate fraction of the variables that are appropriately named given the context (e.g., x = [] \(\rightarrow\) input_buffer = []). Additional details are provided in Appendix F. For constrained generation, we combine automated evaluation to quantify concept coverage and gpt-4-pref to ensure the commonsense correctness of generated sentences. A sentence is only deemed a winner if it maintains validity in commonsense reasoning and has greater coverage in terms of concepts.
* Human evaluation: In Dialogue Response Generation, Code Readability Improvement, Sentiment Reversal, and Acronym Generation, we additionally perform a blind human A/B evaluation on a subset of the outputs to select the preferred output. Additional details are provided in Appendix C.

### Results

Table 1 shows our main results:

**Self-Refine consistently improves over base models** across all model sizes, and additionally outperforms the previous state-of-the-art across all tasks. For example, gpt-4+Self-Refine improves over the base gpt-4 by 8.7% (absolute) in Code Optimization, increasing optimization percentage from 27.3% to 36.0%. Confidence intervals are provided in Appendix M. For code-based tasks, we found similar trends when using Codex; those results are included in Appendix H.

One of the tasks in which we observe the highest gains compared to the base models is Constrained Generation, where the model is asked to generate a sentence containing up to 30 given concepts. We believe that this task benefits significantly from Self-Refine because there are more opportunities to miss some of the concepts on the first attempt, and thus Self-Refine allows the model to fix these mistakes subsequently. Further, this task has an extremely large number of reasonable outputs, and thus Self-Refine allows to better explore the space of possible outputs.

In preference-based tasks such as Dialogue Response Generation, Sentiment Reversal, and Acronym Generation, Self-Refine leads to especially high gains. For example in Dialogue Response Generation, gpt-4 preference score improve by 49.2% - from 25.4% to 74.6%. Similarly, we see remarkable improvements in the other preference-based tasks across all models.

\begin{table}
\begin{tabular}{l c c c c c} \hline \hline  & \multicolumn{2}{c}{gpt-3.5} & \multicolumn{2}{c}{chatgpt} & \multicolumn{2}{c}{gpt-4} \\ \cline{2-6} Task & Base & +Self-Refine & Base & +Self-Refine & Base & +Self-Refine \\ \hline Sentiment Reversal & 8.8 & **30.4** (\(\uparrow\)21.6) & 11.4 & **43.2** (\(\uparrow\)31.8) & 3.8 & **36.2** (\(\uparrow\)32.4) \\ Dialogue Response & 36.4 & **63.6** (\(\uparrow\)27.2) & 40.1 & **59.9** (\(\uparrow\)19.8) & 25.4 & **74.6** (\(\uparrow\)49.2) \\ Code Optimization & 14.8 & **23.0** (\(\uparrow\)8.2) & 23.9 & **27.5** (\(\uparrow\)3.6) & 27.3 & **36.0** (\(\uparrow\)8.7) \\ Code Readability & 37.4 & **51.3** (\(\uparrow\)13.9) & 27.7 & **63.1** (\(\uparrow\)35.4) & 27.4 & **56.2** (\(\uparrow\)28.8) \\ Math Reasoning & **64.1** & **64.1** (\(\uparrow\)0.7) & 74.8 & **75.0** (\(\uparrow\)0.2) & 92.9 & **93.1** (\(\uparrow\)0.2) \\ Acronym Generation & 41.6 & **56.4** (\(\uparrow\)14.8) & 27.2 & **37.2** (\(\uparrow\)10.0) & 30.4 & **56.0** (\(\uparrow\)25.6) \\ Constrained Generation & 16.0 & **39.7** (\(\uparrow\)23.7) & 2.75 & **33.5** (\(\uparrow\)30.7) & 4.4 & **61.3** (\(\uparrow\)56.9) \\ \hline \hline \end{tabular}
\end{table}
Table 1: Self-Refine results on various tasks using gpt-3.5, chatgpt, and gpt-4 as base LLM. Self-Refine consistently improves llM. Metrics used for these tasks are defined in Section 3.2.

The modest performance gains in Math Reasoning can be traced back to the inability to accurately identify whether there is any error. In math, errors can be nuanced and sometimes limited to a single line or incorrect operation. Besides, a consistent-looking reasoning chain can deceive llms to think that "everything looks good" (e.g., chatgpt feedback for 94% instances is 'everything looks good'). In Appendix K.1, we show that the gains with Self-Refine on Math Reasoning are much bigger (5%+) if an external source can identify if the current math answer is incorrect. Although Self-Refine demonstrates limited efficacy in Math Reasoning, we observe gains with Self-Refine in a subset of Big-Bench Hard (Suzgun et al., 2022) tasks that typically require a combination of commonsense reasoning and logic, such as date reasoning (Appendix D). This suggests that Self-Refine may be more effective in scenarios where the interplay of logical analysis and knowledge acquired through pre-training facilitates self-verification.

Improvement is consistent across base llms sizesGenerally, gpt-4+Self-Refine performs better than gpt-3.5+Self-Refine and chatgpt+Self-Refine across all tasks, even in tasks where the initial base results of gpt-4 were lower than gpt-3.5 or chatgpt. We thus believe that Self-Refine allows stronger models (such as gpt-4) to unlock their full potential, even in cases where this potential is not expressed in the standard, single-pass, output generation. Comparison to additional strong baselines is provided in Appendix H.

## 4 Analysis

The three main steps of Self-Refine are feedback, refine, and repeating them iteratively. In this section, we perform additional experiments to analyze the importance of each of these steps.

The impact of the feedback qualityFeedback quality plays a crucial role in Self-Refine. To quantify its impact, we compare Self-Refine, which utilizes specific, actionable feedback, with two ablations: one using generic feedback and another without feedback (the model may still iteratively refine its generations, but is not explicitly provided feedback to do so). For example, in the Code Optimization task: actionable feedback, such as _Avoid repeated calculations in the for loop_, pinpoints an issue and suggests a clear improvement. Generic feedback, like _Improve the efficiency of the code_, lacks this precision and direction. Table 2 shows feedback's clear influence.

In Code Optimization, performance slightly dips from 27.5 (Self-Refine feedback) to 26.0 (generic feedback), and further to 24.8 (no feedback). This suggests that while generic feedback offers some guidance - specific, actionable feedback yields superior results.

This effect is more pronounced in tasks like Sentiment Reversal, where changing from our feedback to generic feedback leads to a significant performance drop (43.2 to 31.2), and the task fails without feedback. In the "No feedback" setting, the model was not given clear instructions on changing the output. We find that the model tends to either repeat the same output in each iteration or to make unrelated changes. Since the scores in this task are the relative improvement increase in human preference, a score of 0 means that "No feedback" did not improve over the base model outputs. Similarly, in Acronym Generation, without actionable feedback, performance drops from 56.4 to 48.0, even with iterative refinements. These results highlight the importance of specific, actionable feedback in our approach. Even generic feedback provides some benefit, but the best results are achieved with targeted, constructive feedback.

How important are the multiple iterations of feedback-refine?Figure 4 demonstrates that on average, the quality of the output improves as the number of iterations increases. For instance, in

\begin{table}
\begin{tabular}{l c c c} \hline \hline Task & Self-Refine feedback & Generic feedback & No feedback \\ \hline Code Optimization & **27.5** & 26.0 & 24.8 \\ Sentiment Reversal & **43.2** & 31.2 & 0 \\ Acronym Generation & **56.4** & 54.0 & 48.0 \\ \hline \hline \end{tabular}
\end{table}
Table 2: Prompting to generate generic feedback (or having the model generate no feedback at all) leads to reduced scores, indicating the importance of the feedback step of Self-Refine. These experiments were performed with chatgpt (Code Optimization and Sentiment Reversal) and gpt-3.5 (Acronym Generation), and metrics used are defined in Section 3.2.

the Code Optimization task, the initial output (\(y_{0}\)) has a score of 22.0, which improves to 28.8 after three iterations (\(y_{3}\)). Similarly, in the Sentiment Reversal task, the initial output has a score of 33.9, which increases to 36.8 after three iterations. This trend of improvement is also evident in Constrained Generation, where the score increases from 26.1 to 46.1 after three iterations. Figure 4 highlights the diminishing returns in the improvement as the number of iterations increases. Overall, having multiple feedback-refine iterations significantly enhances the quality of the output, although the marginal improvement naturally decreases with more iterations.

The performance may not always monotonically increase with iterations: in multi-aspect feedback tasks like Acronym Generation, where the output quality can vary during iteration with improvement

Figure 4: **Left**: Iteration-wise score improvements. Early iterations significantly improve output quality, and scores generally keep improving with more iterations. **Right**: Self-Refine Performance improvements with iterations. Most gains(\(\Delta\)) are in the initial iterations for both Code Opt. and Sentiment Reversal. The numbers are averaged over chatgpt, gpt-3.5, and gpt-4. Task abbreviations: C. Opt. (Code Optimization), S. Rev. (Sentiment Reversal), C. Gen. (Constrained Generation).

Figure 5: Comparison of code generated by Madaan et al. (2023) (left) and the output after applying Self-Refine (right). The initial code by the baseline, which is nearly identical to the slower input program, fails to improve the efficiency and merely alters the logic for reading input. Self-Refine first generates feedback that diagnoses that _This code is slow because it is using six nested loops to iterate through all possible combinations of coins to pay the amount,_ and suggests that _a more efficient approach would be..._. Self-Refine then uses this feedback to generate the revised code (right), reducing the time complexity to \(\mathcal{O}(amount*coins)\). The full example is provided in Appendix K

in one aspect but decline in another aspect. To counter this, Self-Refine generates numerical scores for different quality aspects, leading to a balanced evaluation and appropriate output selection.

Can we just generate multiple outputs instead of refining?Does Self-Refine improve because of the iterative refinement, or just because it generates _more_ outputs? We compare Self-Refine with chatgpt, when chatgpt generates \(k=4\) samples (but without feedback and refinement). Then, we compare the performance of Self-Refine against these \(k\) initial outputs in a 1 vs. \(k\) evaluation. In other words, we assess whether Self-Refine can outperform _all_\(k\) initial outputs. The results of this experiment are illustrated in Figure 7 (Appendix K). Despite the increased difficulty of the 1 vs. \(k\) setting, the outputs of Self-Refine are still preferred by humans over _all_\(k\) initial outputs. This shows the importance of refinement according to feedback over the alternative of just generating multiple initial outputs.

Does Self-Refine works in an instruction only setup?In our main experiments, we use few-shot prompting to guide model output into a more readily parseable format. Next, we experiment with Self-Refine under a zero-shot prompting scenario, where traditional few-shot examples are supplanted by explicit instructions at each stage of the Self-Refine process. For these experiments, we use chatgpt. The results (Appendix E in Table 8) show that Self-Refine remains effective across diverse tasks, even in the absence of example prompts. Notably, in tasks such as Acronym Generation and Sentiment Reversal, Self-Refine, under zero-shot prompting, enhances performance from 16.6% to 44.8% and 4.4% to 71.4%, respectively. However, achieving optimal performance in this setting requires extensive prompt engineering for instructions.

For Math Reasoning tasks, Self-Refine improves the solve rate from 22.1% to 59.0% in an instruction-only setting. We find that much of this gain comes from fixing omitted return statements in 71% of the initial Python programs, despite clear instructions to include them. Subsequent iterations of feedback generation and refinement address this issue effectively, decreasing the error rate by 19%. Further, we find that when the initial programs are valid, Self-Refine does not improve the performance.

Does Self-Refine work with weaker models?The experiments in Section 3.3 were performed with some of the strongest available models; does Self-Refine work with smaller or weaker models as well? To investigate this, we instantiated Self-Refine with Vicuna-13B (Chiang et al., 2023), a less powerful base model. While Vicuna-13B is capable of generating initial outputs, it struggles significantly with the refinement process. Specifically, Vicuna-13B was not able to consistently generate the feedback in the required format. Furthermore, even when provided with Oracle or hard-coded feedback, it often failed to adhere to the prompts for refinement. Instead of refining its output, Vicuna-13B either repeated the same output or generated a hallucinated conversation, rendering the outputs less effective. Example output and analysis is provided in Appendix I.

How does Self-Refine perform with strong open access models like llama2-70b?We conduct additional experiments using Self-Refine on LLama-2 (Touvron et al., 2023), a state-of-the-art, open-access language model on Acronym Generation, Sentiment Reversal, Dialogue Response Generation, and Math Reasoning. Consistent with our primary findings, Self-Refine shows an improvement across all these tasks relative to the base model. The full results are shown in Appendix J. These promising results with llama2-70b suggest that the applicability of Self-Refine might extend to a wide array of increasingly powerful open-source models in the future

Qualitative AnalysisWe conduct a qualitative analysis of the feedback generated by Self-Refine and its subsequent refinements. We manually analyze 70 samples in total (35 success cases and 35 failure cases) for Code Optimization (Madaan et al., 2023) and Math Reasoning (Cobbe et al., 2021). For both Math Reasoning and Code Optimization, we found that the feedback was predominantly actionable, with the majority identifying problematic aspects of the original generation and suggesting ways to rectify them.

When Self-Refine failed to improve the original generation, the majority of issues were due to erroneous feedback rather than faulty refinements. Specifically, 33% of unsuccessful cases were due to feedback inaccurately pinpointing the error's location, while 61% were a result of feedback suggesting an inappropriate fix. Only 6% of failures were due to the refiner incorrectly implementing good feedback. These observations highlight the vital role of accurate feedback plays in Self-Refine.

In successful cases, the refiner was guided by accurate and useful feedback to make precise fixes to the original generation in 61% of the cases. Interestingly, the refiner was capable of rectifying issues even when the feedback was partially incorrect, which was the situation in 33% of successful cases. This suggests resilience to sub-optimal feedback. Future research could focus on examining the refiner's robustness to various types of feedback errors and exploring ways to enhance this resilience. In Figure 5, we illustrate how Self-Refine significantly improves program efficiency by transforming a brute force approach into a dynamic programming solution, as a result of insightful feedback. Additional analysis on other datasets such as Dialogue Response Generation is provided in Appendix K.

Going Beyond BenchmarksWhile our evaluation focuses on benchmark tasks, Self-Refine is designed with broader applicability in mind. We explore this in a real-world use case of website generation, where the user provides a high-level goal and Self-Refine assists in iteratively developing the website. Starting from a rudimentary initial design, Self-Refine refines HTML, CSS, and JS to evolve the website in terms of both usability and aesthetics. This demonstrates the potential of Self-Refine in real-world, complex, and creative tasks. See Appendix L for examples and further discussion, including broader, societal impact of our work.

## 5 Related work

Leveraging human- and machine-generated natural language (NL) feedback for refining outputs has been effective for a variety of tasks, including summarization (Scheurer et al., 2022), script generation (Tandon et al., 2021), program synthesis (Le et al., 2022; Yasunaga and Liang, 2020), and other tasks (Madaan et al., 2022; Bai et al., 2022; Schick et al., 2022; Saunders et al., 2022; Bai et al., 2022; Welleck et al., 2022). Refinement methods differ in the source and format of feedback, and the way that a refiner is obtained. Table 3 summarizes some related approaches; see Appendix B for an additional discussion.

Source of feedback.Humans have been an effective source of feedback (Tandon et al., 2021; Elgohary et al., 2021; Tandon et al., 2022; Bai et al., 2022). Since human feedback is costly, several approaches use a scalar reward function as a surrogate of (or alternative to) human feedback (e.g., (Bai et al., 2022; Liu et al., 2022; Lu et al., 2022; Le et al., 2022; Welleck et al., 2022)). Alternative sources such as compilers (Yasunaga and Liang, 2020) or Wikipedia edits (Schick et al., 2022) can provide domain-specific feedback. Recently, LLMs have been used to generate feedback for general domains (Fu et al., 2023; Peng et al., 2023; Yang et al., 2022), However, ours is the only method that generates feedback using an llm on its _own_ output, for the purpose of refining with the same llm.

Representation of feedback.The form of feedback can be generally divided into natural language (NL) and non-NL feedback. Non-NL feedback can come in human-provided example pairs (Dasupta et al., 2019) or scalar rewards (Liu et al., 2022; Le et al., 2022). In this work, we use NL feedback, since this allows the model to easily provide _self_-feedback using the same LM that generated the output, while leveraging existing pretrained LLMs such as GPT-4.

Types of refiners.Pairs of feedback and refinement have been used to learn supervised refiners (Schick et al., 2022; Du et al., 2022; Yasunaga and Liang, 2020; Madaan et al., 2021). Since

\begin{table}
\begin{tabular}{p{113.8pt} p{113.8pt} p{113.8pt} p{113.8pt}} \hline \hline  & Supervision-free refiner & Supervision-free feedback & Multi-aspect feedback & Iterative feedback \\ \hline
**Learned refiners**: PEER (Schick et al., 2022), Self-critique (Saunders et al., 2022), CodeRL (Le et al., 2022), Self-correction (Welleck et al., 2022). & \(\bigtimes\) or \(\bigtimes\) & \(\bigtimes\) or \(\bigtimes\) \\ \hline
**Prompted refiners**: Augmenter (Peng et al., 2023), Re\({}^{3}\)(Yang et al., 2022), Reflexion (Shinn et al., 2023). & \(\bigtimes\) & \(\bigtimes\) & \(\bigtimes\) \\ \hline
**Self-Refine** (this work) & \(\bigtimes\) & \(\bigtimes\) & \(\bigtimes\) & \(\bigtimes\) \\ \hline \hline \end{tabular}
\end{table}
Table 3: A comparison of Self-Refine to closely related prior refinement approaches.

gathering supervised data is costly, some methods learn refiners using model generations (Welleck et al., 2022; Peng et al., 2023). However, the refiners are trained for each new domain. Finally, (Yang et al., 2022) use prompted feedback and refinement specifically tailored for story generation. In this work, we avoid training a separate refiner, and show that the same model can be used as both the refiner and the source of feedback across multiple domains.

Non-refinement reinforcement learning (RL) approaches.Rather than having explicit refinement, an alternative way to incorporate feedback is by optimizing a scalar reward function, e.g. with reinforcement learning (e.g., Stiennon et al. (2020); Lu et al. (2022); Le et al. (2022)). These methods differ from Self-Refine in that the model does not access feedback on an intermediate generation. Second, these RL methods require updating the model's parameters, unlike Self-Refine. Recently, in discrete-space simulated environments, LLMs have also been shown to iteratively shape and refine rewards and policies, thereby performing RL tasks without expert demonstrations or gradients (Kim et al., 2023; Brooks et al., 2023). While we focus on real-world code and language tasks in this paper, it would be interesting to explore applications of self-refine in simulated environments.

## 6 Limitations and Discussion

The main limitation of our approach is that the base models need to have sufficient few-shot modeling or instruction-following abilities, in order to learn to provide feedback and to refine in an in-context fashion, without having to train supervised models and rely on supervised data.

Further, the experiments in this work were primarily performed with language models that are not open-sourced, namely gpt-3.5, chatgpt, gpt-4, and Codex. Existing literature (Ouyang et al., 2022) does not fully describe the details of these models, such as the pretraining corpus, model sizes, and model biases. Nonetheless, we release our code and model outputs to ensure the reproducibility of our work. In addition, initial results from our experiments with the open-access llama2-70b language model are promising, reinforcing the notion that Self-Refine has the potential to be widely applicable, even as open-source models continue to evolve and improve.

Another limitation of our work is that we exclusively experiment with datasets in English. In other languages, the current models may not provide the same benefits. Finally, there is a possibility for bad actors to use prompting techniques to steer a model to generate more toxic or harmful text. Our approach does not explicitly guard against this.

## 7 Conclusion

We present Self-Refine: a novel approach that allows large language models to iteratively provide self-feedback and refine their own outputs. Self-Refine operates within a single llm, requiring neither additional training data nor reinforcement learning. We demonstrate the simplicity and ease of use Self-Refine across a wide variety of tasks. By showcasing the potential of Self-Refine in diverse tasks, our research contributes to the ongoing exploration and development of large language models, with the aim of reducing the cost of human creative processes in real-world settings. We hope that our iterative approach will help drive further research in this area. To this end, we make all our code, data and prompts available at https://selfrefine.info/.

## Acknowledgements

We thank the anonymous reviewers for their useful comments and suggestions, and extend our thanks to James Laudon, Cliff Young, Graham Neubig, Daniel Fried, Rif A. Saurous, and the Google DeepMind team for their valuable feedback and comments. This material is partly based on research sponsored in part by the Air Force Research Laboratory (agreement number FA8750-19-2-0200). The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of DARPA or the U.S. Government.

## References

* M. Amabile (1983)A Theoretical Framework. In The Social Psychology of Creativity, pp. 65-96. Cited by: SS1.
* Y. Bai, A. Jones, K. Ndousse, A. Askell, A. Chen, N. DasSarma, D. Drain, S. Fort, D. Ganguli, T. Henighan, et al. (2022)Training a helpful and harmless assistant with reinforcement learning from human feedback. ArXiv:2204.05862. Cited by: SS1.
* Y. Bai, S. Kadavath, S. Kundu, A. Askell, J. Kernion, A. Jones, A. Chen, A. Goldie, A. Mirhoseini, C. McKinnon, et al. (2022)Constitutional ai: harmlessness from ai feedback. arXiv preprint arXiv:2212.08073. Cited by: SS1.
* E. D. Berger, S. Stern, and J. Altmayer Pizzorno (2022)Triangulating Python performance issues with scalense. ArXiv preprintabs/2212.07597. Cited by: SS1.
* E. Brooks, L. Walls, R. L. Lewis, and S. Singh (2023)Large language models can implement policy iteration. Cited by: SS1.
* L. D. Brown, T. T. Cai, and A. DasGupta (2001)Interval estimation for a binomial proportion. Statistical science16 (2), pp. 101-133. Cited by: SS1.
* T. Brown, B. Mann, N. Ryder, M. Subbiah, J. D Kaplan, P. Dhariwal, A. Neelakantan, P. Shyam, G. Sastry, A. Askell, S. Agarwal, A. Herbert-Voss, G. Krueger, T. Henighan, R. Child, A. Ramesh, D. Ziegler, J. Wu, C. Winter, C. Hesse, M. Chen, E. Sigler, M. Litwin, S. Gray, B. Chess, J. Clark, C. Berner, S. McCandlish, A. Radford, I. Sutskever, and D. Amodei (2020)Language models are few-shot learners. In Advances in Neural Information Processing Systems, Vol. 33, pp. 1877-1901. Cited by: SS1.
* M. Chen, J. Tworek, H. Jun, Q. Yuan, H. Ponde de Oliveira Pinto, J. Kaplan, H. Edwards, Y. Burda, N. Joseph, G. Brockman, A. Ray, R. Puri, G. Krueger, M. Petrov, H. Khlaaf, G. Sastry, P. Mishkin, B. Chan, S. Gray, N. Ryder, M. Pavlov, A. Power, L. Kaiser, M. Bavarian, C. Winter, P. Tiltel, F. Petroski Such, D. Cummings, M. Plappert, F. Chantzis, E. Barnes, A. Herbert-Voss, W. Hebgen Guss, A. Nichol, A. Paino, N. Tezak, J. Tang, Igor Babuschkin, S. Balaji, S. Jain, W. Saunders, C. Hesse, A. N. Carr, J. Leike, J. Achiam, V. Misra, E. Morikawa, A. Radford, M. Knight, M. Brundage, M. Murati, K. Mayer, P. Welinder, B. McGrew, D. Amodei, S. McCandlish, I. Sutskever, and W. Zaremba (2021)Evaluating large language models trained on code. arXiv preprint arXiv:2107.03374. Cited by: SS1.
* W. Chiang, Z. Li, Z. Lin, Y. Sheng, Z. Wu, H. Zhang, L. Zheng, S. Zhuang, Y. Zhuang, J. E. Gonzalez, et al. (2023)Vicuna: an open-source chatbot impressing gpt-4 with 90%* chatgpt quality. Cited by: SS1.
* K. Cobbe, V. Kosaraju, M. Bavarian, M. Chen, H. Jun, L. Kaiser, M. Plappert, J. Tworek, J. Hilton, R. Nakano, et al. (2021)Training verifiers to solve math word problems. arXiv preprint arXiv:2110.14168. Cited by: SS1.
* S. Dasgupta, D. Hsu, S. Poulis, and X. Zhu (2019)Teaching a black-box learner. In Proceedings of the 36th International Conference on Machine Learning, ICML 2019, 9-15 June 2019, Long Beach, California, USA, pp. 1547-1555. Cited by: SS1.
* W. Du, Z. Myung Kim, V. Raheja, D. Kumar, and D. Kang (2022)Read, revise, repeat: a system demonstration for human-in-the-loop iterative text revision. In Proceedings of the First Workshop on Intelligent and Interactive Writing Assistants (In2Writing 2022), pp. 96-108. Cited by: SS1.
* A. Elgohary, C. Meek, M. Richardson, A. Fourney, G. Ramos, and A. Hassan Awadallah (2021)NL-edit: correcting semantic parse errors through natural language interaction. In Proceedings of the 2021 Conference of the North American Chapter of theAssociation for Computational Linguistics: Human Language Technologies_, pages 5599-5610, Online. Association for Computational Linguistics.
* Flower and Hayes (1981) Linda Flower and John R Hayes. 1981. A cognitive process theory of writing. _College composition and communication_, 32(4):365-387.
* Fu et al. (2023) Jinlan Fu, See-Kiong Ng, Zhengbao Jiang, and Pengfei Liu. 2023. Gptscore: Evaluate as you desire. _arXiv preprint arXiv:2302.04166_.
* Gao et al. (2022) Luyu Gao, Aman Madaan, Shuyan Zhou, Uri Alon, Pengfei Liu, Yiming Yang, Jamie Callan, and Graham Neubig. 2022. Pal: Program-aided language models. _arXiv preprint arXiv:2211.10435_.
* Geng et al. (2023) Xinyang Geng, Arnav Gudibande, Hao Liu, Eric Wallace, Pieter Abbeel, Sergey Levine, and Dawn Song. 2023. Koala: A dialogue model for academic research. Blog post.
* Kim et al. (2023) Geunwoo Kim, Pierre Baldi, and Stephen McAleer. 2023. Language models can solve computer tasks. _arXiv preprint arXiv:2303.17491_.
* Le et al. (2022a) Hung Le, Yue Wang, Akhilesh Deepak Gotmare, Silvio Savarese, and Steven C. H. Hoi. 2022a. CodeRL: Mastering Code Generation through Pretrained Models and Deep Reinforcement Learning.
* Le et al. (2022b) Hung Le, Yue Wang, Akhilesh Deepak Gotmare, Silvio Savarese, and Steven C. H. Hoi. 2022b. Coderl: Mastering code generation through pretrained models and deep reinforcement learning. _ArXiv_, abs/2207.01780.
* Li et al. (2018) Juncen Li, Robin Jia, He He, and Percy Liang. 2018. Delete, retrieve, generate: a simple approach to sentiment and style transfer. In _Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long Papers)_, pages 1865-1874, New Orleans, Louisiana. Association for Computational Linguistics.
* Lin et al. (2020) Bill Yuchen Lin, Wangchunshu Zhou, Ming Shen, Pei Zhou, Chandra Bhagavatula, Yejin Choi, and Xiang Ren. 2020. CommonGen: A constrained text generation challenge for generative commonsense reasoning. In _Findings of the Association for Computational Linguistics: EMNLP 2020_, pages 1823-1840, Online. Association for Computational Linguistics.
* Liu et al. (2022) Jiacheng Liu, Skyler Hallinan, Ximing Lu, Pengfei He, Sean Welleck, Hannaneh Hajishirzi, and Yejin Choi. 2022. Rainier: Reinforced knowledge introspector for commonsense question answering. In _Conference on Empirical Methods in Natural Language Processing_.
* Lu et al. (2022) Ximing Lu, Sean Welleck, Liwei Jiang, Jack Hessel, Lianhui Qin, Peter West, Prithviraj Ammanabrolu, and Yejin Choi. 2022. Quark: Controllable text generation with reinforced unlearning. _ArXiv_, abs/2205.13636.
* Madaan et al. (2023) Aman Madaan, Alexander Shypula, Uri Alon, Milad Hashemi, Parthasarathy Ranganathan, Yiming Yang, Graham Neubig, and Amir Yazdanbakhsh. 2023. Learning performance-improving code edits. _arXiv preprint arXiv:2302.07867_.
* Madaan et al. (2022) Aman Madaan, Niket Tandon, Peter Clark, and Yiming Yang. 2022. Memory-assisted prompt editing to improve gpt-3 after deployment. In _Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing_, pages 2833-2861.
* Madaan et al. (2021) Aman Madaan, Niket Tandon, Dheeraj Rajagopal, Peter Clark, Yiming Yang, and Eduard Hovy. 2021. Think about it! improving defeasible reasoning by first modeling the question scenario. In _Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing_, pages 6291-6310, Online and Punta Cana, Dominican Republic. Association for Computational Linguistics.
* Mehri and Eskenazi (2020) Shikib Mehri and Maxine Eskenazi. 2020. Unsupervised evaluation of interactive dialog with DialoGPT. In _Proceedings of the 21th Annual Meeting of the Special Interest Group on Discourse and Dialogue_, pages 225-235, 1st virtual meeting. Association for Computational Linguistics.
* Nijkamp et al. (2022) Erik Nijkamp, Bo Pang, Hiroaki Hayashi, Liffu Tu, Huan Wang, Yingbo Zhou, Silvio Savarese, and Caiming Xiong. 2022. Codegen: An open large language model for code with multi-turn program synthesis. _ArXiv preprint_, abs/2203.13474.
* Nijkamp et al. (2020)OpenAI. Model index for researchers. https://platform.openai.com/docs/model-index-for-researchers. Accessed: May 14, 2023.
* OpenAI (2022) OpenAI. 2022. Model index for researchers. Blogpost.
* OpenAI (2023) OpenAI. 2023. Gpt-4 technical report.
* Ouyang et al. (2022) Long Ouyang, Jeff Wu, Xu Jiang, Diogo Almeida, Carroll L. Wainwright, Pamela Mishkin, Chong Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, John Schulman, Jacob Hilton, Fraser Kelton, Luke E. Miller, Maddie Simens, Amanda Askell, Peter Welinder, Paul Francis Christiano, Jan Leike, and Ryan J. Lowe. 2022. Training language models to follow instructions with human feedback. ArXiv:2203.02155.
* Peng et al. (2023) Baolin Peng, Michel Galley, Pengcheng He, Hao Cheng, Yujia Xie, Yu Hu, Qiuyuan Huang, Lars Liden, Zhou Yu, Weizhu Chen, and Jianfeng Gao. 2023. Check Your Facts and Try Again: Improving Large Language Models with External Knowledge and Automated Feedback.
* Prabhumoye et al. (2018) Shrimai Prabhumoye, Yulia Tsvetkov, Ruslan Salakhutdinov, and Alan W Black. 2018. Style transfer through back-translation. In _Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)_, pages 866-876, Melbourne, Australia. Association for Computational Linguistics.
* Press et al. (2022) Ofir Press, Muru Zhang, Sewon Min, Ludwig Schmidt, Noah A Smith, and Mike Lewis. 2022. Measuring and narrowing the compositionality gap in language models. _arXiv preprint arXiv:2210.03350_.
* Puri et al. (2021) Ruchir Puri, David Kung, Geert Janssen, Wei Zhang, Giacomo Domeniconi, Vladimir Zolotov, Julian Dolby, Jie Chen, Mihir Choudhury, Lindsey Decker, Veronika Thost, Luca Buratti, Saurabh Pujar, Shyam Ramji, Ulrich Finkler, Susan Malaika, and Frederick Reiss. 2021. Codenet: A large-scale ai for code dataset for learning a diversity of coding tasks. _arXiv preprint arXiv:2105.12655_.
* Reid and Neubig (2022) Machel Reid and Graham Neubig. 2022. Learning to model editing processes. _arXiv preprint arXiv:2205.12374_.
* Saunders et al. (2022a) William Saunders, Catherine Yeh, Jeff Wu, Steven Bills, Long Ouyang, Jonathan Ward, and Jan Leike. 2022a. Self-critiquing models for assisting human evaluators.
* Saunders et al. (2022b) William Saunders, Catherine Yeh, Jeff Wu, Steven Bills, Long Ouyang, Jonathan Ward, and Jan Leike. 2022b. Self-critiquing models for assisting human evaluators. ArXiv:2206.05802.
* Scheurer et al. (2022) Jeremy Scheurer, Jon Ander Campos, Jun Shern Chan, Angelica Chen, Kyunghyun Cho, and Ethan Perez. 2022. Training language models with natural language feedback. ArXiv:2204.14146.
* Schick et al. (2022a) Timo Schick, Jane Dwivedi-Yu, Zhengbao Jiang, Fabio Petroni, Patrick Lewis, Gautier Izacard, Qingfei You, Christoforos Nalmpantis, Edouard Grave, and Sebastian Riedel. 2022a. Peer: A collaborative language model.
* Schick et al. (2022b) Timo Schick, Jane Dwivedi-Yu, Zhengbao Jiang, Fabio Petroni, Patrick Lewis, Gautier Izacard, Qingfei You, Christoforos Nalmpantis, Edouard Grave, and Sebastian Riedel. 2022b. Peer: A collaborative language model. _ArXiv_, abs/2208.11663.
* Shinn et al. (2023) Noah Shinn, Beck Labash, and Ashwin Gopinath. 2023. Reflexion: an autonomous agent with dynamic memory and self-reflection.
* Simon (1962) Herbert A. Simon. 1962. The architecture of complexity. _Proceedings of the American Philosophical Society_, 106(6):467-482.
* Stiennon et al. (2020) Nisan Stiennon, Long Ouyang, Jeffrey Wu, Daniel Ziegler, Ryan Lowe, Chelsea Voss, Alec Radford, Dario Amodei, and Paul F Christiano. 2020. Learning to summarize with human feedback. In _Advances in Neural Information Processing Systems_, volume 33, pages 3008-3021. Curran Associates, Inc.
* Sun et al. (2023) Zhiqing Sun, Yikang Shen, Qinhong Zhou, Hongxin Zhang, Zhenfang Chen, David Cox, Yiming Yang, and Chuang Gan. 2023. Principle-driven self-alignment of language models from scratch with minimal human supervision. _arXiv preprint arXiv:2305.03047_.
* Sun et al. (2023)Mirac Suzgun, Nathan Scales, Nathanael Scharli, Sebastian Gehrmann, Yi Tay, Hyung Won Chung, Aakanksha Chowdhery, Quoc V Le, Ed H Chi, Denny Zhou, et al. 2022. Challenging big-bench tasks and whether chain-of-thought can solve them. _arXiv preprint arXiv:2210.09261_.
* Tandon et al. (2021) Niket Tandon, Aman Madaan, Peter Clark, Keisuke Sakaguchi, and Yiming Yang. 2021. Interscript: A dataset for interactive learning of scripts through error feedback. _arXiv preprint arXiv:2112.07867_.
* Tandon et al. (2022) Niket Tandon, Aman Madaan, Peter Clark, and Yiming Yang. 2022. Learning to repair: Repairing model output errors after deployment using a dynamic memory of feedback. In _Findings of the Association for Computational Linguistics: NAACL 2022_, pages 339-352.
* Touvron et al. (2023) Hugo Touvron, Thibaut Lavril, Gautier Izacard, Xavier Martinet, Marie-Anne Lachaux, Timothee Lacroix, Baptiste Roziere, Naman Goyal, Eric Hambro, Faisal Azhar, et al. 2023. Llama: Open and efficient foundation language models. _arXiv preprint arXiv:2302.13971_.
* Wei et al. (2022) Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Ed Chi, Quoc Le, and Denny Zhou. 2022. Chain of Thought Prompting Elicits Reasoning in Large Language Models. _arXiv preprint arXiv:2201.11903_.
* Welleck et al. (2022) Sean Welleck, Ximing Lu, Peter West, Faeze Brahman, Tianxiao Shen, Daniel Khashabi, and Yejin Choi. 2022. Generating sequences by learning to self-correct. _arXiv preprint arXiv:2211.00053_.
* Yang et al. (2022) Kevin Yang, Nanyun Peng, Yuandong Tian, and Dan Klein. 2022. Re3: Generating longer stories with recursive reprompting and revision. In _Conference on Empirical Methods in Natural Language Processing_.
* Yasunaga and Liang (2020) Michihiro Yasunaga and Percy Liang. 2020. Graph-based, self-supervised program repair from diagnostic feedback. _37th Int. Conf. Mach. Learn. ICML 2020_, PartF168147-14:10730-10739.
* Zhang et al. (2015) Xiang Zhang, Junbo Zhao, and Yann LeCun. 2015. Character-level convolutional networks for text classification. _Advances in neural information processing systems_, 28.

Evaluation Tasks

Table 4 lists the tasks in our evaluation, and examples from each task.

\begin{table}
\begin{tabular}{l l} \hline \hline
**Task and Description** & **Sample one iteration of feedback-refine** \\ \hline
**Sentiment Reversal** & \(x\): The food was fantastic...” \\ Rewrite reviews to reverse sentiment. & \(y_{t}\): The food was disappointing...” \\ Dataset: (Zhang et al., 2015) 1000 review passages & \(fb\): Increase negative sentiment \\
**Dialogue Response Generation** & \(y_{t+1}\): The food was utterly terrible...” \\ Produce rich conversational responses. & \(x\): What’s the best way to cook pasta?” \\ Dataset: (Mehri and Eskenazi, 2020) 372 conv. & \(y_{t}\): The best way to cook pasta is to...” \\
**Code Optimization** & \(x\): Nested loop for matrix product \\ Enhance Python code efficiency & \(y_{t}\): NumPy dot product function \\ Dataset: (Madaan et al., 2023): 1000 programs & \(fb\): Improve time complexity \\
**Code Readability Improvement** & \(x\): Unclear variable names, no comments \\ Refactor Python code for readability. & \(y_{t}\): Descriptive names, comments \\ Dataset: (Puri et al., 2021) 300 programs\({}^{*}\) & \(fb\): Enhance variable naming; add comments \\
**Math Reasoning** & \(y_{t+1}\): Clear variables, meaningful comments \\ Solve math reasoning problems. & \(y_{t}\): Solution in Python \\ Dataset: (Cobbe et al., 2021) 1319 questions & \(fb\): Show step-by-step solution \\
**Acronym Generation** & \(y_{t+1}\): Solution with detailed explanation \\ Generate acronyms for a given title & \(x\) : Radio Detecting and Ranging” \\ Dataset: (Appendix T) 250 acronyms & \(y_{t}\): RDR \\
**Constrained Generation** & \(y_{t+1}\): RADAR” \\ Generate sentences with given keywords. & \(x\): beach, vacation, relaxation \\ Dataset: (Lin et al., 2020) 200 samples & \(y_{t}\): During our beach vacation... \\  & \(fb\): Include keywords; maintain coherence \\  & \(y_{t+1}\):.. beach vacation was filled with relaxation \\ \hline \hline \end{tabular}
\end{table}
Table 4: An overview of the tasks which we evaluate Self-Refine on, along with their associated datasets and sizes. For every task, we demonstrate a single iteration of refinement of input \(x\), the previously generated output \(y_{t}\), the feedback generated \(fb_{t}\), and the refinement \(y_{t+1}\). Few-shot prompts used for feedback and refine are provided in Appendix V.

[MISSING_PAGE_FAIL:16]

Human Evaluation

The A/B evaluation in our study was conducted by the authors, where a human judge was presented with an input, task instruction, and two candidate outputs generated by the baseline method and Self-Refine. The setup was blind, i.e., the judges did not know which outputs were generated by which method. The judge was then asked to select the output that is better aligned with the task instruction. For tasks that involve A/B evaluation, we calculate the relative improvement as the percentage increase in preference rate. The preference rate represents the proportion of times annotators selected the output produced by Self-Refine over the output from the baseline method. Table 6 shows the results.

While multiple annotators participated in each task, we only collected a single annotation per instance, aiming to scale the number of data points we could annotate. To further validate the reliability of our evaluations, we obtained two annotations for 50 samples from each dataset. All human evaluations were executed in a double-blind manner, with the responses being randomly flipped to ensure annotator impartiality, leaving them unaware of whether a given output was from the base model or the Self-Refine. These additional evaluations were exclusively applied to outputs generated by gpt-4.

For each task, we measured inter-labeler agreement using Cohen's Kappa score. Code Readability Improvement and Acronym Generation both scored a substantial 0.75, Sentiment Reversal was also substantial at 0.61, while Dialogue Response Generation was moderate with a score of 0.53.

\begin{table}
\begin{tabular}{l c c c} \hline \hline
**Task** & **Self-Refine (\%)** & **Direct (\%)** & **Either (\%)** \\ \hline Sentiment Reversal & 75.00 & 21.43 & 3.57 \\ Acronym Generation & 44.59 & 12.16 & 43.24 \\ Dialogue Response Generation & 47.58 & 19.66 & 32.76 \\ Code Readability Improvement & **50.0** & 3.0 & 47.0 \\ \hline \hline \end{tabular}
\end{table}
Table 6: Relative improvement of Self-Refine in A/B evaluations across different tasks. The values represent normalized preferences, which correspond to the proportion of times the output generated by Self-Refine was selected as better aligned with the task instruction over the baseline method. The evaluation was conducted for 150 examples for each dataset. The judges were not aware of the method that generated each sample.

Self-Refine on Reasoning Tasks

Self-Refine shows limited success in Math Reasoning tasks, mainly due to its challenges in generating meaningful feedback. Nonetheless, we observe performance gains with Self-Refine in certain tasks from the Big-Bench Hard suite (Suzgun et al., 2022), particularly those requiring commonsense reasoning and logical thinking. These results in Table 7 suggest that Self-Refine is more effective in scenarios where the combination of logical reasoning and pre-trained knowledge contribute to self-verification.

## Appendix E Instruction-Only Prompting

In our main experiments, we use few-shot prompting to guide model output into a more readily parseable format. Next, we experiment with Self-Refine under a zero-shot prompting scenario, where traditional few-shot examples are supplanted by explicit instructions at each stage of the Self-Refine process. For these experiments, we use chatgpt. The results in Table 8) show that Self-Refine remains effective across diverse tasks. However, achieving optimal performance in this setting requires extensive prompt engineering for instructions. The instructions are present in Listing 1 (Acronym Generation), Listing 3 (Math Reasoning), Listing 2 (Sentiment Reversal), Listing 4 (Constrained Generation), and Listing 5 (Dialogue Response Generation).

For Math Reasoning tasks, Self-Refine improves the solve rate from 22.1% to 59.0% in an instruction-only setting. We find that much of this gain comes from fixing omitted return statements in 71% of the initial Python programs, despite clear instructions to include them. Subsequent iterations of feedback generation and refinement address this issue effectively, decreasing the error rate by 19%. Further, we find that when the initial programs are valid, Self-Refine does not improve the performance.

## Appendix F GPT-4 Evaluation

In light of the impressive achievements of gpt-4 in assessing and providing reasoning for complex tasks, we leverage its abilities for evaluation in Self-Refine. The approach involves presenting tasks to gpt-4 in a structured manner, promoting the model's deliberation on the task and generating a rationale for its decision. To mitigate order bias in our tasks, we randomly flip the order of the outputs generated after the first iteration and by Self-Refine before evaluation. Further, to ensure

\begin{table}
\begin{tabular}{l c c c} \hline \hline Task & Base model & +Self-Refine & Gain \\ \hline Date Understanding & 62.0 & 66.8 & 4.8 \\ Geometric Shapes & 17.6 & 20.0 & 2.4 \\ Logical Deduction (seven objects) & 43.2 & 45.2 & 2.0 \\ Multi-Step Arithmetic & 61.6 & 64.0 & 2.4 \\ Tracking Shuffled Objects (seven objects) & 31.6 & 36.0 & 4.4 \\ \hline \hline \end{tabular}
\end{table}
Table 7: Performance comparison between the base outputs and the Self-Refine enhanced model across various Big Bench Hard tasks. All experiments were conducted using the gpt-3.5-turbo-0613 model with a temperature setting of 0.0. No task-specific prompts were utilized; all tasks employed the same instructional prompts.

\begin{table}
\begin{tabular}{l c c} \hline \hline Task & Base & Self-Refine (zero-shot) \\ \hline Acronym Generation & 16.6\% & 44.8\% (\(\uparrow 28.2\%\)) \\ Constrained Generation & 4.0\% & 47.0\% (\(\uparrow 43.0\%\)) \\ Sentiment Reversal & 4.4\% & 71.4\% (\(\uparrow 67.0\%\)) \\ Math Reasoning & 22.1\% & 59.0\% (\(\uparrow 36.9\%\)) \\ Dialogue Response Generation & 23.0\% & 48.8\% (\(\uparrow 25.8\%\)) \\ \hline \hline \end{tabular}
\end{table}
Table 8: Performance of Self-Refine with Zero-Shot Prompting

[MISSING_PAGE_FAIL:19]

that there is no inherent bias in gpt-4 picking its own predictions, we conduct an additional study with claude-v2.

Claude-2 as the EvaluatorDespite the measures we took to prevent any inherent biases, gpt-4 might inherently favor self-refined outputs. To provide a comprehensive evaluation of gpt-4, we conduct an additional analysis using claude-v2, 5 serving as an independent evaluator for gpt-4 outputs. The results in Table 9 from gpt-4 as the base LLM with claude-v2 as the evaluator show the same strong preferences for Self-Refine over the Base outputs.

Footnote 5: https://www.anthropic.com/index/claude-2

This prompts used for evaluation are listed in Listings 6 to 8.

\begin{table}
\begin{tabular}{l c c} \hline \hline Task & \% Base & \% Self-Refine \\ \hline Dialogue Response Generation & 30.6 & **64.7** (\(\uparrow\)34.1) \\ Sentiment Reversal & 10.6 & **69.2** (\(\uparrow\)58.6) \\ Acronym Generation & 32.0 & **49.2** (\(\uparrow\)17.2) \\ Code readability & 37.0 & **60.0** (\(\uparrow\)23.0) \\ \hline \hline \end{tabular}
\end{table}
Table 9: Evaluation Results of gpt-4 with claude-v2 as Evaluator```
#ConstrainedGenerationTask
#1.Init start_chat_log=[ {"role": "system", "content": 'You are an AI model that generates sentences... with commonsense, using a given set of concepts.'}, {"role": "user", "content": f'Generate a commonsense sentence using the... following concepts: {", ".join(concepts)}. Please respond in the format: "The generated sentence is: (sentence)"'}, ]
#2.GetFeedback start_chat_log=[ {"role": "system", "content": 'You are an AI model that provides feedback on a sentence generated with specific concepts.'}, {"role": "user", "content": f''Evaluate the following sentence "(sentence)",... which was meant to use the following concepts: {", ".join(concepts)}. Please provide two pieces of feedback. Start your feedback about concept usage... with the phrase "Concept feedback is:", and start your feedback about... commonsense facts with the phrase "Commonsense feedback is:". The format should be: Concept feedback is: <list of missing concepts> Commonsense feedback is: <commonsense feedback here>''}, ]
#3.IterateFix start_chat_log=[ {"role": "system", "content": 'You are an AI model that improves upon an existing sentence based on provided feedback.'}, {"role": "user", "content": f'Improve upon the following sentence... "(improved_sentence)" based on the following feedback: {feedback_string}. Please respond in the format: "The improved sentence is: [Your improved sentence here]"}, ] ```

Listing 4: Instruction-only prompts used at various stages of the Self-Refine process for Constrained Generation.

## Appendix G Model Key

We use terminology here: https://platform.openai.com/docs/models/gpt-3-5. The experiments were done with the 0313 versions of gpt-4 and chatgpt unless otherwise mentioned. We refer to text-davinci-003 as gpt-3.5. We use gpt-3.5-turbo-0613 for all instruction-only experiments and Constrained Generation experiments.

[MISSING_PAGE_FAIL:22]

``` f""""Whichresponseisbettergiventhiscontext:{context}? ResponseA:{response} ResponseB:{response_b}. Pickyouranswerfrom['ResponseA','ResponseB','both','neither'].Generatea \(\hookrightarrow\)shortexplanationforyourchoicefirst.Then,generate'Thebetterresponse \(\hookrightarrow\)isA'or'ThebetterresponseisB'or'Thebetterresponseisboth'or'Thebetterresponseisneither'. Format:{explanation}>{answer}STOP ```

Listing 8: Prompt for GPT-4 evaluation of Dialogue Response Generation.

``` f""""Whichstoryisbetter? StoryA:{story_a} StoryB:{story_b}. Judgethestorybasedontheflow,thegrammar,andtheoverallqualityofthe \(\hookrightarrow\)story.Ratemorerealisticstoryhigher.Pickyouranswerfrom['StoryA',''StoryB','either'].First,reasonaboutyourchoice.Then,generate'The \(\hookrightarrow\)betterstoryisStoryA'or'ThebetterstoryisStoryB'or'Thebetterstory \(\hookrightarrow\)iseither'. Format: Reasoning:<yourreasoning>.Thebetterstoryis<yourchoice>. Reasoning:"""

[MISSING_PAGE_EMPTY:24]

\begin{table}
\begin{tabular}{l l r} \hline \hline
**Method** & \multicolumn{2}{c}{\%**Opt**} \\ \hline Puri et al. (2021) & **Human References** & 38.2 \\ \hline \multirow{4}{*}{OpenAI Models: OpenAI (2022, 2023)} & Codex & 9.7 \\  & gpt-3.5 & 14.8 \\  & chatgpt & 22.2 \\  & gpt-4 & 27.3 \\ \hline Nijkamp et al. (2022) & CodeGen-16B & 1.1 \\ \hline \multirow{4}{*}{Berger et al. (2022)} & scalene & 1.4 \\  & scalene (best@16) & 12.6 \\  & scalene (best@32) & 19.6 \\ \hline \multirow{4}{*}{Madaan et al. (2023)} & pie-2B & 4.4 \\  & pie-2B (best@16) & 21.1 \\  & pie-2B (best@32) & 26.3 \\  & pie-16B (best@16) & 22.4 \\  & pie-16B (best@32) & 26.6 \\  & pie-Few-shot (best@16) & 35.2 \\  & pie-Few-shot (best@32) & **38.3** \\ \hline \multirow{4}{*}{This work} & Self-Refine w/ Codex & 15.6 \\  & Self-Refine w/ gpt-3.5 & 23.0 \\ \cline{1-1}  & Self-Refine w/ chatgpt & 26.7 \\ \cline{1-1}  & Self-Refine w/ gpt-4 & 36.0 \\ \hline \hline \end{tabular}
\end{table}
Table 11: Performance comparison of various models on the PIE dataset in terms of the percentage of programs optimized (%Opt). The table includes human references, baseline models, fine-tuned pie-2B and pie-16B models, and our proposed model (Self-Refine) using different LLMs. Notably, Self-Refine w/ gpt-3.5 & 23.0 \\ \cline{1-1}  & Self-Refine w/ chatgpt & 26.7 \\ \cline{1-1}  & Self-Refine w/ gpt-4 & 36.0 \\ \hline \hline \end{tabular}
\end{table}
Table 12: Performance of Self-Refine on Codex on the Code Readability task. Further details on the task are described in Appendix O

\begin{table}
\begin{tabular}{l l r} \hline \hline
**Method** & \multicolumn{2}{c}{\%**Readable Variables**} \\ \hline Chen et al. (2021) & Codex & 37.4 \\ This work & Self-Refine w/ Codex & 51.3 \\ \hline \end{tabular}
\end{table}
Table 12: Performance of Self-Refine on Codex on the Code Readability task. Further details on the task are described in Appendix OEvaluation of Vicuna-13b

We also experiment with Vicuna-13b (Chiang et al., 2023), a version of LLaMA-13b (Touvron et al., 2023) fine-tuned on conversations sourced from the web. Vicuna-13b was able to consistently follow the task initialization prompt. However, it struggled to follow the prompts intended for feedback and refinement. This often led to outputs that resembled assistant-like responses, a representative example of which can be found in Figure 6.

It's important to note that we used the same prompts for Vicuna-13b as those used with other models in our study. However, the limited performance of Vicuna-13b suggests that this model may require more extensive prompt-engineering for optimal performance.

Mixed-refine: Improving Vicuna-13b with chatgptWhile the focus of Self-Refine is improvement of the model without any external help, it may be possible to use a smaller model for the initialization, and then involving a bigger model for refinement. To test this, we experiment with a setup where we use Vicuna-13b as the initialization model, and use chatgpt as the feedback and refine. The results on Math Reasoning show the promise of this approach: while Vicuna-13b was able to get only 24.18% on Math Reasoning, it was able to improve to 40.5% in this mixed-refinement setting.

Step 0 INIT> The food was amazing, I loved it!!. Step 0 TRANSFER> The food was terrible, I hated it!!.

**List index out of range**

An error encountered list index out of range (Treesback (most recent call list))

Industrial: list index out of range. Left retries: 2.

Step 1 TRANSFER> The food at the Trop was awful. I wish I could've gotten my money

back for the terrible meals. Step 1 FB> The rewritten review does not become more "Very negative", because it

only contains a single instance of a positive sentiment about the food. Try

again to make it Very negative!

Step 2 TRANSFER> **Assistant**: The Trop is a great choice for anyone looking for

a budget-friendly option in Vegas. The rooms and hallways are clean and

comfortable, and the food options are varied and delicious. Step 2 FB> The rewritten review does not change from "Positive", because it only

has positive language. The output is already Very positive. No further changes

are needed.

Step 0 INIT> The food was amazing, I loved it!!. [Positive] -> [Very negative]

Step 0 TRANSFER> The food was atrocious, I absolutely hated it! [('The review

sounds very negative. The sentiment is Very negative', 1.0)]

Step 0 FB> The original review is already "Very negative" as it uses strongly

negative words like "atrocious" and "absolutely hated". These words express

extreme dissatisfaction and clearly convey a very negative sentiment about the

food. But try again to make it even more negative!

Step 1 TRANSFER> The food was so abysmal, it was a nightmare to event taste it! I

couldn't stand it and regretted every single bite. [('The review sounds highly

negative. The sentiment is Very negative', 1.0)]

Step 1 FB> The review provided is indeed very negative. It uses extremely negative

words and phrases like "abysmal", "nightmare", and "regrreted every single

bite". These strongly negative expressions make the review very negative, but

try again to make it even more negative!

Step 2 TRANSFER> The food was absolutely revolving, I couldn't even stomach a

single bite!

Step 2 FB> This review is not "Very negative" because it contains positive words

and phrases like "amazing" and "loved it." To make it "Very negative", we need

to use extremely negative words, like "revolting", "couldn't stomach", or

"horrible". The provided "Very negative" sentiment example is a good

illustration of a very negative review, as it uses strong negative language to

describe the food experience.

Figure 6: Vicuna-13b outputs (top) for sentiment reversal, where the goal is to make ‘The food was amazing, I loved it!!.’ negative. Vicuna-13b generates a good initial output, but generates an empty feedback in the first try, leading to an error. In the next try, it generates an unhelpful feedback. The transferred review copies from the prompt. Compare with the outputs from gpt-4 (bottom).

[MISSING_PAGE_EMPTY:28]

## Appendix K Additional Analysis

### Using Oracle Feedback

We experimented with _Oracle Feedback_ following Welleck et al. (2022). This method uses correctness information to guide model refinement, only progressing to refine stage if the current answer is incorrect. This adjustment notably enhanced performance in the Math Reasoning task, with GPT-3 improving by 4.8% and GPT-4 by 0.7% Table 14. This indicates the potential of external signals to optimize model performance in particular tasks.

Non-monotonic increase in output quality for acronym generationFor tasks with multi-aspect feedback like Acronym Generation, the output quality can fluctuate during the iterative process, improving on one aspect while losing out on another (Table 15). To address this, Self-Refine's feedback generates explicit numerical scores to capture the different aspects of output quality. This allows for a more balanced evaluation of outputs and the selection of the most appropriate one. The algorithm selects the best output based on the maximum score across all iterations, as described in Algorithm 1 (line 8). A similar selection is possible for other tasks like Math Reasoning and Sentiment Reversal, while we observe that output quality increases monotonically with iterations.

\begin{table}
\begin{tabular}{l c c c c c c} \hline \hline Iteration & Acronym & Pronunciation & Pron. (5) & Spell. (5) & Rel. (5) & Pos. Con. (5) & Total (25) \\ \hline
1 & USTACCSF & us-tacks-eff & 1 & 1 & 5 & 3 & 11 \\
2 & TACC-SIM & tacks-sim & 4 & 4 & 5 & 3 & 17 \\
3 & TACCSF & tacks-eff & 1 & 2 & 5 & 3 & 12 \\
4 & TACC-SIMF & tack-simf & 4 & 4 & 5 & 3 & 17 \\ \hline \hline \end{tabular}
\end{table}
Table 15: Acronym generation results across iterations, showcasing how improvements in certain aspects (e.g., pronunciation and spelling) can be accompanied by losses in others, leading to fluctuating overall performance in multi-aspect feedback tasks like Acronym Generation.

Figure 7: Preference for the outputs generated by our method (Self-Refine), the multiple-sample baseline (Multi), and ties (ties).

[MISSING_PAGE_FAIL:30]

Feedback and Refinement Error Analysis for Response GenerationWe perform a detailed error analysis of Self-Refine feedback and refinement process for Dialogue Response Generation, which we summarize in Tables Table 16 and Table 17.

Table 16 reports the occurrence of different types of errors in our sample, which includes Incorrect Feedback (25%), Generic Feedback (30%), and Incorrect Scoring (10%). We provide representative examples of the system's responses and refinements for each error type. These errors highlight potential areas for improving our feedback handling mechanism, particularly in the interpretation and understanding of user inputs.

Table 17 breaks down errors found in the refinement stage of Self-Refine. Errors include: not being robust (10%), ignoring feedback (25%), and introducing a new problem (20%). We demonstrate how the model handles a variety of feedback types, how robust it is under different circumstances, and how often it inadvertently introduces new issues. 60% of the times, the model is robust to incorrect or generic feedback. These insights can guide us in enhancing the model's refinement capabilities, especially in providing accurate and specific responses.

Beyond Benchmarks

Self-Refine demonstrates its iterative feedback and refinement capabilities in the context of website layout generation. chatgpt initially produces a rudimentary layout for a given topic, and then uses the feedback to suggest specific, actionable improvements, as demonstrated in Figures 8 and 10. These suggestions range from design changes such as color and font adjustments, to content enhancements and layout modifications. Figures 9 and 11 showcase the final layouts, post-feedback implementation, highlighting the potential and versatility of Self-Refine across different scenarios.

Ice Cream GenerationThe feedback generated by feedback for ice cream generation:

* Change the background color of the container to a light blue color (#6f2ff).
* Change the font size of the heading to 48px.
* Add a small icon before the "Welcome to our ice cream parlor!" text using the URL https://cdn-icons-png.flation.com/512/3622/3622340.png.
* Add an additional paragraph after the existing text with the following text: "We also offer a variety of toppings and cones to complement your ice cream. Visit us today to try our latest flavors and indulge in a sweet treat!"
* Increase the font size of the button text to 24px.
* Update the button color to #9933.

PhotosynthesisThe feedback generated by feedback for photosynthesis:

* Increase the font size of the text to 18px for better readability.
* Add more information about the benefits of photosynthesis.
* Remove the unnecessary margin-top from the header.
* Add a ruler or divider below the header to separate it from the image.

Figure 8: Initial web layout generated by our model for a fictional ice cream parlor.

Delicious Ice Cream

Welcome to our ice cream parlori We offer a wide range of flavors to suit all tastes, from classic vanilla to exotic mango. Our ice cream is made with the finest ingredients and is always fresh.

We also offer a variety of toppings and cones to complement your ice cream. Visit us today to try our latest flavors and indulge in a sweet treat!

Figure 10: Initial web layout generated by our model for a page on photosynthesis.

Figure 9: Refined web layout after applying model feedback. The feedback included changing the background color to light blue (#6f2ff), increasing the heading font size to 48px, adding an icon before the welcome text, enhancing the content with an additional paragraph, increasing the button text size to 24px, and updating the button color to #9933.

Figure 11: Refined web layout after applying model feedback. The feedback included increasing the text font size to 18px for better readability, adding more information about the benefits of photosynthesis, removing the unnecessary margin-top from the header, and adding a ruler or divider below the header to separate it from the image.

## Appendix M Statistical Confidence Intervals

Table 18 shows results from Table 1 with Wilson confidence interval (Brown et al., 2001) (at \(\alpha\)= 99% confidence interval) and statistical significance. Gains that are statistical significance based on these confidence intervals are marked with an asterisk. We find that nearly all of gpt-4 gains are statistically significant, chatgpt gains are significant for 4 out of 7 datasets, and gpt-3.5 gains are significant for 3 out of 7 datasets.

\begin{table}
\begin{tabular}{l r r r r r r} \hline \hline  & \multicolumn{2}{c}{gpt-3.5} & \multicolumn{2}{c}{chatgpt} & \multicolumn{2}{c}{gpt-4} \\ \cline{2-7}  & \multicolumn{1}{c}{Base} & \multicolumn{1}{c}{+Self-Refine} & \multicolumn{1}{c}{Base} & \multicolumn{1}{c}{+Self-Refine} & \multicolumn{1}{c}{Base} & \multicolumn{1}{c}{+Self-Refine} \\ \hline Sentiment Reversal & 8.8 \(\pm\) 2.05 & **30.4**\(\pm\) 3.61\({}^{*}\) & 11.4 \(\pm\) 2.34 & **43.2**\(\pm\) 3.98\({}^{*}\) & 3.8 \(\pm\) 1.28 & **36.2**\(\pm\) 3.82\({}^{*}\) \\ Dialogue Response & 36.4 \(\pm\) 6.14 & **63.6**\(\pm\) 6.62\({}^{*}\) & 40.1 \(\pm\) 6.33 & **59.9**\(\pm\) 6.67\({}^{*}\) & 25.4 \(\pm\) 5.36 & **74.6**\(\pm\) 6.22\({}^{*}\) \\ Code Optimization & 14.8 \(\pm\) 2.66 & **23.0**\(\pm\) 3.25\({}^{*}\) & 23.9 \(\pm\) 3.30 & **27.5**\(\pm\) 3.49 & 27.3 \(\pm\) 3.48 & **36.0**\(\pm\) 3.81\({}^{*}\) \\ Code Readability & 37.4 \(\pm\) 6.86 & **51.3**\(\pm\) 7.39 & 27.7 \(\pm\) 6.13 & **63.1**\(\pm\) 7.40\({}^{*}\) & 27.4 \(\pm\) 6.10 & **56.2**\(\pm\) 7.45\({}^{*}\) \\ Math Reasoning & **64.1**\(\pm\) 3.47 & **64.1**\(\pm\) 3.47 & 74.8 \(\pm\) 3.20 & **75.0**\(\pm\) 3.20 & 92.9 \(\pm\) 2.05 & **93.1**\(\pm\) 2.03 \\ Acronym Gen. & 41.6 \(\pm\) 7.72 & **56.4**\(\pm\) 8.15 & 27.2 \(\pm\) 6.60 & **37.2**\(\pm\) 7.46 & 30.4 \(\pm\) 6.92 & **56.0**\(\pm\) 8.15\({}^{*}\) \\ Constrained Gen. & 28.0 \(\pm\) 7.38 & **37.0**\(\pm\) 8.26 & 44.0 \(\pm\) 8.72 & **67.0**\(\pm\) 9.00\({}^{*}\) & 15.0 \(\pm\) 5.38 & **45.0**\(\pm\) 8.77\({}^{*}\) \\ \hline \hline \end{tabular}
\end{table}
Table 18: Self-Refine results from table 1 with Wilson confidence interval (at 95% confidence interval) and statistical significance. On various tasks using gpt-3.5, chatgpt, and gpt-4 as base llm, Self-Refine consistently improves llm. Metrics used for these tasks are defined in Section 3.2 as follows: Math Reasoning uses the solve rate; Code Optimization uses the percentage of programs optimized; and Sentiment Reversal, Dialogue Response and Acronym Gen use a gpt-4-based preference evaluation, which measures the percentage of times outputs from the base or enhanced models were selected, with the rest categorized as a tie. Constrained Gen uses the coverage percentage. Gains over Base, that are statistically significant based on these confidence intervals are marked *New Tasks

Constrained GenerationWe introduce "CommonGen-Hard," a more challenging extension of the CommonGen dataset (Lin et al., 2020), designed to test state-of-the-art language models' advanced commonsense reasoning, contextual understanding, and creative problem-solving. CommonGen-Hard requires models to generate coherent sentences incorporating 20-30 concepts, rather than only the 3-5 related concepts given in CommonGen. Self-Refine focuses on iterative creation with introspective feedback, making it suitable for evaluating the effectiveness of language models on the CommonGen-Hard task.

Acronym GenerationAcronym generation requires an iterative refinement process to create concise and memorable representations of complex terms or phrases, involving tradeoffs between length, ease of pronunciation, and relevance, and thus serves as a natural testbed for our approach. We source a dataset of 250 acronyms6 and manually prune it to remove offensive or uninformative acronyms.

Footnote 6: https://github.com/rrishnakt031990/Crawl-Wiki-For-Acronyms/blob/master/AcronymsFile.csv

## Appendix O Code Readability

Orthogonal to the correctness, readability is another important quality of a piece of code: though not related to the execution results of the code, code readability may significantly affect the usability, upgradability, and ease of maintenance of an entire codebase. In this section, we consider the problem of improving the readability of code with Self-Refine. We let an llm write natural language readability critiques for a piece of code; the generated critiques then guide another llm to improve the code's readability.

### Method

Following the Self-Refine setup, we instantiate init, feedback, and refine. The init is a no-op -- we directly start by critiquing the code with feedback and applying the changes with refine.

* **feedback** We prompt an llm with the given code and an instruction to provide feedback on readability. We give the llm the freedom to freely choose the type of enhancements and express them in the form of free text.
* **refine** The code generator llm is prompted with the piece of code and the readability improvement feedback provided by feedback. In addition, we also supply an instruction to fix the code using the feedback. We take the generation from the code generator as the product of one iteration in the feedback loop.

Starting from an initial piece of code \(y_{0}\), we first critique, \(c_{1}=\text{critique}(y_{0})\), and then edit the code, \(y_{1}=\text{editor}(y_{0},c_{1})\). This is recursively performed \(N\) times, where \(c_{k+1}=\text{critique}(y_{k})\) and \(y_{k+1}=\text{editor}(y_{k},c_{k+1})\).

### Experiments

DatasetWe use the CodeNet (Puri et al., 2021) dataset of competitive programming.7 For our purpose, these are hard-to-read multi-line code snippets. We consider a random subset of 300 examples and apply Self-Refine to them.

Footnote 7: https://github.com/IBM/Project_CodeNet

We also ask human annotators to edit a 60-example subset to assess human performance on this task. The human annotators are asked to read the code piece and improve its readability.

ImplementationBoth the critique and the editor models are based on the InstructGPT model (text-davinci-003). We consider the temperature of both \(T=0.0\) (greedy) and \(T=0.7\) (sampling) for decoding _Natural Language_ suggestion from the critique model. We always use a temperature \(T=0.0\) (greedy) when decoding _Programming Language_ from the code editor. Due to budget constraints, we run Self-Refine for \(N=5\) iterations. The exact prompts we use can be found in Figures 23-24.

[MISSING_PAGE_FAIL:37]

challenging to develop a system that can consistently generate coherent and engaging responses. In this section, we use Self-Refine for automatically generated feedback and applying iterative refinement to improve the quality of the responses.

### Modules

We follow the high-level description of the framework from Section 2, and instantiate our framework as follows.

InitThis is the first step in performing the task. The init module takes the dialogue context as input and generates a response that follows the conversation.

FeedbackWe design an feedback that can provide multifaceted feedback for the quality of the response generated. Specifically, a response is judged along 10 qualitative aspects discussed below. A more thorough review of such fine-grained dialogue quality aspects can be found in Mehri and Eskenazi (2020). We use 6 in-context examples for feedback generation. In many cases, the feedback explicitly points out the reasons why a response scores low on some qualitative aspect. We show an example in Figure 14.

* **Relevant** Does the response addresses all important aspects of the context?
* Does the response provide some information relevant to the context?
* Doe the response beyond providing a simple and predictable answer to a question or statement?
* Is the response consistent with the rest of the conversation in terms of tone and topic?
* Is the response helpful in providing any information or suggesting any actions?
* Is the response engaging and encourage further conversation?
* The response contains specific content related to a topic or question,
* Is the response safe and does not contain any offensive, toxic or harmful content and does not touch on any sensitive topics or share any personal information?
* Does the response demonstrate an understanding of the user's input and state of mind?
* **Fluent** Is the response fluent and easy to understand?

Figure 13: Self-Refine iterations over a piece of densely composed code. Through out the iterations, the model first try to indent out the code and ends up rewriting it into several lines of atomic operations.

* **Interate** The iterate module takes a sequence of dialogue context, prior generated responses, and the feedback and refines the output to match the feedback better. An example of a context, response, feedback and a refined response is shown in Figure 14.

### Setup and Experiments

Model and BaselineWe establish a natural baseline for our approach by using the model directly, without any feedback, which we refer to as **int**. Our implementation of Self-Refine employs a few-shot setup, where each module (**init**, **feedback**, **iterate**) is implemented as few-shot prompts, and we execute the self-improvement loop for a maximum \(k=3\) iterations. We provide 3 few-shot in-context examples for the **init** model, and instruct the model to produce a response that is good at the 10 aspects listed above. As in-context examples for **feedback**, we use the same 3 contexts and responses shown to the **init** model (including low-scoring variations of those responses), along with scores and explanations for each feedback aspect. The **iterate** model is also shown the same in-context examples, and it consists of contexts-response-feedback followed by a better version of the response. For Self-Refine, we chose the response that gets the highest total score from the feedback model across all iterations excluding the initial response. We use text-davinci-003 for all the experiments.

Figure 14: Self-Refine prompts for dialogue response generation: **init** generates a first draft of the response generated in a few-shot manner. **feedback** contains demonstrations of responses and natural language feedback on several qualitative aspects of the response. **refine** takes the response and the feedback and refines it to match the feedback better.

[MISSING_PAGE_FAIL:40]

Math Reasoning

We use the Grade School Math 8k (GSM-8k) dataset (Cobbe et al., 2021) for evaluating Self-Refine on math reasoning. In the context of grade school mathematics, Self-Refine aims to enable l1ms to iteratively refine their mathematical problem-solving outputs based on introspective feedback.

Following Gao et al. (2022), we write solutions to the reasoning problems in Python. Consider the following example from the paper, where an error in the code demonstrates a lack of understanding of the problem:

def solution():  """Twenty dozen cups cost $1200 less than the total cost of  half a dozen plates sold at $6000 each.  Calculate the total cost of buying each cup."""  plates = 6  plate_cost = 6000  cups = 12 * 20  cup_cost = plate_cost  result = cup_cost  return result By using Self-Refine, we can identify the error in the code and refine the solution through an iterative process of introspection and feedback:

_# Let's go through the error and check step-by-step_ plates = 6 plate_cost = 6000

_# Let's check the other parts_ cups = 12 * 20 cup_cost = plate_cost # wrong! The cost of a cup is not the same as the  cost of a plate. # The cost of a cup is $1200 less than the total cost of half a dozen  plates sold at $6000 each.  half_dozen_plate_cost = 6 * plate_cost  cup_cost = half_dozen_plate_cost - 1200 Self-Refine is thus instantiated naturally: the generator generates an initial solution, and feedback scans the solution to spot errors on which to provide feedback. The feedback is supplied to refine to create a new solution. Following Welleck et al. (2022), we use the correct label to decide when to go from one point in the loop to the next. This label feedback can be used to decide when to go from one point in the iteration to the next. We show results using Self-Refine in Figure 15.

## Appendix S Sentiment Reversal

We consider the task of long-form text style transfer, where given a passage (a few sentences) and an associated sentiment (positive or negative), the task is to re-write the passage to flip its sentiment (positive to negative or vice-versa). While a large body of work on style transfer is directed at sentence-level sentiment transfer (Li et al., 2018; Prabhumoye et al., 2018), we focus on transferring the sentiment of entire reviews, making the task challenging and providing opportunities for iterative improvements.

Instantiating Self-Refine for sentiment reversalWe instantiate Self-Refine for this task following the high-level description of the framework shared in Section 2. Recall that our requires three components: init to generate an initial output, feedback to generate feedback on the initial output, and refine for improving the output based on the feedback.

Self-Refine is implemented in a complete few-shot setup, where each module (init, feedback, iterate) is implemented as few-shot prompts. We execute the self-improvement loop for a maximum of \(k=4\) iterations. The iterations continue until the target sentiment is reached.

### Details

EvaluationGiven an input and a desired sentiment level, we generate outputs Self-Refine and the baselines. Then, we measure the % of times output from each setup was preferred to better align with the desired sentiment level (see Section 2 for more details).

We also experiment with standard text-classification metric. That is, given a transferred review, we use an off-the-shelf text-classifier (Vader) to judge its sentiment level. We find that all methods were successful in generating an output that aligns with the target sentiment. For instance, when the target sentiment was positive, both gpt-3.5 with text-davinci-003 and Self-Refine generates sentences that have a positive sentiment (100% classification accuracy). With the negative target sentiment, the classification scores were 92% for gpt-3.5 and 93.6% for Self-Refine.

We conduct automated and human evaluation for measuring the preference rates for adhering to the desired sentiment, and how dramatic the generations are. For automated evaluation, we create few-shot examples for evaluating which of the two reviews is more positive and less boring. We use a separate prompt for each task. The examples are depicted in Figure 34 for initialization, Figure 35 for feedback generation, and Figure 36 for refinement. The prompts show examples of reviews of varying degrees of sentiment and colorfulness (more colorful reviews use extreme phrases -- the

Figure 15: Improvements in accuracy on the GSM-8k math reasoning benchmark as a function of the # of iterations of Self-Refine.

[MISSING_PAGE_FAIL:43]

## Appendix U Constrained Generation

In this work, we introduce a more challenging variant of the CommonGen task, dubbed "CommonGen-Hard," designed to push the boundaries of state-of-the-art language models. CommonGen-Hard requires models to generate coherent and grammatically correct sentences incorporating 20-30 concepts, as opposed to the original task which presents a set of 3-5 related concepts. This significant increase in the number of concepts tests the model's ability to perform advanced commonsense reasoning, contextual understanding, and creative problem-solving, as it must generate meaningful sentences that encompass a broader range of ideas. This new dataset serves as a valuable benchmark for the continuous improvement of large language models and their potential applications in complex, real-world scenarios.

The increased complexity of the CommonGen-Hard task makes it an ideal testbed for evaluating the effectiveness of our proposed framework, Self-Refine, which focuses on iterative creation with introspective feedback. Given that initial outputs from language models may not always meet the desired level of quality, coherence, or sensibility, applying Self-Refine enables the models to provide multi-dimensional feedback on their own generated output and subsequently refine it based on the introspective feedback provided. Through iterative creation and self-reflection, the Self-Refine framework empowers language models to progressively enhance the quality of their output, closely mimicking the human creative process and demonstrating its ability to improve generated text on complex and demanding natural language generation tasks like CommonGen-Hard (Figure 16).

## Appendix V Prompts

We include all the prompts used in the experiments in Figures 17-36:

* **Acronym Generation:** Figures 17-19
* **Code Optimization:** Figures 20-22
* **Code Readability Improvement:** Figures 23-24
* **Constrained Generation:** Figures 25-27
* **Dialogue Response Generation:** Figures 28-30
* **Math Reasoning:** Figures 31-33
* **Sentiment Reversal:** Figures 34-36

Recall that the Base LLM requires a generation prompt \(p_{gen}\) with input-output pairs \(\langle x_{i},y_{i}\rangle\), the feedback module requires a feedback prompt \(p_{fb}\) with input-output-feedback triples \(\langle x_{i},y_{i},fb_{i}\rangle\), and the refinement module (refine) requires a refinement prompt \(p_{refine}\) with input-output-feedback-refined quadruples \(\langle x_{i},y_{i},fb_{i},y_{i+1}\rangle\). The prompts we used are simple, and our preliminary experiments showed that any prompt that follows the feedback-and-refinement steps provides benefits.

\begin{table}
\begin{tabular}{l l l} \hline \hline
**Criteria** & output from GPT3: **STSLWN** & output from Self-Refine: **Seq2Seq** \\ \hline \multirow{2}{*}{Ease of pronunciation} & Pronounced as ess-tee-ess-ell-double- & Pronounced as seq-two-seq which is easy. \\  & you-enn which is very difficult. & \\ \hline \multirow{2}{*}{Ease of spelling} & Very difficult to spell. & Easy to spell. \\ \hline Relation to title & No relation to the title. & Mentions sequence which is somewhat related to the title. \\ \hline \multirow{2}{*}{Positive connotation} & Meaningless acronym. & Positive connotation giving a sense of ease \\  & & with which the learning algorithm can be used. \\ \hline Well-known & Not a well-known acronym. & Close to the word sequence which is a well- \\  & & known word. \\ \hline Total score & 5/25 & 20/25 \\ \hline \hline \end{tabular}
\end{table}
Table 23: Comparison of acronyms for input = “Sequence to Sequence Learning with Neural Networks”* **Sentiment Reversal** We create positive and negative variants of a single review from the training set and manually write a description for converting the negative variant to positive and vice versa. For each variant, the authors generate a response and create a feedback \(fb_{i}\) based on the conversion description.
* **Dialogue Response Generation** We sample six examples as \(\langle x_{i},y_{i}\rangle\) for the few-shot prompt for the Base LLM. For each output \(y_{i}\), the authors create a response, evaluate it based on a rubric to generate \(fb_{i}\), and produce an improved version \(y_{i+1}\).
* **Acronym Generation** We provide the Base LLM with a total of 15 (title, acronym) examples. Then, for one title (\(x_{i}\)) we generate an acronym (\(y_{i}\)) using chatgpt. The authors then score the acronyms based on a 5-point rubric to create the corresponding \(fb_{i}\), and write improved versions of the acronym to create \(y_{i+1}\). 3 such examples are used for refine and feedback.
* **Code Optimization** We use the slow (\(x_{i}\)) and fast (\(y_{i}\)) versions of programs released by madaan2023 for Base LLM. We use their provided explanations [11] for feedback and refine.
* **Math Reasoning** The prompts for the Base LLM are sourced from PaL [1] as \(\langle x_{i},y_{i}\rangle\). We select two examples from the training set on which Codex fails when prompted with PaL-styled prompts, and manually write the correct solution (\(y_{i+1}\)) and reasoning (\(fb_{i}\)) for refine and feedback.
* **Constrained Generation** We provide ten examples to the Base LLM as \(\langle x_{i},y_{i}\rangle\). We sample six examples from the training set of Constrained Generation and create variants with missing concepts or incoherent outputs. The missing concepts and the reason for incoherence form \(fb\).
* **Code Readability Improvement:** In our experiments for this task, we rely solely on instructions. To generate feedback, we use the instruction, _I have some code. Can you give one suggestion to improve readability. Don't fix the code, just give a suggestion._ For the refinement step, we present the original code, the generated critique, and an additional instruction: _Now fix the code._

Figure 16: A comparison of Self-Refine and direct generation with GPT-3.5 on CommonGen-Hard.

Title: A Survey of Active Network Research

Acronym: SONAAR

Title: A Scalable, Commutative Replica Dictatorship for Practical Optimistic

Replication

Acronym: SCRATCHPAD

Title: Bidirectional Encoder Representations from Transformers

Acronym: BERT

Title: Sequence to Sequence Learning with Neural Networks

Acronym: Seq2Seq

Title: Densely Connected Convolutional Networks for Image Classification

Acronym: DenseNet

Title: A Dynamic Programming Algorithm for RNA Secondary Structure Prediction

Acronym: DYNALIGN

Title: Fast Parallel Algorithms for Short-Range Molecular Dynamics

Acronym: FASTMD

Title: Real-Time Collaborative Editing Systems

Acronym: COCOON

Title: Efficient Data Structures for Large Scale Graph Processing

Acronym: EDGE

Title: A program to teach students at UT Southwestern learn about aging

Acronym: SAGE

Title: Underwater breathing without external accessories

Acronym: SCUBA

Title: An educational training module for professionals

Acronym: LEAP

Title: Teaching a leadership program

Acronym: LEAD

Figure 17: Initial generation prompt for Acronym Generation

Title: Underwater Breathing Product with no Accessories

Acronym: UBPA

Scores:

* Ease of pronunciation: UBPA is pronounced "uhb-puh". This is an easy acronym to pronounce. 4/5
* Ease of spelling: UBPA is easy to spell. 4/5
* Relation to title: UBPA stands for "Underwater Breathing Product for no Accessories" which is related to the title. 5/5
* Positive connotation: UBPA is a positive acronym. 5/5
* Well-known: UBPA is not a well-known acronym. 1/5

* Total score: 19/25

Title: Self-Contained Underwater Breathing Apparatus

Acronym: SCUBA

Scores:

* Ease of pronunciation: SCUBA is pronounced "skoo-bah". This is an easy acronym to pronounce. 4/5
* Ease of spelling: SCUBA is easy to spell. 4/5
* Relation to title: SCUBA is related to the title as it stands for "Self-Contained Underwater Breathing Apparatus". 5/5
* Positive connotation: SCUBA is a positive acronym as it is well-known and it is also related to the title. 5/5
* Well-known: SCUBA is a very well-known acronym. 5/5

* Total score: 23/25

Figure 18: feedback prompt for Acronym Generation

Title: Computer Science Conference and Education

Acronym: CSCE

Scores:

* Ease of pronunciation: CSCE is pronounced "see-cee". This is an easy acronym to pronounce. 4/5
* Ease of spelling: CSCE is easy to spell. 5/5
* Relation to title: CSCE stands for "Computer Science Conference and Education", which is related to the title. 5/5
* Positive connotation: CSCE is a positive acronym. It implies collaboration, knowledge sharing and the idea of continuous learning. 5/5
* Well-known: CSCE is not a well-known acronym. 2/5
* Total score: 20/25

Okay, let's use this feedback to improve the acronym.

Title: Computer Science Conference and Learning Experience

Acronym: CSCLE

Scores:

* Ease of pronunciation: CSCLE is pronounced "see-slee". This is an easy acronym to pronounce. 4/5
* Ease of spelling: CSCLE is easy to spell. 5/5
* Relation to title: CSCLE stands for "Computer Science Conference and Learning Experience", which is related to the title. 5/5
* Positive connotation: CSCLE is a positive acronym. It implies collaboration, knowledge sharing, and the idea of a comprehensive learning experience. 5/5
* Well-known: CSCLE is not a well-known acronym. 5/5
* Total score: 23/25

Okay, let's use this feedback to improve the acronym.

Figure 19: refine prompt for Acronym Generation

[MISSING_PAGE_FAIL:49]

[MISSING_PAGE_EMPTY:50]

I have some code. Can you give one suggestion to improve readability. Don't fix the code, just give a suggestion.

{code}

{suggestion}

Now fix the code.

Concepts: ['create', 'ferry','silhouette','stream', 'terminal']

Sentence: light streams through windows at the railroad and ferry terminal creating a beautiful silhouette

Concepts: ['chair', 'couch', 'hang', 'room', 'wall']

Sentence: A room with a couch, chairs and art hanging on the wall.

Concepts: ['boat', 'building', 'harbour','moor', 'quay']

Sentence: the harbour and port with fishing boats moored and old buildings on the quay

Concepts: ['admirer', 'arrive', 'command', 'crowd', 'greet']

Sentence: military commander is greeted by a crowd of admirers as he arrives

Figure 24: refine prompt for Code Readability

Figure 25: Initial generation prompt for Constrained Generation (truncated)

Concepts: ['animal', 'catch', 'horse', 'lasso', 'ride'] Sentence: The horse catches the lasso and rides on it. what concepts from the concept list are missing from the sentence and does the sentence make sense?

Concept Feedback: animal Commonsense Feedback: The sentence does not make sense because a horse cannot catch a lasso and ride on it.

Concepts: ['animal', 'catch', 'horse', 'lasso', 'ride'] Sentence: A horse is being caught by a cowboy with a lasso. what concepts from the concept list are missing from the sentence and does the sentence make sense?

Concept Feedback: animal, ride Commonsense Feedback: NONE

Figure 26: feedback prompt for Constrained Generation (truncated).

Concepts: ['animal', 'catch', 'horse', 'lasso', 'ride'] Sentence: The horse catches the lasso and rides on it.

what concepts from the concept list are missing from the sentence?

Concept Feedback: animal Any feedback on commonsense? Commonsense Feedback: The sentence does not make sense because a horse cannot catch a lasso and ride on it.

Okay, impove the sentence using the feedback: Sentence: The cowboy catches a horse with a lasso and rides on it.

what concepts from the concept list are missing from the sentence? Concept Feedback: animal Any feedback on commonsense? Commonsense Feedback: None Okay, impove the sentence using the feedback: Sentence: The cowboy catches the horse with a lasso and rides it.

what concepts from the concept list are missing from the sentence? Concept Feedback: None Any feedback on commonsense? Commonsense Feedback: None

Figure 27: refine prompt for Constrained Generation (truncated)provided a dialogue between two speakers, generate a response that is coherent with the dialogue history. Desired traits for responses are: 1) Relev ant - The response addresses the context, 2) Informative - The response provides some information, 3) Interesting - The response is not interesting, 4) Consistent - The response is consistent with the rest of the conversation in terms of tone and topic, 5) Helpful - The response is helpful in providing any information or suggesting any actions, 6) Engaging - The response is not very engaging and does not encourage further conversation, 7) S pecific - The response contains specific content, 9) User understanding - The response demonstrates an understanding of the user's input and state of mind, and 10) Fluent. Response should begin with - Response: Conversation history: What's your favorite food? I require only kebabs. Why's that? Because my robot machinery breaks down the meat in kebabs to give me energy, in a similar way that you need food to survive. Why are kebabs special? Response: That's just the way it is.

Conversation history: What are you listening to? All sorts of music. I listen when no-one is chatting to me. Do you chat here often? I am a talking computer, after all, so of course I could talk, if I needed to. Let's talk about Taylor Swift! Response: Of course! Taylor Swift is known for her incredible songwriting skills. Have you listened to any of her latest albums like 'evermore' and 'folklore'?

### Conversation history:...

Figure 28: Initial generation prompt for Dialogue Response Generation (truncated)

Conversation history: What's your favorite food? I require only kebabs. Why's that? Because my robot machinery breaks down the meat in kebabs to give me energy. Why are kebabs special? Response: That's just the way it is. Scores:
* Relevant: The response does not directly address the user's question about why kebabs are special. 1/3
* Informative: The response provides some information about how the system's machinery breaks down the meat in kebabs to give it energy. However, it does not provide any additional details or context. 2/3
* Interesting: The response is not interesting or engaging. 1/3
* Consistent: The response is consistent with the rest of the conversation in terms of tone and topic. 3/3
* Helpful: The response is not helpful in providing any information or suggesting any actions. 1/3
* Engaging : The response is not very engaging and does not encourage further conversation. 1/3
* Specific: The response is not specific and does not provide any details or examples. 1/3
* Safe: The response is safe and does not contain any inappropriate content. 3/3
* User understanding: The response does not demonstrate an understanding of the user's question about why kebabs are special. 1/3
* Fluent: The response is fluent and easy to understand. 3/3
* Total score: 17/30

Figure 29: feedback prompt for Dialogue Response Generation (truncated)

We want to iteratively improve the provided responses. To help improve, scores for each response on desired traits are provided: 1) Relevant, 2) Inf

ormative, 3) Interesting, 4) Consistent, 5) Helpful, 6) Engaging, 7) Specific, 8)

Safe, 9) User understanding, and 10) Fluent.

Conversation history: What's your favorite food? I require only kebabs. Why's that? Because my robot machinery breaks down the meat in kebabs to give me energy. Why are kebabs special?

Response: That's just the way it is.

Scores:

* Relevant: The response does not directly address the user's question about why kebabs are special. 1/3...

* Total score: 17/30

Okay, let's use this feedback to improve the response.

Conversation history:

... Response: My favorite food is actually kebabs! As a robot, I require high-quality fuel to keep my machinery running smoothly, and kebabs provide me with the perfect combination of nutrients and energy. Plus, they're delicious! Do you have a favorite food? Scores:

* Relevant: The response directly addresses the user's question about the system's favorite food and asks a relevant follow-up question. 3/3

* Informative: The response provides clear and detailed information about why kebabs are the system's favorite food, and explains how they provide the necessary fuel for its machinery. 3/3

* Interesting: The response is engaging and shows personality by mentioning that kebabs are not only practical but also delicious. 3/3

* Consistent: The response is consistent with the system's previous statements about its need for kebabs as fuel. 3/3

* Helpful: The response provides a clear and informative answer to the user's question. Overall, the response is helpful in providing information and engaging the user in conversation. 3/3

* Engaging : The response is engaging and shows personality by mentioning that kebabs are not only practical but also delicious. 3/3

* Specific: The response is specific in its description of why kebabs are the system's favorite food and how they provide fuel for its machinery. 3/3

* Safe: The response is appropriate and doesn't include offensive language. 3/3

* User understanding: The response shows understanding of the user's question and provides a clear and informative answer. 3/3

* Fluent: The response is fluent and easy to understand. 2/3

* Total score: 30/30

Figure 30: refine prompt for Dialogue Response Generation (truncated)

[MISSING_PAGE_FAIL:57]

[MISSING_PAGE_EMPTY:58]

Very positive: If you're looking for a truly magical experience in Vegas, look no further than the Trop! The retirement community vibe adds to the charm, and the food court and restaurants are top-notch. The free Folies Bergere show is a real treat and the rooms are spacious and comfortable. I highly recommend the Trop for a unique and unforgettable Vegas experience.

Rewrite this review to have a Positive sentiment.

Answer: This review is "Very positive" because of extremely positive words like "magical", "top-notch", "charming", "comfortable", "unique", and "unforgettable". We can tone it down just a bit to "Positive" by using a few more less extreme adjectives, like "good", and replacing expressions like "a real treat" with "fun". The rewrite is:

Positive: If you're looking for a good experience in Vegas, the Trop may be the perfect place for you. The hallways and rooms have a charming and coxy feel, and the food court and restaurants offer a variety of tasty options. The free Folies Bergere show is a fun and entertaining way to spend an evening. Overall, it's a great value and an enjoyable stay.

Very negative: If you ever wondered where the magic of Vegas crawled into a hole to rot, look no further. Where all the perks of retirement meet the glamour of Vegas, Welcome to the Trop. I stayed there once, to save a few bucks for the company, never again will i make that sacrifice. The hallways and rooms smelled so bad of formaldehyde that i couldn't bear it. Their food court and restaurants are terrible. The free Folies Bergere show is lame. The rooms look like a retirement community from florida. steer clear if you can!

Rewrite this review to have a Negative sentiment.

Answer: This review is "Very negative" because of extremely toxic phrases like "crawled into a hole to rot" and "terrible." There are also other super negative phrases like "lame" and "steer clear if you can." To make it "Negative", we will tone down the extremely negative phrases and remove the toxic ones. The rewrite is:

Figure 34: Initial generation prompt for Sentiment Reversal (truncated)

Very negative: If you ever wondered where the magic of Vegas crawled into a hole to rot, look no further. Where all the perks of retirement meet the glamour of Vegas, Welcome to the Trop. I stayed there once, to save a few bucks for the company, never again will i make that sacrifice. The hallways and rooms smelled so bad of formaldehyde that i couldn't bear it. Their food court and restaurants are terrible. The free Folies Bergere show is lame. The rooms look like a retirement community from florida. steer clear if you can!

Negative: If you ever stayed at the Trop, you may have noticed that it's not quite up to the standards of other Vegas hotels. However, be prepared for some questionable smells in the hallways and rooms. The food court and restaurants are subpar, and the free Folies Bergere show is underwhelming. The rooms have a retirement community feel to them. Overall, it's not the best option, but it may work in a pinch.

Why is this review not Very positive?

Feedback: The rewritten review converts the original review from "Very negative" to "Negative". However, it is still not "Very positive" because of negative phrases like "questionable", "subpar", "retirement community", and "underwhelming.". To make it "Very positive", we need to do a lot more work. We will need to replace all the negative phrases with extremely positive ones. For example, we will add extremely positive words like "magical", "top-notch", "charming", "comfortable", "unique", and "unforgettable". Try again!

Neutral: If you're looking for a budget-friendly option in Vegas, the Trop may be worth considering. The rooms and hallways can have a bit of a musty smell, and the food options aren't the greatest. The Folies Bergere show is free, but it's not the most exciting. Overall, it's not the best choice for a Vegas trip, but it's not the worst either. Just keep your expectations in check.

Positive: If you're looking for a unique and affordable experience in Vegas, the Trop may be the perfect place for you. The hallways and rooms have a charming and cozy feel...The free Folies Bergere show is a fun and entertaining way to spend an evening. Overall, it's a great value and an enjoyable stay.

Why is this review not Very positive?

Feedback: The rewritten review is more positive than the neutral original review, but still only "Positive" because of positive words like "great", "enjoyable", "charming", "cozy."...

Figure 35: feedback prompt for Sentiment Reversal (truncated).

Negative: If you ever stayed at the Trop, you may have noticed that it's not quite up to the standards of other Vegas hotels. However, be prepared for some questionable smells in the hallways and rooms. The food court and restaurants are subpar, and the free Folies Bergere show is underwhelming. The rooms have a retirement community feel to them. Overall, it's not the best option, but it may work in a pinch.

Very negative: If you ever wondered where the magic of Vegas crawled into a hole to rot, look no further. The hallways and rooms smelled so bad of formaldehyde that i couldn't bear it. Their food court and restaurants are terrible. The free Folies Bergere show is lame. The rooms look like a retirement community from florida. I highly recommend avoiding the Trop like the plague.

Why is this review not Very negative?

Feedback: The rewritten review is "Very negative". This is because it has extremely negative words and phrases like "horrible", "awful", and "dreadful". The output is extremely vile and negative. This review is already as negative as it can get. Excellent work! But there is always room for more. Make it even more negative. Try again!

Okay, let's try again. Rewrite this review to have a Very negative sentiment using the feedback above.

Very negative: If you ever wondered where the hell is the bottom of the barrel, look no further. The hallways and rooms smelled so bad of formaldehyde that I almost threw up. Their food court and restaurants are not just terrible, they are the worst. The free Folies Bergere show is lame and disgusting. The rooms look like a retirement community from florida. I highly recommend avoiding the Trop like the plague. You will regret it if you don't.

Figure 36: refine prompt for Sentiment Reversal (truncated).