# Graph-enhanced Optimizers for Structure-aware Recommendation Embedding Evolution

 Cong Xu\({}^{\dagger}\) Jun Wang\({}^{\dagger}\) Jianyong Wang \({}^{\lx@sectionsign}\) Wei Zhang\({}^{\dagger}\)

\({}^{\dagger}\)East China Normal University \({}^{\lx@sectionsign}\)Tsinghua University

\({}^{\dagger}\){congxueric, wongjun, zhangwei.thu2011}@gmail.com \({}^{\lx@sectionsign}\)jianyong@tsinghua.edu.cn

Corresponding author. This work was supported in part by National Natural Science Foundation of China (No. 92270119 and No. 62072182) and Shanghai Institute of Artificial Intelligence for Education.

###### Abstract

Embedding plays a key role in modern recommender systems because they are virtual representations of real-world entities and the foundation for subsequent decision-making models. In this paper, we propose a novel embedding update mechanism, Structure-aware Embedding Evolution (SEvo for short), to encourage related nodes to evolve similarly at each step. Unlike GNN (Graph Neural Network) that typically serves as an intermediate module, SEvo is able to directly inject graph structural information into embedding with minimal computational overhead during training. The convergence properties of SEvo along with its potential variants are theoretically analyzed to justify the validity of the designs. Moreover, SEvo can be seamlessly integrated into existing optimizers for state-of-the-art performance. Particularly SEvo-enhanced AdamW with moment estimate correction demonstrates consistent improvements across a spectrum of models and datasets, suggesting a novel technical route to effectively utilize graph structural information beyond explicit GNN modules. Our code is available at [https://github.com/MTandHJ/SEvo](https://github.com/MTandHJ/SEvo).

## 1 Introduction

Surfing Internet leaves footprints such as clicks [15], browsing [5], and shopping histories [58]. For a modern recommender system [6, 12], the entities involved (_e.g._, goods, movies) are typically embedded into a latent space based on these interaction data. As the embedding takes the most to construct and is the foundation to subsequent decision-making models, its modeling quality directly determines the final performance of the entire system. According to the homophily assumption [31, 59], it is natural to expect that related entities have closer representations in the latent space. Note that the similarity between two entities refers specifically to those extracted from interaction data [47] or prior knowledge [37]. For example, goods selected consecutively by the same user or movies of the same genre are often perceived as more relevant. Graph neural networks (GNNs) [2, 10, 14] are a widely adopted technique to exploit such structural information, in concert with a weighted adjacency matrix wherein each entry characterizes how closely two nodes are related. Rather than directly injecting structural information into embedding, GNN typically serves as an intermediate module in the recommender system. However, designing a versatile GNN module suitable for various recommendation scenarios is challenging. This is especially true for sequential recommendation [8, 51], which needs to take into account both structural and sequential information at the same time. Moreover, the post-processing fashion inevitably increases the overhead of training and inference, limiting the scalability for real-time recommendation.

In this work, we aim to directly inject graph structural information into embedding through a novel embedding update mechanism. Figure 1 (a) illustrates a normal embedding evolution process, inwhich the embedding \(\mathbf{E}\) is updated at step \(t\) as follows:

\[\mathbf{E}_{t}\leftarrow\mathbf{E}_{t-1}+\Delta\mathbf{E}_{t-1}. \tag{1}\]

Note that the variation \(\Delta\mathbf{E}\) is primarily determined by the (anti-)gradient. It points to a region able to decrease a loss function concerning recommendation performance [35], but lacks an explicit mechanism to ensure that the variations between related nodes are similar. The embeddings thus cannot be expected to capture model pairwise relations while minimizing the recommendation loss.

Conversely, structural information can be effectively learned if related nodes evolve similarly at each update. The structure-aware embedding evolution (SEvo), depicted in Figure 1 (b), is developed for this goal. A special transformation is applied so as to meet both smoothness and convergence [57]. Given that these two criteria inherently conflict to some extent, we resort to a graph regularization framework [57, 7] to balance them. While analogous frameworks have been used to understand feature smoothing and modify message passing mechanisms for GNNs [28, 60], applying this to variations is not as straightforward as to features [24] or labels [19]. Previous efforts are capable of smoothing, but cannot account for strict convergence. The specific transformation form must be chosen carefully; subtle differences may slow down or even kill training. Through comprehensive theoretical analysis, we develop an applicable solution with a provable convergence guarantee.

Apart from the anti-gradient, the variation \(\Delta\mathbf{E}\) can also be derived from the moment estimates. Therefore, existing optimizers, such as SGD [41] and Adam [23], can benefit from SEvo readily. In contrast to Adam, AdamW [27] decouples the weight decay from the optimization step, making it more compatible with SEvo as it is unnecessary to smooth the weight decay as well. Furthermore, we recorcet the moment estimates of SEvo-enhanced AdamW when encountering sparse gradients. This modification enhances its robustness across a variety of recommendation models and scenarios. Extensive experiments over six public datasets have demonstrated that it can effectively inject structural information to boost recommendation performance. It is important to note that SEvo does not alter the inference logic of the model, so the inference time is exactly the same and very little computational overhead is required during training.

The main contributions of this paper can be summarized as follows. **1)** The graph regularization framework [57, 7] has been widely used for feature/label smoothing. To the best of our knowledge, we are the first to apply it to variations as an alternative to explicit GNN modules for recommendation. **2)** The final formulation of SEvo is non-trivial (previous iterative [57] or Neumann series [39] approximation methods proved to be incompatible in this case) and comes from comprehensive theoretical analyses. **3)** We further present SEvo-enhanced AdamW by integrating SEvo and reconrecting the original moment estimates. These modifications demonstrate consistent performance, yielding average 9%\(\sim\)23% improvements across a spectrum of models. For larger-scale datasets containing millions of nodes, the performance gains can be as high as 40%\(\sim\)139%. **4)** Beyond interaction

Figure 1: Overview of SEvo. (a) Normal embedding evolution. (b) (Section 2) Structure-aware embedding evolution. (c) (Section 2.2) Geometric visualization of the variation from \(\Delta\mathbf{E}\) to \(\psi^{*}(\Delta\mathbf{E})\). The gray ellipse represents the region with proper smoothness. (d) (Section 2.3) The \(L\)-layer approximation with a faster convergence guarantee.

data, we preliminarily explore the pairwise similarity estimation based on other prior knowledge: node categories to promote intra-class representation proximity, and knowledge distillation [18] to encourage a light-weight student to mimic the embedding behaviors of a teacher model.

## 2 Structure-aware Embedding Evolution

In this section, we first introduce some necessary terminology and concepts, in particular smoothness. SEvo and its theoretical analyses will be detailed in Section 2.2 and 2.3. The proofs hereafter are deferred to Appendix A.

### Preliminaries

**Notations and terminology.** Let \(\mathcal{V}=\{v_{1},\ldots,v_{n}\}\) denote a set of nodes and \(\mathbf{A}=[w_{ij}]\in\mathbb{R}^{n\times n}\) a _symmetric_ adjacency matrix, where each entry \(w_{ij}=w_{ji}\) characterizes how closely \(v_{i}\) and \(v_{j}\) are related. They jointly constitute the graph \(\mathcal{G}=(\mathcal{V},\mathbf{A})\). For example, \(\mathcal{V}\) could be a set of movies, and \(w_{ij}\) is the frequency of \(v_{i}\) and \(v_{j}\) being liked by the same user. Denoted by \(\mathbf{D}\in\mathbb{R}^{n\times n}\) the diagonal degree matrix of \(\mathbf{A}\), the normalized adjacency matrix and the corresponding Laplacian matrix are defined as \(\tilde{\mathbf{A}}=\mathbf{D}^{-1/2}\mathbf{A}\mathbf{D}^{-1/2}\) and \(\tilde{\mathbf{L}}=\mathbf{I}-\tilde{\mathbf{A}}\), respectively. For ease of notation, we use \(\langle\cdot,\cdot\rangle\) to denote the inner product, \(\langle\mathbf{x},\mathbf{y}\rangle=\mathbf{x}^{T}\mathbf{y}\) for vectors and \(\langle\mathbf{X},\mathbf{Y}\rangle=\text{Tr}(\mathbf{X}^{T}\mathbf{Y})\) for matrices. Here, \(\text{Tr}(\cdot)\) denotes the trace of a given matrix.

**Smoothness.** Before delving into the details of SEvo, it is necessary to present a metric to measure the smoothness [57; 7] of node features \(\mathbf{X}\) as a whole. Denoted by \(\mathbf{x}_{i},\mathbf{x}_{j}\) the row vectors of \(\mathbf{X}\) and \(d_{i}=\sum_{j}w_{ij}\), we have

\[\mathcal{J}_{smoothness}(\mathbf{X};\mathcal{G}):=\text{Tr}(\mathbf{X}^{T} \tilde{\mathbf{L}}\mathbf{X})=\sum_{i,j\in\mathcal{V}}w_{ij}\left\|\frac{ \mathbf{x}_{i}}{\sqrt{d_{i}}}-\frac{\mathbf{x}_{j}}{\sqrt{d_{j}}}\right\|_{2}^ {2}. \tag{2}\]

This term is often used as graph regularization for feature/label smoothing [24; 19]. A lower \(\mathcal{J}_{smoothness}\) indicates smaller difference between closely related pairs of nodes, and in this case \(\mathbf{X}\) is considered smoother. However, smoothness alone is not sufficient from a performance perspective. Over-emphasizing this indicator instead leads to the well-known over-smoothing issue [26]. How to balance variation smoothness and convergence is the main challenge to be addressed below.

### Methodology

The entities involved in a recommender system are typically embedded into a latent space [6; 12], and the embeddings in \(\mathbf{E}\in\mathbb{R}^{n\times d}\) are expected to be smooth so that related nodes are close to each other. As discussed above, \(\mathbf{E}\) is learnable and updated at step \(t\) by Eq. (1), where the variation \(\Delta\mathbf{E}\) is mainly determined by the (anti-)gradient. For example, \(\Delta\mathbf{E}=-\eta\nabla_{\mathbf{E}}\mathcal{L}\) when gradient descent with a learning rate of \(\eta\) is used to minimize a loss function \(\mathcal{L}\). However, the final embeddings based on this evolution process may be far from sufficient smoothness because: 1) The variation \(\Delta\mathbf{E}\) points to the region able to decrease the loss function concerning recommendation performance, but lacks an explicit smoothness guarantee. 2) As numerous item embeddings (millions of nodes in practice) to be trained together for a recommender system, the variations of two related nodes may be quite different due to the randomness from initialization and mini-batch sampling.

We are to design a special transformation \(\psi(\cdot)\) to smooth the variation so that the evolution deduced from the following update formula is structure-aware,

\[\mathbf{E}_{t}\leftarrow\mathbf{E}_{t-1}+\psi(\Delta\mathbf{E}_{t-1}). \tag{3}\]

Recall that, in this paper, the similarity is confined to quantifiable values in the adjacency matrix \(\mathbf{A}\), in which more related pairs are weighted higher. Therefore, this transformation should encourage pairs of nodes connected with higher weights to evolve more similarly than those connected with lower weights. This can be boiled down to structure-aware transformation as defined below.

**Definition 1** (Structure-aware transformation).: _The transformation \(\psi(\cdot)\) is structure-aware if_

\[\mathcal{J}_{smoothness}(\psi(\Delta\mathbf{E}))\leq\mathcal{J}_{ smoothness}(\Delta\mathbf{E}). \tag{4}\]On the other hand, the transformation must ensure convergence throughout the evolution process, which means that the transformed variation should not differ too much from the original. For the sake of theoretical analysis, the ability to maintain the update direction will be used to _qualitatively_ depict this desirable property below, though a quantitative squared error will be employed later.

**Definition 2** (Direction-aware transformation).: _The transformation \(\psi(\cdot)\) is direction-aware if_

\[\big{\langle}\psi(\Delta\mathbf{E}),\Delta\mathbf{E}\big{\rangle}>0,\quad \forall\,\Delta\mathbf{E}\neq\mathbf{0}. \tag{5}\]

These two criteria inherently conflict to some extent. We resort to a hyperparameter \(\beta\in[0,1)\) to make a trade-off and the desired transformation is the corresponding minimum; that is,

\[\psi^{*}(\Delta\mathbf{E};\beta)=\underset{\Delta}{\text{argmin}}\;(1-\beta)\; \|\Delta-\Delta\mathbf{E}\|_{F}^{2}+\beta\operatorname{Tr}(\Delta^{T}\tilde{ \mathbf{L}}\Delta). \tag{6}\]

A larger \(\beta\) indicates a stronger smoothness constraint and \(\psi^{*}(\Delta\mathbf{E})\) reduces to \(\Delta\mathbf{E}\) when \(\beta\to 0\). Geometrically, as shown in Figure 1 (c), \(\psi^{*}(\Delta\mathbf{E})\) can be interpreted as a projection of \(\Delta\mathbf{E}\) onto the region with proper smoothness. Taking the gradient to zero could give a closed-form solution, but it requires prohibitive arithmetic operations and memory overhead, which is particularly time-consuming in recommendation due to the large number of nodes. Zhou et al. [57] suggested a \(L\)-layer _iterative_ approximation to circumvent this problem (with \(\hat{\psi}_{0}(\Delta\mathbf{E})=\Delta\mathbf{E}\)):

\[\hat{\psi}_{iter}(\Delta\mathbf{E}):=\hat{\psi}_{L}(\Delta\mathbf{E}),\quad \hat{\psi}_{l}(\Delta\mathbf{E})=\beta\tilde{\mathbf{A}}\hat{\psi}_{l-1}( \Delta\mathbf{E})+(1-\beta)\Delta\mathbf{E}.\]

The resulting transformation is essentially a momentum update that aggregates higher-order information layer by layer. Analogous message-passing mechanisms have been used in previous GNNs such as APPNP [24] and C&S [19]. However, this commonly used approximate solution is incompatible with SEvo; sometimes, variations after the transformation may be opposite to the original direction, resulting in a failure to converge.

**Theorem 1**.: _The iterative approximation is direction-aware for all possible normalized adjacency matrices and \(L\geq 0\), if and only if \(\beta<1/2\). In contrast, the Neumann series approximation \(\hat{\psi}_{nsa}(\Delta\mathbf{E})=(1-\beta)\sum_{l=0}^{L}\beta^{l}\tilde{ \mathbf{A}}^{l}\Delta\mathbf{E}\) is structure-aware and direction-aware for any \(\beta\in[0,1)\)._

As suggested in Theorem 1, a feasible compromise for \(\hat{\psi}_{iter}\) is to restrict \(\beta\) to \([0,1/2)\), but this may cause a lack of smoothness. The Neumann series approximation [39] appears to be a viable alternative as it qualitatively satisfies both desirable properties. Nonetheless, this transformation can be further improved for a faster convergence rate based on the analysis presented next.

### Convergence Analysis for Further Modification

In general, the recommender system has some additional parameters \(\boldsymbol{\theta}\in\mathbb{R}^{m}\) except for embedding to be trained. Therefore, we analyze the convergence rate of the following gradient descent strategy:

\[\mathbf{E}_{t+1}\leftarrow\mathbf{E}_{t}-\eta\hat{\psi}_{nsa}\big{(}\nabla_{ \mathbf{E}}\mathcal{L}(\mathbf{E}_{t},\boldsymbol{\theta}_{t})\big{)},\quad \boldsymbol{\theta}_{t+1}\leftarrow\boldsymbol{\theta}_{t}-\eta^{\prime}\nabla _{\boldsymbol{\theta}}\mathcal{L}(\mathbf{E}_{t},\boldsymbol{\theta}_{t}),\]

wherein SEvo is performed on the embedding and a normal gradient descent is applied to \(\boldsymbol{\theta}\). To make the analysis feasible, some mild assumptions on the loss function should be given: \(\mathcal{L}:\mathbb{R}^{n\times d}\times\mathbb{R}^{m}\rightarrow\mathbb{R}\) is a twice continuously differentiable function whose first derivative is Lipschitz continuous for some constant \(C\). Then, we obtain the following properties.

**Theorem 2** (Informal).: _If \(\eta=\eta^{\prime}=1/C\), the convergence rate after \(T\) updates is \(\mathcal{O}(C/((1-\beta)^{2}T))\). If we adopt a modified learning rate of \(\eta=\frac{1}{(1-\beta^{L+1})C}\) for embedding, the convergence rate could be improved to \(\mathcal{O}(C/((1-\beta)T))\)._

**Remark 1**.: _Our main interest is to justify the designs of SEvo rather than to pursue a particular convergence rate, so some mild assumptions suggested in [32] are adopted here. By introducing the steepest descent for quadratic norms [1], better convergence can be obtained with stronger assumptions._

Two conclusions can be drawn from Theorem 2. **1)** The theoretical upper bound becomes worse when \(\beta\to 1\). This makes sense since \(\hat{\psi}_{nsa}(\nabla_{\mathbf{E}}\mathcal{L})\) is getting smoother and further away from the original descent direction. **2)** A modified learning rate for embedding can significantly improve the convergence rate. This phenomenon can be understood readily if we notice the fact that

\[\|\hat{\psi}_{nsa}(\Delta\mathbf{E})\|_{F}\leq(1-\beta^{L+1})\|\Delta\mathbf{E}\|_ {F}.\]

Thus, the modified learning rate is indeed to offset the _scaling effect_ induced by SEvo. In view of this, we directly incorporate this factor into SEvo to avoid getting stuck in the learning rate search, yielding the final desired transformation:

\[\hat{\psi}(\Delta\mathbf{E};\beta)=\frac{1-\beta}{1-\beta^{L+1}}\sum_{l=0}^{L} \beta^{l}\tilde{\mathbf{A}}^{l}\Delta\mathbf{E}. \tag{7}\]

It can be shown that \(\hat{\psi}\) is structure-aware and direction-aware, and converges to \(\psi\) as \(L\) increases.

### Integrating SEvo into Existing Optimizers

```
embedding matrix \(\mathbf{E}\), learning rate \(\eta\), momentum factors \(\beta_{1},\beta_{2},\beta\in[0,1)\), weight decay \(\lambda\). foreachstep \(t\)do \(\mathbf{G}_{t}\leftarrow\nabla_{\mathbf{E}}\mathcal{L}\) // Get gradients w.r.t \(\mathbf{E}\)  Update first/second moment estimates for each node \(i\): \[\mathbf{M}_{t}[i]\leftarrow\left\{\begin{array}{ll}\beta_{1}\mathbf{M}_{t-1} [i]+(1-\beta_{1})\mathbf{G}_{t}[i]&\text{if }\mathbf{G}_{t}[i]\neq\mathbf{0}\\ \beta_{1}\mathbf{M}_{t-1}[i]+\frac{(1-\beta_{1})}{1-\beta_{1}^{t-1}}\mathbf{M}_ {t-1}[i]&\text{otherwise}\end{array}\right.,\] \[\mathbf{V}_{t}[i]\leftarrow\left\{\begin{array}{ll}\beta_{2} \mathbf{V}_{t-1}[i]+(1-\beta_{2})\mathbf{G}_{t}^{2}[i]&\text{if }\mathbf{G}_{t}[i]\neq\mathbf{0}\\ \beta_{2}\mathbf{V}_{t-1}[i]+\frac{(1-\beta_{2})}{1-\beta_{2}^{t-1}}\mathbf{V}_ {t-1}[i]&\text{otherwise}\end{array}\right.;\]  Compute bias-corrected first/second moment estimates: \[\hat{\mathbf{M}}_{t}\leftarrow\mathbf{M}_{t}/(1-\beta_{1}^{t}),\quad\hat{ \mathbf{V}}_{t}\leftarrow\mathbf{V}_{t}/(1-\beta_{2}^{t});\] Update via SEvo: \[\mathbf{E}_{t}\leftarrow\mathbf{E}_{t-1}-\eta\;\hat{\psi}\bigg{(}\,\hat{ \mathbf{M}}_{t}/\sqrt{\hat{\mathbf{V}}_{t}+\epsilon};\beta\bigg{)}-\eta\lambda \mathbf{E}_{t-1}.\]

Output: optimized embeddings \(\mathbf{E}\).
```

**Algorithm 1** SEvo-enhanced AdamW. Differences from the original AdamW are colored in blue. The matrix operation below are element-wise.

SEvo can be seamlessly integrated into existing optimizers since the variation involved in Eq. (3) can be extended beyond the (anti-)gradient. For SGD with momentum, the variation becomes the first moment estimate, and for Adam this is jointly determined by the first/second moment estimates. AdamW is also widely adopted for training recommenders. Unlike Adam whose moment estimate is a mixture of gradient and weight decay, AdamW decouples the weight decay from the optimization step, which is preferable since it makes no sense to require the weight decay to be smooth as well. However, in very rare cases, SEvo-enhanced AdamW fails to work very well. We next try to ascertain the causes and then improve the robustness of SEvo-enhanced AdamW.

Denoted by \(\mathbf{g}:=\nabla_{\mathbf{e}}\mathcal{L}\in\mathbb{R}^{d}\) the gradient for a node embedding \(\mathbf{e}\) and \(\mathbf{g}^{2}:=\mathbf{g}\odot\mathbf{g}\) the element-wise square, AdamW estimates the first and second moments at step \(t\) using the following formulas

\[\mathbf{m}_{t}=\beta_{1}\mathbf{m}_{t-1}+(1-\beta_{1})\mathbf{g}_{t-1},\quad \mathbf{v}_{t}=\beta_{2}\mathbf{v}_{t-1}+(1-\beta_{2})\mathbf{g}_{t-1}^{2},\]

where \(\beta_{1},\beta_{2}\) are two momentum factors. Then the original AdamW updates embeddings by

\[\mathbf{e}_{t}=\mathbf{e}_{t-1}-\eta\cdot\Delta\mathbf{e}_{t-1},\quad\Delta \mathbf{e}_{t-1}:=\hat{\mathbf{m}}_{t}/\sqrt{\hat{\mathbf{v}}_{t}}.\]

Note that the bias-corrected estimates \(\hat{\mathbf{m}}_{t}=\mathbf{m}_{t}/(1-\beta_{1}^{t})\) and \(\hat{\mathbf{v}}_{t}=\mathbf{v}_{t}/(1-\beta_{2}^{t})\) are employed for numerical stability [23]. In practice, only a fraction of nodes are sampled for training in a mini-batch, so the remaining embeddings have zero gradients. In this case, the sparse gradient problem may introduce some unexpected 'biases' as depicted below.

**Proposition 1**.: _If a node is no longer sampled in subsequent \(p\) batches after step \(t\), we have \(\Delta\mathbf{e}_{t+p-1}=\kappa\cdot\frac{\beta_{1}^{t}}{\sqrt{\beta_{2}^{t}}} \Delta\mathbf{e}_{t-1}\), and the coefficient of \(\kappa\) is mainly determined by \(t\)._

Considering a common case \(\beta_{2}\approx\beta_{1}\), the right-hand side approaches \(\mathcal{O}(\beta_{1}^{p/2})\). The step size for inactive nodes then gets slower and slower during idle periods. This seems reasonable as their moment estimates are becoming outdated; however, this effect sometimes prevents the variation from being smoothed by SEvo. We hypothesize that this is because SEvo itself tends to assign more energy to active nodes and less energy to inactive nodes. So this auto-attenuation effect of the original AdamW is somewhat redundant. Fortunately, there is a feasible modification to make SEvo-enhanced AdamW more robust:

**Theorem 3**.: _Under the same assumptions as in Proposition 1, \(\Delta\mathbf{e}_{t+p-1}=\Delta\mathbf{e}_{t-1}\) if the moment estimates are updated in the following manner when \(\mathbf{g}_{t}=\mathbf{0}\),_

\[\mathbf{m}_{t}=\beta_{1}\mathbf{m}_{t-1}+(1-\beta_{1})\frac{1}{1-\beta_{1}^{t -1}}\mathbf{m}_{t-1},\quad\mathbf{v}_{t}=\beta_{2}\mathbf{v}_{t-1}+(1-\beta_{ 2})\frac{1}{1-\beta_{2}^{t-1}}\mathbf{v}_{t-1}. \tag{8}\]

As can be seen, when sparse gradients are encountered, the approach in Theorem 3 is actually to estimate the current gradient from previous moments. The coefficients \(1/(1-\beta_{1}^{t-1})\) and \(1/(1-\beta_{1}^{t-1})\) are used here for unbiasedness (refer to Appendix A.3 for detailed discussion and proofs). We summarize the SEvo-enhanced AdamW in Algorithm 1 and the modifications for Adam and SGD in Appendix B.1, with an empirical comparison presented in Section 3.3.

The previous discussion lays the technical basis for injecting graph structural information, but the final recommendation performance is determined by how 'accurate' the similarity estimation is. Following other GNN-based sequence models [48; 49], the number of consecutive occurrences across all sequences will be used as the pairwise similarity \(w_{ij}\). In other words, items \(v_{i}\) and \(v_{j}\) that appear consecutively more frequently are assumed more related. Notably, we would like to emphasize that SEvo can readily inject other types of knowledge beyond interaction data. We have made some preliminary efforts in Appendix C and observed some promising results.

## 3 Experiments

In this section, we comprehensively verify the superiority of SEvo. We focus on sequential recommendation for two reasons: 1) This is the most common scenario in practice; 2) Utilizing both sequential and structural information is beneficial yet challenging. We showcase that SEvo is a promising way to achieve this goal. It is worth noting that although technically SEvo can be applied to general graph embedding learning [4], we contend SEvo-AdamW is especially useful for mitigating the inconsistent embedding evolution caused by data sparsity, while effectively injecting structural information in conjunction with other types of information.

Due to space constraints, this section presents only the primary results concerning accuracy, efficiency, and some empirical evidence that supports the aforementioned claims. We begin by introducing the datasets, evaluation metrics, baselines, and implementation details.

**Datasets.** Six benchmark datasets are considered in this paper. The first four datasets including Beauty, Toys, Tools, and MovieLens-1M are commonly employed in previous studies for empirical comparisons. Additionally, two larger-scale datasets, Clothing and Electronics, are used to assess SEvo's scalability in scenarios involving millions of nodes. Following [22; 13], we filter out users and items with less than 5 interactions, and the validation set and test set are split in a _leave-one-out_ fashion, namely the last interaction for testing and the penultimate one for validation. This splitting allows for fair comparisons, either for sequential recommendation or collaborative filtering. The dataset statistics are presented in Table 1.

**Evaluation metrics.** For each user, the predicted scores over _all items_ will be sorted in descending order to generate top-N candidate lists. We consider two widely-used evaluation metrics, HR@N

\begin{table}
\begin{tabular}{c|c c c c} \hline \hline Dataset & \#Users & \#items & \#interactions & Avg. Len. \\ \hline Beauty & 22,363 & 12,101 & 198,502 & 8.9 \\ Toys & 19,412 & 11,924 & 167,597 & 8.6 \\ Tools & 16,638 & 10,217 & 134,476 & 8.1 \\ MovieLens-1M & 6,040 & 3,416 & 999,611 & 165.5 \\ \hline Electronics & 728,489 & 159,729 & 6,737,580 & 9.24 \\ Clothing & 1,219,337 & 376,378 & 11,282,445 & 9.25 \\ \hline \hline \end{tabular}
\end{table}
Table 1: Dataset statistics

[MISSING_PAGE_FAIL:7]

Secondly, either dynamic graph construction in SR-GNN and LESSR, or path sampling in MAERec, requires heavy computational overhead, which directly causes the training failures on large-scale datasets like Electronics and Clothing. Even worse, these high costs associated with SR-GNN and LESSR are inevitable during inference. In contrast, SEvo does not alter the model inference logic at all, thereby maintaining consistent inference time. The computational overhead required in training is also negligible compared to previous graph-enhanced models that employ GNNs as intermediate modules. For example, SASRec with SEvo consumes only 10 minutes compared to the hours of training time required for MAERec. When millions of nodes are encountered in Table 3, each epoch demands just a few more seconds. SEvo is arguably superior to these cumbersome GNN modules in real-world applications. Combining Table 2 and Table 3, it can be inferred that the performance gain increases as the number of items increases. This can be explained by the fact that the randomness of sampling leads to a much more inconsistent evolution when more and more nodes are encountered [56]. SEvo thus plays an increasingly important role as it is capable of imposing direct consistency constraints on embeddings.

Since SASRec is a pioneer in the field of sequential recommendation, it will serve as the default backbone for subsequent studies.

### Empirical Analysis

**Convergence comparison.** In Section 2.3, we theoretically verified the necessity of rescaling the original Neumann series approximation for faster convergence. Figure 1(a) shows the loss curves of SASRec trained with AdamW under identical settings other than the form of SEvo. Without rescaling, SASRec exhibits significantly slower convergence, consistent with the conclusion in Theorem 2. While the theoretical worst-case convergence rate of the corrected SEvo is only 1% of the normal gradient descent when \(\beta=0.99\), its practical performance is much better. SASRec trained with SEvo-enhanced AdamW initially converges marginally slower and catches up in the final stage.

\begin{table}
\begin{tabular}{l l||c c|c} \hline \hline  & & \multicolumn{2}{c}{SASRec} & \multirow{2}{*}{**\%**} \\  & & & \multicolumn{2}{c}{+SEvo} & \multicolumn{1}{c}{} \\ \hline \multirow{4}{*}{**Sevo**} & HR@1 & 0.0033 & **0.0063** & +92.5\% \\  & HR@10 & 0.0208 & **0.0293** & +40.6\% \\  & NDCG@10 & 0.0103 & **0.0159** & +53.9\% \\  & Time/Epoch & 19.94s & +2.22s & \\  & Epochs & 100 & 150 & \\ \hline \multirow{4}{*}{**Sevo**} & HR@1 & 0.0071 & **0.0171** & +139.1\% \\  & HR@10 & 0.0360 & **0.0626** & +73.9\% \\  & NDCG@10 & 0.0199 & **0.0377** & +89.1\% \\  & Time/Epoch & 25.20s & +8.27s & \\ \cline{1-1}  & Epochs & 400 & 300 & \\ \hline \hline \end{tabular}
\end{table}
Table 3: SEvo on large-scale datasets.

Figure 2: Empirical illustrations of convergence and smoothness. The top and bottom panels respectively depict the results for Beauty and MovieLens-1M. (a) SASRec enhanced by SEvo with or without rescaling. (b) Smoothness of (I) the original variation; (II) the smoothed variation; (III) the optimized embedding. A lower \(\mathcal{J}_{smoothness}\) indicates stronger smoothness.

**Smoothness evaluation.** Figure 1(b) demonstrates the variation's smoothness throughout the evolution process and the eventual embedding differences from \(\beta=0\) to \(\beta=0.999\). **(I) \(\rightarrow\) (II):** The original variations exhibit a similar degree of smoothness, but after transformation, they are quite different--smoother as \(\beta\) increases. **(II) \(\rightarrow\) (III):** Consequently, the embedding trained with a stronger smoothness constraint becomes smoother as well. The structure-aware embedding evolution successfully makes related nodes closer in the latent space. Although smoothness is not the sole quality measure of embedding, combined with the analyses above, we can conclude that SEvo injects appropriate structural information under the default setting of \(\beta=0.99\).

### Ablation Study

**SEvo for various optimizers.** It is of interest to study whether SEvo can be extended to other commonly used optimizers such as SGD and Adam. Figure 2(a) compares NDCG@10 performance on Beauty and MovieLens-1M. For a fair comparison, the hyperparameters are tuned independently. It is evident that the performance of SGD, Adam, and AdamW improves significantly after integrating SEvo, with AdamW achieving the best as it does not need to smooth the weight decay.

**Neumann series approximation versus iterative approximation.** Theorem 1 suggests that the Neumann series approximation is preferable to the commonly used iterative approximation because the latter is not always direction-aware and thus a conservative hyperparameter of \(\beta\) is needed to ensure convergence. This conclusion can also be drawn from Figure 2(b). When only a little smoothness is required, their performance is comparable as both approximations differ only at the last term. The iterative approximation however fails to ensure convergence once \(\beta>0.7\) on the Beauty dataset, potentially resulting in a lack of smoothness.

**Moment estimate correction for AdamW.** We compare SEvo-enhanced AdamW with or without moment estimate correction in Figure 2(c), in which average relative improvements against the baseline are presented for each recommender. Overall, the two variants of SEvo-enhanced AdamW perform comparably, significantly surpassing the baseline. However, in some cases (_e.g._, GRU4Rec and STOSA), the moment estimate correction as suggested in Theorem 3 is particularly useful to improve performance. Recall that BERT4Rec is trained using the output softmax from a separate fully-connected layer that is fully updated at each step. This may explain why the correction has little effect on BERTRec. In conclusion, the results underscore the importance of the proposed modification in alleviating bias in moment estimates.

### Applications of SEvo Beyond Interaction Data

We further explore the potential of applying SEvo to other types of prior knowledge. On the one hand, the category smoothness constraint can also be fulfilled through SEvo (see Appendix C.2), leading to progressively stronger clustering effects as \(\beta\) increases. This provides compelling visual evidence of why SEvo is inherently structure-aware. On the other hand, SEvo is arguably an efficient tool for transferring embedding knowledge (see Appendix C.3). Notice that the learning of other modules cannot be guided in the same way, so SEvo alone is still inferior to state-of-the-art knowledge distillation methods [21, 55]. Fortunately, SEvo and other methods can work together to further boost the recommendation performance.

Figure 3: SEvo ablation experiments.

Related Work

**Recommender systems** are developed to enable users to quickly and accurately find relevant items in diverse applications, such as e-commerce [58], online news [15] and social media [5]. Typically, the entities involved are embedded into a latent space [6; 12; 54], and then decision models are built on top of the embedding for tasks like collaborative filtering [16] and context/knowledge-aware recommendation [46; 44]. Sequential recommendation [36; 25] focuses on capturing users' dynamic interests from their historical interaction sequences. Early approaches adapted recurrent neural networks (RNNs) [17] and convolutional filters [42] for sequence modeling. Recently, Transformer [45; 11] has become a popular architecture for sequence modeling due to its parallel efficiency and superior performance. SASRec [22] and BERT4Rec [40] use unidirectional and bidirectional self-attention, respectively. Fan et al. [13] proposed a novel stochastic self-attention (STOSA) to model the uncertainty of sequential behaviors.

**Graph neural networks**[2; 10] are a type of neural network designed to operate on graph-structured data, in concert with a weighted adjacency matrix to characterize the pairwise relations between nodes. GNN equipped with this adjacency matrix can be used for message passing between nodes. The most relevant work is the optimization framework proposed in [57] for solving semi-supervised learning problems via a smoothness constraint. This graph regularization approach has recently inspired a series of work [7; 28; 60]. As opposed to applying it to smooth node representations [24] or labels [19], it is employed here primarily to balance smoothness and convergence on the variation.

**Structural information** in recommendation is typically learned through GNN as well, with specific modifications made to cope with like data sparsity [52; 29]. LightGCN [16] is a pioneering collaborative filtering work on modeling user-item relations, which removes nonlinearities for easier training. To further utilize sequential information, previous efforts focus on equipping sequence models with complex GNN modules, but this inevitably increases the computational cost of training and inference, making it unappealing for practical recommendation. For example, SR-GNN [48] and LESSR [8] need dynamically construct adjacency matrices for each batch of sequences. Differently, MAERec [51] proposes an adaptive data augmentation to boost a novel graph masked autoencoder, which learns to sample less noisy paths from semantic similarity graph for subsequent reconstruction tasks. The resulting strong self-supervision signals help the model capture more useful information.

## 5 Broader Impact and Limitations

Utilizing both sequential and structural information is beneficial yet challenging, and SEvo proposed in this paper suggests a novel and effective technical route for this purpose. Compared to other explicit GNN modules, SEvo is light-weight and easy-to-use in practice. These insights may inspire future research efforts regarding structure-aware optimization. However, there are still some limitations. Firstly, the training-free nature of SEvo makes it versatile, but also limits the expressive power. For a specific task, a sophisticated GNN module may be more desirable for achieving higher recommendation accuracy. Secondly, it might not be so straightforward to apply SEvo to the scenario involving multiple types of prior knowledge. Some efforts [43; 33] in the field of multiple graph learning have proposed some technically feasible solutions. However, these approaches still encounter challenges in terms of efficiency, particularly in the context of recommendation systems.

## 6 Conclusion and Future Work

In this work, we have proposed a novel update mechanism for injecting graph structural information into embedding. Theoretical analyses of the convergence properties motivate some necessary modifications to the proposed method. SEvo can be seamlessly integrated into existing optimizers. For AdamW, we recorrect the moment estimates to make it more robust. Besides, an interesting direction for future work is extending SEvo to multiplex heterogeneous graphs [3], as real-world entities often participate in various relation networks. Furthermore, we believe that SEvo holds potential for application to dynamic graph structures and incremental updates [53]. Two challenges may be encountered in practice: the computational overhead associated with the ongoing adjacency matrix normalization, and how to adaptively weaken the outdated historical information.

## References

* [1] Stephen P Boyd and Lieven Vandenberghe. _Convex optimization_. Cambridge university press, 2004.
* [2] Joan Bruna, Wojciech Zaremba, Arthur Szlam, and Yann LeCun. Spectral networks and locally connected networks on graphs. In _International Conference on Learning Representations (ICLR)_, 2014.
* [3] Yukuo Cen, Xu Zou, Jianwei Zhang, Hongxia Yang, Jingren Zhou, and Jie Tang. Representation learning for attributed multiplex heterogeneous network. In _ACM SIGKDD International Conference on Knowledge Discovery & Data Mining (KDD)_, pages 1358-1368, 2019.
* [4] Ines Chami, Adva Wolf, Da-Cheng Juan, Frederic Sala, Sujith Ravi, and Christopher Re. Low-dimensional hyperbolic knowledge graph embeddings. In _Annual Meeting of the Association for Computational Linguistics (ACL)_, pages 6901-6914. ACL, 2020.
* [5] Jiajia Chen, Xin Xin, Xianfeng Liang, Xiangnan He, and Jun Liu. Gdsrec: Graph-based decentralized collaborative filtering for socialrecommendation. _IEEE Transactions on Knowledge and Data Engineering (TKDE)_, 2022.
* [6] Qiwei Chen, Huan Zhao, Wei Li, Pipei Huang, and Wenwu Ou. Behavior sequence transformer for e-commerce recommendation in alibaba. In _Proceedings of the 1st International Workshop on Deep Learning Practice for High-dimensional Sparse Data_, pages 1-4, 2019.
* [7] Siheng Chen, Aliaksei Sandryhaila, Jose MF Moura, and Jelena Kovacevic. Signal denoising on graphs via graph filtering. In _IEEE Global Conference on Signal and Information Processing (GlobalSIP)_, pages 872-876. IEEE, 2014.
* [8] Tianwen Chen and Raymond Chi-Wing Wong. Handling information loss of graph neural networks for session-based recommendation. In _ACM SIGKDD International Conference on Knowledge Discovery & Data Mining (KDD)_, pages 1172-1180, 2020.
* [9] Kyunghyun Cho, Bart van Merrienboer, Dzmitry Bahdanau, and Yoshua Bengio. On the properties of neural machine translation: Encoder-decoder approaches. In _Proceedings of SSST@EMNLP 2014, Eighth Workshop on Syntax, Semantics and Structure in Statistical Translation_, pages 103-111. ACL, 2014.
* [10] Michael Defferrard, Xavier Bresson, and Pierre Vandergheynst. Convolutional neural networks on graphs with fast localized spectral filtering. In _Advances in Neural Information Processing Systems (NeurIPS)_, volume 29, 2016.
* [11] Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. BERT: pre-training of deep bidirectional transformers for language understanding. In _Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (NAACL-HLT)_, pages 4171-4186. ACL, 2019.
* [12] Ahmed El-Kishky, Thomas Markovich, Serim Park, Chetan Verma, Baekjin Kim, Ramy Eskander, Yury Malkov, Frank Portman, Sofia Samaniego, Ying Xiao, et al. Twhin: Embedding the twitter heterogeneous information network for personalized recommendation. In _ACM SIGKDD International Conference on Knowledge Discovery & Data Mining (KDD)_, pages 2842-2850, 2022.
* [13] Ziwei Fan, Zhiwei Liu, Yu Wang, Alice Wang, Zahra Nazari, Lei Zheng, Hao Peng, and Philip S Yu. Sequential recommendation via stochastic self-attention. In _ACM Web Conference (WWW)_, pages 2036-2047, 2022.
* [14] Justin Gilmer, Samuel S Schoenholz, Patrick F Riley, Oriol Vinyals, and George E Dahl. Neural message passing for quantum chemistry. In _International Conference on Machine Learning (ICML)_, pages 1263-1272. PMLR, 2017.
* [15] Shansan Gong and Kenny Q Zhu. Positive, negative and neutral: Modeling implicit feedback in session-based news recommendation. In _International ACM Conference on Research and Development in Information Retrieval (SIGIR)_, 2022.
* [16] Xiangnan He, Kuan Deng, Xiang Wang, Yan Li, Yongdong Zhang, and Meng Wang. Lightgcn: Simplifying and powering graph convolution network for recommendation. In _International ACM Conference on Research and Development in Information Retrieval (SIGIR)_, pages 639-648, 2020.

* [17] Balazs Hidasi, Alexandros Karatzoglou, Linas Baltrunas, and Domonkos Tikk. Session-based recommendations with recurrent neural networks. In _International Conference on Learning Representations (ICLR)_, 2016.
* [18] Geoffrey E. Hinton, Oriol Vinyals, and Jeffrey Dean. Distilling the knowledge in a neural network. _CoRR_, abs/1503.02531, 2015.
* [19] Qian Huang, Horace He, Abhay Singh, Ser-Nam Lim, and Austin R. Benson. Combining label propagation and simple models out-performs graph neural networks. In _International Conference on Learning Representations (ICLR)_, 2021.
* [20] Tony Jebara, Jun Wang, and Shih-Fu Chang. Graph construction and b-matching for semi-supervised learning. In _International Conference on Machine Learning (ICML)_, pages 441-448, 2009.
* [21] SeongKu Kang, Junyoung Hwang, Wonbin Kweon, and Hwanjo Yu. Topology distillation for recommender system. In _ACM SIGKDD Conference on Knowledge Discovery and Data Mining_, pages 829-839. ACM, 2021.
* [22] Wang-Cheng Kang and Julian McAuley. Self-attentive sequential recommendation. In _IEEE International Conference on Data Mining (ICDM)_, pages 197-206. IEEE, 2018.
* [23] Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In _International Conference on Learning Representations (ICLR)_, 2015.
* [24] Johannes Klicpera, Aleksandar Bojchevski, and Stephan Gunnemann. Predict then propagate: Graph neural networks meet personalized pagerank. In _International Conference on Learning Representations (ICLR)_, 2019.
* [25] Jiacheng Li, Yujie Wang, and Julian McAuley. Time interval aware self-attention for sequential recommendation. In _International Conference on Web Search and Data Mining (WSDM)_, pages 322-330, 2020.
* [26] Qimai Li, Zhichao Han, and Xiao-Ming Wu. Deeper insights into graph convolutional networks for semi-supervised learning. In _Conference on Artificial Intelligence (AAAI)_, 2018.
* [27] Ilya Loshchilov and Frank Hutter. Decoupled weight decay regularization. In _International Conference on Learning Representations (ICLR)_, 2018.
* [28] Yao Ma, Xiaorui Liu, Tong Zhao, Yozen Liu, Jiliang Tang, and Neil Shah. A unified view on graph neural networks as graph signal denoising. In _ACM International Conference on Information and Knowledge Management (CIKM)_, pages 1202-1211, 2021.
* [29] Kelong Mao, Jieming Zhu, Xi Xiao, Biao Lu, Zhaowei Wang, and Xiuqiang He. UltraGCN: Ultra simplification of graph convolutional networks for recommendation. In _International Conference on Information and Knowledge Management (CIKM)_, 2021.
* [30] Leland McInnes, John Healy, and James Melville. Umap: Uniform manifold approximation and projection for dimension reduction. _arXiv preprint arXiv:1802.03426_, 2018.
* [31] Miller McPherson, Lynn Smith-Lovin, and James M Cook. Birds of a feather: Homophily in social networks. _Annual Review of Sociology_, pages 415-444, 2001.
* [32] Yurii Nesterov. Introductory lectures on convex programming volume i: Basic course. _Lecture notes_, 3(4):5, 1998.
* [33] Feiping Nie, Jing Li, and Xuelong Li. Self-weighted multiview clustering with multiple graphs. In _International Joint Conference on Artificial Intelligence (IJCAI)_, pages 2564-2570, 2017.
* [34] Wonpyo Park, Dongju Kim, Yan Lu, and Minsu Cho. Relational knowledge distillation. In _IEEE Conference on Computer Vision and Pattern Recognition (CVPR)_, pages 3967-3976. IEEE, 2019.
* [35] Steffen Rendle, Christoph Freudenthaler, Zeno Gantner, and Schmidt-Thieme Lars. Bpr: Bayesian personalized ranking from implicit feedback. In _Conference on Uncertainty in Artificial Intelligence (UAI)_, 2009.
* [36] Guy Shani, David Heckerman, Ronen I Brafman, and Craig Boutilier. An mdp-based recommender system. _Journal of Machine Learning Research (JMLR)_, 6(9), 2005.
* [37] Kartik Sharma, Yeon-Chang Lee, Sivagami Nambi, Aditya Salian, Shlok Shah, Sang-Wook Kim, and Srijan Kumar. A survey of graph neural networks for social recommender systems. _arXiv preprint arXiv:2212.04481_, 2022.

* [38] Daniel A Spielman. Spectral graph theory and its applications. In _Annual IEEE Symposium on Foundations of Computer Science (FOCS'07)_, pages 29-38. IEEE, 2007.
* [39] Gilbert W Stewart. _Matrix algorithms: volume 1: basic decompositions_. SIAM, 1998.
* [40] Fei Sun, Jun Liu, Jian Wu, Changhua Pei, Xiao Lin, Wenwu Ou, and Peng Jiang. Bert4rec: Sequential recommendation with bidirectional encoder representations from transformer. In _ACM International Conference on Information and Knowledge Management (CIKM)_, pages 1441-1450, 2019.
* [41] Ilya Sutskever, James Martens, George Dahl, and Geoffrey Hinton. On the importance of initialization and momentum in deep learning. In _International Conference on Machine Learning (ICML)_, pages 1139-1147. PMLR, 2013.
* [42] Jiaxi Tang and Ke Wang. Personalized top-n sequential recommendation via convolutional sequence embedding. In _ACM International Conference on Web Search and Data Mining (WSDM)_, pages 565-573. ACM, 2018.
* [43] Wei Tang, Zhengdong Lu, and Inderjit S Dhillon. Clustering with multiple graphs. In _IEEE International Conference on Data Mining (ICDM)_, pages 1016-1021. IEEE, 2009.
* [44] Zhen Tian, Ting Bai, Wayne Xin Zhao, Ji-Rong Wen, and Zhao Cao. Eulemet: Adaptive feature interaction learning via euler's formula for CTR prediction. In _International ACM SIGIR Conference on Research and Development in Information Retrieval (SIGIR)_, pages 1376-1385. ACM, 2023.
* [45] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. In _Advances in Neural Information Processing Systems (NeurIPS)_, volume 30, 2017.
* [46] Xiang Wang, Xiangnan He, Yixin Cao, Meng Liu, and Tat-Seng Chua. Kgat: Knowledge graph attention network for recommendation. In _ACM SIGKDD International Conference on Knowledge Discovery & Data Mining (KDD)_, pages 950-958, 2019.
* [47] Yu Wang, Yuying Zhao, Yi Zhang, and Tyler Derr. Collaboration-aware graph convolutional network for recommender systems. In _ACM Web Conference (WWW)_, pages 91-101, 2023.
* [48] Shu Wu, Yuyuan Tang, Yanqiao Zhu, Liang Wang, Xing Xie, and Tieniu Tan. Session-based recommendation with graph neural networks. In _Conference on Artificial Intelligence (AAAI)_, volume 33, pages 346-353, 2019.
* [49] Xin Xia, Hongzhi Yin, Junliang Yu, Qinyong Wang, Lizhen Cui, and Xiangliang Zhang. Self-supervised hypergraph convolutional networks for session-based recommendation. In _Conference on Artificial Intelligence (AAAI)_, volume 35, pages 4503-4511, 2021.
* [50] Cong Xu, Jun Wang, and Wei Zhang. Stablegcn: Decoupling and reconciling information propagation for collaborative filtering. _IEEE Transactions on Knowledge and Data Engineering (TKDE)_, 2023.
* [51] Yaowen Ye, Lianghao Xia, and Chao Huang. Graph masked autoencoder for sequential recommendation. In _International ACM Conference on Research and Development in Information Retrieval (SIGIR)_, pages 321-330. ACM, 2023.
* [52] Rex Ying, Ruining He, Kaifeng Chen, Pong Eksombatchai, William L Hamilton, and Jure Leskovec. Graph convolutional neural networks for web-scale recommender systems. In _ACM SIGKDD International Conference on Knowledge Discovery & Data Mining (KDD)_, pages 974-983, 2018.
* [53] Jiaxuan You, Tianyu Du, and Jure Leskovec. Roland: graph learning framework for dynamic graphs. In _ACM SIGKDD International Conference on Knowledge Discovery & Data Mining (KDD)_, pages 2358-2366, 2022.
* [54] Shengyu Zhang, Fuli Feng, Kun Kuang, Wenqiao Zhang, Zhou Zhao, Hongxia Yang, Tat-Seng Chua, and Fei Wu. Personalized latent structure learning for recommendation. _IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI)_, 2023.
* [55] Borui Zhao, Quan Cui, Renjie Song, Yiyu Qiu, and Jiajun Liang. Decoupled knowledge distillation. In _IEEE Conference on Computer Vision and Pattern Recognition (CVPR)_, pages 11943-11952. IEEE, 2022.

* [56] Wayne Xin Zhao, Zihan Lin, Zhichao Feng, Pengfei Wang, and Ji-Rong Wen. A revisiting study of appropriate offline evaluation for top-n recommendation algorithms. _ACM Transactions on Information Systems (TOIS)_, 41(2):1-41, 2022.
* [57] Dengyong Zhou, Olivier Bousquet, Thomas Lal, Jason Weston, and Bernhard Scholkopf. Learning with local and global consistency. _Advances in Neural Information Processing Systems (NeurIPS)_, 16, 2003.
* [58] Guorui Zhou, Xiaoqiang Zhu, Chenru Song, Ying Fan, Han Zhu, Xiao Ma, Yanghui Yan, Junqi Jin, Han Li, and Kun Gai. Deep interest network for click-through rate prediction. In _ACM SIGKDD International Conference on Knowledge Discovery & Data Mining (KDD)_, pages 1059-1068, 2018.
* [59] Jiong Zhu, Yujun Yan, Lingxiao Zhao, Mark Heimann, Leman Akoglu, and Danai Koutra. Beyond homophily in graph neural networks: Current limitations and effective designs. 33:7793-7804, 2020.
* [60] Meiqi Zhu, Xiao Wang, Chuan Shi, Houye Ji, and Peng Cui. Interpreting and unifying graph neural networks with an optimization framework. In _ACM Web Conference (WWW)_, pages 1215-1226, 2021.

###### Contents

* 1 Introduction
* 2 Structure-aware Embedding Evolution
	* 2.1 Preliminaries
	* 2.2 Methodology
	* 2.3 Convergence Analysis for Further Modification
	* 2.4 Integrating SEvo into Existing Optimizers
* 3 Experiments
	* 3.1 Overall Comparison
	* 3.2 Empirical Analysis
	* 3.3 Ablation Study
	* 3.4 Applications of SEvo Beyond Interaction Data
* 4 Related Work
* 5 Broader Impact and Limitations
* 6 Conclusion and Future Work
* A Proofs
* A.1 Proof of Theorem 1
* A.2 Proof of Theorem 2
* A.3 Proofs of Proposition 1 and Theorem 3
* A.4 Connection between LightGCN and SEvo-enhanced MF-BPR
* B Detailed Settings
* B.1 Algorithms
* B.2 Datasets
* B.3 Baselines
* C Applications of SEvo beyond Interaction Data
* C.1 Pairwise Similarity Estimation Factors
* C.2 SEvo for Intra-class Representation Proximity
* C.3 SEvo for Knowledge Distillation
* D Additional Experimental Results
* D.1 SEvo for GNN-based models
* D.2 \(\mathcal{J}_{smoothness}\) as a Regularization Term
* D.3 \(L\)-layer Approximation
* D.4 Training and Inference Times

Proofs

### Proof of Theorem 1

In this part, we are to prove the structure-aware/direction-aware properties of the \(L\)-layer iterative approximation [57]:

\[\hat{\psi}_{iter}(\Delta\mathbf{E}):=\hat{\psi}_{L}(\Delta\mathbf{E})=\underbrace {\left\{(1-\beta)\sum_{l=0}^{L-1}\beta^{l}\tilde{\mathbf{A}}^{l}+\beta^{L} \tilde{\mathbf{A}}^{L}\right\}}_{=:\mathbf{P}^{\prime}}\Delta\mathbf{E}, \tag{9}\]

and the \(L\)-layer Neumann series approximation [39]:

\[\hat{\psi}_{nsa}(\Delta\mathbf{E})=\underbrace{(1-\beta)\sum_{l=0}^{L}\beta^{ l}\tilde{\mathbf{A}}^{l}}_{=:\mathbf{P}}\Delta\mathbf{E}. \tag{10}\]

**Fact 1**.: _If \(L\) is odd, the geometric series \(S(x)=\sum_{k=0}^{L}x^{l}\) is monotonically increasing when \(x\leq 0\)._

Proof.: It is easy to show that

\[S(x)=\frac{1-x^{L+1}}{1-x},\]

and the derivative w.r.t \(x\neq 1\) is

\[S^{\prime}(x)=\frac{Lx^{L+1}-(L+1)x^{L}+1}{(1-x)^{2}}.\]

If \(L\) is odd, \(S^{\prime}(x)\) is positive when \(x\leq 0\) and in this case \(S(x)\) is monotonically increasing.

**Lemma 1**.: _Given a normalized adjacency matrix \(\tilde{\mathbf{A}}\in\mathbb{R}^{n\times n}\), let the symmetric matrix deduced from the Neumann series approximation be_

\[\mathbf{P}=(1-\beta)\sum_{l=0}^{L}\beta^{l}\tilde{\mathbf{A}}^{l}. \tag{11}\]

_Denoted by \(\lambda_{\min}(\mathbf{P}),\lambda_{\max}(\mathbf{P})\) the smallest and largest eigenvalues of \(\mathbf{P}\), respectively, then we have \(\forall\beta\in[0,1)\)_

\[\frac{1-\beta}{1+\beta}(1-\beta^{L})\leq\lambda_{\min}(\mathbf{P})\leq\lambda_ {\max}(\mathbf{P})=1-\beta^{L+1}. \tag{12}\]

Proof.: It is easy to shown that the eigenvalues of \(\mathbf{P}\) are in the form of

\[\tilde{\lambda}_{i}=(1-\beta)\sum_{l=0}^{L}\beta^{l}\lambda_{i}^{l},\;i=1,2, \ldots,n, \tag{13}\]

where \(\lambda_{1}\leq\lambda_{2}\cdots\leq\lambda_{n}\) denote the eigenvalues of \(\tilde{\mathbf{A}}\). Recall that these eigenvalues all fall into \([-1,1]\) and \(\lambda_{n}=1\) can be achieved exactly [38]. Hence,

\[\tilde{\lambda}_{n}=(1-\beta)\sum_{l=0}^{L}\beta^{l}=1-\beta^{L+1} \tag{14}\]

is the largest eigenvalue of \(\mathbf{P}\).

In addition, notice that the last term \((1-\beta)\beta^{L}\lambda^{L}\) is non-negative when \(L\) is even. Then, we can get a lower bound no matter \(L\) is odd or even:

\[\tilde{\lambda}=(1-\beta)\sum_{l=0}^{L}\beta^{l}\lambda^{l}\geq(1-\beta) \underbrace{\sum_{l=0}^{2\lfloor(L-1)/2\rfloor+1}\beta^{l}\lambda^{l}}_{=:S( \lambda)}. \tag{15}\]

The minimum of \(S(\lambda)\) must be achieved in \([-1,0]\) because \(S(-\lambda)\leq S(\lambda)\) for any \(\lambda>0\). In fact, in view of Fact 1, we know that \(S(\lambda)\geq S(-1)\). Hence, we have

\[\tilde{\lambda} \geq(1-\beta)S(-1)=(1-\beta)\sum_{l=0}^{2\lfloor(L-1)/2\rfloor+1} \beta^{l}(-1)^{l}\] \[=(1-\beta)\sum_{l=0}^{\lfloor(L-1)/2\rfloor}\Big{(}\beta^{2l}- \beta^{2l+1}\Big{)}\] \[=(1-\beta)^{2}\sum_{l=0}^{\lfloor(L-1)/2\rfloor}\beta^{2l}=(1- \beta)^{2}\frac{(1-\beta^{2\lfloor(L-1)/2\rfloor+2})}{1-\beta^{2}}\] \[=\frac{1-\beta}{1+\beta}(1-\beta^{2\lfloor(L-1)/2\rfloor+2})\geq \frac{1-\beta}{1+\beta}(1-\beta^{L}). \tag{16}\]

The last inequality holds because \(2\lfloor(L-1)/2\rfloor+2\geq L\). Therefore, the smallest eigenvalue of \(\mathbf{P}\) must be greater than

\[\frac{1-\beta}{1+\beta}(1-\beta^{L}).\]

**Proposition 2**.: _The Neumann series approximation is structure-aware and direction-aware for any \(\beta\in[0,1)\)._

Proof.: In view of Lemma 1, we know

\[\lambda_{\min}(\mathbf{P})\geq\frac{1-\beta}{1+\beta}(1-\beta^{L})>0,\quad \forall\beta\in[0,1),\]

so \(\mathbf{P}\) is positive definite and thus \(\hat{\psi}_{nsa}(\cdot)\) is direction-aware. Also, notice that \(\mathbf{P}\) has the same eigenvectors as \(\tilde{\mathbf{A}}\), and so does \(\tilde{\mathbf{L}}\). Hence, it is also structure-aware:

\[\langle\hat{\psi}_{nsa}(\mathbf{x}),\tilde{\mathbf{L}}\hat{\psi} _{nsa}(\mathbf{x})\rangle =\langle\hat{\psi}_{nsa}(\mathbf{x}),\tilde{\mathbf{L}}\hat{\psi }_{nsa}(\mathbf{x})\rangle=\langle\mathbf{P}\mathbf{x},\tilde{\mathbf{L}} \mathbf{P}\mathbf{x}\rangle\] \[=\langle\mathbf{x},\mathbf{P}^{T}\tilde{\mathbf{L}}\mathbf{P} \mathbf{x}\rangle\leq\langle\mathbf{x},\tilde{\mathbf{L}}\mathbf{x}\rangle.\]

**Lemma 2**.: _Given a normalized adjacency matrix \(\tilde{\mathbf{A}}\in\mathbb{R}^{n\times n}\), let the symmetric matrix deduced from the iterative approximation be_

\[\mathbf{P}^{\prime}=(1-\beta)\sum_{l=0}^{L-1}\beta^{l}\tilde{\mathbf{A}}^{l}+ \beta^{L}\tilde{\mathbf{A}}^{L}. \tag{17}\]

_We have \(\lambda_{\min}(\mathbf{P}^{\prime})>0,\;\forall\beta<1/2\)._

Proof.: This conclusion is trivial for the case of \(L\leq 1\). Let us assume that \(L\geq 2\). Firstly, rewrite Eq. (17) as

\[\mathbf{P}^{\prime}=\mathbf{P}+\beta^{L}\tilde{\mathbf{A}}^{L}, \tag{18}\]where \(\mathbf{P}:=(1-\beta)\sum_{l=0}^{L-1}\beta^{l}\tilde{\mathbf{A}}^{l}\). \(\mathbf{P}\) is positive definite in view of Lemma 1 and \(\beta^{L}\tilde{\mathbf{A}}^{L}\) is positive semidefinite when \(L\) is even. Therefore, only the case of \(L\geq 3\) needs to be proved. For a vector \(\mathbf{x}\), we have

\[\mathbf{x}^{T}\mathbf{P}^{\prime}\mathbf{x} =\mathbf{x}^{T}\mathbf{P}\mathbf{x}+\beta^{L}\mathbf{x}^{T}\tilde{ \mathbf{A}}^{L}\mathbf{x}\geq\lambda_{\min}(\mathbf{P})\|\mathbf{x}\|_{2}^{2}+ \beta^{L}\lambda_{\min}(\tilde{\mathbf{A}})^{L}\|\mathbf{x}\|_{2}^{2}\] \[\geq\Big{(}\frac{1-\beta}{1+\beta}(1-\beta^{L-1})+\beta^{L} \lambda_{\min}(\tilde{\mathbf{A}})^{L}\Big{)}\|\mathbf{x}\|_{2}^{2} \tag{19}\] \[\geq\Big{(}\frac{1-\beta}{1+\beta}(1-\beta^{L-1})-\beta^{L}\Big{)} \|\mathbf{x}\|_{2}^{2}=\frac{1-\beta-\beta^{L-1}-\beta^{L+1}}{1+\beta}\| \mathbf{x}\|_{2}^{2}\] \[\geq\frac{1-\beta-\beta^{2}-\beta^{4}}{1+\beta}\|\mathbf{x}\|_{2} ^{2}. \tag{20}\]

The first two inequalities follow from Lemma 1. The last inequality holds by noting the fact that, for \(L\geq 3\) and \(\beta<1/2\),

\[\beta+\beta^{L-1}+\beta^{L+1}\leq\beta+\beta^{2}+\beta^{4}<13/16.\]

Therefore,

\[\lambda_{\min}(\mathbf{P}^{\prime})=\min_{\mathbf{x}}\frac{\mathbf{x}^{T} \mathbf{P}^{\prime}\mathbf{x}}{\|\mathbf{x}\|^{2}}\geq\frac{1-\beta-\beta^{2}- \beta^{4}}{1+\beta}>0. \tag{21}\]

**Proposition 3**.: _The iterative approximation is direction-aware for all possible normalized adjacency matrices and \(L\geq 0\), if and only if \(\beta<1/2\)._

Proof.: If \(\beta<1/2\), we have \(\lambda_{\min}(\mathbf{P}^{\prime})>0\) according to Lemma 2, and thus \(\hat{\psi}\) is direction-aware. Conversely, if \(\beta\geq 1/2\), we can construct an adjacency matrix \(\tilde{\mathbf{A}}\) such that \(\lambda_{\min}(\mathbf{P}^{\prime})\leq 0\) for some \(L\). Let us assume that \(L=1\) and

\[\tilde{\mathbf{A}}:=\left[\begin{array}{cc}0&1\\ 1&0\end{array}\right]. \tag{22}\]

In this case, we have

\[\mathbf{P}^{\prime}=(1-\beta)\mathbf{I}+\beta\tilde{\mathbf{A}}=\left[ \begin{array}{cc}1-\beta&\beta\\ \beta&1-\beta\end{array}\right], \tag{23}\]

whose eigenvalues are \(1\) and \(1-2\beta\). The latter is non-positive for any \(\beta\geq 1/2\). 

**Remark 2**.: _The construction of \(\tilde{\mathbf{A}}\) in Eq. (22) is not unique. In fact, any bipartite graph can be used as a counterexample._

**Corollary 1** (The proof of Theorem 1).: _The iterative approximation is direction-aware for all possible normalized adjacency matrices and \(L\geq 0\), if and only if \(\beta<1/2\). In contrast, the Neumann series approximation_

\[\hat{\psi}_{nsa}(\Delta\mathbf{E})=(1-\beta)\sum_{l=0}^{L}\beta^{l}\tilde{ \mathbf{A}}^{l}\Delta\mathbf{E}, \tag{24}\]

_is structure-aware and direction-aware for any \(\beta\in[0,1)\)._

Proof.: This is a corollary of Proposition 2 and Proposition 3. 

**Proposition 4**.: _The rescaled Neumann series approximation \(\hat{\psi}\) is structure-aware and direction-aware, and converges to the optimal solution as \(L\) increases._

Proof.: The convergence to the optimal solution is obvious by noting that

\[\begin{array}{rl}\lim_{L\rightarrow+\infty}\hat{\psi}(\Delta\mathbf{E})&=\lim _{L\rightarrow+\infty}\frac{1}{1-\beta^{L+1}}\cdot\lim_{L\rightarrow+\infty} \hat{\psi}_{nsa}(\Delta\mathbf{E})\\ &=1\cdot\psi^{*}(\Delta\mathbf{E})=\psi^{*}(\Delta\mathbf{E}).\end{array} \tag{25}\]

Similar to Proposition 2, it can be proved that \(\frac{1}{1-\beta^{L+1}}\mathbf{P}\) is positive definite with a largest eigenvalue \(\leq 1\). Therefore, the rescaled transformation is also structure-aware and direction-aware.

### Proof of Theorem 2

Before delving into the proof of the convergence, we would like to claim that the lemmas below are well known and can be found in most textbooks [32, 1] on convex optimization. For the sake of completeness, we provide here these proofs. Hereinafter, we use \(\|\mathbf{X}\|_{2}\) to denote the spectral norm which returns the largest singular value of the matrix \(\mathbf{X}\).

**Lemma 3**.: _For a twice continuously differentiable function \(f:\mathbb{R}^{n}\rightarrow\mathbb{R}\) with \(\|\nabla^{2}f(\mathbf{x})\|_{2}\leq C,\,\forall\mathbf{x}\in\mathbf{dom}(f)\), we have_

\[f(\mathbf{y})\leq f(\mathbf{x})+\langle\nabla f(\mathbf{x}), \mathbf{y}-\mathbf{x}\rangle+\frac{C}{2}\|\mathbf{y}-\mathbf{x}\|_{2}^{2}. \tag{26}\]

Proof.: For a Taylor expansion of \(f(\mathbf{x})\), there exists a \(\mathbf{z}=\tau\mathbf{x}+(1-\tau)\mathbf{y}\) for some \(\tau\in[0,1]\) such that

\[f(\mathbf{y}) =f(\mathbf{x})+\langle\nabla f(\mathbf{x}),(\mathbf{y}-\mathbf{x })\rangle+\frac{(\mathbf{y}-\mathbf{x})^{T}\nabla^{2}f(\mathbf{z})(\mathbf{y} -\mathbf{x})}{2}\] \[\leq f(\mathbf{x})+\langle\nabla f(\mathbf{x})^{T}(\mathbf{y}- \mathbf{x})\rangle+\frac{C}{2}\|\mathbf{y}-\mathbf{x}\|_{2}^{2}.\]

**Lemma 4**.: _For a positive definite matrix \(\mathbf{P}\), let \(\|\mathbf{x}\|_{\mathbf{P}}:=(\mathbf{x}^{T}\mathbf{P}\mathbf{x})^{1/2}\) be the quadratic norm induced from \(\mathbf{P}\). If the eigenvalues of \(\mathbf{P}\) fall into \([a,b]\), then_

\[\|\mathbf{P}\mathbf{x}\|_{2}^{2}\leq b\|\mathbf{x}\|_{\mathbf{P}}^ {2},\quad a\|\mathbf{x}\|_{2}^{2}\leq\|\mathbf{x}\|_{\mathbf{P}}^{2}. \tag{27}\]

Proof.: Firstly,

\[\|\mathbf{P}\mathbf{x}\|_{2}=\|\mathbf{P}^{1/2}\mathbf{P}^{1/2} \mathbf{x}\|_{2}\leq\|\mathbf{P}^{1/2}\|_{2}\|\mathbf{x}\|_{\mathbf{P}}\leq \sqrt{b}\|\mathbf{x}\|_{\mathbf{P}}.\]

Secondly,

\[\|\mathbf{x}\|_{2}=\|\mathbf{P}^{-1/2}\mathbf{P}^{1/2}\mathbf{x} \|_{2}\leq\|\mathbf{P}^{-1/2}\|_{2}\|\mathbf{x}\|_{\mathbf{P}}\leq\frac{1}{ \sqrt{a}}\|\mathbf{x}\|_{\mathbf{P}}.\]

**Theorem 4**.: _Let \(f:\mathbb{R}^{n}\times\mathbb{R}^{m}\rightarrow\mathbb{R}\) be a twice continuously differentiable function bounded below, and its Hessian matrix satisfies_

\[\|\nabla^{2}f(\mathbf{x},\mathbf{y})\|_{2}\leq C,\,\forall( \mathbf{x},\mathbf{y})\in\mathbf{dom}(f) \tag{28}\]

_for some constant \(C\). The following gradient descent scheme is used to train \(\mathbf{x},\mathbf{y}\):_

\[\mathbf{x}_{t+1}\leftarrow\mathbf{x}_{t}-\eta\mathbf{P}\nabla_{ \mathbf{x}}f(\mathbf{x}_{t},\mathbf{y}_{t}),\quad\mathbf{y}_{t+1}\leftarrow \mathbf{y}_{t}-\eta^{\prime}\nabla_{\mathbf{y}}f(\mathbf{x}_{t},\mathbf{y}_{t}), \tag{29}\]

_where \(\mathbf{P}\) is deduced from the \(L\)-layer Neumann series approximation. Then, after \(T\) updates, we have,_

\[\min_{t\leq T}\|\nabla f(\mathbf{x},\mathbf{y})\|_{2}^{2}\leq \frac{2C}{\gamma(T+1)}\epsilon, \tag{30}\]

_where \(\epsilon=f(\mathbf{x},\mathbf{y})-f(\mathbf{x}^{*},\mathbf{y}^{*})\) and_

\[\gamma=\left\{\begin{array}{ll}\frac{1-\beta}{1+\beta}(1- \beta^{L})(1+\beta^{L+1}),&\mbox{ if }\eta=\eta^{\prime}=\frac{1}{C}\\ \frac{1-\beta}{1-\beta^{L+1}},&\mbox{ otherwise}\end{array}\right..\]

Proof.: The update formula (29) can be unified into

\[\mathbf{z}_{t+1}:=\left[\begin{array}{c}\mathbf{x}_{t+1}\\ \mathbf{y}_{t+1}\end{array}\right]=\left[\begin{array}{c}\mathbf{x}_{t}\\ \mathbf{y}_{t}\end{array}\right]-\underbrace{\left[\begin{array}{cc}\eta \mathbf{P}&0\\ 0&\eta^{\prime}\mathbf{I}\end{array}\right]}_{=:\widetilde{\mathbf{P}}}\nabla f( \mathbf{x}_{t},\mathbf{y}_{t}).\]It is easy to show that

\[a:=\min(\frac{1-\beta}{1+\beta}(1-\beta^{L})\eta,\eta^{\prime})\leq \lambda_{\min}(\tilde{\mathbf{P}})\] \[\leq\lambda_{\max}(\tilde{\mathbf{P}})=\max((1-\beta^{L+1})\eta, \eta^{\prime})=:b.\]

Specifically,

\[a=\left\{\begin{array}{ll}\frac{1-\beta}{1+\beta}(1-\beta^{L}) \frac{1}{\mathcal{C}},&\text{ if }\eta=\eta^{\prime}=\frac{1}{\mathcal{C}}\\ \frac{1-\beta}{1+\beta}\frac{1-\beta^{L}}{1-\beta^{L+T}}\frac{1}{\mathcal{C}},&\text{ otherwise}\end{array}\right.,\] \[b=\left\{\begin{array}{ll}(1-\beta^{L+1})\frac{1}{\mathcal{C}},&\text{ if }\eta=\eta^{\prime}=\frac{1}{\mathcal{C}}\\ \frac{1}{\mathcal{C}},&\text{ otherwise}\end{array}\right..\]

In view of Lemma 3 and Lemma 4, we have

\[f(\mathbf{z}_{t+1}) \leq f(\mathbf{z}_{t})-\langle\nabla f(\mathbf{z}_{t}),\tilde{ \mathbf{P}}\nabla f(\mathbf{z}_{t})\rangle+\frac{C}{2}\|\tilde{\mathbf{P}} \nabla f(\mathbf{z}_{t})\|_{2}^{2}\] \[=f(\mathbf{z}_{t})-\|\nabla f(\mathbf{z}_{t})\|_{\tilde{\mathbf{ P}}}^{2}+\frac{C}{2}\|\tilde{\mathbf{P}}\nabla f(\mathbf{z}_{t})\|_{2}^{2}\] \[\leq f(\mathbf{z}_{t})-\|\nabla f(\mathbf{z}_{t})\|_{\tilde{ \mathbf{P}}}^{2}+\frac{bC}{2}\|\nabla f(\mathbf{z}_{t})\|_{\tilde{\mathbf{P}}} ^{2} \tag{31}\] \[=f(\mathbf{z}_{t})-(1-\frac{bC}{2})\|\nabla f(\mathbf{z}_{t})\|_{ \tilde{\mathbf{P}}}^{2}\] \[\leq f(\mathbf{z}_{t})-a(1-\frac{bC}{2})\|\nabla f(\mathbf{z}_{t} )\|_{2}^{2}. \tag{32}\]

Denoted by

\[\gamma :=aC(2-bC) \tag{33}\] \[=\left\{\begin{array}{ll}\frac{1-\beta}{1+\beta}(1-\beta^{L}) (1+\beta^{L+1}),&\text{ if }\eta=\eta^{\prime}=\frac{1}{\mathcal{C}}\\ \frac{1-\beta}{1+\beta}\frac{1-\beta^{L}}{1-\beta^{L+1}},&\text{ otherwise} \end{array}\right.,\]

we have

\[\min_{0\leq t\leq T}\|\nabla f(\mathbf{x}_{t},\mathbf{y}_{t})\|_{ 2}^{2}\leq\frac{1}{T+1}\sum_{t=0}^{T}\|\nabla f(\mathbf{x}_{t},\mathbf{y}_{t}) \|_{2}^{2}\] \[\leq \frac{1}{T+1}\sum_{t=0}^{T}\frac{2C}{\gamma}(f(\mathbf{x}_{t}, \mathbf{y}_{t})-f(\mathbf{x}_{t+1},\mathbf{y}_{t+1}))\] \[= \frac{2C}{\gamma(T+1)}(f(\mathbf{x}_{0},\mathbf{y}_{0})-f( \mathbf{x}_{T+1},\mathbf{y}_{T+1}))\] \[\leq \frac{2C}{\gamma(T+1)}\epsilon.\]

**Theorem 5** (The proof of Theorem 2).: _If \(\eta=\eta^{\prime}=1/C\), after \(T\) updates, we have_

\[\min_{t\leq T}\|\nabla\mathcal{L}(\mathbf{E}_{t},\mathbf{\theta}_{t})\|_{2}^{2}= \mathcal{O}\big{(}C/((1-\beta)^{2}T)\big{)}. \tag{34}\]

_If we adopt a modified learning rate for embedding:_

\[\eta=\frac{1}{(1-\beta^{L+1})C}, \tag{35}\]

_the convergence rate could be improved to \(\mathcal{O}\big{(}C/((1-\beta)T)\big{)}\)._

Proof.: This is true for \(L=0\), since in this case the update mechanism becomes a normal gradient descent regardless of \(\eta=1/C\) or \(\eta=\frac{1}{(1-\beta)C}\). Let us prove a general case for \(L\geq 1\) next.

According to Theorem 4, we have

\[\min_{t\leq T}\|\nabla\mathcal{L}(\mathbf{E}_{t},\mathbf{\theta}_{t})\|_{2}^{2}\leq \frac{2C}{\gamma(T+1)}\epsilon,\]

where \(\epsilon=\mathcal{L}(\mathbf{E},\mathbf{\theta})-\mathcal{L}(\mathbf{E}^{*},\mathbf{ \theta}^{*})\) and

\[\gamma=\left\{\begin{array}{ll}\frac{1-\beta}{1+\beta}(1-\beta^{L})(1+\beta ^{L+1}),&\text{ if }\eta=\eta^{\prime}=\frac{1}{C}\\ \frac{1-\beta}{1+\beta}\frac{1-\beta^{L}}{1-\beta^{L+1}},&\text{ otherwise}\end{array} \right..\]

Notice that, for \(\eta=\eta^{\prime}=1/C\),

\[\begin{array}{ll}\lim_{\beta\to 1}\frac{1/\gamma}{1/(1-\beta)^{2}}&=\lim_{ \beta\to 1}\frac{\frac{1}{1+\beta}(1-\beta^{L})(1+\beta^{L+1})}{\frac{1}{1- \beta}}\\ &=\lim_{\beta\to 1}\frac{1-\beta^{L}}{1-\beta^{L}}=\frac{1}{L},\end{array} \tag{36}\]

and for \(\eta=\frac{1}{(1-\beta^{L+1})C},\eta^{\prime}=\frac{1}{C}\),

\[\begin{array}{ll}\lim_{\beta\to 1}\frac{1/\gamma}{1/(1-\beta)}&=\lim_{ \beta\to 1}\frac{\frac{1}{1+\beta}\frac{1}{(1-\beta^{L})}}{\frac{1}{1-\beta^{L}} +1}\\ &=2\cdot\lim_{\beta\to 1}\frac{1-\beta^{L}}{1-\beta^{L}}=\frac{2(L+1)}{L}. \end{array} \tag{37}\]

Therefore,

\[\frac{1}{\gamma}=\left\{\begin{array}{ll}\mathcal{O}(1/(1-\beta)^{2}),&\text { if }\eta=\eta^{\prime}=\frac{1}{C}\\ \mathcal{O}(1/(1-\beta)),&\text{ if }\eta=\frac{1}{(1-\beta^{L+1})C},\eta^{ \prime}=\frac{1}{C}\end{array}\right..\]

The remainder of the proof is straightforward.

### Proofs of Proposition 1 and Theorem 3

Adam(W) [23] uses the bias-corrected moment estimates for updating because they are unbiased when the actual moments are stationary throughout the training. Below, Lemma 5 formally elaborates on this, and Theorem 6 extends Theorem 3 with a proof of unbiasedness.

**Lemma 5** ([23]).: _Denoted by \(\dot{\mathbf{m}}_{t}=\mathbf{m}_{t}/(1-\beta_{1}^{t})\) and \(\dot{\mathbf{v}}_{t}=\mathbf{v}_{t}/(1-\beta_{2}^{t})\) the bias-corrected estimates, if the first and second moments are stationary, i.e.,_

\[\mathbb{E}[\mathbf{g}_{t}]=\mathbb{E}[\mathbf{g}],\quad\mathbb{E}[\mathbf{g}_{ t}^{2}]=\mathbb{E}[\mathbf{g}^{2}],\quad\forall t=1,2,\ldots,\]

_then these bias-corrected estimates are unbiased:_

\[\mathbb{E}[\dot{\mathbf{m}}_{t}]=\mathbb{E}[\mathbf{g}],\quad\mathbb{E}[\dot{ \mathbf{v}}_{t}]=\mathbb{E}[\mathbf{g}^{2}],\quad\forall t=1,2,\ldots.\]

**Proposition 5**.: _If a node is no longer sampled in subsequent \(p\) batches after step \(t\), we have_

\[\Delta\mathbf{e}_{t+p-1}=\kappa\cdot\frac{\beta_{1}^{p}}{\sqrt{\beta_{2}^{2}} }\Delta\mathbf{e}_{t-1}, \tag{38}\]

_where the coefficient of \(\kappa\) is mainly determined by \(t\)._

Proof.: In this case, the iterative formula becomes

\[\mathbf{m}_{t+j}=\beta_{1}^{j}\mathbf{m}_{t}+\mathbf{0},\quad\mathbf{v}_{t+j}= \beta_{2}^{j}\mathbf{v}_{t}+\mathbf{0},\quad\forall j=0,1,\ldots,p.\]Therefore,

\[\Delta\mathbf{e}_{t+p-1} =\frac{\hat{\mathbf{m}}_{t+p}}{\sqrt{\hat{\mathbf{v}}_{t+p}}}=\frac{ \sqrt{1-\beta_{2}^{t+p}}}{1-\beta_{1}^{t+p}}\frac{\mathbf{m}_{t+p}}{\sqrt{\mathbf {v}_{t+p}}}\] \[=\frac{\sqrt{1-\beta_{2}^{t+p}}}{1-\beta_{1}^{t+p}}\frac{\beta_{1} ^{p}}{\sqrt{\beta_{2}^{p}}}\frac{\mathbf{m}_{t}}{\sqrt{\mathbf{v}_{t}}}=\frac{ \beta_{1}^{p}\sqrt{1-\beta_{2}^{t+p}}}{\sqrt{\beta_{2}^{p}}(1-\beta_{1}^{t+p}) }\frac{\mathbf{m}_{t}}{\sqrt{\mathbf{v}_{t}}}\] \[=\frac{\beta_{1}^{p}(1-\beta_{1}^{t})\sqrt{1-\beta_{2}^{t+p}}}{ \sqrt{\beta_{2}^{p}}(1-\beta_{1}^{t+p})\sqrt{1-\beta_{2}^{t}}}\frac{\mathbf{m }_{t}}{\sqrt{\mathbf{v}_{t}}}\] \[=\frac{\beta_{1}^{p}}{\sqrt{\beta_{2}^{p}}}\underbrace{\frac{(1- \beta_{1}^{t})\sqrt{1-\beta_{2}^{t+p}}}{(1-\beta_{1}^{t+p})\sqrt{1-\beta_{2}^{ t}}}}_{=:\kappa}\Delta\mathbf{e}_{t-1}.\]

It is easy to show that

\[\lim_{t\rightarrow+\infty}\kappa(t,p)=1,\quad\forall\beta_{1},\beta_{2}\in[0,1). \tag{39}\]

**Theorem 6** (The proof of Theorem 3).: _Under the same assumptions as in Lemma 5 and Proposition 1, the bias-corrected estimates are unbiased and \(\Delta\mathbf{e}_{t+p-1}=\Delta\mathbf{e}_{t-1}\) if the estimates are updated in the following manner when \(\mathbf{g}_{t}=\mathbf{0}\),_

\[\mathbf{m}_{t}=\beta_{1}\mathbf{m}_{t-1}+(1-\beta_{1})\frac{1}{1-\beta_{1}^{t- 1}}\mathbf{m}_{t-1},\quad\mathbf{v}_{t}=\beta_{2}\mathbf{v}_{t-1}+(1-\beta_{2} )\frac{1}{1-\beta_{2}^{t-1}}\mathbf{v}_{t-1}. \tag{40}\]

Proof.: We first show the unbiasedness of \(\mathbf{m}_{t}\) and the proof for \(\mathbf{v}_{t}\) is completely analogous. It remains only to show that

\[\mathbb{E}[\mathbf{m}_{t}]=(1-\beta_{1}^{t})\mathbb{E}[\mathbf{g}].\]

This is trivial for \(t=0\). Assuming that this also holds in the case of \(t-1\), it can be proved by induction.

If \(\mathbf{g}_{t}\neq\mathbf{0}\),

\[\mathbb{E}[\mathbf{m}_{t}] =\beta_{1}\mathbb{E}[\mathbf{m}_{t-1}]+(1-\beta_{1})\mathbb{E}[ \mathbf{g}_{t}]\] \[=\beta_{1}(1-\beta_{1}^{t-1})\mathbb{E}[\mathbf{g}]+(1-\beta_{1}) \mathbb{E}[\mathbf{g}]\] \[=(1-\beta_{1}^{t})\mathbb{E}[\mathbf{g}].\]

If \(\mathbf{g}_{t}=\mathbf{0}\),

\[\mathbb{E}[\mathbf{m}_{t}] =\beta_{1}\mathbb{E}[\mathbf{m}_{t-1}]+(1-\beta_{1})\frac{1}{1- \beta_{1}^{t-1}}\mathbb{E}[\mathbf{m}_{t-1}]\] \[=\frac{1-\beta_{1}^{t}}{1-\beta_{1}^{t-1}}\mathbb{E}[\mathbf{m}_ {t-1}]=(1-\beta_{1}^{t})\mathbb{E}[\mathbf{g}].\]

If the node is no longer sampled in subsequent \(p\) batches after step \(t\), we have

\[\mathbf{m}_{t+j} =\beta_{1}\mathbf{m}_{t+j-1}+(1-\beta_{1})\frac{1}{1-\beta_{1}^{t +j-1}}\mathbf{m}_{t+j-1}\] \[=\frac{1-\beta_{1}^{t+j}}{1-\beta_{1}^{t+j-1}}\mathbf{m}_{t+j-1}= \frac{1-\beta_{1}^{t+j}}{1-\beta_{1}^{t+j-1}}\frac{1-\beta_{1}^{t+j-1}}{1-\beta _{1}^{t+j-2}}\mathbf{m}_{t+j-2}\] \[=\cdots=\frac{1-\beta_{1}^{t+j}}{1-\beta_{1}^{t}}\mathbf{m}_{t}, \quad\forall j=1,2,\ldots,p.\]Analogously, we have,

\[\mathbf{v}_{t+j}=\frac{1-\beta_{2}^{t+j}}{1-\beta_{2}^{t}}\mathbf{v}_{t},\quad \forall j=1,2,\ldots,p.\]

Therefore, the conclusion can be deduced from

\[\hat{\mathbf{m}}_{t+p}=\frac{1}{1-\beta_{1}^{t+j}}\mathbf{m}_{t+p} =\frac{1}{1-\beta_{1}^{t}}\mathbf{m}_{t}=\hat{\mathbf{m}}_{t},\] \[\hat{\mathbf{v}}_{t+p}=\frac{1}{1-\beta_{2}^{t+j}}\mathbf{v}_{t+p }=\frac{1}{1-\beta_{2}^{t}}\mathbf{v}_{t}=\hat{\mathbf{v}}_{t}.\]

### Connection between LightGCN and SEvo-enhanced MF-BPR

For a \(L\)-layer LightGCN, it can be formulated as follows

\[\mathbf{F}=\psi(\mathbf{E}):=\sum_{l=0}^{L}\alpha_{l}\bar{\mathbf{\Lambda}}^{l }\mathbf{E},\]

where \(\alpha_{l},l=0,\ldots,L\) represent the layer weights. According to the linear nature of the gradient operator, it can be obtained that

\[\nabla_{\mathbf{E}}\mathcal{L}=\psi(\nabla_{\mathbf{F}}\mathcal{L}).\]

Hence, denoted by \(\zeta(\cdot)\) the gradient processing procedure of an optimizer, we can establish that LightGCN is identical to the following system:

\[\mathbf{F}(t) =\psi(\mathbf{E}(t))\] \[=\psi(\mathbf{E}(t-1)-\eta\Delta\mathbf{E}(t-1))\] \[=\psi(\mathbf{E}(t-1))-\eta\psi(\Delta\mathbf{E}(t-1))\] \[=\mathbf{F}(t-1)-\eta\psi\circ\zeta\circ\psi(\nabla_{\mathbf{F}} \mathcal{L}).\]

When \(\zeta(\cdot)\) is an identity mapping (i.e., standard gradient descent), LightGCN is equivalent to MF-BPR with SEvo being applied twice at each update. However, when \(\zeta(\cdot)\) is not an identity mapping (e.g., an optimizer with momentum or weight decay is integrated), they cannot be unified into a single system. Compared to explicit GNNs, SEvo is easy-to-use and has minimal impact on the forward pass, making it more suitable for assisting recommenders in simultaneously utilizing multiple types of information. These connections in part justify why SEvo can inject structural information directly.

## Appendix B Detailed Settings

### Algorithms

We present the algorithms of SEvo-enhanced Adam and SGD in 2 and Algorithm 3, respectively.

### Datasets

In this study, we perform experiments on six public datasets. Specifically, the Beauty, Toys, and Tools datasets are extracted from Amazon reviews published in 20142, while Electronics and Clothing are sourced from Amazon reviews published in 20183. Additionally, the MovieLens-1M dataset is made available by GroupLens4.

Footnote 2: [https://cesweb.ucsd.edu/~jmcauley/datasets/amazon/links.html](https://cesweb.ucsd.edu/~jmcauley/datasets/amazon/links.html)```
0: embedding matrix \(\mathbf{E}\), learning rate \(\eta\), momentum factors \(\beta_{1},\beta_{2},\beta\in[0,1)\), weight decay \(\lambda\). foreach step \(t\)do \(\mathbf{G}_{t}\leftarrow\nabla_{\mathbf{E}}\mathcal{L}+\lambda\mathbf{E}_{t-1}\) ; // Get gradients Update first/second moment estimates: \[\mathbf{M}_{t}\leftarrow\beta_{1}\mathbf{M}_{t-1}+(1-\beta_{1}) \mathbf{G}_{t},\] \[\mathbf{V}_{t}\leftarrow\beta_{1}\mathbf{V}_{t-1}+(1-\beta_{2}) \mathbf{G}_{t}^{2};\]  Compute bias-corrected first/second moment estimates: \[\hat{\mathbf{M}}_{t}\leftarrow\mathbf{M}_{t}/(1-\beta_{1}^{t}),\] \[\hat{\mathbf{V}}_{t}\leftarrow\mathbf{V}_{t}/(1-\beta_{2}^{t});\]  Update via SEvo: \[\mathbf{E}_{t}\leftarrow\mathbf{E}_{t-1}-\eta\,\hat{\psi}\bigg{(} \hat{\mathbf{M}}_{t}/\sqrt{\hat{\mathbf{V}}_{t}+\epsilon};\beta\bigg{)}.\] Output: optimized embeddings \(\mathbf{E}\).
```

**Algorithm 3** SGD with momentum enhanced by SEvo. Differences from the original SGD are colored in blue. The matrix operation below are element-wise.

```
0: embedding matrix \(\mathbf{E}\), learning rate \(\eta\), momentum factors \(\mu,\beta\in[0,1)\), weight decay \(\lambda\). foreach step \(t\)do \(\mathbf{G}_{t}\leftarrow\nabla_{\mathbf{E}}\mathcal{L}+\lambda\mathbf{E}_{t-1}\) ; // Get gradients \(\mathbf{M}_{t}\leftarrow\mu\hat{\mathbf{M}}_{t-1}+\mathbf{G}_{t}\) ; // Moment update  Update via SEvo: \[\mathbf{E}_{t}\leftarrow\mathbf{E}_{t-1}-\eta\,\hat{\psi}\bigg{(}\mathbf{M}_{t };\beta\bigg{)}.\] Output: optimized embeddings \(\mathbf{E}\).
```

**Algorithm 4** SGD with momentum enhanced by SEvo. Differences from the original SGD are colored in blue. The matrix operation below are element-wise.

### Baselines

Four GNN-based baselines for performance and efficiency benchmarks:

* **LightGCN**[16] is a pioneering collaborative filtering model that simplifies graph convolutional networks (GCNs) by removing nonlinearities for easier training. It uses only graph structural information and has no access to sequential information.
* **SR-GNN**[48] and **LESSR**[8] are two baselines dynamically constructing session graph. The former employs a gated graph neural network to obtain the final node vectors, while the latter utilizes edge-order preserving multigraph and a shortcut graph to address the lossy session encoding and ineffective long-range dependency capturing problems, respectively.
* **MAERec**[51] learns to sample less noisy paths from a semantic similarity graph for subsequent reconstruction tasks. However, we found that the official implementation treats the recommendation loss and reconstruction loss equally, leading to poor performance here. Therefore, an additional weight is attached to the reconstruction loss and a grid search is performed in the range of [0, 1]. Almost all hyperparameters are tuned for competitive performance.

Four sequence backbones to validate the effectiveness of SEvo:* **GRU4Rec**[17] applies RNN [9] to recommendation with specific modifications made to cope with data sparsity. In addition to the learning rate in {1e-4, 5e-4, 1e-3, 5e-3} and weight decay in [0, 0.1], we also tune the dropout rate for node features in the range of [0, 0.7].
* **SASRec**[22] and **BERT4Rec**[40] are two pioneering works on sequential recommendation equipped with unidirectional and bidirectional self-attention, respectively. For BERT4Rec which employs a separate fully-connected layer for scoring, the weight matrix therein will also be smoothed by SEvo. In addition to some basic hyperparameters, the mask ratio is also researched for BERT4Rec.
* **STOSA**[13] is one of the state-of-the-art models. It aims to capture the uncertainty of sequential behaviors by modeling each item as a Gaussian distribution. The hyperparameters involved are tuned similarly to SASRec.

Four knowledge distillation methods used in Appendix C.3:

* **KD**[18] and **DKD**[55] are two logits-based approaches to transfer knowledge. DKD decomposes the classical KD loss into target class knowledge distillation loss and non-target class knowledge distillation loss.
* **RKD**[34] and **HTD**[21] are two ranking-based approaches. The former focuses the distillation of relational knowledge through distance-wise and angle-wise alignments, while the latter emphasizes the distillation of hierarchical topology by dividing nodes into multiple groups and requiring intra-group and inter-group alignments.

## Appendix C Applications of SEvo beyond Interaction Data

Here, we preliminarily explore the exploitation of more types of knowledge besides consecutive occurrences. We first investigate some elementary factors for interaction data, and then introduce the applications of SEvo to node categories and knowledge distillation.

### Pairwise Similarity Estimation Factors

Recent GNN-based sequence models [48, 49], as well as the SEvo-enhanced models reported in Section 3, estimate the pairwise similarity \(w_{ij}\) between items \(v_{i}\) and \(v_{j}\) based on their co-occurrence frequency in sequences. In other words, items that appear consecutively more frequently are assumed more related. Yet there are some factors that deserve a closer look: **(1)** The maximum sequence length \(K\) for construction to investigate the number of interactions required for accurate estimation; **(2)** Using only the first \(K\) versus last \(K\) interactions in each sequence to compare the utility of early and recent preferences; **(3)** Allowing related items to be connected by a walk of length \(\leq H\) rather than strict consecutive occurrences; **(4)** Frequency-based similarity versus distance-based similarity. The former weights all related pairs equally, while the latter weights inversely to their walk length. For example, given a sequence \(v_{2}\to v_{1}\to v_{3}\) with a maximum walk length of \(H=2\)

Figure 4: Illustrations of different pairwise similarity estimation methods based on interaction data. (a) The default is to adopt the co-occurrence frequency within the last \(K\) items. (b) Using only the first \(K\) items. (c) Allowing a maximum walk length of \(H\) beyond 1. (d) Frequency-based similarity versus distance-based similarity.

the frequency-based similarity of \((v_{2},v_{3})\) gives 1, while the distance-based similarity is \(1/2\) (as the walk length from \(v_{2}\) to \(v_{3}\) is 2).

Figure 4 illustrates these four variants and Algorithm 4 details a step-by-step process. We further compare these four potential factors in Figure 5:

* Figure 4(a) shows the effect of confining the maximum sequence length to the first/last \(K\) items, so only the early/recent preferences will be considered. In constrast to early interactions, recent ones imply more precise pairwise relations for future prediction, even for small \(K\). With the increase of the maximum sequence length, the recommendation performance on Beauty improves steadily, but not the case for MovieLens-1M. This suggests that shopping relations may be more consistent than movie preferences.
* Figure 4(b) explores the relations beyond strict consecutive occurrences; that is, two items are considered related once they co-occur within a path of length \(\leq H\). For the shopping and movie datasets, estimating similarity beyond co-occurrence frequency appears less reliable overall. We also compare frequency-based similarity with distance-based similarity that decreases weights for more distant pairs. It is clear that the distance-based approach performs more stably as the maximum walk length \(H\) increases.

### SEvo for Intra-class Representation Proximity

Sometimes embeddings are expected to be smooth w.r.t. a prior knowledge. For example, in addition to the interaction data, each movie in the MovieLens-1M dataset is associated with at least one genre.

Figure 5: Comparison of similarity estimation across four potential factors. ‘\(\star\)’ indicates the default way applied to SEvo-enhanced sequence models in Section 3.1. (a) Using only the first/last \(K\) items for pairwise similarity estimation. (b) Frequency- and distance-based similarity with a maximum walk length of \(H\).

It is natural to assume that movies of the same genre are related to each other. Heuristically, we can define the similarity \(w_{ij}\) to be 1 if \(v_{i}\) and \(v_{j}\) belong to the same genre and 0 otherwise.

As can be seen in Figure 6, such smoothness constraint can also be fulfilled through SEvo, leading to progressively stronger clustering effects as \(\beta\) increases. However, the resulting performance gains are slightly less than those based on interaction data (see Table 4). One possible reason is that the movie genres are too coarse to provide particularly useful information. In conclusion, while smoothness is an appealing inductive bias, its utility depends on how well the imposed structural information agrees with the performance metrics of interest.

### SEvo for Knowledge Distillation

In addition to the affinity matrix extracted from interaction data or relation data, the pairwise similarity can also be estimated from a heavy-weight teacher model. Recall that Knowledge Distillation (KD) [18] encourages a light-weight student model to mimic the behaviors (_e.g._, output distribution) of the teacher model, so the learned student model achieves both accuracy and efficiency. In general, higher-dimensional embeddings are capable of better fitting the underlying distribution between entities. The pairwise similarities extracted from a teacher model, needless to say, can be used to guide the embedding evolution of a student model. Unlike interaction or relation data, the deduced graph is dense if only the distance function is applied. Therefore, some graph construction steps including sparsification and reweighting should be involved as well. We attempt to use the widely used KNN graph here, and leave a more comprehensive study of graph construction [20] as a future work.

\begin{table}
\begin{tabular}{l|r|r r r} \hline \hline  & & \multicolumn{4}{c}{MovieLens-1M} \\  & \(\beta\) & HR@1 & HR@10 & NDCG@10 \\ \hline Baseline (SASRec) & 0 & 0.0457 & 0.2482 & 0.1315 \\ \hline \multirow{2}{*}{Interaction data} & 0.5 & 0.0494 & 0.2538 & 0.1362 \\  & 0.99 & **0.0517** & **0.2567** & **0.1385** \\ \hline \multirow{2}{*}{Movie genres} & 0.5 & 0.0492 & 0.2527 & 0.1352 \\  & 0.99 & 0.0508 & 0.2549 & 0.1371 \\ \hline \hline \end{tabular}
\end{table}
Table 4: Pairwise similarity estimation based on interaction data versus node categories (movie genres).

Figure 6: UMAP [30] visualization of movies based on their embeddings. For ease of differentiation, we group the 18 genres into 6 categories and colored them individually: Thriller/Crime/Action/Adventure; Horror/Mystery/Film-Noir; War/Drama/Romance; Comedy/Musical/Children’s/Animation; Fantasy/Sci-Fi; Western/Documentary.

Specifically, the distance between each pair \(v_{i},v_{j}\) is estimated using a cosine similarity distance function:

\[d_{ij}=2-2\frac{\mathbf{e}_{i}^{T}\mathbf{e}_{j}}{\|\mathbf{e}_{i} \|_{2}\|\mathbf{e}_{j}\|_{2}}. \tag{41}\]

Then, \(K\)-nearest neighbors are selected for each node; that is

\[(i,j)\in\mathcal{E},\;i\neq j\text{ iff }|\{k\neq i:d_{ik}\leq d_{ij}\}|\leq K. \tag{42}\]

This sparsification is neccessary for several reasons: 1) SEvo with a dense adjacency matrix is computationally prohibitive to conduct; 2) Generally, only the top-ranked neighbors are reliable for next distillation. Finally, the adjacency matrix is obtained through reweighting and symmetrizing:

\[w_{ij}=\hat{w}_{ij}+\hat{w}_{ji},\quad\hat{w}_{ij}:=\exp(-d_{ij}/ \tau),\]

where \(\tau>0\) is the kernel bandwidth parameter.

Table 5 reports the results of the SASRec backbone with different embedding sizes (200 versus 20). Although a student equipped with SEvo can only derive guidance from the teacher in terms of embedding modeling, it has surpassed RKD and HTD that focus on feature/output alignments. Recall that SEvo only needs to access the teacher model once for adjacency matrix construction, whereas other knowledge distillation approaches require accessing the teacher model for each update. SEvo is arguably an efficient tool for transferring embedding knowledge. Nevertheless, SEvo alone cannot be expected to facilitate the learning of the other modules, which consequently is still inferior to state-of-the-art methods such as DKD. Fortunately, SEvo and DKD can work together to further boost the recommendation performance.

## Appendix D Additional Experimental Results

### SEvo for GNN-based models

In Section 3 we have comprehensively validated the effectiveness of SEvo for classic sequence models. It is also of interest to explore the impact on GNN-based models that have learned certain

\begin{table}
\begin{tabular}{c c c c c c} \hline \hline  & HR@1 & HR@5 & HR@10 & NDCG@5 & NDCG@10 \\ \hline LESSR & 0.0088 & 0.0322 & 0.0506 & 0.0205 & 0.0264 \\ +SEvo & 0.0126 & 0.0405 & 0.0625 & 0.0267 & 0.0338 \\ \hline Improv. & 43.2\% & 26.0\% & 23.5\% & 30.4\% & 27.9\% \\ \hline MAERec & 0.0113 & 0.0424 & 0.0662 & 0.0269 & 0.0346 \\ +SEvo & 0.0120 & 0.0441 & 0.0677 & 0.0283 & 0.0358 \\ Improv. & 6.7\% & 4.0\% & 2.3\% & 4.9\% & 3.6\% \\ \hline \hline \end{tabular}
\end{table}
Table 6: Beauty recommendation performance comparison. SEvo-enhanced AdamW is applied to LESSR and MAERec.

\begin{table}
\begin{tabular}{c c c c c c} \hline \hline  & HR@1 & HR@5 & HR@10 & NDCG@5 & NDCG@10 \\ \hline Teacher & 0.0198 & 0.0544 & 0.0786 & 0.0374 & 0.0452 \\ \hline Student & 0.0094 & 0.0327 & 0.0526 & 0.0210 & 0.0275 \\ +KD [18] & 0.0105 & 0.0352 & 0.0552 & 0.0229 & 0.0294 \\ +RKD [34] & 0.0082 & 0.0311 & 0.0515 & 0.0196 & 0.0262 \\ +HTD [21] & 0.0085 & 0.0344 & 0.0549 & 0.0215 & 0.0281 \\ +DKD [55] & 0.0138 & 0.0389 & **0.0577** & 0.0265 & 0.0325 \\ \hline Student & 0.0094 & 0.0327 & 0.0526 & 0.0210 & 0.0275 \\ +SEvo & 0.0107 & 0.0364 & 0.0576 & 0.0236 & 0.0304 \\ +DKD & **0.0166** & **0.0407** & 0.0568 & **0.0289** & **0.0341** \\ \hline \hline \end{tabular}
\end{table}
Table 5: Knowledge distillation from Teacher (SASRec with a embedding size of 200) to Student (SASRec with a embedding size of 20). The results are averaged over 5 independent runs on the Beauty dataset. 10-nearest neighbors (_i.e._, \(K=10\)) are selected for each node.

structural information. Table 6 reports the results on LESSR and MAERec: SEvo not only facilitates the learning of LESSR, but also helps MAERec that already utilizes global graph information. This implies that previous efforts fail to fully exploit structural information, while SEvo demonstrates superior performance in this regard.

### \(\mathcal{J}_{smoothness}\) as a Regularization Term

Structural information may be injected by imposing \(\mathcal{J}_{smoothness}\) as a regularization term; that is,

\[\min_{\mathbf{E},\boldsymbol{\theta}}\quad\mathcal{L}(\mathbf{E},\boldsymbol{ \theta})+\lambda\mathcal{J}_{smoothness}(\mathbf{E};\mathcal{G}), \tag{43}\]

where \(\lambda\geq 0\) is a hyperparameter governing the degree of smoothness. We conduct this ablation study in Figure 7 with a \(\lambda\) from \(10^{-6}\) to \(0.01\). As can be seen, incorporating a smoothness regularization term could slightly improve the recommendation performance, but it is not optimal. SEvo performs better because the gradient of the regularization term may be in conflict with the primary loss function.

### \(L\)-layer Approximation

As \(L\) increases, SEvo gets closer to the exact solution while accessing higher-order neighborhood information. Table 7 lists the performance of different layers, which reaches its peak around \(L=3\) and starts to decrease then. A possible reason is that the higher-order information is over-smoothed and thus not as reliable and easy to use as the lower order information. Similar phenomena have been found in previous works [50, 8] on applying GNNs to recommendation.

### Training and Inference Times

The time complexity of SEvo is mainly determined by the arithmetic operations of \(\tilde{\mathbf{A}}^{l}\Delta\mathbf{E},l=1,2,\ldots,L\). Assuming that the number of non-zero entries of \(\tilde{\mathbf{A}}\) is \(S\), the complexity required is about \(\mathcal{O}(LSd)\). Because the recommendation datasets are known for high sparsity (_i.e._, \(S\) is very small), the actual computational overhead can be reduced to a very low level, almost negligible. Table 8 provides the actual training and inference times.

\begin{table}
\begin{tabular}{c||c c c|c c c} \hline \hline  & \multicolumn{3}{c|}{Beauty} & \multicolumn{3}{c}{MovieLens-1M} \\ \hline  & HR@1 & HR@10 & NDCG@10 & HR@1 & HR@10 & NDCG@10 \\ \hline \(L\)=0 & 0.0124 & 0.0664 & 0.0353 & 0.0465 & 0.2487 & 0.1321 \\ \(L\)=1 & 0.0140 & 0.0717 & 0.0388 & 0.0498 & 0.2562 & 0.1372 \\ \(L\)=2 & 0.0152 & 0.0740 & 0.0403 & 0.0511 & **0.2589** & **0.1389** \\ \(L\)=3

[MISSING_PAGE_FAIL:30]

not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.
* The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.
* If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.
* While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren't acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations.
3. **Theory Assumptions and Proofs** Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? Answer: [Yes] Justification: All assumptions and proofs are detailed in Appendix A. Guidelines: * The answer NA means that the paper does not include theoretical results. * All the theorems, formulas, and proofs in the paper should be numbered and cross-referenced. * All assumptions should be clearly stated or referenced in the statement of any theorems. * The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition. * Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material. * Theorems and Lemmas that the proof relies upon should be properly referenced.
4. **Experimental Result Reproducibility** Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? Answer: [Yes] Justification: Please refer to the settings introduced in Section 3. Guidelines: * The answer NA means that the paper does not include experiments. * If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not. * If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable. * Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed. * While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example 1. If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. 2. If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. 3. If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). 4. We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results.
5. **Open access to data and code** Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? Answer: [Yes] Justification: All experiments are conducted on public datasets and the code can be found in the supplementary material. Guidelines: * The answer NA means that paper does not include experiments requiring code. * Please see the NeurIPS code and data submission guidelines ([https://nips.cc/public/guides/CodeSubmissionPolicy](https://nips.cc/public/guides/CodeSubmissionPolicy)) for more details. * While we encourage the release of code and data, we understand that this might not be possible, so "No" is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark). * The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines ([https://nips.cc/public/guides/CodeSubmissionPolicy](https://nips.cc/public/guides/CodeSubmissionPolicy)) for more details. * The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc. * The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why. * At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable). * Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
6. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: The implementation details of baselines and ours can be found in Appendix B.3 and Section 3, respectively. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material. * The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why. * At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable). * Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
6. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: The implementation details of baselines and ours can be found in Appendix B.3 and Section 3, respectively. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material. * The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why. * At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable). * Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
7. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: The implementation details of baselines and ours can be found in Appendix B.3 and Section 3, respectively. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material. * The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why. * At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable). * Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
8. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: The implementation details of baselines and ours can be found in Appendix B.3 and Section 3, respectively. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material. * The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why. * At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable). * Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.
9. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: The implementation details of baselines and ours can be found in Appendix B.3 and Section 3, respectively. Guidelines: * The answer NA means that the paper does not include experiments. * The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. * The full details can be provided either with the code, in appendix, or as supplemental material. * The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why. * At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable). * Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted.

## Appendix A Appendix

### Appendix B.1.

The main experimental setting is to investigate the performance of the proposed method and baselines. The main experimental setting is to investigate the performance of the proposed method and baselines.

7. **Experiment Statistical Significance** Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? Answer: [Yes] Justification: 1) Paired t-test is performed over 5 independent runs (see Table 2). 2) 1-sigma error bars are marked in most figures and tables. Guidelines: * The answer NA means that the paper does not include experiments. * The authors should answer "Yes" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. * The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions). * The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.) * The assumptions made should be given (e.g., Normally distributed errors). * It should be clear whether the error bar is the standard deviation or the standard error of the mean. * It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis of Normality of errors is not verified. * For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates). * If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text.
8. **Experiments Compute Resources** Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? Answer: [Yes] Justification: Please refer to Appendix D.4. Guidelines: * The answer NA means that the paper does not include experiments. * The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage. * The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute. * The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn't make it into the paper).
9. **Code Of Ethics** Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics [https://neurips.cc/public/EthicsGuidelines?](https://neurips.cc/public/EthicsGuidelines?) Answer: [Yes] Justification: [NA] Guidelines: * The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics. * If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.

* The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction).
10. **Broader Impacts** Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? Answer: [Yes] Justification: The broader impact has been discussed in Section 5. Guidelines: * The answer NA means that there is no societal impact of the work performed. * If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact. * Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations. * The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster. * The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology. * If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML).
11. **Safeguards** Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? Answer: [NA] Justification: This work poses no such risks. Guidelines: * The answer NA means that the paper poses no such risks. * Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters. * Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images. * We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort.
12. **Licenses for existing assets** Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? Answer: [Yes]Justification: The source of datasets are credited in Appendix B.2, and all baselines have been introduced in Appendix B.3. Guidelines:

* The answer NA means that the paper does not use existing assets.
* The authors should cite the original paper that produced the code package or dataset.
* The authors should state which version of the asset is used and, if possible, include a URL.
* The name of the license (e.g., CC-BY 4.0) should be included for each asset.
* For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.
* If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.
* For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.
* If this information is not available online, the authors are encouraged to reach out to the asset's creators.
13. **New Assets** Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? Answer: [NA] Justification: [NA] Guidelines:

* The answer NA means that the paper does not release new assets.
* Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.
* The paper should discuss whether and how consent was obtained from people whose asset is used.
* At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file.
14. **Crowdsourcing and Research with Human Subjects** Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? Answer: [NA] Justification: [NA] Guidelines:

* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.
* According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector.
15. **Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects** Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained?Answer: [NA]

Justification: [NA]

Guidelines:

* The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.
* Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.
* We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.
* For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review.