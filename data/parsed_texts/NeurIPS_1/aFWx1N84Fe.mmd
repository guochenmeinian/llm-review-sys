# The Map Equation Goes Neural:

Mapping Network Flows with Graph Neural Networks

Christopher Blocker

Data Analytics Group

Department of Informatics

University of Zurich, Switzerland

christopher.bloecker@uzh.ch &Chester Tan

Chair of Machine Learning for Complex Networks

Center for Artificial Intelligence and Data Science

Julius-Maximilians-Universitat Wurzburg, Germany

chester.tan@uni-wuerzburg.de

Also at Data Analytics Group, Department of Informatics, University of Zurich, Switzerland

Ingo Scholtes

Also at Data Analytics Group, Department of Informatics, University of Zurich, Switzerland

###### Abstract

Community detection is an essential tool for unsupervised data exploration and revealing the organisational structure of networked systems. With a long history in network science, community detection typically relies on objective functions, optimised with custom-tailored search algorithms, but often without leveraging recent advances in deep learning. Recently, first works have started incorporating such objectives into loss functions for deep graph clustering and pooling. We consider the map equation, a popular information-theoretic objective function for unsupervised community detection, and express it in differentiable tensor form for optimisation through gradient descent. Our formulation turns the map equation compatible with any neural network architecture, enables end-to-end learning, incorporates node features, and chooses the optimal number of clusters automatically, all without requiring explicit regularisation. Applied to unsupervised graph clustering tasks, we achieve competitive performance against state-of-the-art deep graph clustering baselines in synthetic and real-world datasets.

## 1 Introduction

Many real-world networked systems are organised in communities: groups of nodes that are more similar to each other than to the rest. Communities provide insights into network structure at the mesoscale, revealing sub-systems by analysing link patterns. Motivated by different research questions, several characterisations of what constitutes "good" communities have been proposed [1, 2], however, neither of them is fundamentally more correct than any other. Moreover, no single community-detection method outperforms all others on any given network [3], motivating the ongoing efforts of research on community detection. Typically, community-detection approaches formulate an objective function that calculates a quality score for a given partition of the network's nodes into communities. Finding the best partition is an NP-hard search problem and often involves custom heuristic algorithms that attempt to minimise their objective function [4, 5, 6].

Graph neural networks (GNNs) have enabled applying deep learning to graph-structured data by utilising the input graph as the neural network's computational graph [7; 8; 9]. Typical tasks for GNNs include node labelling, graph labelling, and link prediction, all of which involve learning meaningful representations jointly from the graph's topology, the nodes' features, and, possibly, the edges' features. Graph labelling relies on coarse-graining the graph through identifying groups of "similar" nodes and aggregating their links and features, also referred to as pooling [10; 11; 12], which is related to graph clustering [13], however, these two tasks have different goals.

While GNNs excel at incorporating node and edge features with graph topology, including this information is also possible but more challenging with traditional network science approaches, typically requiring modelling or adjusting objective functions and their optimisation algorithms. On the other hand, objective functions for community detection provide precise interpretations as to why one partition is considered better than another while deep-learning-based approaches are black boxes. Model selection in deep learning is often done through regularisation techniques or cross-validation; in contrast, objective functions that are based on the minimum description length (MDL) principle naturally implement Occam's razor, preventing overfitting and enabling principled model selection without requiring extra regularisation or cross-validation [14; 15].

Here, we combine the benefits of traditional community-detection approaches and deep learning and consider the map equation, an information-theoretic objective function for community detection [16]. By adapting the map equation for soft cluster assignments and implementing it in differentiable tensor form, we enable end-to-end optimisation of the map equation as a loss function with gradient descent and GNNs. In analogy to the map equation's stochastic optimisation algorithm Infomap [6], we call our approach Neuromap and evaluate it against Infomap and several recent GNN-based graph clustering methods. Applied to synthetic and real-world networks, Neuromap demonstrates competitive performance against recent deep graph clustering baselines.

Our key contributions can be summarised as follows:

1. We adapt the map equation as a differentiable loss function for end-to-end deep graph clustering and propose Neuromap, a deep-learning-based alternative to the popular Infomap algorithm for unsupervised community detection with the map equation. Neuromap is compatible with any neural network architecture, detects overlapping communities, leverages node features for improved performance on real-world networks, and, by following the minimum description length principle, does not require explicit regularisation.
2. We extensively evaluate Neuromap on hundreds of synthetic and ten real datasets against recent baselines paired with various neural network architectures. Neuromap outperforms the baseline on the synthetic networks in most settings and is amongst the best performers in seven out of ten real datasets.
3. By choosing a higher maximum number of clusters than previous works, we show empirically that recent baselines tend to overfit and report considerably more than the ground-truth number of communities. Moreover, we find that choosing a small maximum number of communities is often detrimental to graph clustering performance.

## 2 Related work

Community detection._Communities_, also called _clusters_ or _modules_, are groups of nodes that are more "similar" to each other than to the rest, often understood as having more links inside than between groups [1; 2]. However, this rather general characterisation leaves precise details of what constitutes a community open. Modularity compares the observed link densities inside communities against a randomised version of the network [17]. The stochastic block model and its variants assume a latent block structure where the probability that two nodes are connected depends only on their block memberships [18; 19]. The map equation identifies communities as regions where a random walker tends to stay for a relatively long time [16; 20]. Traditional clustering approaches, such as k-means, group nodes based on their proximity in space, however, here we consider identifying communities from the link patterns in networked systems. For a detailed overview of community detection in complex networks, we refer to [1; 2].

Minimum description length principle.The minimum description length principle (MDL) is a model-selection approach that formalises Occam's razor and frames learning as a compression problem [14; 15]. MDL states that the best model for data \(D\) is the one that compresses the data the most. In traditional MDL, the data's two-part description length \(L\left(D\right)=\min_{M}L\left(M\right)+L\left(D\mid M\right)\) is the smallest achievable length over all models \(M\), where \(L\left(M\right)\) is the model's description length, and \(L\left(D\mid M\right)\) is the data's description length, given the model. MDL has been adopted for a wide range of applications, including regularising neural networks' weights [21], investigating deep neural networks' data-compression capabilities [22], analysing the characteristics of datasets [23], and community detection [16; 24].

Deep graph clustering and pooling.Graph clustering has long been a research focus in machine learning [13; 25]. Spectral approaches cluster, for example, the eigenspace of a graph's Laplacian matrix or identify communities through graph cuts [26; 27]. Methods based on neural embeddings involve learning node representations with, for example, DeepWalk [28] or node2vec [29], followed by applying standard clustering approaches such as k-means, assuming that similar nodes are embedded at similar locations [30; 31]. Other approaches include graph autoencoders [32; 33], contrastive learning [34], and self-expressiveness [35]. Recently, minimum cuts [11; 12], modularity [36; 37], and the Bernoulli-Poisson model [38] have been integrated with GNNs as loss functions for graph pooling and clustering. Such GNN-based approaches can incorporate graph structure as well as node and edge features in end-to-end optimisation of the clustering objective. Inspired by pooling in convolutional neural networks, graph pooling coarse-grains links, node features, and edge features to summarise graphs, enabling GNNs with improved performance on node and graph classification tasks [10; 12]. Consequently, graph pooling has become a research focus for GNNs, emphasising the importance of graph clustering as a primary objective [10; 12; 36]. For recent surveys of deep graph clustering, we refer to [39; 40].

## 3 Background: the map equation

The map equation [16; 20] is an information-theoretic objective function for unsupervised community detection that follows the MDL principle [14], and has demonstrated high performance in synthetic and real networks from across domains [41; 42; 43]. The map equation formulates community detection as a compression problem and uses random walks as a proxy to model dynamic processes on networks, also called _flow_. The goal is to describe the random walk as efficiently as possible by minimising its expected per-step description length - also called _codelength_ - by partitioning the network into groups of nodes, called _modules_, where the random walker tends to stay for a relatively long time. In practice, however, the map equation does not simulate random walks; instead, the codelength is calculated analytically.

Figure 1: Coding principles behind the map equation. Colours indicate modules, codewords are shown next to nodes, and the black trace shows a sequence of random-walker steps. **Left:** All nodes belong to the same module and all codewords are unique. Encoding the random walk sequence requires \(60\) bits, or \(3.72\) bits per step in the limit. **Right:** Partitioning the network enables reusing codewords across modules, reducing the codelength. However, for a unique encoding, we need to introduce codewords for entering and exiting modules, shown next to the arrows pointing into and out of the modules. With this modular coding scheme, we can compress the description to \(48\) bits, or \(3.01\) bits per step in the limit. **Middle:** The two encodings of the random walkerâ€™s steps.

Let \(G=\left(V,E\right)\) be a graph with nodes \(V\), links \(E\), and let \(w_{uv}\in\mathbb{R}_{0}^{+}\) denote the non-negative link weight on the link from node \(u\) to \(v\). When all nodes are assigned to the same module, the codelength is defined by the Shannon entropy \(H\) over the nodes' visit rates [44], \(H\left(P\right)=-\sum_{u\in V}p_{u}\log_{2}p_{u}\), where \(p_{u}\) is node \(u\)'s visit rate and \(P=\left\{p_{u}\,|\,u\in V\right\}\) is the set of node visit rates. In undirected graphs, we compute visit rates directly as \(p_{u}=s_{u}/\sum_{v\in V}s_{v}\), where \(s_{u}=\sum_{v\in V}w_{uv}\) is node \(u\)'s strength. In directed graphs, we compute the visit rates numerically with smart teleportation [45] and a power iteration. When we partition the nodes into modules, the codelength becomes a weighted average of the modules' entropies and the entropy at the so-called index level for switching between modules. Figure 1 illustrates the coding principle behind the map equation using Huffman codes [46]; note, however, that these codewords are only for illustration and we only care about their expected length in the limit to evaluate the map equation.

Minimising the map equation means balancing between small modules to achieve low module-level entropies and large modules for low index-level entropy. This trade-off between module- and index-level entropies prevents trivial solutions where all nodes are assigned to the same module or each node is assigned to a singleton module [14]. The map equation calculates the codelength for a partition \(\mathsf{M}\),

\[L\left(\mathsf{M}\right)=qH(Q)+\sum_{\mathsf{m}\in\mathsf{M}}p_{\mathsf{m}}H(P _{\mathsf{m}})\,. \tag{1}\]

Here, \(q=\sum_{\mathsf{m}}q_{\mathsf{m}}\) is the random walker's module entry rate, \(q_{\mathsf{m}}=\sum_{u\notin\mathsf{m}}\sum_{v\in\mathsf{m}}p_{u}t_{uv}\) is module \(\mathsf{m}\)'s entry rate, and \(Q=\left\{q_{\mathsf{m}}/q\;|\;\mathsf{m}\in\mathsf{M}\right\}\) is the set of normalised module entry rates; \(p_{\mathsf{m}}=\mathsf{m}_{\text{exit}}+\sum_{u\in\mathsf{m}}p_{u}\) is the rate at which the random walker moves in module \(\mathsf{m}\), including the module exit rate \(\mathsf{m}_{\text{exit}}=\sum_{u\in\mathsf{m}}\sum_{v\notin\mathsf{m}}p_{u}t_{uv}\), and \(P_{\mathsf{m}}=\left\{\mathsf{m}_{\text{exit}}/p_{\mathsf{m}}\right\}\cup \left\{p_{u}/p_{\mathsf{m}}\;|\;u\in\mathsf{m}\right\}\) is the set of normalised node visit and exit rates for module \(\mathsf{m}\). The random walker's transition probability from node \(u\) to \(v\) is \(t_{uv}=w_{uv}/\sum_{v\in V}w_{uv}\). We can rewrite the map equation as (see Appendix A)

\[L\left(\mathsf{M}\right)=q\log_{2}q-\sum_{\mathsf{m}\in\mathsf{M}}q_{\mathsf{ m}}\log_{2}q_{\mathsf{m}}-\sum_{\mathsf{m}\in\mathsf{M}}m_{\text{exit}}\log_{2} \mathsf{m}_{\text{exit}}-\sum_{u\in V}p_{u}\log_{2}p_{u}+\sum_{\mathsf{m}\in \mathsf{M}}p_{\mathsf{m}}\log_{2}p_{\mathsf{m}}. \tag{2}\]

The map equation framework has been extended for overlapping communities through state-space expansions with higher-order network models [47; 48], avoiding over-partitioning in sparse networks using a Bayesian regularisation approach [49], and to deal with sparse constrained structures [50]. Moreover, the map equation framework can incorporate node features through an extension [51] or by preprocessing data [52]. Detecting communities relies on Infomap [6], a greedy stochastic search algorithm that optimises the map equation. However, each of the above extensions requires preprocessing the input data, adjusting the loss function, or adapting the search algorithm. In contrast, adapting the map equation as a loss function for optimisation with gradient descent does not require any custom algorithm, thus enabling flexible experimentation with variations, scalability to GPU clusters, and incorporating it into other loss functions.

## 4 The map equation goes neural

We set out to detect communities by optimising the map equation with GNNs through gradient descent, which essentially means learning coarse-graining node representations in the form of communities (Figure 2). While the standard map equation considers hard clusters where each node is assigned to exactly one module, we introduce a soft cluster assignment matrix \(\mathbf{S}_{n\times s}\) to make the map equation differentiable and enable overlapping clusters. We optimise \(\mathbf{S}=\operatorname{softmax}\left(\operatorname{GNN}_{\theta}\left( \mathbf{A},\mathbf{X}\right)\right)\) indirectly by optimising the GNN's parameters \(\theta\), that is, its weights, with respect to the codelength \(L\). Here, \(\mathbf{A}_{n\times n}\) is the graph's adjacency matrix, \(\mathbf{X}_{n\times d}\) is the node features matrix, \(n=\left|V\right|\) is the number of nodes, \(s\) is the maximum allowed number of clusters, and \(d\) is the node feature dimension.

Without loss of generality, we assume directed networks. We denote the graph's total weight as \(w_{\text{tot}}=\sum_{i\in V}\sum_{j\in V}w_{ij}\). Let \(\mathbf{T}_{n\times n}\) be the random walker's transition matrix and \(\mathsf{d}^{\text{in}}\) be the vector of weighted node in-degrees with

\[\mathbf{T}_{ij}=\begin{cases}\dfrac{w_{ij}}{\sum_{j\in V}w_{ij}}&\text{if } \sum_{j\in V}w_{ij}>0,\\ 0&\text{otherwise,}\end{cases}\qquad\qquad\mathbf{d}^{\text{in}}_{j}=\sum_{i \in V}w_{ij}.\]

To compute the vector \(\mathbf{p}\) of node visit rates, we use smart teleportation [45] and the power iteration method: With probability \(\alpha\), the random walker teleports to a random node, chosen proportionally to the nodes' in-degrees, or follows a link with probability \(1-\alpha\). This approach leads to the iterative update rule \(\mathbf{p}^{(t+1)}\leftarrow\frac{\alpha}{u_{\text{m}}}\mathbf{d}^{\mathbf{in}}+ \left(1-\alpha\right)\mathbf{p}^{(t)}\mathbf{T}\), and we set \(\mathbf{p}^{(0)}=\mathbf{d}^{\mathbf{in}}\). The graph's flow matrix \(\mathbf{F}_{n\times n}\) encodes the flow between each pair of nodes, where \(\mathbf{F}=\frac{\alpha}{u_{\text{m}}}\mathbf{A}+\left(1-\alpha\right)\operatorname {diag}\left(\mathbf{p}\right)\mathbf{T}\). We obtain the flow \(\mathbf{C}_{s\times s}\) between clusters from \(\mathbf{S}\) and \(\mathbf{F}\) as \(\mathbf{C}=\mathbf{S}^{\top}\mathbf{F}\mathbf{S}\). Following Equation (2), we define

\[q=1-\operatorname{tr}\left(\mathbf{C}\right)\quad\mathbf{q}_{\text{m}}= \mathbf{C}\mathbf{1}_{s}-\operatorname{diag}\left(\mathbf{C}\right)\quad \mathbf{m}_{\text{exit}}=(\mathbf{1}_{s}^{\top}\mathbf{C})^{\top}- \operatorname{diag}\left(\mathbf{C}\right)\quad\mathbf{p}_{\text{m}}=\mathbf{ q}_{\text{m}}+\mathbf{1}_{s}^{\top}\mathbf{C}\]

and assemble the map equation

\[L\left(\mathbf{A},\mathbf{S}\right)=q\log_{2}q-\left(\mathbf{q}_{\text{m}}\log _{2}\mathbf{q}_{\text{m}}\right)\mathbf{1}_{s}-\left(\mathbf{m}_{\text{exit} }\log_{2}\mathbf{m}_{\text{exit}}\right)\mathbf{1}_{s}-\left(\mathbf{p}\log_{ 2}\mathbf{p}\right)\mathbf{1}_{n}+\left(\mathbf{p}_{\text{m}}\log_{2}\mathbf{p }_{\text{m}}\right)\mathbf{1}_{s} \tag{3}\]

where \(\mathbf{1}_{k}\) is the \(k\)-dimensional vector of ones, and logarithms are applied component-wise. The third term is constant since it only depends on the node visit rates and can be omitted during optimisation.

The map equation naturally incorporates Occam's razor by following the MDL principle for balancing between model complexity and fit [14; 15], choosing the optimal number of communities automatically, but at most \(s\). In contrast, recent GNN-based clustering approaches require explicit regularisation to avoid over-partitioning [10; 36; 37; 38], and our results show that they often return the maximum allowed number of communities instead of determining the number of communities in a data-driven fashion (see Section 5). In principle, any neural network architecture, such as a multi-layer perceptron (MLP) or GNN, can be used to learn the soft cluster assignment matrix \(\mathbf{S}\). Since the map equation involves logarithms, we add a small constant \(\epsilon\) to each value in the output \(\mathbf{S}\) before the backpropagation step to ensure differentiability. We refer to the combination of using map equation loss (Equation (3)) together with a (graph) neural network to learn (overlapping) communities as _Neuromap_.

Complexity and limitations.The most expensive calculation is the pooling operation \(\mathbf{C}=\mathbf{S}^{\top}\mathbf{F}\mathbf{S}\) which depends on the network's density. When \(s\ll n\) and the number of edges is \(m=\mathcal{O}\left(n\right)\), the complexity of Neuromap is linear in \(n\). When the network is dense, \(m=\mathcal{O}\left(n^{2}\right)\), or the maximum number of clusters approaches the number of nodes \(s\approx n\), we approach quadratic complexity. Therefore, we recommend keeping \(s\ll n\) for scalability.

We assume connected networks, otherwise, clustering should be run on the individual components. The node features \(\mathbf{X}\) aid the GNN in learning patterns, however, they do not contribute to the loss. When no node features are available, Neuromap can use, for example, the adjacency matrix as node features; designing expressive low-dimensional node features remains an active research area [53].

## 5 Experimental evaluation

We evaluate Neuromap on synthetic and real-world networks with different neural network architectures: a 2-layer graph convolutional network (GCN) [9], a 2-layer graph isomorphism network (GIN) [54], and a 2-layer SAGE network [55]. To investigate whether GNNs are required for clustering, we also include a fully connected linear layer and a 2-layer MLP. We include a learnable temperature

Figure 2: Illustration of the setup for GNN-based community detection with the map equation. We learn soft cluster assignments \(\mathbf{S}\) from the graphs adjacency matrix \(\mathbf{A}\) and the node features \(\mathbf{X}\). Here, we allow up to four clusters. When no node features are available, we set \(\mathbf{X}=\mathbf{A}\).

parameter for the softmax operation, which we found speeds up convergence. In all cases, we use the models provided by PyTorch Geometric with SELU activation [56]. Because the specifics between architectures differ, such as message-passing details and aggregation functions, they may be interpreted as using different search algorithms which return different communities. We use the Adam optimiser [57], apply batch normalisation, and for comparability between different methods, set the learning rate for the linear layer to \(10^{-1}\), for MLP to \(10^{-2}\), and for GCN, GIN, and SAGE to \(10^{-3}\). We train all models for up to \(10{,}000\) epochs with a patience of \(100\) epochs and dropout probability \(0.5\). Because the datasets contain hard clusters, we convert the resulting communities to hard clusters, assigning each node to that cluster where it has its strongest membership. As baselines, we use Infomap [6] and five recent approaches for unsupervised graph clustering with GNNs: DMoN [36], NOCD [38], DiffPool [10], MinCut [11], and Ortho [36]. We base our implementation3 on PyTorch [58] and PyTorch Geometric [59] and ran our experiments on a workstation with an Intel i9-11900K @ 3.50GHz CPU, 32 GB of RAM, and a GeForce RTX 3090 with 24 GB of memory.

Footnote 3: [https://github.com/chrisbloecker/neuromap](https://github.com/chrisbloecker/neuromap)

### Synthetic networks with planted communities

We generate directed and undirected Lancichinetti-Fortunato-Radicchi (LFR) benchmark networks with planted ground-truth communities [60] with \(n=1000\) nodes, average node degree \(k\in\{\ln n,2\ln n\}\), maximum node degree \(k_{\max}=2\sqrt{n}\), both rounded to the nearest integer, and mixing parameter \(\mu\) between \(0.1\) and \(0.8\) with a step size of \(0.1\). We set the power-law exponents for the node degree distribution to \(\tau_{1}=2\), and for the community size distribution to \(\tau_{2}=1\). For each combination of parameters, we generate \(10\) LFR networks using the implementation provided by the authors,4 resulting in a total of 320 networks. For each parameter combination, there are 10 LFR networks; for each of these LFR networks, we run each model 10 times, measuring its performance as the average adjusted mutual information (AMI) [61] against the ground truth, and plot the average of those AMI values over the 10 networks per parameter combination. To verify that the number of communities is inferred from the data, we set the maximum number of communities to \(s=n\). Since LFR networks do not have node features, we use the adjacency matrix as node features.

Footnote 4: [https://sites.google.com/site/andrealancichinetti/benchmarks](https://sites.google.com/site/andrealancichinetti/benchmarks)

Figure 3: Performance for Neuromap using a dense linear layer, MLP, GCN, GIN, and SAGE architectures with two layers and Infomap on directed and undirected LFR networks with planted communities. The results show averages of partition quality measured with AMI, number of detected communities \(|\mathsf{M}|\), and codelength \(L\). The shaded areas show one standard deviation from the mean.

We find that the detected communities' quality depends on the choice of neural network architecture (Figure 3). Neuromap achieves the best AMI scores with SAGE. GCN, MLP, and Infomap perform slightly worse, however, with some variation depending on the networks' properties. The dense linear layer and GIN show weaker performance but still identify relevant communities. In the sparser directed networks, Infomap performs slightly better than SAGE when the mixing \(\mu\) is low. However, the AMI values do not tell the whole story: Infomap and MLP tend to report considerably more communities than are present in the ground truth whereas the dense linear layer and GIN tend to report much fewer communities than the ground truth, especially for higher mixing values. GCN reports more communities than are present in the ground truth in the sparser undirected networks but fewer in the directed networks. SAGE detects close to the true number of communities in all cases. Infomap achieves the lowest codelength across all networks. GCN, MLP, and SAGE achieve close to Infomap's codelength, whereas the dense linear layer and GIN have slightly higher codelength.

We compare Neuromap against recent deep-learning-based community detection methods on the same networks by swapping out the loss function while keeping everything else the same, with the exception of using weight decay for NOCD as per the original paper [38]. For DiffPool, Mincut, Ortho, and DMoN, we use the implementation from PyTorch Geometric, for NOCD, we use the implementation provided by the authors.5 Figure 4 shows the results for SAGE; in Appendix B, we also include results for the remaining architectures. Neuromap outperforms the baselines across all architectures, except for NOCD which performs better than Neuromap with GIN and with GCN on directed networks. Different from previous works, we have not limited the maximum number of communities, which allows us to analyse the methods' overfitting behaviour: While Neuromap reports close to the ground-truth number of communities, the remaining methods often overfit the networks' structure and report considerably more communities (note the logarithmic scale). MinCut fails to identify meaningful communities on directed networks for mixing values \(\mu>0.3\). NOCD performs best with the GCN architecture, which was also used in the original paper [38]. Neuromap performs best with SAGE in our experiments.

Footnote 5: [https://github.com/shchur/overlapping-community-detection](https://github.com/shchur/overlapping-community-detection)

### Real-world networks with node features

We benchmark Neuromap on ten real-world datasets (Table 1) from PyTorch Geometric [59], PyTorch Geometric Signed Directed [62], and Open Graph Benchmark [63], and compare it against the same baselines as before. In contrast to previous works that choose a fixed number of hidden dimensions and set the maximum number of communities to a constant [36] or the "ground-truth" number of communities [38], we reflect the networks' sizes in our choices: We set the number of hidden dimensions to \(4\sqrt{n}\) and the maximum number of communities to \(s=\sqrt{n}\). Our choices are based on empirical observations showing that the number of communities typically scales as \(\mathcal{O}\left(\sqrt{n}\right)\)[64].

Figure 4: SAGE-based results for deep learning community-detection methods on synthetic LFR networks with planted communities. We show averages of partition quality measured by AMI and number of detected communities \(|\mathsf{M}|\). The shaded areas show one standard deviation from the mean.

However, a few words of caution are in order: while nodes' true communities determine the link patterns in synthetic networks, it is generally infeasible to obtain ground truth communities for real networks. Often, metadata labels are used as a drop-in, and the inferred communities' quality depends on how well the metadata, which is potentially noisy, aligns with the unknown ground truth [3]. Moreover, determining the number of communities in a network is hard and setting \(s=\sqrt{n}\) should be seen as a simplification rather than an attempt to guess the exact number.

For each method and architecture, we run 25 trials and show the average achieved AMI in Figure 5; we include a similar plot for the number of detected communities as well as the average AMI and the detected number of communities, both with standard deviations, in tabulated form in Appendix C. When several of the best-performing methods achieve similar AMI, we use an independent two-sample t-test to determine whether one of them can be considered to perform better than the other (see Appendix C). In cases where their performances do not differ significantly, we mark both as best.

Neuromap and NOCD are amongst the best performers in seven cases and DiffPool in two. The GCN architecture performs best in seven cases, MLP and SAGE in four cases, and GIN in two cases. A

\begin{table}
\begin{tabular}{l l l r r r r} \hline \hline Dataset & Source & Type & \(|V|\) & \(|E|\) & \(|X|\) & \(|Y|\) & \(\mu\) \\ \hline Cora & PyG & Undirected & 2,708 & 5,278 & 1,433 & 7 & 0.19 \\ CiteSeer & PyG & Undirected & 3,327 & 4,614 & 3,703 & 6 & 0.26 \\ Pubmed & PyG & Undirected & 19,717 & 44,325 & 500 & 3 & 0.20 \\ Amazon Computer (PC) & PyG & Undirected & 13,752 & 143,604 & 767 & 10 & 0.22 \\ Amazon Photo & PyG & Undirected & 7,650 & 71,831 & 745 & 8 & 0.17 \\ Coauthor CS & PyG & Undirected & 18,333 & 81,894 & 6,805 & 15 & 0.19 \\ Coauthor Physics & PyG & Undirected & 34,493 & 247,962 & 8,415 & 5 & 0.07 \\ Cora ML & PyG-SD & Directed & 2,995 & 8,416 & 2,879 & 7 & 0.21 \\ Wiki CS & PyG-SD & Directed & 11,701 & 297,110 & 300 & 10 & 0.31 \\ ogb-arxiv & OGB & Directed & 169,343 & 583,121 & 128 & 40 & 0.35 \\ \hline \hline \end{tabular}
\end{table}
Table 1: Properties of the real-world datasets obtained from PyTorch Geometric (PyG) [59], PyTorch Geometric Signed Directed (PyG-SD) [62], and Open Graph Benchmark (OGB) [63]. \(|V|\) is the number of nodes, \(|E|\) the number of edges, \(|X|\) the node feature dimension, \(|Y|\) the number of communities, and \(\mu\) the mixing for the given communities.

Figure 5: Average achieved AMI on real-world networks (higher is better) with \(s=\sqrt{n}\). Colours indicate methods while shapes indicate neural network architectures. DiffPool ran out of memory on the ogb-arxiv dataset. Detailed tabulated results with standard deviations are included in Appendix C.

possible explanation for why the simpler linear layer and MLP architectures perform well in several cases could be that the map equation loss function captures global information in the random walker's flow patterns, making GNNs superfluous in some cases. All methods tend to detect more communities than are present in the "ground truth", however, this tendency is most pronounced in DMoN, Ortho, and MinCut, which may have gone unnoticed in previous evaluations where the maximum number of communities was set to a much lower, constant value [36], thus artificially preventing overfitting. Infomap is the only baseline that does not utilise node features; instead, it relies solely on topological information, which may explain the large number of detected communities. Comparing Neuromap's performance against Infomap's performance suggests that incorporating node features substantially improves the detected communities' quality in most cases (see Appendix C for significance tests) while drastically reducing the number of detected communities.

We repeat the same experiments with 512 hidden features and \(s=|Y|\), that is, the "true" number of communities, following [38] (results in Appendix D). Limiting the number of allowed communities often leads to better performance for DMoN, MinCut, and Ortho, however, with a few exceptions, it diminishes the performance of Neuromap, NOCD, and DiffPool across all datasets and neural network architectures. Appendix E tabulates the differences in average AMI score between setting the hidden features to \(4\sqrt{n}\) and \(s=\sqrt{n}\) versus using \(512\) hidden features and \(s=|Y|\). In the case of Neuromap, imposing a lower bound on the number of communities interferes with the MDL principle, limiting what models for the data may be explored.

### Synthetic networks with overlapping communities

We apply Neuromap and the baselines to a small synthetic network with overlapping communities [65]. We set the maximum number of communities to \(s\in\{2,3\}\), run each combination of loss function and neural network architecture for 10 trials, and keep the solutions with the lowest loss. Figure 6 shows the results obtained with GCN, Appendix F shows results for the remaining architectures.

We find that Neuromap, DMoN, NOCD, and MinCut identify the correct communities for \(s=2\). DiffPool does not detect overlapping communities and Ortho assigns each node to two communities. For \(s=3\), only Neuromap identifies the correct communities. DiffPool returns the same communities as for \(s=2\). All remaining methods return three communities. These results provide further evidence that the baselines suffer from overfitting when they are not provided with the correct number of communities, which, in general, is unknown. Neuromap identifies meaningful communities while inferring the number of communities in a data-driven fashion by following the MDL principle. However, we leave a more rigorous study of overlapping communities for future work.

Figure 6: Synthetic network with overlapping communities where the leftmost network shows the true community structure. Nodes are drawn as pie charts to visualise their community assignments. The top and bottom rows show results for a maximum of \(s=2\) and \(s=3\) communities, respectively.

Conclusion

Network science and deep learning on graphs tackle community detection from different perspectives. Community detection in network science typically relies on custom heuristic optimisation algorithms to optimise objective functions but often does not leverage recent deep learning advances. Recently, deep graph learning methods have started to incorporate methods from network science for deep graph clustering. We contribute to this young field by adapting the map equation, a popular unsupervised information-theoretic community-detection approach, as a differentiable loss function for end-to-end optimisation with (graph) neural networks through gradient descent, and use PyTorch to implement our approach, which we call Neuromap.

We evaluated Neuromap on various synthetic and real-world datasets, using different neural network architectures to detect communities. Our results show that Neuromap achieves competitive performance and detects close to the ground-truth number of communities across datasets while the baselines tend to overfit and report considerably more communities. Across all tested methods, the achieved performance depends on the used neural network architecture. However, on several real-world benchmarks, Neuromap outperforms several of the the baselines even with simpler, non-GNN, neural network architectures. We hypothesise that this may be because the map equation builds on capturing flow patterns, which contain global information.

While we have considered first-order networks with two-level community structures, complex real-world networks often involve higher-order dependencies and can have multi-level communities [47, 66], prompting a generalisation of our approach. Furthermore, incorporating our method for graph pooling as well as uncovering the precise connection between the utilised neural network architecture and the achieved community-detection performance requires further empirical and theoretical studies.

## Acknowledgments and Disclosure of Funding

We thank Martin Rosvall, Jelena Smiljanic, and Daniel Edler for fruitful discussions and helpful feedback. We are indebted to Lisi Qarkaxhija for helping with PyTorch implementations. Christopher Blocker and Ingo Scholtes acknowledge funding from the Swiss National Science Foundation, grant 176938, and the German Federal Ministry of Education and Research, grant 100582863 (TissueNet).

## References

* [1] Santo Fortunato. Community detection in graphs. _Physics Reports_, 486(3):75-174, 2010.
* [2] Santo Fortunato and Mark EJ Newman. 20 years of network community detection. _Nature Physics_, 18(8):848-850, 2022.
* [3] Leto Peel, Daniel B. Larremore, and Aaron Clauset. The ground truth about metadata and community detection in networks. _Science Advances_, 3(5):e1602548, 2017.
* [4] Vincent D Blondel, Jean-Loup Guillaume, Renaud Lambiotte, and Etienne Lefebvre. Fast unfolding of communities in large networks. _Journal of Statistical Mechanics: Theory and Experiment_, 2008(10):P10008, oct 2008.
* [5] V. A. Traag, L. Waltman, and N. J. van Eck. From louvain to leiden: guaranteeing well-connected communities. _Scientific Reports_, 9(1):5233, Mar 2019.
* [6] Daniel Edler, Ludvig Bohlin, and Martin Rosvall. Mapping higher-order network flows in memory and multilayer networks with infomap. _Algorithms_, 10(4), 2017.
* [7] Franco Scarselli, Marco Gori, Ah Chung Tsoi, Markus Hagenbuchner, and Gabriele Monfardini. The graph neural network model. _IEEE Transactions on Neural Networks_, 20(1):61-80, 2009.
* [8] Justin Gilmer, Samuel S. Schoenholz, Patrick F. Riley, Oriol Vinyals, and George E. Dahl. Neural message passing for quantum chemistry. In _Proceedings of the 34th International Conference on Machine Learning_, volume 70 of _Proceedings of Machine Learning Research_, pages 1263-1272. PMLR, 06-11 Aug 2017.

* [9] Thomas N. Kipf and Max Welling. Semi-supervised classification with graph convolutional networks. In _International Conference on Learning Representations_, 2017.
* [10] Zhitao Ying, Jiaxuan You, Christopher Morris, Xiang Ren, Will Hamilton, and Jure Leskovec. Hierarchical graph representation learning with differentiable pooling. _Advances in neural information processing systems_, 31, 2018.
* [11] Filippo Maria Bianchi, Daniele Grattarola, and Cesare Alippi. Spectral clustering with graph neural networks for graph pooling. In _International conference on machine learning_, pages 874-883. PMLR, 2020.
* [12] Filippo Maria Bianchi and Veronica Lachi. The expressive power of pooling in graph neural networks. In _Advances in Neural Information Processing Systems_, volume 36, pages 71603-71618. Curran Associates, Inc., 2023.
* [13] Satu Elisa Schaeffer. Graph clustering. _Computer science review_, 1(1):27-64, 2007.
* [14] Jorma Rissanen. Modeling by shortest data description. _Automatica_, 14(5):465-471, 1978.
* [15] Peter D Grunwald, In Jae Myung, and Mark A Pitt. _Advances in minimum description length: Theory and applications_. MIT press, 2005.
* [16] Martin Rosvall and Carl T. Bergstrom. Maps of random walks on complex networks reveal community structure. _Proceedings of the National Academy of Sciences_, 105(4):1118-1123, 2008.
* [17] M. E. J. Newman. Modularity and community structure in networks. _Proceedings of the National Academy of Sciences_, 103(23):8577-8582, 2006.
* [18] Paul W. Holland, Kathryn Blackmond Laskey, and Samuel Leinhardt. Stochastic blockmodels: First steps. _Social Networks_, 5(2):109-137, 1983.
* [19] Tiago P Peixoto. Efficient monte carlo and greedy heuristic for the inference of stochastic block models. _Physical Review E_, 89(1):012804, 2014.
* [20] M. Rosvall, D. Axelsson, and C. T. Bergstrom. The map equation. _The European Physical Journal Special Topics_, 178(1):13-23, Nov 2009.
* [21] Geoffrey E Hinton and Drew Van Camp. Keeping the neural networks simple by minimizing the description length of the weights. In _Proceedings of the sixth annual conference on Computational learning theory_, pages 5-13, 1993.
* [22] Leonard Blier and Yann Ollivier. The description length of deep learning models. In _Advances in Neural Information Processing Systems_, volume 31. Curran Associates, Inc., 2018.
* [23] Ethan Perez, Douwe Kiela, and Kyunghyun Cho. Rissanen data analysis: Examining dataset characteristics via description length. In _Proceedings of the 38th International Conference on Machine Learning_, volume 139 of _Proceedings of Machine Learning Research_, pages 8500-8513. PMLR, 18-24 Jul 2021.
* [24] Tiago P. Peixoto. Hierarchical block structures and high-resolution model selection in large networks. _Phys. Rev. X_, 4:011047, Mar 2014.
* [25] Kai Yu, Shipeng Yu, and Volker Tresp. Soft clustering on graphs. _Advances in neural information processing systems_, 18, 2005.
* [26] Jianbo Shi and Jitendra Malik. Normalized cuts and image segmentation. _IEEE Transactions on pattern analysis and machine intelligence_, 22(8):888-905, 2000.
* [27] Ulrike von Luxburg. A tutorial on spectral clustering. _Statistics and Computing_, 17(4):395-416, Dec 2007.
* [28] Bryan Perozzi, Rami Al-Rfou, and Steven Skiena. Deepwalk: Online learning of social representations. In _Proceedings of the 20th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining_, KDD '14, page 701-710, New York, NY, USA, 2014. Association for Computing Machinery.

* [29] Aditya Grover and Jure Leskovec. Node2vec: Scalable feature learning for networks. In _Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining_, KDD '16, page 855-864, New York, NY, USA, 2016. Association for Computing Machinery.
* [30] Aditya Tandon, Aiiad Albeshri, Vijey Thayananthan, Wadee Alhalabi, Filippo Radicchi, and Santo Fortunato. Community detection in networks using graph embeddings. _Physical Review E_, 103(2):022316, 2021.
* [31] Sadamori Kojaku, Filippo Radicchi, Yong-Yeol Ahn, and Santo Fortunato. Network community detection via neural embeddings. _arXiv preprint arXiv:2306.13400_, 2023.
* [32] Chun Wang, Shirui Pan, Guodong Long, Xingquan Zhu, and Jing Jiang. Mgae: Marginalized graph autoencoder for graph clustering. In _Proceedings of the 2017 ACM on Conference on Information and Knowledge Management_, pages 889-898, 2017.
* [33] Nairouz Mrabah, Mohamed Bouguessa, Mohamed Fawzi Touati, and Riadh Ksantini. Rethinking graph auto-encoder models for attributed graph clustering. _IEEE Transactions on Knowledge and Data Engineering_, 2022.
* [34] Maedeh Ahmadi, Mehran Safayani, and Abdolreza Mirzaei. Deep graph clustering via mutual information maximization and mixture model. _Knowledge and Information Systems_, Apr 2024.
* [35] Sambaran Bandyopadhyay and Vishal Peter. Unsupervised constrained community detection via self-expressive graph neural network. In _Uncertainty in Artificial Intelligence_, pages 1078-1088. PMLR, 2021.
* [36] Anton Tsitsulin, John Palowitch, Bryan Perozzi, and Emmanuel Muller. Graph clustering with graph neural networks. _Journal of Machine Learning Research_, 24(127):1-21, 2023.
* [37] Tsuyoshi Murata and Naveed Afzal. Modularity optimization as a training criterion for graph neural networks. In _Complex Networks IX_, pages 123-135, Cham, 2018. Springer International Publishing.
* [38] Oleksandr Shchur and Stephan Gunnemann. Overlapping community detection with graph neural networks. _Deep Learning on Graphs Workshop, KDD_, 2019.
* [39] Liu Yue, Xia Jun, Zhou Sihang, Wang Siwei, Guo Xifeng, Yang Xihong, Liang Ke, Tu Wenxuan, Liu Xin Wang, et al. A survey of deep graph clustering: Taxonomy, challenge, and application. _arXiv preprint arXiv:2211.12875_, 2022.
* [40] Su Xing, Xue Shan, Liu Fanzhen, Wu Jia, Yang Jian, Zhou Chuan, Hu Wenbin, Paris Cecile, Nepal Surya, Jin Di, et al. A comprehensive survey on community detection with deep learning. _IEEE Trans. Neural Netw. Learn. Syst_, 2022.
* [41] Andrea Lancichinetti and Santo Fortunato. Community detection algorithms: A comparative analysis. _Phys. Rev. E_, 80:056117, 2009.
* [42] Rodrigo Aldecoa and Ignacio Marin. Exploring the limits of community detection strategies in complex networks. _Sci. Rep._, 3:2216, 2013.
* [43] Lovro Subelj, Nees Jan van Eck, and Ludo Waltman. Clustering scientific publications based on citation relations: A systematic comparison of different methods. _PLOS ONE_, 11(4):1-23, 04 2016.
* [44] C. E. Shannon. A mathematical theory of communication. _Bell Syst. Tech. J._, 27:379-423, 1948.
* [45] R. Lambiotte and M. Rosvall. Ranking and clustering of nodes in networks with smart teleportation. _Phys. Rev. E_, 85:056107, May 2012.
* [46] David A. Huffman. A method for the construction of minimum-redundancy codes. _Proceedings of the IRE_, 40(9):1098-1101, 1952.

* [47] Martin Rosvall, Alcides V. Esquivel, Andrea Lancichinetti, Jevin D. West, and Renaud Lambiotte. Memory in network flows and its effects on spreading dynamics and community detection. _Nature Communications_, 5(1):4630, Aug 2014.
* [48] Anton Holmgren, Christopher Blocker, and Martin Rosvall. Mapping biased higher-order walks reveals overlapping communities, 2023.
* [49] Jelena Smiljanic, Christopher Blocker, Daniel Edler, and Martin Rosvall. Mapping flows on weighted and directed networks with incomplete observations. _Journal of Complex Networks_, 9(6):cnab044, 12 2021.
* [50] Daniel Edler, Jelena Smiljanic, Anton Holmgren, Alexandre Antonelli, and Martin Rosvall. Variable markov dynamics as a multi-focal lens to map multi-scale complex networks, 2022.
* [51] Scott Emmons and Peter J. Mucha. Map equation with metadata: Varying the role of attributes in community detection. _Phys. Rev. E_, 100:022301, Aug 2019.
* [52] Aleix Bassolas, Anton Holmgren, Antoine Marot, Martin Rosvall, and Vincenzo Nicosia. Mapping nonlocal relationships between metadata and network structure with metadata-dependent encoding of random walks. _Science Advances_, 8(43):eabn7558, 2022.
* [53] Derek Lim, Joshua David Robinson, Lingxiao Zhao, Tess Smidt, Suvrit Sra, Haggai Maron, and Stefanie Jegelka. Sign and basis invariant networks for spectral graph representation learning. In _The Eleventh International Conference on Learning Representations_, 2023.
* [54] Keyulu Xu, Weihua Hu, Jure Leskovec, and Stefanie Jegelka. How powerful are graph neural networks? In _International Conference on Learning Representations_, 2019.
* [55] Will Hamilton, Zhitao Ying, and Jure Leskovec. Inductive representation learning on large graphs. In _Advances in Neural Information Processing Systems_, volume 30. Curran Associates, Inc., 2017.
* [56] Gunter Klambauer, Thomas Unterthiner, Andreas Mayr, and Sepp Hochreiter. Self-normalizing neural networks. _Advances in neural information processing systems_, 30, 2017.
* [57] Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization, 2017.
* [58] Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan, Trevor Killeen, Zeming Lin, Natalia Gimelshein, Luca Antiga, Alban Desmaison, Andreas Kopf, Edward Yang, Zachary DeVito, Martin Raison, Alykhan Tejani, Sasank Chilamkurthy, Benoit Steiner, Lu Fang, Junjie Bai, and Soumith Chintala. PyTorch: An Imperative Style, High-Performance Deep Learning Library. In _Advances in Neural Information Processing Systems 32_, pages 8024-8035. Curran Associates, Inc., 2019.
* [59] Matthias Fey and Jan Eric Lenssen. Fast graph representation learning with pytorch geometric. _arXiv preprint arXiv:1903.02428_, 2019.
* [60] Andrea Lancichinetti, Santo Fortunato, and Filippo Radicchi. Benchmark graphs for testing community detection algorithms. _Phys. Rev. E_, 78:046110, Oct 2008.
* [61] Simone Romano, James Bailey, Vinh Nguyen, and Karin Verspoor. Standardized mutual information for clustering comparisons: One step further in adjustment for chance. In _Proceedings of the 31st International Conference on Machine Learning_, volume 32 of _Proceedings of Machine Learning Research_, pages 1143-1151, Bejing, China, 22-24 Jun 2014. PMLR.
* [62] Yixuan He, Xitong Zhang, Junjie Huang, Benedek Rozemberczki, Mihai Cucuringu, and Gesine Reinert. Pytorch geometric signed directed: A software package on graph neural networks for signed and directed graphs. In _Learning on Graphs Conference_, pages 12-1. PMLR, 2024.
* [63] Weihua Hu, Matthias Fey, Marinka Zitnik, Yuxiao Dong, Hongyu Ren, Bowen Liu, Michele Catasta, and Jure Leskovec. Open graph benchmark: Datasets for machine learning on graphs. _Advances in neural information processing systems_, 33:22118-22133, 2020.

* [64] Amir Ghasemian, Homa Hosseinmardi, and Aaron Clauset. Evaluating overfit and underfit in models of network community structure. _IEEE Transactions on Knowledge and Data Engineering_, 32(9):1722-1735, 2020.
* [65] Alcides Viamontes Esquivel and Martin Rosvall. Compression of flow can reveal overlapping-module organization in networks. _Phys. Rev. X_, 1:021025, Dec 2011.
* [66] M. Rosvall and C. T. Bergstrom. Multilevel Compression of Random Walks on Networks Reveals Hierarchical Organization in Large Integrated Systems. _PLoS One_, 6:e18209, 2011.
* [67] David F. Gleich. Pagerank beyond the web. _SIAM Review_, 57(3):321-363, 2015.

[MISSING_PAGE_FAIL:15]

to cluster m\({}_{2}\) whose usage rate is \(p_{\text{m}_{2}}\). Then, half of \(u\)'s flow, that is \(\frac{p_{u}}{2}\), falls into each of the two clusters and \(u\)'s contribution to the overall codelength is \(-\frac{p_{u}}{2}\log_{2}\frac{p_{u}}{2p_{\text{m}_{2}}}-\frac{p_{u}}{2}\log_{2} \frac{p_{u}}{p_{\text{m}_{2}}}\). In general, let node \(u\)'s assignment to cluster m\({}_{i}\) be \(s_{ui}\in[0,1]\) with \(\sum_{i}s_{ui}=1\), and let m\({}_{i}\)'s usage rate be \(p_{\text{m}_{i}}\). Then, node \(u\)'s contribution to the overall codelength is \(-\sum_{i}s_{ui}p_{u}\log_{2}\frac{s_{ui}p_{u}}{p_{\text{m}_{i}}}\). Essentially, this approach splits each node with assignments to more than one cluster into its corresponding parts, resulting in potentially many small pieces with low visit rates.

The second option is to treat the nodes as indivisible when computing their codeword lengths but reflecting their soft assignments in the contribution to the overall codelength. Using the same example as above, node \(u\)'s contribution to the overall codelength is \(-\frac{p_{u}}{2}\log_{2}\frac{p_{u}}{p_{\text{m}_{1}}}-\frac{p_{u}}{2}\log_{2 }\frac{p_{u}}{p_{\text{m}_{2}}}\), which is lower because the values inside the logarithms are bigger. In general, \(u\)'s contribution to the codelength is \(-\sum_{i}s_{ui}p_{u}\log_{2}\frac{p_{u}}{p_{\text{m}_{i}}}\), where the difference to the previous option is that \(s_{ui}\) does not appear inside the logarithm.

Figure 7: **Modelling node flow with soft cluster assignments.** The labels show each nodeâ€™s contribution to the overall codelength based on their visit rates. **(a)** The one-level partition where all nodes belong to the same community. **(b)** With hard communities, the middle node must be assigned to either the blue or orange community. Here, this leads to a higher codelength than for the one-level partition. **(c)** Reflecting nodesâ€™ partial assignments in the codelength contributions means splitting them into several smaller pieces whose visit rates sum to the original nodeâ€™s visit rate. Important objects are split into several less important objects, requiring longer codewords because of their lower visit rates. Overall, this tends to increase the codelength and can prevent identifying overlapping modules. **(d)** Treating nodesâ€™ contribution to the codelength as constant keeps the nodes intact and allows important nodes to retain their higher visit rates, leading to shorter codewords. As the codelength highlights, only this approach would identify communities in this example.

Results on synthetic networks with different (G)NN architectures

Here, we report further results on the synthetic LFR networks with planted communities for Neuromap, DMoN, NOCD, DiffPool, MinCut, and Ortho using the following architectures: a dense linear layer, a 2-layer MLP, a 2-layer GCN, and a 2-layer GIN. The setup is as described in the main text.

### Linear-layer-based results

Figure 8: Linear-layer-based results for deep-learning community-detection methods on synthetic LFR networks with planted communities. The results show averages of partition quality measured by AMI and number of detected communities \(|\text{M}|\). The shaded areas show one standard deviation from the mean.

Figure 9: MLP-based results for deep-learning community-detection methods on synthetic LFR networks with planted communities. The results show averages of partition quality measured by AMI and number of detected communities \(|\text{M}|\). The shaded areas show one standard deviation from the mean.

[MISSING_PAGE_EMPTY:18]

Results on Real-World Networks

Here, we report further results on real-world networks for setting the number of hidden dimensions to \(4\sqrt{n}\) and the maximum number of communities to \(s=\sqrt{n}\). Specifically, we visualise the average detected number of communities per loss function and neural network architecture for each dataset. We tabulate the average AMI and average number of detected communities, including standard deviations. Two-sample t-tests show when Neuromap or a baseline performs significantly better than the other.

### Number of detected communities on real-world networks

Figure 12: Average detected number of communities on real-world networks. Colours indicate methods while shapes indicate (G)NN architectures. The dashed horizontal lines show the correct number of communities for each dataset while the solid horizontal lines show the chosen maximum allowed number of communities, here \(s=\sqrt{n}\). DiffPool ran out of memory on the ogb-arxiv dataset. We omit Infomap in the plot due to the large number of detected communities.

[MISSING_PAGE_FAIL:20]

[MISSING_PAGE_FAIL:21]

Results on real-world networks with fixed number of hidden channels

We provide further results on real-world networks with a different configuration of the neural networks: we set the number of hidden channels to 512 and set the maximum number of communities to the "ground-truth" number of communities, that is \(s=|Y|\).

### Average Achieved AMI

### Average Number of Detected Communities

Figure 14: Average detected number of communities on real-world networks. Colours indicate methods while shapes indicate neural network architectures. The dashed horizontal lines show the correct number of communities for each dataset, which is also the maximum allowed number of communities. We omit Infomap in the plot due to the large number of detected communities.

Figure 13: Average achieved AMI on real-world networks (higher is better) for \(s=|Y|\), that is, the â€œground-truthâ€ number of communities. Colours indicate methods while shapes indicate neural network architectures. DiffPool ran out of memory on obg-arxiv.

### Tabulated AMI results on real-world networks

Here, we report the detailed AMI performance for Neuromap, DMoN, NOCD, DiffPool, MinCut, Ortho, and Infomap on real-world networks for setting the number of hidden dimensions to \(512\) and the maximum number of communities to \(s=|Y|\). When several of the best-performing methods achieve similar AMI, we use an independent two-sample t-test to determine whether one of them can be considered to perform better than the other. In cases where their performances do not differ significantly, we mark both as best.

### Significance of best Neuromap results vs. best baseline

\begin{table}
\begin{tabular}{l l l l l l l l l l l} \hline \hline Dataset & \multicolumn{2}{c}{Best Neuromap} & \multicolumn{2}{c}{Best Baseline} & \multicolumn{2}{c}{p} \\ \hline Cora & GIN & \(35.8\pm 4.1\) & DMoN GCN & \(37.2\pm 4.2\) & \(0.25\) \\ CiteSeer & GIN & \(16.1\pm 3.2\) & NOCD MLP & \(29.6\pm 10.8\) & \(2.4\mathrm{e}^{-06}\) \\ PubMed & MLP & \(22.9\pm 4.6\) & NOCD SAGE & \(22.6\pm 4.9\) & \(0.83\) \\ PC & GCN & \(49.9\pm 3.6\) & NOCD GCN & \(49.6\pm 2.2\) & \(0.73\) \\ Photo & GCN & \(61.4\pm 4.2\) & NOCD GCN & \(64.4\pm 4.1\) & \(0.02\) \\ CS & MLP & \(74.8\pm 2.4\) & NOCD MLP & \(74.0\pm 1.4\) & \(0.15\) \\ Physics & LIN & \(59.5\pm 8.2\) & NOCD MLP & \(56.8\pm 3.9\) & \(0.17\) \\ Cora ML & GCN & \(26.5\pm 2.8\) & NOCD MLP & \(39.3\pm 5.3\) & \(1.6\mathrm{e}^{-12}\) \\ Wiki CS & SAGE & \(41.0\pm 2.5\) & NOCD GCN & \(42.3\pm 2.2\) & \(0.05\) \\ ogb-arxiv & GCN & \(40.2\pm 1.6\) & NOCD GCN & \(43.6\pm 0.5\) & \(4.8\mathrm{e}^{-11}\) \\ \hline \hline \end{tabular}
\end{table}
Table 7: Independent two-sample t-test between 25 samples of AMI values for Neuromap vs. the best baseline for 512 hidden features and \(s=|Y|\). The p-values indicate for which datasets the null hypothesis â€œthe samples have the same meanâ€ can be rejected. Red p-values highlight cases where the best baseline performs significantly better than Neuromap.

\begin{table}
\begin{tabular}{l l l l l l l l l l l l} \hline \hline Method & Arch. & Cora & CutSeer & PubMed & PC & Photo & CS & Physics & Cora ML & Wai CS & ogb-arxiv \\ \hline Neuromap & LDN & \(19.9\pm 10.3\) & \(12.8\pm 6.9\) & \(0.9\pm 3.7\) & \(0.0\pm 0.0\) & \(0.0\pm 0.0\) & \(71.9\pm 3.7\) & \(50.8\pm 2.8\) & \(53.9\pm 1.1\) & \(17.1\pm 0.1\) & \(0.0\pm 0.0\) \\  & MLP & \(32.7\pm 4.6\) & \(13.6\pm 2.8\)

[MISSING_PAGE_FAIL:24]

[MISSING_PAGE_FAIL:25]

[MISSING_PAGE_FAIL:26]

### GIN-based results

### SAGE-based results

Figure 17: GIN-based results on a synthetic network with overlapping communities where the leftmost network shows the true community structure. Nodes are drawn as pie charts to visualise their community assignments. The top and bottom rows show results for a maximum of \(s=2\) and \(s=3\) communities, respectively.

Figure 18: SAGE-based results on a synthetic network with overlapping communities where the leftmost network shows the true community structure. Nodes are drawn as pie charts to visualise their community assignments. The top and bottom rows show results for a maximum of \(s=2\) and \(s=3\) communities, respectively.

### NeurIPS Paper Checklist

1. **Claims** Question: Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope? Answer: [Yes] Justification: Abstract and introduction introduce the research gap and summarise the developed method and experimentally achieved results on a high level.
2. **Limitations** Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] Justification: We discuss the limitation of our work in section 4.
3. **Theory Assumptions and Proofs** Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? Answer: [NA] Justification: We focus on adapting the well-established map equation framework for community detection with (graph) neural networks and show its utility empirically, however, our work does not include theoretical results or proofs.
4. **Experimental Result Reproducibility** Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? Answer: [Yes] Justification: Our main contribution is adapting the map equation as a differentiable loss function for optimisation with (graph) neural networks. We present the mathematical formulation of our adaptation in section 4. In section 5, we describe our experimental setup, including hyperparameter settings for our experiments.
5. **Open access to data and code** Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? Answer: [Yes] Justification: We made our code available through a public GitHub repository and the synthetic networks through a Zenodo repository. The used real-world networks are publicly available.
6. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: We detail our experimental settings, including hyperparameters, in section 5.
7. **Experiment Statistical Significance** Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? Answer: [Yes] Justification: We report the average achieved performance with standard deviations.
8. **Experiments Compute Resources**Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? Answer: [Yes] Justification: We describe the utilised computational hardware in section 5.
9. **Code Of Ethics** Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics [https://neurips.cc/public/EthicsGuidelines?](https://neurips.cc/public/EthicsGuidelines?) Answer: [Yes] Justification: We have reviewed the code of ethics and find that we conform with it.
10. **Broader Impacts** Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? Answer: [No] Justification: We consider the task of detecting communities in complex networks. While any algorithm can potentially be abused for malicious purposes, we believe that, in our case, this would be a rather contrived scenario.
11. **Safeguards** Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? Answer: [No] Justification: We find it not applicable to provide safeguards in the context of detecting communities in complex networks to understand their organisational structure.
12. **Licenses for existing assets** Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? Answer: [Yes] Justification: We cite the original works of the models we use as baselines as well as the sources of the datasets we use.
13. **New Assets** Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? Answer: [NA] Justification: We do not introduce new assets.
14. **Crowdsourcing and Research with Human Subjects** Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? Answer: [NA] Justification: Our work involves neither crowdsourcing nor research with human subjects.
15. **Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects** Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? Answer: [NA] Justification: Our work involves neither crowdsourcing nor research with human subjects.