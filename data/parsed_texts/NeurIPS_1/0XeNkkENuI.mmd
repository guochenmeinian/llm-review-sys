# The Road Less Scheduled

 Aaron Defazio\({}^{1}\)

Fundamental AI Research Team, Meta &Xingyu (Alice) Yang\({}^{2}\)

Fundamental AI Research Team, Meta &Harsh Mehta

Google Research &Konstantin Mishchenko

Samsung AI Center &Ahmed Khaled

Princeton University &Ashok Cutkosky\({}^{3}\)

Boston University

\({}^{1}\)Research Co-lead &Engineering Co-lead &Senior Author

###### Abstract

Existing learning rate schedules that do not require specification of the optimization stopping step \(T\) are greatly out-performed by learning rate schedules that depend on \(T\). We propose an approach that avoids the need for this stopping time by eschewing the use of schedules entirely, while exhibiting state-of-the-art performance compared to schedules across a wide family of problems ranging from convex problems to large-scale deep learning problems. Our _Schedule-Free_ approach introduces no additional hyper-parameters over standard optimizers with momentum. Our method is a direct consequence of a new theory we develop that unifies scheduling and iterate averaging. An open source implementation of our method is available1. Schedule-Free AdamW is the core algorithm behind our winning entry to the MLCommons 2024 AlgoPerf Algorithmic Efficiency Challenge Self-Tuning track.

Footnote 1: [https://github.com/facebookresearch/schedule_free](https://github.com/facebookresearch/schedule_free)

## 1 Introduction

The theory of optimization, as applied in machine learning, has been successful at providing precise, prescriptive results for many problems. However, even in the simplest setting of stochastic gradient descent (SGD) applied to convex Lipschitz functions, there are glaring gaps between what our current theory prescribes and the methods used in practice.

Consider the stochastic gradient descent (SGD) step with step size \(\gamma>0\), \(z_{t+1}=z_{t}-\gamma g_{t}\) where \(g_{t}\) is the stochastic (sub-)gradient at time \(t\), computed at the point \(z_{t}\) (formally defined in Section 1.1) of a convex Lipschitz function \(f\). Although standard practice for many classes of problems, classical convergence theory suggests that the expected loss of this \(z\) sequence is _suboptimal_, and that the Polyak-Ruppert (PR) average \(x\) of the sequence should be returned instead (Polyak, 1990; Ruppert, 1988):

\[z_{t+1} =z_{t}-\gamma g_{t} \tag{1}\] \[x_{t+1} =(1-c_{t+1})\,x_{t}+c_{t+1}z_{t+1}, \tag{2}\]

where using \(c_{t+1}=1/(t+1)\) results in \(x_{t}=\frac{1}{T}\sum_{t=1}^{T}z_{t}\). Despite their theoretical optimality, PR averages give much worse results in practice than using the last-iterate of SGD (Figures 1(a),8) -- a folk-law result in the field of optimization, and a large theory-practice gap that is often attributed to the mismatch between this simplified problem class and the complexity of problems addressed in practice.

Recently, Zamani and Glineur (2023) and Defazio et al. (2023) showed that the exact worst-case optimal rates can be achieved via carefully chosen learning rate sequences (also known as _schedules_) alone, without the use of averaging. This result suggests that schedules have, in some sense, the same role to play as PR averaging in optimization. However, schedules have a critical disadvantage: they require setting the optimization stopping time \(T\) in advance.

Motivated by the theory-practice gap for Polyak-Ruppert averaging, we ask the following question:

Do there exist iterate averaging approaches that match the empirical performance of learning rate schedules, without sacrificing theoretical guarantees?

By developing a new link between averaging and learning rate sequences, we introduce a new approach to averaging that maintains the worst-case convergence rate theory of PR averaging, while matching and often exceeding the performance of schedule-based approaches - firmly answering this question in the affirmative.

#### Summary of Results

* Our approach does not require the stopping time \(T\) to be known or set in advance. It closely tracks the Pareto frontier of loss versus training time during a single training run (Figure 1), while requiring _no additional hyper-parameters_ over the base SGD (with momentum) or Adam optimizer.
* Our approach uses an alternative form of momentum that replaces traditional momentum. This form has appealing theoretical properties: it is **worst case optimal for any choice of the momentum parameter in the convex Lipschitz setting**, a property that does not hold for traditional momentum.
* Our key theoretical result is a new _online-to-batch_ conversion theorem, which establishes the optimality of our method while also unifying several existing online-to-batch theorems.
* We perform, to our knowledge, **one of the largest machine learning optimization algorithm evaluations** to date, consisting of 28 problems, ranging from logistic regression to large-scale deep learning problems. This evaluation contains more distinct and diverse large-scale machine-learning problems than any other optimizer evaluation we are aware of in the literature. Schedule-Free methods show strong performance, matching or out-performing heavily-tuned cosine schedules.
* Schedule-Free AdamW won the MLCommons 2024 AlgoPerf Algorithmic Efficiency Challenge Self-Tuning (Adaptive Algorithm) Track, providing independent verification of its SOTA performance against other optimization algorithms in cases where hyperparameter-tuning is limited. We provide details of our entry and plots comparing it to the competition baseline.

### Notation

Consider the stochastic convex minimization \(\min_{x\in\mathbb{R}^{d}}f(x)=\mathbb{E}_{\zeta}[f(x,\zeta)]\), where each \(f(x,\zeta)\) is Lipschitz and convex in \(x\), and the expectation is taken over the random variable \(\zeta\). With a slight abuse of notation, we assume we are given, at time step \(t\) and any point \(y\) that we choose, an arbitrary sub-gradient \(\nabla f(y,\zeta_{t})\) from the sub-differential of \(f\).

Figure 1: Schedule-Free methods (black) closely track the Pareto frontier of loss v.s. training time in a single run. Both Schedule-Free SGD (left) and AdamW (right) match or exceed the performance of cosine learning rate schedules of varying lengths (red).

## 2 Method

We propose the following method, which we call Schedule-Free SGD:

\[y_{t} =(1-\beta)z_{t}+\beta x_{t}, \tag{3}\] \[z_{t+1} =z_{t}-\gamma\nabla f(y_{t},\zeta_{t}),\] (4) \[x_{t+1} =(1-c_{t+1})\,x_{t}+c_{t+1}z_{t+1}, \tag{5}\]

where \(c_{t+1}=1/(t+1)\) and \(z_{1}=x_{1}\) is the initial point. Note that, with this weighting, the \(x\) sequence is just a running average of the \(z\) sequence. The \(y\) sequence is the _gradient location_ sequence (on which gradients are evaluated at each step). The \(z\) sequence is the _base_ sequence, which is where the base optimizer's update is performed (in this case SGD). The \(x\) sequence is the _evaluation_ sequence, our best estimate of the weights so far.

This method has a momentum parameter \(\beta\) that interpolates between Polyak-Ruppert averaging (\(\beta=0\)) and Primal averaging (\(\beta=1\)). _Primal averaging_(Nesterov and Shikhman, 2015; Tao et al., 2018; Cutkosky, 2019; Kevis et al., 2019; Sebbouh et al., 2021; Defazio and Gower, 2021; Defazio and Jelassi, 2022), is an approach where the gradient is evaluated at the averaged point \(x\), instead of \(z\):

\[z_{t+1} =z_{t}-\gamma\nabla f(x_{t},\zeta_{t}) \tag{6}\] \[x_{t+1} =(1-c_{t+1})\,x_{t}+c_{t+1}z_{t+1}, \tag{7}\]

this approach maintains the worst-case optimality of PR averaging but is generally considered to converge too slowly to be practical (Figures 1(a),8). The advantage of our interpolation is that we get the best of both worlds. We can achieve the fast convergence of Polyak-Ruppert averaging (since the \(z\) sequence moves much quicker than the \(x\) sequence), while still keeping some coupling between the returned sequence \(x\) and the gradient-evaluation locations \(y\), which increases stability. Values of \(\beta\) similar to standard momentum values \(\beta\approx 0.9\) appear to work well in practice. We will use the notation \(\alpha=1-\beta\) when convenient.

In this formulation, \(\beta=0.9\) gives the practical advantages of momentum, dampening the immediate impact of large gradients, resulting in more stable training. To see this, notice that the immediate effect of the gradient \(g_{t}\) at step \(t\) is to introduce \((1-\beta)g_{t}=0.1g_{t}\) into the iterate sequence \(y\). This is similar to exponential-moving-average (EMA) momentum, where also \((1-\beta)g_{t}\) is added into the iterate sequence on step \(t\). However, here the remainder of \(g_{t}\) is very slowly added into \(y\) over time, via its place in the average \(x\), whereas with an EMA with \(\beta=0.9\), the majority of the gradient is incorporated within the next 10 steps. So from this viewpoint, the Schedule-Free updates can be seen as a version of momentum that has the same immediate effect, but with a greater delay for adding in the remainder of the gradient. This form of momentum (by interpolation) also has a striking advantage: it does not result in any theoretical slowdown; it gives the optimal worst case (Nesterov, 2013) convergence for the non-smooth convex setting (including constants), for any choice of momentum \(\beta\) between 0 and 1 inclusive:

**Theorem 1**.: _Suppose \(F\) is a convex function, and \(\zeta_{1},\ldots,\zeta_{T}\) is an i.i.d. sequence of random variables such that \(F=\mathbb{E}[f(x,\zeta)]\) for some function \(f\) that is \(G\)-Lipschitz in \(x\). For any minimizer \(x_{\star}\), define\(D=\|x_{1}-x_{\star}\|\) and \(\gamma=D/(G\sqrt{T})\). Then for any \(\beta\in[0,1]\), Schedule-Free SGD ensures:_

\[\mathbb{E}[F(x_{T})-F(x_{\star})]\leq\frac{DG}{\sqrt{T}} \tag{8}\]

In contrast, exponential-moving-average momentum in the non-smooth setting actually hurts the theoretical worst-case convergence rate. The Schedule-Free approach maintains the advantages of momentum (Sutskever et al., 2013) without the potential worst-case slow-down.

### General Theory

The method analyzed in Theorem 1 is actually a special-case of a more general result that incorporates arbitrary online optimization algorithms rather than only SGD, as well as arbitrary time-varying sequences of \(\beta_{t}\). The proof is provided in Appendix A.

**Theorem 2**.: _Let \(F\) be a convex function. Let \(\zeta_{1},\ldots,\zeta_{T}\) be an iid sequence such that \(F(x)=\mathbb{E}_{\zeta}[f(x,\zeta)]\). Let \(z_{1},\ldots,z_{T}\) be arbitrary vectors and let \(w_{1},\ldots,w_{T}\) and \(\beta_{1},\ldots,\beta_{T}\) be arbitrary numbers in \([0,1]\) such that \(z_{t}\), \(w_{t}\) and \(\beta_{t}\) are independent of \(\zeta_{t},\ldots,\zeta_{T}\). Set:_

\[x_{t} =\frac{\sum_{i=1}^{t}w_{i}z_{i}}{\sum_{i=1}^{t}w_{i}}=x_{t-1} \underbrace{\left(1-\frac{w_{t}}{\sum_{i=1}^{t}w_{i}}\right)}_{\triangleq 1 -c_{t}}+\underbrace{\frac{w_{t}}{\sum_{i=1}^{t}w_{i}}}_{\triangleq c_{t}}z_{t} \tag{9}\] \[y_{t} =\beta_{t}x_{t}+(1-\beta_{t})z_{t}\] (10) \[g_{t} =\nabla f(y_{t},\zeta_{t}). \tag{11}\]

_Then we have for all \(x_{\star}\):_

\[\mathbb{E}[F(x_{T})-F(x_{\star})]\leq\frac{\mathbb{E}[\sum_{t=1}^{T}w_{t} \langle g_{t},z_{t}-x_{\star}\rangle]}{\sum_{i=1}^{T}w_{i}}. \tag{12}\]

To recover Theorem 1 from the above result, notice that the algorithm analyzed by Theorem 1 is captured by Theorem 2 with \(w_{t}=1\), \(\beta_{t}\) a constant \(\beta\) and \(z_{t+1}=z_{t}-\gamma g_{t}\) for all \(t\). Next, observe that the sequence \(z_{1},\ldots,z_{T}\) is performing online gradient descent (Zinkevich, 2003), for which it is well-known that the _regret_\(\sum_{t=1}^{T}\langle g_{t},z_{t}-x_{\star}\rangle\) (appearing in the numerator of our result) is bounded by \(DG\sqrt{T}\) and so the result of Theorem 1 immediately follows.

The regret is the principle object of study in online convex optimization (Hazan, 2022; Orabona, 2019). Viewed in this light, Theorem 2 provides a way to convert an online convex optimization algorithm into a stochastic optimization algorithm: it is a form of _online-to-batch conversion_(Cesa-Bianchi et al., 2004). Classical online-to-batch conversions are a standard technique for obtaining convergence bounds for many stochastic optimization algorithms, including stochastic gradient descent (Zinkevich, 2003), AdaGrad (Duchi et al., 2011), AMSGrad (Reddi et al., 2018), and Adam (Kingma and Ba, 2014). All of these algorithms can be analyzed as online convex optimization algorithms: they provide bounds on the regret \(\sum_{t=1}^{T}\langle g_{t},z_{t}-x_{\star}\rangle\) rather than direct convergence guarantees. It is then necessary (although sometimes left unstated) to convert these regret bounds into stochastic convergence guarantees via an online-to-batch conversion. Our result provides a more versatile method for effecting this conversion.

Theorem 2 actually provides a "grand unification" of a number of different online-to-batch conversions that have been proposed over the years. Most of these conversion methods were first developed specifically to provide convergence analysis for SGD (or some variant such as dual averaging or mirror descent), and then generalized into techniques that apply to any online convex optimization algorithm. For example, the classical Polyak averaging method can be generalized to form the "standard" online-to-batch conversion of Cesa-Bianchi et al. (2004), and is immediately recovered from Theorem 2 by setting \(w_{t}=1\) and \(\beta_{t}=0\) for all \(t\). More recently Nesterov and Shikhman (2015); Tao et al. (2018) derived an alternative to Polyak averaging that was later generalized to work with arbitrarily online convex optimization algorithms by Cutkosky (2019); Kavis et al. (2019), and then observed to actually be equivalent to the heavy-ball momentum by Defazio (2020); Defazio and Gower (2021); Defazio and Jelassi (2022). This method is recovered by our Theorem 2 by setting \(w_{t}=1\) and \(\beta_{t}=1\) for all \(t\). Finally, very recently Zamani and Glineur (2023) discovered that gradient descent with a _linear decay_ stepsize provides a last-iterate convergence guarantee, which was again generalized to an online-to-batch conversion by Defazio et al. (2023). This final result is _also_ recovered by Theorem 2 by setting \(w_{t}=1\) and \(\beta_{t}=\frac{t}{T}\) (see Appendix B).

In Appendix C, we give a further tightening of Theorem 2 - it can be improved to an equality by precisely tracking additional terms that appear on the right-hand-side. This tightened version can be used to show convergence rate results for smooth losses, both with and without strong-convexity. As an example application, we show that schedule-free optimistic-gradient methods (Rakhlin and Sridharan, 2013) converge with accelerated rates:

\[\mathbb{E}[F(x_{T})-F(x_{\star})]=O\left(\frac{D^{2}L}{T^{2}}+ \frac{D\sigma}{\sqrt{T}}\right). \tag{13}\]

### On Large Learning Rates

Under classical worst-case convergence theory, the optimal choice of \(\gamma\) for a fixed duration training time \(T\) is \(\gamma=D/(G\sqrt{T})\). This is the rate used in our bounds for Theorem 1 above. For _any-time_ convergence (i.e. when stopping is allowed at any timestep), our proposed method can, in theory, be used with the standard learning rate sequence:

\[\gamma_{t}=\frac{D}{G\sqrt{t}}. \tag{14}\]

However, learning rate sequences of this form have poor practical performance (Defazio et al., 2023). Instead, much larger steps of the form \(D/G\) give far better performance across virtually all problems in applications (Defazio and Mishchenko, 2023) -- another theory-practice mismatch that is virtually undiscussed in the literature. Existing theory suggests that this step-size is too large to give \(\mathcal{O}(1/\sqrt{T})\) convergence, however, as we show below, there is an important special case where such large step sizes also give optimal rates up to constant factors.

**Theorem 3**.: _Consider the online learning setting with bounded gradients \(g_{t}\). Let \(z_{t+1}=z_{t}-\gamma g_{t}\). Let \(D=\|z_{1}-z_{\star}\|\) for arbitrary reference point \(z_{\star}\) and define \(G=\max_{t\leq T}\|g_{t}\|\). Suppose that the chosen step-size is \(\gamma=D/G\), then if it holds that:_

\[\sum_{t=1}^{T}\left\langle g_{t},z_{t}-z_{1}\right\rangle\leq D\sqrt {\sum_{t=1}^{T}\|g_{t}\|^{2}}, \tag{15}\]

_then:_

\[\frac{1}{T}\sum_{t=1}^{T}\left\langle g_{t},z_{t}-z_{\star}\right\rangle= \mathcal{O}\left(\frac{D}{T}\sqrt{\sum_{t=1}^{T}\|g_{t}\|^{2}}\right). \tag{16}\]

This regret bound for SGD implies a convergence rate bound for Schedule-Free SGD by application of our online-to-batch conversion. Condition 31 can be checked during a training run (Using reference point \(z_{\star}=x_{T}\), and so \(D=\|x_{1}-x_{T}\|\)), and we find that it holds for _every_ problem we consider in our experiments in Section 4. More generally, the full conditions under which large learning rates can be used are not yet fully understood for stochastic problems. In the quadratic case, Bach and Moulines (2013) established that large fixed step-sizes give optimal convergence rates, and we conjecture that the success of large learning rates may be attributed to asymptotic quadratic behavior of the learning process.

Empirically, we find that Schedule-Free momentum enables the use of larger learning rates \(\gamma>0\) even in quadratic minimization problems \(f(x)=\frac{1}{2}x^{\top}Ax-b^{\top}x\). We generate \(10\) different such \(20\)-dimensional problems with eigenvalues drawn log-uniformly in \([10^{-6},1]\). We plot the average minimal loss achieved as a function of the two parameters \(\beta\) and \(\gamma\) in Figure 1(b). We can see that when the learning rate we use is small, what value of \(\beta\) we choose has little to no effect on the convergence of the algorithm. However, when \(\gamma\) is large, choosing \(\beta<1\) becomes crucial to achieving convergence.

Related Work

The proposed method has a striking resemblance to Nesterov's accelerated method (Nesterov, 1983, 2013) for \(L\)-smooth functions, which can be written in the AC-SA form (Lan, 2012):

\[y_{t} =(1-c_{t+1})x_{t}+c_{t+1}z_{t} \tag{17}\] \[z_{t+1} =z_{t}-\frac{k+1}{2L}\nabla f(y_{t})\] (18) \[x_{t+1} =(1-c_{t+1})\,x_{t}+c_{t+1}z_{t+1}, \tag{19}\]

where \(c_{t+1}=2/(t+2)\). The averaging constant, and more generally

\[c_{t+1}=\frac{r+1}{t+r+1}, \tag{20}\]

for any real \(r>-1\) is equivalent to the weighted average (Shamir and Zhang, 2013; Defazio and Gower, 2021)\(x_{t}\propto\sum_{t=1}^{T}t^{\bar{r}}z_{t}\), where \(t^{\bar{r}}\) represents the \(r\)th factorial power of \(t\). Our framework is compatible with factorial power averages without sacrificing theoretical guarantees.

Our approach differs from conventional accelerated methods by using a different weight for the \(y_{t}\) and \(x_{t}\) interpolations. We use a constant weight for \(y_{t}\) and a decreasing weight for \(x_{t}\). Accelerated methods for strongly-convex problems use a constant weight for both, and those for non-strongly convex use an decreasing weight for both, so our approach doesn't directly correspond to either class of accelerated method. Accelerated methods also use a much larger step size for the \(z_{t}\) sequence than our approach.

The use of equal-weighted averages is less common than the use of exponential weighting in the practical deep learning optimization literature. Exponential moving averages (EMA) of the iterate sequence are used in the popular Lookahead optimizer (Zhang et al., 2019). In the case of SGD, it performs \(i=1\ldots k\) inner steps:

\[z_{t,i}=z_{t,i-1}-\gamma\nabla f(z_{t,i-1}) \tag{21}\]

followed by an outer step:

\[x_{t}=x_{t-1}+\alpha\left(z_{t,k}-x_{t-1}\right). \tag{22}\]

The inner optimizer then starts at \(z_{t+1,0}=x_{t-1}\). The Lookahead method can be seen as the EMA version of primal averaging, just as exponential weight averaging is the EMA version of Polyak-Ruppert averaging.

Tail averaging, either using an exponential moving average or an equal-weighted average, is a common 'folk-law' technique that often yields a practical improvement. For instance, this kind of averaging is used without citation by the influential work of Szegedy et al. (2016): "Model evaluations are performed using a running average of the parameters computed over time.", and by Vaswani et al. (2017): "...averaged the last 20 checkpoints". Tail averages are typically "Polyak-Ruppert" style averaging as the average is not used for gradient evaluations during training.

More sophisticated tail averaging approaches such as Stochastic Weight Averaging (Izmailov et al., 2018) and LAtest Weight Averaging (Kaddour, 2022; Sanyal et al., 2023) combine averaging with large or cyclic learning rates. They are not a replacement for scheduling, instead they aim to improve final test metrics. They generally introduce additional hyper-parameters to tune, and require additional memory. It is possible to use SWA and LAWA on top of our approach, potentially giving further gains.

Sandler et al. (2023) show via a stochastic quadratic analysis framework that averaging and learning rate decreases achieve the same effective learning rate. For instance, and average of two points along the training trajectory can give almost identical results to using a learning rate two times smaller. Stochastic quadratic problems are particularly special, Bach and Moulines (2013) have shown that Polyak averaging gives optimal \(\mathcal{O}(1/T)\) rates _without_ the use of decreasing time-dependent step size sequences in this setting.

Within optimization theory, tail averages can be used to improve the convergence rate for stochastic non-smooth SGD in the strongly convex setting from \(\mathcal{O}(\log(T)/T)\) to \(\mathcal{O}(1/T)\)(Rakhlin et al., 2012),although at the expense of worse constants compared to using weighted averages of the whole sequence Lacoste-Julien et al. (2012).

Portes et al. (2022) use cyclic learning rate schedules with increasing cycle periods to give a method that explores multiple points along the Pareto frontier of training time vs eval performance. Each point at the end of a cycle is an approximation to the model from a tuned schedule ending at that time. Our method gives the entire frontier, rather than just a few points along the path. In addition, our method matches or improves upon best known schedules, whereas the "... cyclic trade-off curve underestimated the standard trade-off curve by a margin of 0.5% validation accuracy" (Portes et al., 2022).

## 4 Experiments

For our deep learning experiments, we evaluated Schedule-Free learning on a set benchmark tasks that are commonly used in the optimization research literature:

**CIFAR10**: A Wide ResNet (16-8) architecture (Zagoruyko and Komodakis, 2016) on the CIFAR10 image classification dataset.
**CIFAR100**: A DenseNet (Huang et al., 2017) architecture on the CIFAR-100 (100-class) classification dataset.
**SVHN**: A deep ResNet architecture (3-96) on the Street View House Numbers (SVHN) dataset.
**ImageNet**: A standard ResNet-50 architecture (He et al., 2016) on the ILSVRC 2012 ImageNet (Russakovsky et al., 2015) classification dataset.
**IWSLT14**: A LSTM architecture (Wiseman and Rush, 2016) on the IWSLT14 German-English translation dataset (Cettolo et al., 2014).
**DLRM**: The DLRM (Naumov et al., 2019) architecture on the Criteo Kaggle Display Advertising dataset (Jean-Baptiste Tien, 2014).
**MRI**: A stacked U-Net architecture (Sriram et al., 2020) on the fastMRI dataset (Zbontar et al., 2018).
**MAE**: Fine-tuning a pretrained Masked Autoencoder (He et al., 2021) ViT (patch16-512d-8b) on the ILSVRC 2012 ImageNet dataset.
**NanoGPT**: A 124M parameter GPT-2 (Radford et al., 2019) style decoder-only transformer on the OpenWebText dataset (Gokaslan and Cohen, 2019).

For each problem, both the baseline and the Schedule-Free method were tuned by sweeping both the weight decay and learning rate on a grid. We also swept \(\beta\) over two values, \(0.9\) and \(0.98\). Final hyper-parameters are listed in the Appendix. Schedule-Free SGD was used for CIFAR10, CIFAR100, SVHN and ImageNet, and Schedule-Free AdamW (Loshchilov and Hutter, 2019) was used for the remaining tasks. We further include a step-wise schedule as a comparison on problems where step-wise schedules are customary. Further results for Polyak and Primal averaging are in Appendix I.

Our approach shows very strong performance (Figure 3) out-performing existing state-of-the-art cosine schedules on CIFAR-10, CIFAR-100, SVHN, IWSLT-14 (Figure 2a) and OpenWebText GPT-2 problems, as well as the state-of-the-art Linear Decay schedules on the fastMRI and Criteo DLRM tasks. On the remaining two problems, MAE fine-tuning and ImageNet ResNet-50 training, it ties with the existing best schedules.

In general, the optimal learning rates for the Schedule-Free variants were larger than the optimal values for the base optimizers. The ability to use larger learning rates without diverging may be a contributing factor to the faster convergence of Schedule-Free methods. The \(\beta\) parameter works well at the default value of \(0.9\) for all problems except NanoGPT, where the loss started to increase rapidly when \(0.9\) was used (similar to the Polyak Averaging results in Appendix I). The larger \(\beta=0.98\) value in our sweep was stable.

### MLCommons Algorithmic Efficiency benchmark

The AlgoPerf challenge (Dahl et al., 2023) is designed to be a large-scale and comprehensive benchmark for deep learning optimization algorithms, covering major data domains and architectures. It includes Transformers, ConvNets and U-Net models across image, language, graph and speech domains, and contains 8 problems total. We evaluated Schedule-Free AdamW following the competition guidelines, comparing against NAdamW, the competition reference Algorithm, running 10 seeds of each. As this is a time-to-target competition, traditional error bars are not appropriate so we instead plot all 10 seeds separately. Note that we excluded one benchmark problem, ResNet-50 training, as neither AdamW nor NAdamW can hit the target accuracy on that task.

The self-tuning track restricts participants to provide a single set of hyper-parameters to use for all 8 problems. Given the large number of problems, this gives performance representative of a good default configuration.

Schedule-Free AdamW performs well across all considered tasks, out-performing the baseline on the WMT, VIT, FASTMRI and OGBG training, while tying on the Conformer and Criteo workloads, and marginally under-performing on the DeepSpeech workload. We attribute the performance on the Conformer and DeepSpeech tasks to their use of batch-norm - the AlgoPerf setup doesn't easily allow us to update the BN running statistics on the \(x\) sequence, which is necessary with our method to get the best performance (See Section 4.3).

### Convex Problems

We validated the Schedule-Free learning approach on a set of standard logistic regression problems from the LibSVM repository. For each problem, and each method separately, we performed a full learning rate sweep on a power-of-two grid, and plotted mean and standard-error of the final train accuracy from 10 seeds using the best learning rate found.

Schedule-Free learning out-performs both averaging approaches and the state-of-the-art linear decay (LD) schedule baseline (Figure 7). It converges faster on all but 1 of 12 problems, has higher accuracy on 6 of the problems, and ties the baseline on the remaining problems. This demonstrates that the performance advantages of Schedule-Free methods are not limited to non-convex problems.

### Implementation Concerns

The Schedule-Free variant of a method typically has the same memory requirements as the base method. For instance, Schedule-Free SGD requires no extra memory over standard SGD with momentum. Whereas SGDM tracks the current point \(x\) and the momentum buffer \(m\), we can track \(x\) and \(z\). The quantity \(y\) can be computed directly from the latest values of \(x\) and \(z\), and so doesn't need

Figure 3: Deep Learning Experiments

to be explicitly stored. It's also possible to instead store \(z\) and \(y\), and then compute \(x\) when needed. This low memory usage is the case for AdamW also, see Algorithm 1.

```
1:Input:\(x_{1},\)learning rate \(\gamma,\)decay \(\lambda,\) warmup steps \(T_{\text{warmup}},\beta_{1},\beta_{2},\epsilon\)
2:\(z_{1}=x_{1}\)
3:\(v_{0}=0\)
4:for\(t=1\)to T do
5:\(y_{t}=(1-\beta_{1})z_{t}+\beta_{1}x_{t}\)\(\triangleright\) Momentum via interpolation
6:\(g_{t}\in\partial f(y_{t},\zeta_{t})\)\(\triangleright\) Gradient is evaluated at \(y\)
7:\(v_{t}=\beta_{2}v_{t-1}+(1-\beta_{2})g_{t}^{2}\)
8:\(\gamma_{t}=\gamma\sqrt{1-\beta_{2}^{t}}\min(1,t/T_{\text{warmup}})\)\(\triangleright\) LR includes warmup and Adam bias-correction
9:\(z_{t+1}=z_{t}-\gamma_{t}g_{t}/(\sqrt{v_{t}}+\epsilon)-\gamma_{t}\lambda y_{t}\)
10:\(c_{t+1}=\frac{\gamma_{t}^{2}}{\sum_{t=1}^{t}\gamma_{t}^{2}}\)
11:\(x_{t+1}=(1-c_{t+1})\,x_{t}+c_{t+1}z_{t+1}\)\(\triangleright\) Update weighted iterate average
12:endfor
13:Return \(x_{T}\)\(\underline{\text{xx}}\)
```

**Algorithm 1** Schedule-Free AdamW

Our efficient PyTorch implementation actually uses one buffer to always store \(z\) and the primary parameter buffer to store either \(x\) or \(y\), with the stored quantity flipping between the two for training and test/inference passes.

Our method requires extra code to handle models where batch norm is used. This is due to the fact that BatchNorm layers maintain a running_mean and running_var to track batch statistics which is calculated at \(y\). For model evaluation, these buffers need to be updated to match the statistics on the \(x\) sequence. This can be done by evaluating a small number of training batches using \(x\) right before each eval. More sophisticated approaches such as PreciseBN (Wu and Johnson, 2021) can also be used. This calculation is not needed for other normalization layers that do not use batch-statistics.

Learning rate warmup is still necessary for our method. We use a linear warmup for a fixed duration, and fuse the Adam bias-correction term into the learning rate for simplicity (this potentially impacts the effect of weight-decay during early iterations), giving a learning rate LR \(\gamma_{t}=\gamma\sqrt{1-\beta_{2}^{t}}\min(1,t/T_{\text{warmup}})\) that approaches \(\gamma\) when the warmup and bias-correction period ends. We found that performance was greatly improved by using a weighted \(c_{t}\) sequence when

Figure 4: Schedule-Free Adam compared to target-setting baseline on the Algoperf competition self-tuning track.

warmup is used, weighted by the square of the \(\gamma_{t}\) used during warmup:

\[c_{t+1}=\frac{\gamma_{t}^{2}}{\sum_{i=1}^{t}\gamma_{t}^{2}}. \tag{23}\]

This sequence decreases at a \(1/t\) rate after the learning rate warmup. It is shifted by one from the indexing used in Theorem 2, which is done to simplify the implementation. This sequence is motivated by Theorem 2's weighting sequences, which suggest weights proportional to polynomials of the learning rate. This sequence was used for both SGD and AdamW experiments.

Weight decay for Schedule-Free methods can be computed at either the \(y\) or \(z\) sequences. We used decay at \(y\) for our experiments, as this matches the interpretation of weight-decay as the use of an additional L2-regularizer term in the loss. We found that computing the regularization at \(y\) gives significantly better performance on some problems including ImageNet and NanoGPT training.

## 5 Parameter Sensitivity

For Schedule-Free learning to be truly _schedule-free_, it's important that the momentum hyperparameter doesn't implicitly have a dependence on the time-horizon. If tuning this parameter gave different values depending on the training duration, then the problem of setting the horizon has just been shifted to setting the momentum value. In Figure 5 we run ImageNet training with Schedule-Free SGD for a longer-then-standard 200 epochs with a variety of momentum values, with the LR fixed to 1.5. We find that the best choice of momentum (\(\beta=0.9\)) is the same for all durations of training.

Schedule-Free learning has a similar mild time-horizon dependency for the baseline learning rate value as schedule-based approaches. Figure 6 shows that the optimal learning rate stays the same for broad range of values, for both Schedule-Free and Schedule based training. For short duration training (\(\leq 25\) epochs), larger LR values begin to show the best performance. Appendix J shows the sensitivity of the final test accuracy to the baseline learning rate for a selection of our test problems, in comparison to the baseline optimizer with a cosine schedule. We see that the overall sensitivity is similar to the baseline optimizer in each problem.

## 6 Conclusion

Two roads diverged in a wood, and I--

I took the one less traveled by,

And that has made all the difference. - Robert Frost

We have presented Schedule-Free learning, an optimization approach that removes the need to specify a learning rate schedule while matching or outperforming schedule-based learning. The primary practical limitation is the need to sweep learning rate and weight decay, as the best values differ from the those used with a schedule. We provide a preliminary theoretical exploration of the method, establishing its worst-case optimal performance for non-smooth Lipschitz convex optimization.

Figure 5: Sensitivity to momentum values

Figure 6: Comparison of the LR sensitivity of Schedule-Free training and cosine schedule training

## Funding Acknowledgments

AC is supported by NSF grant number CCF-2211718.

## References

* S. Bach and E. Moulines (2013)Non-strongly-convex smooth stochastic approximation with convergence rate \(O(1/n)\). In Burges, C., Bottou, L., Welling, M., Ghahramani, Z., and Weinberger, K., editors, Advances in Neural Information Processing Systems, Vol. 26, Curran Associates, Inc.
* Cesa-Bianchi et al. (2004) Cesa-Bianchi, N., Conconi, A., and Gentile, C. (2004). On the generalization ability of on-line learning algorithms. IEEE Transactions on Information Theory50 (9), pp. 2050-2057.
* Cettolo et al. (2014) Cettolo, M., Niehues, J., Stuker, S., Bentivogli, L., and Federico, M. (2014). Report on the 11th IWSLT evaluation campaign. In IWSLT, Cited by: SS1.
* C. Chiang, T. Yang, C. Lee, M. Mahdavi, C. Lu, R. Jin, and S. Zhu (2012)Online optimization with gradual variations. In Conference on Learning Theory, pp. 6-1. JMLR Workshop and Conference Proceedings.
* Cutkosky (2019)Anytime online-to-batch, optimism and acceleration. In International conference on machine learning, pp. 1446-1454. PMLR.
* Dahl et al. (2023) Dahl, G. E., F., Nado, Z., Agarwal, N., Sastry, C. S., Hennig, P., Medapati, S., Eschenhagen, R., Kasimbeg, P., Suo, D., Bae, J., Gilmer, A. L., Khan, B., Anil, R., Rabbat, M., Krishnan, S., Snider, D., Amid, E., Chen, K., Maddison, C. J., Vasudev, R., Badura, M., Garg, A., and Mattson, P. (2023)Benchmarking neural network training algorithms. Cited by: SS1.
* A. Defazio (2020)Momentum via primal averaging: theoretical insights and learning rate schedules for non-convex optimization. Cited by: SS1.
* A. Defazio, A. Cutkosky, H. Mehta, and K. Mishchenko (2023)When, why and how much? adaptive learning rate scheduling by refinement. Cited by: SS1.
* A. Defazio and R. M. Gower (2021)The power of factorial powers: new parameter settings for (stochastic) optimization. In Proceedings of The 13th Asian Conference on Machine Learning, Proceedings of Machine Learning Research, pp. 49-64. PMLR.
* Defazio and S. Jelassi (2022)Adaptivity without compromise: a momentumized, adaptive, dual averaged gradient method for stochastic optimization. Journal of Machine Learning Research23, pp. 1-34.
* A. Defazio and K. Mishchenko (2023)Learning-rate-free learning by D-adaptation. The 40th International Conference on Machine Learning (ICML 2023). Cited by: SS1.
* J. Duchi, E. Hazan, and Y. Singer (2011)Adaptive subgradient methods for online learning and stochastic optimization. Journal of Machine Learning Research12 (61). Cited by: SS1.
* A. Gokaslan and V. Cohen (2019)OpenWebtext corpus. Note: [http://Skylion007.github.io/OpenWebTextCorpus](http://Skylion007.github.io/OpenWebTextCorpus) Cited by: SS1.
* E. Hazan (2022)Introduction to online convex optimization. Note: MIT Press Cited by: SS1.
* E. Hazan and S. Kale (2010)Extracting certainty from uncertainty: regret bounded by variation in costs. Machine learning80, pp. 165-188. Cited by: SS1.
* K. He, X. Chen, S. Xie, Y. Li, P. Dollar, and R. Girshick (2021)Masked autoencoders are scalable vision learners. arXiv:2111.06377. Cited by: SS1.
* K. He, X. Zhang, S. Ren, and J. Sun (2016)Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition, Cited by: SS1.

Huang, G., Liu, Z., Van Der Maaten, L., and Weinberger, K. Q. (2017). Densely connected convolutional networks. In _2017 IEEE Conference on Computer Vision and Pattern Recognition (CVPR)_, pages 2261-2269.
* Izmailov et al. (2018) Izmailov, P., Podoprikhin, D., Garipov, T., Vetrov, D., and Wilson, A. G. (2018). Averaging weights leads to wider optima and better generalization. In _Conference on Uncertainty in Artificial Intelligence (UAI)_.
* Jean-Baptiste Tien (2014) Jean-Baptiste Tien, joycenv, O. C. (2014). Display advertising challenge.
* Joulani et al. (2017) Joulani, P., Gyorgy, A., and Szepesvari, C. (2017). A modular analysis of adaptive (non-) convex optimization: Optimism, composite objectives, and variational bounds. In _International Conference on Algorithmic Learning Theory_, pages 681-720. PMLR.
* Joulani et al. (2020) Joulani, P., Raj, A., Gyorgy, A., and Szepesvari, C. (2020). A simpler approach to accelerated optimization: iterative averaging meets optimism. In _International conference on machine learning_, pages 4984-4993. PMLR.
* Kaddour (2022) Kaddour, J. (2022). Stop wasting my time! saving days of ImageNet and BERT training with latest weight averaging.
* Kavis et al. (2019) Kavis, A., Levy, K. Y., Bach, F., and Cevher, V. (2019). UniXGrad: A universal, adaptive algorithm with optimal guarantees for constrained optimization. _Advances in neural information processing systems_, 32.
* Kingma and Ba (2014) Kingma, D. P. and Ba, J. (2014). Adam: a method for stochastic optimization. In _International Conference on Learning Representations_.
* Lacoste-Julien et al. (2012) Lacoste-Julien, S., Schmidt, M., and Bach, F. (2012). A simpler approach to obtaining an \(o(1/t)\) convergence rate for the projected stochastic subgradient method.
* Lan (2012) Lan, G. (2012). An optimal method for stochastic composite optimization. _Mathematical Programming_, 133(1):365-397.
* Loshchilov and Hutter (2019) Loshchilov, I. and Hutter, F. (2019). Decoupled weight decay regularization. In _International Conference on Learning Representations_.
* Naumov et al. (2019) Naumov, M., Mudigere, D., Shi, H. M., Huang, J., Sundaraman, N., Park, J., Wang, X., Gupta, U., Wu, C., Azzolini, A. G., Dzhulgakov, D., Mallevich, A., Cherniavskii, I., Lu, Y., Krishnamoorthi, R., Yu, A., Kondratenko, V., Pereira, S., Chen, X., Chen, W., Rao, V., Jia, B., Xiong, L., and Smelyanskiy, M. (2019). Deep learning recommendation model for personalization and recommendation systems. _CoRR_.
* Nesterov (1983) Nesterov, Y. (1983). A method for solving a convex programming problem with convergence rate \(O(1/k^{2})\). _Soviet Mathematics Doklady_.
* Nesterov (2013) Nesterov, Y. (2013). _Lectures on Convex Optimization_. Springer Nature.
* Nesterov and Shikhman (2015) Nesterov, Y. and Shikhman, V. (2015). Quasi-monotone subgradient methods for nonsmooth convex minimization. _Journal of Optimization Theory and Applications_, 165(3):917-940.
* Orabona (2019) Orabona, F. (2019). A modern introduction to online learning. _arXiv preprint arXiv:1912.13213_.
* Polyak (1990) Polyak, B. (1990). New stochastic approximation type procedures. _Avtomatica i Telemekhanika_, 7:98-107.
* Portes et al. (2022) Portes, J., Blalock, D., Stephenson, C., and Frankle, J. (2022). Fast benchmarking of accuracy vs. training time with cyclic learning rates.
* Radford et al. (2019) Radford, A., Wu, J., Child, R., Luan, D., Amodei, D., and Sutskever, I. (2019). Language models are unsupervised multitask learners. Technical report, OpenAI.
* Rakhlin et al. (2012) Rakhlin, A., Shamir, O., and Sridharan, K. (2012). Making gradient descent optimal for strongly convex stochastic optimization. In _Proceedings of the 29th International Coference on International Conference on Machine Learning_.
* Rakhlin et al. (2013)Rakhlin, A. and Sridharan, K. (2013). Online learning with predictable sequences. In _Conference on Learning Theory_, pages 993-1019. PMLR.
* Reddi et al. (2018) Reddi, S. J., Kale, S., and Kumar, S. (2018). On the convergence of Adam and beyond. In _International Conference on Learning Representations_.
* Ruppert (1988) Ruppert, D. (1988). Efficient estimations from a slowly convergent Robbins-Monro process. _Technical Report, Cornell University_.
* Russakovsky et al. (2015) Russakovsky, O., Deng, J., Su, H., Krause, J., Satheesh, S., Ma, S., Huang, Z., Karpathy, A., Khosla, A., Bernstein, M., Berg, A. C., and Fei-Fei, L. (2015). ImageNet Large Scale Visual Recognition Challenge. _International Journal of Computer Vision (IJCV)_, 115(3).
* Sandler et al. (2023) Sandler, M., Zhmoginov, A., Vladymyrov, M., and Miller, N. (2023). Training trajectories, mini-batch losses and the curious role of the learning rate.
* Sanyal et al. (2023) Sanyal, S., Neerkaje, A., Kaddour, J., Kumar, A., and Sanghavi, S. (2023). Early weight averaging meets high learning rates for LLM pre-training.
* Sebbouh et al. (2021) Sebbouh, O., Gower, R. M., and Defazio, A. (2021). On the (asymptotic) convergence of stochastic gradient descent and stochastic heavy ball. In _Conference on Learning Theory, COLT 2021_, Proceedings of Machine Learning Research. PMLR.
* Shamir and Zhang (2013) Shamir, O. and Zhang, T. (2013). Stochastic gradient descent for non-smooth optimization: Convergence results and optimal averaging schemes. In _Proceedings of the 30th International Conference on Machine Learning_.
* Sriram et al. (2020) Sriram, A., Zbontar, J., Murrell, T., Defazio, A., Zitnick, C. L., Yakubova, N., Knoll, F., and Johnson, P. (2020). End-to-end variational networks for accelerated MRI reconstruction. In _International Conference on Medical Image Computing and Computer-Assisted Intervention_. Springer.
* Volume 28_. JMLR.org.
* Szegedy et al. (2016) Szegedy, C., Vanhoucke, V., Ioffe, S., Shlens, J., and Wojna, Z. (2016). Rethinking the inception architecture for computer vision. In _2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR)_, pages 2818-2826.
* Tao et al. (2018) Tao, W., Pan, Z., Wu, G., and Tao, Q. (2018). Primal averaging: A new gradient evaluation step to attain the optimal individual convergence. _IEEE Transactions on Cybernetics_, PP:1-11.
* Vaswani et al. (2017) Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., Kaiser, L. u., and Polosukhin, I. (2017). Attention is all you need. In Guyon, I., Luxburg, U. V., Bengio, S., Wallach, H., Fergus, R., Vishwanathan, S., and Garnett, R., editors, _Advances in Neural Information Processing Systems_, volume 30. Curran Associates, Inc.
* Wiseman and Rush (2016) Wiseman, S. and Rush, A. M. (2016). Sequence-to-sequence learning as beam-search optimization. In _Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing_. Association for Computational Linguistics.
* Wu and Johnson (2021) Wu, Y. and Johnson, J. (2021). Rethinking "batch" in batchnorm.
* Zagoruyko and Komodakis (2016) Zagoruyko, S. and Komodakis, N. (2016). Wide residual networks. In _Proceedings of the British Machine Vision Conference (BMVC)_.
* Zamani and Glineur (2023) Zamani, M. and Glineur, F. (2023). Exact convergence rate of the last iterate in subgradient methods.
* Zbontar et al. (2018) Zbontar, J., Knoll, F., Sriram, A., Muckley, M. J., Bruno, M., Defazio, A., Parente, M., Geras, K. J., Katsnelson, J., Chandarana, H., et al. (2018). fastMRI: An open dataset and benchmarks for accelerated MRI. _arXiv preprint arXiv:1811.08839_.
* Zhang et al. (2019) Zhang, M., Lucas, J., Ba, J., and Hinton, G. E. (2019). Lookahead optimizer: \(k\) steps forward, 1 step back. In Wallach, H., Larochelle, H., Beygelzimer, A., dAlche-Buc, F., Fox, E., and Garnett, R., editors, _Advances in Neural Information Processing Systems_, volume 32. Curran Associates, Inc.

Zinkevich, M. (2003). Online convex programming and generalized infinitesimal gradient ascent. In _Proceedings of the Twentieth International Conference on International Conference on Machine Learning_, pages 928-935.

## Contributions

Aaron Defazio discovered the method, led research experimentation and proved initial versions of Theorems 1 and 7, with experimental/theoretical contributions by Alice Yang. Alice Yang led the development of the research codebase. Ashok Cutkosky proved key results including Theorem 2 and led the theoretical investigation of the method. Ahmed Khaled developed preliminary theory for obtaining accelerated rates which was later supplanted by Theorem 2, and investigated the utility of \(\beta\) with large learning rates for quadratics. Additional derivations by Konstantin Mishchenko and Harsh Mehta are included in appendix sections. Discussions between Aaron Defazio, Ashok Cutkosky, Konstantin Mishchenko, Harsh Mehta, and Ahmed Khaled over the last year contributed to this scientific discovery.

## Appendix A Proof of Theorem 2

**Theorem 2**.: _Let \(F\) be a convex function. Let \(\zeta_{1},\ldots,\zeta_{T}\) be an iid sequence such that \(F(x)=\mathbb{E}_{\zeta}[f(x,\zeta)]\). Let \(z_{1},\ldots,z_{T}\) be arbitrary vectors and let \(w_{1},\ldots,w_{T}\) and \(\beta_{1},\ldots,\beta_{T}\) be arbitrary numbers in \([0,1]\) such that \(z_{t}\), \(w_{t}\) and \(\beta_{t}\) are independent of \(\zeta_{t},\ldots,\zeta_{T}\). Set:_

\[x_{t} =\frac{\sum_{i=1}^{t}w_{i}z_{i}}{\sum_{i=1}^{t}w_{i}}=x_{t-1} \underbrace{\left(1-\frac{w_{t}}{\sum_{i=1}^{t}w_{i}}\right)}_{\triangleq 1-c_{t}}+ \underbrace{\frac{w_{t}}{\sum_{i=1}^{t}w_{i}}}_{\triangleq c_{t}}z_{t} \tag{9}\] \[y_{t} =\beta_{t}x_{t}+(1-\beta_{t})z_{t}\] (10) \[g_{t} =\nabla f(y_{t},\zeta_{t}). \tag{11}\]

_Then we have for all \(x_{\star}\):_

\[\mathbb{E}[F(x_{T})-F(x_{\star})]\leq\frac{\mathbb{E}[\sum_{t=1}^{T}w_{t} \langle g_{t},z_{t}-x_{\star}\rangle]}{\sum_{i=1}^{T}w_{i}}. \tag{12}\]

Proof.: Throughout this proof, we will use the notation \(w_{1:t}=\sum_{i=1}^{t}w_{i}\). The result is established by showing the following identity:

\[w_{1:t}F(x_{t})-w_{1:t-1}F(x_{t-1})-w_{t}F(x_{\star})\leq w_{t} \langle\nabla F(y_{t}),z_{t}-x_{\star}\rangle. \tag{24}\]

Where here \(\nabla F(y_{t})\) indicates a subgradient of \(F\) at \(y_{t}\) with \(\mathbb{E}[g_{t}|z_{t}]=\nabla F(y_{t})\). Given the identity (24), we sum over all \(t\) from 1 to \(T\). Then the LHS will telescope to obtain:

\[w_{1:T}(F(x_{T})-F(x_{\star}))\leq\sum_{t=1}^{T}w_{t}\langle\nabla F (y_{t}),z_{t}-x_{\star}\rangle,\]

from which the conclusion immediately follows since \(\mathbb{E}[g_{t}|z_{t}]=\nabla F(y_{t})\). So, let us establish (24). To do so, it will help to observe the following identities:

\[w_{t}z_{t} =w_{1:t}x_{t}-w_{1:t-1}x_{t-1}\] \[w_{1:t-1}(x_{t}-x_{t-1}) =w_{t}(z_{t}-x_{t}) \tag{25}\] \[z_{t}-y_{t} =\frac{\beta_{t}}{1-\beta_{t}}(y_{t}-x_{t}). \tag{26}\]

Now, setting \(\nabla F(x_{t})\) to be an arbitrary subgradient of \(F\) at \(x_{t}\), we have:

\[w_{1:t}F(x_{t})-w_{1:t-1}F(x_{t-1})-w_{t}F(x_{\star})\] \[=w_{1:t-1}(F(x_{t})-F(x_{t-1}))+w_{t}(F(x_{t})-F(x_{\star}))\] \[\leq w_{1:t-1}\langle\nabla F(x_{t}),x_{t}-x_{t-1}\rangle+w_{t}(F (x_{t})-F(x_{\star}))\]

using (25):

\[=w_{t}\langle\nabla F(x_{t}),z_{t}-x_{t}\rangle+w_{t}(F(x_{t})-F(x _{\star}))\] \[=w_{t}\langle\nabla F(x_{t}),z_{t}-x_{t}\rangle+w_{t}(F(x_{t})-F (y_{t}))+w_{t}(F(y_{t})-F(x_{\star}))\] \[\leq w_{t}(\nabla F(x_{t}),z_{t}-x_{t}\rangle+w_{t}\langle\nabla F (x_{t}),x_{t}-y_{t}\rangle+w_{t}\langle\nabla F(y_{t}),y_{t}-x_{\star}\rangle\] \[=w_{t}\langle\nabla F(x_{t})-\nabla F(y_{t}),z_{t}-y_{t}\rangle+ w_{t}\langle\nabla F(y_{t}),z_{t}-x_{\star}\rangle\]using (26):

\[=w_{t}\frac{\beta_{t}}{1-\beta_{t}}\langle\nabla F(x_{t})-\nabla F(y_{t}),y_{t}-x _{t}\rangle+w_{t}\langle\nabla F(y_{t}),z_{t}-x_{\star}\rangle\]

Finally, recall that any convex function satisfies \(\langle\nabla F(b)-\nabla F(a),a-b\rangle\leq 0\) for all \(a,b\). This classical fact can be established by adding the following two subgradient identities:

\[F(a)\geq F(b)+\langle\nabla F(b),a-b\rangle,\] \[F(b)\geq F(a)+\langle\nabla F(a),b-a\rangle.\]

Then, since \(\beta_{t}\in[0,1]\), we have \(w_{t}\frac{\beta_{t}}{1-\beta_{t}}\langle\nabla F(x_{t})-\nabla F(y_{t}),y_{t }-x_{t}\rangle\leq 0\), which establishes the desired identity (24). 

## Appendix B Recovering Prior Conversions, and Connections to Momentum

The following recursions provide an equivalent update to our main algorithm that casts the update in a more "momentum-like" form.

**Theorem 4**.: _Under the same assumptions and notation as Theorem 2, set:_

\[\Delta_{t} =z_{t+1}-z_{t},\] \[m_{t} =x_{t+1}-x_{t},\] \[u_{t} =y_{t+1}-y_{t}.\]

_Then:_

\[m_{t} =\frac{w_{t+1}w_{1:t-1}}{w_{t}w_{1:t+1}}m_{t-1}+\frac{w_{t+1}}{w_ {1:t+1}}\Delta_{t}\] \[u_{t} =\left(\beta_{t}+(\beta_{t}-\beta_{t+1})\frac{w_{1:t}}{w_{t+1}} \right)m_{t}+(1-\beta_{t})\Delta_{t}.\]

Here \(u_{t}\) is playing the role of the "update vector", as the sequence of points \(y_{t}\) are where we will be evaluating gradients. The \(\Delta_{t}\) value can be interpreted as a "base update" value: for the case that the \(z_{t}\) sequence is specified by SGD (as in Theorem 1), \(\Delta_{t}=-\eta g_{t}\). Thus, the update can be interpreted as a momentum term \(m_{t}\), plus an extra "push" in the direction of \(\Delta_{t}\) scaled by \(1-\beta_{t}\).

Proof.: Let's solve for \(m_{t}\) in terms of previous values:

\[m_{t} =x_{t+1}-x_{t}\] \[=\frac{w_{t+1}}{w_{1:t+1}}(z_{t+1}-x_{t})\] \[=\frac{w_{t+1}}{w_{1:t+1}}(\Delta_{t}+z_{t}-x_{t})\] \[=\frac{w_{t+1}}{w_{1:t+1}}(\Delta_{t}+\frac{w_{1:t-1}}{w_{t}}(x_{ t}-x_{t-1}))\] \[=\frac{w_{t+1}w_{1:t-1}}{w_{t}w_{1:t+1}}m_{t-1}+\frac{w_{t+1}}{w_ {1:t+1}}\Delta_{t}.\]

Now let's solve for \(u_{t}\):

\[u_{t} =\beta_{t+1}x_{t+1}+(1-\beta_{t+1})z_{t+1}-\beta_{t}x_{t}-(1-\beta _{t})z_{t}\] \[=\beta_{t}m_{t}+(1-\beta_{t})\Delta_{t}+(\beta_{t}-\beta_{t+1})(z _{t+1}-x_{t+1})\] \[=\beta_{t}m_{t}+(1-\beta_{t})\Delta_{t}+(\beta_{t}-\beta_{t+1}) \frac{w_{1:t}}{w_{t+1}}(x_{t+1}-x_{t})\] \[=\beta_{t}m_{t}+(1-\beta_{t})\Delta_{t}+(\beta_{t}-\beta_{t+1}) \frac{w_{1:t}}{w_{t+1}}m_{t}\] \[=\left(\beta_{t}+(\beta_{t}-\beta_{t+1})\frac{w_{1:t}}{w_{t+1}} \right)m_{t}+(1-\beta_{t})\Delta_{t}\]

[MISSING_PAGE_FAIL:17]

_Define the "compressed sum" notation: \(w_{1:t}=\sum_{i=1}^{t}w_{i}\), with \(w_{1:0}=0\). Then we have for all \(x_{\star}\):_

\[\mathbb{E}[F(x_{T})-F(x_{\star})]= \mathbb{E}\left[\frac{\sum_{t=1}^{T}w_{t}\langle g_{t},z_{t}-x_{ \star}\rangle}{w_{1:T}}\right]\] \[\quad-\mathbb{E}\left[\frac{\sum_{t=1}^{T}\frac{w_{t}}{\alpha_{t} }B_{F}(y_{t},x_{t})+\frac{w_{t}(1-\alpha_{t})}{\alpha_{t}}B_{F}(x_{t},y_{t})} {w_{1:T}}\right]\] \[\quad-\mathbb{E}\left[\frac{\sum_{t=1}^{T}w_{1:t-1}B_{F}(x_{t-1}, x_{t})+w_{t}B_{F}(x_{\star},y_{t})}{w_{1:T}}\right].\]

Let's take a minute to unpack this result since it is depressingly complicated. Recall that the Bregman divergence for a convex function must be positive, and so all the subtracted Bregman divergence terms can be dropped to make the bound only looser. This recovers Theorem 2. However, in Section D, we show how to exploit the negative Bregman terms to achieve accelerated rates when \(F\) is smooth, and in Section E we show how to exploit the negative Bregman terms to achieve faster rates when \(F\) is strongly-convex.

Proof.: The proof is nearly the same as that of Theorem 2. The only difference is that we keep track of all the error terms in the inequalities via Bregman divergences.

Throughout this proof, we use \(\nabla F(x)\) to indicate \(\mathbb{E}_{\zeta}[g(x,\zeta)]\). When \(F\) is differentiable, this is simply the ordinary gradient at \(x\). When \(F\) is non-differentiable, this reprents a specific choice of subgradient at \(x\).

Recall that any convex function satisfies \(\langle\nabla F(b)-\nabla F(a),a-b\rangle=-B_{F}(a,b)-B_{F}(b,a)\) for all \(a,b\). This classical fact can be established by adding the following two subgradient identities:

\[F(a)=F(b)+\langle\nabla F(b),a-b\rangle+B_{F}(a,b)\] \[F(b)=F(a)+\langle\nabla F(a),b-a\rangle+B_{F}(b,a)\] \[\langle\nabla F(b)-\nabla F(a),a-b\rangle=-B_{F}(a,b)-B_{F}(b,a). \tag{27}\]

The Theorem is established by showing the following identity:

\[w_{1:t}F(x_{t})-w_{1:t-1}F(x_{t-1})-w_{t}F(x_{\star})= w_{t}\langle\nabla F(y_{t}),z_{t}-x_{\star}\rangle\] \[\quad-\frac{w_{t}}{\alpha_{t}}B_{F}(y_{t},x_{t})-\frac{w_{t}(1- \alpha_{t})}{\alpha_{t}}B_{F}(x_{t},y_{t})\] \[\quad-w_{1:t-1}B_{F}(x_{t-1},x_{t})-w_{t}B_{F}(x_{\star},y_{t}). \tag{28}\]

Given the identity (28), we sum over all \(t\) from 1 to \(T\). Then the LHS will telescope to obtain:

\[w_{1:T}(F(x_{T})-F(x_{\star}))= \sum_{t=1}^{T}w_{t}\langle\nabla F(y_{t}),z_{t}-x_{\star}\rangle\] \[\quad-\sum_{t=1}^{T}\frac{w_{t}}{\alpha_{t}}B_{F}(y_{t},x_{t})- \frac{w_{t}(1-\alpha_{t})}{\alpha_{t}}B_{F}(x_{t},y_{t})\] \[\quad-\sum_{t=1}^{T}w_{1:t-1}B_{F}(x_{t-1},x_{t})-w_{t}B_{F}(x_{ \star},y_{t}),\]

from which the conclusion immediately follows since \(\mathbb{E}[g_{t}|g_{1},\ldots,g_{t-1}]=\mathbb{E}[\nabla F(y_{t})|g_{1},\ldots, g_{t-1}]\). So, let us establish (28). To do so, it will help to observe the following identities:

\[w_{t}z_{t} =w_{1:t}x_{t}-w_{1:t-1}x_{t-1}\] \[w_{1:t-1}(x_{t}-x_{t-1}) =w_{t}(z_{t}-x_{t}) \tag{29}\] \[z_{t}-y_{t} =\frac{1-\alpha_{t}}{\alpha_{t}}(y_{t}-x_{t}). \tag{30}\]So, we have:

\[w_{1:t}F(x_{t})-w_{1:t-1}F(x_{t-1})-w_{t}F(x_{\star})\] \[=w_{1:t-1}(F(x_{t})-F(x_{t-1})+w_{t}(F(x_{t})-F(x_{\star}))\] \[=w_{1:t-1}\langle\nabla F(x_{t}),x_{t}-x_{t-1}\rangle+w_{t}(F(x_{t })-F(x_{\star}))\] \[\qquad-w_{1:t-1}B_{F}(x_{t-1},x_{t})\]

using (29):

\[=w_{t}\langle\nabla F(x_{t}),z_{t}-x_{t}\rangle+w_{t}(F(x_{t})-F(x_ {\star}))-w_{1:t-1}B_{F}(x_{t-1},x_{t})\] \[=w_{t}\langle\nabla F(x_{t}),z_{t}-x_{t}\rangle+w_{t}(F(x_{t})-F( y_{t}))+w_{t}(F(y_{t})-F(x_{\star}))\] \[\qquad-w_{1:t-1}B_{F}(x_{t-1},x_{t})\] \[=w_{t}\langle\nabla F(x_{t}),z_{t}-x_{t}\rangle+w_{t}\langle \nabla F(x_{t}),x_{t}-y_{t}\rangle+w_{t}\langle\nabla F(y_{t}),y_{t}-x_{\star}\rangle\] \[\qquad-w_{1:t-1}B_{F}(x_{t-1},x_{t})-w_{t}B_{F}(y_{t},x_{t})-w_{t }B_{F}(x_{\star},y_{t})\]

using (30):

\[=w_{t}\frac{1-\alpha_{t}}{\alpha_{t}}\langle\nabla F(x_{t})-\nabla F (y_{t}),y_{t}-x_{t}\rangle+w_{t}\langle\nabla F(y_{t}),z_{t}-x_{\star}\rangle\] \[\qquad-w_{1:t-1}B_{F}(x_{t-1},x_{t})-w_{t}B_{F}(y_{t},x_{t})-w_{t }B_{F}(x_{\star},y_{t})\]

using (27):

\[=w_{t} (\nabla F(y_{t}),z_{t}-x_{\star})\] \[\qquad-w_{t}\frac{1-\alpha_{t}}{\alpha_{t}}(B_{F}(x_{t},y_{t})+B_ {F}(y_{t},x_{t}))\] \[\qquad-w_{1:t-1}B_{F}(x_{t-1},x_{t})-w_{t}B_{F}(y_{t},x_{t})-w_{t }B_{F}(x_{\star},y_{t})\] \[=w_{t} (\nabla F(y_{t}),z_{t}-x_{\star})\] \[\qquad-\frac{w_{t}}{\alpha_{t}}B_{F}(y_{t},x_{t})-\frac{w_{t}(1- \alpha_{t})}{\alpha_{t}}B_{F}(x_{t},y_{t})\] \[\qquad-w_{1:t-1}B_{F}(x_{t-1},x_{t})-w_{t}B_{F}(x_{\star},y_{t}).\]

## Appendix D Acceleration

In this section, we show that by instantiating our framework with an _optimistic_ online learning algorithm (Rakhlin and Sridharan, 2013), we achieve accelerated convergence guarantees. Our results match those available in the prior literature (Kavis et al., 2019; Joulani et al., 2020). Our approach is inspired by Joulani et al. (2020),: their method is based upon a version of Theorem 5 for the special case that \(\alpha_{t}=0\). Our result simply extends their analysis to \(\alpha_{t}=O(1/t)\).

First, we establish an important technical Corollary that simplifies Theorem 5 in the case that \(F\) is smooth and \(\alpha_{t}\) is sufficiently small.

**Corollary 1**.: _Under the same conditions as Theorem 5, suppose additionally that \(F\) is \(L\)-smooth and suppose \(\alpha_{t}\leq\frac{w_{t}}{10w_{1:t}}\) for all \(t\). Then we have for all \(x_{\star}\):_

\[\mathbb{E}[F(x_{T})-F(x_{\star})]\leq\mathbb{E}\left[\frac{\sum_{t =1}^{T}w_{t}(g_{t},z_{t}-x_{\star})}{w_{1:T}}\right]\] \[\qquad\qquad\qquad\qquad\qquad-\mathbb{E}\left[\frac{\sum_{t=1}^ {T}w_{1:t-1}\|\nabla F(y_{t})-\nabla F(y_{t-1})\|^{2}}{6Lw_{1:T}}\right],\]

_where above the value of \(y_{0}\) is arbitrary (since the coefficient is \(w_{1:0}=0\))._Proof.: The key thing is to observe that smoothness implies \(B_{F}(a,b)\geq 2L\|\nabla F(a)-\nabla F(b)\|^{2}\). The rest of the argument is straightforward manipulation of the terms in Theorem 5:

\[-\frac{w_{t}}{\alpha_{t}}B_{F}(y_{t},x_{t})-\frac{w_{t}(1-\alpha_{t })}{\alpha_{t}}B_{F}(x_{t},y_{t}) \leq-\frac{w_{t}(2-\alpha_{t})}{2L\alpha_{t}}\|\nabla F(x_{t})- \nabla F(y_{t})\|^{2}\] \[\quad-w_{1:t-1}B_{F}(x_{t-1},x_{t})-w_{t}B_{F}(x_{\star},y_{t}) \leq-\frac{w_{1:t-1}}{2L}\|\nabla F(x_{t})-\nabla F(x_{t-1})\|^{2}.\]

Next, observe that for any vectors \(a,b,c\), for any \(\lambda>0\):

\[-\|a+b+c\|^{2} =-\|a\|^{2}-\|b\|^{2}-\|c\|^{2}-2\langle a,b\rangle-2\langle b,c \rangle-2\langle a,c\rangle\] \[\leq-(1-2/\lambda)\|a\|^{2}+(2\lambda-1)(\|b\|^{2}+\|c\|^{2}),\]

where we have used Young's inequality: \(|\langle v,w\rangle|\leq\frac{\|v\|^{2}}{2\lambda}+\frac{\lambda\|w\|^{2}}{2}\). Therefore, setting \(\lambda_{t}=3\) we obtain:

\[-w_{1:t-1}B_{F}(x_{t-1},x_{t})-w_{t}B_{F}(x_{\star},y_{t})\] \[\leq-\frac{w_{1:t-1}}{6L}\|\nabla F(y_{t})-\nabla F(y_{t-1})\|^{2}\] \[\quad\quad+\frac{5w_{1:t-1}}{2L}(\|\nabla F(x_{t})-\nabla F(y_{t} )\|^{2}+\|\nabla F(x_{t-1})-\nabla F(y_{t-1})\|^{2}).\]

Now, since \(\alpha_{t}\leq\frac{w_{t}}{10w_{1:t}}\leq 1\), we obtain:

\[-\frac{w_{t}}{\alpha_{t}}B_{F}(y_{t},x_{t})-\frac{w_{t}(1-\alpha_{ t})}{\alpha_{t}}B_{F}(x_{t},y_{t})-w_{1:t-1}B_{F}(x_{t-1},x_{t})-w_{t}B_{F}(x_{ \star},y_{t})\] \[\quad\leq-\frac{w_{1:t-1}}{6L}\|\nabla F(y_{t})-\nabla F(y_{t-1}) \|^{2}\] \[\quad\quad-\frac{5w_{1:t}}{2L}\|\nabla F(x_{t})-\nabla F(y_{t})\| ^{2}+-\frac{5w_{1:t-1}}{2L}\|\nabla F(x_{t-1})-\nabla F(y_{t-1})\|^{2}.\]

Now summing over \(t\) from 1 to \(T\) (and dropping one negative term), the sum telescopes to:

\[\sum_{t=1}^{T}-\frac{w_{1:t-1}}{6L}\|\nabla F(y_{t})-\nabla F(y_{t-1})\|^{2}.\]

The result now follows from Theorem 5. 

Now, we consider the case that \(z_{t}\) is given by an optimistic mirror descent algorithm:

**Corollary 2**.: _Suppose \(F\) is \(L\)-smooth. Define \(g_{0}=0\) and suppose also that for some \(D\) satisfying \(D\geq\|y_{1}-x_{\star}\|\):_

\[\sum_{t=1}^{T}w_{t}\langle g_{t},z_{t}-x_{\star}\rangle\leq D\sqrt{\sum_{t=1}^ {T}w_{t}^{2}\|g_{t}-g_{t-1}\|^{2}}.\]

_Finally, suppose \(\mathbb{E}[\|g_{t}-g_{t-1}\|^{2}]\leq\|\nabla F(y_{t})-\nabla F(y_{t-1})\|^{2} +\sigma_{t}^{2}\) for some constants \(\sigma_{1},\ldots,\sigma_{T}\) (these are just variance bounds on the stochastic gradient oracle). Then with \(w_{t}=t\) and \(\alpha_{t}\leq\frac{1}{5(t-1)}\), we have:_

\[\mathbb{E}[F(x_{T})-F(x_{\star})] \leq\frac{14D^{2}L}{T(T+1)}+\frac{2D\sqrt{\sum_{t=1}^{T}t^{2} \sigma_{t}^{2}}}{T(T+1)}\] \[=O\left(\frac{D^{2}L}{T^{2}}+\frac{D\sigma}{\sqrt{T}}\right),\]

_where \(\sigma\) is uniform upper-bound on \(\sigma_{t}\). Note that the algorithm does not need to know \(L\) or \(\sigma\)._

Algorithms producing \(z\) sequences obtaining the guarantee stated here are called "optimistic online learning algorithms".

Proof.: Applying Corollary 1, we obtain immediately:

\[\frac{T(T+1)}{2}\mathbb{E}[F(x_{T})-F(x_{\star})]\] \[\leq\mathbb{E}\left[D\sqrt{\sum_{t=1}^{T}t^{2}\|g_{t}-g_{t-1}\|^{2 }}-\sum_{t=1}^{T}\frac{(t-1)t}{12L}\|\nabla F(y_{t})-\nabla F(y_{t-1})\|^{2}\right]\] \[\leq D\sqrt{\sum_{t=1}^{T}t^{2}\mathbb{E}\left[\|\nabla F(y_{t})- \nabla F(y_{t-1})\|^{2}\right]+t^{2}\sigma_{t}^{2}}+\frac{\|\nabla F(y_{1})\|^{ 2}}{24L}\] \[\qquad-\frac{1}{24L}\sum_{t=1}^{T}t^{2}\mathbb{E}\left[\|\nabla F (y_{t})-\nabla F(y_{t-1})\|^{2}\right]\] \[\leq D\sqrt{\sum_{t=1}^{T}t^{2}\mathbb{E}\left[\|\nabla F(y_{t})- \nabla F(y_{t-1})\|^{2}\right]}+D\sqrt{\sum_{t=1}^{T}t^{2}\sigma_{t}^{2}}+\frac {\|\nabla F(y_{1})\|^{2}}{24L}\] \[\qquad-\frac{1}{24L}\sum_{t=1}^{T}t^{2}\mathbb{E}\left[\|\nabla F (y_{t})-\nabla F(y_{t-1})\|^{2}\right]\]

Using the identity \(A\sqrt{C}-BC\leq\frac{A^{2}}{4B}\):

\[\leq 6D^{2}L+\frac{L\|y_{1}-x_{\star}\|^{2}}{24}+D\sqrt{\sum_{t=1}^ {T}t^{2}\sigma_{t}^{2}}\] \[\leq 7D^{2}L+D\sqrt{\sum_{t=1}^{T}t^{2}\sigma_{t}^{2}}.\]

Divide by \(\frac{T(T+1)}{2}\) to conclude the result. 

### An Optimistic Regret Bound

In this section we provide an algorithm that achieves the optimistic regret bound required for our acceleration result Corollary 2. This algorithm is a mild variation on the established literature (Rakhlin and Sridharan, 2013; Chiang et al., 2012; Hazan and Kale, 2010; Joulani et al., 2017) to slightly improve a technical dependence on the maximum gradient value.

**Lemma 1**.: _For a sequence of vectors \(g_{1},\ldots,g_{T}\), set \(\eta_{t}=\frac{D}{\sqrt{2\sum_{t=1}^{T}\|g_{t}-g_{t-1}\|^{2}}}\) with \(g_{0}=0\), define \(m_{t}=\max_{i\leq t}\|g_{i}-g_{i-1}\|\) and define the sequence of vectors \(z_{t},z_{t}^{\prime}\) and \(\tilde{g}_{t}\) by the recursions:_

\[z_{1} =z_{1}^{\prime}=0\] \[\tilde{g}_{t} =g_{t-1}+\min\left(m_{t-1},\|g_{t}-g_{t-1}\|\right)\frac{g_{t}-g_{ t-1}}{\|g_{t}-g_{t-1}\|}\] \[\eta_{t} =\frac{D}{\sqrt{m_{t}^{2}+\sum_{i=1}^{t}\|\tilde{g}_{i}-g_{i-1}\| ^{2}}}\] \[z_{t+1}^{\prime} =\Pi_{\|z_{t+1}^{\prime}\|\leq D}z_{t}^{\prime}-\eta_{t}\tilde{g }_{t}\] \[z_{t+1} =\Pi_{\|z_{t+1}\|\leq D}z_{t+1}^{\prime}-\eta_{t}g_{t}.\]

_Then:_

\[\sum_{t=1}^{T}\langle g_{t},z_{t}-x_{\star}\rangle\leq 7D\sqrt{2\sum_{t=1}^ {T}\|g_{t}-g_{t-1}\|^{2}}.\]

[MISSING_PAGE_EMPTY:22]

So, we have:

\[\sum_{t=1}^{T}\langle g_{t},z_{t}-x_{\star}\rangle \leq 2Dm_{T}+\frac{\|z_{1}^{\prime}-x_{\star}\|^{2}}{2\eta_{1}}+\sum _{t=2}^{T}\frac{\|z_{t}^{\prime}-x_{\star}\|^{2}}{2}\left(\frac{1}{\eta_{t}}- \frac{1}{\eta_{t-1}}\right)\] \[+\sum_{t=1}^{T}\frac{\eta_{t-1}\|\tilde{g}_{t}-g_{t-1}\|^{2}}{2}\] \[\leq 2Dm_{T}+4D^{2}/\eta_{T}+\sum_{t=1}^{T}\frac{\eta_{t-1}\| \tilde{g}_{t}-g_{t-1}\|^{2}}{2}\] \[\leq 6D^{2}/\eta_{T}+\sum_{t=1}^{T}\frac{\eta_{t-1}\|\tilde{g}_{t }-g_{t-1}\|^{2}}{2}\] \[\leq 6D^{2}/\eta_{T}+\sum_{t=1}^{T}\frac{D\|\tilde{g}_{t}-g_{t-1} \|^{2}}{2\sqrt{\sum_{t=1}^{t}\|\tilde{g}_{t}-g_{t-1}\|^{2}}}\] \[\leq 6D^{2}/\eta_{T}+D\sqrt{\sum_{t=1}^{T}\|\tilde{g}_{t}-g_{t-1} \|^{2}}\] \[\leq 7D\sqrt{2\sum_{t=1}^{T}\|g_{t}-g_{t-1}\|^{2}}.\]

## Appendix E Strongly Convex Losses

Suppose that the expected loss \(F\) is actually known to be \(\mu\)-strongly convex. Then we'd like to have a convergence guarantee of \(O(1/\mu T)\). This is achieved in Theorem 6 below.

**Theorem 6**.: _Under the same assumptions as Theorem 5, define \(\ell_{t}(z)=\langle g_{t},z\rangle+\frac{\mu}{2}\|y_{t}-z\|^{2}\). Define the "regret" of the sequence \(z_{t}\) as:_

\[\text{Regret}_{\ell}(x_{\star})=\sum_{t=1}^{T}w_{t}(\ell_{t}(z_{t})-\ell_{t}(x _{\star})).\]

_Then we have for \(x_{\star}=\text{argmin }F\):_

\[\mathbb{E}[F(x_{T})-F(x_{\star})]\leq\mathbb{E}\left[\frac{\text{ Regret}_{\ell}(x_{\star})-\sum_{t=1}^{T}\frac{w_{t}\mu}{2}\|z_{t}-y_{t}\|^{2}}{w_{1 :T}}\right].\]

_In particular, suppose \(\|x_{\star}\|\leq D\) for some known bound \(D\) and \(\|g_{t}\|\leq G\) for all \(t\) for some \(G\) so long as \(\|y_{t}\|\leq D\). Then if we define \(w_{t}=t\) for all \(t\) and set \(z_{t}\) by:_

\[z_{t+1}=\Pi_{\|z\|\leq D}\left[z_{t}-\frac{2(g_{t}+\mu(z_{t}-y_{t}))}{\mu(t+1)} \right].\]

_then we have:_

\[\mathbb{E}[F(x_{T})-F(x_{\star})]\leq\frac{2(G+2\mu D)^{2}}{\mu(T+1)}.\]

Proof.: From Theorem 5, we have:

\[\mathbb{E}[F(x_{T})-F(x_{\star})]\leq\mathbb{E}\left[\frac{\sum_{t=1}^{T}w_{t} \langle g_{t},z_{t}-x_{\star}\rangle}{w_{1:T}}-\frac{\sum_{t=1}^{T}w_{t}B_{F}( x_{\star},y_{t})}{w_{1:T}}\right].\]

[MISSING_PAGE_EMPTY:24]

Recall from D-Adaptation (Defazio and Mishchenko, 2023) theory that:

\[\sum_{t=1}^{T}\gamma\left\langle g_{t},z_{t}-z_{1}\right\rangle=\frac{1}{2}\sum_{ t=1}^{T}\gamma^{2}\left\|g_{t}\right\|^{2}-\frac{1}{2}\left\|s_{t+1}\right\|^{2} \tag{33}\]

and:

\[\sum_{t=1}^{T}\gamma\left\langle g_{t},z_{t}-z_{*}\right\rangle\leq\left\|s_{T +1}\right\|D+\sum_{t=1}^{T}\gamma\left\langle g_{t},z_{t}-z_{1}\right\rangle. \tag{34}\]

Now suppose that the regret at time T is negative. Then trivially the theorem holds:

\[\frac{1}{T}\sum_{t=1}^{T}\left\langle g_{t},z_{t}-z_{*}\right\rangle\leq 0= \mathcal{O}\left(\frac{D}{T}\sqrt{\sum_{t=1}^{T}\left\|g_{t}\right\|^{2}} \right),\]

therefore, without loss of generality we may assume that \(\sum_{t=1}^{T}\gamma\left\langle g_{t},z_{t}-z_{*}\right\rangle\geq 0\). Then from combining Equation 34 with Equation 33 we have:

\[0\leq-\frac{1}{2}\left\|s_{T+1}\right\|^{2}+\left\|s_{T+1}\right\|D+\frac{1}{ 2}\sum_{t=1}^{T}\gamma^{2}\left\|g_{t}\right\|^{2}.\]

This is a quadratic equation in \(\left\|s_{T+1}\right\|\) which we can solve explicitly via the quadratic formula, taking the largest root:

\[\left\|s_{T+1}\right\|\leq\frac{-b\pm\sqrt{b^{2}-4ac}}{2a}.\]

Plugging in the values \(a=-\frac{1}{2}\), \(b=D\), \(c=\frac{1}{2}\sum_{t=1}^{T}\gamma^{2}\left\|g_{t}\right\|^{2}\):

\[D\pm\sqrt{D^{2}+\sum_{t=1}^{T}\gamma^{2}\left\|g_{t}\right\|^{2}}\leq 2D+\sqrt{ \sum_{t=1}^{T}\gamma^{2}\left\|g_{t}\right\|^{2}}.\]

Therefore:

\[\left\|s_{T+1}\right\|\leq 2D+\gamma\sqrt{\sum_{t=1}^{T}\left\|g_{t}\right\|^{ 2}}.\]

Substituting this into Equation 34:

\[\sum_{t=1}^{T}\gamma\left\langle g_{t},z_{t}-z_{*}\right\rangle\leq 2D^{2}+ \gamma D\sqrt{\sum_{t=1}^{T}\left\|g_{t}\right\|^{2}}+\sum_{t=1}^{T}\gamma \left\langle g_{t},z_{t}-z_{1}\right\rangle.\]

Therefore, if \(\sum_{t=1}^{T}\left\langle g_{t},z_{t}-z_{1}\right\rangle\leq D\sqrt{\sum_{t=1 }^{T}\left\|g_{t}\right\|^{2}}\) then:

\[\sum_{t=1}^{T}\gamma\left\langle g_{t},z_{t}-z_{*}\right\rangle\leq 2D^{2}+2 \gamma D\sqrt{\sum_{t=1}^{T}\left\|g_{t}\right\|^{2}}.\]

Plugging in \(\gamma=D/G\):

\[\sum_{t=1}^{T}\left\langle g_{t},z_{t}-z_{*}\right\rangle \leq 2DG+2D\sqrt{\sum_{t=1}^{T}\left\|g_{t}\right\|^{2}}\] \[\leq 4D\sqrt{\sum_{t=1}^{T}\left\|g_{t}\right\|^{2}},\]

and the theorem follows.

Experimental Setup

### Convex experiments

Each dataset is obtained from the LIBSVM repository and used without modifications.

### Cifar-10

We used custom training code based on the PyTorch tutorial code for this problem. Following standard data-augmentation practises, we applyed random horizontal flips and random offset cropping down to 32x32, using reflection padding of 4 pixels. Input pixel data was normalized by centering around 0.5.

### Cifar-100

We used the same codebase as for our CIFAR-10 experiments, with the same data augmentation.

We normalized each input image using fixed mean and standard error values derived from pre-processing the data.

### Svhn

We used the same codebase as for our CIFAR experiments, and following the same data preprocessing.

\begin{tabular}{|c|c|} \hline
**Hyper-parameter** & **Value** \\ \hline GPUs & 1\(\times\)V100 \\ \hline Batch size & 16 \\ \hline Epochs & 100 \\ \hline Seeds & 10 \\ \hline Schedule-Free \(\beta_{1}\) & 0.9 \\ \hline \end{tabular} 
\begin{tabular}{|c|c|} \hline
**Hyper-parameter** & **Value** \\ \hline Decay & 0.0 \\ \hline Optimizer & Adam \\ \hline Baseline \(\beta_{1}\) & 0.9 \\ \hline \(\beta_{2}\) & 0.95 \\ \hline \end{tabular}

### Cifar-10

We used custom training code based on the PyTorch tutorial code for this problem. Following standard data-augmentation practises, we applyed random horizontal flips and random offset cropping down to 32x32, using reflection padding of 4 pixels. Input pixel data was normalized by centering around 0.5.

### Cifar-100

We used the same codebase as for our CIFAR-10 experiments, with the same data augmentation.

We normalized each input image using fixed mean and standard error values derived from pre-processing the data.

### Cifar-100

We used the same codebase as for our CIFAR-10 experiments, with the same data augmentation.

We normalized each input image using fixed mean and standard error values derived from pre-processing the data.

### Cifar-100

We used the same codebase as for our CIFAR-10 experiments, with the same data augmentation.

### Cifar-100

We used the same codebase as for our CIFAR-10 experiments, and following the same data preprocessing.

### ImageNet

We used the same code-base as for our CIFAR-10 experiments, and applied the same preprocessing procedure. The data-augmentations consisted of PyTorch's RandomResizedCrop, cropping to 224x224 followed by random horizontal flips. Test images used a fixed resize to 256x256 followed by a center crop to 224x224.

\begin{tabular}{|c|c|} \hline
**Hyper-parameter** & **Value** \\ \hline Architecture & ResNet50 \\ \hline Epochs & 100 \\ \hline GPUs & 8\(\times\)V100 \\ \hline Batch size per GPU & 32 \\ \hline Schedule-Free Decay & 0.00005 \\ \hline Baseline Stepwise LR & 0.1 \\ \hline Baseline Cosine LR & 0.05 \\ \hline \end{tabular}

### IWSLT14

We used the FairSeq framework 3 for our experiments. Rather than a vanilla LSTM we use the variant from Wiseman and Rush (2016) provided in the FairSeq codebase.

Footnote 3: [https://github.com/facebookresearch/fairseq](https://github.com/facebookresearch/fairseq)

\begin{tabular}{|c|c|} \hline
**Hyper-parameter** & **Value** \\ \hline Architecture & 1stm\_wiseman\_iwslt\_de\_en \\ \hline Max Epoch & 55 \\ \hline GPUs & 1\(\times\)V100 \\ \hline Tokens per batch & 4096 \\ \hline Warmup steps & 4000 \\ \hline Dropout & 0.3 \\ \hline Label smoothing & 0.1 \\ \hline Schedule-Free LR & 0.02 \\ \hline Schedule-Free warmup & 5\% \\ \hline Baseline schedule & Linear Decay \\ \hline \end{tabular}

Footnote 4: [https://github.com/karpathy/nanoGPT](https://github.com/karpathy/nanoGPT)

### NanoGPT

We followed the NanoGPT codebase 5 as closely as possible, matching the default batch-size, training length and schedule. Our runs replicate the stated 2.85 loss in the documentation. Disabling gradient norm clipping is crucial for the Schedule-Free runs.

\begin{tabular}{|c|c|} \hline
**Hyper-parameter** & **Value** \\ \hline Architecture & transformer\_lm\_gpt \\ \hline Batch size per gpu & 12 \\ \hline Max Iters & 600,000 \\ \hline GPUs & 40\(\times\)V100 \\ \hline Tokens per sample & 512 \\ \hline Dropout & 0.0 \\ \hline Baseline LR & 0.0005 \\ \hline Warmup & 2,000 \\ \hline Schedule-Free LR & 0.005 \\ \hline Schedule-Free \(\beta\) & 0.98 \\ \hline Schedule-Free decay & 0.05 \\ \hline \end{tabular}

Footnote 5: [https://github.com/karpathy/nanoGPT](https://github.com/karpathy/nanoGPT)

\begin{tabular}{|c|c|} \hline
**Hyper-parameter** & **Value** \\ \hline Block Size & 1024 \\ \hline Num layer & 12 \\ \hline Num head & 12 \\ \hline Num embd & 768 \\ \hline Float16 & True \\ \hline Update Frequency & 16 \\ \hline Seeds & 5 \\ \hline Decay & 0.1 \\ \hline Baseline \(\beta_{1},\beta_{2}\) & 0.9, 0.95 \\ \hline Gradient Clipping & 0.0 \\ \hline \end{tabular}

### Mae

Our implementation uses the offical code5, with hyper-parameters following examples given in the repository.

Footnote 5: [https://github.com/fairinternal/mae](https://github.com/fairinternal/mae)

### Dlrm

We used a custom implementation of the DLRM model based on the publicly available code. Our optimizer uses dense gradients for implementation simplicity, although sparse-gradients using AdaGrad is a more common baseline on this problem, we consider AdaGrad variants of our scheduling approach as future work.

### Mri

We used the version of the the fastMRI code base at [https://github.com/facebookresearch/fastMRI/tree/main/banding_removal](https://github.com/facebookresearch/fastMRI/tree/main/banding_removal). Note that we found that training failed using PyTorch 2 or newer, and so we ran these experiments using PyTorch 1.9.

### Algoperf

Our full algoperf entry is availiable at [https://github.com/facebookresearch/schedule_free/tree/main/schedulefree/algoperf](https://github.com/facebookresearch/schedule_free/tree/main/schedulefree/algoperf). The hyper-parameters used for the self-tuning track submission are listed below.

\begin{tabular}{|c|c|} \hline
**Hyper-parameter** & **Value** \\ \hline Learning Rate & 0.0025 \\ \hline one-minus Beta1 & 0.1 \\ \hline Beta2 (default) & 0.9955159689799007 \\ \hline Weight Decay (default) & 0.08121616522670176 \\ \hline \end{tabular}

\begin{tabular}{|c|c|} \hline
**Hyper-parameter** & **Value** \\ \hline Dropout Rate & 0.1 \\ \hline Warmup Percentage & 2\% \\ \hline Label Smoothing & 0.2 \\ \hline Polynomial in \(c_{t}\) average & 0.75 \\ \hline \end{tabular}

[MISSING_PAGE_EMPTY:30]

Polyak and Primal Averaging Runs

These experiments follow the same tuning setup as Figure 3, where the learning rate and momentum is tuned separately for each method. In each case the \(c\) weighting sequence used for Schedule-Free training is also used to ensure a fair comparison. The Polyak averaging runs include momentum in the base optimizer as we found this gave the best results. We ran the NanoGPT experiment for a shorter 200,000 steps due to computational budget considerations. The NanoGPT Polyak averaging runs show a divergence in test loss for Polyak averaging.

Figure 8: Polyak and Primal Averaging Experiments

[MISSING_PAGE_EMPTY:32]

### NeurIPS Paper Checklist

1. **Claims** Question: Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope? Answer: [Yes] Justification: Our paper contains new theory as well as extensive experimental results for our method.
2. **Limitations** Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] Justification: We detail the limitations of our method in the conclusion section.
3. **Theory Assumptions and Proofs** Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? Answer: [Yes] Justification: All theorems stated in the paper are proven in the Appendix.
4. **Experimental Result Reproducibility** Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? Answer: [Yes] Justification: Detailed results concerning the experimental setup are provided in the appendix.
5. **Open access to data and code** Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? Answer: [Yes] Justification: We have already open sourced our method. Experiments can be replicated using our open source PyTorch optimizer implementation together with existing open source code bases implementing each method.
6. **Experimental Setting/Details** Question: Does the paper specify all the training and test details (e.g., data splits, hyper-parameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? Answer: [Yes] Justification: To the best of our knowledge, we provide sufficient information about hyper-parameter settings for all experiments to be reproducible.
7. **Experiment Statistical Significance** Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? Answer: [Yes] Justification: All experiments reported use multiple seeds, and error bars are included in all plots.
8. **Experiments Compute Resources** Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments?Answer: [No] Justification: As our method has no runtime overhead compared to existing approaches, we do not report computation times.
9. **Code Of Ethics** Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics [https://neurips.cc/public/EthicsGuidelines?](https://neurips.cc/public/EthicsGuidelines?) Answer: [Yes] Justification: We have abided by the code of ethics.
10. **Broader Impacts** Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? Answer: [NA]. Justification: There is no foreseeable societal impact from our work.
11. **Safeguards** Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? Answer: [NA] Justification: Not Applicable
12. **Licenses for existing assets** Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? Answer: [No] Justification: We do not distribute any models or datasets with this work. Datasets used for evaluation have license information available at the cited source.
13. **New Assets** Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? Answer: [NA]. Justification: No new assets are being released.
14. **Crowdsourcing and Research with Human Subjects** Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? Answer: [NA]. Justification: Not Applicable
15. **Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects** Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? Answer: [NA]. Justification: Not Applicable